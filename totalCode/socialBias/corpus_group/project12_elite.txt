  We don't want to take this for a couple reasons:
1. It's nonstandard. With our events we've been sticking to the DOM standards more or less, with the notable exception of our onChange handling (and some differences in bubbling, which I tend to regret overall).
2. Apple, who designed touch events, intentionally chose to not provide this information on every move event to avoid needing to perform the hit test on every event while dragging. This is both on iOS natively and on web.

It shouldn't be hard to call elementFromPoint in user land if you want this info. Also, you might be interested in the keyboard I wrote in math facts which lets you press down then drag around (written for RN but could be adapted for web).
  ## React.PureComponent

This provides an easy way to indicate that components should only rerender when given new props, like PureRenderMixin. If you rely on mutation in your React components, you can continue to use `React.Component`.

Inheriting from `React.PureComponent` indicates to React that your component doesn't need to rerender when the props are unchanged. We'll compare the old and new props before each render and short-circuit if they're unchanged. It's like an automatic shouldComponentUpdate, but it also affects the behavior of functional children that are rendered:
## Functional components

We've heard clearly that most React users intend for their functional components to be pure and to produce different output only if the component's props have changed (https://mobile.twitter.com/reactjs/status/736412808372314114). However, a significant fraction of users still rely on mutation in their apps; when used with mutation, comparing props on each render could lead to components not updating even when the data is changed.

Therefore, we're changing functional components to behave as pure when they're used inside a React.PureComponent but to rerender unconditionally when contained in a React.Component:

``` js
class Post extends React.PureComponent {  // or React.Component
  render() {
    return (
      <div className="post">
        <PostHeader model={this.props.model} />
        <PostBody model={this.props.model} />
      </div>
    );
  }
}

function PostHeader(props) {
  // ...
}

function PostBody(props) {
  // ...
}
```

In this example, the functional components PostHeader and PostBody will be treated as pure because they're rendered by a pure parent component (Post). If our app used mutable models instead, Post should extend React.Component, which would cause PostHeader and PostBody to rerender whenever Post does, even if the model object is the same.

We anticipate that this behavior will work well in real-world apps: if you use immutable data, your class-based components can extend React.PureComponent and your functional components will be pure too; if you use mutable data, your class-based components will extend React.Component and your functional components will update accordingly.

In the future, we might adjust these heuristics to improve performance. For example, we might do runtime detection of components like

``` js
function FancyButton(props) {
  return <Button style="fancy" text={props.text} />;
}
```

and optimize them to "inline" the child Button component and call it immediately, so that React doesn't need to store the props for Button nor allocate a backing instance for it -- causing less work to be performed and reducing GC pressure.
 > for an app that consists entirely of functional components to opt in to pure functional components the root component needs to be a class component (which extends PureComponent), it can't be a functional component itself, right?

This is correct.

> presumably every library that renders user-provided components ‚Äî eg. react-router, react-redux, etc. ‚Äî will need to provide two versions of whatever internal component renders the user provided components, one that extends PureComponent and one which extends Component so that library users can be offered the choice of having their functional components further down the tree be pure or not. I guess this is not really a question, more of a realisation that it looks like this will end up being an option in the api of a majority of libraries once this gets released.

In some cases, but not necessarily. This is not much different from today: libraries have to take a stance on where they are on the mutability spectrum. For example React Redux _already_ has pure class containers, so it will switch to `PureComponent`. (But it already provides `pure: false` opt-out, so I guess we‚Äôll have to keep offering that options.)

As for other libraries, it‚Äôs no different then the situation today. If you don‚Äôt want to force your users to be immutable, you can just export a regular class. If the consumer wants optimizations, they can _wrap_ the children into _their_ pure container:

``` js
<Router> // not optimized
  <MyApp> // my own, optimized! 
    <Header /> // functional, optimized thanks to MyApp
```

So I think 

> It seems that you would have to expose one non-pure and one pure of every third-party component

is unnecessary overkill, and doesn‚Äôt need to happen. If you‚Äôre not sure your users are immutable, just provide `Component`. It‚Äôs no different from choosing whether to provide `shouldComponentUpdate()` today‚Äî**it‚Äôs exactly the same decision third party component have been doing for a long time**.

I expect that most libraries will provide just `Component`s, and if you _want to_ opt into the optimizations, you just wrap _your_ components in a `PureComponent`.

The optimizations kick in if **the closest class parent is a `PureComponent`** so, e.g. in case of React Router, you‚Äôd only need to make your `App` top-level handler a `PureComponent`, for the rest of the app to work.

In any case, there should be no goal of ‚Äúmaking every component pure‚Äù. It‚Äôs just an optimization that would cover many cases, and generally benefit apps that use immutability. You shouldn‚Äôt be chasing that optimization with every component in your app‚ÄîReact reserves the right to not enable it in some cases anyway.
 @glenjamin If this worked before, it only worked because some component above it caused it to re-render by `setState` or `forceUpdate`. Since this function wouldn‚Äôt have `PureComponent`s above it, the existing pattern wouldn‚Äôt break, so I don‚Äôt see why this is breaking compatibility.
 To clarify again: this change doesn‚Äôt make _all_ functional components pure. You still have to opt in by making _their closest class parent_ a `PureComponent`. At this point we know that all children would be effectively pure anyway, because if the parent didn‚Äôt rerender, they wouldn‚Äôt either. This is why it‚Äôs safe to make them as pure in this situation.
 > if you treat props as immutable in some places of your app, you probably need to do that everywhere or you'll end up incredibly confused as to which components assume immutability and which don't. in that case why not make every component in the app pure?

Sure, but that wouldn‚Äôt work for people already using mutation (e.g. some implementations of Flux, some perf optimizations, making React work inside existing apps with Backbone, etc). So we want to keep that use case.

> Adding an automatic shouldComponentUpdate would stop them updating when the parent re-renders. Inlining them into the parent would be equivalent to having the component always update.

I‚Äôm not sure I follow your point. There is no inlining in this PR (at least, not yet). I thought you were saying that adding this heuristic can potentially break functional components that use something like `Date` inside them. Can you show a bigger example demonstrating how they would break?
 > With this we also have to be aware that changing a parent might cascade pure render checks down.

How would that be noticeable? If you made the parent pure _you already effectively short-circuited it_. What happens below is just an additional optimization that React can make now; it doesn‚Äôt affect your behavior. Can you show an example demonstrating why this could be a problem?
 I think some confusion comes from us giving another meaning to ‚Äúpure‚Äù when we say ‚Äúcomponent‚Äù.

React _never allowed_ `render` function to be impure. That is, components already _have to_ have pure `render` function [per the documentation](https://facebook.github.io/react/docs/component-specs.html):

> **The render() function should be pure**, meaning that it does not modify component state, it **returns the same result each time it's invoked**, and it does not read from or write to the DOM or otherwise interact with the browser (e.g., by using setTimeout). If you need to interact with the browser, perform your work in componentDidMount() or the other lifecycle methods instead. Keeping render() pure makes server rendering more practical and makes components easier to think about.

So functions that use something like `Date().now` are not officially allowed anyway, and won‚Äôt even work unless by some coincidence a parent component redraws often enough.

In the context of this discussion, ‚Äúpure component‚Äù means that **not only it is a pure function (which it already must be anyway), but it also doesn‚Äôt rely on any deep mutations in the props**. In other words, it means that **the props are immutable** rather than the function is pure. And whether the props are immutable or not, depends on the caller, and not on the component itself.

Sorry about the confusion.
 (Of course React allows impure `render` functions in the sense that you can call `forceUpdate()` to force-render them. This doesn‚Äôt go away. You can also `setState({})` to force re-rendering. In this case, the implementation proposed in PR would also disable the optimization.)
 > you can easily create/break chains when refactoring components along the hierarchy no? That all feels like a bit of hard to track down magic that could case subtle bugs.

The idea is you shouldn‚Äôt have to think about it at all. This heuristic is intended to be an optimization React makes on its own; not something you need to be aware of. Because it doesn‚Äôt break the existing scenarios (does it?) it is effectively safe to add, so it‚Äôs a nice-to-have feature that you shouldn‚Äôt have to think about it.

> Not to mention the issues around context propagating through pure components

It‚Äôs not any different than components with `shouldComponentUpdate`. Either implementing `shouldComponentUpdate` or inheriting `PureComponent` is an opt-in decision. Once you do so, **you already break the context updates** for all the children. So adding `PureComponent` and the optimizations related to it doesn‚Äôt make the situation any worse than it already is.
 > could case subtle bugs.

Could you please provide a specific example that demonstrates how it causes a bug? It would need to show that adding `PureContainer` with the functional component optimization is more dangerous than adding `shouldComponentUpdate` (without functional optimization) in the same place.

Otherwise this discussion goes into a very theoretical tangent üòÑ .
 > Won't this break components that deal with mutable data internally?

I have an answer for this:

> Could you please provide a specific example that demonstrates how it causes a bug?

üòÑ 

We‚Äôre getting too abstract and might mean some different things; code will help.

> Even more so considering your example, ReactRouter must not mark itself as pure or my entire app must then be pure?

Not entire app, just the descendants between React Router and next impure class. React Router marking itself as pure would have the same effect as React Router implementing a strict `shouldComponentUpdate`. To cause re-renders below, you‚Äôd have to use `setState()` or `forceUpdate()`. But these work with the new model as well!
 Functional components can‚Äôt `setState()` or `forceUpdate()`, right? So if functional component is _inside_ a class component with strict `shouldComponentUpdate()` we _know_ it won‚Äôt get re-rendered unless that parent also gets re-rendered. This is why we apply the heuristic here (and use `PureComponent` as a flag because we don‚Äôt know what‚Äôs in your `shouldComponentUpdate()`): functional component‚Äôs closest class parent is known to be pure.

If we introduce an impure class component between them, this will no longer be true. Maybe it calls `setState({})` every second, and this causes functional component to update. This is why we don‚Äôt apply the heuristic here: functional component‚Äôs closest class parent is impure, so we don‚Äôt risk.
 @syranide I‚Äôm not sure, why would it? The automatic optimization is only enabled for functional components, and this component is an (impure) class.
 I think this proposal is not just about direct parents. It is about ‚Äúthe closest class parent‚Äù.
 > That said, here's a contrived example that works currently but would break if PureComponent was used instead of using shallowCompare on the parent class

I'm unclear how this would behave differently with this PR. Can you explain?

> ```
>  return function RenderCounter() {
>    return <span>Rendered {++n} time(s)</span>;
>  }
> ```

This is an impure render function, which, [as @gaearon notes above](https://github.com/facebook/react/pull/6914#issuecomment-222363687), has never been supported by React in any kind of component (functional, class, createClass, or factory). Will this example still show behavior difference with pure render functions?
  React 15 removed the use of spans around text nodes so that should go away if you upgrade. We won't be back porting the change to 14. in the mean time you could use rows and cells to make it so the spans are ok to use.
  @lexjacobs updated the pull request.
  We are in active discussions about how to handle binding.  I think the general consensus at the moment is to drift toward using property initializers with lambda functions.  But property standards aren't an officially approved standard yet, so we haven't officially recommended them.

Anyway, we're thinking about it.  But we probably won't add a parallel `own` prop for every `on` prop, so I'm going to close out this issue.
 I just wanted to chime in saying I‚Äôd like to see us provide a _good_ explanation of why we can‚Äôt do this, in this issue. It is not very obvious to a lot of people, and we don‚Äôt have a place where we‚Äôd write up all the possible APIs, and reasons why they aren‚Äôt working for us. So I‚Äôll keep it open, and if nobody gets a chance to reply, I‚Äôll come back to this and do a writeup.
 The render method does have a reference to the containing instance. That's `this`. But you're then passing that function off when you create elements. I guess theoretically it would be possible for React to track the reference to the instance when we call `render` internally and then when we call the event handler, do it with a `handler.call(trackedInstance, event)`. This would be an on demand binding so you don't pay the cost all the time.

My main concern with an approach like that it's inconsistent with how the rest of JS works and how the rest of the use of your methods would work.

Maybe `<button onClick={this.handleClick />` works. But in some other function you have `setTimeout(this.otherMethod)`. If we make the former work, the expectation would likely be that the latter works. However it wouldn't as we've cheated and just made `render` special. The latter works with `createClass` because we bind on creation so everything is pre-bound before you reference (which is also why the bind in c'tor approach is popular).
 > I guess theoretically it would be possible for React to track the reference to the instance when we call render internally and then when we call the event handler, do it with a handler.call(trackedInstance, event). This would be an on demand binding so you don't pay the cost all the time.

I don‚Äôt think even that would work correctly. Consider:

``` js
class Button extends Component {
  render() {
    return <div onClick={this.props.onClick}Click me</div>
  }
}

class MyButton extends Component {
  handleClick() {
    console.log(this)
  }

  render() {
    return <Button onClick={this.handleClick} />
  }
}
```

The event handler was in the element created inside `render` of `Button`. However I think everybody would be very surprised if `MyButton#handleClick` got a `Button` instance as `this` because that‚Äôs what was being rendered.
 If we were magically treating `this.*` inside `onClick` value with a Babel plugin, it would also cause weird issues.

Even if this:

``` js
<div onClick={this.handleClick}>
```

did the autobinding to `this` in scope, we wouldn‚Äôt be able to do this for

``` js
const { handleClick } = this
<div onClick={handleClick}>
```

and they would have different behavior.

This code is equivalent in JS, so it is an extremely fragile situation. Basically it would mean you can‚Äôt safely extract a variable.
 @arackaf 

Can you suggest an API to this that would not be confusing? Having two names for the same event doesn‚Äôt seem any more elegant than `.bind` calls.
 @arackaf Also, what are your thoughts on @zpao‚Äôs argument?

> Maybe `<button onClick={this.handleClick />` works. But in some other function you have `setTimeout(this.otherMethod)`. If we make the former work, the expectation would likely be that the latter works. However it wouldn't as we've cheated and just made `render` special. The latter works with `createClass` because we bind on creation so everything is pre-bound before you reference (which is also why the bind in c'tor approach is popular).
 This is such a missed opportunity from es6. It was fixed for arrow functions which has the `this` you expect, but not for classes :(

The static initializer proposal ( https://github.com/jeffmo/es-class-fields-and-static-properties ) would fix the issue by binding the function at construction time.

``` js
class Button extends Component {
  render() {
    return <div onClick={this.props.onClick}Click me</div>
  }
}

class MyButton extends Component {
  handleClick = () => { // notice here, it's an arrow function that binds this to the instance
    console.log(this)
  }

  render() {
    return <Button onClick={this.handleClick} />
  }
}
```
 :+1:

I think we accumulated some info about why this would be hard to do in this thread, so I‚Äôll refer to it if this question arises again in the future. Thanks for asking!
  This is a usage question, rather than a bug in the React core. Usage questions are better answered on sites like StackOverflow, as we try to use github issues for tracking bugs in the React core. For this reason, I'm going to close out this issue, which takes it off our radar, but feel free to continue the conversation here (or move it to StackOverflow).

Also, your message does not contain enough information to be actionable.  Based on what you've said, it sounds like fabric is not correctly being loaded into your server-side environment.  You may need to add it as a project dependency, or dynamically request the file and eval it into the JSVM.  Unfortunately, with only the information you've provided, it's not possible to determine what is going wrong here.  Either way, it doesn't appear to be related to React.
  The best medium for discussions like this is probably discuss.reactjs.org

We use github for tracking bugs in the react core.  For this reason, I'm going to close out the issue, but feel free to continue the discussion on this thread or move it to discuss.reactjs.org.
  Followup to #6896, add explanation of workaround.
 @gaearon 
 Let‚Äôs also add a link to https://bugzilla.mozilla.org/show_bug.cgi?id=1276240
  This has a few benefits:

1) This allows the element to always remain on the young generation.
2) The key can be accessed on the fiber which is easier to keep as the
same class and is directly accessible in the child reconciliation of every
object.
3) This conveniently means that we don't have to create a fake element for
continuations which was really hacky.

We can still do the quick bailout of rerendered things using the props
object which is also unique.

Also I added a commit to use Tag instead of Stage for the coroutine
phase.
 Do I understand correctly that you want to stop holding onto the elements?
 Yea. That part is a bit minor. A huge win would be to stop holding onto props which we can do too but that's a separate one. E.g. by always rerendering certain components or holding onto it in a WeakMap for ref equality check.
 lgtm except the inline, as long as tests are the same.
  @sminutoli Do you have any benchmarks that indicate that creating such an object would be any faster than binding a function?
 It's not clear to me what problem this is solving or how the solution is related to the problem I assume you're trying to solve. You mention binding but you would still need to bind if you want to call instance methods. Maybe you're referring to paying the binding cost even if the function isn't called? In that case I think I'd like to redirect to #6908 where there's a bit of discussion.

We already make use of event delegation (we attach single listeners for each event at the top level) so I think that might be tangential.

Obviously I'm not understanding clearly so if please correct me if I've made incorrect assumptions :)
  Duplicate of https://github.com/facebook/react/issues/6556, related to https://github.com/facebook/react/issues/6368
  cc @spicyj @zpao can one of you stamp?
 Did you fix up Facebook?
 I just landed #6677 (so I wouldn't have to do something in just the branch) so you'll have to rebase too. Sorry.
 Ok, fixed+rebased.  Also I have a diff up for FB internally.  After that merges, we will want to do one last pass through the scuba logs immediately prior to doing the sync.
  Can we just always pass `props.is`? It would be `undefined` unless specified, which is indistinguishable from not passing it at all.

cc @jimfb 
 Haha, got it. Let‚Äôs split into two branches to make it a bit easier on eyes?

``` js
} else if (props.is) {
  ...
} else {
  ...
}
```
 Is there any way to test this with jsdom so we don‚Äôt regress?
 Thanks!
 Do you know if this Firefox bug been reported to Mozilla?
  # From maintainers: if you have this problem, please see the explanation in https://github.com/facebook/react/issues/6895#issuecomment-281405036.

I am getting a strange error I've never come across. Googling it doesn't help at all.
`Error: performUpdateIfNecessary: Unexcpeted batch number (current 36, pending 31)(...)`
It has caused me a lot of headaches. I've reverted to 2 days ago and the error persists, even though 2 days ago everything was running smoothly and all tests were passing.

I would appreciate any sort of direction as to how I can begin to resolve this bug. My guesses are that it's an error with Redux, Webpack, Redux-Form, or React itself. I know, not that precise, but I'm quite lost. 

---

Example redux logger information: 
![screen shot 2016-05-26 at 11 18 43 am](https://cloud.githubusercontent.com/assets/8007686/15585614/f6ef14e8-2334-11e6-9c44-a9380b028707.png)

Max OS X, El Capitan 10.11.5
React v15.0.1 (error persists on v15.1.0)

_I'm sorry if this isn't specific to React. I did look into the error message code and it appears to be coming from the Facebook/React code._

Thanks!
 If you scroll up, are there any earlier errors before these ones? You can see them in the `error` field in Redux logger.
 No, those are the first errors.

I'm using react hot loader 3-beta.1 and when I hide and show the side logger I can reproduce the same error over and over.

![screen shot 2016-05-26 at 12 07 27 pm](https://cloud.githubusercontent.com/assets/8007686/15586702/99b5850e-233a-11e6-9c12-a11c3452311c.png)

I think it's an error with one of my dependencies, but not sure which one. Postcss/autoprefixer and redux-form are back on my list of guesses. 

edit: I've reverted back _2 weeks_ and get the same error. I think it has to be my OS or a dependency is failing.
 Does `npm ls react` show only one copy of React? Can you create a minimal project reproducing the problem?
 ```
‚îî‚îÄ‚îÄ UNMET PEER DEPENDENCY react@15.1.0

npm ERR! peer dep missing: react@^0.14.8, required by react-addons-css-transition-group@0.14.8
npm ERR! peer dep missing: react@^0.14.8, required by react-addons-test-utils@0.14.8
npm ERR! code 1

```

My package.json specifies `"react": "^15.1.0",`
 Ugh, `npm ls react` breaks because of peer deps. What‚Äôs confusing though is you seem to have `react-addons-css-transition-group@0.14.8` and `react-addons-test-utils@0.14.8`. Can you please update these packages to `15.1.0` as well and make sure they don‚Äôt contain `node_modules/react` inside themselves?
 Okay, I've upgraded both packages and checked their respective folders in `node_modules`to see if they contain their own `node_modules/react` (which they don't).

```
"react-addons-css-transition-group": "^15.1.0",
"react-addons-test-utils": "^15.1.0",
```

`npm ls react`now returns
`‚îî‚îÄ‚îÄ react@15.1.0`

I still seem to be getting the same error 
 Cool. Still having the same issue? At this point only a reduced example would help.
 I reverted back even further and it finally works. The major package changes were redux-form (v5 -> v6) and some smaller stuff. 

Going to keep trying out different packages until I find out what was throwing the issue. Hopefully I post back here soon with the solution for the rare chance someone else has a similar problem.

Thanks a lot for the help! @gaearon 
 This sounds like it is probably a bug in React.  That invariant is new; it was added in 15.1.0, which was released six days ago.  https://github.com/facebook/react/pull/6650

@brotzky If you can provide a reproducible test case, that would be super helpful.  Even if it is part of a larger codebase that you can share (my guess is it is going to be super hard to isolate that example).

cc @spicyj 
 Yes, if you can post something that reproduces the problem it would be very helpful.
 Yes, we updated to 15.1.0 yesterday, May 25th. That was when we started getting these new errors. 

I will see if I can isolate the issue, but it's very hard to track down. That's the only error message I get. This doesn't break all components, only ones on a specific view. For example, it's the only view that uses `<ReactCSSTransitionGroup />`. 

Here's an entire log I get from start to finish. 
![screen-shot-2016-05-26-at-1 54 02-pm](https://cloud.githubusercontent.com/assets/8007686/15589938/ef72786c-2349-11e6-9baa-e6defad3b2fb.jpg)
 Ive just removed the `redux-form` component from the page and it loads fine.
`redux-form@6.0.0-alpha.13`

Will continue looking into this. It seems my original suspicion was correct.`react@15.1.0` isn't playing nicely with `redux-form@6.0.0-alpha.13`
 @erikras Ever seen this?
 @erikras, when I specifically remove the      

``` javascript
<Field
    name="inputName"
    component={inputName => 
     ...
}/>
```

Everything works as expected. 
 This is definitely a React bug though. There's nothing Redux Form is doing that would be wrong. So if you can repro, please share a case!
 I'm not sure it was React (or at least only React). Sure, the errors were thrown by React but it's possible that those errors were thrown correctly. Having said that, I've never seen those specific batch errors until upgrading to the newest version 15.1.0 (they're not very descriptive errors). The issue I had was with redux-form -- I had a slightly improper setup that was causing issues. 

To resolve my specific errors I had to alter my `mapStateToProps` function in my redux-form container.

Before:

``` javascript
const mapStateToProps = (state) => ({
  fieldValue: state.form && state.form.quote.values.value,
});
```

After:

``` javascript
const mapStateToProps = (state) => ({
  fieldValue: state.form && state.form.field && state.form.field.values && state.form.quote.values.value,
});
```

Overall, if you're using redux-form v6.x and need to get your form fields value on props I recommend using `formValueSelector()` instead of how I approached the issue. http://redux-form.com/6.0.0-alpha.13/docs/api/FormValueSelector.md/. This will be much cleaner and less prone to issues. 

Sorry I wasn't able to create an example. I'm still not sure how to replicate the error in a specific example and unfortunately I can't expose the code I'm currently working on.
 > I'm not sure it was React. Sure, the errors were thrown by React but it's possible that those errors were thrown correctly.

This is highly unlikely, unless code is reaching deep into the internals of React, it should not be possible for a user to trigger this error message.  The error message is for internal debugging/sanity-check purposes.

This is probably a bug, but we're going to need some sort of repro from someone experiencing the bug.  As I mentioned before, it's probably going to be really hard to isolate the bug, so even full-app repros are acceptable in this case.
 If anyone else is experiencing the bug, please feel free to post!  We'd like to collect as much data on this one as possible!
 If I have time, I will see what I can do over the weekend. üé± 
 @realbugger Can you try to extract a minimal case reproducing this?
  The vast majority of users really have no reason to jump into the React source code.  And the React source code is complex enough that jumping into the code is not going to give a user a meaningful understanding of how things work.

Feel free to continue the discussion on this thread.  We can re-open this issue if our thinking on this matter changes substantially.
  Thanks!
  Looks good to me.
  I believe this is a duplicate of https://github.com/facebook/react/issues/6871.
ReactPerf doesn‚Äôt work with production build of React.
We‚Äôll fix it not to throw, but you need to use the development build for measurements.

If you can reproduce this with the development build, please provide a minimal project showing it.
Thanks!
 Oh, on a second read, I now realize it‚Äôs a different problem.
Let‚Äôs discuss 15.1.0 (we don‚Äôt have plans to make fixes to ReactPerf in 15.0.x).
 > warning.js:44 Warning: There is an internal error in the React performance measurement code. We did not expect componentDidMount timer to stop while no timer is still in progress for another instance. Please report this as a bug in React

This looks weird. Can you try to produce a minimal reproducing case?
We have a bunch of tests that verify returning `null` works, so it‚Äôs not obvious what‚Äôs going on here.
 In particular, where do you run `ReactPerf.start()` and `ReactPerf.stop()`? Do you call it from the console, or do you just call it in your app?
 > I will try to prepare some code to reproduce it.

Please do!

> In previous version 0.14.7 I didn't have any problems with Perf tools

It was completely rewritten in 15.1.0 for a number of reasons. Some issues are expected, as the rough edges get fixed. Thanks for helping make it better.
 Thank you!
  I‚Äôll squash when this is ready, GitHub now lets it be done via UI.
 We should warn for `ReactPerf.getLastMeasurements()` too.
 Got it, thanks for explaining.

Let's also add a test similar to ReactDOMProduction in its setup so we don't break it again. It would call all the methods (to make sure we don't crash), assert return values, and verify that console error was called once. 
 @sashashakun updated the pull request.
 > Also, have some problem with test in travis, but don't have problems with local tests.

Try to merge master into your branch and check if something fails locally.

> P.S. I am afraid that do this PR too long

I‚Äôve been doing the ReactPerf PR for two months so it‚Äôs not long. üòâ 
Take your time.
  ::bind is not a thing yet, afaik.  ES7 is not ratified yet, but I don't think this is even on track to be a part of ES7.  We probably shouldn't mention things that aren't a thing yet.
  As we talked in #6874, this is the first step that extracts error codes to a JSON file. The script adds any new error messages to the end of the file _without_ changing existing codes. The traversal order of files is determined by their path names so that the result is stable.

I added `babel-traverse` and `babylon` as new dev dependencies, but they are [already required](https://github.com/babel/babel/blob/master/packages/babel-core/package.json#L34-L36) by `babel-core` so we actually just lifted them up.

Thanks for reviewing! CC @spicyj 

A few things left:
- [x] Rename files
- [x] ~~Require glob patterns rather than copy them~~ Use gulp
 @keyanzhang updated the pull request.
 @zpao the tests pass locally but not on travis. Could this be a caching-related issue? https://travis-ci.org/facebook/react/jobs/133367229
  Seems reasonable üëç 
  This builds on top of #6268.

I fixed a few style nits and indirection in it, and later I realized it introduces a bug in `cloneElement()`. As I was tracing this bug, I found that it already existed in `createElement()` in 15.x (#6879).

So I fixed the bug for both cases, added more tests, and shuffled them around to sit in the corresponding files.

---
- React: Fixed incorrect coercion of `ref` or `key` that are `undefined` in development (@gaearon in #6880)
- React: Fixed a false positive when passing other element‚Äôs props to `cloneElement` (@ericmatthys in #6268)
 Can you inline all the `var expectation =` now that they're only used once each? Otherwise looks great.
 @zpao 

For the changelog:
- React: Fixed incorrect coercion of `ref` or `key` that are `undefined` in development (@gaearon in #6880)
- React: Fixed a false positive when passing other element‚Äôs props to `cloneElement` (@ericmatthys in #6268)
  Sorry that took so long! We don't have this on the download page but we do have it elsewhere: http://facebook.github.io/react/docs/package-management.html#using-react-from-npm where we say to use this:

``` js
new webpack.DefinePlugin({
  "process.env": {
    NODE_ENV: JSON.stringify("production")
  }
});
```

(the `JSON.stringify` ensures it's a quoted quoted string)

Granted, that page needs some more attention to make this easier to find, but we do have it documented. We should probably link to this page from the downloads page.
  This is a _work in progress_ on implementing React's [Error Code System](https://github.com/reactjs/core-notes/blob/master/2016-05/may-12.md#error-messages). Comments and feedback are more than welcome!
#### Background

We currently have [fbjs-scripts/babel-6/dev-expression](https://github.com/facebook/fbjs/blob/master/babel-preset/plugins/dev-expression.js) as a babel pass. It rewrites all `invariant` calls from 

``` js
invariant(condition, argument, argument);
```

to 

``` js
if (!condition) {
  if ("production" !== process.env.NODE_ENV) {
    invariant(false, argument, argument);
  } else {
    invariant(false);
  }
}
```

If you take a look at `invariant`'s [implementation](https://github.com/facebook/fbjs/blob/master/src/__forks__/invariant.js#L34-L38), this is why we have the "Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings." error message in production.
#### What's new

This PR implements an error code system and changes the rewriting to

``` js
if (!condition) {
  if ("production" !== process.env.NODE_ENV) {
    invariant(false, argument, 'foo', 'bar');
  } else {
    PROD_INVARIANT('XYZ', 'foo', 'bar');
  }
}
```

where
- `XYZ` is an error code: an unique identifier (a number string) that references a verbose error message. The mapping is stored in `scripts/error-codes/codes.json`.
- `PROD_INVARIANT` is the `reactProdInvariant` function that always throw with an error URL like https://facebook.github.io/react/docs/error-decoder.html?invariant=109&args[]=Foo. A demo can be found [here](https://facebook.github.io/react/docs/error-decoder.html?invariant=109&args[]=Foo).
#### How it works
1. We have a script that extracts error codes to a JSON file. Implemented in #6882
2. Add a page to display the error codes. Implemented in #6946
3. As we walk through files, the second argument (the error message template) of `invariant` is taken. Then it rewrites the `invariant` in production to `reactProdInvariant` using error IDs. #6948
#### Size comparison

```
   raw     gz Compared to master
     =      = build/react-dom-server.js
     =      = build/react-dom-server.min.js
     =      = build/react-dom.js
     =      = build/react-dom.min.js
 +2191   -276 build/react-with-addons.js
 +2363  +1045 build/react-with-addons.min.js
 +1605   -382 build/react.js
 +2261  +1007 build/react.min.js
```
 Ironically I had been working on #6876 this morning to make sure that works for us (as well as the other projects using the preset). I think we'd still be able to do what you did and fork that dev transform, would just need to opt-out of the one already packaged (which is the opposite of how it exists today where you opt-in).
 @zpao Haha I moved it from `fbjs` to here to make my development easier and to gather more feedback. Do you think this pass should eventually stay here or move to `fbjs`? It's not really coupled with React at the moment.
 Stay here until (if) we decide it's a good thing to do in other projects and then we can "promote" it to fbjs (that's the path we've taken for all the transforms). It might not end up being a good idea for every project and we can move faster and experiment more with it here.
 @keyanzhang updated the pull request.
 Discussed in person, but let's split this out into three parts:
1. Script to extract error codes to a JSON file. I don't think we need to store the version at all ‚Äì instead, the script will just add any new error messages to the end of the file without changing existing codes.
2. Changes to the website to display the error codes. Right now I'm thinking we could have one page called `error-decoder.html` or similar so you can visit `error-decoder.html?code=123&args=%5B%22ComponentName%22%5D` and it will show you the full error message with the args substituted in.
3. Changes to the build pipeline to actually transform the invariant calls. I was thinking we would output something like `reactInvariant(false, 123, componentName)` which would then output a link like my example above.
  I took #6769 as a base and updated it to match changes in master so that it merges cleanly.
 Cool, thanks for taking this on and tracking down. If it rebases cleanly onto master, let's do that and then squash those last 2 commits into the "update jasmine2 with changes from master" commit, then do a real merge (not squash and merge).
 <img width="325" alt="screen shot 2016-05-25 at 22 41 18" src="https://cloud.githubusercontent.com/assets/810438/15557229/d97454d4-22c9-11e6-8721-6a552e034dd1.png">

![](https://media.giphy.com/media/YucHVxk7WYIc8/giphy.gif)
  This probably happens because you‚Äôre running a production build of React, but ReactPerf only works in the development build.

We need to make it clear by emitting a warning instead of crashing.
 We‚Äôll allow this in the future, but it isn‚Äôt possible at the moment. You can track #6627.
 If someone wants to take this, here‚Äôs what I‚Äôd do:
1. Make `ReactDebugTool.getFlushHistory()` return `flushHistory` regardless of the environment
2. Add warnings and early returns to all methods in `ReactPerf` when `__DEV__` is `false`
 @sashashakun Thanks! I put myself as assignee so I don‚Äôt forget to come back to it, but please work on it and feel free to ask any questions!
 > May be it will be better to make a separate helper, like a roundFloat in the beginning of ReactPerf.js? 

Sure, sounds good.

> 2) What warning message I should use?

`ReactPerf is not supported in the production builds of React. To collect measurements, please use the development build of React instead.`

> 3) What need to return, false or may be 0?

I think `print*()` methods can just exit early without a return value (just like they usually do anyway). `get*()` methods can probably return empty arrays. I suggest using whatever return type they usually have, but without any information.

> so should I add **DEV** checking from your first point to this method also?

Worth adding it to log the warning, but the return value should be an empty array anyway.

Finally: I think we should make sure we don‚Äôt warn more than once. If somebody has `ReactPerf.start()` and `ReactPerf.stop()` calls around some hot function we don‚Äôt want to spam the console in production.
 I suggest let‚Äôs open a PR now so I don‚Äôt forget to look into it?
Thanks a bunch!
 Note that warning() is a noop in prod builds.
 Haha, oops, I didn‚Äôt realize that üòû .
Do you have any preferences about how to tackle this?
 Let's just do a console.error.
  If we're going to do this, we would need to mention that this is only true for the `createClass` API (not for ES6 classes).  But I'm not convincd this is worthwhile, as we're going to change the docs to ES6 classes soon, and this will just need to be removed again.
 Yeah, ok, thanks!
  Sounds like this is as per the spec.  I agree we don't want to exceed the spec, and it sounds like we're doing whatever Chrome does, so I'm going to close this out.  Feel free to continue the discussion on this thread, and we can re-open if our thinking changes substantially.
  You're seeing validatePropTypes and checkType in the production build?  :/.

The production build is minified.  How would you even find those functions?
 Yeah, I'm pretty sure the functions you linked are not called in production.
 You are looking at ReactElementValidator. Its functions are not used in production build. If you look for the matches in the source, you will see that it's only used in DEV. 
 That happens! üëç 
  While working on #6836, I found that `escapeTextContentForBrowser` can take up a significant amount of time in server rendering because it gets called for every string child and every attribute value. 

By replacing the current implementation with `escape-html`, my server rendering test cases see a reduction of 8-20% in server rendering time, depending on how many attributes there are per element and whether or not the values have special characters.

I don't know what the react policy is on dependencies, but it looks like there are other MIT-licensed dependencies already, so I thought this might be possible.
 > I don't know what the react policy is on dependencies, but it looks like there are other MIT-licensed dependencies already, so I thought this might be possible.

`object-assign` & `fbjs` are the only actual prod deps and they're only added here as part of a transform. We don't do the same internally. Currently all `require`s resolve internally which will make this a little bit tricker until we revamp how we sync (which will happen but hasn't yet). So short version is that it should be fine but will need some internal FB work done so might take a little longer to make a final call here.
 @zpao Thanks for the response!

> Currently all requires resolve internally which will make this a little bit tricker until we revamp how we sync (which will happen but hasn't yet).

I'm curious; is this referring to things internal to Facebook or internal to React? I tried to cover what's needed in React to include the dependency, and it at least seems to work from tests and inspection of the output build.

@syranide Thanks for responding!

>  this was discarded in-favor of simplicity for the time being (presumed not to really matter)

Totally understood; premature optimization is uncool.

> With that minor tweak I imagine the difference would then be negligible. 

I think (though I'm not 100% sure) that short circuiting for numbers and booleans also helps significantly. This is true in all test cases because `escapeTextContentForBrowser` is called once per element for `data-reactid`, which always passes in a number.

> I'm also suspecting your test-cases are heavily skewed towards values that need escaping

I understand your suspicion, but it's not the case. I ran a test where the leaf nodes both did and did not need escaping, and while the escaping tests showed a larger perf boost, every case was better with this code. The numbers were:

| Leaf node JSX | Perf Boost |
| --- | --- |
| `<div tabIndex="2>" hidden={true} width="30>">{"abc<efg>ij"}</div>` | 20% |
| `<div>{"abc<efg>ij"}</div>` | 13% |
| `<div tabIndex="2" hidden={true} width="30">{"abcdefghij"}</div>` | 12% |
| `<div>{"abcdefghij"}</div>` | 8% |

> `escapeTextContentForHtml` is meant to be explicitly about text content and not for attribute values (there is technically no need to escape <> in text content). 

Yeah, I did some exploratory testing to see if an implementation that didn't check for <> would be faster for attribute values. It didn't seem like there was any real difference, so I stuck with a function that would work for both attribute values and text content.

>  in the future we may want to change that. So it may be make sense to keep our own implementation here.

I might be misreading you here, but I don't understand why using `escape-html` now forecloses the possibility of using a different implementation in the future.

> I also suspect changing to `&#39`; will cause a bunch of peoples tests to fail which may be unnecessary churn.

Hmmmm... good point! I'm curious; did this happen when `data-reactid` was changed in React 15? Is there then a general aversion to ever changing the output of `renderToString`, or is it just that this change doesn't have much upside?

Overall, I totally take your point that the vast majority of real-world inputs to the function will not need to be escaped, so the majority of the perf increase could be achieved with a combo of type-check short-circuit and pretesting for the escapable characters. (In fact, I wrote and almost submitted that version, but then I decided to also test perf when encoding was needed, which led me to `escape-html`.) 

If you would rather have that version, which trades off runtime perf of the unlikely cases for simplicity of dependency management, just let me know; I'd be happy to submit it!
 > That's the optimization I was referring to, I suspect that should close the gap considerably.

That's almost character-for-character what I was about to submit before I moved to `escape-html`; great minds think alike!

So, I went ahead and ran the benchmark I've been using on four scenarios (linked to the commit if you want to look at code): 
- [just short-circuit for numbers and booleans](https://github.com/aickin/react/commit/33c9284398da6af0ccf5891a1b81320b9d5e678a) (typeof)
- [just pretest the regex (what @syranide wrote in the comment above)](https://github.com/aickin/react/commit/f2a80a41d87f6177631ca54e8d1f27f68468e418) (pretest)
- [short-circuit for numbers and boolean AND pretest the regex](https://github.com/aickin/react/commit/914e4e41e883cfa1da81ea2b0827f60b0932eaa8) (typeof & pretest)
- this pull request (escape-html)

| Leaf node JSX | typeof | pretest | typeof & pretest | escape-html |
| --- | --- | --- | --- | --- |
| `<div tabIndex="2>" hidden={true} width="30>">{"abc<efg>ij"}</div>` | 5% | 1% | 2% | 18% |
| `<div>{"abc<efg>ij"}</div>` | 5% | 2% | 1% | 12% |
| `<div tabIndex="2" hidden={true} width="30">{"abcdefghij"}</div>` | 2% | 8% | 10% | 9% |
| `<div>{"abcdefghij"}</div>` | 4% | 8% | 8% | 7% |

For test cases that don't need any escaping, pretest, typeof & pretest, and escape-html are all about the same. For test cases that do need escaping, escape-html is the clear winner.

I'm happy to do whatever. I'd probably recommend typeof & pretest or escape-html, depending on whether we care about the escaping case. Thoughts?
 >  is this referring to things internal to Facebook or internal to React?

Sorry, wasn't clear. I mean internal to Facebook. Since our current sync process is "copy files from src/" we need require to be resolvable. We'll just need to have a module internally that is `@providesModule escape-html` to make this work, which just means it's another thing to remember.

It looks like `escape-html` is either fastest or close enough that it doesn't matter, so unless we duplicate their work we'll likely want to just use it. It's strictly better than what we're doing today.

> I'm curious; did this happen when `data-reactid` was changed in React 15? Is there then a general aversion to ever changing the output of `renderToString`,

This is one of those areas where "semver" gets kind of vague & icky. There are many who would say that changing the output of that (when not fixing a bug) requires a major version change. I don't really feel that way but I can understand the argument. We changed reactid in a major version so it was safe from scrutiny.
 > There are many who would say that changing the output of that (when not fixing a bug) requires a major version change. I don't really feel that way but I can understand the argument. We changed reactid in a major version so it was safe from scrutiny.

Oh, I was just assuming this would go in a major version. I asked the question because I thought that @syranide was objecting that the change might cause churn in over-literal unit tests, **even in a major version**, and I was wondering if that churn in fact happened when `data-reactid` changed.
 @ericf Huh, that's definitely odd.

I just checked in [my test setup](https://github.com/aickin/react-server-perf-tricks/tree/escape-text-perf), and the test functions can be found [here](https://github.com/aickin/react-server-perf-tricks/blob/escape-text-perf/benchmarkedFns.js). It's not the most elegant code, but it produces reproducible results. You run it with `npm install` and `npm run benchmark`.

I used Node v5.7.1 with react@master vs. the various branches in my repo, which I tested by changing the package.json to point to them.

If I may, I'd like to ask a few questions about your setup: What were you rendering? How many nodes did it have, and how big a document did it produce? And what tools did you use to profile the render?

Thanks!
 Thanks for working on this! (And sorry about the branch confusion...)

> In both dev and prod CPU profiles, I'm not seeing escapeTextContentForBrowser bubbling up enough to show up in the Bottom Up view.

The tests always use a minified version of React to get the best perf, so you aren't going to see `escapeTextContentForBrowser` in there; it's been renamed. I don't really know if it's possible to profile React while it's envified and minified; I'd have to think about it for a bit.

For what it's worth, you're seeing very, very similar times to what I'm seeing on my 2.8GHz mid 2014 MBP.
 @ericf: I spent some more poking around with the production env CPU profile that you uploaded, and I have a theory for what's going on. (And apologies in advance for the length of this post... üòä)

First off, I went through react.min.js from `react@15.1.0` and found that `escapeTextContentForBrowser` is minified as `function o(e){...}` and `quoteAttributeValueForBrowser` (which calls `escapeTextContentForBrowser`) is minified as `function r(e){...}`. Armed with this info, I spelunked through CPU-20160526T021311.cpuprofile, and to my surprise I found the function:

<img width="538" alt="screen shot 2016-05-26 at 10 58 00 am" src="https://cloud.githubusercontent.com/assets/44199/15584763/d79b1654-2330-11e6-89c2-a6003945b8fe.png">

`escapeTextContentForBrowser` is called from those two methods (`createMarkupForID` and `_createContentMarkup`), so this looks like a perfect match. And given that `renderToString` (also called `o` in this profile) takes 17,389.7 ms, it seems like  `escapeTextContentForBrowser` doesn't contribute at all to the overall time.

However, there are a few unexplained quirks here. First, `escapeTextContentForBrowser` is also called from `createMarkupForProperty`, and that doesn't show up at all in the callers. Second, both `createMarkupForID` and `createMarkupForProperty` take up a significant amount of time, which is odd if `escapeTextContentForBrowser` isn't a problem:

<img width="503" alt="screen shot 2016-05-26 at 11 07 43 am" src="https://cloud.githubusercontent.com/assets/44199/15585020/204fad28-2332-11e6-89be-dce8848d0454.png">

<img width="509" alt="screen shot 2016-05-26 at 11 08 32 am" src="https://cloud.githubusercontent.com/assets/44199/15585028/3cbae1f8-2332-11e6-9e4a-d2fdb01f31ef.png">

Together those two methods take 3,202.4 ms, or 18.4% of the 17,389.7 ms `renderToString` total. (Ignore the percentages in those images, as the denominator includes a lot of idle time when `renderToString` isn't running.)

This was really curious, because `createMarkupForID` and `createMarkupForProperty` are both really minimal functions. `createMarkupForID`, for example, basically just calls into `quoteAttributeForBrowser`:

``` javascript
createMarkupForID: function(id) {
  return DOMProperty.ID_ATTRIBUTE_NAME + '=' +
    quoteAttributeValueForBrowser(id);
},
```

How could that be taking up 875ms of **self** time? Literally all it's doing is looking up an object property and two string concats!

Then I realized: **inlining**. v8 uses a sampling profiler, and it can't report inlined functions on the call stack, because they aren't actually _on_ the call stack. As a result, `escapeTextContentForBrowser` is only showing up in the profiler for the few times it's called before it gets inlined. 

To test this theory, I wrote a page with the following code and profiled it in Chrome:

``` javascript
function match(matcher, text) {
    if (matcher.test(text)) {
      text.replace(matcher, function() { return "b"; });
    }
}
function run() {
  var text = "asfasdfasdfasdfasdfasdfasdfadsfasdfasdf";
  var matcher = /c/;
  for (var i = 0; i < 1000000; i++) {
    match(matcher, text);
  }
}
```

This is the profile I got:

<img width="422" alt="screen shot 2016-05-26 at 11 26 00 am" src="https://cloud.githubusercontent.com/assets/44199/15585590/d3a874e8-2334-11e6-9efc-fb1d2dab5214.png">

Note that `match` doesn't appear _at all_. Then I added a try/catch block to match in order to make it un-inlineable:

``` javascript
function match(matcher, text) {
  try {
    if (matcher.test(text)) {
      text.replace(matcher, function() { return "b"; });
    }
  } catch (e) {
    console.log(e);
  }
}
```

which gave the following profile:

<img width="422" alt="screen shot 2016-05-26 at 11 29 26 am" src="https://cloud.githubusercontent.com/assets/44199/15585645/29354fee-2335-11e6-9a0b-08d29b81a47f.png">

Now that the function isn't inlined, we can see that the vast majority of the time is spent in `match`.

So, I think this explains how you and I could get such a different view of how much time `escapeTextContentForBrowser` is taking. v8 is inlining the function, making it invisible to the profiler. 

Does this make sense? Do you agree that this is what is happening here?

And thanks so much for your work on this; it's been unexpectedly fun to dive into profiling!
  Fixes #6842.

We keep the existing behavior of testing for matching `onBeginLifeCycleTimer`/`onEndLifeCycleTimer` calls, but we push the current timer onto the stack if we enter a flush. This solves an issue with portals which cause updates while a lifecycle timer is already running.

I chose to subtract the time spent in the flush from the time counted towards the lifecycle method because it would artificially inflate the ‚Äútotal‚Äù time of the component due to all the components inside the portal, so it would skew the exclusive table.
 Sending this one your way too @spicyj üòÑ 
  First commit is expanding the structure of child reconciliation. The steps are organized around phase rather than type of component. I found this helpful for now but I'm sure other structures make sense too.

New Coroutine Primitive. Alternative APIs are possible. The important part is getting the implementation details right to have all the pieces available in the reconciler.
 I think this makes sense overall. My two main points of confusion (already noted inline):
1. `completeWork` getting called twice on coroutines and the existence of `hasPendingChanges`
2. whether yields always need to be direct children of the corresponding coroutine (seems like intermediate composites are allowed, but no host components nor other coroutines).
 Implemented the feedback. I'll leave the yield hack in for now.
  This fixes `componentWillUnmount()` not being measured because `ReactDebugTool` doesn‚Äôt realize there is a flush going on. Also adding tests to check that all lifecycle methods are instrumented.
 @spicyj 
 üëç 

I assume we already have tests to make sure renders due to setState are instrumented? Because that's a different code path than the top-level renders. Thanks for including a top-level update though.
 We currently don‚Äôt, sorry üòÑ  . I‚Äôll add a `setState` path here as well before merging.
  Looks good to me, thank you!
  > how about just use Object.prototype.hasOwnProperty.call(config, key)?

Sounds good, would you like to send a PR with a fix and a test case?
 > +1 for support prototype-less objects

Sure, I don‚Äôt see why not. I think we did support them, and we just regressed when we added a warning. Thanks!
 Fixed in #6855.
  We should add the equivalent here then: https://github.com/facebook/react/blob/master/src/isomorphic/modern/element/__tests__/ReactJSXElement-test.js#L113

The idea is that those tests are supposed to line up and have the same semantics.
 k, done.
  Thanks!
  Follow-up of #6824. The type checker is now a separate module under `isomorphic/classic/types`, which takes either a React element or an internal component instance. As a result, `ReactCompositeComponent` now displays the component stack info when type checking fails. Also, context type errors are memorized and will only be shown once.

CC @spicyj 
  Yeah, I agree with @gaearon, this whole page is all about the legacy API, there is no reason to introduce syntax that will require a transpiler to run the old code out in the wild.
  I actually think that we need to do a more extensive overhaul of the tutorial to make functional and ES6 components fit more naturally.
 @zpao I agree with you, but is there any harm in taking this change since it is incrementally closer to our end goal?
 @jimfb If we end up doing a worse job of teaching React, then absolutely. We should be coordinating efforts to update the site for ES6 and make sure it's _better_. We should not land partial incremental updates that leave us in a state that is not better.
  @VonKieffer Can you provide a jsfiddle that demonstrates the issue?
 @VonKieffer Your example uses a `Select` with a capital `S` and you're setting props which you didn't define in the code above.  The code fragments you posted depend on application logic outside of React, and do not allow us to easily reproduce your issue.  If you can't reproduce the bug in a jsfiddle, it's probably an issue in your application.  Either way, we are going to need a reproducible test case that demonstrates the bug (otherwise this issue is unactionable).
 @VonKieffer To be completely clear, `Select` is not something React provides. It‚Äôs a custom component that you import from somewhere. Have you verified it‚Äôs not a bug in that `Select` component?
 @VonKieffer Your code is still setting props that you haven't specified in this issue.  Realistically, there is too much going on here for us to easily see if this is in userland or a React bug.   I think we're going to need simplified examples using jsfiddles.
 FYI: I fixed the formatting in your comment above.

While this is a much smaller example than being deep in your app, as Jim said, the most helpful thing would be a jsfiddle (here's a good one to start from: https://jsfiddle.net/reactjs/69z2wepo/). You can probably use most of the code you have above as is in there and then just make sure it reproduces in IE. It would be even more helpful if you could reduce it further (Eg, if you removed all the styles, does this still happen? or is there some specific style that breaks it?)
  Can you provide a simple jsfiddle example that demonstrates the issue?
  Can you please provide a complete runnable example that reproduces this?
 Thanks, this makes sense. For the context, I forgot about the portal use case where people `ReactDOM.render` again right inside a lifecycle method, thus making timers stack. We should probably keep the warning but push any timers running when a flush starts onto the stack, and pop them when the flush ends.
  Eeh, this is really a non-issue.  Target is always non-null.  I'll submit a PR to remove the null check, since it is a little confusing, but the extra check really wouldn't have hurt anything.
  Hi, thanks for reporting! Can you publish a minimal project reproducing the issue?
 Sounds like a userland issue.  Devtool was never public/documented API, and we are still iterating on the API so we do not guarantee stability across even patch releases.  I'm going to close this out, unless you are able to reproduce with only the standard devtools.

With regards to the specific point (numbers instead of instances), this is intentional.  The internal instances are intended to be internal to React, and third party tools should only be using the reference for identity.  We transitioned to using IDs in order to enforce this, by not actually exposing the internal instances at all.

Feel free to continue the discussion on this thread.  We can re-open if this turns out to be an actual bug in the core.
 > In other words, if I re-render a different view, could another component get that same _debugId?

They are unique during a single session, as they are assigned by an ever incrementing counter. So no, it can‚Äôt be reused.

> Also, if I re-render the same page over, and over again, would the same component always get the same id?

No, it is possible that the IDs will change. There are no guarantees about the creation order of components.
 > With the instance we built our own unique, persistent key, but now that possibility is gone. 

How did you build a persistent key based on an internal instance? It is not clear.

> It also made the onUnmountComponent hook useless.

Why?

> Also, as a side note, even though it is not public API, you did change the API to be able to work with multiple devTools (aka ReactInstrumentation.debugTool.addDevtool(eventHandlers)), so when changing the API please take into consideration uses of other devtools, and not just the use cases of react devtools.

We encourage experimentation with the API, but the mere fact that it allows adding several devtools doesn‚Äôt mean we won‚Äôt change it again and again. As you said, it is not a public API, and to make it useful we need to iterate on it very fast before declaring it public and letting people rely on it.

We don‚Äôt make changes to it for no reason. Exposing internal instances is dangerous because it blocks some work on the new reconciler (#6170) which is a big goal for React this year. We are effectively creating a fork of React inside React so that the logic can be written in a different way, and reconciliation can be done in multiple passes. This means **any internal structures are likely to change anyway**. For all I know, internal instances **might not even get created** in some cases when we know it‚Äôs unnecessary.

If a long chain of tools (including our own!) comes to depend on internal structures, the transition to the incremental reconciler will be very painful. Even React DevTools currently reaches into internal instances, which is problematic because it has to maintain [a module that tries to make sense of them](https://github.com/facebook/react-devtools/blob/master/backend/getData.js) which will break as soon as we change the private field names, or skip instance creation for some cases. This is why we needed to add an API that would be instance-agnostic as soon as possible. It exposes events like `onMountComponent(id)`, `onSetText(id)`, `onSetDisplayName(id)`, `onSetChildren(id)`, etc, which lets us keep the tooling decoupled from the reconciler. We will be gradually transitioning React DevTools to use this new devtool API as well.

> We used this API to time-travel inner component state through the redux-devtools.

It sounds cool, but can you help me understand:
- Why do you need the internal instances to generate a unique key, and how do you guarantee that it is indeed unique across refreshes?
- How does unique key across refreshes help you implement time travel?

Thanks.
 > We guarantee that it is persistent, and unique (enough for our need), by generating a key based on the component's name,and location in the component tree (yes we iterate up the tree, and possibly get quite a long key, but it works and is only for devTools).

This should work now too. Check out `ReactComponentTreeDevtool`. It gets added automatically, and it tracks parent/child relationships. You can write something like

``` js
function getUniqueKey(id) {
  var parentID = ReactComponentTreeDevtool.getParentID(id);
  if (parentID) {
    var siblingIDs = ReactComponentTreeDevtool.getChildIDs(parentID);
    var index = siblingIDs.indexOf(id);
    return getUniqueKey(parentID) + ' > ' + index.toString();
  } else {
    return 'root';
  }
}
```
 No, we don't have such guarantees. But I am not using an ID itself: I'm using a position in the tree. I assume this is what you mean by being consistent with refreshes. Give it a try. 
 @omerts 

Not at the moment. However, we are interested in `ReactComponentTreeDevtool.getState(debugID)` being implemented, as it will be needed for React DevTools. Would you like to send a PR?

After implementing it, we will need to add corresponding APIs for setting props and state from DevTools, but let‚Äôs discuss them separately.
  @jimfb is this the same as #6813?
 Yeah, looks like a duplicate, already fixed in master.
  Thanks!
  Thanks!
  Can you post the sizes before and after? I believe they should be printed when you run the build. 
 @ruiaraujo updated the pull request.
 Looks good to me.  Thanks!
 Wow, -600 bytes gzipped is great, thanks!
 Just coming around to this. This win is going to get lost internally at FB and in the future if we move to imports, both cases where dependencies are statically analyzed. It's not the only place we do this (IIRC) so it's totally cool to do, just wanted to fill in some backstory (and make sure other FB people understand).
 @zpao I totally broke my mind trying to parse your second sentence, can you rephrase please? üòÑ 
 I'm pretty sure we have another require() in dev blocks so it's ok to do here. I just wanted to reiterate that we only get the wins here and not at FB since requires are resolved statically.
  Thanks for the PR! I think we won‚Äôt take it as is.

Rather than add new examples for ES6 classes, we want to convert most of the _existing_ examples to use them. Please see https://github.com/facebook/react/issues/3710#issuecomment-220775190 for more details about this plan. If you‚Äôd like to help out, please let us know in that issue, and contribute!

Also, `::bind` syntax is not part of ES2016 aka ES7. It is just a proposal, and there is no guarantee it will ever be implemented. Projects using it do so at their own risk, and we won‚Äôt mention this syntax in the docs unless it becomes a part of the standard.
  Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 Hi, thanks for the PR! I don‚Äôt think we‚Äôll take this as is because it becomes a run-on sentence, and there is no mention of ES6 classes in this tutorial at all. I think we‚Äôd appreciate a pull request that _converts_ this tutorial to the ES6 classes, but just adding this information inline in the text distracts from the point of the tutorial.
  We pass the elements from `React.render()` into a `TopLevelWrapper` component, which just returns `this.props` (aka. the element you passed in), so this is actually the same as #2127.  Fixing #2127 should automatically fix this problem.  Regardless, we probably don't want to change this behavior independently of #2127, so let's just close this out.
  Sorry about that, small mistake while publishing. This should all be working now.
 I recommend to switch to npm@3, it has much less annoying warning. If you look at error closely you'll see why it fails:

```
npm ERR! peerinvalid Peer react-addons-css-transition-group@15.1.0 wants react@^15.1.0
npm ERR! peerinvalid Peer react-addons-test-utils@15.1.0 wants react@^15.1.0
```

You have half of React packages at 15.0.2 and another half at 15.1.0. Please use a single version for all of them, and the problem will go away. 
  Implements #6791. I renamed `_checkPropTypes()` to `_checkContextTypes()` since it only checks context types for now. 
Moreover, now `ReactElementValidator`'s `checkPropTypes()` and `ReactCompositeComponent`'s `_checkContextTypes()` are pretty much the same and we can merge them. Should I create a separate PR to refactor them or just change them here? @spicyj 
 It's not obvious to me whether the two methods can be easily combined because they behave a little differently with the addendum (and it would be nice to calculate the addendum only if there is a warning) but if you see a way to clean them up let's do that in a follow-up PR.
 After fixing the inline comments, feel free to merge.
  @jquense, any ideas?
  Yes, afaik.  Although there is https://github.com/facebook/react/issues/6582 under discussion.

This is a usage question, rather than a bug in the React core. Usage questions are better answered on sites like StackOverflow, as we try to use github issues for tracking bugs in the React core. For this reason, I'm going to close out this issue, which takes it off our radar, but feel free to continue the conversation here (or move it to StackOverflow).
 FWIW, the source code on github doesn't contain NODE_ENV checks, those are part of a transform step before shipping to npm (look for **DEV** in the code - those get transformed)
  As we said in #6803, we're going to ship 15.1.0 as it stands today.

I'm mostly looking to make sure the wording in the changelog is fine. In particular, the description here for the Perf tooling is really short and could use a little bit more, maybe even a followup blog post? (cc @gaearon)
 I can do a separate small blog post on changes to ReactPerf if you‚Äôd like.
  It is not wrapped because we want to save an object allocation (the allocation of an array object) if you only have a single child.  You should always be using the React.Children utilities, so this should be transparent to you.
  Hmm, I have mixed feelings.  The online docs are for the current version of React.  This has always been the case.  We recommend that you always stay up-to-date.

We occasionally note when we've made a change to an API's behavior in order to avoid confusing people who know the old behavior, but we generally don't call out when we've made minor changes (like adding a newly supported attribute).  If we called out every attribute and the version it was added, the docs would have version numbers everywhere and the docs would be very cluttered and difficult to read.  We're trying to optimize for people who are up-to-date, since those are the people who are following the recommended workflow.
 I think we don‚Äôt want to take this. If you look for it, you can find other information that is only applicable to React 15. The website always documents the current version, and you can find older versions of the docs by opening the appropriate GitHub tags.
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 I have no philosophical objection to this, but honestly, it hasn't come up that often.  If you go through the quick start tutorial, you learn to use events there.  Also, handling events is a super common flow in any React code, so you could have looked at pretty much any example app (including the third example on the [reactjs.com](http://reactjs.com) homepage).

CLA required: https://code.facebook.com/cla
  Thanks @roderickhsiao!
  Thanks!
  Thanks!
 @jimfb BTW, I speak Mandarin so feel free to assign me if you need me to review docs/translations.
  Personally, I agree, it is confusing.  But `onDoubleClick` is a "better" name, so the decision was made to use it.

We should probably add a warning so people aren't confused.
 Leaving the issue open to track adding a warning.
 Let's wait until #6800 merges since new changes might break.
 @natenorberg As far as I can see, you can take it!
 Fixed in #6881 
  Thanks!
  Indeed, please use StackOverflow or discussion forums for questions. We use the issue tracker for bugs and feature requests. Feel free to leave a link to your SO questions in this thread. Thank you!
  I think caching is probably fine. Jest does it by default too.

@chicoxyzzy if you're ok having your commits squashed, @dmitriiabramov could do it in his branch and it will retain you as an author.

@dmitriiabramov - I think you're just introducing syntax errors right? What about type errors?
 ![doit](https://cloud.githubusercontent.com/assets/8445/15418458/5dee5274-1e14-11e6-882b-5079429424eb.gif)
 No RFC. I would say just take definitions from typings.

Improving the TS tests is totally fine, just make sure we have the same set of tests with the same results in the ES6Class and CoffeeScript test files. We have a tests that ensures you have the same expectations so it _should_ fail if you don't.
 Yes please, that's a distinct effort. I'll merge this in now.
  We have a 15.0.3-dev branch and a 15.1.0-dev branch (each published as an alpha). React Native is using 15.1.0-alpha in master and soon to be (already cut?) 0.27-rc. Ideally we wouldn't ship 15.1.0 as is and would get more into it, however it's a real risk to RN to churn while they're in RC. While we could say "that's tough shit, you used an alpha", that's really not cool, we're all a big happy family and we should work together ‚ô•Ô∏è (and we told them to use an alpha).

So even if I don't think we should do it in an ideal work, pragmatically we should probably just publish what we already have as final. Since we have 15.0.3 with patch fixes and 15.1.0 on top of that, we can ship both easily.

15.0.3 changes: https://github.com/facebook/react/compare/846b5ea252108d104ab1b67f99879459ef591851...d8d6c7a07b6f0b5015286b62fdb0c5b59a243c13
15.1.0 changes (on top of 15.0.3): https://github.com/facebook/react/compare/d8d6c7a07b6f0b5015286b62fdb0c5b59a243c13...7da88845814fd186e30f657588ea28d20916c6d1

Longer term I don't think shipping and maintaining multiple releases is really tenable for us so it's doubtful we'd ship 15.0.4 (outside of a security release). We will need to properly plan what our cadence is and consider a train-like model. That's tangential to the decision here though so I'll write this down my thoughts on this later and we can discuss wherever that is.

A couple related discussions: https://github.com/facebook/react/issues/6738 & https://github.com/facebook/react-native/issues/7385
 cc @ide because I'm pretty sure you're on board.
 We need to add #6753 to 15.1.0. It fixes a memory leak I introduced earlier. 
 Alright, going to just ship 15.1.0 as is with the additional fix. Even though 15.0.3 is ready it's really unlikely that we'll be following that pattern of parallel patch & minor so no point starting now.

@ide Yup, but there's always risk, especially since semver gets hard to define around the edges. I was just considering the option to provide an out for people who want a smaller set of changes.
 https://github.com/facebook/react/pull/6752 is another fix that needs to get into 15.1.0.
  Can you attempt to reduce this further? As is there's not enough for us to determine what might be wrong. At the very least, please share what's happening in `onDispatchClick` since that's when your problem occurs.
 Thanks. There still isn't enough to go on, we'll need a reduced test case. A runnable example using jsfiddle or similar would be helpful. https://jsfiddle.net/reactjs/69z2wepo/
  Hmm. Doesn‚Äôt this move to `src/shared` rather than `src/renderers/shared`?
  Adds a warning for unknown properties.  This unblocks #140, but is probably an intelligent thing to do anyway (regardless of what we do on that issue).

We had previously punted on adding this warning because it was difficult to act upon without source information.  We now have source information attached to the elements, so we can provide context with the warning, which now makes the solution tractable, so we can now add this warning.

cc @gaearon @spicyj 
 We should show the full stack. @keyanzhang is going to add a `ReactComponentTreeDevtool.getStackAddendum(debugID)` in #6799 and then we can use it here.
 Yeah, I'm fine with adding a call to `getStackAddendum`.  In general, I don't like holding up diffs on other unmerged diffs when unnecessary, but it looks like that diff might land imminently, so it's fine.  I'll update this PR after that merges.
 @jimfb Are you blocked by #6799? If yes then I can push `ReactComponentTreeDevtool.getStackAddendumByID` separately first. üòÉ 
 getStackAddendumByID is available now.
 Ok, converted all the warnings to use `getStackAddendumByID`.
 üëç  other than inlines.
  This PR implements #6790. ~~I rewrote some of the tests from JSX to `createElement` calls since #6398 added source locations at JSX compile-time and hard-coding line numbers in tests doesn't sound good.~~
- [x] "Encountered two children with the same key" error
  - [x] `ReactChildReconciler`
  - [x] `flattenChildren`
- [x] "Each child in an array or iterator should have a unique 'key' prop"
  - [x] `ReactElementValidator`
- [x] Switch tests back to JSX and normalize code location info in tests
  - [x] `ReactElementValidator-test`
  - [x] `ReactChildReconciler-test`
  - [x] `ReactMultiChild-test`
- [x] Clean up `ReactElementValidator`
  - [x] Update `ReactElementValidator-test`
- [x] Fix `ReactChildReconciler`
- [x] Refactor `flattenChildren` and add test cases 
  - [x] Test cases
- [x] Implement `ReactComponentTreeDevtool.getStackAddendumByID`
- [x] Pass `debugID` to `ReactTransitionChildMapping.getChildMapping`
- [x] Improve `ReactElementValidator` Error Message -- #6823
 @keyanzhang updated the pull request.
 This PR should be ready for review. I refactored `ReactElementValidator` (inlined a function) but didn't change the warning message since the current message format is more explicit than the component stack info. Please feel free to let me know if you want me to change it. Thanks @spicyj!
 Did you change anything in ReactElementValidator other than adding the stack? It's hard to tell because the code moved around.
 (Also, pretty sure I meant to do needs-revision on this last time! Just a few more questions and I think we'll be good.)
 looks good to me, feel free to "squash and merge"
  Are there other attributes like this that necessitates server rendering?

Most features have corresponding DOM properties that we prefer. There's some case with app cache that I know about as well that only has server-side meaning.

If this is a more generic problem we might need a way to solve this server-side. We don't want global plugins. The client side solution is just refs and manual manipulation so we generally don't need to fix it. It is uncommon enough and doesn't create ecosystem fragmentation/isolation by global plugins (I learned something from MooTools).
  Per @sebmarkbage, we want `isomorphic` folder to only contain the code necessary to author React components. It should not have dependencies on `ReactInstrumentation`, `ReactDebugTool`, and `devtools/*` friends, which themselves should be moved to `renderers/shared/`.

The only caller we to `ReactInstrumentation` we have right now in that folder is [`onSetState()`](https://github.com/facebook/react/blob/8ea1cf4ee0f5315c4190a9e67e15f0f7404cb0cf/src/isomorphic/modern/class/ReactComponent.js#L70) inside `ReactComponent`. We need to move it somewhere inside the renderer (e.g. in the update queue implementation).

Labeling it as a `good first bug` because this mostly involves moving files. The goal is that files in `isomorphic` folder don‚Äôt contain anything that references `ReactInstrumentation`.

This is up for grabs but I‚Äôll do it myself if no one takes it.
 Yea.

@gaearon Do you have a plan for how the new perf tool API will be used since it is tied to a particular renderer? It is the only of the add-ons that does that.
 I don't quite understand what you're asking. From user's point of view it is used the same way as before, through react-addons-perf. If you create a third party renderer you'll need to emit some events to tell it what's going on, but I don't see this as being "tied" to RN or DOM renderers.
 @gaearon `react-addons-perf` currently requires `react/lib/ReactDefaultPerf`. After #6795 there won't be such a file because it will live in `react-dom/lib/ReactDefaultPerf`. However, that only works for DOM. For React Native, we'd have to require `react-native/lib/ReactDefaultPerf`.
 I still don‚Äôt quite understand what you want to do in #6795. Why is `react-addons-perf` affected by this but other addons are not?
 Currently both `react-dom` and `react-native` uses the same instance of all the shared modules. It uses runtime dependency injection to determine which environment actually gets used. The idea is to copy all the modules to each one of them, except the isomorphic ones. That way multiple renderers can coexist on npm, but more importantly they can be versioned independently.

This means that there will be two copies of the `ReactPerf` modules on npm. One in each renderer.

The alternative would be that we keep `ReactPerf` and the debug tool in isomorphic and have renderers register themselves there somehow.

The other addons are not affected because they only depend on things in the `isomorphic` folder which will remain shared.
 Do I understand correctly that you are concerned that changes to `ReactDebugTool` (e.g. adding new events) will force us to release isomorphic `react` more often, and will force us to keep `react-dom` and `react-native` versioned more closely together than we would have preferred otherwise?
 @iamdustan Yes, that is an imminent upcoming scenario.
 @gaearon I'm more concerned about the events not making sense across renderers, but I guess we already tried to make that very generic so maybe that's unfounded.

I'm concerned about having too much in the isomorphic package. It is supposed to be small.

I'm also concerned about having stateful modules in the isomorphic package. It would be nice to let `react` be a direct dependency instead of peerDependency. But there are also practical issues such as that it is difficult that `beginX` and `endX` calls aren't nested inside each other when there are two different renderers doing different work on the same stateful module.

I think `ReactInstrumentation` and `ReactDebugTool` should at least be on a per renderer level.

`ReactPerf` itself is more like one tool of many that could connect to any number of renderers that have a `ReactDebugTool` hook. It could live in the `react-addons-perf` package.

Then we'd need some way to connect them up. For UI based tools such as the Chrome React DevTools, we've used a global variable to coordinate. That way it doesn't matter how npm nests the packages and it doesn't matter which module loads first. The perf tool or the renderer.

Not sure how we'd solve this with a programmatic API though.

One solution would be to expose the ReactInstrumentation module on the renderer and then you have to register it to get a paired up perf tool.

``` js
var ReactDOMPerf = require('react-addons-perf')(require('react-dom'));
```

If we're comfortable with `react` remaining a peerDependency, we could have every renderer register their instrumentation. `react-dom` would call:

``` js
require('react').registerRendererInstrumentation(require('ReactInstrumentation'));
```

Then the perf tool can be a summary of all renderers ever registered.
 I'm offering problems more than solutions. Eager to hear your proposals.

Btw, a design goal was to allow third parties doing something like `ReactInstrumentation.debugTool = totallyCustomTool;` which would have full access to custom profiling etc.
 Thanks, I understand it better now. I created #6812 to track this and will share my thoughts next week.
  A simple plan:

1) Copy all files to each renderer package.

2) Rewrite any require to the files in the isomorphic folder to `require('react/lib/MyFileName')`. (Hardcode a whitelist if needed.)

That way they all share isomorphic modules but none of the other files.

That way versioning separate renderers is easy and doesn't depend on everyone updating their `react` peer dependencies.
 Renderers are still dependent on the `react` package right? We can just version them independently without having to publish React (in other words, what we've wanted to do for a while), and theoretically just stick their dep as `react: ^15.0.0`?. We might still want to version `react-dom` with `react`, at least initially, but it would help immediately with the `react-native-renderer` case.

Do we think this lasts longer term, particularly around the current owner? I know we talked about pulling that out as well (and @iamdustin made that effort)
 Yea, this was the plan all along.

The current owner is part of `react` and for now that is a peerDependency so it should just work. If it was pulled out, then `react` doesn't necessarily need to be a peerDependency anymore and we could support multiple versions of React but that's not as critical.

ReactART won't work as its own standalone yet. It'll have to depend on ReactDOM, but hopefully I can cut it over to the new reconciler.
 > This plan is regarding mapping haste to node_modules as a build step, correct?

Right, and then eventually cut out the haste part entirely (#6336).

> Yea, this was the plan all along.

Cool, just making sure this wasn't some variation.
 > Cool, just making sure this wasn't some variation.

The variation is that this doesn't properly remove unused files from the packages, and it still doesn't do flat builds. So it is an uglier subset I guess.
 If we're already needing to track which requires are from isomorphic, I think we can skip copying those files over to the renderer packages pretty easily (and subsequently the inverse).

Edit: ultimately the file exclusion doesn't matter since they won't be referenced by the packages themselves. And maybe it makes sense to not do any exclusion short-term, the addons packages might get a bit trickier‚Ä¶
 Yeah, I agree with the goal here. We don't need to go all the way though. The simplest near-term solution looks to me to be copying the native renderer files into RN when we want to update and leaving React DOM alone for now. That solves our versioning problems here and also solves our internal problem where RN devs are finding it frustrating to work with RN renderer files in the `react` package. Then RN will depend on `react` only for the isomorphic bits.
 That would further delay getting rid of providesModule, flat bundles with a build step, and might necessitate keeping specialized flow configuration since flow will special case node_modules. And whatever other non-idiomatic thing we'll be chasing to support this instead of addressing the core issue.

I'm fine with this but I feel like we never permanently fix anything anymore. We just do the minimal viable thing so we can fix the next thing next week.

> On May 18, 2016, at 4:43 PM, Ben Alpert notifications@github.com wrote:
> 
> Yeah, I agree with the goal here. We don't need to go all the way though. The simplest near-term solution looks to me to be copying the native renderer files into RN when we want to update and leaving React DOM alone for now. That solves our versioning problems here and also solves our internal problem where RN devs are finding it frustrating to work with RN renderer files in the react package. Then RN will depend on react only for the isomorphic bits.
> 
> ‚Äî
> You are receiving this because you authored the thread.
> Reply to this email directly or view it on GitHub
 Once you have to make a build script that does this, why not just make it do both packages at the same time since they currently line up to do the same thing?

We can copy the result into the RN repo or not but seems orthogonal.

The alternative is to put the sync and build script into the RN repo but we still have to build it and we'd do so in a way that doesn't address both use cases.

I guess I don't see why building once for both is harder than one time for RN-only (and then another time later).
  There's nothing actionable here. No test case, no code. So I'll have to close out. If you have a specific stress test that we can work with, we can talk further, but there's not much we can do with a vague comment about performance.
  It works though, doesn‚Äôt it?

<img width="60" alt="screen shot 2016-05-18 at 17 02 53" src="https://cloud.githubusercontent.com/assets/810438/15366009/63eb44a2-1d1a-11e6-9ee9-31adcbca3438.png">

I haven‚Äôt looked into the implementation but I assume the difference is because we are using a JS DOM API to set it rather than an HTML attribute. (Don‚Äôt quote me on that though, I‚Äôm just making a guess.) The result is the same: it gets selected, just by different means.

Why is the attribute important to you?
 > I can't think of another way to programatically determine the selected option 

Use the DOM API for `<select>`‚Äôs `value`:

``` js
page.find('select#project-switcher').value
```

> Being able to access option[selected] is, indeed, important.

Why? You can still read `node.selected` with DOM API, it just isn‚Äôt an attribute.
 > Being able to access DOM elements via selectors, including attributes, is just a normal way to do it.

You are using a UI library to abstract away DOM handling. This library has an opinion over how to apply those changes, and that opinion may vary in different versions as well. Whether React uses attributes or properties is an implementation detail of React, and you should not rely on it.

If you‚Äôd like to put an attribute on a selected option, do this explicitly: put a `className` or `data-my-custom-attribute` on it. React won‚Äôt mess with the attributes you set explicitly, but please don‚Äôt expect it to emit any particular attributes for things like `value` on the parent `select`.

I‚Äôll close the issue for this reason. Please feel free to continue the discussion though. Thanks for explaining your reasoning, too. I hope that my answer provides a viable solution for you.
  Hi! We use React issue tracker for bugs in React.
What you describe sounds more like a usage question about Redux.

We ask that you ask usage questions on StackOverflow instead.
Please feel free to leave a link here in the comment!

Cheers.
 As for your question, you might find this helpful: http://stackoverflow.com/questions/36795819/react-native-es-6-when-should-i-use-curly-braces-for-import/36796281#36796281
  I'm  slowly working on making sure no code at FB depends on modules internal to React. Mostly that involves changing code to use public APIs but there are also several things that are in React which are more general purpose and should be moved out to `fbjs`. The example I'm hitting right now is `isEventSupported`, used by `normalizeWheel`, used by `ReactWheelHandler`, used by a couple modules in Fixed Data Table. I know `adler32` is also used elsewhere, as are some of the transition event detection, and there are surely others.

Mostly this is a reminder to myself to do this and a notice of sorts to others that random files will disappear from the repo and will live in fbjs instead.
- [ ] `isEventSupported`
- [ ] `adler32`
  `shallowCompare` is not really meant to be super intelligent but a cover 80% of the cases. The problem you're calling out is function identity and it's also been a problem with event handlers and callback refs. But we don't have any intent to support that out of the box and it really muddies the API to add things like this (why not add it to context and state as well?). If you want something like this, feel free to fork shallowCompare.

Another solution is to write your code differently. Remember that you are creating a newly bound function that the VM needs to track scope for on every render pass when you use arrow functions like that. If you did something like this:

``` js
const Component = (props) => <div>{props.title}</div>;
...
render() {
  return <MyComponent component={Component} />
```

Then you would maintain identity and it would work fine with `shallowCompare`
  You must use `readOnly` (note the camelCase).  We currently have a bug where the warning telling you this is not firing, sorry about that!
  It indeed appears missing.

```
dan) cd ~/Downloads/react-15.0.2/examples/basic-commonjs/
basic-commonjs) ls -f
.            ..           index.html   index.js     package.json README.md
```

cc @zpao
 This is fixed by #6688 which will go out with whatever release we do next. Sorry about that.

> Other oddity is that package.json is explicitly requiring 15.0.1 of react!

I think we're using caret ranges in there so you'll get the latest one. We always update for the major releases but might miss updating that file in the other releases.
  Unless I'm mistaken, that issue is completely unrelated (just working around a browserify "bug") and has no impact on runtime VM behavior.
  Hmm. I agree with https://github.com/facebook/react/pull/6780#issuecomment-219411960 that 

``` js
PropTypes.instanceOf(Set)
PropTypes.instanceOf(WeakSet)
PropTypes.instanceOf(Map)
PropTypes.instanceOf(WeakMap)
```

should work fine for this scenario.

For arrays, I think the main reason we have `arrayOf()` is to type-check their values. Compared to `instanceOf(Array)`, this is a convenience feature, as it _adds_ a better type check rather than _enables_ the type check at all.

This convenience feature already exists. However at some point we stopped adding convenience features to PropTypes to stop expanding their API surface, as we want to slowly transition to using Flow instead.

The reason we added `symbol` prop type is because it _enables_ type checking symbols. It is _not_ just a convenience feature. You can‚Äôt use `instanceOf(Symbol)` because it‚Äôs a new primitive type.

Unlike Symbols, `Map`s and `Set`s are not primitive types. For `Set`s and `Maps`s to have feature parity with arrays, we would need to add something like `mapOf()` and `setOf()`. However that would also be a convenience feature, like `arrayOf()`. Since we don‚Äôt want to expand the API surface of PropTypes, we‚Äôd rather avoid adding more convenience features. This is why I‚Äôd rather see it in a third-party package, similar in spirit to [`react-immutable-proptypes`](https://www.npmjs.com/package/react-immutable-proptypes).
 @gaearon is correct.  Proptypes are mostly legacy and in maintenance mode right now.  We don't want to increase the surface area of proptypes at the moment, if we can avoid it.

@chicoxyzzy These additional proptypes would be a good thing to publish as a separate third-party library on github, if you'd like to do that :).
  Yea, I saw this myself yesterday.
 This bug is a bit annoying.  For one thing, there are many different input types to consider (https://www.w3.org/TR/html5/forms.html#attr-input-type) and browsers seem to support more types than the spec indicates (for instance, Mozilla appears to support "month" as per https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input).

In the particular case of a radio button, this is further complicated by the fact that you can't determine the "controlledness" of a group just by looking at a single input.  You need to look at all the inputs with the same `name` prop within the same form group.  Yuck.

Too bad we can't just ban uncontrolled components. That would make life so much easier.  :P.
 @syranide I think it's a bit more complicated than that.  Think about how you would implement these warnings for switching between controlled and uncontrolled radio buttons.

If any of the radio inputs within that form group have the `checked` attribute specified, then the whole group is controlled.  Controlledness can't be tracked on a per-node basis for radio buttons.
 Let's scope this to handling the 90% case which is just that this is warning incorrectly. We can worry about making it perfect some other time.
 @zpao That's what I'm talking about - this warning firing incorrectly (too often) for radio buttons.

if we just want a quick fix, I think we need to just disable this warning for radio buttons.  I don't think there is a 90% solution for radio buttons that won't occasionally fire spurious warnings.  A "correct" fix will require tracking all the radio inputs within each form group.
 The test case in the initial report is warning and it should not be. It is not because of needing to track across radios in this case it's because we're incorrectly looking at `value` for radios and checkboxes (right here: https://github.com/facebook/react/blob/master/src/renderers/dom/client/wrappers/ReactDOMInput.js#L169-L171). We should not be falling back to `value`, we should be using the type to determine if we should be looking at `checked` or `value`.

You are talking about a real problem but it's tangential to this one.
 @zpao Right, but an uncontrolled radio group is not required to set a defaultChecked on any of the elements.  And a controlled radio group is allowed to set a defaultChecked on a controlled element (for the reset button).  This means that unless we do the smarter logic, any check we do is wrong and will fire spurious warnings.  We might as well just remove the check (for radio buttons) at that point.
 @syranide Are you required to specify `checked={false}` if the radio button is not checked in a controlled component?  Today, the answer is no.  Maybe we could/should change that, but it's a much wider discussion and almost certainly not within the scope of a 90% quick fix that @zpao wanted.

Example: this is a legal (immutable) controlled form:

```
<form>
  <input type="radio" name="foo" value="1" onChange={()=>{}} />
  <input type="radio" name="foo" value="2" onChange={()=>{}} checked />
  <input type="radio" name="foo" value="3" onChange={()=>{}} />
</form>
```

Obviously it's a contrived example.  You can imagine that the user has a list of elements and just "sets" the checked attribute on the one that is checked.  But the result is the same.

The "controlledness" of the input is defined by the entire group within the form.  The lack of a `checked` attribute is insufficient to know if a particular input element is controlled.  In this case, the controlledness of the first input is determined by the controlledness of the second.

That's why this warning is so tricky for radio buttons.
 > Actually the answer is yes in a sense...? https://jsfiddle.net/hx2r7bc4/ (contrived example, but still)

Wow, that sucks.  That is the most terrible thing I've seen all month.  But I'll give you credit because it demonstrates a problem with not specifying the checked prop on a controlled component when all values are false.

> Also, I would consider it very weird for someone to have a controlled component and not explicitly set checked (I doubt you'll find anyone that does even), additionally, this is a warning and basically intended to shine light on bad behavior so I'm not really sure if I would consider it a problem anyway?

I'm not sure it's that weird.  It is pretty intuitive/natural to loop over some data and set `checked` IFF the data says that value is checked (assuming you aren't using jsx).  I'm not even convinced it's bad behavior (except given your fiddle above).

Anyway, I suppose I'm fine with banning that behavior üëç.  I think that will work.

---

The only other edge case I'd worry about is what happens if a controlled checkbox turns into a controlled text input, but that should be easy for us to get right, we just need to test it after making our change(s).
 @LiJinyao 

It means `this.state.isMustFill` is not always `true` or `false`, but rather `true` or `undefined`, for example. Make sure it‚Äôs always boolean, and the problem will go away.
  Thanks!
  This helps us make sure we don't break React ART in a minor or patch release. The idea is to not change these files when making minor or patch changes. Copied directly from react-art with requires fixed. (I also picked a different haste name just in case.)

Then I fixed the tests.
 @facebook/react-core This is kinda icky. My native/host rename mucked this up (getNativeNode) but the devtools warns about missing debug IDs too before this change. We can't really change React ART because we have no way to guarantee that people aren't using React ART v15 with React 15.1.
 Well, apparently we haven't published React ART 15.0. But the point stands, I think.
 Can we just actually ship ReactART's source inside the `react` npm package and then we won't have to worry?
 > Can we just actually ship ReactART's source inside the react npm package and then we won't have to worry?

Isn't that the opposite of what we want to do with renderers?
 Ehh‚Ä¶ React ART is weird because it isn't its own environment so we can't make things completely separate. Unlike React DOM and React Native where it's okay if they have different versions (and we don't _want_ them to share any state or code). Maybe we can try to make React ART more independent (and that might be a good idea anyway) but we're not set up for that right now.
 ART doesn't depend on shared state other than owner and current context.

Just copying all the files from React to ART should be sufficient too.

The question is, if we keep going in the opposite direction of decoupling, when will we ever get to a decoupled state? What spin off effects will we get from doing this?

> On May 15, 2016, at 10:27 PM, Ben Alpert notifications@github.com wrote:
> 
> Ehh‚Ä¶ React ART is weird because it isn't its own environment so we can't make things completely separate. Unlike React DOM and React Native where it's okay if they have different versions (and we don't want them to share any state or code). Maybe we can try to make React ART more independent (and that might be a good idea anyway) but we're not set up for that right now.
> 
> ‚Äî
> You are receiving this because you are on a team that was mentioned.
> Reply to this email directly or view it on GitHub
 Okay, we don't have to merge them. Does this PR look good though? I want to be able to test against React ART even if we consider them decoupled.
 @spicyj updated the pull request.
  Not entirely sure what is being requested here, but it's highly unlikely that we're going to change the jsx syntax definition, since it is already being implemented in so many places (babel, typescript, editors, etc).  For this reason, I'm going to close this out.  We can always re-open if our thinking on this matter changes.

However, with regards to your specific feature request... can you elaborate on what you're trying to do?  You can already pass tags as an expression, as demonstrated in http://jsfiddle.net/e3t4jzxj/
 We are working on a way to represent styles in javascript, but it is still a work in progress.  However, our solution is not likely to "change expression brackets from {} to []".  The current recommendation for representing styles is: https://facebook.github.io/react/tips/inline-styles.html
  Thanks!
  ![image](https://cloud.githubusercontent.com/assets/6820/15267642/f7392460-197b-11e6-8009-f2204aaee487.png)

This works pretty well, even if you don't have source info compiled in ‚Äì it falls back to annotating with owner info. The weirdest thing I noticed is that if A renders `<section><B /></section>` and B renders `<div><C /></div>` and C gives a warning, then the stack will be

```
in C (created by B)
in B (created by A)
in section (created by A)
in A
```

and makes no mention of the div that should live between B and C: it can't, because that element hasn't been created yet. I think this probably won't be too confusing in practice but I wonder if there's something we can do to make it clearer.

cc @facebook/react-core
 I had to track the stack because we don't know the parent hierarchy until the children are fully mounted. I wonder if we can change that.
 @spicyj updated the pull request.
 Can we add `onSetParent` and pass the parent `debugID` down to the children as they are being mounted? It would never change so not too much of a hassle.

I think we should try harder to avoid relying on the stack again because this can become hard to rip out later. 
 I think we don‚Äôt even need to pass it to the children as long as we set it right away after instantiating them but before recursing.
 Yes, that works out nicely. How do you like this?
 üëç 
  woah, this is awesome. I'll let the React folks merge this one, though :)
 @zpao @sebmarkbage can you think of a way to reduce the amount of permutation in `ReactMultiChildText-test.js`? It seems like it's taking 150 seconds because of the amount of work it is doing. Is all of this necessary?
 It is supposed to take less time. I posted a PR earlier today that fixes a severe perf issue. Still slow after the change but not that slow.
 @spicyj where can I see your change? I can't find it.
 @cpojer Oops, you're right. I forgot to send it. Thanks. #6770
 @dmitriiabramov Would you mind rebasing please?
 @dmitriiabramov updated the pull request.
 I think that seems reasonable. Is there a way we can make the output show a more readable diff? Even if not, this seems good ‚Äì thanks for doing the work!
 Thanks a ton @dmitriiabramov! I rebased this in #6872 and merged.
 hell yeah! I think no one is using jasmine1 any more now, we'll make it optional in Jest and not download it by default any more :)
 Also the tests should be 20 % faster or so :)
 > Also the tests should be 20 % faster or so :)

Yes, it certainly seemed so to me. Great job!
  @gaearon
 LGTM
  @GGAlanSmithee 

I don‚Äôt believe this is correct. [ES6 object literal shorthand notation](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Object_initializer) allows `render() { }`.

@superchangme 

We use the issue tracker for bugs and feature requests in React itself. What you‚Äôre asking seems like a usage question, and would be more appropriate on StackOverflow.

The error says:

> createClass(...): Class specification must implement a render method.

This means one of your `createClass()` calls misses a `render()` function on the specification object. Since you didn‚Äôt post the complete code, I can‚Äôt say which exactly. 

When you see an error like this, click on a small arrow next to it:

<img width="709" alt="screen shot 2016-05-13 at 12 54 14" src="https://cloud.githubusercontent.com/assets/810438/15247115/de19ea5e-1909-11e6-95fc-93ab116d5497.png">

This is the stack at the time the error was thrown. The third line should show _where_ in your code that `createClass()` call was. Click on it, and you‚Äôll find the component with the missing `render()` method.

I hope it helps! I‚Äôm closing as this is unlikely to be a bug in React, but please feel free to continue the discussion.
  Being able to get the source for your parent components seems useful, and ReactComponentTreeDevtool is best poised to be able to do that.

I'm also not sure it makes sense to have separate DOM-specific `onMountDOMComponent` and `onUpdateDOMComponent` events, so I removed them for now. Even if we want them, their timing seemed sort of arbitrary.

I also made it so DOM devtools can listen to non-DOM events too. Willing to change that if people think it's ugly though.

Reviewers: @gaearon
 Now tracking element, and removed extra debugging code (moved to #6768).
 LGTM 
 Ugh, I guess I totally missed the boat on #6398, I think @gaearon tried to warn me about `ReactComponentTreeDevtool` landing around that time. :-)
 @troydemonbreun No worries, your work was still helpful! Thanks for doing most of the work.
 @spicyj You are very generous.
  Let‚Äôs add extra tests that verify that running `begin`/`start` or `end`/`stop` twice has no effect.
 > separate tests right? because they're testing start etc. instead of isRunning

Yeah. I‚Äôd probably just test the public API here (`ReactPerf`). Basically to verify that it doesn‚Äôt crash when you try to `start()` or `stop()` it twice, and that `isRunning()` returns a sensible value.
 Thanks!
  `ReactDebugTool` is not a public API by itself, at least not yet. I‚Äôm open to adding `isRunning()` to `ReactPerf` though, as it‚Äôs the public API. Would you like to send a PR?
 Yeah, we can add `isRunning()` to `ReactPerf` and `isProfiling()` to `ReactDebugTool` with the real state being in `ReactDebugTool`.
 Yep!
  The goal there was to speak at a higher level and try to avoid the intermediate element representation. That's not actually relevant to the understanding there. I agree that it can be a bit confusing, but generally only for people who know enough to skip past that section. I think by raising this point you've made it clear that you know enough :)
  Yes, nice catch, thanks!
  The close-form tag didn't change (it was present in tutorial16.js) and also isn't interesting (there is no reason to draw the user's attention to it).  I see no reason to highlight it.  Let me know if I missed something.
  What does your ES6 class look like? Is your import/export set up correctly? Classes will be a function so should never be an object.
 Ping @naveenideas2it
  As stated, this is a part of the development addons bundle. Thanks for commenting @ajgreenb!
  Previously, `renderIntoDocument` relied on the synchronous return value of render.  As per https://github.com/facebook/react/issues/6397, we want to start moving away from relying on this synchronous return value.  This PR takes the first step toward that goal, by providing a `renderIntoDocumentAsync` method, which makes it easy to render into a document and wait on the return value for the purposes of unit testing.  Long term, the `renderIntoDocumentAsync` is intended to replace `renderIntoDocument` for all intents and purposes.

The primary motivation for this PR is that it brings our unit tests closer to matching the semantics of an incremental reconciler, thereby allowing us to iterate on our incremental reconciler without failing all the unit tests.

cc @sebmarkbage @spicyj @zpao 
 @jimfb updated the pull request.
 Overall I think this is an ok thing to do. For the record, I talked to Jim offline about what we think future `render` API looks like. It's unclear at this point how incremental reconciliation would change things so instead of trying to plan a test utils API that mirrors that hypothetical API, we should pave forward and wrap with something useful in the mean time.
 Can we split this diff in twain? Use this PR to introduce and test the new API, then a 2nd to use it. Or at the very least 2 commits in this PR.
 Ok, I split the usage into https://github.com/facebook/react/pull/6785
 I think this is ready to go, modulo bikeshedding on the new function's name.  We could also just merge this now and fix the name later... :P.
  @hckrmoon Can you create a simple jsfiddle that demonstrates the problem.  Also list the device type (ios/android) and browser version you used.
  `ReactDebugTool` used to only call `purgeUnmountedComponents()` while profiling, so information about unmounted instances kept accumulating when not profiling.

Additionally, unmounting in React Native and rendering to string did not correctly clean up the devtool.

Finally, the tests tested the wrong behavior and relied on explicit `purgeUnmountedComponent()` calls.

To fix this, we:
- Test specifically that unmounting is enough to clean up the tree devtool.
- Add missing `onBeginFlush` and `onEndFlush` calls to server and native rendering so `ReactDebugTool` knows when to copy the tree.

Fixes #6750.

Reviewers: @sebmarkbage @spicyj.
 Thanks.
  This fixes #6742. It was caused by a composite changing from rendering `null` to rendering a native component. We don‚Äôt register the empty components in the devtool (as they are a temporary implementation detail), but we used to report them in some events, which caused the aggregation code to fail.

I fixed the problem and added a few remedies for the future:
1. Tests for these particular cases.
2. `ReactPerf` tests now call all aggregation methods just in case so if they throw, the tests will fail.
3. We now warn if the `debugID` passed to devtools is zero. We use zero for implementation details like TopLevelWrapper and empty components, and we don‚Äôt want to leak information about them.
4. Fixed a few remaining callsites that passed zero or undefined (mostly in tests).

Reviewers: @sebmarkbage @spicyj 
 I think this looks fine, just confused about a couple things.
 lgtm
  Seems reasonable ( üëç )
 @chadfawcett We don't have a good system for translation management.  Right now, translators just watch for changes to the documentation and update the translations when they see changes.  We will come up with a better system eventually.  No action item on your end.
  Related to https://github.com/facebook/react/issues/5397, potentially fixable by https://github.com/facebook/react/pull/6701
  Looks good to me ( üëç )
 @grassator Merged into master.  This should make it into one of the upcoming releases.
 Yea, no problem!
  Thanks!
  Potential alternate fix is https://github.com/facebook/react/pull/6710 which appears to be a superset of this PR.
 Closing in favor of #6710.
  Using findDOMNode is just as bad as using isMounted.  If you feel the need to check, your code is already smelly "because the only reason you would check is because you think you might be holding a reference after the component has unmounted" (https://facebook.github.io/react/blog/2015/12/16/ismounted-antipattern.html).

If anything, this suggests to me that findDOMNode should also warn if called on an unmounted component.  It's literally just as bad as doing a setState on an unmounted component.

The correct solution would be to drop references in componentWillUnmount.  It appears that componentWillUnmount already clears all the timers.  Why is this isMounted logic necessary in the first place?
  What exactly are you suggesting here? That React support a `hidden` attribute? Or that React supports having `!important` in styles?
 Thanks for clarifying @twoeo. But as @mijamo correctly notes, this isn't a React issue as your `test` class is overriding the browser-default `display` property.
  Is there any way you can find a test case reproducing this? That would be really helpful!
 This probably happens when a composite switches from rendering `null` to rendering a DOM tag.
 Fixed by #6752. Big thanks for reporting.
  This is most likely a duplicate of #6538.
It has been fixed in master in #6650 and will be out in the next React release soon.
  I took a brief look. As far as I can tell, this isn't a React issue. It looks like maybe something is wrong with the locale fetching code. Since the page just says `...` and the network inspector in Safari seems to only show a request to it.json and none to en.json. I'm not sure why this would differ between the Facebook in-app browser and Safari though. If you keep having trouble, trying to reduce it to a minimal repro could help. Maybe even just by alert debugging or similar. You should be able to post a link to Facebook to your local dev server (with Only Me privacy) and then test locally. If you get to a small repro case but still can't figure it out, post back here and I can take a look.
  > I could always recommend poking the other dependencies and have them change to ^15.0.0-0 as a peer dependency instead, that way they're also compatible with all prereleases.

Alas, this doesn‚Äôt help in this case. `^15.0.0-0` matches `15.0.0-alpha.0` but not `15.0.3-alpha.0`, for example. There‚Äôs just no way in semver to specify ‚Äúmajor version and all its prereleases‚Äù AFAIK.
 I knew this would be a problem‚Ä¶

15.0.3-alpha.2 was at next but then 15.1.0-alpha.1 superseded that. Could make it `next-patch` or something like that. I don't want to go down the route of publish as real versions because we'll burn through versions way too quickly as we attempt to make things work in RN.

Do dist-tags really help? You need all deps to use them too right? And then we can't break the semantics (Eg publish a "next-rn" and then move it to point to a new major version when that time comes)
 > That seems equally problematic, but in a different way?

Perhaps not equally but definitely still a problem.

We could probably do it with some guarantees and do something like `next-rn-15`, much like `next`, however we wouldn't ever point it past `15.y.z`. People would have to republish to support a new major version, but we probably want them too anyway. I think `npm` does something similar just without the preprelease bits which do make it harder (but shipping a client is different than shipping a library and I don't think publishing a pile of (unobviously) unsupported versions is the right thing to do)

It's still an all or nothing game though.
 I don't philosophically agree with shipping seemingly "stable" versions of react that are only intended for us to try to make RN work but that we need to publish 5 times to get right.

Help me understand the scope of the problem‚Ä¶ is it packages that RN depends on or ships with? Or is it only an issue for people building apps using RN from github? If it's the latter then I propose we don't care. Published versions of RN will point at released versions of React. Maybe that goes for RCs as well. Our plan from the React side was to ship alphas so RN can get things as quickly as possible, and then shipping the alpha as a stable release and update RN so it's final version never uses an alpha.

cc @facebook/react-core since we've been talking about this and perhaps there are some discussions around this I haven't been a part of
 > It's the latter, potentially including RCs

How many people is that? I'm not sure how much I actually care to go out of our way to support a small number of people building from arbitrary points on master. Maybe we change our modus operandi for RCs though.
 Let's live for a tiny bit longer. If it's unbearable then I'll step out of the way and help make this work. It just really muddies the process we have with a stable branch and how we publicize releases, so on top of my philosophical reservations, there's a bit more to figure out :)

The dist-tag for alphas is doable in the mean time if you want to pursue that.
 Let‚Äôs close for now as I don‚Äôt see anything actionable on our side.
We decided to [speed up release cadence](https://github.com/reactjs/core-notes/blob/master/2016-05/may-19.md#new-release-proposal) which should help things a bit.
  üëç thanks!
  I approved the related PRs but they only created new files as far as I saw. I‚Äôm super confused about this.
 cc @zpao, any ideas what happened?
 cc @dotu for the future reference‚Äîids and permalinks need to be unique.
 Travis was taking a lot of time to run. It just finished two minutes ago, and after Cmd+R I see all pages in English.
  Is this actually related to the spriting or is it just related to click events? Does this fiddle http://jsfiddle.net/a31yq2rm/ break? That's just a plain JS implementation of basically the same thing.
  We haven't actually changed the way the way we operate on the DOM here. The difference you're seeing is that we no longer generate HTML for initial render and use the same code path we would use for updates. I assume you're looking in the devtools, which make it a bit harder to really see the true values (parsing style attribute vs setting properties‚Ä¶ result is the same but visually setting the property gets parsed before being displayed so has the extra quotes in there).

Can you recreate a case that doesn't work and specify browser? I took the clip-path example from MDN and tried to reproduce but it appears to be working fine in Firefox (49): https://jsfiddle.net/ue1nwwtq/1/. It doesn't seem to be working in Chrome but that also doesn't work if I take the plain HTML example either.
  cc @spicyj @syranide 
 Who is our resident event system expert at this point?  It used to be @syranide and @spicyj.  Perhaps now it's @jquense?
 I haven't had enough time to think about this so I can't suggest a solution but ReactDOMTreeTraversal shouldn't be aware of roots at all; it's designed to answer questions only about a single tree.
  Yet another bug which is automatically fixed by https://github.com/facebook/react/pull/6406

Demo without fix: https://jsfiddle.net/6tefu8g7/
Demo with fix: http://jsfiddle.net/m2ke4chf/

Can we PLEASE get that PR reviewed/merged.  cc @facebook/react-core 
  üëç but let‚Äôs make it a link to `/react/docs/create-fragment.html`?
  This is a usage question, rather than a bug in the React core. Usage questions are better answered on sites like StackOverflow, as we try to use github issues for tracking bugs in the React core. For this reason, I'm going to close out this issue, which takes it off our radar, but feel free to continue the conversation here (or move it to StackOverflow).
 This might be related: #858, #870.
  @actionnick Perhaps we could warn for such situations.  Can you give the exact style object you're setting?
 @syranide Not something we'd want to do on the production code path, but it might be worth doing in dev mode if it allows us to give good warnings for style failures that might otherwise be difficult to debug.
 I'm also a little curious to see exactly what went wrong, to better understand what was going through the user's mind and why it didn't work as he expected.
 > The bigger issue is XSS if you ask me, I assume lack of encoding is the most likely reason people would bump into this and it's unlikely that any such warning would ever help you there before it's too late.

That seems like even more reason to warn.  Increase the chances that someone sees the problem and digs into it.

> cherry-picking some easy to detect cases and not being able to test all the others seems like a can of worms.

Idk, I have a more pragmatic view.  Create helpful warnings whenever we can, and don't get hung up on the fact that we won't/can't catch every possible conceivable bug.
  The command should be `node`.

Node.js is sometimes installed as `nodejs` instead of `node` due to a package naming conflict.  More info: http://stackoverflow.com/questions/18130164/nodejs-vs-node-on-ubuntu-12-04

This is not a React bug, so I'm closing it out.
  Can you please provide a fiddle demonstrating the issue?
  Did you intend for the `id` to refer to the variable `main` or the string "main"?  There is some ambiguity with regards to what the intent would be, which is slightly suboptimal.  It also makes parsing slightly more difficult/complex.

For the reasons above, I think we're unlikely to make this change.  However, feel free to continue the discussion on this thread and we can always re-open if our thinking changes substantially.
 In any case, feature suggestions for JSX would be better placed in http://github.com/facebook/jsx.
  @zpao @syranide @spicyj Is this something we want to support?  Looks like the status is "Candidate Recommendation" but it is supported by a couple browsers.
 Sounds like Firefox, Chrome, and Edge all support it. We might as well too though I don't know if it's worth polyfilling.
 If we add something to the synthetic event object, it needs to be available in all browsers. 
  Using component instances is an escape hatch anyway.  It is not a recommended pattern, so we don't want to encourage their usage by providing more helper functions.

You can already get a reference to the instance by attaching a ref to the root node when you mount the component.  Once you have an instance, you could attach it to the container DOM node, or do anything else you'd like (eg. save it somewhere else).  The point is that an additional `getComponentAtNode` doesn't actually allow you to do anything that you couldn't do prior to having that function.  This is the most compelling reason to not increase the API surface area by adding more functions.

Hope that makes sense!

I'm going to close this out, since it's probably not something we'd want to add.  However, feel free to continue the discussion on this thread.  We can re-open if our thinking on this matter changes substantially.
  Do you have a jsfiddle that demonstrates the issue?
 Also, if you'd like to submit a PR for this, this is something we'd probably want to support in React.
  This makes it very tough to change internal structures of React Native. Have you considered a build script that puts them into the same repo like we do for React? Or maybe putting forwarding modules into a common directory? That seems to be a pretty common pattern for solving this problem with C headers.
 Hm. This only works if `react` and `react-native` happens to be at the same level of node_modules hierarchies, right?

I can imagine scenarios where this is not the case. E.g. when you use an application framework as a dependency which uses `react-native` to render so that's an indirect dependency but `react` is a peerDependency so it ends up at the top level.

I think the problem is that we can't make `react-native` a dependency of `react` to clarify this to npm.

Even with npm3 there are scenarios where you end up with nested dependencies, right?
 I kind of think that some of these should go on an indirection on the global object directly instead of in the module system since there is no way in the node/npm world to define a global host environment module other than through the global object. E.g. `global.process.UIManager`
 > You are correct here. I chose this variant to maintain backwards compatibility. If react@15.0.3 is not compatible with older versions of react native anyway, I will introduce the necessary forwarding modules and change this PR.

FWIW, I'm pretty sure that regardless of how this gets done it's not going into 15.0.3 and we'd do it as a 15.y.0.
  Thanks @iamdustan!
  Ok, thanks!
  cc @zpao
 It doesn't look like it worked‚Ä¶ but do whatever it takes
 It used to work üòû What happened?
 ¬Ø\_(„ÉÑ)_/¬Ø want to dig into it?
 Last time I checked, the `./coverage` folder contains nothing after running `grunt jest:coverage`. But `jest --coverage` works. Could it be a grunt script related issue? It might be related to https://github.com/facebook/jest/issues/433
 Looking at travis logs, it seems that the coverage stopped working after #6620. 
If I remove `'--runInBand'` from our [grunt task](https://github.com/facebook/react/blob/master/grunt/tasks/jest.js#L77) then it generates coverage correctly. Am I on the right path @zpao @cpojer? :)
 That sounds believable. I think not using runInBand was making the tests flakier. Maybe because of the extra memory overhead? Not sure. So the issue is that jest might not support coverage with runInBand properly. I haven't looked into it at all, but that might not be too hard to fix.
 Yeah, Jest doesn't generate coverage when used with runInBand.
 That is weird and seems like a bug in Jest. It is probably a silly thing that's easy to fix.
  I don't understand.  `this.myTextInput` is defined under "complete example" (that's the point, it's a complete example).
 We may happen to use the same variable in the section on callback refs, but we aren't depending on anything from that section.
 actually, I just looked at the page again.  We aren't even using the same variable name in that previous section.  The refs section uses `_input` and the complete example uses `myTextInput`.
 it's just an expando property, pretty standard in javascript.
 > Maybe it's the ES6 magic in this line making it hard to read.

To add some context, I think what @jimfb means is that this pattern isn‚Äôt really specific to ES6.
Here‚Äôs an equivalent in ES5:

``` js
<input type="text" ref={function(ref) {
  this.myTextInput = ref;
}.bind(this)} />
```

This is not much different from patterns like

``` js
$.ajax(url, function (result) {
  this.data = result.data;
}.bind(this))
```

that are prevalent in ES5 code with many libraries.

So we pass a callback that writes to `this.myTextInput`. In JavaScript, people often don‚Äôt declare the initial (empty) values for fields that are set asynchronously. Refs are set asynchronously, so while technically we could put `this.myTextInput = null` somewhere, it doesn‚Äôt really make a difference. Therefore we would prefer to leave it as is.
  I wonder if this is a duplicate of https://github.com/facebook/react/issues/6538, which has already been fixed in master using a different solution.

Can you create a unit test that fails without this change and passes with this change?  We should have that as a regression test anyway, assuming this bug is not already fixed in master.
 Perhaps this is a fix for https://github.com/facebook/react/issues/5296
 > I can create a test case as it's pretty easy to repro.

This would be most helpful!
  _isOwnerNecessary was unused.

cc @facebook/react-core
 üëç
  Hmm, if you can't repro a contained case it might be due to that polyfill or when/how it gets loaded. You should only get that warning if we can't find the iterator function that should be on the object (and we look for that fn with this: https://github.com/facebook/react/blob/master/src/shared/utils/getIteratorFn.js#L32-L40). Since this is a pretty particular case, it might be helpful to try to repro outside of jsfiddle (which is using babel 5 right now so probably different from what you're doing). Maybe just a standalone html & js file & then shared in a gist.
  This is not enough information for this issue to be actionable.  Can you reproduce the bug in a minimal repro/jsfiddle?
 I think the determining factor will be what the value of `props.children` is at that point. I haven't looked to see if there are node types that aren't valid in labels but that's my best guess.
 No response from OP.
 @jineshshah36 Can you please try to reproduce this with a version of React compiled from master? You can grab one from http://react.zpao.com/builds/master/latest/.
 Thanks for following up. If you do figure out what Cloudflare might have been doing to break in such a way, let us know. We might want to work with them to ensure it doesn't happen to others.
 Potentially related to https://github.com/facebook/react/pull/5753#issuecomment-220436362 if you're mounting server-rendered markup.
  This will be fixed by https://github.com/facebook/react/pull/6406, which has also been gathering a bit of dust.  #6406 was intended to supersede #5680.
  > React 0.13.3

I don't know off hand what's going on there, but the react perf stuff did work in 0.13.3, as far as I know.  We don't generally support/debug old versions of React (my recommendation is that you upgrade!).  If you can provide a jsfiddle (using a new version of React) that demonstrates a bug in React, we'll happily look into it!

I'm going to close this out because it's not an actionable bug on our end.  Feel free to continue the discussion on this thread.
 Yeah, we use github for tracking bugs in the master release of React core, so we're pretty proactive about closing out issues like this.  Personally, I'd recommend trying on StackOverflow, which is better setup for getting usage help.
 One thing I‚Äôd check for is whether you don‚Äôt include two copies of React on the page by mistake. This would explain why one of them in unaware of the time spent in the other.
 You can run `npm ls react` and check if you have a duplicate installed by some library.
  We have several minor/subtle issues with styles, all of which get knocked out by this PR.

For instance, `initial render` of a component should be identical to [`initial render`, `different render`, `initial render` again].  That is, the only thing that SHOULD matter is the most recent render.  However, if with our old code, there are edge cases where this is untrue (eg. when specifying a general style and a more specific style).  Example: http://jsfiddle.net/0861av29/  Historically, we've told people "don't do that", but that's not a good answer.  For users, the old code made it hard to solve in general, because this situation often arrises when a parent clones a child and append an additional (more specific) style.  This creates complex interactions between components that are difficult to debug.  Solved by this PR.

Another big fix, this PR also enables vendor prefix for css values, which has been a popular request for a long time.  Syntax looks like this:

```
var styles = {
  padding: 0,
  margin: 0,
  listStyle: 'none',
  display: ['-webkit-box', '-moz-box', '-ms-flexbox', '-webkit-flex'],
  WebkitFlexFlow: 'row wrap',
  justifyContent: 'space-around',
};
```
 We've said in the past that we might want to support `margin: [20, 0]` which this would preclude.
 @spicyj If we wanted to do that, we could support both within React.  Margin would just be a css style that is known to take multiple values (ie. disable vendor prefixing logic for those known styles).  That is, if we do desire to support that behavior.  So I'd say these approaches aren't mutually exclusive.
 `background` is a property that would need both.
 Ok, well, as per discussion, it sounds like we'll go with something like `React.multi(['-webkit-box', '-moz-box', '-ms-flexbox', '-webkit-flex'])` which allows us to punt on the question of using an array as a value.
 We can always bikeshed on the name if we take this route. I also dislike `multi` and think we could make something clearer if we do this.
 @zpao proposal?  I'm very open to ideas.  I'm not attached to this notation/name, but I would like to find something that is acceptable to everyone so we can drive this to completion.
 Haven't thought any more about a name beyond that multi seems overly vague.

Regardless of that, can we pull this apart so we can consider the 2 pieces of this distinctly.
1. use the `style` attribute instead of the CSSOM
2. newly proposed support for specifying multiple values that relies on 1
 Maybe worth running some demos from @chenglou‚Äôs react-motion.
  Eeh, ok.  We generally don't take small changes like this, but this does fix a typo, so I suppose we can take it.
 @jayphelps There is some discussion in https://github.com/facebook/react/pull/6463

Generally, we prefer that you squish it into a more meaningful commit that happens to touch the same file.  The TLDR is that these little micro-changes clutter the commit log for a given file and make it more difficult to track the more meaningful history/changes.
 I think this one is probably fine but I would say we should do a sweep and ensure there are no other places that also need to be updated. This one is a bit different from #6463 since that was a code style change and this is more of a correctness thing.
  Haven't looked into it, but I'll tentatively tag this as a regression since apparently it worked on 0.14.8.

@jslatts sounds like you've started looking into this already.  Do you want to submit a PR for this?
 Is this only happening with IE10? Does this only happen when using the development build? My guess is that it's related to the new warnings for synthetic events so that's where I would start investigating: https://github.com/facebook/react/blob/2af4765a2af0d4de81d2f23f702d9d39d8917a0b/src/renderers/dom/client/syntheticEvents/SyntheticEvent.js#L177
 @jslatts Would you mind verifying in http://jsfiddle.net/9kungxn4/ which is a build that contains the commit you mentioned.
 Excellent, I'll close this out!  Thanks @jslatts!
 It looks like that change isn't likely to make it into 15 so you may be waiting a while for the fix. If there's something smaller that fixes your issue we might be able to take that.
  @zyrolasting Proptypes do (or will soon) become noop functions in production (to save bytes when downloading React in production mode), so they aren't usable in the production build.  Also, as @Aweary mentioned, proptypes are legacy, so we aren't adding new features.

I think your best bet would be to copy-paste the validator code from React into a separate library, which you could then use in production.  Or, like you mentioned, use a third party validation library.

I'm going to close this out for the reasons above.  Feel free to continue the discussion on this thread.
  @gaearon 
 Left some comments. Thanks!
 A few more minor changes, and this is good to go.
 Thank you!
  LGTM
  Any idea whether video/audio source/track are affected too?
 This looks fine to me, so unless anyone has any objections, I'm going to tentatively accept.

@syranide Do you have a demo/example that demonstrates the problem, so we can verify the fix and also see when we regress this?
 üëç Great, thanks @syranide!

Reposting the relevant code here, just so it doesn't get lost if the file on dev.cetrez.com goes away.

``` js
<script>
var Hello = React.createClass({
  render: function() {
    return (
      React.createElement('object', {type: 'application/x-shockwave-flash', data: 'awd', width: 200, height: 200}, [
        React.createElement('param', {name: 'movie', value: 'awd'}),
        React.createElement('param', {name: 'bgcolor', value: '#0000ff'})
      ])
    );
  }
});

ReactDOM.render(
  React.createElement(Hello),
  document.getElementById('container')
);

document.body.style.background = '#cc0000';
</script>
```
 Thanks for sending, just one note inline and then feel free to merge.
 You're right, let's keep the toLowerCase. Forgot about the XHTML case.
 Thanks!
  This is an outline for the new reconciler infrastructure.

I created a noop renderer to have something to get started from.

I split the reconciler folder into old and new, as well as shared. I put shouldUpdateReactComponent in shared as an example of a utility that can easily be shared between both. I plan on breaking out more utilities like these.

Builds on top of #6682
 > have they thus far been informal and undecided and this PR is just to flesh them out?

Yes, I think this is just @sebmarkbage trying to create a useful proof of concept in a way that makes sense to him. The goals are simple: change React from deep recursive rendering on every change to some kind of scheduling.

The way I understand this PR is the following. For scheduling to work, we need some kind of priority system, or otherwise there is no way for React to know which updates should be processed first. ‚ÄúLow‚Äù and ‚Äúhigh‚Äù is the simplest possible way to describe priorities. We don‚Äôt know if more kinds of priorities would be helpful, so starting with two makes sense to me. How they are used is an open question, but it‚Äôs easy to imagine some options. For example, we might want to schedule high priority updates for something is interacting with (e.g. pressing a Like button) because UI should be responsive to feedback. On the other hand, rendering loading data might be a lower priority (i.e. it‚Äôs better to render a new story in the feed with a small delay than cause an animation happening at the same time to drop frames).

If there is any specific algorithm in mind, it‚Äôs in @sebmarkbage‚Äôs head, but I think he‚Äôs just fleshing out a system capable of rendering existing React components with priorities. There‚Äôs really not much to it aside from what I wrote above. The existing reconciler code is deeply OO and relies on recursive dynamic dispatches (e.g. `mountComponent()` of any composite component [causes `mountComponent()` of whatever it renders to](https://github.com/facebook/react/blob/b6a60781677bcdace8f41457d50412096f98d74a/src/renderers/shared/reconciler/ReactCompositeComponent.js#L474)) so it‚Äôs hard to shove priorities into the existing system. This is why @sebmarkbage is starting the reconciler from scratch in this PR. It‚Äôs not clear how long it will take to get to the feature parity, but we‚Äôll see.
 Also, for the record, I don‚Äôt understand what `Fiber`s are either yet üòÑ . The `EffectHandler` and `EffectTag` reminds me of [this post by @sebmarkbage about algebraic effects](https://esdiscuss.org/topic/one-shot-delimited-continuations-with-effect-handlers). The gist of ‚Äúeffects‚Äù in [Eff](http://www.eff-lang.org) is that functions can throw ‚Äúeffects‚Äù and not just errors, and their callers can ‚Äúcatch‚Äù these effects, do something, and then yield back to the child function.

This sounds a lot like what React components want to do. Today, we can say `setState()` is like an effect because it schedules an update to the system. But we want React components to be able to do more and to provide more ways for children and parent to communicate. This is crucial for supporting layout in React: you want a child to ‚Äúyield‚Äù its size to the parent while rendering so that the parent can use this size to set the child‚Äôs position. Some notes on a system like this [have been posted in react-future two years ago](https://github.com/reactjs/react-future/blob/ba5a275d08451756137559714d79f15055b9a14e/04%20-%20Layout/02%20-%20Layout%20Components.js) but this wasn‚Äôt being worked on. However, two months ago @sebmarkbage, inspired by effects in Eff, made another prototype of a system that would support layout, [also in react-future](https://github.com/reactjs/react-future/blob/ba5a275d08451756137559714d79f15055b9a14e/04%20-%20Layout/prototype/index.js).

Another example is context: we want context updates to be fast, as it is useful for layout and animations, but the current system involves walking the whole tree to update the context which causes issues like #2517. If context was also an effect, and we built support for effects handled by parent components (or React itself) in React, this would probably get solved as well.

Since we don‚Äôt actually have algebraic effects in JavaScript, my guess would be that `Fiber`s are some sort of internal abstraction for connecting functions that ‚Äúthrow‚Äù effects directly to the functions that handle them. But this may change any day as @sebmarkbage‚Äôs still trying different approaches to see what is minimally needed to implement a scheduling reconciler while ensuring future use cases like layout in React are supported better than in the current model.

I might be totally wrong though!

You might also find this helpful: https://github.com/reactjs/react-basic. Especially https://github.com/reactjs/react-basic#algebraic-effects. This is pretty much a braindump of what @sebmarkbage has been thinking about for the past few months. I think the new reconciler will move closer to this _conceptual_ model of React than the existing one, although of course implementation details will still differ from the conceptual model because we live in a real world. üòÑ 
 Fibers as a concept is essentially https://en.m.wikipedia.org/wiki/Fiber_(computer_science) reimplemented in user space.

But yea, I don't really know what I'm doing yet. I have a rough idea.

> On May 5, 2016, at 4:47 AM, Dan Abramov notifications@github.com wrote:
> 
> Also, for the record, I don‚Äôt understand what Fibers are either yet üòÑ . The EffectHandler and EffectTag reminds me of this post by @sebmarkbage about algebraic effects. The gist of ‚Äúeffects‚Äù in Eff is that functions can throw ‚Äúeffects‚Äù and not just errors, and their callers can ‚Äúcatch‚Äù these effects, do something, and then yield back to the child function.
> 
> This sounds a lot like what React components want to do. Today, we can say setState() is like an effect because it schedules an update to the system. But we want React components to be able to do more and to provide more ways for children and parent to communicate. This is crucial for supporting layout in React: you want a child to ‚Äúyield‚Äù its size to the parent while rendering so that the parent can use this size to set the child‚Äôs position. Some notes on a system like this have been posted in react-future two years ago but this wasn‚Äôt being worked on. However, two months ago @sebmarkbage, inspired by effects in Eff, made another prototype of a system that would support layout, also in react-future.
> 
> Since we don‚Äôt actually have algebraic effects in JavaScript, my guess would be that Fibers are some sort of internal abstraction for this pattern of ‚Äúthrowing‚Äù effects and having callers handle them. But this may change any day as @sebmarkbage‚Äôs still trying different approaches to see what is minimally needed to implement a scheduling reconciler while ensuring future use cases like layout in React are supported better than in the current model.
> 
> ‚Äî
> You are receiving this because you were mentioned.
> Reply to this email directly or view it on GitHub
 Meh, okay.
  Looks good, thanks!
  I don't think trying to involve gulp here will be beneficial. Learning from the compilation options that are happening there might be valuable but not the rest of the gulp stuff since we're doing compilation in the jest preprocessor.
  @zpao @spicyj 
 We already have a `.babelrc` in there and the version is not needed since we don't publish this. Could you strip this down to just updating the React dependencies?
 Bah, I thought I fixed the babelrc packaging issue with #6617. Sorry about that. I'll try that again‚Ä¶
 Thanks! And thanks for catching the issue with the babelrc. I have a proper fix for that now so we'll avoid the issue in the future.
  Depends on #6682, currently looking at the root for .flowconfig but can be changed as needed. cc @sebmarkbage
 Seems good. Grunt is weird.
 Ok. If you rebase, it should pass.
 Alright, locked in at Flow 0.24.0 since that's what we have installed (and our flowconfig expects that). I also ensured we're using latest fbjs which comes with a `Promise.js` lib file with the non-standard methods that we're (where we just means other code in fbjs) using.
  This just configures flow to be checked and fixes our existing Flow typed files.

Test Plan:

flow

Possible enhancements:

Export .js.flow declarations from the build. Unclear whether this will be a supported workflow in the future or not, so let's wait on that.

We should fail builds and CI on Flow errors.

Ideally we should lint for Flow style guides (like no space before colon).
 @zpao You want to help set up CI for this and add it to the grunt builds maybe?
 I'm good with this.
 It's just RN files presently, right?
 @zpao Can move the flowconfig deeper if he feels strongly about it. I'm worried about syncing to www bringing it in and what is the recommended best practice for checking things outside the tree.
  Probably a duplicate of https://github.com/facebook/react/issues/6538
  Thanks :)
  This reverts #6458 and then implements the goal of that PR without affecting the output.

While I agree that #6458 is "safe", it's a subtle behavior change in the generated output and I think we shouldn't take it in the branch. In `master` we should make the change to stop appending `px` to all strings (not just `'0'`).
 LGTM
 (I believe you‚Äôll need #6458 when cherry-picking this though?)
 > (I believe you‚Äôll need #6458 when cherry-picking this though?)

I'll special case this and cherry-pick just the 2nd commit here instead of landing and reverting.
  These should be disabled as others have said but if you can reproduce & share a case where they aren't, that would be helpful. And _just in case_ you weren't abbreviating in your comment, make sure you have `NODE_ENV` set to `production` not `prod`. I'm going to close out but we can reopen if need be.
  This is a usage question about webpack/commonjs, rather than a bug in the React core. Usage questions are better answered on sites like StackOverflow, as we try to use github issues for tracking bugs in the React core. For this reason, I'm going to close out this issue, which takes it off our radar, but feel free to continue the conversation here (or move it to StackOverflow).
  We don't do a blog post for every release but we did update the releases page. I neglected to cherry-pick some commits over to master with what landed in the release branch but they are there now.
  –†–µ–∫–æ–º–µ–Ω–¥—É—é –ø–æ—á–∏—Ç–∞—Ç—å http://www.vavilon.ru/noragal/slovo2.html ‚Äî –º–Ω–æ–≥–æ –ø—Ä–æ–±–ª–µ–º —Å–≤—è–∑–∞–Ω–Ω—ã—Ö —Å –Ω–µ—É–∫–ª—é–∂–∏–º —è–∑—ã–∫–æ–º. –ù–æ –µ—Å–ª–∏ –ø—Ä–∏—á–µ—Å–∞—Ç—å —Ç–µ –º–µ—Å—Ç–∞, –∫–æ—Ç–æ—Ä—ã–µ —è –ø–æ–º–µ—Ç–∏–ª, –≤ —Ü–µ–ª–æ–º –±—É–¥–µ—Ç –Ω–æ—Ä–º–∞–ª—å–Ω–æ.

–ë–æ–ª—å—à–æ–µ —Å–ø–∞—Å–∏–±–æ, —á—Ç–æ –Ω–∞—à–ª–∏ –≤—Ä–µ–º—è!
 > –°–∫–∞–∂–∏, –º–æ–≥—É –ª–∏ —è –¥–æ–±–∞–≤–ª—è—Ç—å –≤ –ø–µ—Ä–µ–≤–æ–¥ –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏—è, –∫–æ—Ç–æ—Ä—ã—Ö –Ω–µ—Ç –≤ –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω–æ–º —Ç–µ–∫—Å—Ç–µ, –Ω–æ –∫–æ—Ç–æ—Ä—ã–µ –ø–æ–º–æ–≥—É—Ç –º–Ω–µ –±–æ–ª–µ–µ —è—Å–Ω–æ –≤—ã—Ä–∞–∑–∏—Ç—å —Å–≤–æ—é –º—ã—Å–ª—å? 

–ù–µ—Ç, –≤—Å—ë-—Ç–∞–∫–∏ —ç—Ç–æ –ø–µ—Ä–µ–≤–æ–¥, —Ç–∞–∫ —á—Ç–æ –∫–∞–∂–¥–æ–µ –ø–µ—Ä–µ–≤–µ–¥–µ–Ω–Ω–æ–µ –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–µ –¥–æ–ª–∂–Ω–æ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–æ–≤–∞—Ç—å –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω–æ–º—É. –ê –≤–æ—Ç –ø–µ—Ä–µ—Ñ—Ä–∞–∑–∏—Ä–æ–≤–∞—Ç—å —Å–∞–º–∏ –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏—è —á–∞—Å—Ç–æ –Ω—É–∂–Ω–æ, —Ç.–∫. –∫–∞–ª—å–∫–∞, –∫–∞–∫ –ø—Ä–∞–≤–∏–ª–æ, –≤—Å—ë-—Ç–∞–∫–∏ –Ω–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π –ø–µ—Ä–µ–≤–æ–¥.

> –ò –µ—â—ë, –º–Ω–æ–≥–∏–µ —Ç–µ—Ä–º–∏–Ω—ã, —Ç–∞–∫–∏–µ –∫–∞–∫ —Ä–µ–Ω–¥–µ—Ä–∏–Ω–≥, –º—ç–ø–∏–Ω–≥, –∫–æ–ª–±—ç–∫, –±–∏–Ω–¥–∏–Ω–≥ –∏ –¥—Ä. —É–∂–µ —É—Å—Ç–æ—è–ª–∏—Å—å –≤ —è–∑—ã–∫–µ —Ä–∞–∑—Ä–∞–±–æ—Ç—á–∏–∫–æ–≤, –Ω–æ –∏—Ö —Ä–∞–∑—ä—è—Å–Ω–µ–Ω–∏—è –Ω–µ—Ç –≤ –≤–∏–∫–∏–ø–µ–¥–∏–∏. –ú–æ–∂–Ω–æ –ª–∏ –∏—Ö –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –≤ –ø–µ—Ä–µ–≤–æ–¥–µ –∏–ª–∏ –∑–∞–º–µ–Ω—è—Ç—å –∏—Ö –¥—Ä—É–≥–∏–º–∏, –±–æ–ª–µ–µ –ø–æ–Ω—è—Ç–Ω—ã–º–∏ —Å–ª–æ–≤–∞–º–∏?

–Ø –±—ã —Ä–µ–∫–æ–º–µ–Ω–¥–æ–≤–∞–ª –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å —Ç–µ—Ä–º–∏–Ω—ã –∫–æ—Ç–æ—Ä—ã–µ –ª–∏–±–æ –∏—Å–ø–æ–ª—å–∑—É—é—Ç—Å—è –≤ –≤–∏–∫–∏–ø–µ–¥–∏–∏, –ª–∏–±–æ –≤ —É—Å—Ç–æ—è–≤—à–µ–π—Å—è —Ä—É—Å—Å–∫–æ—è–∑—ã—á–Ω–æ–π –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏–∏ (–Ω–∞–ø—Ä–∏–º–µ—Ä, –∫ –∫–∞–∫–æ–π-–Ω–∏–±—É–¥—å –±–∏–±–ª–∏–æ—Ç–µ–∫–µ –Ø–Ω–¥–µ–∫—Å–∞ üòÑ ). 
 This looks much better, thanks! Left some more feedback.
 One last nitpick above and this is good to go. Thank you!
  @zenjava can you provide a jsfiddle that demonstrates the issue?

Also, I'm wondering if this might be an issue unrelated to React, because it appears you are breaking out of React and interacting with the element directly.
 No response from OP.
  Also, looks like there are merge conflicts.
 I think this is ready to merge.
 Ok, thanks @Yaxian and @keyanzhang!
  Thanks @wincent!
  Duplicate of https://github.com/facebook/react/issues/6441
  Seems reasonable to have this and have it be optional. Any thoughts @spicyj? (in particular, iI'm wondering about potentially changing PureRenderMixin as well)
 Seems fine to me if we remove the undefined check ‚Äì let's change PureRenderMixin too.
 Ping @tony99nyr
 Thanks @tony99nyr!
 I just realized this is a breaking change. If someone calls `shallowCompare(this, nextProps, nextState)` manually, it may have returned false before but would always return true now. This broke a component at FB that ended up updating endlessly because it would setState to the same state values, expecting it not to rerender.

Bad component design, but maybe we do want the undefined check after all. Can we revert this for now? I have to work around this at FB until we do.
 I'd prefer to fix-forward instead of revert, if possible/practical.  Can you just comment out this change on www so we have a little time to fix this up before our next sync?

Checking for undefined seems like a reasonable path forward here.  Or we could add a `shallowCompareWithContext` function.
 > I'd prefer to fix forward instead of revert, if possible/practical.

Why? It doesn't slow us down (except for an artifically-created sense of urgency) and master is unbroken in the meantime.

> Can you just comment out this change on www so we have a little time to fix this up before our next sync?

Yes, though it's always preferable that master actually matches what we're using.
 (There's also little chance of merge conflicts, which would be the typical reason for pushing forward.)
 > Why?

Fixing forward makes it easier to reason about what changes are actually in master.  It reduces churn, makes the diffs much easier to follow.  It reduces the probability of breaking someone who was depending on a merged commit (related to merge conflicts, except harder to detect since it's not caught by git).  It reduces the probability of us undoing a feature and then never re-introducing it (https://github.com/facebook/react/pull/6364).  It closes a whole can of worms (for instance, should we revert the wrapping of events because it breaks IE/edge in some cases: https://github.com/facebook/react/issues/5700, or should we fix forward).

In this particular case, it's basically a two line diff, so it is easy to go forward/back and it probably doesn't matter one way or the other.  But in general, it seems better to always fix forward when possible/practical.
 I disagree that #6364 is an argument in favor of not reverting: rather, I see that if it had stayed in master than master would still be broken. Fixing forward makes it easier to reason about what's in "master" but if we're not running master because it's broken and we need to patch it locally to get it to run, I'm not sure what value that provides. You're right that it helps people who were depending on the merged functionality but somehow weren't affected by the bug.
 Regarding #6364, master is still broken either way.  Reverting just traded one bug for a different bug.  Unless we go back all the way and revert https://github.com/facebook/react/pull/4182, master will still be broken.  I think the whole #6364 thing is a perfect example of why we should try to always fix forward (when possible/practical).

I'm actually fine with reverting this particular commit, if that's what we decide to do. I wasn't entirely sold on the value of this commit in the first place; I think all the shallowCompare stuff should be moved to userland anyway.  But I was not ok with the fact that we reverted #6364 without discussion - I think that was the wrong call.

If we want to revert this commit, that's fine, but it would be preferable if we can find a fix forward.
 Please revert and followup with the correct fix. That should be the way we operate. It's on the reverter & reviewer to ensure we actually followup.

Further, the change to `ReactComponentWithPureRenderMixin` is definitely a breaking change and should actually land separately so we can take the `shallowCompare` change in the stable branch (once it's not breaking).
 Reverted in #6877.
  Thank you for your work on this! I left a few comments that I think need to be addressed before this gets merged. Cheers!
 Aside from a minor nitpick, this looks great. Thanks for coming back and addressing my comments. Cheers!
  The best practices for form validation are the same as our best practices for React in general.  One-way data flow, create reusable components, etc.  I don't think we have any opinions that are specific to form validation.
 > This isn‚Äôt updating props.

It is updating `this.state.value` **which is a prop to the `input`**:

``` js
  render: function() {
    return (
      <input
        type="text"
        value={this.state.value} // <--- here
```

When the docs talk about controlled and uncontrolled components, they mean `<input>`s and other DOM components themselves‚Äî_not_ user‚Äôs components.

In this example `<input>` is a controlled component because it receives its `value` as a prop. If it wasn‚Äôt controlled, it would maintain _its own_ state (invisible to you) that you would be unable to modify from inside _your_ parent component‚Äîwhich is why it would be uncontrolled.
 This is React top-down data flow:
- Your component maintains some state 
- It passes this state as a prop down to another component
- That component passes it as a prop down to another component
- ...

This way it‚Äôs easy to trace any prop up the tree to the `state` it originated from.
This is the case described in https://facebook.github.io/react/docs/forms.html#controlled-components.

On the other hand, this is an anti-pattern:
- Your component maintains some state 
- It passes this state as a prop down to another component
- That component passes it as a prop down to another component **which uses this prop to initialize its own state**
- It passes that own state down as a prop to another component
- ...

This is the case described in https://facebook.github.io/react/tips/props-in-getInitialState-as-anti-pattern.html. It is an anti-pattern because the bold part is where you can get out of sync issues, and everything below that component may potentially receive props that are out of sync.

Summary:
- Passing props to children based on own state is good
- Basing own state on own props is generally not good
  Changed "**a** uncontrolled input" to "**an** uncontrolled input".
 @jakeboone02 You will need to fix the unit tests to match.  See https://github.com/facebook/react/pull/6591/files
 Thanks, @jimfb.  I didn't see #6591.  Looks like that covers it, so I'll close this one.
 @jakeboone02 The original author of that PR hasn't responded in a week.  If you want to fix the tests in your PR, we could merge this one.  Your call.
 Looks good, just same comment as in the other PR.
 OK, working on this.  I'll squash to one commit as well.
 Thanks @jakeboone02!
  It's way too much work to do a React release right now. It's mostly muscle memory for me at this point but it should be easy for anybody to do it. Historically I kept certain steps manual because I screwed things up and wanted to be able to pause and double check.

There are a few things contributing to the difficulty:
- use of react-bower repo as the first push target
  - which is a result of fb.me link generation / CDNization needing to happen on internal FB infra
- manual steps across multiple repos
- manual version modification
- assets needing to be in multiple places, copied across branches

A few ideas:
- we should be able to differentiate between pre- and final releases. It should be a single command to ship a new alpha at any point and they should be lightweight.
- final releases need a little more since they will get installed by default by people and have additional requirements (eg changelogs, assets in multiple places)
- `npm run release` which then does all the things. It could be an interactive process
- start using the GitHub releases APIs to store build assets, cutting out steps
- set up cdn.reactjs.org and just host our builds there, dropping fb.me entirely (risk, we have to run this forever‚Ä¶)
  - alternatives: work with existing CDNs and make sure we can have versions deployed on command (pull based autoupdating can result in delays, things like jsfiddle, our tutorial need assets available immediately)
- investigate lerna, could be helpful with the multiple packages we have, though we ideally want to disentangle the releases
 > alternatives: work with existing CDNs and make sure we can have versions deployed on command (pull based autoupdating can result in delays, things like jsfiddle, our tutorial need assets available immediately)

With Redux, we‚Äôve been directing people to @mjackson‚Äôs http://npmcdn.com.
  Yes, this is expected because elements are checked at the creation time. So when you write `<MyComponent />`, it turns into a `React.createElement()` call, and the props are validated.

When you rely on `cloneElement()` to specify required props, our recommendation is to use `defaultProps` in your component for sensible fallbacks, e.g.

``` js
MyComponent.defaultProps = {
  onSubmit: () => {}
}
```
  The code here feels a little convoluted but I don't know how to make it clearer. Suggestions welcome.

cc @facebook/react-core

Fixes #2410. Fixes #6371. Fixes #6538.

I also manually tested the codepen in #3762 and verified it now works.
 Looks good to me.  Let's ship it.  üëç 
 :+1:
 As discussed in person: If componentWillUnmount is allowed to have side-effects (which I think it needs to because unsubscribing is a side-effect) which includes setState on another component, then it should be outside of the reconciliation pass which is supposed to be side-effect free. Maybe we should queue/defer unmounts?
 Going to bump this to 15.x since it doesn't apply cleanly without some of the things we're taking there. Shouldn't matter too much in terms of timing.
  Release tracking: semver-patch because it's just a bug fix, but it's dependent on #5746 so can't cherry-pick until that is in.
  This removes the old ReactPerf implementation and replaces it with the one from #6046.
Corresponding React Native PR: https://github.com/facebook/react-native/pull/7283

To be exact:
- The old `ReactPerf`, `ReactDefaultPerf`, and `ReactPerfAnalysis` are removed.
- `ReactDebugTool` (added in #6046) takes care of measurements, and `ReactPerfAnalysis` is renamed to just `ReactPerf`.
 @gaearon updated the pull request.
 @sebmarkbage 

This is ready for review now, and has tests salvaged from the previous implementation.
I tested this with https://github.com/facebook/react-native/pull/7283, and it works well.
 Rebased on the current master.
@sebmarkbage Can you please take a look until this gets merge conflicts again? üòÑ 
 What's the summary of the current state of the new perf? Where have it been deployed? As anyone other than us tested it?

Seems good to at least have some eyes on it before we kill the old one forever, no?

> On May 3, 2016, at 6:22 AM, Dan Abramov notifications@github.com wrote:
> 
> Rebased on the current master.
> @sebmarkbage Can you please take a look until this gets merge conflicts again? üòÑ
> 
> ‚Äî
> You are receiving this because you were mentioned.
> Reply to this email directly or view it on GitHub
 I tested it on some of the open source apps/examples that I maintain. The results are consistent with what I‚Äôd expect them to be. Internally we don‚Äôt really use the console version of ReactPerf so I‚Äôm not sure what you mean by having it deployed. 

> Has anyone other than us tested it?

No, but we can cut 15.1.0-alpha and ask people to try.

> Seems good to at least have some eyes on it before we kill the old one forever, no?

Sure, I agree. I still think it‚Äôs safe to land in master because if we find bugs, we can add more test cases for them. I don‚Äôt think we‚Äôll find bugs though until we release this in some form.
 Ping @sebmarkbage, anything I can do on my side?
 Ok. Hope this works! :)
 Let‚Äôs cut 15.1.0-alpha with this? I have some people in mind who might help us test it!
cc @slorber
  The "React Way" is to store your application state higher up (eg. in a [Flux](https://facebook.github.io/flux/docs/overview.html) store).  React only renders your current state, so you never need to send "events" down to children.  The "events" change your application state (eg. the scroll position), and you pass the current scroll position down as a prop.

Of course, React does allow you to model your application state at lower level components, and you can then get a ref to a the component and call functions on that component, but this has always been an escape hatch rather than a recommended pattern.

A general rule of thumb is that the parent component should never be telling a child to "do something", and should never be "asking" a child anything.  Obviously there are exceptions to every rule (that's what refs are for) but as a first order approximation it's true.  If you find yourself breaking this rule often, it's an indication that you should probably rethink the data flow of your application (and specifically, rethink where state is being stored).
 > ... covers maybe 95% of real-world dev cases. For the outlier cases that don't fit that pattern, as you mention, we can use refs. But the reality is that this doesn't work, and is a pretty non-React-like workaround for what I see as a normal, valid subset of use cases.

For the other 5%, we're ok with you breaking out using one of the escape hatches.  We're constantly working to reduce this 5% down to 1% and then down to 0.1%, but we're still getting there.  The fact that it's non-react-like is a symptom of the fact that you're now working directly with the underlying platform, having escaped out of React.  The most common use cases for escape hatches today are layout, animations, etc.  We are actively working on these topics, and we have some ideas, but there are a lot of complexities that aren't necessary obvious at first glance and we want to make sure that we "get it right".

In general, however, React does a pretty good job covering the common use cases.  Usually, when people complain that something is difficult or that they are breaking out of React too often, it's because their mental model is wrong.  They're still thinking imperatively, instead of thinking declaratively.  It's not always easy to retrain your brain, and so it's easy to fall into the imperative trap without even realizing it.

>  Another example is list items in a parent scroll container that need to all animate at specific times, which also needs to play well with their lifecycles as items are added/removed/changed. "I need to animate now" is not a piece of state, it's a time-based message that doesn't need to be retained.

That is the imperative way of looking at it.  But there are other models that are equally valid, and perhaps even better (more flexible).  For instance, suppose someone removes a node, but then a fraction of a second later decides "actually, we're aborting that operation, put it back!".  You want the animation to effectively slow down and then reverse its self.  The imperative "fire-and-forget" model for animations does not work well in that situation, but a declarative spring model (where the component's position is modeled by a spring whom's position is derived over time) works really well in the general case.  Our current thinking is probably closest to what is described here: https://facebook.github.io/react-native/docs/animations.html

In the most general sense, the declarative way of looking at events is as a set (list) of timestamped objects.  When a new event "occurs", it is simply added to the list.  The list is a constant value, which may reasonably be passed as props.  And now you've completely eliminated the need to "fire an event" in a sense.

> The one-way communication model could be expanded to include either stateful/persistent or one-time-use information. These are two distinctly different types of information that could be communicated in a similar way. Best practices could be defined around when to use which.

The "two distinctly different types of information" aren't distinct, because you can convert between the two.  "one-time-use information" becomes declarative "state" if you save it into a list.

I'm not saying that we would never go down such a route.  Jordan had some wild ideas a year back about making all components a pure function of signals (events).  (ie. nothing is stateful, everything is an event transform).  This has some interesting properties, especially because it makes "history" and time-travel debugging super easy.

Anyway, it's a big design space, and we're thinking about it.

> React's diffing engine (a great thing in itself) often makes these cases even more painful to solve.

Totally agree, there is no perfect solution.  We try to make React as painless as we can.

## 

I don't want to re-open, only because there is nothing actionable here at the moment.  We understand the desire/use case, and we regularly have team discussions about such topics.  But we use github issues for tracking actionable bugs (not discussions or questions).  We use issues to track things that have a plan forward (or at least a strong candidate proposal).  In this case, the only thing we know for sure is that we want to avoid anything that feels imperative (like an "event" "firing").  But rest assured, we are thinking about the problem.

Feel free to continue the discussion on this thread.  I can't guarantee I'll respond to every post, but I do read pretty much everything that passes through github.  Another place that such discussions can take place is https://discuss.reactjs.org/
  Yea, this should be fine. Thanks :)
 Not much we can do if it's a dep we don't own. If you want to hunt it down and file an issue against whatever package is to blame, I encourage that :)
 Nah, we generally recommend using (and most/all of the team uses) LTS versions for sanity so I think we'll just do that on Travis to cut down on the build matrix. Build output _should_ be the same regardless.
  @sebmarkbage @zpao 
 You can also just move them up one level. I only kept this folder structure while I was constantly rebasing.
 Accepted. Feel free to hit Squash and Merge when you're ready.
  I would like to keep the surface area that we expose to React as minimal as possible. E.g. UIManager, FocusState. Would you mind creating an indirection like `ReactNativeEvent.listen()` or something? I just don't want to take on all of BatchedBridge if that makes sense.
 Yea. That would work. I just want to make sure that people submitting PRs to React Core realize that all of BatchedBridge is not available.

Basically this is the equivalent of adding eventlisteners in document.body for DOM and we have an opportunity to unify these if we don't take on too many more dependencies.
 We could further simplify this and have one bridging module/interface for both UIManager and other callable module configuration, but it seems cleaner to split them out by area for now.
  The code you reference appears to be general d3 javascript, and the event does not pass through React's event system.  This looks like a d3 question, unrelated to React.  For this reason, I'm going to close out this issue.

On another note, you should use a `ref` to reference a DOM node, NOT selecting by ID.  Using things like `d3.select("#viewport")` can cause interoperability issues with other components that happen to choose the same ID, and prevent a component from being used multiple times on the same page.  Using a `ref` will solve these issues.
  There's a bunch in here so getting this up to track now that I pulled in everything that wasn't RN related.

The full list: https://github.com/facebook/react/issues?q=milestone%3A15.0.2+is%3Aclosed

Still have to do the actual release bits but we're about there. Note: if you want to try this out now, I just published `15.0.2-alpha.4`.
  @ev1stensberg Hey, I've noticed you've been doing a few PRs lately, which is great. However a lot of them haven't made much progress. One of the things I'd like for us to do more of is discuss changes in behavior in an issue before implementing them. This allows discussion of the idea to happen and can shape & clarify the plan before any code gets changed. For example, filing an issue declaring your goal of warning when `initialState` is `null` would have been a great place to kick off the discussion and may have lead to a clearer indication of where that change would have to be made. Keep it up, but let's make sure we focus on the right things :)
 @ev1stensberg https://github.com/facebook/react/issues?q=is%3Aissue+is%3Aopen+label%3A%22good+first+bug%22
 As of right now there is no specific roadmap. We might create a special repo for tracking it, but we haven‚Äôt committed to doing this yet.

In the meantime, as @jimfb notes, [good first bug](https://github.com/facebook/react/issues?q=is%3Aopen+is%3Aissue+label%3A%22good+first+bug%22) is usually a good place to start. Please make sure to check that if you want to work on an issue, nobody else is already working on it, and leave comment stating you‚Äôd like to help, so nobody starts working on it right after you.

For changes like this PR, it‚Äôs absolutely fine just to raise an issue with a suggestion first. This issue tracker is a good place for this.
 > Problem with issue tracker, is that the issue gets closed straight away without a good discussion that helps towards a complete solution.
> 
> If its closed, it gets trashed and forgotten. Still waiting for someone to answer my closed thread on transferring state through props, but I know it won't be much of help when it's closed.

Generally this doesn‚Äôt happen when we understand _why_ you are trying to accomplish something, and it matches what we‚Äôd like to see in React. [This issue](https://github.com/facebook/react/issues/6114) is a good example of this at work: somebody saw a problem in React and explained it, the team agreed this is something they would like to see, and somebody else [came along to implement it](https://github.com/facebook/react/pull/6121).

However, issues like #6616 are harder to discuss because they lack the essential context:
- Why are you implementing this?
- How will this help you build your app, and will this be useful for teams at Facebook?
- Does this require API changes, and why are they justified?
- Can you show an external interest in this feature from other users of React?

When an issue fails to address these questions, keeping it open doesn‚Äôt help anyone because it is not actionable for the team or anyone else.

On the other hand, focused, easy to understand issues like #6114 that don‚Äôt affect the public API are usually a better way to start contributing.

I hope this helps! We mean well.
  I think this should be fixed by #6570. Not released yet.
  This makes #6549 work with React Native.
Note the big test is the key part but GitHub UI skips it:

https://github.com/gaearon/react/blob/6173bdd6c460a5fa5cb8547c57dd789b946848a9/src/isomorphic/devtools/__tests__/ReactComponentTreeDevtool-test.native.js

I copy-pasted all tests from the main suite but edited to reflect some specifics of RN.
 What's the test plan here? You should probably test this in the actual React Native environment since our tests here are still poor.
 Will do tomorrow!
 Works well with `UIExplorer`:

<img width="505" alt="screen shot 2016-04-29 at 16 06 50" src="https://cloud.githubusercontent.com/assets/810438/14920270/7d9d6e16-0e24-11e6-8384-02c9afbbc7d6.png">
  `componentDidEnter` and `componentDidLeave` both log `did appear` in your code sample. Might this be the issue?
  If an object gets created when the `object` tag is appended to the document, then probably.
 That seems reasonable. The fact that this took weeks to be reported suggests to me that few people are in this situation. Were you not able to get your patch #6640 to work? Why not?
  Another thing we don‚Äôt currently document here is that you can return `null` from `render()` and, since 15, from functional components. This is probably an omission.

Maybe something like

```
type ReactNodeList = ReactNode | ReactEmpty | undefined;

type ReactEmpty = null | boolean;

---

type ReactComponent<TProps> = {
  props : TProps,
  render : () => ReactElement | ReactEmpty
};

type ReactStatelessComponent<TProps> = (TProps) => ReactElement | ReactEmpty;
```

would be more correct.
 I don't think returning undefined was ever supported. It is in ReactEmpty because ReactEmpty was not used as return value. Essentially returning null or false doesn't seem documented today at all. I'm just proposing one possible way to fix this. 
 I‚Äôd say let‚Äôs not tackle `null` here, it‚Äôs a separate issue.
Please change `ReactStatelessComponent` to `ReactFunctionalComponent`, and this is good to go.

Thanks. üëç 
 Thank you!
  As discussed in #6015, we plan to add a new build configuration that does _not_ have the `__DEV__` overhead but that comes with the new `ReactPerf` enabled.

This means that developer warnings, etc, will need to be gated by `__DEV__`, but the component tree (#6549) and some other events (e.g. #6612) will need to be gated by `__PROFILE__`.

I‚Äôm curious how this could be implemented. Right now our system is simple:
### Current System
#### Variables
- `__DEV__ = (process.env.NODE_ENV !== 'production')`
#### Development Build (any `NODE_ENV` except `'production'`)
- `__DEV__` is `true`
#### Production Build (`NODE_ENV` is `'production'`)
- `__DEV__` is `false`

As you can see, if `process.env.NODE_ENV` is omitted, we assume `__DEV__` mode. This is a sensible assumption, and not the one we want to change, as most projects today don‚Äôt specify anything as `NODE_ENV` in development, and we don‚Äôt want them to suddenly lose all developer warnings.

Therefore, I propose the following new system:
### Proposed System
#### Variables
- `__DEV__ = (process.env.NODE_ENV !== 'profile' && process.env.NODE_ENV !== 'production')`
- `__PROFILE__ = (process.env.NODE_ENV === 'profile'`)
#### Development Build (any `NODE_ENV` except `'profile'` or `'production'`)
- `__DEV__` is `true`
- `__PROFILE__` is `true`
#### Profile Build (`NODE_ENV` is `'profile'`)
- `__DEV__` is `false`
- `__PROFILE__` is `true`
#### Production Build (`NODE_ENV` is `'production'`)
- `__DEV__` is `false`
- `__PROFILE__` is `false`

This would let us have three separate build configurations. We can use the same pattern in other `fbjs` projects as well, if desired. I would say it‚Äôs unlikely we‚Äôd ever want to add a separate fourth configuration so this should cover all our needs.

Any thoughts why this would be a bad idea? Should I implement this in `fbjs`?

cc @facebook/react-core 
 If we go with this system, we‚Äôll also probably want to run some tests (like `ReactPerf` tests) with `__DEV__` set to `false` but `__PROFILE__` set to `true`, to emulate the profile build.
 Makes sense to me. The only issue here is what we do about internal Facebook code and React Native because this system doesn't exist there. We would probably need to make this push universal and talk to stakeholders instead of just going our own way. At the very least we'll need a way to deploy this to www where we don't use the pre-compiled version. cc @zpao 
  Ref: https://github.com/facebook/react/issues/631#issuecomment-214909216

It's a little surprising that the codepath is even being hit, maybe that's a bug too, but there should clearly be some sort of `if` check in that area.
 We have a `ReactServerRenderingTransaction` type that gets used instead of the regular `ReactReconcileTransaction`.
 Could be that simple. You might have some issues checking types since
there's pooling on these transactions and instanceOf might not work (I
don't recall)

On Wed, Apr 27, 2016 at 11:20 AM, Brandon Dail notifications@github.com
wrote:

> So this would just adding a check to the warning invariant checking if
> the transaction argument is not ReactServerRenderingTransaction at
> src/renderers/dom/shared/ReactDOMComponent.js#L212-L220
> https://github.com/facebook/react/blob/76a4c46dbaadfd4e717aec7a9e401251cb9b402c/src/renderers/dom/shared/ReactDOMComponent.js#L212-L220
> ?
> 
> ‚Äî
> You are receiving this because you commented.
> Reply to this email directly or view it on GitHub
> https://github.com/facebook/react/issues/6626#issuecomment-215180637
 It sounds like @Aweary might be giving it a try. If not, then you are more then welcome @RaitoBezarius
 I think at this point I would prefer we make use of the canonical source of information at that point, not environment details to. It's an explicit vs implicit difference (and the implicit could be wrong as code changes in the future). If we need we could potentially add more details to the transactions so that checking attributes is safe without adding a dependency for instanceOf.
 Might want to change the name (I might call it something like `isServerRendering`), but if that's the approach we need to take then it's doable. I haven't looked at this code to say if that's definitely the right approach, I'll let you tell me if that's necessary :)
  The old code was fine as-is.  We generally don't take small diffs that don't impact functionality because they clutter up the commit logs.  I think I've mentioned this before in https://github.com/facebook/react/pull/6558#issuecomment-212650273
  Good catch. Would you like to work on adding the information about functional components to this page?
 Everyone on the team is busy with different things, and the team is small, so any help, especially in the area of the docs, is very appreciated. If you do decide to submit a PR, we will definitely review it and if there‚Äôs anything we‚Äôd rather see differently, we‚Äôll let you know. Even if we don‚Äôt end up accepting it, we might use some parts later. It‚Äôs your call but if you have time, we‚Äôd love to get your help on it.
  Looks good to me üëç 

I like that you added the locations, that was a nice touch.

cc @zpao 
 Thanks!
  cc @aickin who is experimenting with changing how server markup is validated in #6618
 @nickdima I would recommend figuring out why the DOM differs.  You should be fixing those errors anyway, and that's the "theoretically correct" solution.

When validation fails, there is the question of "what todo".  React needs to be able to update the DOM (that's its job, after all), but if there are arbitrarily wrong nodes in the render tree, it's not obvious how updates should occur.  In such situations, React just blows away the entire render tree and starts from scratch, thus ensuring that everything matches.  This has the side effect of clearing any DOM state (for better or for worse).

I think Sebastian likes the current behavior (always blow away the entire tree if validation fails) because it avoids "interaction bugs".  Suppose a user clicks the "delete" button for the third document in a list.  When the element was rendered with SSR, the document had the title "old todo list", but when rendered on the client side the third item is a document entitled "important financial/tax documents".  React notices that only the element title changes, so it applies the update and then fires the click listener for the "delete" operation.  Now the user just deleted the wrong document.  Throwing away the entire DOM tree minimizes the likelihood of this happening, because everything (including pending operations/state) is destroyed.

Personally, I don't have an opinion.  cc @sebmarkbage, who may have an opinion.
 It is not always possible to fix DOM diffing. E.g. internationalized date formats can't be done the same way on the server and client for certain cases because the Windows internationalization libraries differ and are closed source.

It seems strange that your ad code would differ though.
 That's not how it works right now (before #6618). It diffs against the checksum, not the actual DOM.
  Probably this issue would be better discussed in https://github.com/facebook/react-devtools since an additional attribute on a component would be completely transparent to the React core.  For this reason, I'm going to close out the issue, but feel free to open an issue in the other repository.

With regards to the specifics of your idea, I have no objection to this.  However, I would suggest that if your application is sufficiently complicated that context providers are cluttering up your development experience, your application might be too complex.  I would gently suggest that maybe your application is overly-abstracted or that you aren't being faithful to one-way data flow from parent/owner to child.  Obviously I haven't seen your code, so take that with a grain of salt.  Just food for thought.
  There is one test failing right now. Pretty sure it is because we updated to jsdom 8. Will look into this tomorrow unless anyone has some ideas ‚Äì seems like the multiple defaultValues test is failing in ReactDOMSelect ‚Äì is this a bug in React or jsdom?
 The unit test expectation matches what the browser does, so it looks like a jsdom bug.
 This is just the jest update, not the Jasmine 2 update correct?
 yes.

Waiting for the jsdom fix here: https://github.com/tmpvar/jsdom/pull/1462/commits/236caaef9fd7a5fe3c7204b8569396da6d37e918
 @cpojer updated the pull request.
  Can you try to extract a reproducible case?
 @tomdcc Also, are you using React Router?
 Can you put a simplified copy of your webdriver test on github or somewhere so we can run it?
 I sort of wonder if this is related to https://github.com/facebook/react/issues/6495
 @keyanzhang Can you try to dig into this and figure out what the underlying cause is? We've had a few pull requests that simply add a null check before trying to dereference a node or component, but we should instead be canceling timers and dequeueing things when they are unmounted so that there are never null elements left over.
 @bengotow That sounds right to me. Do you want to send a PR to store it as `this.node` alongside `this.classNameQueue` and then use that node when flushing the classes? We should null it out afterwards like we do with the timeout. Can you check that that fixes the codepen linked above?
  **Goal**: this PR intends to implement [step 1](https://github.com/facebook/react/issues/6420#issuecomment-213135763) of the [proposal to pull apart server DOM rendering from client DOM rendering and enable server streaming](https://github.com/facebook/react/issues/6420). Instead of a string checksum, this PR walks the server-generated DOM to validate that the markup matches. This makes it somewhat more lenient than the current algorithm, which requires a character-for-character match. This in turn should eventually enable server renderers that are decoupled from the client code and as a result more performant.

**Performance**: [at @sebmarkbage's suggestion](https://github.com/facebook/react/issues/6420#issuecomment-213604948), this PR only focuses on correctness, not performance. I have a fairly simple benchmark project with Selenium scripts, though, and I intend to run that tests in different browsers in the next few days. Any suggestions on areas of the PR that look suspect from a perf perspective would be welcome. I'm not super experienced in JS perf optimization.

**Tests**: All existing unit tests pass, and I added about 90 or so more for the new code path.  I realize that might seem like overkill, but I found there were a surprising number of special cases and fiddly bits.

**Notes**: The basic implementation strategy is to add an optional argument to `mountComponent`/`mountChildren` called ~~`nodesToReuse`~~ `nativeNodeToReuse`, which ~~are~~ is the node~~s~~ in the DOM that the component in question is supposed to attach to. ~~This argument can either be a single DOM node in the document (for `ReactDOMComponent` or `ReactDOMEmptyComponent`) or an array of DOM nodes in the case of `ReactDOMTextComponent`.~~ Note that this DOM node is the **first** node corresponding to the component. In the case of `ReactDOMComponent` or `ReactDOMEmptyComponent` which only produce one DOM node, it is the first and only DOM node, whereas with `ReactDOMTextComponent`, it is the first node of two or three. This optional argument made it pretty easy to isolate the PR's changes from the non-SSR client code path. Also, the `renderToString` code path should be completely unchanged.

I'll go through the individual files in the PR and try to add comments where I think they make sense. Please feel free to ask any questions. Also: apologies if I broke any conventions or rules; this is my first PR to React. And if there's a more constructive way to present these changes, please don't hesitate to let me know. Thanks!

Tagging @jimfb, @goatslacker, @lelandrichardson, and @lencioni, all of whom have expressed interest in this PR.
 Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 The build isn't passing, but the error it's giving is pretty strange. I'm going to close and reopen to force a second build just to make sure the error is reproducible.
 Opening to run another build.
 @ljharb thanks for replying!

> like {'a'}{'b'} versus {'ab'}?

This implementation throws a mismatch error if you have two text components in the server markup and only one text component in the client (and vice versa). The reason is that each non-empty text component generate 3 DOM nodes (two comments and one text), so the markup is not the same between two text components and one. 

In theory, you could make the client side code more lenient and accept two adjacent text components as the same as one single text component, but that would involve modifying the DOM to remove some of those extra comment nodes, and that seems like a bad idea to me. Thoughts?

> What about HTML comments, and the whitespace surrounding them?

As far as I know (and I may be wrong!), other than the `react-text` and `react-empty` comments, server side rendering doesn't generate any HTML comments, so I don't think we need to worry about reconnecting to them. They should throw a markup mismatch error, although I don't think I have a specific test case for that.
 >  I don't even know why React renders {'a'}{'b'} as two textNodes rather than one :-/

Agree with @lelandrichardson above. Also, remember that while JSX could in theory do static analysis in your example and merge those strings, it's not possible in a general case to know whether the value in curly braces will be a string or a component. For example:

```
<div>{'a'}{isMonday() ? 'b' : <SomeCustomComponent/>}</div>
```

So merging text nodes at the ReactElement level is not possible in the general case. However, I could in theory imagine a renderer that, while walking the tree, attempted to merge sibling text nodes at runtime. It would add some complexity to walking the tree, though, and I think to tree diffs as well (although I don't know as much about that). 

In any case, I think it's orthogonal to this PR, as I'm trying to keep current behavior, but it would certainly make an interesting PR of its own!
 @aickin Amazing work!

> In theory, you could make the client side code more lenient and accept two adjacent text components as the same as one single text component, but that would involve modifying the DOM to remove some of those extra comment nodes, and that seems like a bad idea to me. Thoughts?

I think we would like to do something like this eventually, I think there is an open issue for this somewhere.

> So merging text nodes at the ReactElement level is not possible in the general case. However, I could in theory imagine a renderer that, while walking the tree, attempted to merge sibling text nodes at runtime.

Merge... or split.

> In any case, I think it's orthogonal to this PR, as I'm trying to keep current behavior, but it would certainly make an interesting PR of its own!

Yes, totally agree.

## 

This is a nice beefy PR.  I just skimmed it, but it looks good at first glance.  I'll need to go through it in more detail later today, but I'm excited.  cc @facebook/react-core @sebmarkbage @tomocchino for situational awareness (also, relevant issue is https://github.com/facebook/react/issues/6420), cc @spicyj and @gaearon to help find the edge cases.
 >  I'm going to do a second pass with performance in mind now that I have a better understanding of what you've changed, and see if I have anything to add from that angle.

@lelandrichardson Thanks in advance for your help!

> I'll need to go through it in more detail later today, but I'm excited.

@jimfb Me, too! Thanks so much for your guidance already on this strategy, and I look forward to your feedback.
 I had enough time to write a more thorough performance test of this PR, and I'd like to share the results.

Methodology: I made a simple recursive div component and loaded pages with trees of different breadths both with master (the checksum strategy) and code off this PR (dom-walk strategy). (I actually didn't use this PR exactly, because I felt that since dom-walk doesn't need `data-reactid`, it put dom-walk at a disadvantage to test against this exact PR. Therefore, I changed a few files to remove `data-reactid` and tested against that branch.)

I made test pages that render DOM trees of four different sizes:

|  | DOM nodes | Size (checksum) | Size (dom-walk) |
| --- | --- | --- | --- |
| small | 781 | 28.9K | 14.5K |
| medium | 2,801 | 107.2K | 53.6K |
| large | 16,105 | 635.5K | 316.0K |
| xlarge | 54,241 | 2,178.6K | 1,077.1K |

There are two versions of each page, one that uses checksum and the other that uses dom-walk, and the pages have timing code that measures how long it takes to render into the SSR markup. I then used Selenium and Sauce Labs to run each of those pages on 11 different browser/OS combinations, and I repeated each browser/OS in the matrix 15 times and took the median times. 

Because the server-generated markup was different in the two branches (checksum branch having `data-reactid` attributes), I thought that browsers might be able to parse the content from the dom-walk branch faster. Accordingly, I also measured the apparent time to get to DOMContentLoaded.

Rather than copy the (rather large) table here, I invite you to look at [the Google Sheet that contains the data](https://docs.google.com/spreadsheets/d/1nB-fziUNnTW8-xi3nMj6Cx4IUNCeAizH78plyT1EdSs/edit?usp=sharing). The most interesting columns are the last two: the difference in raw render time and in render + dom parse, or total startup time. Negative numbers mean that dom-walk was faster than checksum.

Observations: 
- Webkit/Blink-based browsers seem to do better with DOM walking, with anywhere from 5-20% perf gains on total startup time.
- Firefox slows down a bit on rendering, although if you look at overall startup time, it's not hugely significant (except for xlarge on Linux).
- Internet Explorer 10 & 11 look pretty bad to me at about 60-80% worse in total startup time.
- On reflection, we should probably not worry too much about the perf of the xlarge page. I was curious how browsers would perform, but 54 thousand DOM nodes is probably absurd.
- It's worth noting that this test is not measuring two other possible perf gains that the dom-walk strategy would get in the real world:
  - Without `data-reactid`, the server generated markup is smaller and will therefore take less time to transfer to the client.
  - We believe that server markup generation can be significantly improved after this PR is accepted.

What do other folks see in/think about these results? What would you like to see improve, and by how much? Is the current code's gain in Chrome/Safari enough to offset the losses in IE?

Next steps:
- Test render/startup perf of other DOM features, like attributes and elements without events (in this test, every div has an onClick handler and no other attributes).
- Experiment with removing functionality from dom-walk to get a sense of where the time is currently being spent.
 @lencioni They are indeed without gzip, but I'm not sure I get why gzip would matter for client side perf (other than the transfer time of the HTML, which I didn't measure here). Can you expand on your thoughts? Thanks!
 Got it. 

Unfortunately, I think the gzipped sizes for this test are going to be pretty misleading, because they are just test pages that repeat the same DOM node over and over again in a tree. This text is extremely compressible, especially when you get rid of react ids, so it wildly overestimates how effective gzip will be in the real world:

|  | Gzip size of entire html (checksum) | Gzip size of entire html (dom-walk) |
| --- | --- | --- |
| small | 2663 bytes | 457 bytes |
| medium | 8647 bytes | 696 bytes |
| large | 46,761 bytes | 2221 bytes |
| xlarge | 152,652 bytes | 7,716 bytes |

IIRC my usual experience with real-world HTML is that it is about 20% the size when compressed, but take that with a  grain of salt.
 I think we're on board with this general strategy but the way I'd frame it is not as validation at all but as "overriding" the DOM and fixing it up with an optional validation that we can do in DEV only if needed.

I've realized that this general strategy is something we'll want to for client-only rendering as well. We can render a tree once on the client. Then throw away the React tree while keeping the DOM tree. Then we can restore it by rendering the same thing again - **on demand**.

Additionally, I'd like to get to a point where we don't need to do diffing at all in the DOM layer. We can just set all properties every time if the C++ boundary is fast enough (which it looks like it is). Because the DOM does diffing in its properties already.

So basically, what this could do is become a write only pass. The read that checks the existing value becomes just an extra warning that we can disable.

We're also already walking the tree to restore nodes for event handling. There is a lazy pass that walks the tree backwards and populates node handles. It would be good if we could unify that logic with this logic. For example, do we really need nodesToReuse if nativeContainer already has that information?
 Note: It is easy to get rid of data-reactid without changing how we checksum and traverse nodes. See #6662.
 @sebmarkbage: Thanks for the reply!

> We can just set all properties every time if the C++ boundary is fast enough (which it looks like it is). Because the DOM does diffing in its properties already. 
> 
> So basically, what this could do is become a write only pass.

I think I don't entirely understand what you are proposing, but wouldn't the code still need to read the DOM attributes to know which attributes to remove?

> with an optional validation that we can do in DEV only if needed
> The read that checks the existing value becomes just an extra warning that we can disable.

I think that many or most of the checks would still be required. For example, you have to check a DOM element's `tagName` to see if you need to replace it. Does that make sense?

> We're also already walking the tree to restore nodes for event handling. There is a lazy pass that walks the tree backwards and populates node handles.

I don't think I know anything about that. Can you point me to the code that does that? Thanks!
 @jimfb Thinking over your very helpful comments, I decided that my strategy around `nodesToReuse` was unnecessarily confusing. 

With 061867a, I renamed that argument to `nativeNodeToReuse` and made it always be a single DOM node (as opposed to the weird dance before where it was sometimes an array). 

I also tried to centralize and comment all the logic of traversing and evaluating native nodes in a new file: `NativeNode.js`. In the earlier version of the PR, that logic was spread across `ReactDOMComponent.js`, `ReactDOMTextComponent.js`, and `ReactDOMEmptyComponent.js`, and I see now that was super confusing.

With 061867a, I think I have addressed all current code review comments. Many thanks to @ljharb & especially @jimfb for looking the code over, and I welcome more feedback!
 @aickin Awesome!  Just FYI, this PR was at the top of our agenda during our team meeting on Friday, and was the main topic of discussion for the rest of the evening.  We're all super excited!

I just chatted with Sebastian and he seemed optimistic about getting this merged soon.  He needs to do a full read-through some time (early) this week.  I'll also do another pass today or tomorrow, but this is looking good.  Thanks for all your hard work!
 > optimistic about getting this merged soon

@jimfb What delightful news to start the week! Thank you thank you.

Hopefully quick question: how are you all feeling about perf? I have been running many more versions of the tests I posted upthread to see if there are optimizations to be made (found one small one, but nothing game changing). 

Are you thinking that this PR can maybe be merged without more perf work? If it is merged, are you expecting me (or someone else) to turn to perf next?
 Let's see what @sebmarkbage says when he reviews the code, he'll likely have at least a few requested changes, and it isn't a done deal until the PR is merged, but things are on a good track.  Obviously we do care about perf, but let's figure out the high-level stuff and then we can dive into perf.
 There's a lot of excitement over this pull request, and we've been debating internally over whether this is a move in the right direction or not. Here's my take. My understanding is that this pull request promises value in two areas:

First, the markup validation would be somewhat less brittle. In particular, it would be fine to output attributes in a different order or with different capitalization and whitespace as logn as the output is semantically identical. However, the actual mapping from prop names to attribute names (ex: `className` to `class=""`) would still need to match exactly between server and client, as would the logic for when an attribute value is used and exactly which value it takes in the DOM (ex: `download={false}` produces `download=""` but `checked={false}` produces no markup). It is my sense that matching these rules and configuration for attributes and children is by far the most cumbersome process of making the markup match and that this pull request doesn't change the requirements in that area at all.

Given an alternative implementation that matches these semantics, this pull request _does_ enable using different HTML escaping, attribute ordering, or whitespace ‚Äì but these strike me as unlikely to be brittle in practice and easy to match. We could also look at changing the checksum to be looser about things like attribute ordering if this is significant for you.

I recognize that this pull request brings us closer to being able to "patch up" server-rendered trees if the client's tree does differ, but it's not clear to me that this is a behavior that we want to promote because any deviance probably indicates a bug somewhere that should be fixed properly.

Second, this pull request enables better warnings in the case of a markup mismatch. This sounds appealing but I don't think will be a major motivator in practice. Our warning for a bad checksum currently seems to work pretty well and we rarely see false positives or red herrings from the warning. The most common recent error was due to differing property ordering on the server and client due to bugs in V8's Object.assign but this was a real deviance that caused the checksum to differ, not only a symptom surfaced by the error message.

One example of a case where we did have a bad warning was in #6452 due to nodes added by a browser extension, but it's my understanding that your pull request here wouldn't actually fix this problem and can't not know which nodes are React-rendered because it ignores `data-reactid`. If we believed that these current warnings that read from `.innerHTML` are often misleading due to extensions or other transformations that the browser performs when inserting markup, we could introduce better tools that allow the client code to extract the original generated HTML for debugging only and compare it directly so that any transformations the browser performed don't have any effect.

These advantages seem relatively minor to me. Am I missing other enhancements which this provides or unlocks? As it currently stands, I am finding it hard to be enthusiastic about merging this pull request. It was pointed out to me that this PR would allow us to stop sending down the HTML-generation, checksum, and lazy tree rehydration (`ReactDOMComponentTree`) code to the client which would be a minor win, but it's not clear to me that this new code is in a better position to take that place, especially because the existing code has been more battle-tested. Subjectively, I also find the existing checksum solution to be rather elegant and simple, whereas this new code that walks the DOM feels like it has more room for bugs and incidental complexity. All combined, this currently feels to me like a change with significant churn and only minor potential benefit. Also note that I haven't looked much at the code in detail yet so there are likely to be nuances that I've missed.

I hope this helps clarify my personal thinking. I know that @jimfb and @sebmarkbage have also thought a fair amount about this and may feel differently on these issues. If I'm missing things in my interpretation here, please let me know because I'd hate to be accidentally criticizing a strawman.
 > First, the markup validation would be somewhat less brittle. In particular, it would be fine to output attributes in a different order or with different capitalization and whitespace as logn as the output is semantically identical. However, the actual mapping from prop names to attribute names (ex: className to class="") would still need to match exactly between server and client, as would the logic for when an attribute value is used and exactly which value it takes in the DOM (ex: download={false} produces download="" but checked={false} produces no markup). It is my sense that matching these rules and configuration for attributes and children is by far the most cumbersome process of making the markup match and that this pull request doesn't change the requirements in that area at all.

This PR allows us to further loosen the rules in the future, if we so desire, to accommodate renderers.  For instance, we could call `hasAttribute` instead of checking the value for boolean attributes.  This PR opens the door to arbitrarily loosen the validation requirements (if so desired) in the future.  This PR doesn't do the full loosening because it aims at feature parity with the current implementation in order to simplify review.

> I recognize that this pull request brings us closer to being able to "patch up" server-rendered trees if the client's tree does differ, but it's not clear to me that this is a behavior that we want to promote because any deviance probably indicates a bug somewhere that should be fixed properly.

Agree, this PR is more about opening doors than it is about any specific fix that is absolutely necessary.  Unclear if we would want to patch up the server-rendered trees, but if we do, now it's an option.  Sebastian seemed to think it was at least an area worth discussing/exploring.  But the point is that we now have more flexibility to iterate on client-side and server-side implementations independently.

> Second, this pull request enables better warnings in the case of a markup mismatch. This sounds appealing but I don't think will be a major motivator in practice. Our warning for a bad checksum currently seems to work pretty well and we rarely see false positives or red herrings from the warning. The most common recent error was due to differing property ordering on the server and client due to bugs in V8's Object.assign but this was a real deviance that caused the checksum to differ, not only a symptom surfaced by the error message.

Again, agree.  But it's incrementally better :).

> One example of a case where we did have a bad warning was in #6452 due to nodes added by a browser extension, but it's my understanding that your pull request here wouldn't actually fix this problem and can't not know which nodes are React-rendered because it ignores data-reactid. If we believed that these current warnings that read from .innerHTML are often misleading due to extensions or other transformations that the browser performs when inserting markup, we could introduce better tools that allow the client code to extract the original generated HTML for debugging only and compare it directly so that any transformations the browser performed don't have any effect.

Yes, minor change in functionality.  We could enhance this validation logic to search for data-reactid if that's really the deal breaker.

> These advantages seem relatively minor to me. Am I missing other enhancements which this provides or unlocks? As it currently stands, I am finding it hard to be enthusiastic about merging this pull request. It was pointed out to me that this PR would allow us to stop sending down the HTML-generation, checksum, and lazy tree rehydration (ReactDOMComponentTree) code to the client which would be a minor win, but it's not clear to me that this new code is in a better position to take that place, especially because the existing code has been more battle-tested. Subjectively, I also find the existing checksum solution to be rather elegant and simple, whereas this new code that walks the DOM feels like it has more room for bugs and incidental complexity. All combined, this currently feels to me like a change with significant churn and only minor potential benefit. Also note that I haven't looked much at the code in detail yet so there are likely to be nuances that I've missed.

All true, except this is more about setting us up to split out the SSR renderer than anything else.  The goal is to open doors.  It's similar to Sebastian's refactorings of internals and his incremental reconciler stuff - no short term wins but opens doors for long term wins.  It's all about setting us up for potential discussions/improvements down the line, which are hard/impossible to do without walking the DOM.  It implements a couple of these improvements out of the box (like better warning) and opens us up to many more (like using hasAttribute for boolean props).

@aickin Is that an accurate response?  Any thoughts / anything you want to add?
 @jimfb As far as I can tell, the only new possibilities you mention are (1)

> we could call hasAttribute instead of checking the value for boolean attributes

which doesn't seem particularly motivating to me and (2) patching server-rendered trees ‚Äì if we do want that, we should focus our discussion on how best to make that happen and if this PR is the best way to do that. You said "open doors" a lot of times but it's not clear to me that any useful doors are actually being opened.

You also claimed that the warnings are better ‚Äì can you show examples where the new warnings are more helpful?

In any case, I've already spent hours talking with you about this and would like to hear @aickin's take. :)
 @spicyj: thanks for your reply! @jimfb: thanks for chiming in! There's a lot to address here, but I'll do my best to cover it.

> These advantages seem relatively minor to me. Am I missing other enhancements which this provides or unlocks?

and

> All true, except this is more about setting us up to split out the SSR renderer than anything else. The goal is to open doors.

So, at a high level, I think it's important to understand my motivation in making this PR has relatively little to do with the mechanics of server-generated markup validation or either of the two benefits @spicyj  mentioned. My two motivations are:
1. `renderToString` can be pretty slow for production sites rendering whole pages, and I'd like it to be significantly faster.
2. There's no way to stream a server render, which means that TTFB suffers, and servers use potentially a lot more memory per request than they need to.

Obviously, this PR addresses neither of these concerns. So why did I write it? Well, after talking with @jimfb for a while about the SSR speed/streaming problem and prototyping a little bit, I came to believe that:
1. the current SSR code path is a lot slower than it could be because it is embedded inside the client rendering code path, and the client code path does a lot of heavy work that is not needed at all on the server.
2. making the client code path support streaming (& asynchronicity in general) was going to be majorly disruptive and my guess was that it was a non-starter.
3. SSR performance could get as much as an order of magnitude better by being pulled out into a totally separate code path.
4. It would be pretty difficult and bug-prone to write a separate server renderer that produced character-for-character the exact same markup as the current code path.

(I should note that @jimfb was extremely influential in my thinking here, but these were my conclusions and I do not claim to speak for him.)

My hope was that if we moved the client to DOM-based validation and got rid of IDs, it would be a bit more lenient to write a server renderer on a totally different code path, and maybe in a completely separate project.

Since making this PR, I've written a prototype standalone server renderer that can be used with this PR's DOM-based validation, and it passes all but 5 of the unit tests already. This prototype renderer is about 7-8x faster than `ReactDOMServer.renderToString`, and it supports streaming on the same code path. So I feel pretty good about pulling SSR out of the client code path as a way to achieve perf gains.

The question of how to validate whether or not the server rendering can be reused was for me simply a means to an end. As long as the validation is well-documented enough and not intimately tied to the implementation of the server renderer, I'm probably happy. Does that make sense?

I also have a few reactions to specific points:

> I recognize that this pull request brings us closer to being able to "patch up" server-rendered trees if the client's tree does differ, but it's not clear to me that this is a behavior that we want to promote because any deviance probably indicates a bug somewhere that should be fixed properly.

I agree with this; I think that server-client mismatches should be classified as programmer errors, and I don't want to spend a lot of time optimizing for them. (Caveat: I have not thought deeply about this, so my opinion is lightly held.)

> as would the logic for when an attribute value is used and exactly which value it takes in the DOM (ex: download={false} produces download="" but checked={false} produces no markup).

I agree that the mapping of prop names and values to HTML names and values is sometimes funny, and I've definitely found some interesting corner cases over the last two weeks. My view isn't quite as dire about how hard this is, especially if it were better documented as part of this process, but I may not have hit all of the sharp edges yet.

As for the particular example you gave, though, I'm a bit confused:

``` javascript
console.log(ReactDOMServer.renderToString(
  <div>
    <input type="checkbox" checked={true} onChange={()=>{}}/>
    <input type="checkbox" checked={false} onChange={()=>{}}/>
    <a download={true}>Some Text</a>
    <a download={false}>Some Text</a>
  </div>));
```

produces in React 15 (with whitespace added for clarity):

``` html
<div data-reactroot="" data-reactid="1" data-react-checksum="778127387">
  <input type="checkbox" checked="" data-reactid="2"/>
  <input type="checkbox" data-reactid="3"/>
  <a download="" data-reactid="4">Some Text</a>
  <a data-reactid="5">Some Text</a>
</div>
```

It seems to me that `download={false}` and `checked={false}` behave the same, but maybe I'm missing something?

> Our warning for a bad checksum currently seems to work pretty well and we rarely see false positives or red herrings from the warning. The most common recent error was due to differing property ordering on the server and client due to bugs in V8's Object.assign but this was a real deviance that caused the checksum to differ, not only a symptom surfaced by the error message.

If the only difference between client and server markup was HTML attribute ordering, then I'd argue that the checksum mismatch was in fact a false positive. As far as I know, there is nothing stopping the client from rendering into server markup that has a different attribute order.

> We could also look at changing the checksum to be looser about things like attribute ordering if this is significant for you.

This is really interesting to me. I think there are some other possible checksums that would be easier to document and/or not depend on character-for-character implementation details, and those probably could enable my desire to pull SSR out into another, faster code path.

I think with the validation what we are really trying to figure out is if the client native component tree is the same as the server native component tree, not whether the generated HTML markup is the same. I could totally imagine a standardized serialization of the native component tree that would get checksummed on either side, which would preserve the leniency of this PR while not walking the DOM. We wouldn't get partial tree patching, but as I said before, that's not a huge priority for me.

> we could call hasAttribute instead of checking the value for boolean attributes

In fact, it might [already use hasAttribute](https://github.com/facebook/react/pull/6618/files#diff-5574f655d491348f422bca600ff6711dR748)... ;)
 > It would be pretty difficult and bug-prone to write a separate server renderer that produced character-for-character the exact same markup as the current code path

Can you explain why this is? This is a statement that sounds true on the surface level to me and everyone else I've talked to, but after thinking about it more, it seems to me that the real cost is in making the attribute names and values match exactly (something that's necessary regardless of the implementation), and if you get that far then making an exact string match is relatively easy.

> making the client code path support streaming (& asynchronicity in general) was going to be majorly disruptive

Can you tell me more about asynchonicity? What would you want to do concurrently with generating the markup ‚Äì is it only sending the bytes over the network or are there other operations that you would want to perform at the same time? (It seems like generating and sending the markup is the number-one priority at that time so you wouldn't want to do much else.)

Can you confirm that to make streaming work, the renderer need only make calls akin to `stream.write('<div>'); ... stream.write('</div>');`? Just want to check my understanding as I'm thinking about the requirements.

> I've written a prototype standalone server renderer that can be used with this PR's DOM-based validation, and it passes all but 5 of the unit tests already.

Can you say more about which unit tests you're running and how you're running them? Also, what test cases are you using to benchmark?

> It seems to me that `download={false}` and `checked={false}` behave the same, but maybe I'm missing something?

You're totally right, sorry for the confusion. I wrote that example off the top of my head and got it a little bit wrong. `download={true}` vs `className={true}` is a better example; those result in `download=""` and `class="true"`, respectively.

> If the only difference between client and server markup was HTML attribute ordering, then I'd argue that the checksum mismatch was in fact a false positive.

I mostly meant that the warning message did indicate the true cause of the checksum mismatch, but your claim here is totally fair. 
 > Can you explain why this is? This is a statement that sounds true on the surface level to me and everyone else I've talked to, but after thinking about it more, it seems to me that the real cost is in making the attribute names and values match exactly (something that's necessary regardless of the implementation), and if you get that far then making an exact string match is relatively easy.

You might be right. Questions I've run into while trying to achieve character-for-character match:
1. **Ordering of HTML attributes in props.** How should the props be ordered when they are translated into attributes?
2. **Ordering of styles.** How should styles be ordered?
3. **Boolean attributes.** Should a `true` value be represented as `attribute=""`, `attribute`, or `attribute="attribute"`?
4. **Quote type.** Single or double quotes for attributes? Should quotes be used when they aren't necessary (e.g. `<input type=text>`)?
5. **Where extra attributes go.** Do things like `data-reactroot`, `data-reactid`, and `data-react-checksum` go before attributes from props? What order do they go in when they are all in an element?
6. **Whether void tags have a trailing slash.** Are void tags rendered as `<tag>` or `<tag/>`?
7. **HTML Entities** Which characters must be escaped in text? What about in attribute values? Which characters must NOT be escaped? Which kind of escaping do we use (e.g. &amp;amp; vs. &amp;AMP; vs. &amp;#x00026; vs. &amp;#38;)?
8. **Whitespace.**

I think there are a few more, but this gives a sense. Now, all of these are answerable questions, but each one adds a bit more to the complexity of getting the renderer right without adding to the actual correctness of the renderer. 

It also seems to me like a pretty rigid API to enforce, which could make it messy to change in the future. For example, what if someone in the future decides that escaping quotes in text content, which is currently done by the server renderer but is not necessary, should be removed? If that will break the checksum contract, they may not be able to.

> Can you tell me more about asynchonicity? 

Sure! 

Streams are inherently asynchronous. Imagine that the network is pulling content out of the render stream, say 16K at a time. Ideally, the stream renders just the first 16K, hands that to the network, and then chills for a while until the network asks for more content.

If the renderer is synchronous, then the stream will generate all 200K (or whatever) of the page before it can hand back that first 16K chunk, and it will have lost all benefits of streaming.

> What would you want to do concurrently with generating the markup ‚Äì is it only sending the bytes over the network or are there other operations that you would want to perform at the same time? (It seems like generating and sending the markup is the number-one priority at that time so you wouldn't want to do much else.)

Yes, generating and sending markup is the number-one priority for your request, but there are other requests running at the same time, and they have priorities, so streaming provides a way to yield control to other requests. 

This is especially nice when you have a server that has a mix of small and large pages. With synchronous rendering, a large page monopolizes the CPU until it is done rendering. If a request for a small page comes in while a large page is rendering, the small one just has to wait until the large one is completely done. With streaming, the large page will yield to the small page and let it quickly render before getting back to its work. This results in lower average TTLB across all the pages.

> Can you confirm that to make streaming work, the renderer need only make calls akin to `stream.write('<div>'); ... stream.write('</div>');`? Just want to check my understanding as I'm thinking about the requirements.

No, that's not how it works. I want to create a [Readable Stream](https://nodejs.org/api/stream.html#stream_class_stream_readable_1), which at a high level just has one method: `_read(n)`. The argument `n` indicates how many bytes are desired, and it should generate about that many bytes of markup in response.

> Can you say more about which unit tests you're running and how you're running them? 

The full test suite of `master` plus this PR plus a few extras I wrote in the branch. Running them via `npm test`.

> Also, what test cases are you using to benchmark?

[A repo I made for testing big renders](https://github.com/aickin/react-server-perf-tricks) for a talk I gave on SSR perf.

> You're totally right, sorry for the confusion. I wrote that example off the top of my head and got it a little bit wrong. download={true} vs className={true} is a better example; those result in download="" and class="true", respectively.

Got it. 

As a side note, am I wrong in thinking that's really strange behavior for `className={true}`? Even more weirdly, that means that `<div className/>` renders as `<div class="true" data-reactid="2"></div>`. Huh.

Thanks for your engagement!
 Thanks for the link about streams, I definitely had the wrong mental model there.

For testing, do you mean that you replaced the implementation of ReactDOMServer.renderToString (and maybe renderToStaticMarkup) and left the other APIs alone? (We actually have relatively little test coverage for server rendering specifically, though the existing implementation is tested pretty extensively when running with `ReactDOMFeatureFlags.useCreateElement = false`.)

> As a side note, am I wrong in thinking that's really strange behavior for `className={true}`?

Maybe. For string-valued attributes, we decided to cast all non-null attribute values to string and don't have special logic for strings vs booleans vs numbers. For "boolean" attributes (like autoPlay, checked, hidden) we only check whether the value is truthy or falsey. Maybe this rule could be simplified but it seems to work well in practice.

> Even more weirdly, that means that `<div className/>` renders as `<div class="true" data-reactid="2"></div>`. Huh.

Yeah, that's weird.
 > For testing, do you mean that you replaced the implementation of ReactDOMServer.renderToString (and maybe renderToStaticMarkup) and left the other APIs alone? 

Yep!

> (We actually have relatively little test coverage for server rendering specifically

Yeah, I noticed that while working on this PR. (For example, I found that events weren't being tested on SSR markup, which led to PR #6668 .) I added over 90 server rendering unit tests as part of this PR, but I can't claim that they are comprehensive.

> For string-valued attributes, we decided to cast all non-null attribute values to string and don't have special logic for strings vs booleans vs numbers.

This totally makes sense to me for numbers; a common use case would be `<input defaultValue={count}/>`. It would be really annoying to have to write `<input defaultValue={String(count)}/>`, and there's no other way to express numbers in HTML attributes AFAIK.

For booleans, it makes less sense to me. I can't think of a common case where you want an attribute value to be the string literal "true" or "false", and booleans do have a representation in HTML, expressed by the presence or absence of the attribute name in HTML. It's especially confusing for an attribute like `download`, which can be boolean- or string-valued in HTML. But this is probably a discussion for another time/PR.

> Yeah, that's weird.

;)
 Given all of this (very helpful!) discussion in the last day, I want to take the temperature of folks on the core team about how to proceed (or not) with this. 

As I said above, my goal is to get server streaming and a faster server string algorithm into the world. I am not particularly interested in changing the client validation scheme, pulling server rendering out into another project, patching up server trees on the client, enhancing the markup mismatch errors, or enabling many different server renderer projects to coexist, except inasmuch as it helps me get fast SSR and streaming.

With those goals in mind, I can think of four paths forward:
1. **Don't do anything.** Close this PR and don't attempt to have React support streaming or faster SSR. Obviously, this not my preference; I think many folks using SSR have had difficulty with its current speed (I've certainly heard this from @mridgway and @goatslacker), and based on the reaction to `react-dom-stream`, I think there's a real audience for streaming. On the other hand, this may not raise to a high enough priority for the core team to be worth the code changes, and I would understand that if it's true.
2. **Pull string rendering logic out of the client code path, but keep the current checksum.** Pull string rendering out of `mountComponent` into its own recursive function, but reuse a lot of the current code that generates markup (like `DOMPropertyOperations.createMarkupForProperty`), which would alleviate @spicyj's objections about the difficulty of replicating the current complicated props => attributes logic. I think this would mean that we could get faster SSR and streaming in core without having to change the current character-for-character checksum, which we would keep. However, since the checksum doesn't change, this would not make it any easier for external projects to write their own server renderers.
3. **Develop a checksum based on a canonical representation of the HTML tree, not on actual generated markup.** Retain a checksum-based validation, but it would be a checksum on a defined canonical string representation of the markup tree, not on the actual generated markup. This would allow server renderers to make stylistic choices about how to express a particular component tree in HTML as long as it doesn't change the semantic meaning of the HTML, which would open up the possibility of independently written server renderers. As @spicyj points out, though, independently written server renderers would still have to copy the (fairly complex) logic of translating props to attributes.
4. **Use DOM validation.** The last path is to use the strategy in this PR, which validates on the client via DOM. This strategy has the difficulty of copying the props => attributes logic. It also is a bit worrisome to me when it comes to perf on non-Webkit/Blink browsers. However, if you're interested in server tree patches, this strategy makes that potentially viable.

Are there other paths towards these goals? For core team members especially: which path(s), if any, would you support?
 cc @facebook/react-core @tomocchino @sebmarkbage 
 @jimfb We're all subscribed already, you know. :)
 I see a lot of value in getting rid of the HTML generation code on the client. I know @spicyj doesn't agree with me here but I'll try to make a case for it.

As for this diff I see a major issue that it rerenders upon a mismatch. That's a behavioral difference because the side-effects that happen in componentWillMount will happen twice without a clean up phase if I read this correctly. We'll need to be a bit more aggressive about being resilient to this because of error boundaries and incremental reconciler. However, it seems like a pretty significant issue that may cause memory leaks and weird artifacts if not handled correctly.

I see a plausible way forward to at least use the error boundaries path. However, that is also less than ideal because we've already rendered most of it. We might as well just patch it up.

I think a better way forward would be to patch up the DOM using the same logic as for creating it and only logging errors. Not throwing.

At that point the checksum vs. reading the DOM becomes a lot more interesting. Because to do "fix up" the current logic have to generate compatible HTML. To get fix up to work without HTML generation you would do most of the same thing in both solutions.

Therefore my preference would be something that walks the DOM and sets all the properties as if it was a new tree only it reuses it. Optionally comparing them along the way.
 @sebmarkbage Thanks for looking over this PR!

> As for this diff I see a major issue that it rerenders upon a mismatch. That's a behavioral difference because the side-effects that happen in componentWillMount will happen twice without a clean up phase if I read this correctly.

That's a great point, and one that I hadn't considered. I thought the current code in master re-rendered on a markup mismatch, but I can see now that it doesn't. This is indeed tricky.

> I see a plausible way forward to at least use the error boundaries path.

I don't know what this means. Can you explain (or point me in the direction of an explanation) of what "error boundaries path" means?

> Therefore my preference would be something that walks the DOM and sets all the properties as if it was a new tree only it reuses it. Optionally comparing them along the way.

I'm probably missing something, but doesn't it have to compare to know which attributes in the DOM to remove?

(And again, thanks for joining in!)
 > seems like a pretty significant issue that may cause memory leaks

Thinking about this more, I got a bit confused about this point. It seems to me that if `componentWillMount` allocates memory that it expects to release later, that's already a bug during the SSR lifecycle. According to [this unit test,](https://github.com/facebook/react/blob/master/src/renderers/dom/server/__tests__/ReactServerRendering-test.js#L123) `componentWillMount` gets called on the server, then `render`, and that's it. So if `componentWillMount` leaks memory, it should already be a big problem on the server, right?

At the same time, I recognize that there could be other, non-memory leak side effects in `componentWillMount` that could make the double rendering a problem. Perhaps something like a global counter of how many components have been rendered?
 Okay, we talked some more about this today. Server rendering is clearly important to all of you and we'd love to figure out a way to make it better, especially if we can make a significant performance improvement.

Overall, I'm still a little shaky on the claim that this PR is necessary in order to build a standalone server renderer so we'd be interested to see if we can facilitate building a fast server rendering without requiring this as a first step. It sounds (based on comments from @jimfb) like you already have a working implementation of a server renderer that stacks on top of this work ‚Äì would you mind posting it as a separate PR so we can take a look and get a better idea of how it works and discuss the best avenues to getting it landed?

It seems like this PR has the potential to make a handful of things better in various ways. As I mentioned above, it seems like there are other individual solutions that would collectively give the same benefits, but it's clear this pull request has a lot of potential so we're interested in it if we can solve a few things together and not regress existing behavior. Here's a summary of what we'd like to see in this pull request to feel comfortable with it:

As @sebmarkbage said above, we shouldn't execute user code (componentWillMount, render) twice in the case of a markup mismatch. There are two possibilities for how we can solve this.

First, we can look at making this PR patch markup trees instead of throwing them away and starting from scratch. This is what was suggested above and also appeals to me personally the most because it showcases the unique value of this PR and does something that our existing design can't. However, patching existing markup comes with additional complications that we need to solve. Even if there is an opt-in way to accept markup differences, we'd still want to warn in most cases for a difference because differing content on the server and client would still usually point to a bug. We also need to solve how user-mutable state is treated if we're patching things up. In particular, it would be bad if you see a post that says "Ben says hi." (from the server) and start typing a comment below it, then as you're clicking Submit it changes to "Jim says bye." (from the client), because you would be misled. React currently solves this by blowing away the tree when a mismatch happens (@lelandrichardson yes, this is supported), but one option here might be to find a way to completely reset all user state, either by somehow setting the properties back or by recreating the DOM nodes and swapping them out.

Second, upon noticing a mismatch we could completely recreate the DOM tree by reusing the React elements that were returned from `render` without calling any user code a second time. This would effectively match today's behavior when confronted with a mismatch, although the implementation would obviously differ. This is conceptually simple but might be technically difficult to implement.

In addition to solving the render-once concern, it would be good to get a better handle on the performance impact here -- what parts are slow and why. Finally, I'm uneasy with the idea that this would break when extensions add extra nodes. Unless someone (presumably @jimfb) did a lot of real-world logging on Facebook and verified with confidence it won't cause any problems, I'd like to stick with having some markers on the React nodes so we can identify them later.

Do those requirements sound reasonable? Those are in addition to any code-level changes we'd end up with after reading through the patch in detail and reviewing it for both style/structure and correctness.

I hope you can forgive us for wanting to tread carefully with this code. Even though Facebook doesn't use server-side rendering extensively, this code really is near the heart of React DOM and may affect what we can do in the future so we want to make sure to get it right and not rush instead of merging something now that we'll have to rip out a few months down the road. 
 > Server rendering is clearly important to all of you and we'd love to figure out a way to make it better, especially if we can make a significant performance improvement.

Awesome to hear!

> Overall, I'm still a little shaky on the claim that this PR is necessary in order to build a standalone server renderer so we'd be interested to see if we can facilitate building a fast server rendering without requiring this as a first step.

To be clear, I don't really believe that fast server rendering requires this PR as a first step. I'm just trying to get to a faster renderer that supports streaming in whatever way I can, and this looked like the easiest path. I am wrong fairly frequently; it may well be that other paths are easier! 

(FWIW, while I don't think this PR is necessary for a **faster streaming** server renderer, I do still believe that this PR or something like it is probably necessary for a **standalone** server renderer. In addition to the issues I mentioned above, I found some more tricksy issues with object property ordering. In particular, it seems like the current checksum requires that all server renderers guarantee the property ordering of not only `props`, but also of `state` and `context`. Yuck.)

> It sounds (based on comments from @jimfb) like you already have a working implementation of a server renderer that stacks on top of this work ‚Äì would you mind posting it as a separate PR so we can take a look and get a better idea of how it works and discuss the best avenues to getting it landed?

Sure! I think it'll take me a little while (more than a day but less than a week?) to get it presentable enough for others to read. I will work on that. 

I also have a version in my head of a fast/streaming server renderer that doesn't depend on this PR; would that be interesting for the discussion as well?

> we shouldn't execute user code (componentWillMount, render) twice in the case of a markup mismatch

Interesting to me that render shouldn't be run twice; my understanding was that render is supposed to be side-effect-free, but I'm probably missing some subtlety. Perhaps it's a case of how the API is documented to be used vs. how it is actually used in the current real world?

> Do those requirements sound reasonable?

They do, but I'm not 100% clear which of them are requirements. Here's what I heard:
- Even when there is a markup mismatch, the code should only instantiate one instance of a component per appearance in the element tree.
- `componentWillMount` and `render` must each be called at most once on that instance.
- The code should do something reasonable in the case where the user has started to interact with form elements before the client-side call to `ReactDOM.render`.
- (Unclear if this is a requirement) The performance of the code should be profiled to give a good sense of which parts are taking up the most time (presumably on many browsers?)
- (Unclear if this is a requirement) data-reactids must be left in.

Is that a fair restatement?

> I hope you can forgive us for wanting to tread carefully with this code.

Of course! It's your project, and you will have to live with the results of any PR, so it's absolutely fair to be deliberate about big changes.

As for my next steps, unless y'all tell me to do something different, I think I'll work next on polishing up the server renderer I have in a separate PR and seeing if I can make it work without this PR for comparison. Given your feedback, I don't think it's a good use of my time to address the issues in this PR until y'all have a chance to look at that code and decide if it's a path you'd rather pursue. Does that make sense?

Thanks!
 OK, so it took me a bit longer than I expected, but I just opened [a WIP PR](https://github.com/facebook/react/pull/6836) of a server renderer that supports streaming. That PR actually works on top of the current client validation in master and has around 600 unit tests to try to make sure it's up to spec. I originally was going to open two different PRs, one with a streaming renderer on top of this branch and one with a streaming renderer on top of master, but the renderers ended up being pretty similar, so it wasn't worth it to me to do both.

A few thoughts on the streaming server renderer, in no particular order:
- I'm not super proud of the code; it could probably use some refactoring into a larger number of functions.
- It uses the same checksum strategy as master and shouldn't have the double call `componentWillMount` problems that this PR has.
- I more or less followed the strategy outlined by @goatslacker above; I first wrote a bunch of unit tests against the current code base to characterize exactly how the current SSR code behaves. All told, I wrote about 140 or so new test cases. For many of the test cases, I run them against multiple different rendering scenarios (server render to string, server render to stream, clean client render, client render on top of server string render, client render on top of server stream render, and client render on top of bad markup). This means that the renderer test ends up running about 620 actual test cases. I think this gives pretty good coverage of all the special cases I found, but I'm sure there are some cases that I haven't found. I'd love for folks to let me know what they are!
- A lot of the tough logic of properties to attribute mapping is pushed into shared code in `DOMPropertyOperations`, which is a good thing.
- There may be a little more space to share code between the client validator (`mountComponent`) and this server renderer, but I don't suspect there's a ton.
- I had to disable two of the existing tests. One is a test of `unstable_handleError`, which I think is fundamentally at odds with server streaming. The other was a test validating that owners are tracked correctly in `ReactInstrumentation.debugTool` in SSR. I couldn't really see the use of tracking owners on server-side, but I may be wrong.
- My preliminary perf testing of this branch is not super encouraging. On big pages, there's a modest (~20%) perf gain, and obviously streaming is a big win for TTFB. But it is nothing like the 2-5x perf increases I was seeing in my renderer branch based on DOM validation, and I have no idea what is driving that. It could be that this renderer is just more compliant to correct behavior, but there could also be something in this branch that is unperformant and wouldn't be necessary on top of DOM validation.
- I think that there are some interesting perf tweaks we could add to this renderer going forward, but I'm not sure that there are any perf tweaks (other than streaming!) that would be uniquely enabled by this renderer. (One idea is a server-side cache of already rendered components. Another would be a Babel transform to pre-render constant components to string at compile time.)

So, some questions I'd like to ask folks on this thread:
- What do you think about this implementation strategy? Is it sustainable? Is the moderate gain in perf and the addition of streaming worth the added code complexity? Is the testing comprehensive enough to catch bugs going forward?
- Are there any funky corner cases in rendering you know about that I missed?
- What should be done about `unstable_handleError`? As far as I can tell, it's fundamentally at odds with streaming.
- Are there any ways I could communicate this better (either online or f2f) or break down the code so you can understand it more easily? I know that big PRs like this can be a bear.

(And I said this in the renderer PR, but if it's all right with folks, I'd like to keep the discussion in this PR, except for direct comments on lines of code. I think it'd be helpful to have the discussion of which direction, if any, to go forward in one place. Thanks!)
  @ev1stensberg Thanks for the write-up!

The biggest problem with having parents maintain their child state is that: you need a way to match a component's internal state with the key of the element being generated.  Once you've done this (in an automatic way), you basically end up back where we are today (with a `this.state`, managed by React).  For this reason, I don't think we'd want to pursue this within the core until we've resolved the discussion in #4595.

I'd recommend trying to find workarounds in userland, and continue experimenting with this in a separate repository.  If you really need to inject things into the core, you can probably follow an injection strategy similar to https://github.com/web-perf/react-worker-dom (although this technique is technically not supported and could break without notice).

If your library becomes popular and/or we figure out a solution in #4595, we can always reconsider.  I'm going to close this out for now, since I don't think we would want to do this until we've figured out an optimal solution to #4595.
 You are conflating props and state, but the concepts still exist at a higher-level.  Otherwise you wouldn't need a `State-to-props` and `props-to-state` lifecycle.
 Right, but then...

> The biggest problem with having parents maintain their child state is that: you need a way to match a component's internal state with the key of the element being generated. Once you've done this (in an automatic way), you basically end up back where we are today (with a this.state, managed by React). For this reason, I don't think we'd want to pursue this within the core until we've resolved the discussion in #4595.
  Dealing with the virtual DOM is a large part of what React does (ie. pretty much all of React is implementing the virtual dom rendering).  The virtual DOM nodes are created in your component's `render` function (that's what you return, when you write JSX), the nodes are used in places like `ReactCompositeComponent` and `ReactDOMComponent` (specifically, look at the `mountComponent` and `receiveComponent` functions).

This is not a bug in the React core. For this reason, I'm going to close out this issue.  A better place for discussions like this would be discuss.reactjs.org, or stackoverflow, or quora, or IRC.
 https://discuss.reactjs.org/
http://stackoverflow.com/
https://www.quora.com/
https://facebook.github.io/react/support.html
 Sure. 

Elements are what you return from your render method. https://github.com/facebook/react/blob/master/src/isomorphic/classic/element/ReactElement.js

Composite component implementation manages the lifecycle of the components you write, and updates its rendered child when a new element is received.  https://github.com/facebook/react/blob/master/src/renderers/shared/reconciler/ReactCompositeComponent.js

DOM component implementation updates the actual DOM when a new element is received. https://github.com/facebook/react/blob/master/src/renderers/dom/shared/ReactDOMComponent.js
  @arendjr No, I don't think so.  #6406 has nothing to do with events.
 @arendjr Presumably autofill fires some sort of DOM event.  When that event fires with the new value, we should fire an onChange event.  So the proper path forward is to figure out which event we should be listening to, and add the logic to ensure an onChange fires.
  This is extracted from #6046 and implements a new devtool that tracks native operations.
 Hm. What would you think about just passing the new "props" object instead of `onNativeOperation` or `onSetValueForProperty`? Like `onPropsChanged(debugID, props)`. Would that be sufficient?

How the native "props" get applied is a fast moving implementation detail of each renderer.
 Come to think of it, why isn't props already an argument to `onUpdateComponent` and `onMountComponent`? Wouldn't you need to get the props to build a debug tree for things like the Chrome devtools? Whatever API gets the props for a composite component could get them for the native component.
 Yeah, it should be an argument, I just didn‚Äôt have a use case yet in ReactPerf.

I was shooting for similar output as existing ReactPerf whose `printOperations()` print actual DOM work. Tracking new props is not quite equivalent. For example, `update style` currently only fires for changes individual values but if we were to fire events for any changed native props, the log would be spammed with `update styles` that have no effect on the render of every component containing them.

To make it useful, we would have to make the devtool aware of the fact that unlike any other native props, `style` itself needs to be shallowly unequal to the previous version, which mean we would have to keep it around and make the devtool aware of the special nature of `style` in the DOM renderer which doesn‚Äôt seem nice.

Spamming the log is not just bad because it becomes less useful. It is also bad because it makes `printWasted()` broken. If every style change is counted as a native operation, `printWasted()` will never consider components with inline styles wasted because they always _seem_ to produce native operations. Maybe this isn‚Äôt the best heuristic but this is the single method people use the most and we can‚Äôt break it.

Indeed, native operations may change any day. This is actually exactly how this devtool is supposed to work. It reports whatever the renderer tells it, the names of everts are not set in stone. When DOM renderer changes to do things in a different way, it is free to fire different native operations in the places where it interfaces with the DOM to give the user a picture of what is going on.
 printWasted could do an deepEqual test. One thing I wanted to try is never diffing native components, not store the previous props, and always override the native ones. Because the DOM calls in modern browsers now have little overhead and is effectively diffed inside the DOM anyway. The bulk of the work has already been done because lack of shouldComponentUpdate bailing out.

Basically when I turn that on, any of these assumptions in the tooling would immediately break and I'd have to go fix it.

I think there is a false assumption that DOM operations are heavy and therefore we overfocus on this level of the instrumentation. ReactPerf printing these operations is probably an artifact of that.

I'll accept for equivalence but I think we should change the heuristic and logged data to something more representative.
 > I'll accept for equivalence but I think we should change the heuristic and logged data to something more representative.

üëç 

I filed it as #6632 and will come back to it after the old ReactPerf is gone.
For now let‚Äôs shoot for feature parity.
  Hi!

It‚Äôs not entirely clear what you mean by creating this issue. The warning explains the problem, along with the link you quoted. Hopefully this is helpful, but if it isn‚Äôt, please describe the problems you had following these instructions in more detail.

If you think the warning is being fired incorrectly and you have a good reason to minify React without envifying it, please let us know in https://github.com/facebook/react/issues/6479.

I‚Äôm closing because the issue is vague and not actionable in its current form. Cheers!
  A proptype can, in general, be any validation function (it is not limited to the ones we provide).  This means that you could define your own `isNotRequired` which just returns successfully if the function is null/undefined, and otherwise forwards the value to the previous propType checker for further validation.  This can be done entirely in userland, without changes to the React core.  If you find this useful, I would encourage you to make your `isNotRequired` open source so other people can re-use the same code.

In general, proptypes are mostly legacy at this point, as things move toward static analysis tools like Flow, so we aren't really adding new features to proptypes at the moment.  For this reason, I'm going to close this out.

Feel free to continue the discussion on this thread.  If you end up implementing this and publishing the source code, please do link to your repository from this issue.
  Looks good, thanks for doing this :)
  Yeah, we (Sebastian+Jordan+Myself) were discussing this a few months back.  The problem is that the mental model of PureRenderMixin is "if props change, the component will rerender".  If you ignore functions, then someone could get in the situation where they ARE changing the function (eg. capturing a variable within a closure) and the component does not update, and it becomes very hard to debug and difficult to reason about because it breaks the mental model.

That said, ignoring function changes is "usually" safe, and can improve the performance of your app.  It's worth noting that PureRenderMixin is literally only a couple lines of code.  If you wanted to write a version that didn't cause a rerender when function references change, it would be very easy to do so.  Such a thing can be done entirely in user land.  If you find it useful, I would encourage you to make it open source so other people can take advantage of the same functionality.

I'm going to close this out, which takes it off our todo list, because this is probably not something we'd do in the React core.  Feel free to continue the discussion on this thread and/or build in userland.
  Thanks!
  Is it possible that you have a `shouldComponentUpdate` there? (Or something that implements it, e.g. `connect()` from React Redux.) There is a known issue about it in #2517.

Alternatively this may be a new issue. Can you provide a JSFiddle reproducing it?
  Seems like a reasonable start.  I know @zpao has given some thoughts to templates.
 @zpao Accept / decline?
 We'll probably change it later but this seems like a good place to start. Thanks!
  Thanks for the pull request!

In general, we don't take small changes that don't impact correctness/functionality.  The reason being that they clutter up the git history+blame, which makes it harder to understand changes to the code.  If you're looking for ways to get involved, I recommend submitting fixes for one of the existing issues.  In particular, our [good first bugs](https://github.com/facebook/react/issues?q=is%3Aopen+is%3Aissue+label%3A%22good+first+bug%22) list is a great way to get started.
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thanks for catching this! I'm going to solve this differently in #6617 and just ensure that the `.babelrc` file is packaged (which is a slightly cleaner solution IMO).
  Thanks! I left a few comments but I agree we should add this.
 @gaearon I have slightly more mixed feelings about this PR.  I tend to think it's probably sufficient to give the user a nudge in the direction of using refs, but a full fledged example here seems like overkill.  Especially since there are many other equally valid use cases for using events.  For instance, suppose you want to imperatively clear an uncontrolled component.

I feel like I would just collapse this whole section into two sentences:

> If you need to imperatively perform an operation, you have to obtain a [reference to the DOM node](/react/docs/more-about-refs.html#the-ref-callback-attribute).  For instance, if you want to imperatively submit a form, one approach would be to attach a `ref` to the `form` element and manually call `form.submit()`.

@gaearon Thoughts?  I don't feel strongly one way or the other.  It's just that attaching refs is intended as an escape hatch instead of an endorsed pattern, so a little side-note seems sufficient.
 I also had mixed feelings so I side with @jimfb.
 Yeah, we should probably update the header.  The title "Imperative operations" sounds fine to me.
 üëç 
  > the source of the problem is a the 3rd-party lib (uikit.js) that transform the dom after is was mounted 

I don‚Äôt think something like this is supported by React. You can tell React explicitly to never update children of some component that you manage manually or with a third party library by implementing `shouldComponentUpdate() { return false }` in your component. However you can‚Äôt expect that you can both change the DOM arbitrarily and re-render it with React at the same time.
 It is not possible for us to predict all possible mutations that could be applied to a DOM.  Our general rule is that external libraries should not be mutating React DOM (although we do allow you to add children to leaf nodes, so long as that node will always remain a leaf node and never receive children which are managed by React).
  @bportnoy Can you update this PR to not update the auto-generated files.  Other than that, I think this is ready-to-go.
 superceded by https://github.com/facebook/react/pull/6657
  Should we also remove ReactNativeGlobalInteractionHandler itself since it is no longer used?
  I think the correct solution (at least for now) is to handle this in user land as a separate library.  If it becomes popular, we could consider an addition to React.  This is our general recommendation for anything that is possible to handle in userland, is to prove the viability before trying to pull it into React.
 If something becomes sufficiently popular and there is value in merging it into the React core, that's always considered as an option.
  This has come up a couple times lately as being an issue (#6479, #6581, #6511), I think perhaps because we added the minification warning and people are ending up seeing they aren't getting prod code when they expected it. But there's also the argument that you want React to be production and still use NODE_ENV for other purposes.

There would be a few things to figure out to make sure envify works, and deciding what we do for other projects which currently also use the NODE_ENV pattern (eg, Relay, fbjs, third-party code, etc).

This might not be a good idea at all though and definitely isn't happening immediately, but wanted to start the discussion.
 > `EVERY_DEPENDENCY_IN_MY_SYSTEM_ENV`

Definitely want to avoid that.

> If you must not conflict with `NODE_ENV`, maybe `BUNDLE_ENV` or `BUILD_ENV` and the world can follow suit.

Yea, this is interesting and could be an approach to take. There's also the concern that sometimes you are running in Node and do want `NODE_ENV` so fallback might be necessary as others have proposed. That would make our transformed code even uglier (at least until we have more confidence minifiers can handle the output of https://github.com/facebook/fbjs/pull/86)

Thanks for the quick feedback all!
 Babel is an interesting case because people use it both on the client and in production, and `env` in `.babelrc` reads from `BABEL_ENV` with a fallback to `NODE_ENV` (which is what most people specify). Introducing `BUNDLE_ENV` could be a solution but I feel like it would make the Babel situation more confusing.
  In general, if you are minifying your code on staging to simulate a production environment, you should probably be running the production copy of React just in case there are any subtle differences in the code paths (there shouldn't be, if we did everything right, but you never know and it's that type of bug that can really bite you).

Anyway, closing as a duplicate of https://github.com/facebook/react/issues/6479
  What do you mean by ‚Äúdoes not accept‚Äù? As far as I can see accepts any kind of components that React supports; otherwise, nobody would be able to use them in JSX. Here is an example: https://jsfiddle.net/7vuL1Lg5/.

In the future, please try to provide a reproducible example when filing an issue, or at least provide more context. It is hard to help without understanding what precisely you were trying to do, and how exactly it broke.

Thanks!
 No response from OP.
 On line 25, `element` is not a jest expect, so it doesn't have a `should` property.  You probably intended to write something more like `expect(element).should.be.ok();`

Also, to be clear, the thing returned by `renderIntoDocument` is an `instance`, not an `element`.
 @hotay As per the note at the bottom of http://facebook.github.io/react/docs/reusable-components.html#stateless-functions, stateless functions do not have backing instances.

Also mentioned in the `React.render()` documentation: https://facebook.github.io/react/docs/top-level-api.html#reactdom.render

If you want a reference, you will need to wrap the stateless function in a stateful component (like an ES6 class component) which does have a backing instance.
  Can you please provide an example reproducing the issue? It‚Äôs not entirely clear what is broken in your opinion.
 @mtsee Sounds like you're saying this is not a React bug, so I'll close it out.  If you believe you've found a bug in React, please provide a jsfiddle that demonstrates the issue and we can reinvestigate.
  You are technically correct. However, this is based on the existing DOM property called `defaultValue`. If we go down this route we should also rename `<img />` to `<image />` but that ship has sailed.
 Maybe we should allow it to update until the first change which causes the value mode to change then.

> On Apr 23, 2016, at 4:45 PM, Thomas Mayrhofer notifications@github.com wrote:
> 
> But if the naming decision is based on the DOM property defaultValue then it should behave exactly like it.
> 
> The element has a value mode flag which is either value or default. Initially, the value mode flag must be set to default.
> 
> When the value mode flag is in mode default, the contents of the element represent both the value of the element and its default value.
> 
> The defaultValue IDL attribute, on getting, must return the element's default value. On setting, the attribute must set the element's default value, and, if the element's value mode flag is in the mode default, set the element's textContent IDL attribute as well.
> 
> The defaultValue IDL attribute, on getting, must return the element's default value. On setting, the attribute must set the element's default value, and, if the element's value mode flag is in the mode default, set the element's textContent IDL attribute as well. (https://www.w3.org/TR/html5/forms.html#concept-output-mode)
> 
> This means that the browsers defaultValue can also be changed after the initial rendering, if the input field is in value mode: default. If the input.value changes, the value mode is set to value. The defaultValue can't be set anymore. See Quick and dirty example
> 
> The value IDL attribute must act like the element's textContent IDL attribute, except that on setting, in addition, before the child nodes are changed, the element's value mode flag must be set to value. (https://www.w3.org/TR/html5/forms.html#the-output-element)
> 
> Currently React only sets the default value during initial render. If for any reason the default value changes in a rerender react won't handle it. So that's why I think the defaultValue should either be renamed to initialValue or change the behaviour so that defaultValue can be updated as long as the value mode is set to default.
> 
> ‚Äî
> You are receiving this because you modified the open/close state.
> Reply to this email directly or view it on GitHub
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 The JSON there is a simplified representation of what's in the tutorial repo that we expect people to be following along with. However since we did have these ids in the data earlier in the tutorial, this is totally fine.
 @yuji0602 Please sign the CLA when you get the chance, so we can merge.  Thanks!

https://code.facebook.com/cla
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 Just noticed this was against the `15-stable` branch, will cherry-pick over to `master` to make sure we don't lose this in the future.
  This is a result of the fact that you are combining the short syntax and then setting extra specific properties. This is fine for initial render, however since only `background` is updated on render, when that is set on the node, it overrides the other properties. Just like with plain CSS the order of operations is important to remember. My recommendation is to not treat JS styles like CSS because it is dynamic (unlike CSS). Either use the shortcut syntax entirely or ensure that each property you want set is explicitly declared.

Here's it in action https://jsfiddle.net/9x2jby1z/ (your issue) vs https://jsfiddle.net/9x2jby1z/1/ (working due to explicit setting of only `backgroundImage`).

Since we don't intend to write a CSS parser and know the varying ways that you can specify these shorthand properties, I think I'm going to close this out as an unfortunate but expected behavior. Sorry it caused you problems!
  We need to put an end to these one-line jsdoc fixes.  Not sure what to do about the problem though.  I don't want to reject these PRs because having wrong jsdocs is worse than having no jsdocs - it can be confusing as hell when the docs are lying to you.

Anyway, thanks @elas7!  If you're fixing up jsdocs, it would be great if you could go through and get as many of them as possible squeezed into a single PR.  But if you're just browsing the code and happened to see this one, great, thanks for fixing!
  Effectively a duplicate of https://github.com/facebook/react/issues/2517
  @jscissr updated the pull request.
 I suppose this technically fixes a regression, since we previously rendered new elements to markup.
  Thanks!
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Can you please sign the CLA so we can merge?

https://code.facebook.com/cla
 Ping @ghost
 Great, thanks @ghost!
  There's no keywords list on GitHub but maybe adding it to the package.json would get indexed and ranked high?

Otherwise you're totally right - it's called React and so we won't be adding "ReactJS" to any of our documentation/readme/etc.
 Perhaps a keywords section at the bottom of the README/page?  That's the poor-man's solution to dealing with keywords in wiki systems that don't support keywords.  I don't feel strongly one way or the other, but we should make a decision about the disposition of this bug.
 Just going to close. I don't think this is really any different from any other project (Eg searching github for "emberjs" doesn't get you to their project either) and not really worth doing hacky things to try to optimize.
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
  Components suddenly disappearing after a refactoring would be frustrating IMO.
 Proptype checks have a very measurable impact on the performance of your application.  That's why proptypes aren't checked in production.

The runtime behavior of development mode must match the behavior of production mode.  So if the behavior is going to change (ie. don't render the component) then we would be forced to do the proptype checks in production (which we don't want to do, because it's slow).

For this reason, we're probably not going to do this, so I'll close out the issue.  Feel free to continue the discussion on this thread, and we can re-open if our thinking on this matter changes substantially.
  The bug that was fixed was related to _synchronously_ updating the input state. This was always supported, and broke in 15.0.0. Asynchronously updating without losing the position was never supported as @syranide noted.
  Can‚Äôt reproduce this: https://jsfiddle.net/s9ej9Lp2/1/

<img width="335" alt="screen shot 2016-04-21 at 12 30 07" src="https://cloud.githubusercontent.com/assets/810438/14707467/d9faf674-07bc-11e6-8e7a-d1c386f9c096.png">

Most likely you have `setState()` or top-level rendered triggered by a Promise, and you‚Äôre using a Promise implementation that  doesn‚Äôt log unhandled rejections, so they get swallowed.

If you think this is a bug in React please provide an example that reproduces it, but for now I‚Äôll close.
 No problem. I suggest to make sure you use an implementation that logs unhandled rejections because it‚Äôs very easy to make mistakes like this.
  Thanks!
  As per the discussion today...

Sometimes you are developing on a platform that doesn't have devtools (safari, etc).  The problem is that you are looking at a whole pile of markup, and can't tell which components rendered it.  Without devtools, the output markup is really hard to navigate.  It would be cool if we had comment nodes (or a `data-reactcomponent` attribute) that helps users navigate the output.

These nodes would be rendered only in dev mode or with some flag turned on or something.
 Would it have all the owners and parents too? On FB this would look like `<img data-reactcomponent="Image" />` otherwise. Which is best practice so not very helpful.

This should also go in DEV mode only since the names can get minimized and removed and it's expensive putting an attribute on everything. That would be very risky since someone will start relying on the attribute being there for selectors and it will break in prod.
 Comments would require the child reordering logic to take that into account. It is probably possible but I wouldn't want to make that more complicated because then it is harder to change. It is already difficult enough to come up with new algorithms.

On the flip side. It shouldn't be that hard to get the real devtools working on any browser.

The original devtools worked with Safari mobile debugging using the remote protocol. Now that we have our own protocol it should be even easier.

We could open the devtools UI in a stand alone iframe environment that inspects the main page. We could also do remote debugging using the RPC protocol. We already do this with React Native.

That would get us all the other features that we have or are building such as perf tools etc.
 > On the flip side. It shouldn't be that hard to get the real devtools working on any browser.

There are a lot of browsers in the world (including ones on dumb phones), and we can't reasonably cover all target devices/environments.  Sometimes bugs only appear in specific browsers (especially older/dumber ones which don't support the devtools), which was one of the primary motivations of this conversation/issue.
 I don't think it would be too hard to reconcile the comment nodes, especially since we don't really walk the DOM anyway (since v15, we retain references to the nodes directly, though I suppose this might potentially change with stateless functions.  Regardless, if it does change for stateless functions, then we're touching that algorithm anyway and could potentially add this).

That said, the attribute solution seems fine to me.  For nodes with multiple composite parents that don't add DOM nodes, the attribute could be the parent/owner path to that element.

Anyway, I don't really have a strong preference for how we solve this, but it would be good to have a general solution that doesn't depend on us supporting the particular render target, since I doubt we want to build devtool support for all the various webviews on all the various platforms/environments.
 We can support any browser that has a WebSocket easily. We just install the hook from the web page. There are WebSocket polyfills like socket.io that covers every browser.

You simply present the UI in a different browser than the one you're remote debugging. That's how the Safari debugger used to work when the React DevTools was first launched.
 > then we're touching that algorithm anyway and could potentially add this

This is exactly what makes refactoring so hard because you can't reason about all these special cases. It is just too many of these to think about at once. 
  Hey, glad to see you're so excited about contributing!

In general, we don't take small fixes like this.  For this change in particular, there is no chance that the performance difference is a result of this change.  The variable in question is an integer, so a better default value would be zero (instead of null, which implies a pointer reference).  However, we generally avoid small fixes like this because they clutter the commit log and make it harder to find the relevant commits.

If you're looking for a good first bug, check out https://github.com/facebook/react/issues?q=is%3Aissue+is%3Aopen+label%3A%22good+first+bug%22
  Refs are dom nodes, and thus we suggest you don't store them in state, right?  You always store them somewhere on the instance?

Assuming so, calling setState in a ref callback sounds like an antipattern. https://github.com/facebook/react/issues/6249#issuecomment-212589250
 Let's confirm the assumption before working on it :) I could see an argument for allowing setState in the ref callback. Also refs aren't always DOM nodes (composite components can be refs) & you could be doing something besides storing the node regardless. You can get into the same infinite loop if you call setState in componentDidUpdate so let's not rule out the potential use case yet.

cc @sebmarkbage 
 Yea, there's plenty of use cases for this. The beauty of a ref callback is that you can start acting on it once a child becomes available and then do something with either the child or its parent. It is effectively componentDidMount for a child.
 @sebmarkbage Do you have any specific use cases in mind?  The only thing I can think of is child measurement, but you should probably wait for all your children to render and then measure them in componentDidMount instead (to avoid layout thrash of measuring multiple children).

What would you be doing that involves a set state?
 I just chatted with Sebastian.  The conclusion of that discussion was "yeah, it's probably 'supported but discouraged', sounds kinda like an anti-pattern but refs are an escape hatch anyway, so do whatever you want at that point."

Action item on this issue is to update the docs (we should create a compatibility table, about how we for each action within each lifecycle) to indicate/clarify our current thoughts around this pattern.

Closing in favor of https://github.com/facebook/react/issues/6586
  Sounds like a bug, probably a good first one.
 It's probably not a "good first bug" (it will surely involve at least looking at our event system, which is anything but good for a first dive into the code). But people are welcome to try :)
 Yeah, I was torn on labeling this one.  We need a "good third bug" label :).

The reason I thought it might be a reasonable first one is that the code from controlled text inputs can probably be copy-pasted here nearly verbatim.  In fact, I'm a little surprised it doesn't already follow the same code path.
 I'm pretty sure that typing in a `<input type="number">` doesn't fire the same events (or only fires them for some interactions) so we just don't even know anything is happening. Otherwise I'm mostly sure the we don't differentiate between text and number types so we're already running the same code.
 Yep, @syranide is correct.  https://jsfiddle.net/1tscfoLf/

Not sure if there is anything we can do about this at the moment, short of writing our own handlers based on cursor position and keystrokes.  Maybe that's what we need to do.  (or request revisions from W3C, but that's a longer term thing)
  If we're going to do this, it seems like we should be consistent with doing it for all the addons.  But I'm not sure I understand who the target audience is, because anyone touching that code will almost certainly know where those docs are located.

@dmnd How did you run into this being an issue?
 Hmm.  I think I could be ok with it if we documented all the jump points (the most critical ones being the React core API, and all the addons).
 Yeah, ok, seems fine.  Thanks!
  Are you measuring the production build?
 Try to add `.min.js` instead. We know developer builds regressed but this shouldn't be the case for the production ones. 
 @spicyj I remember you saying you have ideas about low hanging fruit to Make Dev Builds Fast Again, anything in particular that comes to mind? This could be a nice first bug. 
 Wait, v15 dev is 3.5x slower than v0.14 dev? That doesn't sound right.

@gaearon Just gotta start with profiling to see what's slow.
  Hi, thanks for reporting. This is a duplicate of https://github.com/facebook/react/issues/6547 and two other issues linked from there. It is fixed in master but this fix hasn't gotten into a release yet. Let's keep this open so people don't file more issues. 
 Fixed in https://github.com/facebook/react/pull/6442

@gaearon We generally close out issues when things have been merged into master.  The reason is that otherwise, it's too hard to tell what is still an active item (needs to be fixed) verses things that are already fixed and remain open only to help people find them.  You could read through all the comments, but that takes time (especially if you're going through a bunch of them) and they are often nuanced with regards to remaining action items.  You don't want to read through an hour of comments, only to discover that the whole thing is fixed and no longer relevant.
  Sounds like an iOS bug.  As best as I can tell from reading the spec, a `fieldset` tag is NOT required to be associated with a form.

As per https://www.w3.org/TR/html-markup/fieldset.html#fieldset-interface, the form attribute has a question mark after the type, which presumably indicates that the attribute may be null if there is no form owner.

>  readonly attribute HTMLFormElement? form;

The `fieldset` [spec preview](https://dev.w3.org/html5/spec-preview/the-fieldset-element.html) explicitly states that "The form attribute is used to explicitly associate the fieldset element with its form owner", and links to https://dev.w3.org/html5/spec-preview/association-of-controls-and-forms.html#form-owner

> A form-associated element can have a relationship with a form element, which is called the element's form owner. If a form-associated element is not associated with a form element, its form owner is said to be null.

And the first example in the w3c wiki (https://www.w3.org/wiki/HTML/Elements/fieldset), while non-authorative, has a `fieldset` without a `form` element, which seems consistent with the spec.

My recommendation is to file a bug with ios/chrome.
  I agree with @jimfb here. We say what we do support so I don't think we really need to clarify what we don't support. Blog posts are a little different and can use looser language as they are anchored in time.
  > I would intuitively upgrade them to
> "react-addons-css-transition-group": "^0.15.1",

This would be 15.0.1, as we jumped to a major version now.

> However, I cannot find any changelog or gitrepo belonging to theese add-ons

[React 15 blog post](http://facebook.github.io/react/blog/2016/04/07/react-v15.html) lists the complete changelog, including the addons. We don‚Äôt actively work on addons so you shouldn‚Äôt expect many breaking changes there.

I looked through the blog post, and it seems that we made no changes to either of those addons.
  @ev1stensberg 

`bind()` is not necessary with `React.createClass()` as the methods are autobound. Also the code is identical but behaves differently in different versions, so it‚Äôs an indication that it might be React‚Äôs fault.

@mavisd 

I think this is the same as #6440 and #6434, and was fixed in #6442. The fix is not out in 15.0.1, but it should get into the next patch release. I can confirm this working with the build from the master:

<img width="175" alt="screen shot 2016-04-19 at 15 32 18" src="https://cloud.githubusercontent.com/assets/810438/14642839/f1e635ca-0643-11e6-83c4-cfa9e116933e.png">

I‚Äôm closing for this reason.
  @ev1stensberg 

I think this issue about Content Security Policy, not Communicating Sequential Processes. Yeah it‚Äôs confusing üòÑ .

@hackvertor 

The code you are looking at is not a part of React. It‚Äôs from `node_modules/fbjs-scripts/babel/node_modules/babel-core/browser.js`. Unless you want to run Babel in browser, you don‚Äôt need it to use React. The React builds [available on the website](http://facebook.github.io/react/downloads.html) do not include this code so you can use them if you‚Äôre having trouble getting transitive dependencies of the React build process approved in code review or something like this.

I‚Äôm closing for this reason, as it‚Äôs not a problem with React.
  FWIW, this would be fixed by https://github.com/facebook/react/pull/6406, but we'll see if/when that gets merged.
  Appears to work fine for me: http://jsfiddle.net/314xxopf/
 @moret When I run the code in your fiddle, the video appears to be muted (no sound).  That's the only thing that React guarantees; React is not required to set the attribute if it is not required.
 When rendering on the client we'll use the property since it was determined that modifying the attribute didn't actually affect the video. We must set it as `node.muted = true|false`, so you don't see that reflected in the attribute.
  I‚Äôm not sure I understand what you describe. Can you rephrase this from the use case perspective? What are you trying to accomplish, and why?
 I don‚Äôt understand what `ref={this.state}` is supposed to do. Refs give you access to the component instance in case you want to call methods on it imperatively. There are string refs (e.g. `ref='something'`) that make the instance available as `this.refs.something`, and callback refs (e.g. `ref={instance => this.something = instance}`) which let you do the same thing but are more generic and composable. I don‚Äôt understand what you are trying to do with `ref={this.state}` though.
 I don't think we'd do this with `ref={this.state}`, and we certainly can't access objects that have been GC'd (as of ES2015).  The general issue of externalizing state is being tracked as https://github.com/facebook/react/issues/4595
  Unlike in #5332, this does appear to fire in chrome (http://jsfiddle.net/x14c21g0/) so it's odd that we're not firing the event in React.
  Proxies are not supported in legacy browsers.  It will likely be a couple of years before we can use them outside of development mode (ie. on a production code path).
  Looks good to me, thanks. I‚Äôll leave this open for a few days in case anybody has objections.
 @gaearon Just make sure @zpao and @jamesgpearce see this.  It's a pretty minor change, but since it touches the copyright header, it's good to get some eyes (potentially from legal).

@jamesgpearce should we ping legal on this, or is this sufficiently innocuous?
 There's nothing legal needs to see here.

I'd prefer not to make this all JSDoc-y. Can we just stick `@license` above the actual license part (not the copyright) or even just `@preserve` at the top?
 FWIW, this change is only going to impact the `react[-*].min.js` files that end up on the CDN and in `dist/` in the npm package. It's not going to matter for anybody compiling the npm package via browserify or webpack (except for the webpack config that sticks the dist file in and skips the node package)
 That's going to be much more involved and would require changing every license header we have in `src/` (or maybe a new build step). I personally don't think that's worth it and you probably need to make similar changes to other libraries to really be effective. And fwiw, you probably want all of those compiled away with maybe the exception of 1 for file size purposes. Maybe it would be enough to preserve the headers in the entry point (src/isomorphic/React.js).

Can you make sure this works how you expect and describe that case so we have a better idea of what you've tested.
 @andykenward updated the pull request.
  Curious: What browser+version are you using when you see this error?  Any chance it's Chrome 49?  Can you reproduce on Firefox or any other browser?
 Also, can you provide a simple jsfiddle that demonstrates the issue?
 @rickychien @omerts If someone could try to produce a minimal repro / jsfiddle, that would be very helpful!
 @rickychien @omerts Another question, are you guys using ReactRouter and/or Redux?
 I trimmed it down to a case that involves just React.

Fiddle: https://jsfiddle.net/ycLw3bbq/

``` js
var callbacks = [];
function emitChange() {
  callbacks.forEach(c => c());
}

class App extends React.Component {
  constructor(props) {
    super(props);
    this.state = { showChild: true };
  }
  componentDidMount() {
    this.setState({ showChild: false });
  }
  render() {
    return (
      <div>
        <ForceUpdatesOnChange />
        {this.state.showChild && <EmitsChangeOnUnmount />}
      </div>
    );
  }
}

class EmitsChangeOnUnmount extends React.Component {
  componentWillUnmount() {
    emitChange();
  }
  render() {
    return null;
  }
}

class ForceUpdatesOnChange extends React.Component {
  componentDidMount() {
    this.onChange = () => this.forceUpdate();
    this.onChange()
    callbacks.push(this.onChange);
  }
  componentWillUnmount() {
    callbacks = callbacks.filter(c => c !== this.onChange)
  }
  render() {
    return (
      <div key={Math.random()} onClick={function(){}} />
    )
  }
}

ReactDOM.render(<App />, document.getElementById('container'));
```
 Also, a few observations:
1. This only happens with `onClick` listeners which [get queued here for Mobile Safari](https://github.com/facebook/react/blob/9df54e0fce209a60c49145da9fc3f15b2671e719/src/renderers/dom/client/eventPlugins/SimpleEventPlugin.js#L622-L632).
2. It seems related to batching. In the initial reproduction cases, I still used a `<Link>`, and I noticed that navigating inside `setTimeout` instead didn‚Äôt repro the problem, but wrapping it in `unstable_batchedUpdates` did. In my small repro above, I don‚Äôt use events or `unstable_batchedUpdates`, but it seems like doing this stuff inside the initial render batch has the same effect, so I‚Äôm calling `forceUpdate` and `setState` in `componentDidMount`.
 Replacing

``` js
  render() {
    return (
      <div key={Math.random()} onClick={function(){}} />
    )
  }
```

with

``` js
  render() {
    return (
      <img key={Math.random()} />
    )
  }
```

reproduces #6371 (`Uncaught Invariant Violation: Must be mounted to trap events`).
 I guess the issue here is that all `transaction.getReactMountReady().enqueue` calls in `mountComponent` seem to imply that `unmountComponent` is guaranteed to happen after `getReactMountReady()` callbacks have happened, but this may break if one of those callbacks can cause children component to unmount.

I think the sequence is:
1. Composite parent enqueues its `componentDidMount` in `transaction.getReactMountReady()`
2. DOM component mounts
3. DOM component enqueues DOM-related in `transaction.getReactMountReady().enqueue`
4. `transaction.getReactMountReady()` starts calling its callbacks
5. The composite‚Äôs `componentDidMount` was registered first, and it queues an update to the child which causes the DOM component to unmount
6. DOM component unmounts
7. `transaction.getReactMountReady()` proceeds and calls the unmounted DOM component‚Äôs callbacks
 Yet another manifestation of the same issue (this time, only in master).

``` js
  render() {
    return (
      <input key={Math.random()} />
    )
  }
```

gives `Uncaught TypeError: Cannot read property 'valueTracker' of null`
 I won‚Äôt be looking into this more for now as I‚Äôm not sure how to proceed.
I think @spicyj might have more context here.

This is a visualization of what happens.
Note how `div(4)#reactMountReadyCallback` happens after `div(4)#unmount`.

<img width="684" alt="screen shot 2016-04-22 at 19 45 34" src="https://cloud.githubusercontent.com/assets/810438/14751654/cfca1a16-08c2-11e6-9840-cc8823b1e97b.png">
 #6371 was reported earlier and these two errors are caused by the same underlying problem so I propose to close this one in favor of #6371. @jimfb?
 As per @gaearon, yes, this is a duplicate of #6371 so we'll close in favor of that.
 I just landed a fix for this (#6650) which will be in 15.0.3 or 15.1.0, whichever we release next.
 No need for additional repro cases now unless you confirm they're still broken in master (or in 15.0.3/15.1.0 when they come out).
 @kilianc master branch.
 Easiest is to install from npm from

http://react.zpao.com/builds/master/latest/react.tgz
http://react.zpao.com/builds/master/latest/react-dom.tgz

because you can't use our github repo without building.
 @kilianc I believe this issue is fixed in master.  Not sure why you're unable to repro on 15.0.2.

There was also a super similar issue that was only showing up on chrome 49, which vanishes when you upgrade to chrome 50.  Chrome browsers auto-update at some point, so perhaps that was your issue.

Either way, glad it's resolved for you!
 @schneck It will be solved with the next update.
  Can you provide a simple jsfiddle (ideally without meteor) that demonstrates the issue?
 @pricetula Hi! I hope you don‚Äôt mind that I formatted your messages so the code is highlighted. You can include small blocks in backticks (`), and large blocks between triple backticks: ```js and ```. This helps everyone read the issue a little easier in the future. Cheers!
 @pricetula No problem. You are welcome!
  Looks like these are super easy to find+fix, so it might not be terrible to just break this.  On the other hand, we haven't warned for a release and there is no harm in leaving the code here.  Honestly, I don't care what we do here; @zpao do you have any thoughts/preferences?
 Yea, we never actually respected the `@deprecated` in JSDocs, nice find :). We should warn for 15 but it would be safe to remove like this in 16.

So this is actually an interesting case and will need a slight bit more thought on the best way to do this since we need a different change to made for the 15-stable branch. This is totally fine to go into master as is so I'm going to accept but let's hold off on merging until we document the exact process (would hate for us to lose track of this)
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 @dlax Thanks, this looks good.  Can you sign the CLA (https://code.facebook.com/cla) and then I think this is ready to merge.
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 Thanks @dlax!
  > (not consistent will have a side effect for ref call)

What side effect?  How is the code change related to the new unit test? (they look orthogonal at first glance)
 @yiminghe updated the pull request.
 @yiminghe updated the pull request.
 cc @gaearon (seems related to #6362)
 Hmm. I don‚Äôt think #6362 is related per se.
The code that #6362 removed looked like this already:

``` diff
-      if (__DEV__) {
-        ReactCurrentOwner.current = this;
-        try {
-          inst = new Component(publicProps, publicContext, ReactUpdateQueue);
-        } finally {
-          ReactCurrentOwner.current = null;
-        }
-      } else {
-        inst = new Component(publicProps, publicContext, ReactUpdateQueue);
-      }
```
 I guess this fix is correct. The logic here is very confusing though and I don't know what we can do to avoid bugs in the future. ReactRef should also not check the owner for function refs because there is no reason to, so I amended your commit to check that too and merged as b11540ccb2321aeb7259fcf0b3a38aeeea35231d.
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 ping.
  Yeah, this is an error related to your `npm` configuration, rather than a bug in the React core.  For this reason, I'm going to close out the bug, since we try to keep github issues for tracking bugs in the React core.  Feel free to continue the discussion on this thread or move your question over to StackOverflow.
 The issue is due to `react-tap-event-plugin` and `react-mounter` wanting React 0.14.
You should update them if they have new versions compatible with 15.
You can also switch to using `npm@3.x` which doesn‚Äôt enforce peer dependencies, and proceed at your own risk.
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 Hi, thanks for the PR.

I think it was actually consistent. We use `/* */` for method and module JSDoc descriptions, and `//` for inline comments (even if they are multiline).

We‚Äôd also prefer style fixes like this to be part of some larger changes to functionality. We generally don‚Äôt take purely stylistic small fixes as they add to the PR noise and make it harder to see what really changed between the releases.
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
  Thank you for the feedback!

The context API is an experimental feature, and its API is definitely a work in progress. As React phases PropTypes out in favor of static analysis (Facebook mostly uses Flow for this), I expect that the context API will also stop relying on PropTypes. However I don‚Äôt think we plan to change it in the near future; at least not until we‚Äôre confident how we want to change the context.
 Context types is not likely to become optional in the near/foreseeable future, although I suppose anything could change.  There are several reasons we would want to keep contexttypes.  Most of them revolve around the fact that proptypes are implicit, and thus much harder to reason about than props which are easy to see and passed explicitly.  Some reasons are: readability, documentation, and correctness (context types are implicit and can have name conflicts, making them much more error prone, and the types can't be verified at compile time even by a language like typescript).  But the most important reason of all... is because it opens the door to some internal optimizations... Specifically, it is helpful to know which context variables a component is listening to because this allows us to know which components may need to be re-rendered when a variable changes.

If you are using typescript and don't want to jump through the hoops of specifying the types of your context variables, you can specify all of them as `React.PropTypes.any`, which will match anything.  Then you're effectively just specifying the name of the contexttype, which is the minimum information React needs at runtime.
  Hmm, it could be that Object.assign is at play here. I didn't think that would matter on initial render at least (I don't think we use a copy of the style object) but I'm just skimming this code path. It would make sense that the order is getting screwed up and red gets set before none.

The computed values are going to be misleading due to the use of createElement. In 14 we generated a string of markup for initial render which would look like `<div style="background: none; background-color: red"></div>`.

In 15 we create a DOM node and then set each style, just like we would do for updates in 14 and below. So `var node = document.createElement('div'); node.style.background = 'none'; node.style.backgroundColor = 'red';` Chrome doesn't report that sequence in the computed value so you only see the final value.

So what would be interesting is if you followed the same steps as React is doing in both versions of Chrome and see what happens. http://jsbin.com/dekiyulane/edit?html,js,output
 The Object.assign issue has been pretty random and inconsistent in my experience. Thanks for checking!
  Are you using decorators/inheritance, or HOC?  Higher order components render their children (as per https://goo.gl/vbSrxD) and so they shouldn't be a problem / shouldn't hide the component name.

https://github.com/facebook/react-devtools/issues/308 may be relevant to you.  You might be able to achieve what you're looking to do by setting displayName.

Regardless, this is mostly a usage question.  We use github issues to track bugs in the React core.  Usage questions are better addressed on StackOverflow.  For this reason, I'm going to close out the issue, but feel free to continue the discussion on this thread or move it over to StackOverflow.  To the extent that it's a feature request, it is tracked in other places like https://github.com/facebook/react-devtools/issues/308.
  I think this was fixed in https://github.com/facebook/react/pull/6442
  This is probably unintentional.
  For those following along, I assume @Spacerat is referring to https://facebook.github.io/react/blog/2013/08/19/use-react-and-jsx-in-python-applications.html

It's an old blog post (with a date), not part of the living docs.  We generally don't go back in time and update old posts because things are constantly changing over time and it's hard enough to just keep the main documentation up-to-date.

If someone wants to add a red note box that says "Update: PyReact is now deprecated", I think I would be ok with that and we would likely accept such a PR.  cc @zpao because he feels the strongest about updating historical posts.

Anyway, I'm going to close this out to take it off our radar, because we don't generally track/update historical posts.
 Meh, If somebody did want to add a note like that, that would be fine. But I don't think we need to change the content of the post. And linking to the actual project is probably good because it has a nice big deprecated notice in the readme.
  This is a usage question, rather than a bug in React.  Your `shouldComponentUpdate` function is explicitly telling React that it should not update, so obviously it does not update, this is expected behavior.

Optimizing components that can take in arbitrary children is somewhat non-trivial.  In general, it will require walking/diffing the children in some way, and (for completely general children) this is technically not possible for the same reasons that `componentWillReceiveProps` does not guarantee props will be different (http://facebook.github.io/react/blog/2016/01/08/A-implies-B-does-not-imply-B-implies-A.html).

Also, keep in mind that `shouldComponentUpdate` should be used somewhat sparingly in critical parts of your application.  Diffing values (especially a tree of values, like `children` is likely to be) can be expensive, and if your `shouldComponentUpdate` is ultimately going to return true anyway, than React will need to do that same diffing again during reconciliation, so you're just wasting CPU cycles (ie. it might actually be cheaper as a whole to just skip implementing that function).

Anyway, I'm going to close out the issue, since it's not a bug in React.  Feel free to continue the discussion on this thread, or move the discussion to StackOverflow.
 This might be an inconvenience or even a conceptual problem, but definitely not a bug.
As you note here:

``` js
  shouldComponentUpdate(nextProps) {
    // na√Øve, only for demo purpose
    return nextProps.color !== this.props.color;

    // how to optimize this for children??
    // it doesn't make sense for it to have to check for its
    // children, as it's simple composition, it shouldn't
    // have to care about what is passed through it.
  }
```

Indeed, just `nextProps.color !== this.props.color` will bail out for `children` changes so it is not enough. Usually people [compare props shallowly](https://facebook.github.io/react/docs/shallow-compare.html) so `children` are included in the comparison.

This begs the question: isn‚Äôt this negating the benefits of `shouldComponentUpdate`? If your children are static, [hoisting constant elements in production would help](https://medium.com/doctolib-engineering/improve-react-performance-with-babel-16f1becfaa25) but this doesn‚Äôt apply to cases where you rely on `this.state` inside the child element.

There was some discussion about taking `children` off of `props` so you might want to have a look at it for some historical context: https://github.com/facebook/react/issues/4694. 
 For your use case, you can take the same approach (I believe?) that FixedDataTable takes. Rather than accept `children`, accept `renderChildren`. For example,

``` js
render() {
  return (
    <MyTable
      renderRow={this.renderRow}
      renderHeader={this.renderHeader}
    />
  )
}
```

Make sure the function references don‚Äôt change on every render (just don‚Äôt bind them in `render()`) and you‚Äôll be fine. Sure, closing over `this.state` won‚Äôt bring updates in this case:

``` js
renderRow() {
  // won‚Äôt update
  return <CustomRow data={this.state.data} />
}
```

To work around it, make any necessary data props to your table so that it can pass them back to the `render*` props whenever it needs:

``` js
render() {
  return (
    <MyTable
      renderRow={this.renderRow}
      renderHeader={this.renderHeader}
      data={this.state.data}
    />
  )
}

renderRow(data) {
  return <CustomRow data={data} />
}
```

This way, unless `data` changes, re-rendering `<MyTable />` won‚Äôt re-render every row.

> How would you do this in practice? I understand shallowCompare on the parent props (which include children) but wouldn't that only basically check for nextProps.children === this.props.children? In which case, I feel like it would be different every render...

Yes, however, most components in my experience don‚Äôt take custom `children` so this only comes up in limited cases, and usually `shallowCompare` works fine. When it doesn‚Äôt, you can make it work good by using the workaround I suggest above.
 Anti-pattern is a loaded word. It‚Äôs a tool; like any tool it has upsides and downsides. In this particular case I think it‚Äôs very appropriate.
 Well, some anti-patterns are just bad, always.  But I wouldn't classify passing a render callback as an anti-pattern, I'd just classify it as a pattern.

The pattern is used pretty commonly when a parent needs to pass necessary info to an unowned child.  I think it's at least as good as cloning elements or using context.
 As long as the callback is pure, everything remains pure.  The component is still a function of props (even though the prop happens to be a pure function).

`shouldComponentUpdate` can check equality of the function, to see if the function is referentially equal to the old function.
 The way I see it, you don‚Äôt get the render thousands of rows and keep perfect encapsulation :smile: . Something‚Äôs gotta give.

That said I don‚Äôt see where the encapsulation is breaking. If you rename it from `counter` to `rowData`, it‚Äôs pretty abstract and can work for different kinds of children. The fact that you pass a function rather than children themselves‚Äîwell, that‚Äôs an optimization. Maybe you want to support a million rows in the future, and creating all of them is a waste anyway, so you build support for lazy creation right in your API. I don‚Äôt really see an issue with this.
  Overall this is a good question to ask elsewhere while we try to keep GitHub focuses on bugs and specific issues about React itself. Using discuss.reactjs.org or Stack Overflow are generally better places for this.

I'm going to close out since there's nothing directly actionable and it's not something we're going to build into React itself, there are several reasonable approaches to solving this problem and they all involve additional tooling.

Now that said, a bit of insight into what we do at FB - we have a special component that gets transformed with knowledge of the target language and translations. So we would do something like `<h2><fbt>HeyHo</fbt></h2>` (to use your example). The `<fbt>` ends up being a lookup and we have the option to either statically transform to a new string with babel or whatever to the right set of languages (and potentially build separate bundles for each language). Or it could be more complex and do the lookup at runtime and be a real composite component.

At a high level this is similar to what I'm understanding of what you wrote. I'm not a huge fan of your exact proposal with using quote types to differentiate. I think you'd have better luck with something like a unique JSX component (aka "an extra html tag") or something that's also unique. Since you are effectively just doing templating, taking some cues from handlebars and using `{{String}}` wouldn't be too bad either.
 Not sure what the meteor approach means. I used that simply as more unique signal than a double quote, which has lots of uses in natural language which you might want to remain. Eg if you want to translate `<h3>"The following is a quote from Ben Franklin. "JavaScript is great.""</h3>` - the extra parse you do becomes more complex and error prone. But picking out something like `<h3>{% The following is a quote from Ben Franklin. "JavaScript is great." %}</h3>` becomes a bit easier.

We don't have anything using `fbt` publicly. It could be a pretty straightforward step though. A custom babel transform that looks for JSXElement and does something to replace the node. Here's a really basic example: http://astexplorer.net/#/89aJSotOE1
 We probably won't open source it, it's very much tied to our infrastructure and way of doing things. I think you'd be better off trying to do something yourself or look more into other ideas built more around existing translation solutions or maybe some combination of approaches.
 No idea.
 I think using loaders (Webpack jargon for transforms) for this is not super great because they operate on strings. Paul‚Äôs suggestion to use Babel instead sounds easier and more reliable to me.
 I‚Äôm confused as to what `babel-german` would mean in your example. Since it‚Äôs in Webpack configuration, it‚Äôs probably supposed to be a Webpack loader, but loaders operate on strings, not on AST.

When you see `babel` in Webpack config, it means the string contents of the file gets parsed by Babel, and its transforms (defined in `.babelrc` or Babel loader options) run on the AST, like [the one you can explore here](http://astexplorer.net/). These are easier to write because operating on AST is generally much safer than on strings, as you don‚Äôt have to ‚Äúthink like a parser‚Äù.

This is why we suggest writing it **as a Babel transform rather than a separate loader**. If it‚Äôs a Babel transform, you can [write a plugin](https://github.com/thejameskyle/babel-handbook/blob/master/translations/en/plugin-handbook.md) that detects and transforms special JSX expressions or function calls. It doesn‚Äôt matter whether you use JSX or a special function call for this‚Äîthe important part is doing this on AST level rather than by processing strings, which you‚Äôd have to do if you implemented this as a Webpack loader.

I hope this helps!
  This almost certainly means you are including a duplicate copy of React.  This is one of the dangers of using npm; it doesn't handle such dependencies very well and leads to cryptic errors like this.  You can try the things mentioned in the gist, there is some good discussion there.

I'm going to close this out because it's probably due to a duplicate dependency.  If you're able to come up with a simplified repro (eg. in a jsfiddle) that demonstrates a bug in React, we'll be happy to re-investigate.
  It's a new warning so you wouldn't see it in 0.14.x.

@dangreen Is `process.env` that being set at runtime some point after ReactDOM is required? I think that's the only way you would see this.
 Without steps to reproduce this is going to be a bit tricky to track down. Could you perhaps reproduce your set up minimally? You probably want to be running browserify with your NODE_ENV set (which will trigger the envify part). Here's a simple set up I made that you can use as a model. No transforms (so no JSX) or anything else. Just browserify and uglify. You could even skip the uglify step - browerifying React would be enough, would just leave a bunch of dead code in there. This warning you're seeing should be dead code.

https://gist.github.com/zpao/2b545c0fc5c2fdc8a2911fd49b8b92a4
 @lambert-velir 2 things for your case specifically
1. `require('envify')` will use `process.env.*` values. If you look at the example in the readme again you'll actually see that you need to `require('envify/custom')`
2. You may also need to pass `{global:true}` as the first argument to `b.transform` so it's applied to dependencies. I think by default browserify won't transform files from `node_modules`.

@dangreen Again, without seeing how you're running things I can't really help. Yes, React uses loose-envify but I think only when you compile from the command line and presumably you can control that in your build system. If I do it via the API it looks like this is working just fine.

``` js
var browserify = require('browserify');
var envify = require('envify/custom');

// where index.js is from the gist above
var b = browserify('./index.js');

b.transform({global: true}, envify({
  NODE_ENV: 'production'
}));

b.bundle(function(err, buf) {
  console.log(buf.toString());
});
```

I leave off the envify transform, `process.env` is still in the React code.
 It's at the bottom of that section of the browserify docs, but not super obvious. Also is a command line option too.

As to why? The upside is that if you avoid runtime process lookups AND if you then pass your code through uglify or some other minifiier, you'll get the dead code removed.
 @dangreen That's really helpful because now I have steps to reproduce your issue.

Unfortunately I don't think it's possible to disable the transform we specify in our package.json, not recursively anyway. Perhaps if you were browserifying our package directly (eg, instead of `./index.js` you specify `react`) you could use the `browserField: false` option.

So my best suggestion right now is to either not set `NODE_ENV = 'docker'`, or set it after doing the browserify step (and then adjusting your browserify step to use envify directly). Alternatively, don't use `NODE_ENV` for values besides `'development'`, `'production'`, `'test'`, and `undefined` and use some other environment variable to indicate that you're in docker. `NODE_ENV` isn't a standard but from what I can tell it's become more common practice to expect those values and make adjustments accordingly (eg, even Sails does this in a couple places: https://github.com/balderdashy/sails/search?utf8=%E2%9C%93&q=NODE_ENV&type=Code). Personally that's what I would do, but I don't know everything that went into your decision or what constraints Sails imposes that wouldn't make that possible.

I'm going to close because there's nothing else we can do here. The benefit of automatically transforming outweighs the cost of the occasional difficult integration point. Sorry that you happen to be in one of the cases that isn't easy.
  This is pretty much the same as https://github.com/facebook/react/issues/5067.

I think we won‚Äôt be supporting PropTypes-based introspection because we don‚Äôt plan to add new features to them, and eventually plan to phase them out in favor of tools like Flow (which may add runtime checking at some point).

I understand where you‚Äôre coming from (styleguides are cool) but I‚Äôm afraid we‚Äôre just not going to add more to PropTypes API. You can, however, implement custom PropTypes matchers that delegate to React.PropTypes for validation, but also expose the necessary metadata, and have your components use those custom PropTypes instead.

I hope this helps!
  Would you mind reproducing this in JSFiddle? Thanks.
 Ping @eipark
 Can you modify and post the code from one of the examples in the React starter pack, to create a simplified repro, with instructions on how to reproduce?
 Ok, nice repro!  I was able to reproduce.  @spicyj immediately said "Chrome bug!" as soon as he saw it, maybe he is right.  Interestingly, the Firefox debugger behaves even worse than Chrome does.

Commenting out the fake-dom-node-event-logic seems to fix the issue.
 Actually, I take that back, perhaps it is not related to the fake-dom-node-logic.  I was overly excited, commenting it out doesn't appear to have done anything :(.
  There is not much info to go on here.  This looks to me like the error is occurring in UglifyJS (not React).

@rashmimadanshukla If you can provide a simplified example that demonstrates the issue, we can investigate further.
 Ping @rashmimadanshukla
 Closing due to no response from OP.  We can re-investigate if/when we can get a repro.
  Doh, thanks!
  I am trying to upgrade from `0.14.8` to `15.0.1` in a Universal JS application, without any warnings on `0.14.8`.  I'm getting a few warnings, however I think this might be an issue with ReactDOM?
### Reuse markup warning

```
Warning: React attempted to reuse markup in a container but the checksum was invalid. This generally means that you are using server rendering and the markup generated on the server was not what the client was expecting. React injected new markup to compensate which works but you have lost many of the benefits of server rendering. Instead, figure out why the markup being generated is different on the client or server:
```

When I looked into this specific issue it was because on the server an input field with a `required` attribute rendered as `required=""` whereas on the client it's just `required`.

For a quick example of this issue:

```
// in node command line
> ReactDOM.renderToString(React.createElement('input', { required: true }));
'<input required="" data-reactroot="" data-reactid="1" data-react-checksum="573510284"/>'

// same simple input field rendered in the client via ReactDOM.render
var el = React.createElement('input', { required: true });
ReactDOM.render(el, document.getElementById('app'));
<input data-reactroot required>
```
 I'm fairly confident that the `required` vs `required=""` difference is a red herring. Unfortunately this has come up several times. These attributes are probably fine like this and there's a good chance the difference is actually later in the markup. The empty string vs bare attribute is typically a difference only in the DOM API's representation of the markup (I think we use outerHTML).

We've seen some similar issues in the v15 upgrade and there's more discussion in #6451. If you could show that this is happening explicitly with `required={true}` (eg, in a simplified example, not your application), then we should reopen. I couldn't make it happen with your example above (https://jsfiddle.net/16jtetL6/). So for now I'm going to close and encourage you to follow along in the other issue.
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 This has been fixed independently as part of #6148 so I‚Äôm closing, but thanks for contributing!
I‚Äôm closing this PR as master is already fixed.
  Overall, this looks good to me.  A couple of comments to fix.  Also, if you can squash your commits (`git rebase -i`, `git push -f`).  Other than that, I think this is good to go.
 @hkal updated the pull request.
 Thanks @hkal 
  I'm not sure what you mean when you say:

> flex:1 can directly use in a component,but in html css, it supposed a flex attribute in its parent.

Can you elaborate?  Perhaps with an example?
 Going to close out since this appears to be a misunderstanding. If you have issue with `flex` in regards to React Native specifically, I would ask in their repository.
  In a perfect world `react-addons-update` shouldn‚Äôt peer depend on React at all.
Relevant to https://github.com/facebook/react/issues/6490.
 In the meantime you can use https://github.com/kolodny/immutability-helper instead as a drop-in replacement.
 I'm going to close this.  [Immutability-helper](https://github.com/kolodny/immutability-helper) is a good solution for this specific case, and https://github.com/facebook/react/issues/6490 tracks the wider issue.  Feel free to continue the discussion on this thread.
 > warn my dependents about potential peer dependency mismatches (if I have a non-peer dependency on a react-addon)

This won‚Äôt work in npm 2. Additionally, even with npm 3, this will cause multiple copies of React to be installed in case of version mismatch which will likely break the addons that _need_ to depend on React anyway. And those that don‚Äôt need to, like `react-addons-shallow-compare`, shouldn‚Äôt depend on it in the first place, as I said above.

> or to force them to install the react-addon on my behalf (by listing it as a peer dependency).

I think this is the most sensible solution in the present circumstances. It‚Äôs not ideal but at least npm 3 users will never get a duplicate React because of this.
  I'm going to close this out and just track in https://github.com/facebook/react-devtools/issues/357. If there's something specific React needs to do that comes out of that investigation we can file something here.
  @jmm `class component` refers to things that are not stateless function components (so I think the change log is technically correct as-is), but should probably make that more clear.  Your new wording is slightly less precise given the React vocabulary we use, so we're still going to need to massage it a bit.

How about this as an alternate wording:

>  Functional components can now return `null`. We added support for [defining stateless components as functions](/react/blog/2015/09/10/react-v0.14-rc1.html#stateless-function-components) in React 0.14. However, React 0.14 still allowed you to define an **ES2015** class component without extending `React.Component`, so [we couldn‚Äôt reliably tell if your component is a function or a class](https://github.com/facebook/react/issues/5355), and did not allow returning `null` from **a stateless functional component**. This issue is solved in React 15, and you can now return `null` from any component, whether it is a class or a function. ([@jimfb](https://github.com/jimfb) in [#5884](https://github.com/facebook/react/pull/5884))

My changes bolded for visibility, real copy should retain standard formatting.

Adds "ES2015" qualifier to class component, and removes `or using React.createClass()`, for clarity.  Resolves ambiguous "it" to a stateless functional component.  Would that have resolved your confusion?
 > It's also confusing that so many terms are used somewhat interchangeably: component, component class, React class, class component, ES6 class component, probably more. I'm not sure class component is a good choice in any context. ES2015 component class, though a bit awkward, would probably be better.  I'd appreciate if you could tell me where I went wrong with the React vocabulary.

They're not entirely interchangeable.  It's like the difference between a square and a rectangle.  Technically, all squares are rectangles, but not all rectangles are squares.  Similarly, a `class component` is a `component` but not all `components` are `class components`.  There are several nuances like this that we should do a better job of documenting.
- component = A thing you would render (some frameworks use the term "widget", if that's helpful).  An example might be a `NewsFeedStoryWidget` or a `DatePickerWidget`.  It's a user-interface concept.
- component class = Short for a "react component class".  A definition of a widget.  This is a programming language concept; it is the implementation of the widget.
- react class = Short for a "react component class".  Same thing as a "component class" (in the context of React).  We should probably just pick one term, but we'd need to bike shed on which one.  We could always use the long version, but if you always use the long version of all terms, your sentences become very long and incomprehensible.  The full term for "stateless function" is "stateless react component definition function" or some such permutation of those words.
- class component = A component that will, when instantiated, have a backing instance.  Explicitly not a "stateless function component".
- ES6 class component = A component that is explicitly defined using ES6 classes.

Part of the problem/ambiguity is inherent in the english language.  For instance, you mention that a `class` is a function (which is technically true, and an implementation detail of the design of classes), but when we refer to a function (as oppose to a class) we generally don't intend to also capture classes in that statement (but sometimes we make general statements about functions which also apply to classes because classes are functions).  Similarly, when someone says they "have a class", they could be referring to the source code, or to a reference to a JSVM entity representing that class, etc.  When they say they "have a component", they could be referring to the source code, or to a class object, or to an instance of that component class, etc.   English sucks.

ES2015 and `React.createClass` are mutually exclusive, so the statement would make no sense.  Removed in my new revision:

> Functional components can now return null. We added support for defining stateless components as functions in React 0.14. However, React 0.14 still allowed you to define an ES2015 class component without extending React.Component, so we couldn‚Äôt reliably tell if your component is a function or a class, and did not allow returning null from a stateless functional component. This issue is solved in React 15, and you can now return null from any component, whether it is a class or a function. (@jimfb in #5884)

Anything still confusing about this draft?
 > ,what kind your component is and did not allow

This sentence structure still feels awkward to me.  How about:

> , so we couldn‚Äôt reliably determine the component's type, and thus couldn't allow returning null from a stateless functional component.

So the paragraph becomes:

> Functional components can now return null. We added support for defining stateless components as functions in React 0.14. However, React 0.14 still allowed you to define an ES2015 class component without extending `React.Component`, so we couldn‚Äôt reliably determine the component's type, and thus couldn't allow returning `null` from a stateless functional component. This issue is solved in React v15, and you can now return `null` from any component.
 So the paragraph becomes:

> Functional components can now return null. We added support for using pure functions as "stateless" components in React 0.14. However, React 0.14 still allowed you to define an ES2015 class component without extending React.Component, so we couldn‚Äôt reliably determine the component's type, and thus couldn't allow returning null from a stateless functional component. This issue is solved in React v15, and you can now return null from any component.
  @xadh00m Honestly, this code doesn't have a real owner, so it's hard to know who to cc on this issue.  I think @gaearon took a look at a few PRs recently, so he might have some feedback.

If you can demonstrate a bug and have a PR to fix, I think we'd likely take it.
  Yes, this is intentional. `value={undefined}` makes the input uncontrolled. This means, for example, that resetting state to be `undefined` won‚Äôt clear it later, and this catches people by surprise. If you want the component to be controlled (and empty), please pass an empty string instead.

More about controlled and uncontrolled inputs: https://facebook.github.io/react/docs/forms.html#controlled-components
 > I needed the input to be controlled and have a value of undefined.

What do you mean by ‚Äúhave a value of undefined‚Äù?
If this is input, using the value of `''` should work great for you.
  Thanks @syranide and @satya164!

I'm going to close this out to take it off our radar, since it appears we've identified the root cause and it's not React's fault.  Flash does not support updating parameters on an already instantiated flash.  Feel free to continue the discussion on this thread.
  Note: this is stacked on top of #6486 so ignore the first commit.

---

This is a follow-up to #6486, also extracted from #6046.

Here, we add an introspection API that will let React DevTools, ReactPerf, and third party tools query information about the internal instances without exposing them.
 > I would be happy to hear what people think about making the API two way, meaning adding ability to inject back into the component things such as state, and props.

Yea, this will definitely be added at a later stage after new ReactPerf is ready. We want to migrate React DevTools to use this API, and they have a way of tweaking props so scheduling updates will be allowed here as well.
 Closing per https://github.com/facebook/react/pull/6486#issuecomment-211965328. Will do it differently.
  Yes, please track this in https://github.com/facebook/react/issues/6451.
  I noticed you closed this and changed the title. I just wanted to confirm that this is in fact fixed in 15.0.1 and was only an issue in 15.0.0.
  I think we rely on the synchronous value update to handle cursor position.  To be honest, I'm confused why the `setTimeout` is necessary, I wouldn't have expected that.

cc @spicyj @jquense 
 Yes, I wouldn't expect the setTimeout here to be necessary. Sometimes browsers are finicky with focus and selection though so it may just be due to that.
 With @jquense's excellent observation that the `onKey` events fire before `onChange`, I now feel like everything is behaving as expected.  For reference, my fiddle: https://jsfiddle.net/rmsLxtbj/

@jchitel If you can provide a fiddle that demonstrates something you believe is unexpected behavior, let us know and we can re-investigate.
 Event ordering is defined by the browsers, you can probably find some W3C docs on when events are fired.

If I understand correctly, anything that is selected at the time `onChange` fires will get replaced by the character that was typed into the text box.  This seems to be supported by my fiddle, which always replaces the first character (which is selected by the key event).

As far as I can tell, everything is working correctly / as expected, so I'll close this out.  If you run into any issues and things are looking sketchy/wrong, let me know and we can re-examine.
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 Hi, thank you for the pull request! I agree this is useful, but there is a work in progress on a special introspection API (#6389, extracted from #6046, and more to follow) that is aimed at providing introspection capabilities like this without exposing internal instances.

#6389 contains more details about the plan. I‚Äôll close this PR as we don‚Äôt want to expose the internal instances in the new API (at least we‚Äôll try not to). However I think we‚Äôll be happy to take a contribution that adds something like `getState(instanceID)` to `ReactDebugIntrospection` after it lands (in a few weeks).

Cheers!
  cc @sebmarkbage for some additional thoughts / links.
 This has been discussed so many times that there is no single easy link to post to. We should probably make a new summary but I'll do my best here.

We did have an idea to allow promises passed to `setState(promise)` as a convenience. That would also allow it to clean up itself automatically if the component gets unmounted if it gets resolved earlier.

1) If you allow a Promise or Observable in render, you end up in an intermediate state. What do you do with your UI in the mean time? What goes into the `<div>` in the example of `<div>{promise(this.state.myPromise)}</div>` before it gets resolved? What about when the value updates? We didn't want to encourage a system where you could block the UI by accidentally putting a too long Promise in there.

2) One of the benefits of React over what came before it was that as a user you never deal with specialized data structures. Like change tracking sets, Promises or Observable values. It's all plain data. `async/await` gets closer to that but still requires a lot of explicit opt-in. In other languages there are solutions that doesn't require this but still have the capabilities that you want here.

3) Promise and Observable chains execute whenever the async dependencies get resolved. They're push oriented. When something happens, immediately compute all the artifacts of it. The scheduling work mentioned above is about making sure that such operations don't steal CPU cycles. Because if that work is low-priority, it will cause responsiveness issues for higher priority work.

Now there are mitigating factors for all these things:

1) We have an idea for how we could do **forked** behavior of components where they could live in two states at once and then rebase. This would allow a component to update itself (remain responsive) while a pending update is still being processed.

2) We could potentially design the API around generators or async/await to avoid exposing users to first-class Promise values. (Or even better, algebraic effects.)

3) The [ECMAScript Zones proposal](https://github.com/domenic/zones) could allow for overriding the default scheduling of Promises. Allowing us to defer work that is not high priority. This would make the whole idea of push oriented values more palatable.
  For the record, we plan to provide an official introspection API for this.
#6488 is the start of this.

What information would you like to extract about the instance that has been updated?
  > Is there a way to remove this warning?

Currently, no. One of the things that's somewhere on the roadmap is to make it easier to opt-in/out of specific warnings but there hasn't been a lot of motion on that. Maybe there's something we can do specifically for that warning though...
 The issue reported here is specifically about minifying non-production React. If you have problems with your toolchain creating a production build, that's a distinct issue and should be discussed in a new issue (or stack overflow first, as this is not intended to be a support forum).
  @jimfb Would #6406 fix this?
 Yes, fairly certain.
  Sounds like a browser quirk.

```
<form method="get" action="http://www.example.com">
  <input type="text" name="foo" />
  <input type="submit" id="submit" onclick="this.setAttribute('disabled', 'disabled');" />
</form>
```

Same behavior without React.
  Yeah, I think this was fixed in #6458 and will get into one of the closer releases.
 Yes, closing as fixed.
  User-specified keys undergo an escaping transformation to prevent collisions with automatically-generated keys.  For instance, if your `li` element had the key `1=::=2`, the key in the warning would be `.$1=0=2=2=02`.  This happens during traversal, so `flattenChildren` gets the already-escaped keys and doesn't have access to the original keys.

But yes, auto-generated keys are completely internal (never user visible) and are guaranteed to never conflict (because they are generated, and user keys are escaped), so I don't see a reason why we couldn't report the original key name in warning messages.

Probably the best solution would be to un-escape the key before reporting the error message.  We would want to move key escaping/unescaping into a `KeyEscapeUtils` utility that provides an `escapeKey` and `unescapeKey` function.
  I think we generally prefer string concatenation (simpler), but it doesn't really make a huge difference one way or the other.
  Please make sure you don‚Äôt have two instances of React on the same page.
`npm ls react` can help to determine this.

If you don‚Äôt, please share the minimal example reproducing this issue on GitHub or JSFiddle.
Thanks!
 @nickbae91 @doctyper I am still unable to reproduce.  Here is my fiddle: http://jsfiddle.net/jtxx6goy/  Can one of you provide a jsfiddle that demonstrates the issue?
 I have a (relatively) consistent repro in chrome: https://jsfiddle.net/r4ewebqs/

Still unable to reproduce in Firefox.

Almost looks like it might be a chrome race condition, potentially related to garbage collection, because the hit rates go way down if you spread out the calls to `ReactDOM.render` temporally.  But the OP suggests that they've seen the failure in firefox also.
 Yeah, if I upgrade from Chrome 49 (out-of-date) to Chrome 50 (latest stable), the error goes away.  This is consistent with my original observation that it appeared to be a race condition potentially related to garbage collection.

I'm going to close this out as a browser bug, unless someone is able to reproduce on Chrome 50.  I'd also be curious to see a firefox repro.
 Let's be careful about assuming a GC issue / browser bug. We should be able to confidently say what specifically is at play. It could well be a bug in React (particularly around transactions, mounting, and local events)

My best guess here (especially since all the reports are for nodes that we have to add load / error listeners to directly) is that timing is at play. With the switch to createElement we'll actually kick off the fetching of resources earlier than before - instead of waiting for the browser to parse the img element and see src, we create the img and set src right there. That means we'll probably get a load event earlier. How early and is it possible for that event to fire before we actually attach a listener to that node is the question, and what impact does it actually have. Does it only happen on updates? Are there other events actually at play?

> One thing I find interesting is if you edit the fiddle so that the audio element has no source elements, the errors do not appear

This would support my theory here as you won't get at least some of the media events.
 Please try to provide a minimal example reproducing this. 
  For some reason I thought we already had this‚Ä¶ maybe it was a part of the SVG change that got backed out.

I like this in concept but let's do 2 things
1. Move this to the HTML config. This is really a general XML thing and applies to XHTML as well.
2. Remove the test (we don't have tests for any of these normal config attributes)
3. Maybe make it `xmlNS`. We've remapped a couple things so they make more sense in JS and this sort of fits the criteria.
 Actually, I guess just leave it as in the SVG config since there's also `xmlns:xlink`, which we should get in there too. Can you add that as well?
 @salzhrani updated the pull request.
 @salzhrani updated the pull request.
  @jackson-huang updated the pull request.
 Thanks!
  Yes, I think this seems reasonable. Thank you!

Can you move `body` to the top so it's still alphabetically sorted?
 Wait a second... I think this would break full-page rendering.  While we generally recommend against FPR, it is a use case that people utilize.  We should add a test that rendering `<html><body><div /></body><html>` won't emit a warning.
 @jimfb Line 187 should account for that.
 Also line 70 of the test.
 Oh, ok, I'm good with that.
 We _do_ have a test.
 @keyanzhang updated the pull request.
 Thanks @keyanzhang!
  I don‚Äôt think setting a property value to something like `'value; other-name: other-value'` was ever officially supported. It might have worked by coincidence because, as mentioned prominently in the blog post, we used innerHTML to populate the initial tree when a component is mounted. It so happens that this hack you were using is compatible with the way we used to glue HTML code on initial mount.

However I don‚Äôt think this way of specifying multiple CSS values for a single property was every supported. You won‚Äôt find it anywhere in the documentation or example. Moreover, I‚Äôm pretty sure it was broken before 15 in a different way: yes, mounting a component with a style like this would work in 0.14, but updating it would fail for the same reasons this doesn‚Äôt work at all in React 15. Updates were always using DOM API for setting styles rather than innerHTML, so this hack would not work with updates. React 15 just normalizes the behavior between mounting and updates, and always uses DOM API to create DOM elements.

I see your point though. I don‚Äôt have a good solution to this inside React. This was discussed in https://github.com/facebook/react/issues/2020#issuecomment-123402094 before, and the conclusion is you should probably handle this outside React by feature testing. For example you can create a DOM element once when your code initializes, set different values of `style.display` on it, and see whether it sticks or gets reset. When it sticks, it means the browser supports the given value. This way you can build up a dictionary of mappings between standard values and the ones supported by the browser. Most likely there are some libraries that can do this for you.

I hope this helps! This isn‚Äôt a bug as you were relying on a hack, and we never officially supported it, as explained in https://github.com/facebook/react/issues/2020#issuecomment-123402094. 
 > Since react is removing a value depending on it's content, shouldn't you document that and warn the users?

It‚Äôs not React removing the value. Your browser does it. Try to assign a string like this to `node.style.display` without React (or just in style inspector) and you will see that this is the case.

We documented that React is switching to using `createElement()` in the blog entry several times. That is the reason why anything relying on concatenation will break. In my opinion this was clearly a leaking implementation detail and relying on such details always comes at your own risk. 

> PS. it worked fine in 0.14 with updates.

Would you mind providing a specific example code in JSFiddle that demonstrates it working? I don‚Äôt see how updates could possibly work correctly because React always used `style` DOM API for updates, and it can‚Äôt work the way you describe just because you rely on string concatenation which doesn‚Äôt happen in this case.
 Here‚Äôs a scenario that world not work in 0.14:

1) On initial render, `display` is `none`
2) After an update, it is set to this long string

So even the existing ‚Äúsupport‚Äù for it was inconsistent and confusing. It was broken already, you just happened to be lucky to not hit these cases. 

I agree it‚Äôs not good we don‚Äôt have a good solution for auto prefixing multiple values. We could potentially allow this by letting you pass an array for the value. Let‚Äôs reopen to hear what others think.

cc @zpao
 This was never an officially supported use case so we're unlikely to do anything about this in the short term. The fact that it ever worked was simply a by-product of how we optimized initial render in the past.

On the client-size we've generally recommended something that picks the right values for you based on the user agent, but as noted, that's not great for server rendering. My recommendation has always been to just use plain old style sheets for this. There are several places where the DOM APIs don't support all of the things you can do with stylesheets in an optimized way (`:hover` is another example - adding and removing specific styles in JS in response to events is pretty crappy even if it's possible).

Inline styles (read: JS styles) is something we're investigating more over the coming months. I'm sure that will shape how we think of styles in React in the future, but right now we aren't planning on changing anything. The issue you're having and other related issues are all a part of the considerations.
  I don‚Äôt think this is a bug in React. This code has a fundamental problem: it reads the private `state` of a ref. This should never be the case in React apps. Instead, you should pass the new value to the `onChange` handler. And the child should not be stateful: instead, the state should live in the parent component, and `Checkbox` should merely reflect the props passed to it. This way the data flow is easy to think about because there is just one source of truth, that is, the parent component. 

In React, `setState` is asynchronous. This is why reading `state` right away won‚Äôt work. And in any case reading _other_ component‚Äôs state is always discouraged: it is private by design.

I think you might find this guide helpful: https://facebook.github.io/react/docs/thinking-in-react.html. It explains how state ownership works in React apps. Please don‚Äôt skip it because it is absolutely essential, and you‚Äôre going to run into more issues if you keep using multiple sources of truth and reach into private component state from other components.

If you refactor the code to use the top-down data flow and the problem persists please let us know and try to provide a fiddle where you can reproduce this. Right now this looks like incorrect usage so I am closing. Cheers!
 Glad it helped!
  <s>Hmm. I think the plan was to move these warnings to element creation: #6345</s>

Never mind, I meant to comment on a different pull request.
 @nhunzaker: It's up to you.  https://github.com/facebook/react/pull/6398 does solve a subtly different problem and hasn't been touched in almost a week, but this commit is going to depend on some incarnation of that PR so it will be tough to make progress on this until that gets finished.  You might be able to adopt that PR (eg. merge it into here), fix it up, and the two of you can work together to get it merged.  Up to you guys to figure out how to best proceed.

Fair warning, #6398 may be a rough one to attempt as a first bug, as per https://github.com/facebook/react/issues/6062#issuecomment-185528241.  I can offer my guidance on this bug, but ultimately the team would need to arrive at a consensus which means that implementation/design decisions would be up for debate, which can be a little frustrating for outside contributors.  If you're looking for an easier way to get involved, I recommend looking at https://github.com/facebook/react/issues?q=is%3Aopen+is%3Aissue+label%3A%22good+first+bug%22 .  Anyway, your call.  This one would certainly be a valuable one to get solved!
  We don't intend on making React too knowledgeable about vendor prefixing. As much as possible that belongs at a level above React. There are libraries out there that can add the appropriate prefix to your style values (I don't know one off the top of my head but they exist or you could write one relatively easily).

``` js
// Instead of this
var myStyle = {translate: ...}
return <div style={myStyle} />

return <div style={prefixStyles(myStyle)} />
```
  Eeeh, sure.  I guess we can take this.

For future reference, we generally ask that minor fixes like this are thrown into a larger more meaningful commit - the reason being that there are trillions of these little fixes and constantly merging them would burry the meaningful changes in noise.

Before we can merge, you'll need to sign the CLA here: https://code.facebook.com/cla
 Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 I would be against taking it unless it fixes some issue. This obscures the blame/history information but doesn‚Äôt bring any changes. Additionally, we have many similar patterns in the codebase, and doing it only a single place doesn‚Äôt seem very consistent with the rest of the code, even if it reads easier in this particular case. That said I appreciate the contribution!
 Readability is important but in this particular case it‚Äôs somewhat subjective. Some people are more used to the return-early pattern, some people are used to the branching. In fact sometimes return-early can be a problem‚Äîfor example, you might want to add some code in the beginning _and_ in the end of the method that must be called consistently (e.g. performance measurements), and in this case you have to restructure the code to avoid the early returns. So I‚Äôm not saying they are bad, but they‚Äôre not universally better either :smile: .

Generally, improving readability is great when it‚Äôs a part of some larger body of work (e.g. fixing a bug). In a mature project like React, it is often more important to have very precise history of changes to the file. This is extremely useful for finding where the bugs were introduced. In this case, small changes like this distract the person looking for the bug because it‚Äôs not clear whether the change was harmless, or some small behavioral change was accidentally overlooked.

Even if everything is fine, it still changes the ‚Äúblame‚Äù information on the particular lines so you no longer see the most recent _actual_ change to the logic anymore. This is why big projects usually avoid large stylistic changes like adding/removing semicolons: they will remove the useful blame information from every file because they touch every line. Of course this isn‚Äôt what we‚Äôre dealing with here, but if we accepted this particular change, we‚Äôd have to choose where to draw the line, and it would be strange if we later rejected similar changes for no good reasons.

I hope this clarifies my thinking a bit. We want the codebase to be readable, but readability is often subjective whereas making small changes adds burden to people changing and debugging this code in the future.
 No problem, thank you for taking time to contribute!
 @Bilge Can you please suggest any resources so I could learn it? Thanks!
 @Bilge This PR is not an architectural decision/change.  It's not even a functionality change.  It's purely style, and it's not even objectively better; style is a matter of debatable opinion.
  @Wildhoney What will happen if you mount into a div that lives in a document fragment?  Will this do the right thing, or do we need to walk up toward the top to discover the fragment that we live within?
 I talked with @spicyj on internal chat, he just didn't know it was a use case.  I don't think there is any reason not to support this.

My question though was with regard to ensuring that the document fragment gets selected as the document if we are mounting into a div within that document fragment.

```
var proto = Object.create(HTMLElement.prototype, {
  createdCallback: {
    value: function() {
      var mountPoint = document.createElement('div');
      this.createShadowRoot().appendChild(mountPoint);

      var name = this.getAttribute('name');
      var url = 'https://www.google.com/search?q=' + encodeURIComponent(name);
      ReactDOM.render(<a href={url}>{name}</a>, mountPoint);
    }
  }
});
document.registerElement('x-search', {prototype: proto});
```

In this case, we are mounting into the `div`, so `nodeType === DOC_FRAGMENT_TYPE;` will return `false`, which makes me wonder if `doc` will be pointing to the right place.  I assume the "right place" would be the document fragment, but I just want to confirm that we get this right.
 Specifically, I'm concerned that `mountPoint._ownerDocument` will be `undefined` in that case, which will result in events not working correctly.
 Yeah, ok, I buy that.  I'll accept to fix the regression.  We should handle the other case at some point.  Would you be willing/interested in doing a followup PR to handle that?
 @Wildhoney Ideally there would be a fast/easy way to get it directly.  Worst case, it might require walking up the DOM nodes' parentNode until you find a document/fragment (or null).  Obviously we'd only want to do that on initial mount and cache the value (maybe emit a warning if we can't find a good root).
  @hkal updated the pull request.
 @hkal updated the pull request.
 Hmm. I think the plan was to move these warnings to element creation: #6345
cc @jimfb 
  As suggested [on Twitter](https://twitter.com/montogeek/status/718473945851236356).
Let‚Äôs do it so we don‚Äôt get more broken components?
 I still like the `lib/` pattern üò¢ It might be slightly more obvious to people not to require files from `private/` but nothing really stopping them and we'd end up telling people the same thing - "don't require things from here".
 While we have been telling this to people, the reality is that a lot of people (me included) thought it was relatively safe some time during 0.12, and there is a bunch of components whose authors don't know this needs changing.

Renaming it for 16 would serve as a good warning for any existing components, as it would effectively force authors to explicitly opt into using "private" parts or find workarounds. 
 We could go all in and really obfuscate it. Some hash or something that gets added to our build pipeline and changes for every major release.

```
echo '16' | md5
5b6b41ed9b343fed9cd05a66d36650f0
```
 :+1:   `:%s/major release/build/g`
 Nah, shouldn't do it on every build. I thought about it but that would probably screw our own packages so we need some reliability (eg react-dom 15.0.0 should be able to use react 15.0.1).
 Our own packages should have a way of accessing the internals needed, using private API like SECRET_DOM, without indexing into lib.  That has the added bonus of allowing addons to be put into separate UMD builds.
 I feel like people experimenting should check out the React repository anyway, rather than relying on an NPM build.  Maybe I'm wrong, curious what @gaearon thinks about that point.
 Depending on how we did it, I don't think it would really hinder experimentation. You would just be forced into knowingly using non-public APIs and if we went down that hash per major route, you'd just have to update paths for a major version. We'll definitely keep the use case in mind though. And you're paying attention so I'm sure you'll chime in (or I'll reach out) if we make any drastic changes that would be unrecoverable.
 > I feel like people experimenting should check out the React repository anyway, rather than relying on an NPM build.

Building it and then doing something like `npm link` can be a pain considering you‚Äôd want the renderer to be a peer dep, and to both run tests in it _and_ experiment on some project in another directory. This is when symlinks get too inconvenient. I definitely see the appeal of just using the npm package when fiddling with the renderers.

> Depending on how we did it, I don't think it would really hinder experimentation. You would just be forced into knowingly using non-public APIs and if we went down that hash per major route, you'd just have to update paths for a major version.

Something like `react/lib/5b6b4/*` (5 chars would be enough IMO) wouldn‚Äôt be too bad if we communicated clearly what this is. We could ship a `react/lib/README.md` that explains that the hash changes on every major version.
 > Another factor to consider. There are recordings of you guys considering Enzyme to be officially supported as a community based library for testing React. There are parts of Enzyme that currently require reaching into react. So either we would need to work together on some of that, or need continued access into the internals.

Yeah, absolutely. From [the related core notes](https://github.com/reactjs/core-notes/blob/master/2016-05/may-05.md):

> #### Challenges
> - Ideally we want test runner to be a separate renderer.
> - Tests should run consistently and often synchronously so we don‚Äôt want to run them with incremental reconciler.
> - **We have no official renderer APIs yet so without TestUtils Enzyme would have to rely on React internals.**

We understand this is the case now, too. We‚Äôll be keeping this in mind as we figure out the strategy for how to move further with #4230 without breaking everyone.
 It's worth noting that this is only relevant as long as we use `@providesModule`, which might not be for much longer (#6336). At that point we'll probably be using relative requires and perhaps go even further with a flat bundling approach where our npm module is a single file. There are things to work out and people/projects to work with before we finalize anything regardless. So I think it's probably not worth changing things multiple times and thus I doubt we'll do anything about this.
 üëç Let‚Äôs close it then in favor of #6336 and #6351.
  Conceptually, yes, we would like to do something like this.  It is being tracked as #140.

Unfortunately, there is some complexity.  We would need to warn for a release for any attributes that are currently being dropped (not on the whitelist, thus not rendered to the DOM).  The reason is that some people may use the spread operator to pass along all props, and rely on the whitelist to strip out props that aren't applicable to the DOM node.

If you would like to work on adding that warning, we could take that commit for v16, and then re-consider this PR for v17.  The warning would need to have line numbers, so it is likely dependent on the work being done in https://github.com/facebook/react/pull/6398
 I'm going to close this out for now, since it's not actionable for the next major release (or two).  I'll mark it as unsolved so we can come back to it at the appropriate time (do remind us if we forget).  But the first step is to start warning whenever we drop an attribute and thus don't render it to the DOM.

This is great work though, much appreciated!
  Correct.  We should not fire the warning for zeros, because zeros are zero no matter what the units.
 @zpao This one should also be safe for v15.0.1, though not super high priority if you want to punt it to a larger release that has been tested more heavily internally.
 Hmm, I'm not quite sure this is _technically_ safe in 15 at all as it changes the value we set for the style. I'm not really sure we can say this is a bug fix since it doesn't fix a bug. If we simply wanted to silence the warning we should be exempting `'0'` there, not changing what value we render.
 @zpao Na, that's just a bug fix.  Rendering 0px works in many browsers, but not all.  Rendering "0" is always the correct behavior, but rendering "0px" is sometimes incorrect/broken and will result in complaining browsers (Opera?).  I don't think it's possible for someone to depend on it rendering "0px" as the intended behavior of their application.
 @mondaychen 

>  I won't call it safer.

Try it in Opera.  If Opera doesn't fail/complain, try an older version of Opera.  I'm nearly certain that I've seen `0px` break in some browsers.  This is safer / more correct, afaik.
 @jimfb can you point me to a specific case where "0" is ok but "0px" is not? (not counting the exemptions we already have for some properties).

@mondaychen I'm agree that the change is better, my question is about whether it's the right change to take in 15. We _will_ change the behavior on string numbers, that's the point of the warning. But we haven't done it yet for any number so should we be doing it for "0" now? Or should we exclude at the spot we warn? Keep in mind the way you phrased the pull request and description - your goal as I interpreted it was to exclude that case from the warning, not to change the generated value.
 @jimfb what version of Opera is that for and can you reproduce? I don't recall any issue reported to us about this in the history of React. So as reported and per the intent here, this is not a bug fix but a behavior change.
 Honestly, I don't remember.  I spent a few minutes searching the internet, but came up empty.  Maybe it's not a problem.  Probably not a good use of time to keep searching / trying to repro.

I just distinctly remember running into this CSS issue when I found the solution, being like "oh, yeah, zero is always zero regardless of units, I suppose that makes sense, but seems like a really stupid css/browser requirement".  I distinctly remember css units being required for non-zero but breaking for zero, but this was a couple years ago and I unfortunately don't remember the details.
 @dlong500 

I believe you can find the discussion ‚Äúwhy‚Äù in the comments right above: https://github.com/facebook/react/pull/6458#issuecomment-213593093 and following.

A pull request that implements the same in a different way (without behavioral changes) is #6677, and I think it will be out in the next patch release.
  We are bringing it back until React 16. 
The fix will be out in 15.0.1 today.
https://github.com/facebook/react/pull/6444
  @Wildhoney Yes, we should probably add it back in.  Without having looked into it deeply, my guess is that the breakage was just an oversight.

Would gladly accept a PR to fix this.
 I'd look at nativeContainer and topLevelWrapper; the info might need to be added if it isn't already available.  I think @spicyj wrote the nativeContainer code, so he might know.  Otherwise, it'll require a bit of investigation.
 Fixed in #6462 
  What does the rest of that warning say?
 I'm pretty sure this is just the same as #6451 so I'm going to close this out. Let me know if I'm incorrect in that assumption.
 @spicyj How has the checksum check changed now that we're using createElement? Before it would work in this case because we'd be looking at the checksum of the generated markup string which wouldn't have seen the actual DOM. Or is this actually a case where the warning uses outerHTML so this mismatch is just pointing at the wrong thing.
 @zpao Nothing's changed ‚Äì we still generate HTML client-side when reviving server-rendered markup.
 @DylanPiercey The checksum still would not be thrown off by anything added by an adblocker like this (and should work identically to 0.14.7). The error message is misleading in this case though. If you disable your adblocker, what error do you get instead?
 Going to close this because it's unlikely this is actually a React bug but please reply and we can continue to debug.
 No worries, I just wanted to clarify my earlier comments. Didn't mean to put any pressure on you to reply quickly! If you have more trouble with that project then feel free to post and we'll figure out what's going on.
  If you have `Object.assign` in your environment already I don't think that will work because `object-assign` will use `Object.assign` if it exists so you're really just saying `Object.assign = Object.assign`.
 It does sound familiar but I didn't think that was part of the original discussion. I recall that we were just going to use Object.assign directly and then there was an issue with the spec (it would throw when getting `null`, which would have been really bad with how we were cloning props). Firefox had already implemented that old version of the spec so for a short period Facebook was actually completely broken in Firefox Nightly.

FWIW, I think the problem that's being exposed here could have been encountered before, especially if you ever used spread in JSX (or even regular object spread) and use Babel. Both of these get compiled to using Object.assign (essentially). The difference though is probably frequency, instead of just hitting it for those cases, it's happening for normal use of props.

I'm not sure the best way to handle this. I really want us to be able to use native code and not end up relying on our own dated polyfill. See #6376 for that discussion. We assumed it was perfectly safe, particularly due to the fact that we effectively have been using native Object.assign for facebook.com for at least a year (we did some module replacement internally). We don't do much server rendering so did not properly consider this case (and honestly completely forgot that v8 still has this bug)
 Seems like this would be a problem Babel spread too. Typically this is the kind of issue a polyfill should test for before assuming compatibility of the native impl.
 I wish we checked for validity by walking the DOM rather than calculating a checksum for markup.  It's more about **us** not being spec-compatible, rather than a V8 bug.
 No, V8 is not spec compliant. The enumeration order is defined by spec and fixed in newer V8s.

There are other APIs like Intl number formatting that **does** allow for different output. That's a separate issue and even if we walked the DOM that wouldn't automatically solve that issue.
 Ah, ok, they fixed the spec :).  We're depending on previously undefined behavior.  But the behavior is still undefined if we're targeting anything below ES6, so one could argue that we should solve this within React anyway.
 Yes, V8 has a bug in their Object.assign implementation. I've heard the bug might have been fixed but that's really unlikely to end up in Node v4.x || 5.x.
 ^ cc @spicyj 
 > change the checksum algorithm in a way that it doesn't matter what are the attributes ordering, checking only if they exist and are the same (probably the cost can be high in big apps, but better this than inject an entirely new markup)

Ideally that is what we would do but I think you are definitely right and it would be expensive. Server rendering is already relatively expensive / slow, so you might lose the advantages you would otherwise get.
 When reviving server-rendered markup, we generate markup on the client using the exact same codepath and generate the checksum based on that ‚Äì so any changes to the createElement mode won't affect checksums and are unrelated.
 It sounds like there are two related bugs in V8 that mess with the property enumeration order (thanks @mridgway for digging on these):

https://bugs.chromium.org/p/v8/issues/detail?id=4118
https://bugs.chromium.org/p/v8/issues/detail?id=3056

Sounds like the best solution is to send a PR to https://github.com/sindresorhus/object-assign that tests for these cases and doesn't use Object.assign if so. 
 @buzinas In React 0.14.8, we had an internal polyfill for `Object.assign`.  In React 15.0, we started using the native `Object.assign` (if/when available) instead of the polyfill.  Thus the problem when the native implementation of `Object.assign` is buggy.
 `object-assign` npm package _is_ the polyfill React uses now. The problem is that it first tries the native implementation which is buggy in some cases. 

https://github.com/facebook/react/issues/6451#issuecomment-212154690 works because it deletes the native implementation first, so the polyfill doesn‚Äôt use it.
 Not saying it‚Äôs an official recommendation though. Ideally `object-assign` should feature test broken native versions.
 I just released a new version of object-assign (4.1.0) that includes a feature test for these V8 bugs. Can someone reinstall and try with the new version and verify that this is fixed?
 Sounds great. I'll close this; hopefully it works for everyone else too.
 > I'm using object-assign@4.1.0 and still getting this. It only started once I upgraded to react 15

Please provide a project reproducing the issue. Also please make sure you don‚Äôt have an older `object-assign` somewhere deeper in the tree, e.g. inside `node_modules/react/node_modules`.
  This is almost a duplicate of https://github.com/facebook/react/pull/6268, the relevant discussion is there.
  @jimfb This is on you. I think we should probably have left it as `ReactComponent` since that is the current API, even if you want to say it's going away eventually.
 Hmm, this is a tricky one.  I don't like setting the return value to `void` because that's technically not correct and might confuse people.  I don't like `ReactComponent` because we don't want people glancing at the signature and seeing that return value.

I think maybe the best fix here would be to have the return value with a strikethrough: ~~`ReactComponent`~~
  Are you upgrading incrementally?  (ie. from version 0.11 to 0.12 to 0.13 to 0.14 to 15, rather than just jumping to v15)?  The upgrade experience is designed to be done incrementally.

But for versions that old, yes, the upgrade experience might be a little rough.  I think we do better nowadays with the more recent versions.  The new `React.renderComponent` is `ReactDOM.render`, and if you passed a string to that function, the error message would say:

> Uncaught Invariant Violation: ReactDOM.render(): Invalid component element. Instead of passing a string like 'div', pass React.createElement('div') or `<div />`.

Anyway, there is nothing actionable here, since it is fixed in latest and we are not going to backport that far back.

Sorry the upgrade experience from 0.11 to 15 might be a little tough, but I promise it gets better (especially if you keep your application up-to-date rather than doing huge jumps long after).
  This API was removed because it was undocumented and existed solely for our JSXTransformer/react-tools, which haven't been supported for a year. However it turns out TypeScript is still using this API in their TSX compilation and it kind of sucks to break people who want to upgrade React but not the rest of their toolchain.

~~Note: this doesn't quite (read at all) work with the `Object.assign` -> `object-assign` transform I wrote so would need to fix that too.~~
 Can we make it say something about TypeScript and JSTransformer specifically so people know how to upgrade?
 At least these days we know [how to name things](https://github.com/facebook/react/blob/80bff5397bf854750dbe7c286f61654ea58938c5/src/umd/ReactUMDEntry.js#L21). 
 I originally confused this with https://github.com/facebook/react-native/blob/master/Libraries/ReactNative/ReactNative.js#L96 and got overexcited to kill this too. I should've deprecated it first.
 > Can we make it say something about TypeScript and JSTransformer specifically so people know how to upgrade?

Better? I figured we could just link to a page on the wiki that discusses typescriupt and coffeescript specifically instead of putting it in the warning.
 :+1: 
 @zpao updated the pull request.
 Just going to point that fb.me url here for the time being. We can change it later, but I'm optimizing for the path which gets me to a drink fastest.
 @zpao updated the pull request.
 @m4tthumphrey 

This is not a problem with your code. It's a problem with whatever tool you use to compile JSX. 

If you are using `react-tools` to compile JSX, please switch to Babel. That project was unsupported for more than a year.

The fix will be out today because TypeScript still depends on it but this method is still deprecated so please try to migrate to tools that don't use it.  
 How do you compile JSX?
 You are using `jsx-loader` which uses deprecated `react-tools`. Replace it with `babel-loader`. Then configure Babel to use `es2015` and `react` presets and you should be good. 
 > I'm doing these things now and still getting the depreciation warning. Is this to be expected until Typescript fixes whatever internals they need to fix?

If you use TypeScript, yes, you will need for them to release the fix.
 Thanks @DanielRosenwasser, I appreciate the quick turn around! Sorry for the surprise breakage.
  @gaearon How would you feel if we changed that whole sentence to:

> React's use of the `<noscript>` tag has always been considered an implementation detail of how React targets the DOM.

Otherwise, it reads "these changes changes have always been considered implementation details".
 @jimfb Sounds good!
 @Aweary updated the pull request.
 @Aweary updated the pull request.
 Woops, @zpao, thanks for catching that this needs to be merged to stable.
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 This looks good to me, just a couple easy changes requested.
 @trevorsmith updated the pull request.
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 @zpao This fixes a regression, it would be good to get it into 15.0.1 if possible/practical.
  Looks like we're applying the prop changes in a bad order.  The logic to get this right is solvable in general (for known types), but could be complex to get perfect if we want to minimize DOM operations.
 I'm surprised that this particular case is problematic because this code should ensure that we always set `.type` before any other attributes on an `<input>`:

https://github.com/facebook/react/blob/0b1fd186855a48dff78987f13466cec1e579b78c/src/renderers/dom/client/wrappers/ReactDOMInput.js#L74

Not sure why that isn't working as designed. It's not totally clear to me whether setting type first always solves cases like these or setting type first would simply cause the same warning when switching the other way.

(See also #2242, which is something we may want to have happen but may be difficult to implement cleanly in the current system. It was easier when we had full composite wrappers for these components but we no longer do. Creating a new element whenever the type changes could be surprising because it would mean that the ref to that component changes during the lifetime of the component which we never have elsewhere.)
 The easiest workaround here is to set a `key` on the input that changes with the type so that a new input element is created when the type changes.
 Could be caused by Object.assign V8 order bug? Or was this before 15?
 @gurinderhans Which browser?  Also, can you provide a jsfiddle that demonstrates the issue?
  Fixed in https://github.com/facebook/react/pull/6442
  Thanks
  Yes, from the JSX spec, that's not a valid syntax. Since JSX isn't a part of JS the `<` ends up putting the parsers into a different mode, which would allow the `{ /* comment */}`. But anything before that is left alone.

If you want a comment there you would need to do it as plain JS or move it inside the `<nav>`.

Sorry that's not obvious. That's one of the downsides of introducing new syntaxes :)
  https://github.com/WICG/EventListenerOptions/blob/gh-pages/explainer.md

It would be good to have everything be passive by default and only opt-in to active when needed. E.g. you could listen to text input events but only preventDefault or used controlled behavior when you have active listeners.

Similarly, we could unify this with React Native's threading model. E.g. one thing we could do there is synchronously block the UI thread when there are active listeners such as handling keystrokes.

cc @vjeux @ide
  All of those things would be great items to have.  This function is not a priority for us internally, so we aren't focused on it at the moment.  @jhicken We'd gladly accept a pull request for any of those features.  
  There is a typo in the fiddle. You are passing ‚ÄúMidloth**ai**n‚Äù but the value is ‚ÄúMidloth**ia**n‚Äù.
The fiddle works with the typo fixed: http://jsfiddle.net/j03c41pw/

Please let me know if I missed something! So far this appears to work as intended so closing.
 Let's discuss it there then? üôÇ

It's a fun coincidence but I wouldn't say it's the same issue, as here the issue was the typo, and in the other issue, it is a genuine regression caused by a bugfix that was never released in RCs so it couldn't cause any issues before the final 15. 
  I looked into this the other day but it's not clean at the moment while we use npm2 and some of the plugins we use haven't released updates with 1.0 compat/peerDeps.

0.4 has worked well for 3 years so I'm not in a rush to change it. We will probably end up switching to gulp to align with many of our other projects and use more shared infra.
  This was only used by JSTransform which has been deprecated for a while. An early version of Babel used it as well.
 How many non-regression changes can we squeeze into a final release after the RC?
 "experiment" aka using spread in JSX
  This may be correct-as-is; the uncontrolled example demonstrates `defaultValue`, and the example behaves much like the uncontrolled example above (without `defaultValue`).
 Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 The previous block of code is an uncontrolled component but the previous "example" is a controlled component which starts with that text and keeps the input in sync, exactly like an uncontrolled component would. So I think yes, this change is correct.
  That is an interesting use case, but I'm not yet convinced that it justifies an additional lifecycle method, because I think there is an equally viable alternative for your service deconstruction.  I'm curious if you would agree...

What if a Service (as created by the parent) receives the information needed to open the required connection/resource, but doesn't actually open the resource until a child component starts listening.  The service then closes the connection/resource when the last child stops listening.  This means that the parent never needs to destroy the service, and normal garbage collection rules can apply.  Would this approach work for you?
 I think my previous comment above still holds true for most implementations of the Observer pattern.  Just `:%s/service/observable/g`

If children don't stop listening properly, you've likely got bigger problems.  It is common for data to be provided by a static parent and children to enter/exit throughout the lifetime of the application, so you'll likely be leaking anyway.
 > AFAIK, without a symmetrical hook for server-side rendering it is impossible to release any resources (unsubscribe listeners) used in componentWillMount.

Isn‚Äôt the current recommendation to never hold onto any resources in `componentWillMount` and do this in `componentDidMount` (which has a symmetric `componentWillUnmount` to free them up)?
 By the way I‚Äôm interested in having this method too.

When a child is subscribed to a Flux store, and the parent fires an action in `componentWillUnmount` to clean up the store state, the child has to include special code for existence of this slice of state, or it would fail to retrieve it (potentially with a null reference).

The child doesn‚Äôt know that it should unsubscribe because the parent is cleaning up. There is no way for the parent to safely clean up any external state the child may depend upon. If we had `componentDidUnmount`, the parent would be given this opportunity.
 @gaearon 

> The child doesn‚Äôt know that it should unsubscribe because the parent is cleaning up. There is no way for the parent to safely clean up any external state the child may depend upon. If we had componentDidUnmount, the parent would be given this opportunity.

@gaearon Yes, that was the original post/request almost verbatim.  But is there a reason the approach in https://github.com/facebook/react/issues/6424#issuecomment-206436302 is insufficient?  Seems like a parent can always create an object that lazy-initializes any required resource, and cleans it up when all users of those resources are done.  Is it just that there is a little additional boilerplate?  Is there a particular resource you have in mind that would exemplify the use case?
 > Is there a particular resource you have in mind that would exemplify the use case?

In this case, I‚Äôm referring to some piece of data in a Flux store that the parent cleans up. I don‚Äôt use this pattern myself but some consumers of React Redux bindings do, and I recently introduced a regression related to this use case (https://github.com/reactjs/react-redux/issues/351).

I wish I could tell people to use a different lifecycle hook for tearing down the data rather than being careful in the container implementation and having to implement workarounds like this: https://github.com/reactjs/react-redux/commit/ea53d6fb076359a864a1d543568d951d4b3eab3d. Asking them to pass something like `onUnmount` also feels unnatural, especially considering that connected children can be deeply in the tree.
 cc @sebmarkbage 
 By the way I briefly chatted with @sebmarkbage today about this, and my particular problem would be solved by delaying some calls until `render()` or transactional `setState()` callback. I didn‚Äôt use this pattern because `setState()` itself is somewhat inefficient inside a large list, but this is a separate issue.
 > Unless the object cleans itself up (not ideal, and sometimes not available as an option

Why is it not ideal?  When is it not an option (I'm fairly certain it is always an option, because you can use simple reference counting to determine when to cleanup)?

> e.g. parent provides set of listeners (children), then listeners get unmounted, then parent provides another set of listeners), the parent can't clean the object up because the parent gets unmounted before the children.

Why does the parent need to do any cleanup?  Why doesn't the datastore cleanup when the last child unmounts?
  Do we even support this? If we don't we should have a good early error message. 
  Thanks @andreypopp, exactly correct.

@josephMG Just FYI, Usage questions are better answered on sites like StackOverflow, as we try to use github issues for tracking bugs in the React core.
  I haven't tested 0.10 but I'm surprised with the output. Any chance you are behind some sort of firewall that makes npm registry requests return gibberish?
 Thanks for tracking that down @petetnt. Closing this out since it's an npm registry issue. Please subscribe to the issue linked above if you need to know when it is fully resolved.
  tl;dr: I'd like to know how much enthusiasm there is on the core React team for accepting a PR with the ability to render markup to a stream. I don't need a guarantee, of course, but I'd like to get an sense if it's something the React team might do before spending a ton of time working on it.
### Background

Currently, server rendering is accomplished by `ReactDOMServer.renderToString` or `ReactDOMServer.renderToStaticMarkup`, which are synchronous functions that return a string. 

The server render methods can be somewhat slow. Large (~500K) web pages can easily take over 100 or 200ms to render, depending on the server. Also, since node is single threaded and single-core performance has not been improving rapidly, this is not just a problem that Moore's Law will eventually solve. The slowness in turn causes two problems in production websites with large (or somewhat large) HTML pages:
1. First, because the methods return a string, they completely render the entire component before you can return even the first byte to the browser, meaning that the browser is waiting idle while the render method is called.
2. Second, because the methods are synchronous and node is single threaded, the server is unresponsive during rendering, which means that a large page render can easily starve out renders of smaller pages (which may only take a few ms). An asynchronous render method would let large page renders yield CPU to small pages, improving average response time.
### Proposed Solution

The proposal is to add two methods to ReactDOMServer, both of which return a node Readable Stream.

``` javascript
Stream renderToStream(ReactElement element)
Stream renderToStaticMarkupStream(ReactElement element)
```

In terms of behavior, these methods would return a Readable Stream that outputs the same markup as `renderToString` and `renderToStaticMarkup`, respectively.

These methods could solve both problems above. A stream can begin emitting content immediately to send to the browser, keeping TTFB constant as components get larger. Streams are also inherently asynchronous, which allows large pages to not starve out smaller ones.

A few months back I forked react into a library called [react-dom-stream](https://github.com/aickin/react-dom-stream) to do this exact thing, and it's been fairly well received (1,100+ stars on GitHub, though modest actual downloads on npm). There's also [a wishlist bug thread](https://github.com/facebook/react/issues/3009) on this repo about it. However, maintaining a fork is a less than desirable position, and I wonder if I can get it integrated in to the core code base.

My implementation in `react-dom-stream` is not ideal; I ended up copying basically every implementation of `mountComponent` and making the copied versions asynchronous. The benefit of this approach was that it didn't affect `renderToString` performance, but the obvious drawback was that any code changes or bug fixes would have to be performed in both forks of the code, which is not ideal.

Recently, I figured out a way to share code in a better way between `renderToString` and `renderToStream`, but the result was that `renderToString` slowed down relatively significantly (+30%, plus or minus). I'm trying to figure out how if I can tune it more carefully, but it's not looking great yet.
### Questions

So I think the questions I'd like to ask to the team are:
1. Assuming it were perfectly implemented with no performance degradation of the current code, is this even something you are willing to accept a PR for this feature?
2. If you were to accept this, how important to you is it that the string and stream versions of the code follow the same code path?
3. Are you willing to accept any degradation in performance of the string version of server rendering in order to get stream rendering that has constant TTFB and keep a single code path?

Thanks for your time, and thanks for all the great work you do on react!

(Tagging @spicyj, @gaearon, and @sebmarkbage, as I was instructed to do on the react IRC channel.)
 Thanks for following up and filing this.

I haven't looked at your code in detail, but I am generally positive on this. It sounds like serious users of server rendering (which include none of us on the core team) would all appreciate this feature. We should get feedback from some of those people before settling on an API.

I would prefer to have parallel codepaths rather than degrade the performance of renderToString. It shouldn't require serious changes: I believe that React[Server]ReconcileTransaction and ReactDOMComponent are really the only modules that have knowledge of the server-rendering difference, so there shouldn't be much to split. In particular, none of our "isomorphic" modules know about server rendering because it is a DOM-specific concept (ex: React Native does not support server rendering).
 @spicyj:

> I am generally positive on this. It sounds like serious users of server rendering (which include none of us on the core team) would all appreciate this feature.

So great to hear, thanks!

> We should get feedback from some of those people before settling on an API.

Agreed. Other than this issue, and outreach I will do to `react-dom-stream` users, are there any other methods to get feedback you would suggest?

> I would prefer to have parallel codepaths rather than degrade the performance of renderToString.

Good feedback, thanks.

> I believe that React[Server]ReconcileTransaction and ReactDOMComponent are really the only modules that have knowledge of the server-rendering difference, so there shouldn't be much to split.

I think it's a bit more widespread than the code that has knowledge of server-rendering; the issue is that the `mountComponent` and `mountChildren` signature (everywhere it shows up, both in DOM-specific and non-DOM-specific code) is synchronous, which won't work with streams. In my current implementation, I wrote a parallel set of `mountComponentAsync`/`mountChildrenAsync` methods which have an async function signature. 

I'm currently working on a newer version where `mountComponent` instead returns a data structure that can be processed either synchronously or asynchronously, depending on the caller. The preliminary (pretty messy) code for it is [here](https://github.com/facebook/react/compare/master...aickin:mergeable-stream-rewrite) if you are interested (ignore the test code; most of the interesting stuff is in `React***Component` and `StringLazyTree` files).

@mridgway:

> also looked at your implementation of react-dom-stream

Eek. The implementation is... not my proudest achievement; I had to rewrite it from scratch about 4 or 5 times (callbacks, generators, async/await) because perf was often abysmal once I got it working.

>  I think the best course of action (and recommendation by @sebmarkbage) was to move the recursion out of the individual React*Component.mountComponent methods and into the ReactReconciler.mountComponent method instead.

I think I did something like this in [my most recent experimental WIP branch](https://github.com/facebook/react/compare/master...aickin:mergeable-stream-rewrite) (as I said above, most of the interesting stuff is in `React***Component` files and `StringLazyTree`). Rather than hoisting the recursion into `ReactReconciler`, though, I pulled it out into a structure I called `StringLazyTree` (after `DomLazyTree`), but the rest of the idea is basically the same. The `mountComponent`/`mountChildren` methods now return a StringLazyTree, which is basically an array of raw strings and closures to call as you recurse down the tree. That can be done synchronously or asynchronously, which preserves the same code path for `renderToString` and `renderToStream`.

This experimental branch passes nearly all the tests (it doesn't do checksums yet, but I know how to do that from previous work), but it's about 50-100% slower for last byte than `renderToString` in my tests. Working on that now, although I'm not making much progress.

> It is difficult to commit to working on this further without buy in from the core team and more information on what is involved in #6170.

Thanks for pointing that out; I didn't know about it at all. Is there any info on what the algorithm rework looks like?
 > The new approach would walk the DOM tree and verify that the tree is the same, attributes and their values are the same, and content is the same.

This would probably be very slow and would likely require a bunch of internal refactors to even make possible.

> Get rid of `data-reactid`.

We barely need this at all now but I kept it intentionally so we can distinguish React-rendered nodes from nodes from elsewhere (from browser extensions, for instance).
 > We barely need this at all now but I kept it intentionally so we can distinguish React-rendered nodes from nodes from elsewhere (from browser extensions, for instance).

Nodes from elsewhere are going to disturb a react render anyway, and thus get blown away when React mounted into the dom.  I don't think there is much value in knowing where the nodes came from (knowing that the nodes differ is sufficient), but there is a disadvantage to being forced to maintain the `data-reactid` because it mandates a specific render order.
 > Does this sound right? Did I miss something?

That's what I remember, yes.

> This would probably be very slow and would likely require a bunch of internal refactors to even make possible.

We talked about this a while, and we weren't entirely sure how slow it would be, but I agree it's the biggest risk in the idea. @jimfb argued that it would be at least same big(O) of what is done currently when rendering on top of server markup, but the question is how much worse reading dom tag names and attributes is than constructing a giant string. I'm worried that it might be MUCH worse, but we will see.
 @goatslacker also, thanks for writing this up! üëç 

FYI, I'm trying to hack my way through a rough cut of step 1 today. I'm in the middle of it right now, and it's definitely a beast. I've got a few dozen new unit tests passing but a bunch not.
 @goatslacker

> Also helpful would be knowing where the logic that checks if it's React.createClass, React.Component, or SFC is at.

src/renderers/shared/reconciler/ReactCompositeComponent.js (eg. https://github.com/facebook/react/pull/5884)
 Quick update on potential speed of reconnecting to DOM by walking the dom rather than checksum (step 1).

I have a branch that does this now, although it's by no means complete (needs work on interactivity, a bunch more unit tests, 3 existing unit tests fail, and the code is not as readable as I'd like). It is complete enough to do a really rough comparison of performance between the two strategies, though, which I started this morning.

My **very preliminary and very rough** observation is that DOM walking is about 20% slower than checksum in Safari/OSX and about 40% slower in Chrome/OSX. 

This is obviously not ideal (faster is better!), but it's also not an order of magnitude increase. It's also not a giant amount of absolute time: in my (once again, rough) test on a 635KB render, the difference amounted to 20-40ms. When I tested a 107KB render, I couldn't detect a difference between the two result with ad-hoc testing. It's also worth noting that I haven't done any perf optimization on the branch.

I'm still concerned about the potential for bad perf regression, particularly given that different browsers can have wildly different perf characteristics. I think the best path forward is to polish up my test, make it automatable via Selenium, and run it enough times to get statistical significance on a variety of platforms. I think good coverage would look something like:
- Multiple document sizes
  - ~25K
  - ~100K
  - ~500K
- Platforms
  - Chrome/Windows 10
  - Firefox/Windows 10
  - OS X latest/Safari
  - iOS 9.2/Safari
  - Android 4.4/Default Browser
  - IE11/Windows 10
  - IE10/Windows 8
  - IE9/Windows 7

Does that make sense? Do folks agree?

Also: How much perf regression on client reconnect to server markup would you accept, if any?
 > I think the answer might depend, at least partly, on how much faster we think we can make server rendering with the optimizations we discussed.

Agreed. Even if connecting server markup on the client is slower, it's conceivable that the perf gains from speeding up server rendering and reducing page weight by removing `data-reactid` could make up for it in practical use. However, it's a hard for me to know how to trade these off without empirical data about the servers and networks that this will be used on.
 @aickin Great work!  This is amazing!

Obviously we do care about performance in all browsers, but if you have perf metrics for a couple of browsers (eg. Chrome+Firefox), my intuition is that it's sufficient to understand the likely ramifications of your changes.  Obviously feel free to collect more data if you think it's desirable/impactful, but your effort might be better spent optimizing and fixing bugs.  Your call.  We can always go collect more perf metrics later if such metrics are needed to make a decision.

Personally, I think 20-40% is fine.  Especially since there are so many benefits to this approach.  We can give better error messages.  We can remove remove all the complicated data-id lookup logic.    We can remove the dataids from the markup, making markup smaller.  We can have a faster/optimized/dedicated SSR renderer (I predict at least 2-5x improvements there anyway, which will annihilate the additional 20-40% remount cost).  Etc.  However, that said, it's ultimately a team/community decision.  And we should still do everything we can to make it even faster and get better numbers!

I think I would also be curious to hear how the performance compares with an initial pass that was rendered without serverside markup (ie. the createElement path).
 I think it will be difficult to get this off the ground if you try to make it better in phase 1. Just getting to a point where the code is decoupled while still maintainable in a way is going to be hard enough.

As a first goal, I'd suggest we get to a point where it is just feature/implementation parity with what we have to day.
 > As a first goal, I'd suggest we get to a point where it is just feature/implementation parity with what we have to day.

Sage advice. I wanted to know that it wasn't going to be like 5x worse to walk the DOM before investing a ton more time in this strategy, and I feel pretty confident that's the case now (Selenium-izing the tests shows between 5-70% worse perf, depending on platform). Back to working on correctness!
 I just opened PR #6618, which attempts to tackle the correctness side of stage 1. Please feel free to comment there. Thanks!
  This is fixed in v15 (stateless function components can now return null).  I'm going to close this out because we are in the process of shipping v15 and by the time this got merged and cherry-picked over, we'd already be on v15 and would have to do another PR to remove this note.

If you're interested, this was fixed in: https://github.com/facebook/react/pull/5884

The note is great.  Just the timing is wrong.  A month or two ago, we would gladly have accepted this PR!
 Do you think it might make sense to have some docs about this and just call out that it only applies in v0.14 but 15 does work? I think we're somewhat likely to see reports from people still using 14 but reading the 14 docs and getting the wrong idea.
 Yeah, alright, I could get behind that.
 @IvanVergiliev Can you update the note to indicate that this applies to v0.14, and that this was fixed in v15 such that stateless functions can now return null.

Perhaps:

> In React v0.14, stateless functional components were not permitted to return `null` or `false` (a workaround is to return a `<noscript />` instead).  This was fixed in React v15, and stateless functional components are now permitted to return `null`.
  @bryzaguy Thanks for the pull request!

The lifecycle methods (like `componentWillReceiveProps`) exist explicitly for the purposes of mutating state in response to a props change (you should not mutate state in render, so these functions should be kept separate).  In general, these functions are escape hatches, and shouldn't need to be used commonly.

More importantly, there is no guarantee that a render will only happen when props/state/context change.  In fact, React would be perfectly within its rights to re-render your component 60 times per second.  This makes having access to previous props (within render) effectively useless, because a prop change would only be "changing" for a single frame and a user would be unlikely to notice that single frame (next render, previous and current props would be the same).  Thus it makes no sense to utilize previous props while rendering (it only makes sense to update internal state - which can be rerenderd an unlimited number of times - based on a props change).

For this reason, we wouldn't do a change like this in React, so I'm going to close out the PR.

However, we do appriciate the effort you put into this PR!  If you're looking for a way to contribute, a good place to start would be: https://github.com/facebook/react/issues?q=is%3Aopen+is%3Aissue+label%3A%22good+first+bug%22
  There's just one thing left on the blocker list, which should get merged shortly. Then we're code complete. Everything else we were considering wasn't a regression so it got booted and we can catch up later.
## Real Code Changes
- [x] remaining regression with simulating events (#6380)
- [x] fix failing test / fallout from #6228 (#6426)
- [x] upgrade deps (#6413)
## Docs
- [x] update properties & attributes
- [ ] Removed deprecated methods
- [ ] Add any new deprecation notes
- [x] Add notes for potentially confusing version mismatches (eg, returning null from a functional component)
## Actual Release
- [x] create branch (`15-stable`)
- [x] shrinkwrap
- [x] update changelog (sync with blog post)
- [x] publish
- [x] Update travis to build docs from new branch (part of release but after everything is published)
## Post-release
- [x] update the tutorial repo
- [x] update fiddles
- [x] ensure master has release resource synced
 Note, we're going to break React Native init if we ship to latest until https://github.com/facebook/react-native/pull/6846 is shipped so that may impact us. We can always ship and just leave the `latest` npm tag pointing at 0.14.8 if we're ready to go before that's out.
 I added one, thanks.
 Nope, 15 is correct. http://facebook.github.io/react/blog/2016/02/19/new-versioning-scheme.html
  @gaearon (the author of that transform) works on React, so in a sense, he is "official" and has clearly put some thought towards this topic.  Having said that, I think the project is still very exploratory and I don't know of any official proposals to introduce it into the React core at this time.  I think we would want to let the experiments bake a little longer before we considered bringing it into the core.

I'm going to close this out, which will take it off our radar, since it's more of an exploratory/discussion topic at this point.  However, I am curious to hear your use case (what are you building that requires transforming all components?).
 I think I don't recommend this approach anymore. (Doesn't mean you have to stop using the project though. Not until we have a good alternative.)

I was mostly interested in hot reloading and error catching. Hot reloading is tricky but can be done without such an invasive transform if you wrap things in proxies at the call sites. Read more about it in https://medium.com/@dan_abramov/hot-reloading-in-react-1140438583bf. For errors, React will support error boundaries soon so this is also not a problem. For other use cases like perf monitoring, React is adding a blessed dev tool API, and it is a much better way to "spy" on components than wrapping them, in my opinion. Hope it helps. 
 By the way you can also explore wrapping component at call sites if this is what you're after. Patch createElement() and keep a mapping between unwrapped and wrapped components.
 It‚Äôs pretty much the same technique as Babel plugin but executed at the call site. As long as you keep a cache of wrapped classes and only wrap lazily and once, I don‚Äôt see much difference. Still, I would note that this is rather unorthodox. If it works well for you, it‚Äôs fine though :smile: 
  Thanks for the feedback but this is intentional. `console.error` provides good stack traces and our treatment of warnings is that they _should_ be fixed before they are committed and shipped. With maybe 1 exception, I think they should all be fixable.

One of the things we're working towards is a better way to manage these so that you can silence specific warnings or types of warnings without having to fork React. You can track that in the umbrella issue - https://github.com/facebook/react/issues/5306
  This is a usage question, rather than a bug in the React core. Usage questions are better answered on sites like StackOverflow, as we try to use github issues for tracking bugs in the React core. For this reason, I'm going to close out this issue, which takes it off our radar, but feel free to continue the conversation here (or move it to StackOverflow).
 I‚Äôm not sure we support putting text (which empty string is) inside a transition group: https://github.com/facebook/react/issues/6365.
Try `null` instead.
  What are your thoughts on using JavaScript for this? Conceptually React‚Äôs **experimental-and-subject-to-change** [context](https://facebook.github.io/react/docs/context.html) feature allows you to define variables local to a subtree of components. Your parent might look like

``` js
class BlueBar extends Component {
  getChildContext() {
    return {
      color: '#f00'
    };
  }

  render() {
    return (
      <div>
        <Background>
          <NotificationBadge />
          <SearchBox />
        </Background>
      </div>
    );
  }
}
BlueBar.childContextTypes = {
  color: PropTypes.string.isRequired
};
```

and your child components could read it like this:

``` js
class Background extends Component {
  render() {
    return (
      <div style={{ backgroundColor: this.context.color }}>
        {this.props.children}
      </div>
    );
  }
}  
Background.contextTypes = {
  color: PropTypes.string.isRequired
};
```

I understand this is orthogonal to whether we want to support CSS variables, but it could be a good solution in the meantime.
 Thanks for sharing the context (pun totally intended).
Let‚Äôs wait for my DOM-savvy colleagues to reply now.
Have you had a chance to look at what doesn‚Äôt work now and what it would take to fix it?
 As long as the spec is stable enough (haven't looked at it recently), it seems like this should be doable, but not sure at what cost. Basically we can use `node.style.setProperty('--color', 'hotpink')`. But if we need to look at every style property to see if the key starts with '--' then it could get costly.

> I am able to add them using the following syntax `<div style={{["--color"]: "hotpink"}} />`, but then they aren't updated if I try assigning a new value‚Äîwhich ruins much of the point of using a variable.

Yea, that's a result of us using innerHTML to do the first render and then updating properties after that. This will stop working in v15, even for initial render, so heads up.
 I think the short-term plan for this is probably to just leave the status quo and not change what we do for styles. As we continue to explore js styles, I think we're likely to end up changing how we end up doing styles. `!important` is another feature which has the same problem where it would work for initial render when using innerHTML but wouldn't update and now doesn't work at all v15 for client rendered. That is also possible to set using a DOM API but would be expensive to look at every value, so we might want an alternative way to express that.

For now if you want to use CSS variables you'll want to just break out of the declarative approach and manage setting these yourself with the lifecycle hooks (eg set refs and then in componentDidMount componentDidUpdate, use the ref to call `node.style.setProperty(...)` directly)
  Like mouse enter/leave, these are almost always what you want, not the `onFocus` and `onBlur` events we currently expose. I run into this semi-frequently when actually doing product work. We should add them.
 FWIW, I agree with you.  People know about focusin/focusout, and so we should just make them work, despite the fact that they would map to the exact same event handler we use for focus/blur.

However, last time this was discussed, we opted to not do this (https://github.com/facebook/react/pull/6226) and decided to warn instead (https://github.com/facebook/react/pull/6296/files).

I'd be fine with reversing this decision if you can get the momentum within the team.
 It looks like it was decided against because of an incorrect claim that they're indistinguishable from onFocus/onBlur. onFocusIn/onFocusOut is different in that when moving focus between two children of an element, neither event fires on the container.
 Doing it properly means adapting the logic in EnterLeaveEventPlugin and isn't as simple as adding it to SimpleEventPlugin.
 Ah, that makes sense. Thanks for explaining!

Adding ‚Äúgood first bug‚Äù here. Note @spicyj‚Äôs comments: they need to behave like `onMouseEnter` and `onMouseLeave`. You‚Äôll want to look at `EnterLeaveEventPlugin`.
 Hmm, that sounds plausible. Thanks for the correction. Kinda annoying that we'll end up renaming these for people but maybe it's for the best.
  A parent can access as many children as it wants (using multiple callback refs).  A single child can be referenced by as many parents as want (by wrapping/chaining callback refs, such that when a ref fires then the latest parent calls the ref of any other parent that was already listening).  So there is no such restriction for callback refs.  That restriction does exist for string refs, but string refs are documented as legacy and should be avoided.
 @zpao @gaearon Is there anything actionable here, or do we just want to close it out.  If actionable, any suggestions/bikeshedding on wording?
 I‚Äôd close this because I‚Äôm not sure what exactly could be improved. If there are any specific suggestions, they can be sent as a PR.
  Spiritual successor to https://github.com/facebook/react/pull/5680.  This is a fix for #6119 and #6219, both of which are blocking v15. As an added bonus, it happens to also fix #4618 :P.  It works by setting/removing both the attribute and property for `value` on inputs, and setting the property for `defaultValue`.

I fixed the tests to be more reasonable (inputs retain their initial value, rather than having the value potentially change when defaultValue changes). I also fixed the browser inconsistencies.
 @jimfb updated the pull request.
 @jimfb updated the pull request.
 @jimfb updated the pull request.
 @jimfb updated the pull request.
 Ok, I think this is ready to go.

EDIT: Actually, never mind, the bug still exists, fixing  :/ .
 This is not for 15.0, right?
 Paul Sebastian and I were at the PR review, and we weren't 100% decided, but Paul said to fix up #5680 to potentially land for v15.0
 @jimfb updated the pull request.
 @jimfb updated the pull request.
 Ok, I think this is good to go now.  Here are some fiddles that demonstrate everything working:

> http://jsfiddle.net/3r0krefu/ (fixes Ben's concerns from https://github.com/facebook/react/pull/5680)
> http://jsfiddle.net/ub6ec5rt/ (fixes Ben's concerns from https://github.com/facebook/react/pull/5680)
> http://jsfiddle.net/v6fz2ct1/ (fixes https://github.com/facebook/react/issues/6119)
> http://jsfiddle.net/wavkdt6b/ (fixes https://github.com/facebook/react/issues/6219)
> http://jsfiddle.net/c0u6v6fr/ (fixes https://github.com/facebook/react/issues/4618)
 Can you refresh me and explain why we need to change `defaultValue` behavior here?
 @zpao https://github.com/facebook/react/issues/4618 - In case someone has an uncontrolled component and then clicks the reset button, which was the genesis of this PR.  I used it (`defaultValue`) to solve browser inconsistencies; it might be sufficient to do it with just attributes (I could look into backing out `defaultValue` and using only the attribute if you think that's worthwhile, but Sebastian likes properties so I figured I'd throw him a bone and just use the property there :P).
 Rebased, in case we decide to take this as an alternative to https://github.com/facebook/react/pull/6449
 @jimfb updated the pull request.
 Some comments from me inline.

@sebmarkbage says that when you change defaultValue it _should_ change the visible value (but we can't take that for 15).

@zpao wants a more detailed test plan with exact steps and specific browser versions noted.
 As per PR review... Ben had some nitpicks to fix, sebastian had the detach on initial mount request, and Paul wanted a full browser test matrix to show that the behaviors demonstrated in the fiddles work on all the browsers we care about.  Given that those things are done, everyone is happy this and we can merge.
 Ok, updated to fix Ben's nits, Sebastian's request to disconnect at initial mount, and Paul's request that I re-test in the various browsers after fixing the nits.

My test routine:
- verify that modifying default value does not modify text input value
- verify that modifying default value does not modify checkbox value
- verify that modifying default value does not modify textarea value
- verify that the reset button will reset text inputs to the specified default value
- verify that the reset button will reset checkboxes to the specified default value
- verify that the reset button will reset textareas to the specified default value
- verify that progress element can be set to an indeterminate state
- verify that we render a select box with `value=""` as the empty string
- verify that controlled inputs work, curser does not jump to the end of the text input

My browsers:
Chrome (Version 50.0.2661.86)
Firefox 46 (Version 46.0)
Safari 9.1 (Version 10601.5.17.4)
Opera 36 (Version 36.0.2130.65)
Internet Explorer 11 (Version 11.103.10586.0)
Internet Explorer 10 (Version 10.0.9200.17519)
Internet Explorer 9 (Compatibility mode in IE10, Browser=IE9, Document=Standard)
Microsoft Edge 25.10586.0.0

Everything worked beautifully in all the browsers :).
 @jimfb updated the pull request.
 Accepted with inline comments. Also Travis is failing.
 @jimfb updated the pull request.
 Ok, I think this is mostly ready-to-go.  A couple of last todo items for me are:
- Look into `skipReplace` and remove if unnecessary.  Add comment if necessary.
- Re-run the full test plan above on all the browsers above, verify things didn't break.

If people have other last comments, I think now is the time.
 Yeah, let's get this in after you fix the skipReplace thing.
 Ok, just got done with my test suite, things are looking good.  Since we no longer set the textContent of controlled textareas during reconciliation (due to changes requested by @spicyj and @sebmarkbage), I needed to apply a minor patch for correctness:

```
diff --git a/src/renderers/dom/client/wrappers/ReactDOMTextarea.js b/src/renderers/dom/client/wrappers/ReactDOMTextarea.js
index fd18c1d..74d62ff 100644
--- a/src/renderers/dom/client/wrappers/ReactDOMTextarea.js
+++ b/src/renderers/dom/client/wrappers/ReactDOMTextarea.js
@@ -174,7 +174,11 @@ var ReactDOMTextarea = {
       if (newValue !== node.value) {
         node.value = newValue;
       }
-    } else if (props.defaultValue) {
+      if (props.defaultValue == null) {
+        node.defaultValue = newValue;
+      }
+    }
+    if (props.defaultValue) {
       node.defaultValue = props.defaultValue;
     }
   },
```

Other than that, all looks good.
 It looks like input updateWrapper is now:

``` js
    if (value != null) {
      var newValue = '' + value;
      if (newValue !== node.value) {
        node.value = newValue;
      }
    } else {
      if (props.value == null && props.defaultValue != null) {
        node.defaultValue = '' + props.defaultValue;
      }
    }
```

whereas textarea updateWrapper is:

``` js
    if (value != null) {
      var newValue = '' + value;
      if (newValue !== node.value) {
        node.value = newValue;
      }
      if (props.defaultValue == null) {
        node.defaultValue = newValue;
      }
    }
    if (props.defaultValue) {
      node.defaultValue = props.defaultValue;
    }
```

Is there a reason these are different? I would have thought we'd want the same exact behavior.

Do we have tests for when both value and defaultValue are specified? What if defaultValue is `''`? It looks like the textarea code will incorrectly treat that as unspecified.
 They are different because inputs set value properly during reconcilation.  This is what I wanted to do with textareas also (indeed, my prior implementation DID, and it worked well!), but you guys told me to do the sketchy hack where a textarea returns `{children: initialValue}` instead of always reflecting the current/correct value.

You asked me to always return the initial value instead of the actual value, because you didn't like me changing `setTextContent` to check if the value actually changed before changing the value (which was necessary because of a bug in IE9).  I don't like the solution you and sebastian advocated for, but I needed to choose my battles in the interest of moving this diff forward, so I capitulated, but that's the reason for the difference.

With regards to the defaultValue being the emptyString... you are correct, that should be a null check, I'll update it and add a test for that situation.  That is an extreme edge case, since the default value for defalutValue is the empty string, it would require someone to set the defaultValue and then change the defaultValue to the empty string - which is very unlikely (but valid) thing to do.  Updating now.
 Are we targeting 15 or 16 with this?
  @Sumei1009 updated the pull request.
 Ping @Sumei1009, would you mind making these changes?
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 CLA is required before we can merge this.   https://code.facebook.com/cla 
 Ping.
 Âú® merge ÊÇ®ÁöÑ PR ‰πãÂâçÈúÄË¶ÅËØ∑ÊÇ®Á≠æÁΩ≤‰∏Ä‰∏ã https://code.facebook.com/cla „ÄÇË∞¢Ë∞¢ÔºÅ
  This would put a pretty heavy burden on component authors.  They would need to distribute two versions of their components (prod vs. dev).  It's also not super actionable if you're using a third-party component that defines proptypes.  An automated transform wouldn't necessarily be able to eliminate all proptypes (eg. on stateless function components) without making a bold assumption that assigning proptypes to a function means that function must be a React component.

Anyway, I'm not actually oppose to the idea, but I think we'd need to have the transforms in existence before we could enable such a warning.  My guess is that it's not worth the headache.  But if someone writes such a transform, and people start using it and find that the byte savings justify the complexity, we could consider enabling such a warning.  Let's re-evaluate if/when such a transform becomes mainstream.
 @mijamo Yeah, that solves some of, but not all of, the overhead that @brigand mentioned.  React components will still have a proptype object defined with a bunch of empty function references.  But yes, it's an improvement :).
  Document legacyness of the return value of ReactDOM.render(), as per https://github.com/facebook/react/issues/6397
 Ping @gaearon @zpao Can one of you review this?
 :+1: I think it‚Äôs a good idea. This would be a breaking change for them tho? If it becomes a default. @iamdustan 
 @jimfb I‚Äôm accepting on the condition you address the above comments. Thanks!
 I think `renderTo*` methods would stay synchronous because they don‚Äôt have any updates. They are meant to be called as one-offs, rather then maintain continuously rendering UIs. On the other hand, `ReactDOM.render()` schedules a reconciliation that can be paused because _other_ important work is happening (e.g. handling a gesture). Incremental reconciliation doesn‚Äôt really help on the server because you can‚Äôt just show ‚Äúsome parts‚Äù and later show ‚Äúother parts‚Äù‚Äîonce you send the response it‚Äôs too late, and in any case the network latency is much bigger than the rendering cost so you ‚Äúdrop frames‚Äù anyway.
 @gaearon beat me to the punch.  His answer is exactly correct. üëç 
  Fix for #6062 

Let me know if I'm off base by using this approach.

(in trying to rebase with a merge conflict, I created commit noise, sorry)

Thanks!
 @troydemonbreun updated the pull request.
 @troydemonbreun updated the pull request.
 @troydemonbreun updated the pull request.
 @jimfb What about this approach?  Thanks for your time.
 @troydemonbreun Yes, this is the approach that I had in mind.  However, you're going to want to save the source when a component is rendering (ie. as oppose to `onInstantiateReactComponent`), because the warning could fire during an update (which won't have a corresponding instantiation).  Also, you'll want to give the source location of the jsx element being rendered, rather than the jsx element that lead to the component that has the problem.  Maybe something like `onMountComponent` and `onUpdateComponent`.

We will need unit tests for all the various cases.  Three that come to mind are:
- A custom/composite component renders 10 div tags, one of which has an unknown property - the source should specify which of the 10 divs is the problem.
- Unknown property during initial render.
- No unknown properties during initial render, but yes unknown properties for an update render.
 @troydemonbreun updated the pull request.
 @jimfb Thanks for the direction!  I noticed that `ReactDebugTool` has those events, is it okay to add those events also to `ReactDOMDebugTool`, or would you prefer a better way to be DRY about it? 
 @troydemonbreun Probably `ReactDOM` should register a `ReactDebugTool` that forwards all the `ReactDebugTool` events to the `ReactDOMDebugTool`.
 Ping @troydemonbreun
 Sorry about the delay,  my Dev VM is having problems,  looks like I will
need to rebuild.  Should get back to it tomorrow.
On Apr 13, 2016 5:51 PM, "Jim" notifications@github.com wrote:
 @troydemonbreun updated the pull request.
 @jimfb Trying to grok your last piece of advice. To keep from bothering you, I've spent some time browsing the code trying to infer from current debug tool examples, etc.

Do you mean to create another debug tool and `.addDevtool(ReactDebugToolEventForwarderDevTool)` in `ReactDebugTool`? Granted, that doesn't seem to meet the criteria of ReactDOM doing the registering.

I've also thought of `.addDevtool(ReactDOMUnknownPropertyDevtool)` in `ReactDebugTool` and extending it to handle the ReactDebugTool events.

Thanks for your time.
 @troydemonbreun updated the pull request.
 > Do you mean to create another debug tool and .addDevtool(ReactDebugToolEventForwarderDevTool) in ReactDebugTool?

Yes, I was thinking of a `ReactDebugToolEventForwarderDevTool`, but no, probably not registered IN ReactDebugTool (see below).

> Granted, that doesn't seem to meet the criteria of ReactDOM doing the registering.

I think registration would occur in `ReactDefaultInjection` (which is ReactDOM specific) or in `ReactDOM.js` (which would invoke `ReactInstrumentation.debugTool.addDevtool();`).  That way, ReactDOM is doing the registering.  I don't pretend to understand the injection stuff, so maybe I'm wrong.  cc @sebmarkbage may have better advice there.  Also, if you post something and it looks suboptimal, someone will probably be able to jump in with feedback, but obviously it would be better if those people (@sebmarkbage, @spicyj, @syranide, @gaearon) can provide feedback now instead after the code is written.
 @troydemonbreun updated the pull request.
 @jimfb `onMountComponent` appears to be triggered after the unknown property warning is thrown.  Is there another method/event in the workflow that might get the specific instance being warned, or did I just code this wrong?  

I have pushed my latest work in progress to this PR to show my progress.

Thanks!
 The places that those elements get generated is within `MountComponent` and `UpdateComponent`, but they're a few calls deeper (I think).  My comment about those functions was with regards to your use of instantiateComponent, which was not correct (because of things like updates)  Sorry, I wasn't looking at the code and my answer was a little too high-level.

The places that we currently warn are: `onCreateMarkupForProperty`, `onSetValueForProperty`, and `onDeleteValueForProperty`.  Each of those properties comes from an element (that element gets created on Mount or Update).  We need to know which element those properties came from.

Does that make sense?  Let me know if not / if you have questions that I can clarify.
 I think that makes sense.  I'll dissect `internalInstance` to get more familiar with that structure.
 @jimfb Getting a bit stuck on this one, and it probably has the most to do with me needing understanding more of the internals -- the relationships, wrappers vs. contexts vs. owner vs. renderedComponents vs. renderedChildren vs. reactInternalInstance. Note: I don't expect you to explain those things to me.  I'm sure there are many devs that understand the internals.

But just in case I misunderstood, let me reiterate what I think you are saying is the approach (aside from groking the structure). To capture the proper element creation, I need to go for a deeper event than  `onMountComponent`and `onUpdateComponent`?
 "Element creation" is not the issue (I'm going to be nitpicky with terminology here, just to try and avoid ambiguity).  We need to know which ReactElement we're currently "processing" (for lack of a better word) when making an invocation to something like `setValueForProperty`.  That is to say, we need to know which ReactElement is directly responsible for reading the value for that property (where did we get the values/arguments which we passed to setValueForProperty).

I spent a couple minutes looking at the code again.  The thing about source code is that it's hard to see what's actually going on unless you're actually writing it, so take all this with a grain of salt... 

This whole discussion is complicated by the fact that some functions have the same names and the event names are a bit ambiguous with regards to when they fire.  The `onMount` event is fired by the reconciler, after the instance has already been mounted (ie. it's too late at that point).  Maybe there should be two events called `onMountStart` and `onMountEnd` (we should probably do this anyway).  The event also fires for composite components, which is sketchy but maybe it isn't a problem because composite components should presumably never invoke `setValueForProperty`.  The other problem with the current `onUpdateComponent` is that it doesn't pass the next element (you can't read from instance.currentElement because that value will be the old element, not the new one).  Anyway, I think that could be made to work.

An alternative solution is to dig deeper and fire some DOM events in places like `ReactDOMComponent.mountComponent` and `ReactDOMComponent.updateComponent`.  This is what I meant, digging deeper than `ReactReconciler.mountComponent`.

There are some other edge cases where `setValueForProperty` is called (like `ReactDOMTextarea.js`) that we'd likely want to handle also.

I think either solution would be perfectly fine, and I don't have an opinion on which is cleaner.  Maybe others on the team have opinions about how this should be done.  I've been itching to find an issue to cc our new @facebook/react-core group, and I think I've found one.  If people have opinions, they should speak now.
 Note that I plan to add elements to `onMountComponent` and `onUpdateComponent`, I just haven‚Äôt had an opportunity to do that yet. Also please note the changes I‚Äôm doing in #6549: rather than pass an internal instance, we will be passing IDs. You can see the last commit in #6046 for the reference of building on top of events like this. I hope this helps!
 > An alternative solution is to dig deeper and fire some DOM events in places like ReactDOMComponent.mountComponent and ReactDOMComponent.updateComponent. This is what I meant, digging deeper than ReactReconciler.mountComponent.

This makes sense to me from my experience with #6046.
 @gaearon Thanks, that is excellent info! To be sure, the last commit = "Add new ReactPerf" 6a0a824? (Chronologically, it seems to come after your comment, unless I am misreading GH)
 @jimfb Thanks for following up!  Please be nitpicky, it is helpful for getting direction. :-) 
 > To be sure, the last commit = "Add new ReactPerf" 6a0a824? 

Yes.
 @troydemonbreun updated the pull request.
 @troydemonbreun What is the status on this PR, is it ready to go, or are you still working on it?  Just wondering if I should do another code review now or wait for more updates.
 Still working
On Apr 26, 2016 7:08 PM, "Jim" notifications@github.com wrote:

> @troydemonbreun https://github.com/troydemonbreun What is the status on
> this PR, is it ready to go, or are you still working on it?
> 
> ‚Äî
> You are receiving this because you were mentioned.
> Reply to this email directly or view it on GitHub
> https://github.com/facebook/react/pull/6398#issuecomment-214925505
 OK, sounds great, thanks!  Just let me know when you're ready for a review.
 @troydemonbreun updated the pull request.
 @jimfb Moved triggers to `ReactDOMComponent`.

Questions:
- Not sure if I placed the triggers at the exact proper locations
- I'm still reading from `instance._currentElement` (instance is ReactDOMComponent passed in) since I'm at a deeper level, yet I am not getting the source in some cases, so is _currentElement also not right at this level?  @gaearon is passing in debugID in his refactor #6549 - I don't grok the debugID at the moment outside of his `ReactComponentTreeDevtool`(e.g. how to user debugID to get a element)
- I named the event `onMountComponent`for the meantime, but am open to a different name to avoid confusion vs. `ReactDebugTool.onMountComponent`
- I dropped the `ReactDebugToolEventForwarderDevTool`since I am listening for a "different" onMountComponent, I can bring it back if needed
 > @gaearon is passing in debugID in his refactor #6549 - I don't grok the debugID at the moment outside of his ReactComponentTreeDevtool(e.g. how to user debugID to get a element)

I would imagine both `onMountComponent` and `onUpdateComponent` can receive `nextElement` as the second argument.
 @gaearon Thanks for your input.  Do you mean inside `ReactDOMComponent.mountComponent`? Is that a property on this, or?
 I mean whatever the current `_currentElement` is. I haven‚Äôt thought about this deeply so sorry if I‚Äôm on the wrong track üòÑ 
 > Not sure if I placed the triggers at the exact proper locations

Looks ok to me.

> I'm still reading from instance._currentElement (instance is ReactDOMComponent passed in) since I'm at a deeper level, yet I am not getting the source in some cases, so is _currentElement also not right at this level? @gaearon is passing in debugID in his refactor #6549 - I don't grok the debugID at the moment outside of his ReactComponentTreeDevtool(e.g. how to user debugID to get a element)

I don't understand the issue.  At first glance, it looks like `_currentElement` will be correct at this point.  Are your warnings getting an incorrect result here?  I think @gaearon was suggesting that you could pass in the current element into the event, instead of (or in addition to) passing in the internal instance such that the devtools isn't reading the private `_currentElement` field off the instance.

> I named the event onMountComponentfor the meantime, but am open to a different name to avoid confusion vs. ReactDebugTool.onMountComponent

Perhaps `onMountDOMComponent`?  Such that there is no issue if we do forward the core React onMount event.

> I dropped the ReactDebugToolEventForwarderDevTool since I am listening for a "different" onMountComponent, I can bring it back if needed

Sounds like it is not going to be needed for this PR, if you go with the approach of firing events in ReactDOMComponent.  However, I wouldn't throw away the code.  Maybe create a second PR that adds the `ReactDebugToolEventForwarderDevToolsince` since it is probably something we'd want to add to React anyway.
 > Perhaps onMountDOMComponent?

Related: conversation with @sebmarkbage in https://github.com/facebook/react/pull/6612#issuecomment-214956544, take what you will from it üòÑ .
 @jimfb Have not tested in browser.  Added jasmine test (currently commented out to keep Travis from barking) What I have observed is that if I use 
`ReactTestUtils.renderIntoDocument(<div class="muffins"/>);`
the source is populated, if I use
`ReactDOMServer.renderToString(React.createElement('div', {class: 'muffins'}));`
the source is _null_.
I probably don't understand the subtleties of the difference between those. However, in the existing 'should warn about class' test that triggers the warning referenced in the issue, `ReactDOMServer.renderToString` is being used, so I was concerned that the source was null in that case.
 @jimfb Forgot to mention that `ReactTestUtils.renderIntoDocument(<div class="muffins"/>);` does not trigger the warning anyway, (the source is available because I was logging to console).
 @gaearon Do I need to pass in debugID (as a standard) if I am not using it?
 @troydemonbreun The source information is only added if the user is using JSX.  The source information is not added automatically if the user uses `createElement` (although, this is potentially something we could fix/change at some point).  Anyway, this is about the usage of `createElement`, unrelated to `renderToString`.  This is expected behavior, just make sure the warning does an appropriate thing if there is no source.

With regards to the `debugID`, it's not particularly useful for this devtool, but other devtools might find it useful, so might as well include it.  But it doesn't really matter, not a huge concern either way.
 @troydemonbreun updated the pull request.
 @jimfb I've added in more tests for `ReactDOMUnknownPropertyDevtool.onCreateMarkupForProperty`. How do I trigger the `ReactDOMTextarea`edge case, in other words, how do I write the test so I know I'm capturing that edge case?  I tried some tracing on `DOMPropertyOperations.setValueForProperty` and rendered a textarea, but I didn't see it make it to that path for the invalid property I set.  Thanks!
 @troydemonbreun To trigger that case (with the `value` prop in `ReactDOMTextarea`), I think you need to update the component:

```
var container = document.createElement('div');
ReactDOM.render(<textarea value="foo" />, container);
ReactDOM.render(<textarea value="bar" />, container);
```

ReactDOM will never fire an `unknown property warning` for that case, so it is probably fine to fix that as a followup PR.  (or feel free to fix up this PR).

I'm going to tentatively accept, since I think this PR makes the world incrementally better.
 @jimfb Great, thanks for all your help!  I'll keep this PR as it is now functionally to keep things simple.
 @troydemonbreun Great job! Sorry that I haven‚Äôt been very responsive.
 Thanks!  You have been responsive and helpful.
On May 3, 2016 6:27 PM, "Dan Abramov" notifications@github.com wrote:

> @troydemonbreun https://github.com/troydemonbreun Great job! Sorry that
> I haven‚Äôt been very responsive.
> 
> ‚Äî
> You are receiving this because you were mentioned.
> Reply to this email directly or view it on GitHub
> https://github.com/facebook/react/pull/6398#issuecomment-216694995
  This is a tracking issue, because we're not ready to deprecate the return value of `ReactDOM.render()` yet.  This will likely be a longer-term objective (not immediate), but we should have an issue to reference as we start to get the ball rolling.

Reasoning: We are working towards a new incremental reconciler, which means that a render may not be complete prior to `ReactDOM.render()` returning.  For anyone relying on the return value of `ReactDOM.render()`, there would be a race condition where the returned instance is potentially not fully mounted.  Safe-looking code might work 99% of the time, but fail 1% of the time, at the sole discretion of the scheduler.  To be clear: this is not an issue today, but will become an issue once we start utilizing an incremental renderer, iff people rely on the return value.

As we prepare for the new reconciliation algorithm, we should start encouraging people should start avoiding the return value of `ReactDOM.render`.  People should, instead, attach a callback ref to their root component when rendering the component, thus allowing them to get a reference to the instance after mounting is complete.

First step in this process is to update the documentation to state that the return value of `ReactDOM.render` is legacy, and that people should attach a ref instead (similar to what we did for string refs).
 Related: https://github.com/facebook/react/issues/2642#issuecomment-65808681
 ReactTestUtils might be an exception as a convenience. Testing likely needs its own reconciler anyway.
 @ibhub I don't understand your question/comment.  React v15.0.0 does contain a render function, and `ReactDOM.render` is not deprecated (only usage of the return value is discouraged, the behavior is unchanged).
  This adds the blog post for React 15 release.
There are still a couple of action items here that I intend to go over on Monday:
- [x] Include info about more recently merged warnings
- [x] Experiment with linking to pull requests for community contributions more extensively

Feedback is welcome!
Dating this as Monday.
 @gaearon updated the pull request.
 @gaearon updated the pull request.
 @gaearon updated the pull request.
 @gaearon updated the pull request.
 @gaearon updated the pull request.
 @gaearon updated the pull request.
 @gaearon updated the pull request.
 @gaearon updated the pull request.
 @gaearon updated the pull request.
 @gaearon updated the pull request.
 This is now done. Some proofreading and link-clicking would be nice. :smile: 

Personally I like the new style with PR links. My only concern is that we don‚Äôt have `target="_blank"` for external links but we probably should. But I‚Äôm too lazy to fix it now. I‚Äôd also rather fix it on JS side.
 Note that it may be a tiny bit unconventional to use usernames to link to PRs. I think it makes sense though. At first I used `([@user] in [#PR])` but it was _way_ too noisy, and PR numbers don‚Äôt really convey any information. I think linking from user names to PRs is a good tradeoff between keeping the log readable, acknowledging the contributors, and linking to detail for interested parties.
 @gaearon updated the pull request.
 @gaearon updated the pull request.
 Flattened and committed directly for the release - https://github.com/facebook/react/commit/75f492507421f243f49ef9cfdcab5c557022eefe. If you see any grammar changes, let's just open a PR and we'll make sure it gets synced, thanks!
  We tried to make it clear from the notes that no specific implementation is in the works right now. The exploration is targeted at looking if either of these approaches, or a combination of them, can work at Facebook scale without regressing performance or other important characteristics.

So right now the possibility of React having some built-in support for managing inline styles is **purely hypothetical**. Before we get into any API implications, we need to learn about the actual challenges posed by different approaches. So it‚Äôs not really about ‚Äúwhich one of these libs should we build into React DOM‚Äù but about ‚Äúwhich of these approaches can work at Facebook scale, if any?‚Äù

We will share our findings when/if we have some tangible results, but at the moment we don‚Äôt, so it‚Äôs too early to discuss how specifically we want to handle inline styles, and what should be delegated to third party packages.
 Feel free to bring it up again if we ever implement this though :+1: 
 In this case it‚Äôs a little more involved (i.e. an implementation might both want to return either a bunch of classes or a bunch of styles, or both). We don‚Äôt currently allow string styles although @jimfb expressed some similar thoughts in #5397.

cc @vjeux as he‚Äôs the one looking into this stuff.
  That's a private package that will never be published so I don't think there's any value in having this. The real package that gets published to npm does have this set (https://github.com/facebook/react/blob/master/packages/react/package.json#L8). Thanks though!
  Thanks for the idea. For the time being (if/when there's a js styles approach we support in core), we're going to just stick with our current approach to styles and not add more magic here. I do see the convenience though and there's a chance we end up doing something similar. cc @vjeux as you think about this stuff.
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 I think it being a larger header is intentional.
  Can you provide a simplified jsfiddle that demonstrates the issue?
  There is #6377 though. Maybe you should collaborate :wink: 
  Hi @ORESoftware!

We generally prefer that issue tracker is used exclusively for feature requests and bug reports because questions get lost here. [StackOverflow](http://stackoverflow.com) is a better place for specific questions.

> Doesn't / couldn't React have enough info to go off of already, so as to not need an actual reference to the React component on the front-end as well?

No, it doesn‚Äôt. The DOM node is just the DOM: it does not contain any JavaScript code related to the component, such as event handlers or its `render()` method. The markup may arrive before the JS is even loaded, which is what makes server rendering useful.

However this means that React can only take over updating that markup after you give it _the code_ for your component, which corresponds to the `<MyComponent />` argument in `ReactDOM.render()` call.

If it was possible to just call `ReactDOM.render(document.getElementById('react-root'))` and have React take over the updates on the client, then it would mean loading React alone is enough and this code can run before the JavaScript code for your app is loaded. However this contradicts the fact that React can‚Äôt guess how to make your component markup dynamic without having access to your component‚Äôs code. This is why it‚Äôs necessary to associate the two.

Note that you don‚Äôt really ‚Äúre-render‚Äù on the client. If the markup is identical, React will just attach a component instance to the existing DOM. However it can‚Äôt do that without access to component‚Äôs code on the client side, which is why you have to associate it with markup using that `ReactDOM.render()` call. And if the markup won‚Äôt match, it will forcibly re-render your app to use the markup generated by the client side which seems preferable to just silently failing.

I hope this helps! Please try to use StackOverflow next time because questions are much easier to search there. Thanks!
 > SO is unfortunately not for "why" questions unless you like downvotes LOL

I don‚Äôt think it‚Äôs [necessarily the case](http://stackoverflow.com/search?q=why). StackOverflow community cares that the questions are specific, can be answered objectively, and are carefully formatted, explained, and titled. Your question can satisfy all of these constraints.

As for the docs, they definitely could be better, and contributions are welcome :smile: . If you have specific suggestions for improvement maybe you could give it a try to send pull request? You know better than me which docs you looked at, so you have more context on where that warning would make more sense.

Thanks!
 > For example if I want to render a variable number of child components, do I just cross my fingers that the data on the front-end sent to the parent component matches the data sent to the component when it was rendered on the backend?

Yeah, this is correct. You need to send the data down. So that results in some duplication but on the other hand you have something visible immediately before JS is loaded and picks it up. It‚Äôs a tradeoff.

If you use something like Redux to manage your state, you might enjoy reading http://redux.js.org/docs/recipes/ServerRendering.html as I think it answers some of your questions about data hydration.
  Thank you for the suggestion! We try not to expand the API surface area for PropTypes because they are effectively in maintenance mode and the longer term plan is to use something like Flow instead. Indeed, as @brigand‚Äôs project shows, this can be solved in the ecosystem. When and if React gets first-class support for inline styles as the blessed solution to style React apps, we might reconsider this, but for now please use https://github.com/brigand/react-style-proptype and feel free to file issues for supporting more style props there. Cheers!
  This is a usage question, rather than a bug in the React core. Usage questions are better answered on sites like StackOverflow, as we try to use github issues for tracking bugs in the React core. For this reason, I'm going to close out this issue, which takes it off our radar, but feel free to continue the conversation here (or move it to StackOverflow).

With regards to the specifics of your question: If you want to test updates, then you can just manually create a div/container and render into it twice, as you mentioned. You don't need to use renderIntoDocument if you don't find it useful for your particular test.
  This sounds very much tied to your specific application and is unlikely to be a bug with React, which is what we try to keep GH for. Have you tried posting to stack overflow with more specific information or a link to your project where people can look and see what's going on. As is, you've posted lots of unspecific information for a very specific issue and didn't actually say what invariant is being violated. My best guess is that you need to enable another transform so that the export line is transformed to common js.

I'm going to close out since this isn't a bug with React.
 Babel.
 use the es2015 preset.

This is the last response I'll put here. Please use another medium for support.
  Thanks @cbrwizard!
  Thanks for reporting. We'll get this fixed.
 Are we not checking for unexpected warnings in tests? Should we? Curious how this crept in unnoticed.
 node doesn't support Proxies so none of that code is actually getting tested :/ Even running with `--harmony` flag (which we do at least with `grunt test`) doesn't enable it since it's "in progress".  We could probably run with `--harmony_proxies` to force it on.
  If the user is using a Babel polyfill, would a component defined with `PropTypes.symbol` print a warning?
How do we want to handle this scenario?
 @puradox updated the pull request.
 We will review this after 15.0 is out. Feel free to ping me if we forget to (but we shouldn't). 
 Rerunning now
 @puradox updated the pull request.
 @puradox updated the pull request.
 Merging since this was accepted.
  Not 100% sure if we should do this and add to the list of "where does this come from" modules. Simply rewriting and requiring the defacto polyfill instead of our own. This will require a few small changes internally.

A couple alternatives:
- change all `require('Object.assign')` to `require('object-assign')`. Same amount of work, but potentially clearer that this is the npm module and now a providesModule. This will play nicely into #6336 when that happens.
- Just update our Object.assign to be the content of object-assign (and add copyright headers, etc). This is the least amount of work but a bit like cheating :).

Net result for browser packages is the same for all of these - we end up with object-assign packages. The only real difference would be in the npm package and adding another dependency.

Fixes #6372
 You probably know which option I like :smile: .

> change all require('Object.assign') to require('object-assign'). Same amount of work, but potentially clearer that this is the npm module and now a providesModule. This will play nicely into #6336 when that happens.
 Wouldn't it make more sense to have this redirect live in fbjs? E.g. a forwarding module. That's the place where we swap out FB specific polyfills for community ones.
 @zpao updated the pull request.
 Why are we picking `object-assign` specifically? What do babel code end up depending on? `fbjs` has a core-js dependency. Can we end up with one?

My only concern for this is perf. We know that we've intentionally overridden this in RN in the past because it is too slow.

How do we override this internally?
 Babel desugars spread operator to this helper:

``` js
"use strict";

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
```

However if you import `babel/polyfill`, you‚Äôll actually end up with [`Object.assign()` as implemented by core-js](https://github.com/zloirock/core-js/blob/master/modules/_object-assign.js).
 I picked object-assign because it's stable and apart from the Symbol support, virtually identical to what we have now. Compare https://github.com/sindresorhus/object-assign/blob/master/index.js to https://github.com/facebook/react/blob/05b05c4c81154b6e653a10479dd77a569d2b52f7/src/shared/stubs/Object.assign.js

In RN if perf is a concern then they can set Object.assign before loading any other modules and they'll be better off anyway (will catch the user code too). Since this module actually uses Object.assign first instead of always using a custom method that means RN only has 1 thing to override.

on www we would have

```
// @providesModule object-assign
module.exports = Object.assign;
```

This is what we do already for `@providesModule Object.assign` (or if we did exactly as I have already here without rewriting requires, it would be identical). This will use our real polyfill which uses the native impl if it exists. This means www already supports Symbols.

As for fbjs‚Ä¶ in theory sure. But React is pretty much the only thing internally using this Object.assign module. Everything else uses Object.assign or spread directly.

---

I chose not to use the babel transform / runtime since I didn't want to make another direct dependency on core-js which isn't the smallest dep. And inlining `_extends` into all the callsites wouldn't be great for bytesize. If we went through fbjs for this then yes, it would be a transitive dep which is already there so wouldn't be too bad. But see previous note about that.
 @zpao updated the pull request.
 There isn't a solid plan, we've mostly taken them on a case by case basis. We've inlined in a couple places (eg `Object.is` because it's a single line and there would have been one or 2 callsites). Another instance of Symbol support was just to get a Symbol in 1 place so we did an inline check and fallback to a string.

ES5 was easy to make the call and just tell people to bring their own. Personally I mostly feel the same about ES6, with some careful consideration about using things that can't be polyfilled. I don't know what the benchmark is to get everybody to agree with me though :) Historically Node made that harder to really say but with the recent upgrade rate it's much more doable. Polyfilling a Node environment is still pretty gross though and I don't think I could comfortably argue that everybody doing server rendering must `require('core-js/path/to/es6/polyfil')` before running any code.
 @zpao updated the pull request.
 FYI: I'm cleaning up other callers internally and in RN (https://github.com/facebook/react/pull/6376) so I think I might change this slightly so that we are using the `object-assign` module directly instead of redirecting like this. It's a bit more work but it feels better.
 > in RN (#6376)

Probably https://github.com/facebook/react-native/pull/6766.
 @zpao updated the pull request.
 Took it one step further and replaced all uses of our own assign with Object.assign directly. I wrote a Babel plugin (based on the idea of http://babeljs.io/docs/plugins/transform-object-assign/ but inserting requires instead of the _extends helper for less code and an actual Object.assign polyfill). I could have used `file.addImport` but that ends up generating the interopRequire noise which I didn't want. So at the end of the day our generated code is virtually identical to what we have right now.

``` js
// before
var assign = require('Object.assign');
assign(...);

// after
Object.assign(...);

// after transform
var _assign = require('object-assign');
_assign(...)
```
 @sebmarkbage accepted verbally the other day so just updating the label to match that.
 @zpao updated the pull request.
 @mijamo Yes, doing this was a mistake. We shouldn‚Äôt do this again. cc @zpao 
 Oh, I was referring to removing `React.__spread` and the TypeScript issue.

While `react/lib/Object.assign` story is similar, I don‚Äôt think we‚Äôll be adding it back. I believe we explicitly said many times that components must never rely on anything inside `react/lib/`.

`React.__spread` _kinda_ was part of the public API, at least to the JSX transforms, but was never the case for `React/lib/Object.assign`. We could potentially remove it in any patch version. We really can‚Äôt make any guarantees about internal modules people choose to rely on because they can be gone after any refactoring.
 We won't be re-adding that module. None of the `lib/` files are part of our public API and using them has always been at your own risk. We move and rename files with some frequency.

We're reverting the `__spread` change because it was on the exported object and even though it wasn't a supported API, it was there.

> IMHO it would have deserved a RC3

You're right, we should have done an RC3.
 In a way... Causing havoc is sometimes a good thing. It helps enforce expectations. We should avoid if possible though.

> On Apr 8, 2016, at 9:13 AM, Paul O‚ÄôShannessy notifications@github.com wrote:
> 
> We won't be re-adding that module. None of the lib/ files are part of our public API and using them has always been at your own risk. We move and rename files with some frequency.
> 
> We're reverting the __spread change because it was on the exported object and even though it wasn't a supported API, it was there.
> 
> IMHO it would have deserved a RC3
> 
> You're right, we should have done an RC3.
> 
> ‚Äî
> You are receiving this because you were mentioned.
> Reply to this email directly or view it on GitHub
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
  Thanks!
  It is a bit inconsistent that just before this paragraph we `bind` in the `render()` method. Maybe we can change that example instead of introducing the new one, and just repeat the constructor in this section instead?
 @mfunkie updated the pull request.
 @mfunkie updated the pull request.
 @mfunkie updated the pull request.
 I read this a couple of times, and that sentence still stands out as too long to me.
I think we can do better and I have another idea.

1) Change it to `We recommend that you bind your event handlers in the constructor so they are only bound once for every instance:`
2) Change the example below to include the `state` assignment so reader doesn‚Äôt assume it can be removed for some reason.
3) _Before_ our new sentence, add an example _demonstrating_ the previous (existing sentence), like

``` js
// You can use bind() to preserve `this`
<div onClick={this.tick.bind(this}>

// Or you can use arrow functions
<div onClick={() => this.tick()}>
```

4) Finally, at the very end, add another one liner, a la `Now you can use this.tick directly as it was bound once in the constructor. This is better for performance of your application:`

``` js
// It is already bound in the constructor
<div onClick={this.tick}>
```

Sorry for the back and forth. What do you think of this?
 This is looking great! Maybe worth changing ‚Äúif you compare props using `shouldComponentUpdate`‚Äù to ‚Äúif you implement `shouldComponentUpdate()` with a [shallow comparison](https://facebook.github.io/react/docs/shallow-compare.html) in the child components‚Äù.
 :+1: this makes more sense
 @mfunkie updated the pull request.
 @mfunkie updated the pull request.
 @mfunkie updated the pull request.
 Thanks for your work on this! This will be up on the website soon.
  What is the use case for using Symbols as state keys? State is already private and is never shared so it‚Äôs not clear what the benefit of supporting Symbols as keys is. Would you mind sharing your thoughts on this?
 cc @sebmarkbage 

Basically this boils down to the fact that the `Object.assign` "polyfill" we have inside React doesn't handle symbols. We just use that to assign the pending updates into the current state - https://github.com/facebook/react/blob/22a3d0387b190eed4689937a375ce22b1338803b/src/renderers/shared/reconciler/ReactCompositeComponent.js#L762-L771. We knew that going in when we first added it but that was a long time ago and symbols are a real thing that browser support now so maybe we should too.
 No, it's a "polyfill" which we always use and never fall back to native implementation. This was because at the time of adding this, the `Object.assign` spec had just changed (around handling null/undefined I think) so we decided to always use our own code for consistency. Here's the code: https://github.com/facebook/react/blob/22a3d0387b190eed4689937a375ce22b1338803b/src/shared/stubs/Object.assign.js
 I don't know yet, would like to get input from @sebmarkbage about intent before deciding how to fix it (personally, I think if yes we would likely just get rid of our polyfill and use babel-polyfill/runtime for it _or_ even just say that you must include a polyfill of your own like we have for ES5 code)
 Yea, we should use native if available. Either using our own module or a mandatory external polyfill. Probably best to keep our own if a native is not available. Easy to miss the polyfill warning if you're only testing in modern browsers.
 Worth noting that there are very few cases of these. We've long used ES5 but ES6 is mostly compiled out or we provide our own polyfills (Object.assign as a module, Object.is inlined are the only 2 I know of). The idea of a react-polyfill repo is interesting though and definitely something we'll keep in mind moving forward.
  This trapping code got moved around a bit in 15, can you paste the stack for that repro? A consistent repro we can run would be helpful, so I appreciate you trying, let us know if you do get it working.

The high level assumption here - we have some special event code for some events which don't bubble on some dom nodes. In this case it's the img in the header and likely a load (or error) event. It's possible the event is firing when componentWillUnmount is happening (which is in turn triggering a rerender and removing the img), but I would have thought that (a) this happens outside the current event loop and (b) the node is removed and event listener removed before this could happen. This unmount, setState handling code is pretty confusing though. Perhaps @spicyj knows what's up.
 I don't know offhand. A repro case would be very helpful ‚Äì you shouldn't ever see that error.
 @gaearon Sounds like this might be redux related, especially if it requires the redux devtools extension be installed.  Should we move this over to that repository?
 @jimfb It should be impossible to trigger this error in React, so it is a React bug even if all the repro cases use Redux.
 @spicyj Ah, yeah, probably true.  I have no idea what the redux devtools extension is doing, but it's entirely conceivable that they're reaching into internals, in which case, it would not be a React bug.  If the issue doesn't repro without the redux-devtools (which @Dattaya's comment seemed to imply) then that would seem to imply it might not be a React bug.  But yeah, that's why I asked @gaearon.
 Redux DevTools don‚Äôt touch React internals, it‚Äôs only userland code.
 I can‚Äôt vouch for the Chrome extension though.
Maybe @zalmoxisus has some insight into this.
 Yes, sorry for any ambiguity, I was referring to the chrome extension.
 @Dattaya Thanks for posting the repro case. Hopefully one of us can look into this.
 Apparently both `inst._rootNodeID` and `inst._nativeNode` are `null` the second time it is called while handling the button click. This is why `ReactDOMComponentTree` can‚Äôt find it.

Not sure what this means though.
 Minimal repro thusfar:

``` js
var callbacks = [];
function emitChange() {
  callbacks.forEach(c => c());
}

class App extends React.Component {
  constructor(props) {
    super(props);
    this.state = { showChild: true };
  }
  componentDidMount() {
    this.setState({ showChild: false });
  }
  render() {
    return (
      <div>
        <ForceUpdatesOnChange />
        {this.state.showChild && <EmitsChangeOnUnmount />}
      </div>
    );
  }
}

class EmitsChangeOnUnmount extends React.Component {
  componentWillUnmount() {
    emitChange();
  }
  render() {
    return null;
  }
}

class ForceUpdatesOnChange extends React.Component {
  componentDidMount() {
    this.onChange = () => this.forceUpdate();
    this.onChange()
    callbacks.push(this.onChange);
  }
  componentWillUnmount() {
    callbacks = callbacks.filter(c => c !== this.onChange)
  }
  render() {
    return (
      <div key={Math.random()} onClick={function(){}} />
    )
  }
}

ReactDOM.render(<App />, document.getElementById('container'));
```

Thanks Dan for helping reduce!
 #2410 is a known problem which _might_ cause this but otherwise that should only happen if something throws an exception (and maybe not even then).
 @spicyj No, this is almost certainly caused by a variant of https://github.com/facebook/react/issues/3298
 But it's not an exact duplicate, so I don't want to close this one out as a duplicate.  In this case, it's something to the effect of: redux setting state on a component after/while react-router is unmounting it (or its parent).  But it's a very similar phenomenon that occurs due to an unmount higher up in the tree within the same transaction.
 Note: this is exactly the same as https://github.com/facebook/react/issues/6538. The message depends on what you render (https://github.com/facebook/react/issues/6538#issuecomment-213534947), but the underlying issue is explained in https://github.com/facebook/react/issues/6538#issuecomment-213537928.
  Thank you for reporting! I believe this to be a duplicate of #6142 so I‚Äôm closing. Feel free to join the discussion there or in #6149.
  Would you mind creating a JSFiddle reproducing the issue? It‚Äôs preferable that you use React 15 RC2 to verify it happens with the latest code. Thank you for reporting!
 Just to clarify - is this a new issue with 15 or was this happening in 14 as well?

Edit: I tried myself - looks like this isn't new to 15 so we'll have to come back to this and see if there's anything we can possibly do after we ship. Thanks for filing and the repro!
 This type of thing is literally the worst.  Engineers try to be "helpful" by automatically trimming the value, and end up making life more difficult.  This is why code should only ever do the trivially simple thing and just pass values along.

Ironically, if we fired an onChange when the user hit the space bar, all controlled email inputs would necessarily strip spaces (even if that wasn't the desired behavior).

I suppose we could try to track keystrokes and derive our own backing state, but @sebmarkbage said that supporting i18n makes the custom handling of text input incredibly difficult (borderline impossible) to get right.

I'm almost tempted to say this is a "won't fix", unless someone has an idea for what we could reasonably do in this situation.
 The browser DOM node returns a value that does not accurately reflect what the user sees.  That's what I was complaining about.  It's a gotcha in the spec that propagates to become a gotcha in the browser that propagates to become a gotcha in the library.

@marcolanaro When I said "Engineers trying to be 'helpful'", I was referring to the engineers who wrote the W3C spec, not to you and other users of React.  My commentary was intended to apply to infrastructure code (browsers/react/etc) and not to application code.  Sorry for the ambiguity.
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 This seems reasonable, CLA required (https://code.facebook.com/cla).
 Thanks, looks like the CLA bot didn't followup correctly. I can see that the CLA is signed.
  Keeping the translations up-to-date is an ongoing effort rather than an actionable issue. We don't need a separate issue to track each language, and we are tracking improved translation management as #5810, so I'm going to close out the issue. Feel free to submit a pull request for the translation mentioned above.
  ```
<ReactTransitionGroup>Welcome to React</ReactTransitionGroup>
```

(http://react.jsbin.com/towaxoqaya/edit?html,js,output)

throws

> Invariant Violation: Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: undefined. Check the render method of `ReactTransitionGroup`.

Not sure what this _should_ do, but at the very least the error message is terrible.
 @devinargenta Thanks for the comment. This is still a case that ReactTransitionGroup shouldn't error on (or at least, should give a clear error for). TransitionGroup and CSSTransitionGroup are related but different. (Sorry if the terse bug report was confusing ‚Äì when reporting bugs on projects I work on I often don't explain myself fully for someone without context and use the issue almost as notes for myself.)
  I'm going to revert this in #6741 ‚Äì sorry I'm just seeing this now. ReactErrorUtils is a generic util and shouldn't know about SyntheticDragEvent, a DOM-specific concept. We should find a different fix for this.
  This documents a somewhat unobvious solution to #5408.

Reviewers: @zpao 
 @gaearon updated the pull request.
 @gaearon updated the pull request.
  I haven‚Äôt thought about this idea in detail so it might not be a good one. A few questions worth answering:
- What happens if user closes over some prop or state in their `render` implementation? Do we handle that correctly? Do we need testing this?
- Is this the case where we give more control than is necessary? Is it useful for any other cases than a single child? If not, could providing an opt-in `onlyChild` prop be a simpler solution? Or are there other use cases for transforming the received children?
 I thought about it some more, and it appears that this is unnecessary. Your use case can be accomplished by passing a custom component as `component`. That custom component would return its first child directly. In other words, the key insight is that `component` doesn‚Äôt have to be a string, and composite components can return their children directly (as long as it‚Äôs only a single child).

Example:

``` js
// Note: returning null from functions requires React 15.
// If you use React 0.14, you can return <span /> instead or make this a class.
function FirstChild({ children }) {
  return React.Children.toArray(children)[0] || null;
}

// Usage inside components:
return (
  <CSSTransitionGroup
    component={FirstChild}
    transitionEnterTimeout={250}
    transitionLeaveTimeout={250}
    transitionName="example"
  >
    {condition ? <MyComponent /> : null}
  </CSSTransitionGroup>
)
```

I tested this with 15, and it doesn‚Äôt seem to generate spans. I‚Äôm closing but please let me know if this approach doesn‚Äôt work for you for some reason. Cheers!
 Yeah I‚Äôd say it‚Äôs a neat find and I haven‚Äôt seen it mentioned before. I‚Äôll try to add this to the docs.
Thanks for a fruitful discussion!
 > I ran into problems when we're replacing the child with a new child

In this case you can‚Äôt use this approach. While you‚Äôre technically passing a single child, **two children (one entering and one leaving) are being rendered by the `TransitionGroup` at the same time**.

The workaround suggested here is only possible when there is at most a single element rendered to the DOM. For example, this is the case for a collapsible panel with one element that switches between zero and one elements.

However this is _not_ the case for an image carousel or a route change because it physically displays two children at the same time. In this case `TransitionGroup` _has to_ wrap them with some kind of common parent element because React components can‚Äôt just return a fragment (#2127).

That said you still have full control over that wrapper. You can make it any type of DOM component and give it any props.

Hopefully #6363 should explain this better.
  Hey, thanks for the PR!

> P.S. Does anybody know how to properly mock getEventCharCode function for SyntheticKeyboardEvent?

I searched the codebase for ‚Äúmock‚Äù and found this:

https://github.com/facebook/react/blob/a2780212ae72882e7fd2ee4e29607cb6721b50e1/src/renderers/dom/shared/__tests__/ReactDOMComponent-test.js#L1046-L1051

It‚Äôs probably the technique you are looking for!
 @cbrwizard updated the pull request.
 @cbrwizard updated the pull request.
 Thanks!
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 This is actually correct as is - the tutorial is designed to be run with one of the servers in the tutorial repository. These are all essentially API servers where `api/comments` will return json.
 @zpao Might as well add the additional `.json`, right?  It doesn't hurt anything and it does add to clarity?  And makes it compatible with any server that won't automatically serve up a file without the suffix.
 My personal preference is to fix everywhere to have the `.json` suffix.  I don't see why a user should need to do anything more than drop the tutorial files into a simple http server (for the purposes of the tutorial).  But let's wait and see what @zpao thinks of that before we invest any further work one way or the other.
 @jimfb no, while the server does essentially just load the file and send that out, it's specifically meant to simulate a real-life API server. We changed to this from serving the file directly since we needed to handle POST and it got confusing. Consistently having an API is cleaner and less confusing in the long run.
  Can you please provide a JSBin replicating the issue?
 Thanks for taking time to investigate!
  @pavelkornev updated the pull request.
 @pavelkornev updated the pull request.
 Thanks for the PR!

Proptypes are mostly legacy and in maintenance mode, having been replaced by tools like Flow, so we've generally shied away from adding new features/functions/api. There is no reason that this functionality needs to be tied into React, so my intuition is that the best strategy here is to just create a third-party library that helps users define deprecated proptypes, and post that on github.
 Thanks to everyone in the discussion.

I‚Äôd say this will better live in user land, at least initially.
As @Aweary wrote above, he made a package for it: https://github.com/Aweary/react-is-deprecated.

If the package proves to be popular enough we can reconsider adding this to the core.
For now I‚Äôll close this PR but I‚Äôm very grateful to @pavelkornev for starting the discussion.
  This makes it invisible to test frameworks which solves #5292 and #6194.

Reviewers: @sebmarkbage 
 This is the hottest path in React. Worried about perf. We can do it in DEV but a bit risky if someone uses spread. However I thought this worked at one point. Is it because we didn't attach owner in shallow renderer?
 > I believe this will break IE8 compatibility.

I don‚Äôt think so. Still using `canDefineProperty` and falling back to setting it directly when we can‚Äôt. And this is identical to how we already do this with `element._source`, for example.

> However I thought this worked at one point. Is it because we didn't attach owner in shallow renderer?

Asserting on `render` output for classes works fine as they normally don‚Äôt get the `_owner` in shallow rendering. We have problems in two cases:
- Testing class components that generate elements during the constructor (#5292)
- Testing functional components (#6194)

The reason these two case are problematic is the following. Normally, for composites, during shallow rendering we [replace `_renderValidatedComponent` with `_renderValidatedComponentWithoutOwnerOrContext`](https://github.com/facebook/react/blob/a2780212ae72882e7fd2ee4e29607cb6721b50e1/src/test/ReactTestUtils.js#L406-L408). This doesn‚Äôt seem very nice encapsulation-wise but I guess it does the job.

However, functional components create element during the initial constructor call. Same is true for #5292 where elements end up being created in the constructor. The constructor call is inlined in `mountComponent` which always sets `ReactCurrentOwner`, and there is no corresponding `_callConstructorWithoutOwnerOrContext`. We can introduce it and use a similar pattern as with `_renderValidatedComponent` if we want to. Would you like to go down that road instead?
 Setting owner during the constructor was always sketchy. I guess it was for some error message. It should use a different flag. I think I have PR for it somewhere.

Creating elements in the constructor is sketchy too because you might be tempted to mutate it which would break with automatic bailouts for elements.
 > Setting owner during the constructor was always sketchy.

It was added with the first stateless component commit: 5a7bd964b4265a0e0e87e453fa0d1a4ccb604fe1. If we remove the owner completely, are we also going to remove information about it from ReactPerf? It‚Äôs quite useful as the aggregation key in the inclusive summary.
 I believe the reason it was added was because in 0.14 we didn't know if something would be a stateless component or not before calling it. With 0.15 we could remove it since we have the isReactComponent check.

We had an idea to infer ownership based on source code location for debugging purposes. The babel plugin that adds source file and line information would let us do that. Not sure if that would be solid enough for ReactPerf.
 > We had an idea to infer ownership based on source code location for debugging purposes. The babel plugin that adds source file and line information would let us do that. Not sure if that would be solid enough for ReactPerf.

Ideally we‚Äôd like to know the name of closest enclosing class or `createClass()` expression but it‚Äôs doable with Babel.
 Superseded by #6362. @sebmarkbage Mind taking a look?
  We have previously considered bundling React into a flat file without `require`s and a module map. 

For example, #4230 is a (somewhat outdated) implementation of this.
[Rollup](https://github.com/rollup/rollup) is another tool that, if I‚Äôm not mistaken, bundles modules in the same way.

Do we really want to do this? What problems does this solve for us? If we want to try, what is the plan, and how do we evaluate whether the switch is worth it?
 Relying on React internals was never supported in the first place. There are edge cases where this is still necessary (renderers) but presumably we would come up with public APIs or unstable exported modules for them. 
 We should do this and taking it a step further, we will want to consider using our bundled file in npm (with a single entry point that does the dev check, requiring & rexporting either the min or dev version). Downside of that is you don't get the shared deps for everything that comes from fbjs (and anything else we might depend on in the future). But as long as those deps are stateless then we're ok. The other piece to figure out is the bridges between packages like react-dom, react-native, etc and making sure the right bits (be they public APIs or unstable ones) are exposed.
  As per PR review meeting, looks reasonable, tentatively accepting for 15.x.  cc @spicyj for a sanity check.
 I think that as you call out @nhunzaker, we don't need a DOM dependency here ‚Äì so it's better to not have one. I also think it might not be guaranteed that `_nativeNode` is set at this point when reviving server-rendered markup so I'd rather leave it as-is.
 @nhunzaker updated the pull request.
  # This "good first bug" is taken by @YongPilMoon. Don't work on it unless that's you!

This has been discussed a few times before but I don‚Äôt think there was any conclusion, and PRs intending to solve the issue were not merged for various reasons.

I would like to close those PRs as outdated, and reboot the discussion about this.
Performance considered, the conclusion from @sebmarkbage and @syranide seems to be:

> We should consider not allowing conflicting style rules at all.

‚Äî https://github.com/facebook/react/pull/2013#issuecomment-57338177

> IMHO, all things considered it's better to just disallow overlapping and warn in dev.

‚Äî https://github.com/facebook/react/pull/4661#issuecomment-132996649

Radium by @ianobermiller came to the same conclusion in https://github.com/FormidableLabs/radium/issues/95 but there was some backlash afterwards. React Native seems to allow style expansions but only for a few attributes (e.g. `margin` and `padding`, but not `border`).

I‚Äôm closing old pull requests about this, and creating this issue to track implementation of the behavior we seem to agree upon: we should warn in `__DEV__` when `border` and `borderBottom` are used at the same time. We can discuss more specifics (should either be ignored? should we allow a few whitelisted properties but warn for others?) in this issue.

As a migration strategy, we can suggest people to use something like https://github.com/ActionIQ/style-builder if they really need those shortcuts. It‚Äôs also something we‚Äôll need to decide upon when implementing integrated styling.

---

Related issues:
- #2231
- #2407
- #5030
- https://github.com/FormidableLabs/radium/issues/95

Related PRs:
- #2013
- #4661
 > Question. Is the intent of this issue to address only the analysis of individual style objects or is there also a desire to analyze and warn about possible collisions of properties that are conditionally applied?

Not sure I understand the question, can you elaborate?
 Ah, good point. I‚Äôd probably warn only if we _know_ the styles overlap but I‚Äôm not sure how easy it is to tell. I haven‚Äôt thought about it much and I don‚Äôt have a good solution.
 @gaearon An alternate solution that I like better is to use csstext as per https://github.com/facebook/react/issues/5397, which IIRC cleanly solves a superset of these issues.
  [`isUnitlessNumber` checks for different browser prefixes](https://github.com/facebook/react/blob/dcd092560da72d6435b4c941ee7bf58b6d648903/src/renderers/dom/shared/CSSProperty.js#L66-L70) but this doesn‚Äôt affect the actual used style name. Putting a `console.log()` there and seeing invalid property names is expected and doesn‚Äôt mean those invalid property names are actually being used anywhere other than those checks.

I‚Äôm closing because this appears to work as designed: we do extra checks just to be careful and to avoid hardcoding every possible prefix permutation. **If you see incorrect behavior for specific properties**, please provide a JSFiddle reproducing it, and we will be happy to reopen and inspect it.

But if you‚Äôre just worried that `isUnitlessNumber` performs tests on invalid names‚Äîthat‚Äôs just a tradeoff that lets us avoid keeping a much larger whitelist. I hope this explains it, but if not, or if I missed something or misunderstood you, please let me know!
  Thanks for the idea! As I get closer to #6335 I‚Äôll keep your suggestion in mind and maybe make it a little more personal.
  @Sumei1009 updated the pull request.
 Can you please rebase so it merges cleanly, and fix the lint issues? You can run `npm run lint` locally and see why ESLint is failing. Thanks!
 Ping @Sumei1009
  You are mutating the default prop that was passed in.  The line `this.props.nested.prop = this.props.parse.nested.prop;` is illegal.

This is a usage question. We use github to track bugs in the react core, rather than usage questions. A more appropriate place for usage questions is StackOverflow, so I'm going to close out this issue, but feel free to continue the conversation on this thread or move the discussion over to StackOverflow.
 :+1: Thanks! We don‚Äôt have the bandwidth to answer all questions here so StackOverflow is a better place for this.
  Yes, these modules only work when packaged with the `react` module from npm (it does this because we need access to private APIs). If you want to use the prepackaged React and an addon, then we recommend use use ReactWithAddons and map react-addons-css-transition-group to React.addons.CSSTransitionGroup.
  Yes, this is part of the change to generate elements instead of a markup string. It turns out that `!important` would appear to work before but it only worked for first render, never subsequent renders which would set `node.style.display` directly (where `!important` is ignored). As a result of the inconsitent behavior, this was never a supported feature. Currently you'll need to use CSS (or some inline style library that uses CSS) if you want to use `!important`
  Side note: there _are_ valid reasons to use indexes as keys but those are rare cases. For example, if you implement a virtualized list with limited number of real items, you actually _want_ them to be reused.
  This creates a new `react-native-renderer` package which contains the React integration for React Native. (Although in reality the files live in the `react` package just like for `react-dom` because builds.)

I moved the most core files over but I still want to see how we can further minimize the contract. The individual commits show the process.

Currently everything in `src/renderers/native/ReactNative/__mocks__/` have to required from the platform.

This also contains some patches to make this compatible with 15.0. As well as enabling spread properties.

I still need to run further test in the React Native repo to ensure everything works as expected.

We might want to consider this as part of 15.0 to avoid publishing a 15.1 immediately after since we'd have to do a minor bump for this stuff.
 Once we have a more stable contract for renderers we might do that but currently it is unstable. It is too hard to iterate on the internals and keep them in sync when they're in separate repos. It is also too easy to create massive cross dependencies.

The idea isn't that these files will remain RN specific but to make more of this stuff shared and narrow the external contract.
 @sebmarkbage updated the pull request.
 > We might want to consider this as part of 15.0

2 RCs deep is not really the time to drop this‚Ä¶

Is there a less aggressive thing we can do to make sure RN works with 15 and do something like this for 15.1? Also, looks like this is purely new stuff and doesn't touch any of our existing code that would be in the React package. Could we perhaps just ship React 15 without needing this and then clean this up and ship the new package, like next week.

Also also, how is this going to affect our internal syncing?
 I'm still working on compatibility with RN. There are a lot of things broken with 15 in RN. That's exactly why we need to fix this since we've gone way too long without making it RN compatible.

Not sure yet if that would need a new release of `react` to fix it regardless.

Ideally we should only have to release a new version of `react-native-renderer` to do these fixes, but we can't because everything still actually lives in `react` and we don't have flat bundles that copies the relevant shared code to each renderer package. They still share the same modules.
 > we can't because everything still actually lives in `react`

Oh right‚Ä¶ that.
 > I'm still working on compatibility with RN. There are a lot of things broken with 15 in RN

Honestly, that makes me want to push to 15.1 even more. Do you expect any core API changes to accommodate RN? As long as our core API doesn't change and we wouldn't need to ship a v16, I'm leaning strongly towards just saying we get 15.0 out and do what ever else we need in 15.1, even if that happens relatively soon after. We've been sitting on this release for too long already and I don't really want to push a couple more weeks & do more RCs. That's the nice thing about having these major version numbers :)
 > Also also, how is this going to affect our internal syncing?

We might need to stub out the missing files to satisfy the module systems but other than that it shouldn't affect us. We can just pull in the files that won't be required.

> As long as our core API doesn't change and we wouldn't need to ship a v16

I don't think we'll need to make it 16. We can't make it a patch though.

The minor could potentially break other renderers like React ART since, again, they still share the same internal modules. If that's the case it is arguable that it would need to be a v16 release.
 @sebmarkbage updated the pull request.
 @sebmarkbage updated the pull request.
 @sebmarkbage updated the pull request.
 @sebmarkbage updated the pull request.
 This now works with RN. Haven't tested the Flow stuff yet. That's next. I believe we can manually release this as a separate package by copying files over to the react-native-renderer package.
 All looks good I think.
 @sebmarkbage updated the pull request.
 @sebmarkbage updated the pull request.
 @sebmarkbage updated the pull request.
 @sebmarkbage updated the pull request.
 @sebmarkbage updated the pull request.
 @sebmarkbage updated the pull request.
 @sebmarkbage updated the pull request.
  It's been great for us at FB but not so much for everybody else. It's long been a goal to get rid of this and just use common js / es6 modules but haven't put the time in yet.

This change will require changes internally at FB and probably some work with fbjs so I'm going to assign this to myself.
 > I've found it really helpful when searching for a component in the repo (since there are no relative import paths).

If we remove `providesModule` we‚Äôll use relative paths like everybody else does.
 Unknown until we do it. Ideally we would expose everything that a library like Enzyme would need. This impacts our addons-\* packages as well.
 `React.__SECRET_UTILS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED_UNLESS_YOU_ARE_ENZYME_IN_WHICH_CASE_ITS_FINE`.
  Historically we haven‚Äôt been very good at explaining how to contribute to React.
We have a [small guide](https://github.com/facebook/react/blob/master/CONTRIBUTING.md) but it doesn‚Äôt offer crucial information about:
- Our build process and `providesModule`.
- Design constraints that guide what gets in and what doesn‚Äôt.
- Conventions like `invariant`, `warning`, `__DEV__`, and infra around them.
- How we introduce breaking changes and deprecations.
- How syncing with React Native and Facebook website affects contributions.
- Basic directory organization, what can or can‚Äôt go in either directory.
- Unfortunate decisions in the codebase that we want to get away from.
- What is being actively worked on, and why.
- An internal glossary:
  - Elements
  - Public instances
  - Internal instances
  - Composite components
  - Native components
  - Reconciliation
  - Transactions
  - Update queue
  - Synthetic events

What do you think? I‚Äôm especially interested in hearing from people who considered contributing to React but were turned away by the internal complexity.
 Some incoherent notes I made earlier about design philosophy:
- no global config (ex: events, dangerouslySetInnerHTML)
- abstractions that scale (no .reactTarget)
- benchmarking the right thing
- don't put things in the core if they don't need to be
- but we're moving Flux into the core (maybe)
- simple > easy? (e.g., cursor in controlled components)
- server rendering vs service workers
- optimize for readability/greppability (lifecycle names)
- APIs that accept too-liberal data (e.g., nulls) are not helpful in the long run
 - Things that break encapsulation or potentially leaking implementation details across levels of components.
- Favor modularity and ability to build it outside React (e.g. as a component) - unless it is something that we expect most apps to have to build. E.g. component state.
 Commonly requested: an explanation of what happens when you call `setState()`, from start to end. Granted, this can change between releases, but a high level overview of the process would improve contributors‚Äô understanding quite a bit.
 In what ways is React Native more modern? Lots of it builds on top of React so is a little higher-level but otherwise I tend to think the coding styles are similar.
 I agree with @jide that internal reliance on mixins (e.g. `ReactMultiChild`) and injection are confusing. I don‚Äôt want this thread to become a place to bikeshed on different internal complexities but we definitely want to document the high level ideas behind the code organization and how we split module responsibilities, as well as some historical context behind that.
 @nhunzaker #4595 has some related discussion. Nothing decided yet.
  Yeah, @Aweary is exactly correct.  JSX is just transformed into `React.createElement`.  This is done by Babel, not by React.  Babel makes it easy for you to write your own transforms, so you can do something like this for emmet in userland without any changes to React.  If the transform becomes popular enough, it might even become a babel preset that people could enable.  Regardless, it's not something that we should track in the React repository.
  @kentcdodds updated the pull request.
 Thanks @kentcdodds!
  Conceptually, I think it's great to document the React contribution process!

I have a few concerns with the specifics; the biggest concern is that the content is not tailored to how we do things in the React repository.  For instance, the flow you describe in [how-top-update-a-pull-request](https://egghead.io/lessons/javascript-how-to-update-a-pull-request-on-github?series=how-to-contribute-to-an-open-source-project-on-github) is counterproductive for users because it discusses/demonstrates things that really don't apply to our repository (git hooks, will confuse the user who would now be expecting them) and does NOT demonstrate the most important thing for updating a React pull request (`git commit --amend` and `git push -f`) because we request that all PRs be squashed into a single commit and that's what generally trips people up when updating their PRs.  There are a bunch of confusing discrepancies like this throughout the lesson plan.  It is useful as a general-purpose lesson plan for beginners, but isn't particularly useful to anyone submitting a change for the React core (core-contributors generally already know how github works, and are looking for the info that is React-specific).
 I think this is fine and definitely better than nothing. We can always change it if we feel like we need more or different content. Many people have made PRs before so they are probably not going to go through the course. And as we know, very few people actually load contributing docs anyway. For those that do and that decide to watch, nothing learned in the course will be wrong per se (even if it doesn't necessarily apply) and will only help people in their future uses of git & github.
  Fixes #6328
 > I think that this would supersede and close #6022, correct?

Some of it, yes. This doesn't do anything about the current owner bit though which would be needed to get to true separation.
 Nit: maybe call it something like `ReactUMDEntry`? I could see this causing some confusion as people using Browserify won‚Äôt actually be using this module. Unlikely to cause any harm though.
 Nobody should be referring to any of our module names ever so I don't think it's a big deal, but that might be a better name... will try it on for size (or something similar that's a bit more generic than "Browserify").
 @zpao updated the pull request.
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
  We do output a warning:

> Warning: MyComponent(...): A valid React element (or null) must be returned. You may have returned undefined, an array or some other invalid object.

We detect that the function didn't return a valid return type, and print the warning.  There really isn't much more you could detect in this case.

If you didn't get the warning, please verify that you are using the dev build of React (instead of the production build).  If there are further issues, please provide a simple jsfiddle that demonstrates the issue.
 Production vs. Dev builds refer to the two different build configurations.  You should be using the dev build when developing on your devserver, and the prod build when you package your app and deploy to your production servers.  For example, go to the [Downloads page](http://facebook.github.io/react/downloads.html) and notice we have both the development and production builds available.

The RC2 is already published (http://facebook.github.io/react/blog/2016/03/16/react-v15-rc2.html).  We will likely do another RC and then a final release of v15.
  Reproed. This is either a React bug or a Firefox bug.
  Can you please narrow it down to a reproducible test case and show the relevant code?
This is definitely not a bug in React as it has no control over how `this` is handled.

One relevant result I discovered by [searching](https://www.google.co.uk/search?q=%22ReferenceError%3A+this+is+not+defined%22) for the error message you posted is [here](http://stackoverflow.com/questions/31067368/javascript-es6-class-extend-without-super). Apparently this is the [intended ES2015 behavior](https://github.com/nodejs/node/issues/1723). Most likely you have a class that `extends` another class (such as `Component`) but does not call `super()`.

So if you have something like

``` js
class Blog extends Component {
  constructor() {
    this.state = { something: 42 };
  }
}
```

you need to change it to call the base constructor with `super()`:

``` js
class Blog extends Component {
  constructor(props) {
    super(props);
    this.state = { something: 42 };
  }
}
```

I‚Äôm closing as this cannot be caused by React itself. I hope this helps!
 How are you using class properties on Node? Are you also using Babel but without the class transform?
  I don‚Äôt think ReactPerf would give any results here: the author already nailed it down to a very specific issue, which is selection restoration. I don‚Äôt have a good knowledge of that part of the codebase but I wonder if we can opt out of that if there was no selection in the first place, or if we can make it faster.
 Your initial flame graph showed `ReactInputSelection.hasSelectionCapabilities` taking ~5ms, which was a red flag because if you look at the implementation of that function, you will see that all it does is read a couple of short string properties and do a couple equality checks.

I wonder if reading properties off a flash object requires doing some expensive IPC / context switches.  We could potentially special case flash, but flash is dying anyway so I'm not sure it's worth the headache.  We would probably take a PR for this, but probably wouldn't do it ourselves because there are higher priority issues.
 I'm going to close this out, since I don't think it's something that we would invest in.  We would probably take a PR for this if anyone cares to implement it.
  I can't reproduce this (or maybe am misunderstanding what you're saying). https://jsfiddle.net/rkc64ybp/ is showing that the node is unchecked in the DOM. You might run into issues if you use `e.preventDefault()` but I don't see that in your code here.
 Ah, I see. The attribute is set but the property isn't. That will be solved in v15 where we will remove the attribute instead of just setting the property to false. See https://jsfiddle.net/rkc64ybp/1/ (same code, just with `hasAttribute` calls and upgraded to 15, I saw the issue with 0.14)
 That's a good question‚Ä¶ @syranide - was there any discussion about that?
 Once again, I'll repeat that it does not make sense to talk about the native behavior here. That is, HTML does not have a concept of going from

```
<input type="checkbox">
```

to

```
<input type="checkbox" checked>
```

We created this concept. In HTML, you can do a property assignment (`.value =`), attribute assignment (`.setAttribute`), or you can blow away the entire thing and replace the whole node with `.innerHTML`. You can also have the user click it.

We can decide for any of these to be the behavior that React matches. None of them is the objectively correct "native behavior" so it's misleading to talk as if that were the case.

It seems like setting the attribute is least confusing for people in most cases (so that both `[checked]` and `:checked` would work), but it's still not clear whether that's best, especially with forms.
 Why are you "meant to" update it with the property? `.setAttribute()` is an equal here.
 Conceptually, upon every change, we throw away the entire page and rerender from scratch.  Ideally, the output of an initial render should be identical to the output of an initial render followed by an update render, assuming the final state is the same.
  > I've been working on a small tool that relies on the callbacks being called, and I found out that in some cases that never happened: the state was set, the callback was pushed into the queue, then the component was unmounted and the callback was lost and never called.

Could it be that you were calling `setState` from `componentWillMount`? I believe there‚Äôs a known (albeit undocumented and definitely not obvious) issue there:

https://github.com/facebook/react/blob/1e8156143a6389e2235fa16536bb9161d26a23ce/src/renderers/shared/reconciler/ReactUpdateQueue.js#L140-L144
 The issue I was referring to is #1740 and apparently it was fixed. Would be great to verify. If you can do that, and/or provide a test case reproducing the issue, that would be hugely helpful.
 Thanks for working it out. I realize now that I read your description without paying enough attention.
I missed this part:

> I've been working on a small tool that relies on the callbacks being called, and I found out that in some cases that never happened: the state was set, the callback was pushed into the queue, **then the component was unmounted** and the callback was lost and never called.

IMO this is expected behavior: `setState` callback fires after changes have been flushed to the DOM. Since they were never flushed, it was never called. However we should probably communicate this better in the documentation.

@spicyj Is my interpretation correct?
 Yes, I think that the setState callback fires after the rerender (just after componentDidUpdate) and shouldn't fire if the component unmounts first.
  Ok, glad you found a solution that works for you!  Let's keep usage questions on StackOverflow.

Proptypes are legacy/maintenance mode, so this is probably not something we'd be adding to React.
  > No description provided.

Nothing actionable here.
  Travis is failing because of lint warnings, you can run `npm run lint` to find the problems.

More generally, however, I'm worried about several correctness issues here.  For example, `validateExplicitKey` appears to be ignoring `addenda.offendingElement`.  We are going to need a bunch of unit tests to verify the expected/desired behavior here.
 Ping @PiereDome
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thanks for this but I'm going to close out and manage myself. I just pushed some more commits to the branch so this will get wiped out in a few minutes. I'll keep an eye out for that commit to build and push the revert manually. I'm looking into fixing this more permanently because this is crazy.
  üëç Nice find, thanks!
  I think this is intentional and normalized across the browsers. Please see https://facebook.github.io/react/docs/dom-differences.html:

> The `onChange` event behaves as you would expect it to: whenever a form field is changed this event is fired rather than inconsistently on blur. We intentionally break from existing browser behavior because `onChange` is a misnomer for its behavior and React relies on this event to react to user input in real time. 

See also https://facebook.github.io/react/docs/forms.html. 
  @cbrwizard updated the pull request.
 Thanks @cbrwizard!
 @cbrwizard updated the pull request.
  Would you like to investigate why this happens?
 Ah, right. The problem is you bind only the first argument, the second one becomes the event from the event handler. As a result `setState` thinks it‚Äôs the callback argument, and fails. You can fix this by using `setState.bind(this, { ... }, null)` so the second argument is ignored. 

We can probably provide a better invariant message when we receive an event instead of the callback because `bind()` is a very common use case where people encounter this.
 I would like to reopen until we provide a better error message or decide it is not necessary. 
 It appears that a better error message was added in #5193.
However I would still argue that 

> Uncaught Invariant Violation: enqueueCallback(...): You called `setProps`, `replaceProps`, `setState`, `replaceState`, or `forceUpdate` with a callback of type object. A function is expected

is not much better for this particular case, and we can explain the problem much more specifically.
 I think this is a good argument for having pages on our site for each invariant / warning where we can go much more in depth than we can in a string. We can show specific cases like this where we show common "bad" code that might be triggering it. Adding all the code to React that does all of the possible debugging gets tricky. Especially in a case like there where you could probably just do an `instanceof SyntheticEvent` check, but that breaks the boundary between the core and DOM, so you would need to go about it in a roundabout way.
 Put up #6310 to address this.
 I will close this as we can continue the discussion in #6310.
  @maherbeg updated the pull request.
 Thanks @maherbeg!
  I can reproduce this on IE11.
Have you looked into why this might be happening?
 Oh, indeed. Then I‚Äôm closing this as a duplicate.
  @qerub updated the pull request.
 Thanks!
  Fix for #6275 - Add warning for onFocusIn and onFocusOut.
 Sorry for the commit noise.  It's really only 2 files changed. Had another proposed fix in my master and it was unintentionally pulled into my branch.
 @troydemonbreun updated the pull request.
 @sarbbottam Thanks, for some reason Github Desktop is not updating my git config, even though I updated it in the UI.  I'll go to shell to check it.
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 @ajgreenb updated the pull request.
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 Thanks for the PR!

Proptypes are mostly legacy and in maintenance mode, having been replaced by tools like Flow, so we've generally shied away from adding new features/functions/api.  There is no reason that this functionality needs to be tied into React, so my intuition is that the best strategy here is to just create a third-party library that helps users build custom proptypes, and post that on github.
  I‚Äôm closing as this most likely is a duplicate of #6246 which has been fixed in RC2.
If you still experience the problem in RC2 please let us know and I will reopen.
Thank you for reporting!
  @cody is correct.

The problem is that Webpack fails to parse the arrow function in the compiled code and doesn‚Äôt replace `require()` with its module resolution mechanism.

You can see this by inspecting the compiled code:

``` js
    var Component = React.createClass({
      displayName: 'Component',

      render: function () {
        return React.createElement(
          'div',
          null,
          React.createElement(
            'h1',
            null,
            'Component'
          ),
          React.createElement('img', { src: __webpack_require__(160) }) // <--- note: Webpack recognized this
        );
      }
    });

    var StatelessFunctionalComponent = props => React.createElement(
      'div',
      null,
      React.createElement(
        'h1',
        null,
        'Stateless Functional Component'
      ),
      React.createElement('img', { src: require('./test.png') }) // <---- note: just require
    );
```

It‚Äôs possible that Webpack 2 beta doesn‚Äôt have this problem but I haven‚Äôt checked. In either case it‚Äôs likely that **if you want your code to run in most browsers, you _do_ want to compile arrow functions with Babel**. Adding `es2015` preset to your Babel configuration should solve this problem.

I am closing because it is not related to React.
  Does [`React.isValidElement()`](https://facebook.github.io/react/docs/top-level-api.html#react.isvalidelement) help? This should be it. Let me know if I missed something.
  @jontewks updated the pull request.
 @jontewks updated the pull request.
 Seems fine to me, minor nit for the error message and then I think we can take this.
 Looks good, thanks @jontewks!
  You need to set your charset to utf-8 in the meta tag on your html doc. That's should be it.
  I think this is the same as #4302 so I will close in its favor. This is definitely something we plan to improve for testing purposes, and gradually moving our warnings to the new devtools API in #5306 should make this possible.
  Yeah, this is something we are considering. You can help, too: https://github.com/facebook/react/issues/3218

On an unrelated note, I some anti-patterns in your code. While this not relevant to this issue I figure I‚Äôd mention them:

1) Deriving state based on props is usually an anti-pattern. It‚Äôs better to move state management to the parent component and provide a callback to the child as a prop.
2) Using `forceUpdate()` is also an anti-pattern. React will automatically re-render your component when you call `setState()` in it or its parent.
3) Assinging something directly to anything inside `this.state` is an anti-pattern. I suggest you to create a new object based on the old one, and call `setState()` to update the relevant part of the state with a reference to the new object. Treating state as immutable lets you add powerful performance optimizations later because it is possible to compare which objects have changed by comparing their references with the previous values.
4) There is never a reason to assign `this.props`. Props are immutable. React will update the reference to `this.props` after `componentWillReceiveProps()` exits. Don‚Äôt do this manually.

I recommend you to read through [Thinking in React](https://facebook.github.io/react/docs/thinking-in-react.html) which covers top-down data flow and state ownership. While React provides escape hatches that you are using, they are absolutely not the primary way to build React apps, and you might have problems later on unless you got back to these topics and get familiar with them. 

I hope that this is helpful. Cheers!
 You can use something like [React immutability helpers](https://facebook.github.io/react/docs/update.html) for working plain objects or Immutable.js which provides API for deep updates.

In general if your state is very complicated you might want to consider moving its handling out of the component with a library like http://redux.js.org (disclaimer: I wrote it). It lets you describe changes in state as pure functions that call each other, and ‚Äúreducer composition‚Äù pattern used there corresponds to the deep updates you want to implement.

Finally, even if you mutate the state directly, you still don‚Äôt need to reassign the props. The correct way to go with mutation is to perform it in the component that owns the state, and to call `setState` in it. Then the change will propagate down to any children‚Äîyou don‚Äôt need to do anything with props to make it happen. 
  What is the exact line of code throwing the error? Can you show the call stack please?
 Debugging experience in IE8 is truly abysmal. :smile: 

I was able to get it to break at the actual error site after removing a few `try-catch`es from React. The line in question is here:

<img width="661" alt="screen shot 2016-03-20 at 20 55 35" src="https://cloud.githubusercontent.com/assets/810438/13907091/3a7d7488-eede-11e5-8a6e-f7b3a6a6b218.png">

As you can see it is not related to React. Apparently [`isEqualNode()` is only supported since IE9](https://msdn.microsoft.com/en-us/library/ff975128%28v=vs.85%29.aspx). See also information on [quirksmode](http://quirksmode.org/dom/core/) about this.

The usage is [located in react-select code](https://github.com/JedWatson/react-select/blob/master/src/Select.js#L313) so you may ask them to fix it. I‚Äôm not sure why it is using `isEqualNode` rather than just `===` comparison there.

In any case, this is not a bug in React, so I will close this.
  Ah, nice find. The issue is that `elem` in that code is actually `window` (or `form`) at that point and thanks to the magic of named inputs as properties on `window`, this is screwing up. I wonder if there are other cases like this‚Ä¶
 @zpao That was my first thought too, in which case we could special-case window, but I don't think that's quite right.

```
ReactDOM.render(
  <form><input name='nodeName' /><input type='submit' /></form>,
  document.getElementById('container')
);
console.log(window.nodeName);
```

I think the issue occurs as we traverse the DOM hierarchy for the purposes of synthetically bubbling the event.  We are hitting the `form` node, which is the one that has magic expando properties.  It's a bit more complicated to identify form nodes when `tagName` and `nodeName` can both be overwritten by named inputs.

In `shouldUseChangeEvent`, we are searching for `input` and `select` nodes.  Cleanest solution I can think of at the moment is to return false for any node where `typeof nodeName !== 'string'`.  The sucky thing is that this is not a general solution and there are likely other places in the codebase where we're going to need to play whack-a-bug.
 Yea, I updated my comment and mentioned the form. Otherwise window properties are due to ids, not name, whereas form properties are there for names. Maybe something with the iframes + debugger screwed me up.
 So what we could do is instead of ever checking nodeName is do `instanceof` checks. So this code would become

``` js
function shouldUseChangeEvent(elem) {
  return (
    elem instanceof HTMLSelectElement ||
    (elem instanceof HTMLInputElement && elem.type === 'file')
  );
}
```

The risk is that we're in an environment that doesn't have the globals we expect. Maybe we read them from `window` instead & wrap potential problems in canUseDOM checks. We shouldn't hit this path at all in node anyway so I don't think it's a problem in this case, maybe in others.
  I can‚Äôt find mentions of `integrity` or `crossorigin` on that page.
Can you help me understand where you see it?
 Thanks. I can reproduce this.
@zpao Can you give any insight into this?
 @petetnt The problem is that the headers aren't being set on the fb.me server, so the python gist is irrelevant / will not solve this issue.

This is a security feature of browsers, since checking integrity can leak information about the content of the response.

fbcdn does allow all origins, but fb.me does not, which is the root cause of the error here.

Does fb.me serve anything directly, or is always just redirects?  If it always just redirects, we might be able to blindly enable the CORS headers on fb.me without any security impact (thereby relying on the redirect-destination to control the CORS permissions).  Otherwise, we would need to enable the cross-origin headers for individual URLs, which will require adding data to the fburl database, which is probably a more intense task.

Another option is to use a different URL (not fb.me).  Could link directly to the CDN, for instance.

I think the shortest term solution is to remove the offending attributes from the script tag, which makes the tags look cleaner/simpler (read: less scary to new user) anyway.
 fb.me is always a redirect, but I thought it was set up right such that this worked. I thought I checked the headers when I added those attributes to the docs... maybe not‚Ä¶ I think ultimately we shouldn't use fb.me but haven't gone and done that yet. We might just set up a little mini-cdn of our own since we have some other issues with the older fb.me links (corrupted cache somewhere that we thought we tracked down but still see occasional issues). cdnjs and jsdelivr are both great external third-party options right now so I definitely recommend them over fb.me regardless. We just need some control when we ship releases so relying on them entirely isn't in the cards.

I think we should keep the attributes (when they work) - moving towards a world with these checks is a good thing and we can help promote these features. But shorter-term, yea that's fine.
 > We might just set up a little mini-cdn of our own

I've used CloudFront in the past, and can certify that it's totally awesome.  FWIW.
  Thanks for reporting. This is a known issue and is not solved yet. Please subscribe to https://github.com/facebook/react/issues/4972 in order to track it! I‚Äôm closing this one as a duplicate so we keep the list focused.
  Sure, please squash these into a single commit (`git rebase -i`, `git push -f`) and then we can merge.
  We never render the `data-reactid` on the client side - only on the server side.  Can you provide a jsfiddle that demonstrates the invariant violation?
 Thanks for tracking down more specifically. Could be that browsers don't actually support that body usage? Or when actually parsed from markup, the body node doesn't exist (which seems likely and matches up with what we see in other situations where the browser changes markup). I won't have a chance to look into this more for a few days - it might be best to just use your alternate approach for now.
 > Or when actually parsed from markup, the body node doesn't exist (which seems likely and matches up with what we see in other situations where the browser changes markup).

It seems so. Even without React, I can‚Äôt get Chrome (or Firefox for that matter) to make `body` an actual node:

<img width="261" alt="screen shot 2016-03-17 at 15 19 30" src="https://cloud.githubusercontent.com/assets/810438/13850973/2ec59918-ec54-11e5-818d-dcb1cf3392fc.png">

http://jsbin.com/qelademodi/1/edit#file
 @gaearon FWIW, `ReactDOM.render()` does manage to put one in: http://jsfiddle.net/j5hh76h2/
 Sounds like we should add this to `validateDOMNesting`: we should warn and tell you you can't put a body tag inside foreignObject. We don't do anything much for SVG there right now; probably the ideal solution would be to pass the namespace info down too, then we can distinguish SVG and HTML tags with the same name (like title), then make sure the contents of a `foreignObject` SVG tag are appropriate HTML tags.

Not sure which HTML tags are and aren't allowed but it might be detailed in the HTML5 spec at https://html.spec.whatwg.org/multipage/.
  both are needed and the id is still there for React to mount that markup. If you use renderToStaticMarkup and render over that, the DOM will be thrown away, which can be bad for large content (might see a flicker) and for stateful elements like inputs.

You mentioned on Twitter that you had a specific problem. If you can repro that, please file a new issue and we can see what's going on.
  It seems to me that this is not the correct fix.  React-native shouldn't be sending a move event before a start event, right?
 I'm going to close this out, because I don't think this is the right fix.  It would just hide the problem, making it more difficult to debug/reproduce/witness. Also, with this fix, you would still be loosing events, which is a bad user experience.  I'm going to close this out in favor of tracking facebook/react-native#5246.  If the RN team bounces it back here, we can re-investigate.
  Sounds like this is intended for the react native repository at https://github.com/facebook/react-native, I'm going to close this out in favor of posting there.
 ... can you elaborate?  How do we reproduce this in the core?
 Yeah, I agree.  That's why I initially suggested posting in the react-native repository.  Doing something like https://github.com/facebook/react/pull/6278 would just hide the problem, making it more difficult to debug/reproduce/witness.  And even with the https://github.com/facebook/react/pull/6278 "fix", you would be loosing events, which is a bad user experience.  I'm going to close this out in favor of https://github.com/facebook/react-native/issues/5246, because I don't think there is anything actionable here.  If the RN team bounces it back here, we can re-investigate.
  This was introduced as part of #6164 and approved by @spicyj but got reverted in #6243 by accident.
I believe the web component part of it is still relevant (I should‚Äôve split that PR to signal that):

<img width="389" alt="screen shot 2016-03-16 at 21 12 40" src="https://cloud.githubusercontent.com/assets/810438/13828875/d82bb832-ebbb-11e5-9ee2-85d23fc1a347.png">

This PR just applies the part of #6164 that is still relevant (for web components only).

Test plan: when `dangerouslySetInnerHTML` is specified, it is no longer copied as an attribute.

<img width="207" alt="screen shot 2016-03-16 at 21 15 25" src="https://cloud.githubusercontent.com/assets/810438/13828940/3a652178-ebbc-11e5-8eec-1bf0968acc49.png">
## Reviewers

@sebmarkbage 
 The only thing I‚Äôm not sure about is whether I need `keyOf` here. This is related to Closure Compiler optimizations that I don‚Äôt understand. @spicyj said [`keyMirror` is not necessary](https://github.com/facebook/react/pull/6164#discussion_r54671570) but I wonder why `keyOf` was present then.
 üëç sorry for not being more careful in the revert.
 OK this makes sense to me now. Seems like the current approach is the correct one. `keyOf` was there to avoid introducing a string like `'children'` which would be incorrect, but with the current approach we don‚Äôt hard code strings at all, which is fine by GCC.

I‚Äôll merge this in because it‚Äôs been reviewed before and @zpao just gave a :+1: .
  As per https://github.com/facebook/react/pull/6274, we should warn if these attributes are used.
  Unit tests are great, thanks @cbrwizard!
 @cbrwizard updated the pull request.
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 Thanks for the PR, and welcome to the community!

This is not a typo.  http://blog.apastyle.org/apastyle/2012/04/using-a-or-an-with-acronyms-and-abbreviations.html
  Thanks @rofrischmann
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
  Flagging for performance: This adds two call to `propertyIsEnumerable` in the production code path.  We may want to just disable the warning when cloning, similar to what I did in https://github.com/facebook/react/pull/5976/files

@ericmatthys Let's make sure we add a unit test to verify the exact case you're talking about.  Write a simple component that passes the props object into cloneElement and assert that it does not warn.

On a higher level note, I wonder how we feel about passing the props object directly to cloneElement as a config.  It means the cloned child will receive all the props of the parent, when the owner should probably be passing those props directly to the child.  @ericmatthys can you elaborate (in detail) why you are using this pattern?
 I suggest you to extract something like

``` js
function getRef(config) {
  if (__DEV__) {
    return !config.hasOwnProperty('ref') ||
      Object.getOwnPropertyDescriptor(config, 'ref').get ? null : config.ref;
  } else {
    return config.ref === undefined ? null : config.ref;
  }
}

function getKey(config) {
  if (__DEV__) {
    return !config.hasOwnProperty('key') ||
      Object.getOwnPropertyDescriptor(config, 'key').get ? null : '' + config.key;
  } else {
    return config.key === undefined ? null : '' + config.key;
  }
}
```

Then you can use them both in `createElement()` and `cloneElement()`. Another nice thing about this: it avoids `'' + config.key` duplication as well.

Would you like to give it a try?
 @ericmatthys updated the pull request.
 This doesn't merge cleanly, can you look into why? Thanks. 
 @ericmatthys updated the pull request.
 This look sensible to me. More tests would be welcome :+1: 
 @ericmatthys updated the pull request.
 @ericmatthys Ok, I see your use case, you are wrapping Connectors and want all the props to propagate down.  I think you are running into this issue because you are using connectors to pull data out of your application state, rather than pulling out the application info at the application-component level.

I think a better way to structure your application would be:

```
<OuterConnector1 state={store.getWhateverState()}>
  <OuterConnector2 error={store.hasError()} populated={store.isPopulated()}>
    <InnerFoo bar={store.getMyVariable()} noise={store.getMyOtherVariable()} />
  </OuterConnector2>
</OuterConnector1>
```

It is a little more typing, but it's far more explicit.  Your current method of having connectors pull data out of and do a bucket-brigade of blindly passing/forwarding props makes the code much harder to reason about because you don't know what props are expected at any given stage (ie. it runs into a lot of the same maintainability problems as `context`).
 Thanks a lot for the PR, and sorry it took a long time to review! I started merging this, but then found a few existing issues in the same area, and so I rebased your commit and added a bunch of new ones on top. Your PR helped surface those bugs!

I‚Äôm closing but your commit will get in as a part of #6880.
  Since this is not an issue with React, StackOverflow would be a more appropriate place to ask about this. As noted correctly by @cody and @yaycmyk, the problem is that the functions you pass to `addChangeListener` and `removeChangeListener` do not match, and binding early would fix this problem.
  Yes, closing as per @iamdustan, should be fixed in latest/master.
 ETA is within the next week.
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 @infiman updated the pull request.
 Context is an experimental feature and is intentionally not documented outside of the page on context.
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
  This would also mean you can't run in a worker or anywhere that requires crossing a serialization boundary (eg. react-native).  My guess is that we wouldn't want to do this.
 Note (mostly to self): Another problem is that jsx elements can be inserted multiple times, but DOM elements can not.

This is a valid component:

```
function MyComponent() { return <div><div class="foo">{this.props.children}</div><div class="bar">{this.props.children}</div></div>}
ReactDOM.render(document.createElement('div'), document.createElement('div'));
```
 @JaRail You can't clone DOM nodes, since the whole point here would be to retain referential identity.
  I agree with @syranide, this looks like a duplicate of the mentioned bugs.  The fix has already been merged into master.  If you experience the bug in RC2 (which will be released soon) or in the master/future build (eg. http://jimsproch.com/react/future/), ping us to reopen/reinvestigate.
  Agree, nothing here to indicate a bug in React, looks like a usage error/question.
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 Thanks!
  Ok, this looks good now.  Can you squash into a single commit (`git rebase -i`, and `git push -f`), and then I think we can merge.
 Thanks!
  Capitalized, bolded, and wrapped in asterisks... seems a bit aggressive.  I think I'd prefer one of the three.

I'm a little curious how you ran into this?  Did you checkout the source code from master, or how did the examples fail for you?
 Ping @terry3

> I'm a little curious how you ran into this? Did you checkout the source code from master, or how did the examples fail for you?
 Sounds like other people don't have a strong opinion here.  Do you want to update the PR (`git commit --amend`, `git push -f`) to do one of the three (Capitalized / bolded / wrapped in asterisks) and then I think we can merge this.
 Let's just use `<strong>`. We don't need `*` nor caps.
 @terry3 updated the pull request.
 Looks good, thanks!
 FYI: This isn't documentation in the same sense (doesn't end up on website) and we're not likely to do another 0.14.x release unless something major comes up, so not merging to stable.
  Thanks!
  Overall, this looks good.  Just a few nitpicks.

Also, can you add a full-path test that actually creates a component with a proptype specified, and then calls `React.render` with a miss-capitalized proptype?  We want to make sure the public API semantics are tested.
 That would imply that `createChainableTypeChecker` is being called twice (once at createElement and once at ReactDOM.render).  I didn't sit down and think about why that might be happening, it surprises me a little - it might be worth looking into.

We are probably going to need to add some deduplication logic into your devtool anyway.  We don't the warning to fire every single time the component is rerendered.  You can take a look at the other places we emit warnings (eg. DOMPropertyOperations.js contains `illegalAttributeNameCache` and `validatedAttributeNameCache`), and you can do something similar within your devtool.
 @ahmedghoneim92 updated the pull request.
  This is a usage question, rather than a bug in the React core. Usage questions are better answered on sites like StackOverflow, as we try to use github issues for tracking bugs in the React core. For this reason, I'm going to close out this issue, which takes it off our radar, but feel free to continue the conversation here (or move it to StackOverflow).
  At first glance, I like this API much better than our current API.

The function name would need a bit of bikeshedding.  At the very least, it would need to live on `ReactDOM`.  It should also be given a name that indicates that it's dangerous and that it is NOT making the HTML safe, but rather dangerously marking it as trusted.

cc @syranide @sebmarkbage Thoughts on such an API?
 I just talked with @sebmarkbage about this, here are the results.

Overall, Sebastian indicated that the new API was probably ok, but a change should probably be low priority.  His main concern was performance in the case where React nodes are siblings of the foreign markup (updating the foreign markup might require iterating over the nodes to delete them individually because you need to figure out which nodes are foreign and where the react siblings are located).

However, I now wonder if React should even have a dangerousHtml feature.  Setting inner html is a very non-reacty pattern; it's clearly an escape hatch.  An alternative is to attach a ref to a DOM node, and set the innerHTML of the DOM node.  There is no fundamental reason this can't be handled entirely within userland.
 Ah, thanks @sthzg, we had neglected to consider SSR.  You're right, we need some sort of API!

I'm back in favor of this new API proposal.
  I might be wrong but I think `fbjs` is used internally in React. That‚Äôs why it was created: as a way for Facebook projects to share some common code. It is an implementation detail and should not affect you externally.
 Fbjs is not optional. Envify is there for use with browserify so could probably be called optional.
 I don‚Äôt think making `envify` an optional dependency makes sense either. Browserify build [will fail](https://github.com/reactjs/redux/issues/1304) if a package specifies a transform that doesn‚Äôt happen to be installed. Doesn‚Äôt seem like there is ever a case when we want `react` to get installed without `envify` coming with it. Of course it only matters to Browserify users, but we can‚Äôt guess the bundler a person is using.
 > I'm claiming the package is usable without the fbjs dependency because the distribution files (in dist/) have a bundled/inlined copy of the library. It seems a bit strange to me to bundle one copy and then force installation of a second copy through the dependency list.

Yeah, but the same can be said about React itself. The fact that it exists in `dist` doesn‚Äôt mean we should get rid of `lib` folder. The `dist` files exist for consumers who want to use UMD builds via npm. For example, this is useful when you swap CommonJS modules for UMD builds in production configuration. However, the main contents of the npm packages are still CommonJS modules, and those won‚Äôt work without `fbjs` being a dependency (also consumed via CommonJS).

> Regarding envify, would it be possible to split out Browserify-specific functionality into another package (e.g. react-browserify)? I'm not using Browserify and am not too happy with having envify and it's transitive dependencies {jstransform, base62, esprima-fb, source-map, amdefine, through} lying around doing nothing but complicating future application maintenance

React relies on envification in order for CommonJS consumers to be able to get both development and production build depending on the configuration. Different build tools have different approaches to envification. Webpack has the stance that libraries should ship compiled code, and any further transformations should be done manually by the user if necessary. Browserify decided that libraries can declare the necessary transformations. Both approaches have upsides and downsides, but they are already ingrained in the respective communities.

If we remove the Browserify transformation step, most today‚Äôs Browserify consumers will get development builds in production. This is because, without `envify`, Browserify will still provide a polyfill for `process.env`, but `NODE_ENV` will be `undefined`. This means that introducing such a change will have a long-lasting impact of forcing pretty much every Browserify user change their React build setup to `envify` _their_ build globally just because React decided to change their mind. Even if you consider Browserify design suboptimal, you can probably agree this would be a very devastating change especially considering that many people are going to miss it, and as a result will end up with slower apps running developer builds in production.

Having a separate package like `react-browserify` could be an option, but it is going to cause a ton of confusion. What about related packages like addons? What about code examples that all use `require('react')` or `import React from 'react'`? It would be very unfortunate to ask people to pick different NPM packages based on their bundler, and some people inevitably will use the wrong one, so this doesn‚Äôt seem like a viable option.

Browserify was the first successful mainstream CommonJS bundler and we can‚Äôt ignore its conventions even if in some cases they seem suboptimal. Having transitive dependencies because of a build tool you don‚Äôt use can indeed be frustrating, but breaking all users of the most popular bundler or introducing major inconsistency in using React with it seems like a worse kind of problem to me. I think that with the current situation your best bet would be to either use React from a CDN, or set up a mirror npm package where you only bring the dist files and remove the dependencies. Sorry I can‚Äôt be more helpful than that!
 Great back and forth, thanks for explaining it Dan. Apologies for my curtness, I'm on my phone at the beach üèñ

One option to cut down on deps for the browserify case is to switch to using loose-envify which only has 1 additional dependency and should work fine since we don't have any crazy uses of process.env.
 > switch to using loose-envify which only has 1 additional dependency and should work fine since we don't have any crazy uses of process.env

Sounds great. @qerub Would you like to take a stab at PR?
 I am closing this per the discussion above.

We would be happy to accept a different PR that switches React to use `loose-envify` instead of `envify`. As noted above this should get rid of most of these transitive dependencies.

Thank you for taking time to contribute, and we hope to see you again!
  If you define ref as a string, it will be available on `this.refs` object, for example, `this.refs.input`.
If you define a callback ref, you are free to do anything with it, including saving it on `this` if you‚Äôd like.

The string refs are eventually going to be deprecated. Callback refs were introduced later but they cover all use cases of string refs and don‚Äôt have some of their downsides. I suggest you to always use callback refs in the new code you write.

In the future, please consider asking questions on StackOverflow. We don‚Äôt officially consider issue tracker to be a support forum, and unfortunately GitHub search does not work as well as StackOverflow search, so it‚Äôs likely somebody is going to ask this again. Whereas if you posted this on StackOverflow, it‚Äôs likely you‚Äôd get a good answer, your question would get voted up, and more people would have learned from it and found it in the future.
 No problem! Please feel free to submit a pull request to the documentation if you feel like we could make it more obvious that we recommend the callback ref pattern in the new code.
  @vitalybe What is your use case for refs? If you just set an instance field it should make absolutely no difference whether it is reattached on every render or not. 
 We should probably throw early if you setState from a ref callback. I don't think this is meant to be a supported pattern. 
  This is definitely something we want to do.
Please refer to #5703 for the related discussion.
I‚Äôm not sure what the specific roadblocks are, but it‚Äôs better to ask in the existing issue.
 Yea, this was a bad one that got through. We should have caught it. There are a couple things we could do differently for that particular one (including but not limited to browser testing). Thanks for bringing it up - it's definitely on our minds.
  @ludvigsen updated the pull request.
 @ludvigsen updated the pull request.
  I can reproduce it in IE11.
Edge seems fine though.
 Darn it, I remember considering this a few months back but must have forgotten. Easiest solution might be to treat document fragments specially in DOMLazyTree but I'm open to other ideas.

cc @mwiencek if you're interested
 Thanks to everybody for the quick find and reduction! This is exactly how the process should work ‚ô•Ô∏è
  Bah, good catch. Thanks! I even had it locally when I was testing but didn't read that PR carefully before pressing merge.
  `data-react-id` was an implementation detail so it‚Äôs best to avoid relying on something like this. I would suggest you to come up with your own system of unique keys (e.g. `data-automation-id="..."`) and use those instead. Unlike with the ones generated by React, you can set these explicitly, have full control over them, and they are guaranteed to not go away.

Does this help?
  @edvinerikson updated the pull request.
 @edvinerikson updated the pull request.
 üëç thanks!
  Looks like a specific usage question so I'm going to close out. In the future please try to work these out elsewhere, perhaps with the specific library authors or on stack overflow. We try to keep our issues here focused on bugs with React and not for support. If you do think you've found a bug in React then I'll request you create a minimal test case that we can run (ideally in a jsfiddle or jsbin).
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 This is compiled to `require('./React')` as a part of our build system and all of the internal module references are relative. Build tools like Browserify should handle this fine since this module is internal to the `react` package.
  This is unfortunate side effect of combining npm modules and dist versions but there isn't really anything we can do without exposing all of the modules that the transtion group addon needs on the React object (like we did with __SECRET_DOM...). We aren't going to do that. Using the dist version of React and the addons is simply incompatible. I suggest using the npm package of React so everybody can be using the same code.
  Can you make a contained repro case with jsfiddle (https://jsfiddle.net/reactjs/69z2wepo/)
  Can you provide a jsfiddle which demonstrates the issue?

You can fork http://jsfiddle.net/9kungxn4/
 It is likely that you‚Äôre hitting a browser bug.

It might also be possible that there is a bug in React, but unfortunately there is not enough information here for the team to investigate it. If you manage to isolate the issue in a fiddle, please let us know.

I will close the issue, but we are happy to reopen if you can provide a way to reproduce.
Thanks!
  Or the babel6 transform that I use for my own testing: http://www.jimsproch.com/react/

But yeah, you have a couple extra parenthesis after `React.Component`; should be:

```
class IndexPage extends React.Component { render() { return (<div />); } }
```
  @sairion updated the pull request.
 Thanks!
  @mbrio @JacksonGariety What browser are you guys using?  Any chance you were using Chrome 49?  We've seen a similar bug (https://github.com/facebook/react/issues/6472) and I'm unable to reproduce in Chrome 50, so I'm wondering if this might just have been a chrome bug.

@mbrio @JacksonGariety Can either of you provide a jsfiddle that demonstrates the issue?  You can fork http://jsfiddle.net/9kungxn4/ and use `ReactDOMServer` to get access to the server-side-rendering logic if you need that for your repro.
 Using v15.0.1, I get that event emitter is not defined: https://jsfiddle.net/ft5xeugv/
 Using EventEmitter from CDN, I don't seen any errors: https://jsfiddle.net/dv85q3w2/
 @damienleroux @gbhrdt I am not sure.  We have a couple of fairly complicated repros (100-ish lines, with dependencies like ReactRouter and Redux) of a similar bug which may or may not be related.  We don't yet have any repro that is super simple/actionable and demonstrates a bug in React as oppose to ReactRouter/Redux.  So to answer your question, if you can provide a simple Repro, that would still be super helpful, otherwise we will look at the other issues (https://github.com/facebook/react/issues/6538 and https://github.com/facebook/react/issues/6371) and loop back to this one later.
 @damienleroux @gbhrdt Ok, the repro that we have for the other issues is NOT related to anything dealing with SSR, so yes, we still need a repro of this!
 @TooTallNate

```
  componentWillMount() {
    setTimeout(() => this.setState({ foo: 'baz' }), 1000);
  },
```

I feel like setState should not be called in a `setTimeout` registered in `componentWillMount`, since the setState will likely occur after the render has occurred.  You should consider calling `setState` directly within `componentWillMount`, or using `componentDidMount` for this use case if it needs to happen after mounting.

Sounds like a usage error to me.  Perhaps we could warn in this case, but I don't think this was ever a supported pattern.

I'm assuming we have a regression not related to setting state after a component has rendered.  If everyone above is seeing this behavior as a result of something like @TooTallNate's example, I think we could just close out this error (or warn in this situation).
 @TooTallNate Yeah, there are a bunch of people who want features like that.  See https://github.com/facebook/react/issues/6481 and https://github.com/facebook/react/issues/1739.  Short answer is: "no, we don't have a good solution for that".
 @03eltond The [code you linked](https://github.com/reactjs/react-router/blob/master/modules/Router.js#L77) calls `setState` directly (not in a setTimeout) which is legal and entirely different from the example @TooTallNate showed.  Does anyone have a simple repro (jsfiddle) that does not use setTimeout&friends?
 cc @ryanflorence @taion @mjackson @timdorr any comment?

https://github.com/reactjs/react-router/blob/master/modules/Router.js#L77
 The repro case that @TooTallNate posted does throw this error in v15 but also throws an error in 0.14.7:

> Uncaught TypeError: Cannot read property 'firstChild' of undefined

We want to add a warning when calling setState after a server render (#5473) but at least that case isn't a regression. I'll look into some of these others in a bit.
 @JacksonGariety After cloning your repo (and manually installing babel-plugin-transform-object-rest-spread, chalk, lodash) I can load http://127.0.0.1:1337/ without errors. Am I doing something wrong?
 Can anyone here give repro instructions for an example that works fine in 0.14 but is broken in 15? Small repro cases (ex: jsfiddle) preferred but I can also work with a full app to clone. Otherwise, I'll close this issue because all the cases I've tried so far do not repro or were also "broken" in 0.14.
  cc @hellendag because I hear he knows something about all of this.
 I'm going to close this out as "probably not react issue" as per @fowerling5555's latest comment.  If someone can demonstrate that this is a React issue (using jsfiddles) we can reinvestigate.
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 We've talked about doing something like this before and we might get there but I think right now it'll actually cause issues. If for example another module was using react-with-addons, that would end up not using the same React object whereas it should if we leave this as is. Same with our addons. This is due to the way we require deeply. Thanks for the effort though :)

One thing you can consider doing if you are having performance problems is try to bundle your whole node app, just like you would bundle your client side app. You can get the same benefits as you would with what you're doing here but applied to the rest of you app and without the problems I mentioned above.
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 @everdimension updated the pull request.
 Going to take this for 15 to fix the regression. There has been some discussion about doing something more involved with properties and attributes but this is the safest fix for the time being. Thank for doing this!
  Thanks @antoaravinth!
 @yaycmyk  It's a little annoying to add unit tests for every type of event.  Since the native events need to be forged, they're of minimal value anyway, since all you're testing is the forged event.  Such tests would make a lot more sense if/when we do in-browser testing (but the tests would need to be written differently anyway, using webdriver/whatever, which we currently don't support).

That said, if you'd like to submit a PR that adds a test for this event type, we'd gladly accept.
 Was this the correct fix?

I find it a bit weird that we seem to [already normalizing `focusin` and `focusout`](https://github.com/facebook/react/blob/c3b7f937b062a0afbdd404ba5ada51043a753808/src/renderers/dom/client/ReactBrowserEventEmitter.js#L300-L313) as part of `focus` and `blur` support. Supporting them explicitly seems contrary to the goal of having a normalized event system, especially considering that they are not supported in Firefox.
 I think we should still support the event name (or at the very least warn and say "use focus/blur", but that seems dumb).  If the behavior is the same in our polyfilled environment, we should just map them to the same behavior/implementation.
 > If the behavior is the same in our polyfilled environment, we should just map them to the same behavior/implementation.

So far we have tried to have only way to do something. Why break this tradition? It‚Äôs the same as `class` vs `className`, `onClick` vs `onclick`: if we chose one, let‚Äôs stick with it.

> at the very least warn and say "use focus/blur", but that seems dumb

IMO it actually sounds really sensible. This is a great opportunity to warn the user in a very specific and useful way. I think we should revert this PR but add a warning.
 Warning is fine. Not sure about mapping it since that means we need to have logic and checks for it in prod. Why is it important to map if there is a warning and we never supported it in the past?
 :+1: 
 This has been reverted in #6274. Sorry about the back and forth on this!
If there‚Äôs something about the existing `onFocus` and `onBlur` that doesn‚Äôt work for you, please let us know. Cheers!
  @WebReflection updated the pull request.
 @WebReflection updated the pull request.
 @WebReflection updated the pull request.
 @WebReflection updated the pull request.
 @WebReflection updated the pull request.
 It would be even nicer if we could have this just work by going through IE8.js's `addEventListener` polyfill so that we play nicely with the execution order of events etc.

It turns out that IE8.js does a really good job at polyfilling most things so this mostly just works! We just have to address the focus bubbling issue specifically.

See https://github.com/facebook/react/issues/3131#issuecomment-194642861

We'll revisit doing early checks if we have to. Might need a consistency check in more places. However, it looks like we can work really well just on top of polyfills too so maybe we don't need to.

Thanks for looking into this! We really appreciate it.
  Thanks!
  Thanks. We like to keep under 80 chars but it looks like the surrounding code is already offending so I'll let it slide. :)
 (@zpao plz pick for 15.0 final)
 Err, I was going to request changes @spicyj

Specifically, this seems to be hacking around the issue (use of `in`), and in a not-very-good-way.  For instance, if `Component.displayName = undefined;` then this will use undefined, which is worse than `Element`.

It would be better to do something like `return component && (component.displayName || component.name) || 'Element';`

Also, less importantly, we should probably have a unit test to prevent a regression.
 This is objectively better than the previous code. We should have shared utils for getting names from a type since we do this a little differently in every spot, but we don't currently and we're not consistent.

Agree it would be nice to have a unit test.
  Ultimately, what you are really trying to specify is "this component is controlled, but is currently empty".  It is intentional that you specify this by setting the value to be the empty string.  When the value is specified as undefined, React has no way of knowing if you intended to render a component with an empty value or if you intended for the component to be uncontrolled.  It is a source of bugs.  This is why the warning exists.

It sounds to me that `this.props.search.get('term')` should return the empty string instead of undefined, assuming the initial value of the search box is the empty string.

Alternatively, you could do a null/undefined check in this component, before passing the value to the input.

We haven't received too much push back on this one, so I think it's uncommon enough that the benefit outweighs the cost.  Therefore, we probably aren't going to change this, so there is nothing actionable in this bug.  However, if our thinking changes on this matter, we can certainly reconsider.
  This is not a regression.

If you look at the [history of TapEventPlugin in the React codebase](https://github.com/facebook/react/commits/master/src/renderers/dom/client/eventPlugins/TapEventPlugin.js) you will see that it was affected by one of the recent refactorings (this is internal code and we make no guarantees about the API stability). Specifically, 4a465fbd9a99815e9a0eb8b14af0c0423d9e8552 and f470cb88f88b4667419f170fcc7971dad4298494 changed some of the arguments that were being passed.

Since `react-tap-event-plugin` is effectively a fork of `TapEventPlugin`, it needs to incorporate upstream changes to be compatible with any next release. I sent a PR to `react-tap-event-plugin` that mirrors these changes. In my testing this makes it compatible with React 15 RC2, and I would expect it to also be compatible with the final 15 because that code hasn‚Äôt changed since. You can find that PR as https://github.com/zilverline/react-tap-event-plugin/pull/65.

I‚Äôm closing this but please let us know if you have any other issues. Cheers!
 I don't think it's maintained per se. It's just that there was an internal refactoring that changed the argument order, and @soprano went through all matching call sites, changing them there, and it happened to include TapEventPlugin. We make no guarantees about it not being broken. I think we should remove it from the core source code. But yeah, this means that its maintainers will need to track changes to internal APIs. We don't have a better solution right now. Eventually we might expose event system officially as well as DOM configs but if addons taught us anything, it's that anything we expose creates a huge maintenance burden down the road which creates significant delays in development of React itself. So please excuse us that we don't have a good story around this right now. We are happy to discuss handling taps in a separate issue though so feel free to file it! Thanks. 
 @gaearon is correct.  To add to his comment, the plan is to rip it out of the core repository and have this handled in user land, as per: https://github.com/facebook/react/issues/436#issuecomment-178268985
 > Since Chrome and Safari have both removed their tap delays for mobile pages, it's probably time to stop using TapEventPlugin and just use the onClick event.

:+1:
  We've actually been following semver the whole time üòÉ. We've already explained the versioning change as @krzysiek1507 has linked and now that it will be over 1.0 you can push it past your corporate overlords.
  Yeah, I spent a few minutes looking for the PR that I suspect is responsible for this, but don't see it at the moment.

Without having actually dug into the code, my intuition is to look at https://github.com/facebook/react/blob/master/src/renderers/dom/client/wrappers/ReactDOMSelect.js and https://github.com/facebook/react/blob/master/src/renderers/dom/client/wrappers/ReactDOMOption.js

But don't rely on those tips too heavily, I don't want to send you off on a wild goose chase.
 @jimfb Was #1510 the PR you were looking for?
 FWIW, if you mount into something that was server side rendered, you get the `value=""` as desired:

```
document.getElementById("container").innerHTML = (ReactDOMServer.renderToString(Select));
ReactDOM.render(Select, document.getElementById("container"));
```

A potential solution here would be to stop treating `value` as a special property, and just set it as an attribute, which means this could also be solved by https://github.com/facebook/react/pull/5680 (I think).
  @aleclarson updated the pull request.
 Did you run the tests?
 This has been around almost for a year and is not merged so I‚Äôm closing. If this fixes an issue and there is a person who can review it and confirm it‚Äôs correct please feel free to reopen!
 Ugh, sorry, I read that as 2015 but it‚Äôs actually from 2016 :scream: 
Reopening but it would be great to know who can review this!
 Has Travis not run the tests on this PR from over a month ago?!
  Going to delegate here‚Ä¶ @spicyj I know you don't have a ton of time but you might know this code best. You also touched it last to import some changes from RN :). Or maybe @sebmarkbage can take a look / bring in somebody from RN who knows this. I would imagine if things are broken here then RN is going to be hosed.
 I commented here already: https://github.com/facebook/react/commit/6ec3b651690befb4226230855fa2e102654ad35f#commitcomment-16569138. :) I think @jordwalke is probably the best contact here.
 Oh yes, that sounds right. Here's what I wrote when I imported the latest version of this plugin from RN: https://github.com/facebook/react/pull/5308#issuecomment-166764304.
 It's been in prod since August.
 Original summary (D2163934 internally):

> Change PanResponder to allow Views to block native components from becoming the responder.
> This should be done through PanResponder's onResponderReject, but that does not work: onResponderReject will be called _after_ the native View has already intercepted the touch. At that point it is too late to cancel the native intercept (similar on both android and ios) even if we wanted to.
> Instead, we can now block native components from intercepting the touch in the first place.
> On the JS side: when you set the panResponders, you can set whether your JS component should block all native components from trying to become responder (ie. range slider not allowing ScrollView or ViewPager from getting the responder, image cropper not allowing ViewPager to steal the responder etc). PanResponder will then tell native to block native components from intercepting touches when the responder is granted, and unblock the setting when the responder is released.
> On the native side: UIManager passes the jsResponder changes to NativeViewHierarchyManager, which can get the View for the given react tag. We then call (un)blockNativeResponder with the parent of this View because ViewParent implements requestDisallowInterceptTouchEvent - which can be set to not let any ancestors from intercepting the touch events. This required moving JSResponder from UIManager to NativeViewHierarchyManager, but it didn't seem to do much for UIManager in the first place. Also, I did not create an operation for the js responder changes, because they do not qualify as ViewOperations. 
 Leaving this open until a fix is merged.
  Yea, we could do better here, which would be an improvement. We have a few other style-related warnings which are in the same position (eg "Unsupported style property..."). It looks like the function that's warning there doesn't have enough context to do it but the caller does have a reference to the DOM component that's being rendered. From that we can get the tag (eg, 'div') and I think walk back up to the owner to add the "check render method of ___" bit. If you're interested & can do that soon, we can try to get it into final.
  @nhunzaker updated the pull request.
 I missed that you are reusing the `props` when it‚Äôs not disabled. In this case I think it is fine as is.
2eeebf9ee7f016e4da046949a6e94402aaf18f4b solved my concern but maybe somebody else has more.
 I tested this on every major browser on OS X, and in IE9+ and Edge on Windows.
It looks good to me so I‚Äôm marking as accepted and setting 15.x milestone.
@zpao and @spicyj, if you have any objections please let me know.
 I don't feel strongly either way. This could theoretically be breaking so probably shouldn't go out in a patch release.
 Is it likely somebody relies on `onChange` firing on disabled elements in IE when it isn‚Äôt the case for other browsers? Not trolling, just not sure how often such situations happen in practice.

Maybe we could include it in a minor. We still think it‚Äôs a bugfix but minor would be a bit lower risk. Is that what you were saying?
 @nhunzaker updated the pull request.
 From #1790 it wasn't clear to me which browsers are affected. If it is inconsistent across browsers then I'm less worried, but still probably a little better to put it in a minor rather than a patch.
 So no browsers fire mouse events on disabled inputs normally? If so, this seems smart.
 @nhunzaker Thanks for the investigation and for confirming.
 That would seem to also work. I don't have a strong feeling on which is better.
 We‚Äôll cut 15 and get back to this asap.
 @nhunzaker updated the pull request.
 Don‚Äôt see any reason not to get this in. Thanks!
 Thanks @nhunzaker and @gaearon!
 @gaearon Is this safe in 15.0.x? Seems like could be potentially behavior changing. Or does it just fix a bug in some browsers?
 @zpao 

As far as I tested, it just makes the behavior in older versions of IE (<= 11) consistent with all other browsers that ignore mouse events on disabled inputs. We already had an identical fix for buttons‚Äîit just wasn‚Äôt wide enough.
 Cool, thanks! I just wanted to double since I didn't look closely.
  Thanks!
  React 15 removed whitelisting attributes for SVG completely in #5714. The names left in the [whitelist](https://github.com/facebook/react/blob/master/src/renderers/dom/shared/SVGDOMPropertyConfig.js) are only there to print deprecation warnings. You will find that any arbitrary attribute, including `focused`, should get passed correctly in in any version >= 15 RC1. 

React 15 RC1 was [shipped yesterday](https://facebook.github.io/react/blog/2016/03/07/react-v15-rc1.html) so I would suggest you to check it out. I would expect 15 to arrive shortly within a few weeks.
 Seems like we‚Äôre going to go back on that change (see #6243).

Are there any browsers that actually support `focusable`?
We can add it if that‚Äôs the case but [from a quick look it doesn‚Äôt appear to be implemented](http://stackoverflow.com/questions/22671799/svg-focusable-attribute-is-not-working).
 cc @tomocchino whitelists... :P
  In #5714, we changed SVG attribute logic to pass all SVG attributes unchanged.

This means, for example, that instead of `<svg strokeWidth>` you‚Äôd write `<svg stroke-width>`.
The reason for this change was that we don‚Äôt want to maintain a whitelist of attributes.

Since we released 15 RC, I saw a [report on Twitter](https://twitter.com/albertfdezp/status/707148130307993600) saying that `<svg className>` now also prints a warning:

> Warning: SVG property `className` is deprecated. Use the original attribute name `class` for SVG tags instead.

In a way, this makes sense, as it is consistent with us not maintaining a whitelist, and with [how we treat custom components](https://github.com/facebook/react/issues/4933).

On the other hand, SVG elements do not seem _that_ special, and asking people to use `class` on them instead invites the old discussion about doing that for DOM elements as well.

I would like to double-check that this `className => class` is indeed a change we want to make for SVG elements. Alternatively, we can leave `className` as is by introducing a special case for it alone.
 Yes, this was intentional.  We could introduce a special case for `className`, but then the behavior would be different from the webcomponent behavior, so we're going to have divergent behavior either way.  This change was intentional, the simple rule "we pass svg attributes through" works well, and we've already released the RC, so let's close this out.

As per our discussion on the team chat, we can provide a codemod to facilitate an easy migration: https://github.com/facebook/react/issues/6213
 I don't remember the rationale here. We don't use class for HTML elements so why should we on SVG when there is a perfectly fine property name?

I interpreted the change as "we don't block other attributes" but we can still make special cases just like we do for HTML.

Web Components is only different because there is no other way and support is busted anyway. Discrepancy between HTML/SVG which have merged into a single integrated standard and are both core features of the platform seems worse than discrepancy between the core features and a feature that nobody really uses.

I don't really like that we have this discrepancy without a clearer story around it (and without a major section describing in the blog post).
 > ...  but we can still make special cases just like we do for HTML.

Special cases suck.  You have differences anyway because React html elements use camelCase and svg attributes use kebab-case, among other things... unless you want to write some fancy logic to try and normalize the differences and automatically apply transforms to recapitalize and insert hyphens.  But it's pointless to perform computation and special-case checks when you could just pass them through.  It's much cleaner to have a simple "pass-through" rule for svg, and we should apply that rule consistently.

EDIT: Actually, you couldn't write an automatic rule, because SVG is inconsistent about the names of their attributes.  You have camelCase attributes like `pointsAtY` and `surfaceScale`, but you also have kebab-case ones like `underline-position` and `unicode-range`.  You're not going to be able to get around the inconsistencies between SVG and HTML.
 Looks like there is more discussion here.
 > Any chance this might be reverted before official v15.0.0?

We're exploring a couple options. I think at the very least we'll make sure `className` continues to work. The extreme option might be to backout all of this SVG work and get us back to 0.14 support. That's obviously not ideal but is available to us. I think I'm personally leaning towards backpedaling on the "pass everything through" approach and expand the list of supported attributes in the whitelist. This would mean we'd no longer support hyphenated attributes and would go back to the camelCase mapping. I don't see this as a huge problem as it maintains current (0.14) behavior, matches what we do for HTML attrs, and is something we have to continue doing for a handful of attributes anyway for the namespaced attrs (`xlink:href`).

> Renaming `className` &rarr; `class` for HTML elements seems fine to do in the long run ... but that sounds like a much bigger breaking change

Maybe we could do it but it definitely is a very big change. We might be too far down this path and honestly by the time we feel ready for it, we might all be using abstractions on top of the DOM (something like [react-native-web](https://github.com/necolas/react-native-web) for example), so it might not matter as much. I agree with what I think you're getting at though - we should probably do it all at once and not live in this hybrid world where SVG uses one pattern and HTML uses another.
 Yea I think it would have to be totally complete.

On Wednesday, March 9, 2016, Jason Killian notifications@github.com wrote:

> I think I'm personally leaning towards backpedaling on the "pass
> everything through" approach and expand the list of supported attributes in
> the whitelist.
> 
> Would the list be fairly complete? I know in previous iterations of React
> it was missing quite a large number of tags/attributes. It's tough as just
> one or two of these missing can make things a lot more painful in your
> application's code. That being said, definitely agree with this:
> 
> not live in this hybrid world where SVG uses one pattern and HTML uses
> another.
> 
> ‚Äî
> Reply to this email directly or view it on GitHub
> https://github.com/facebook/react/issues/6211#issuecomment-194677965.
 Closing as #5714 was reverted in #6243.
  Cool, doing a bit of planning so not merging this very second but I think we should get this into 15.
  `data-reactid` is gone for client-side rendering, but still exists for server-side rendering.  This is expected behavior.

However, `<!-- react-empty: 1 -- data-react-checksum="1336804998">` is NOT desired output.  Can you provide an example component/render that generates this output?
 http://jsfiddle.net/k9u4r28j/
 > ended up confirmed it's a false alarm

But, to be clear, this is a valid bug in React.
 Right, but the use case that @dittos mentioned clearly demonstrates the bug.

It's necessary for tracking separating the text elements in order to apply updates/diffs.
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 Thanks!
  Don't merge. I'll just push so the tagged commit is in mainline history.

But if anybody who's watching has any quick comments, speak now
 Good call @cody. I'll make sure that gets into the final notes.
  In general, React is pretty fast out of the box.  My guess is that you're over-thinking this whole thing.  A couple calls to bind is not going to make-or-break your application.

StackOverflow is the correct place for a usage question like this.
  Thank you for reporting! This appears to be fixed in 15.0: http://codepen.io/anon/pen/ONMeor?editors=1010.

To me, this does not look like a high-priority issue so I would suggest to work around it by using an empty `<div>` until you can switch to 15. I will leave it open for other team members to comment on.
 Confirmed, fixed: http://jsfiddle.net/smw2cLe1/
  Powered by the awesome Algolia :)

![](http://g.recordit.co/0K7lyNgmFz.gif)
 #paternityleave
 - Made it look more like a search box
- Increased the contrast for the row highlight
- Removed the space between the header and the dropdown

![](http://g.recordit.co/PErvKKa9T4.gif)
 @vjeux updated the pull request.
 Let's do it. If we want to tweak anything more we can do it live.
 Ping :)
 Sorry, been out of town. It's all up now.
  Thanks!
  Fixed in future/master: http://jsfiddle.net/5s44Lhg2/
  It exists so React Native, React, Relay, and (possibly) other Facebook projects can share some code between them. This is a matter of internal code organization and indeed should not affect you.
 This should have no external impact, so I'm going to close it out.  Feel free to continue the conversation on this thread.
  Seems fine to me but I haven't been looking at these at all. Seem ok @gaearon?
 Yeah, they‚Äôre great
  Proposed fix for Issue #5468

Added DEV warning for invalid oneOf/OneOfType args
Added typeCheckWarn() func and updated the oneOf/oneOfType tests to cover warn and fail

grunt test passed
grunt lint passed
CLA signed

_This is my first contribution to React, any feedback is appreciated. :)_
 @troydemonbreun updated the pull request.
 @yaycmyk Sorry, I originally hosed everything up when I worked on my master and tried to branch from there.  I am starting over with the PR from another repo, so I hope it will be cleaner. Still learning git/github.  Thank you for your guidance. :-)
  Thanks!
  After staring at the confusing mess that is the synthetic event system today and talking with @sebmarkbage, we're no longer confident that we need the pooling that the system currently uses. GCs have gotten pretty good so we may be experiencing diminishing returns at this point, or maybe losing out on some benefits. We do have to consider that we still support some older browsers who's GCs don't have the benefit of the last several years worth of innovations so it might be premature, but it's probably worth investigating.
 :+1: We can also get rid of `event.persist()` which has caused engineers to bang their heads against walls for years.  I think the value of persistent events shouldn't be underestimated, so I'm in favor of doing this even at the cost of slowing down legacy browsers - so long as things are acceptable in the latest versions of browsers.
 Yes, `persist()` would go away naturally as a result (you'd be beholden to normal GC rules).
 Not all JS GCs work the same. This would optimize for a copying collector in which case this would be essentially free, except it might cause more frequent young GCs which should be fine. If the JS engine chose a different strategy that wouldn't be the case.

It's not about GC in general or whether the GC is optimized or not. It is whether it uses a copying collector specifically or not.
  Fixes #6187 (hacky but it seems to work)
 Not quite, I missed another piece of this...
 I suppose the subclasses should use Object.assign to inherit the static properties like they would on a native class.
 The subclasses don't seem to be the problem though, it's the base class.
 I think this might be setting up the wrong prototype:

https://github.com/facebook/react/blob/36798f7395d9b2e1cfaed988133d11fa88afa8f1/src/renderers/dom/client/syntheticEvents/SyntheticEvent.js#L193

Is that right? I think the second argument there should be extending the prototype of SyntheticEvent which has the right `.constructor` on it.
 Or maybe not. That whole thing is so confusing. Create an issue to rewrite it and drop all the pooling shit?
 Object.create to the rescue. I think it should be safe to use blindly there since we're already guarded to engines that support Proxies.
 @zpao updated the pull request.
  I think this is effectively a request for https://github.com/facebook/react/issues/6481 and https://github.com/facebook/react/issues/1739.  Closing as a duplicate of those two issues.
  This blames to #5939, cc @kentcdodds 

Not sure yet if this is affecting all load events or just ones that are attached directly to nodes (for eg image). But the problem is that when we intercept `set` operations for `SyntheticEvent`s (but not "subclasses" like `SyntheticMouseEvent`), we don't have `target.constructor` @ https://github.com/facebook/react/blob/36798f7395d9b2e1cfaed988133d11fa88afa8f1/src/renderers/dom/client/syntheticEvents/SyntheticEvent.js#L199

Simplest repro: http://jsfiddle.net/ge8b0np9/ (will still fail w/o the load listener)
 Isn‚Äôt this https://github.com/facebook/react/pull/5947 by @koba04?
@kentcdodds‚Äôs #5939 was similar but it didn‚Äôt use `constructor` or proxies.
 oops, yea. Sorry for getting the blame wrong!
  Yeah, it would probably be worth converting the original/legacy-style components into ES6 classes on the context page.  We intentionally don't mention context outside of the context page because context is an experimental feature that is likely to change in future releases.
  Yes, http://jsfiddle.net/30sf8Lh3/

This is a usage question, rather than a bug in the React core. Usage questions are better answered on sites like StackOverflow, as we try to use github issues for tracking bugs in the React core. For this reason, I'm going to close out this issue, which takes it off our radar, but feel free to continue the conversation here (or move it to StackOverflow).
  Fixed in https://github.com/facebook/react/pull/6183
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 When you make your change, use `git commit --amend` and `git push -f`, so there is only a single commit.

Also, please sign the CLA, and then I think we'll be good to merge.
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 @camjc updated the pull request.
 Thanks!
  Duplicate of https://github.com/facebook/react/issues/2642
  Can you create a simple jsfiddle that demonstrates the issue?

Here is a base fiddle you can fork: http://jsfiddle.net/9kungxn4/
 You‚Äôll likely want to look up how to enable logging of unhandled rejections for whatever Promise implementation you are using so that such errors don‚Äôt go unnoticed.
  Can you provide a jsfiddle that demonstrates the issue.  Also, some of these things surprise me (event.keyCode is always 229, event.charCode is always 0, event.which is always 229), can you verify that the native event is correct (eg. native `addEventListener`) on your device.
 I agree, the behavior of the synthetic event sounds weird, given that the other events are not firing.  This is probably a weird side effect of some event api smoothing that we're doing (and apparently we have a bug there that is causing nonsensical events to be fired).  I tried your fiddle on my android (different model/version) and did not get any of the mysterious synthetic events (at least as far as I can tell, I got no events on the android).  I don't have a phone matching the specs you mentioned, so it's a bit difficult for me to debug further on my end.  If you're able to debug on your end and submit a PR, that would be much appreciated!
 This is starting to sound increasingly like a browser quirk rather a bug in the React core.  I suppose one question remaining is: Is this an API quirk that we want to smooth out?
  Agreed it‚Äôs not great. These APIs aren‚Äôt meant to be used from code (at least, not commonly). They are mostly meant to be used from DevTools console. These two articles are really great at explaining how you can use them:
- http://benchling.engineering/performance-engineering-with-react/
- http://benchling.engineering/deep-dive-react-perf-debugging/

ReactPerf is going to change somewhat (#6046) so it would probably be unwise to spend more time documenting the right now.
 > Where are we supposed to place each of the API calls? Some example code would be great.

```
Perf.start();
React.render(<div />, document.getElementById('container'));
Perf.stop();
Perf.printInclusive(measurements);
```

Is that the type of code example you are looking for?  Or what would be a code example that you would want?

Also, @gaearon Those links are great, I'd be totally ok with linking to those docs until we release the new react perf stuff.
 @ffxsam The easiest way is to use the bower builds:

```
<script src="https://fb.me/react-with-addons-0.14.7.js"></script>
<script src="https://fb.me/react-dom-0.14.7.js"></script>
```
 I usually do this (in development only!):

``` js
if (process.env.NODE_ENV !== 'production') {
  window.ReactPerf = require('react/addons').addons.ReactPerf
}
```

somewhere in my `index.js`.

Again, agreed it‚Äôs far from nice, and we need a better story around this.
 Yeah, that‚Äôs the longer term plan.
 @tj

> the react-addons-perf module apparently does not exist once installed

Can you clarify? I was able to run 

```
npm i --save-dev react-addons-perf
```

then put

``` js
window.ReactPerf = require('react-addons-perf')
```

in my `index.js`, and was able to refer to it from the console
 You might want to verify you don‚Äôt have a duplicate React. Maybe there was some version issue and you got a duplicate one? `npm ls react`
 > I see a lot of transactions here like, update attribute, set innerHTML, update styles, set textContent and so on. Do they really happen?

Yes, although AFAIK some `updateAttribute`s might be avoidable: #5329. Note that a DOM operation isn‚Äôt necessarily expensive so don‚Äôt worry too much about them unless they really seem unexpected.

> In addition, why I can't see the detailed content of "set innerHTML"

The operation name is misleading because it‚Äôs actually using `document.createElement()`. Those are real nodes, and reading their `innerHTML` is prohibitively expensive.
  Also, I think the location of this code seems wrong.  You put this logic inside isRequired, which means it will only fire if the prop is required, but we want to fire in all cases of an incorrectly cased prop.

Also, new warnings should be added via a devtool (as an example, take a look at https://github.com/facebook/react/pull/6121)
 https://github.com/facebook/react/pull/6255 seems closer, so I'm going to close this out in favor of that one.
  Heh, this is half of a diff I started writing (though with some different indentations). I guess I'll put up the rest now :)
  I'm just going to start this as a thread to give everyone notice of work being put into the core reconciliation algorithm.

This will need to include features like:
- Incremental updates in chunks. Maybe even two different versions of the same tree at the same time!
- Back and forth yielding (and prerender) to support layout. This probably also includes a new type of "context".
- Error boundaries that catches updates.
- Make this work with existing tooling such as dev tools, perf tools, server rendering, various renderers.

If you're working on fixing issues with life-cycles or the core reconciliation parts (like child reconciliation) then you might want to be aware that this is a moving target. There might be requests for changes unrelated to the status quo but related to this future work. It might require a lot of context and commitment to be able to contribute to these parts.

However, if what you're fixing is DOM issues, packaging, builds, diffing of props for styles, react native etc. Then it is probably unrelated to this work and you should feel free to send out PRs.
 @timdorr Perhaps ironically, that page is one of the few things that probably won't change.  It's just the details of the implementation (specifically with regards to the flow of control) that will change; the high-level description remains the same.
 @jquense Yep, as always, we will do our best to keep the community informed and involved.  Currently it's all theoretical discussions about scheduling techniques and tradeoffs.  We will certainly continue to post updates as they become available.
 @haohcraft 

I found this method really useful to understand how reconciliation works today: https://twitter.com/dan_abramov/status/699395627264962561
 Some initial work started here: https://github.com/facebook/react/pull/6690
  The `React.DOM` API (not to be confused with `ReactDOM`) does not make sense in the greater scheme of the React API being used in other rendering environments like React Native or GL or <insert anything that isn't the DOM>. The `React.*` API is meant to be universal in that sense. We are never going to add React.iOS.

However, these factories don't actually have any implementation details that rely on actual DOM details, they essentially just map like so: `React.DOM.div = (...args) => React.createElement('div', ...args)`, which is why they ended up in the universal React package and not in ReactDOM.

This would only impact people who don't currently use JSX and have held out using the function call syntax. `<div/>` now (and has for over a year) transforms to `React.createElement('div')`. The conveniences of the function syntax are a big deal for many people (especially coffeescript users and those who are strongly anti-JSX) so we don't want to break anybody, but we would like to migrate them from the core React API.

So the proposal would be a new package which just exports the exact set of things that `React.DOM` currently makes available. It would require some small changes to your code and a new package dependency, but is otherwise identical. Here's what the change might look like.

``` js
// before
{div, span} = React.DOM

// after
{div, span} = require('react-some-other-package');
```
 These also work today:

``` js
const div = React.createFactory('div'); 
// then div(...)
const e = React.createElement;
// then e('span', ...)
```
 Potentially but we would have to change the API so there would be code changes required anyway (`ReactDOM.DOM` is bad). Personally I think it would make more sense in a standalone package. Ideally we'd like to move away from whitelists like this in React and ReactDOM itself. There's nothing stopping you from doing `React.createElement('awesome-new-spec-element')` but maintaining a whitelist requires a new release and it can be versioned independently and be used with different React versions. Adding `React.DOM['awesome-new-spec-element']` would require a new release and would be truly obnoxious to add to every possible version so we'd likely only add it in the next minor version, not backporting. Whereas a separate package could get its own bump without having to pick up other React changes.
 Which `ReactDOM`? `react-dom`, `react-dom/server` or `react-dom-third-party...`? The point is to not have a dependency from a normal component into the specific renderer so that you can switch out the renderer.
 @matystl I really don't think we'll change any APIs or behaviors. The idea is not to make these methods more flexible and support different use cases, simply to move them from their current location. People are welcome to use hyperscript or similar if they want other APIs instead.
 I would probably move it to a separate project in the org, but nothing for anybody to do at the moment.
 Yes however that depends on the `react` package (which we wouldn't directly, would probably be a peerDep?) and it supports adding extra properties (eg isRendered) which we also wouldn't do.
 I don‚Äôt have full context on this so I can‚Äôt give a good reply. Here‚Äôs what I know about this:
- We still have a concept of ‚Äúowner‚Äù which is a dynamic thing set by `createElement` that relies on global state about the currently executing `render()` method. I think the plan is to get rid of it (#6350) but that would mean deprecating string refs. Until `_owner` is gone we can‚Äôt generate objects all the time without screwing up string refs.
- We added a certain level of protection against XSS in user input in #4832 which tags every ‚Äúsafe‚Äù element coming from the code (as opposed to a user JSON) with a Symbol. These would be a bit of a pain to write by hand.
- There is a [Babel plugin](https://babeljs.io/docs/plugins/transform-react-inline-elements/) that makes JSX output inline objects. However we only recommend it in production because it effectively bypasses any `propTypes` validation or useful developer warnings.
  Sounds like autobinding might be screwing with the factory somehow.  I'm a little surprised that the code you mentioned didn't work, do you have a minimal jsfiddle?

Yeah, we wouldn't recommend disabling autobinding in your copy of React, since that will make your components not interoperable with third party components.  You might try writing your component as an ES6 class, since ES6 classes don't have autobinding.

I'm also curious to hear why you are doing `this.InsideComponent`.  It sounds like some sort of weird nested class logic.  In general, it's probably cleaner to just define another top-level class.

`React.createClass` is mostly legacy at this point, so I don't think we're going to make major changes to the autobinding code at this point.  However, I would be curious to hear what you discover.
 They can live in the same file without having a nested class arrangement.
 > I need them to be dynamic

@mariusrak, you can always store the state in the parent and pass it down explicitly to the child.  In general, anything that can be done with nested classes can be done without nested classes.  I think nested classes (like inheritance) are a bit of an antipattern anyway.  I would recommend finding an alternative structure for your code.

`createClass` is mostly legacy at this point, and we generally aren't making large changes to the way it works.  You're welcomed to submit a PR if you'd like, and we'll take a look and decide if it makes sense to merge based on the scope of the change, but I don't think this is something we'd fix ourselves.  For this reason, I'm going to close it out.

Feel free to continue the discussion on this thread.  In particular, I'm curious to hear if ES6 classes solve your problem (since there is no autobinding) or if you figure out a potential fix to the autobinding code that we could integrate into React.
 @mariusrak No, there are no plans to deprecate `createClass` in the near future.  It's just in maintenance mode, and new development work goes into optimizing ES6 classes and stateless functions.  Most of those features you mention (mixins, autobinding, etc) were intentionally omitted from the ES6 API after we gained a lot of experience with those APIs and determined that they were not good patterns.  Mixins make it much more difficult to maintain your code because things get injected sideways, autobinding leads to issues exactly like the one you're describing in addition to many other edge-case issues.  The recommendation is still to upgrade to ES6 classes, since we believe it is a better API, but `createClass` will continue to work afaik.
  You should not rely on the name of a component, we use it for debugging information/messages only.  It is unreliable at best, and may behave differently in production.

@bORm it sounds like you are using it to determine styling information.  We recommend inline styles, or explicitly passing the css class name.

If you have other use cases, I would be curious to hear about them.  I'm going to close this issue because I don't think we want to support people accessing the component names for purposes like this, but feel free to continue the discussion on this thread.
 @bORm You'll want to take a look at https://github.com/facebook/react-devtools/issues/308
 @bORm This is turning into a usage question (since there is already an open issue for solving what you're asking, as per above); we use github to track bugs in the React core and redirect usage questions to other sites like StackOverflow.

The thread I linked mentions that you can set a static property on the child components, using a transform that supports static class properties, or by setting the property after creating the class:

```
class Child extends Parent { ... }
Child.dispalyName = 'MyChildName';
Child.myName = 'MyChildName';
```

Then you can read that property off the class.

Or, that thread also links a discussion about fixing this in general for React https://github.com/facebook/react/issues/5618#issuecomment-162643284 if you wanted to submit a PR to make React better.

Or you could "fix" the babel plugin to recursively chase down parents in order to determine if a specific component is a React Component and should therefore get a displayName assigned at transform time.

We prefer composition over inheritance, so supporting the inheritance pattern is not a priority for us, but we'd be happy to take PRs to fix or you can utilize the workarounds mentioned in the other thread or you can wait for someone to fix it.  At the moment, I think those are your options.
  Currently, as far as I know there are no plans to add new features to `PropTypes`.
The longer term plan is to use Flow instead (and potentially add optional runtime validation to Flow).

See https://github.com/facebook/react/issues/3510#issuecomment-126126495.
 @JustBlackBird If it was forgotten by accident, it would be `=== undefined`.  If it was passed explicitly but simply has no value, it would be `=== null`.  In the interest of API intuitiveness, It's probably not a good idea to use a non-standard sentinel value.

Proptypes are mostly legacy and in maintenance mode, having been replaced by tools like Flow. My guess is we aren't going to add this, so let's close it out.  We can re-open if our thinking on this matter changes substantially.

It is worth noting that proptypes are just validator functions.  You can define your own, and share/distribute your own proptypes.  This is the optimal outcome, because people can download the additional proptypes if they find them useful.
  Could you post a plunker or gist with the source example that contains the DOM to which you would want the above warnings to result?
 So, given that fiddle, what would the warning text be?
 Cool, that would be helpful info.
  You want to make use of `super.componentWillUnmount()` in child classes, that's how inheritance works. If you just do that in your code it looks like something weird happens due to your ComposerFunction in there, but if you just create a base component class and extend that, both will get called. See http://codepen.io/anon/pen/RaNzBX?editors=0010
  This change seems good conceptually.  I like the additional unit tests and docs change.

> If so, are you interested in consolidating that logic so it's applied consistently everywhere it's needed? That's the idea behind the getComponentName added here.

We generally aren't afraid of a little copy-pasting.  Premature consolidation can actually make readability worse (https://www.youtube.com/watch?v=4anAwXYqLG8).  For instance, when reading the tests, I became a little frustrated when I hit `testKeyAccess` because I couldn't see what the test was doing just by reading the test, so I had to scroll up to the definition of `testKeyAccess` only to discover that it was doing something with `opts.name` but I couldn't remember what that was and so I had to scroll around two more times.  Not a huge deal, but something to consider.

Anyway, I could go either way with `getComponentName`.  Single line functions are a little questionable, IMO.  I'd just as soon fix it inline within `ReactElement.js`, especially since we've already pulled out many of the accessors in places like `ReactCompositeComponent.getName`, it means there would only be a few callsites of `getComponentName`.
 Also, you have a few lint errors, try `npm run lint`
 @jmm updated the pull request.
 The "if so" is a little confusing.  How about:

> `.displayName` or `.name` may be used as the name of the component within debug messages if it's a non-empty string. `.displayName` would take precedence over `.name` when calculating the component name.
 @jmm updated the pull request.
 > This is WIP. I want to see if this is something you're interested in and if so I can clean everything up.

Is this now ready, or are there more changes that you wanted to make?

Also, please squash your commits together into a single commit (`git rebase -i`, `git push -f`).
  There are a bunch of these that got missed.  Like `describe('when using parent that uses .createFactory()'`
 :+1: 
 Thanks @mxstbr!
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 @swaroopsm updated the pull request.
 @swaroopsm updated the pull request.
 One nit pick.  Let's also add a few unit tests, and then I think this is ready to go.
 @swaroopsm updated the pull request.
 Ok, looks good to me.  Let's squash these commits (`git rebase -i`, `git push -f`) and I'll leave it open for a day to see if there is any other feedback before we merge.
 @jimfb before you merge, can you read through #1305 which we didn't merge in part due to issues with jest mocking (many mocked things become undefined which was really noisy internally). It would be good to test this internally and see what the ramifications are. (Though that was before we had createWarning so we can now probably exclude this warning from tests)
 @swaroopsm updated the pull request.
 It requires me to do a sync internally, which is blocked because the current build breaks react-art and I need to figure out that dependency.  Will get to this in a couple days.  Thanks for pining, feel free to ping me again if this falls off the radar.
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 Ping @jimfb, does this get in?
 What happens when class mixes mixin `A` which happens to include `null` in _its_ `mixins` field? Does the error message still make sense in this case?
 Sorry, I wasn't very clear. Mixin system lets mixins define _their own_ mixins. So class A can use mixins B and C, and mixin B can use mixins D and E. If D is null, what will happen? I have not tested but it feels like the warning will blame component A. However the real problem would be with component B, and this might be confusing. 
 Whoops, read above as "mixin B". 
 Since we can‚Äôt get any information about mixin names, maybe expanding the error message with something like ‚ÄúCheck the mixins included by the component, as well as any mixins they include themselves.‚Äù
 @swaroopsm updated the pull request.
 Let‚Äôs also add a test for this ‚Äúmixin defines a mixin‚Äù case.
 @swaroopsm updated the pull request.
 @swaroopsm updated the pull request.
 Now the only thing holding this back is @zpao sharing his thoughts on how we want to do branches now that we use major versions. Thank you for your work!
  Normally, our style is to use jsx within tests.  I think some of the tests explicitly aren't using jsx, and that's the point.  Perhaps it would be better to copy-paste that message into each of the tests that doesn't use jsx, since it's easy to miss the note up at the top and having the note at the top is somewhat ambiguous.
 I think I prefer having the inline comment copy-pasted.  A little copy-pasting never hurt anyone (https://www.youtube.com/watch?v=4anAwXYqLG8).

@mxstbr I'd take a PR for this, assuming no one else objects.
  cc @sebmarkbage 

Duplicate of https://github.com/facebook/react/issues/4424
  Probably just want to wget the file from a cdn. Or just update the site to
point at that file on the cdn. Or actually build the Babel 6 version of it.

On Monday, February 29, 2016, BJR Matos notifications@github.com wrote:

> sorry i'm trying to figure it out, i don't have any experience with Rake [image:
> :sweat_smile:]
> 
> snapshot of the problem:
> 
> [image: captura de pantalla 2016-02-29 a las 11 07 08 p m]
> https://cloud.githubusercontent.com/assets/4262050/13417379/5cc18426-df39-11e5-8b41-9bdf296bf5c4.png
> 
> ‚Äî
> Reply to this email directly or view it on GitHub
> https://github.com/facebook/react/issues/6155#issuecomment-190530758.
  Thanks for contributing! I‚Äôm closing because I think this should already be possible for any property, so there is no need to add a special support for `type`: https://github.com/facebook/react/issues/6100#issuecomment-202629895. Please let me know if I‚Äôm wrong!

Cheers.
 Yeah perhaps you‚Äôre right. Since we‚Äôre setting `target` anyway, might as well set the `type`.
I don‚Äôt feel strongly either way. I wonder why this hasn‚Äôt come up before though.

Should  [this line](https://github.com/yaycmyk/react/blob/17f4c15433d1902586a963b5d109c2a075b911d7/src/test/ReactTestUtils.js#L317) have the same addition too for consistency? I don‚Äôt know this code well so can‚Äôt say.

I‚Äôll defer to @zpao on whether we want this.
 Yeah but you‚Äôre not using SimulateNative, are you? I‚Äôm not sure who‚Äôs using it because it‚Äôs undocumented but quite extensive. Maybe Facebook uses it internally; I haven‚Äôt checked.
  ``` js
const Foo = ({ onAction }) => <div onClick={onAction} />;
Foo.propTypes = {
  onAction: PropTypes.function
};

const Bar = () => <Foo onaction={() => console.log('action')} />; // This should warn
```

We currently don't warn for properties that don't exist in the `propTypes` set. I.e. we don't catch typos. This is mostly a legacy artifact and there are many components out there that don't define their full set of props. E.g. when `...` spread is used. Few components also define the `children` prop even though they use it. Warning for all of these might be too much work initially.

However, we can start small. We can find missing properties that have corresponding properties with a different case and suggest that the developer use that instead. This is essentially always a bug.

While it is technically possible to have the same property name with two or more different case, it is considered bad practice to allow both. It causes overhead to test for both in the diffing/rendering. It causes style-guide issues where people have to pick which style to use. It also makes it worth for tooling where search/replace can easily miss less commonly used variants. That's why React only allows a single case, and ideally so should custom components.
  Followup to #6090
- Fixes the extraneous `class=""`
- Adds actual redirect in case those pages are linked to (as best as we can do on GH pages). I didn't use the built-in functionality of the redirect_from gem because it seems to generate pages in the wrong place so had to do the layout manually (also why I used the more awkward `dest_url` key).
 :+1: 
  This is a potentially breaking change.  But it's not something we could warn for, so I'm not sure there is much we can do about that (assuming we want to take this).  I also wonder if the old ordering was intentional - there may be occlusion effects that are desired whereby the new item appears on top of the old.
 Merging this as is would most certainly break a lot of styling assumptions for the users of existing `TransitionGroup`.

To be quite honest I‚Äôm not sure it‚Äôs even worth introducing as a prop. In animations, relying on DOM order is really flaky. Can you please give more context as to why this is important for your app? Ideally you should be able to specify `style={{ zOrder: whatever }}` and not worry about the node ordering at all.
 Some info from @petehunt: the original merge algorithm was more ‚Äúcorrect‚Äù but slower so it was replaced. This could be pluggable if there is enough interest but this would increase the API surface area for something we might not want to commit to long term.

I‚Äôm inclined to close this unless you can show a compelling use case for animation that depends on the specific DOM node order that is hard to implement without it.
 I meant CSS `z-order`. I thought you had problems with stacking items and that the new ones appeared below on the Z axis the old ones visually.

I think I understand what you mean better now. You are not animating the position, just some appearance properties (e.g. opacity?). I wonder if you considered positioning the items absolutely based on their index?

I don‚Äôt think there is any ‚Äúcorrect‚Äù position for the new items. In case of logs it makes sense that new items appear on the bottom, but if your app used a reverse timeline (e.g. Twitter), it would make just as much sense for them to appear at the top.

I agree it would be best to configure it. Can you show which properties you animate so I could better understand your use case? Again, I thought you were positioning items absolutely and animating their position so they enter and exit smoothly but this doesn‚Äôt appear to be the case. 
 Yeah, I meant `z-index` :smile: 

Your suggestions make sense but I‚Äôm not sure we want to keep supporting `TransitionGroup` in this repo because we don‚Äôt actively use it in production and it‚Äôs hard for us to make API decisions without our products actually relying on it.

Let‚Äôs keep this open for now. We‚Äôll figure our plan for `TransitionGroup` and other addons after 15 release and look again at this PR. Thank you for contributing!
  We're not quite done but we're getting ready for RC this week so getting this started.

If you're CC'ed here, I either figured out your name via github or I'm giving you the opportunity to provide something else. Let me know if things are ok as is or if you would like a change.

---
### Is your name OK?
- [x] @karczk
- [x] @Andrew8xx8
- [x] @antoaravinth
- [x] @davidvgalbraith
- [x] @matthewlooi
- [x] @MattijsKneppers
- [ ] @benhalpern
- [x] @conorhastings
- [x] @csbok
- [x] @dortonway
- [ ] @hejld
- [x] @jonathanp
- [x] @bellanchor
- [x] @songawee
- [x] @tmysz
- [x] @JinxiuLee
- [x] @raineroviir (I also pulled your email since Macbook-pro.local didn't seem like what you would want)
- [ ] @yuanyan (your email was also on your profile but didn't pull it)
- [x] @cbrwizard
- [x] @rofrischmann
- [x] @terry3 (pulled name but not email from profile)
### Would you like to specify something more specific (mostly just your GH username in there)
- [x] @puppybits
- [ ] @kryogenic
- [x] @prometheansacrifice
- [x] @Third9
- [ ] @wikinee
- [ ] @thomasp9
- [x] @Zhangjd
- [x] @adraeth
- [x] @zjjw
- [ ] @koh-taka
- [x] @kohashi
- [ ] @leeyoungalias
- [ ] @maxprafferty
- [x] @nakazye
- [x] @translucens
- [x] @shogunsea
- [x] @zwhitchcox
- [x] @iawia002
- [x] @rgarifullin
- [x] @speedskater
 @zpao updated the pull request.
 Looks good, thanks!
 @zpao updated the pull request.
 @zpao updated the pull request.
 @zpao updated the pull request.
 @zpao updated the pull request.
 @zpao updated the pull request.
  What do you mean by "cannot use"?  Do you get an error message?  Do they get filtered out?  Do they fail in subtle ways?  What specifically is the issue?

It would be helpful if you can provide a minimal testcase (in a jsfiddle, feel free to fork http://jsfiddle.net/9kungxn4/) that describes the expected behavior and demonstrates that the actual behavior differs.
 Ah, gotcha.  I nearly forgot React.DOM existed and thus had no idea what you were talking about :).

React.DOM are just convenience wrappers around `React.createElement` for DOM components.  You could always use `React.createElement('filter');` or `React.createElement('foreignObject');`

Browsers are constantly adding new element types, and maintaining a huge whitelist of all of them is out of scope.  Same goes for SVG.  We are looking to move away from maintaining whitelists.  Eventually you will hit an element not on our whitelist and will need to break out and use `createElement` anyway.

For this reason, I'm going to close the issue, since we aren't going to track all the separate elements in `React.DOM` individually as github issues.  If you want to submit a PR for all the SVG elements, I bet other SVG users would appriciate it.

The file you will want to look at for a PR is [ReactDOMFactories.js](https://github.com/facebook/react/blob/master/src/isomorphic/classic/element/ReactDOMFactories.js)
  It's not entirely clear what you mean by "Child elements not showing anything on componetWillRecieveProps and componentDidUpdate."

I tried pulling your code into a jsfiddle, but it doesn't run.  It is missing some setup code, among other things.

Anyway, this looks like it is probably a usage question.  We use github to track bugs in the react core, rather than usage questions. A more appropriate place for usage questions is StackOverflow, so I'm going to close out this issue, but feel free to continue the conversation on this thread or move the discussion over to StackOverflow.

If you can provide a jsfiddle that demonstrates a bug in the React core, we'd be happy to re-investigate.
 This code is still not runnable.  It is missing dependencies:

```
import ReactWizardItem from './react-wizard-items.js';
import categoryStore from '../store/categoryStore.js';
import subcategoryStore from '../store/subcategoryStore.js';
```

Please create a simple jsfiddle that demonstrates the issue by forking this fiddle: http://jsfiddle.net/9kungxn4/
 Sorry, we can't help you without a reduced test case. The video almost helps but there's too much going on with your code. I know it seems like a small change is making the difference and you're right but there's still a lot happening in the other code. This isn't a support forum but where we track bugs with React. Right now we can't discern if what's happening is a bug with your code or React. Try StackOverflow as Jim mentioned or if you can reduce to something much simpler, try again here.
  Your mini project is not minimal.  For example, you appear to be using extensions like `webpack-hot-middleware` which could certainly contribute to lifecycle weirdness.  Your repro is a little too complex to see what's going on at first glance.  It's not clear if this is a bug in React, or if something else is going on there.

If you can create a minimal repro within a master/future jsfiddle, that would help us identify the issue.  I have a base jsfiddle (which includes `React`, `ReactDOM`, and `ReactDOMServer`) that you can use as a starting point: http://jsfiddle.net/9kungxn4/
 Yeah, that's why you're not supposed to use the index as a key if/when you can avoid it.  The index defines the identity.  Step 1 has the first three keys, so those nodes are preserved in Step 2, which is why those nodes don't get mounted in step 2.  The keys are the same, so the nodes get reused.  Example: http://jsfiddle.net/b67vnyn9/
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 Thanks!
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 üëç thanks!
  I don't _really_ consider the old message to be a bug but I suppose this is indeed better. :) Thanks!
  I'm going to close this in favor of https://github.com/facebook/react/pull/6148, because this section is getting super long already.  I went ahead and incorporated this change into that PR.  Thanks!
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 @timwis updated the pull request.
 Thanks! These files are being reshuffled in #6148 so I‚Äôll leave it to @jimfb to pick up these changes manually.
 Ok, pulled this into #6148
  #4999 referred to when adopting server-rendered markup, where previously React _would_ give you a node back. Can we make sure to test that case?
 Sorry this one didn‚Äôt go through! It appears that we merged a pretty much identical PR a couple of days ago (#6305) so I am closing this one.
  I‚Äôm afraid there is already work in progress in https://github.com/facebook/react/pull/6121 ‚Äî it wasn‚Äôt linked to from the issue. I added a link.
 I‚Äôll close since work on #6121 started earlier, is pretty close to being done, and uses the devtool API that we try to use for new warnings. Thanks for contributing!
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 @spicyj Do we still do some cheating with the props object in a React-internal component? I remember us doing something in the past‚Ä¶
 @zpao TopLevelWrapper in ReactMount does but it doesn't use createElement.
 I think it‚Äôs fine to put this between `/*eslint-disable no-proto*/` and `/*eslint-enable no-proto*/`.
It‚Äôs very intentional here and I fail to see the downside.
 This looks mostly good but let‚Äôs fix the linting and the couple of nits I left. Thanks for contributing!
 @richardscarrott updated the pull request.
 @sethkinast Can you give more details? React.createElement already does ignore the prototype chain so it is probably an error to use an object with a prototype. Moreover, React.createElement pulls off the "key" and "ref" properties so you'd also get strange behavior if those were to be present in the models you're using as props ‚Äì and it's not clear to me what you would write if you _did_ want to set a key or ref. We generally suggest putting your model one level lower if you want to pass it unchanged, so props would be like `{model: ...}` and you use `this.props.model`.
 I would recommend putting `toJS()` on the base `Model` class that would be like

``` js
toJS() {
  return Object.assign({}, this);
}
```

Then you can 

``` js
render() {
  return <SomePersonComponent {...spicyj.toJS()} />;
}
```

which doesn‚Äôt seem like a lot of hassle.
 The slightly confusing part about this is that any methods on it wouldn‚Äôt get bound, but seems like this is already an issue with the way you‚Äôre doing it. Maybe `toJS()` could specifically pick non-function properties, if it helps.
 I guess `<SomePersonComponent {...spicyj} />` should probably pass `{...spicyj}` (not just `spicyj`) to React.createElement.
 This wouldn‚Äôt let us warn at all though.
 It would for people calling React.createElement directly. I guess I think of `...` as losing the prototype so that wouldn't surprise me ‚Äì but I don't know exactly what #3435 was originally trying to fix.
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 Ah true, that's what I get for trying to review from my phone üò¨
 Thanks!
  @chicoxyzzy updated the pull request.
 Thanks!
  This seems reasonable. We've inlined `Object.is` in a couple places now (it's short) so we'll probably just do do that again.
 There was some discussion had elsewhere and at least at the time we were trying to avoid another polyfill.

https://github.com/facebook/fbjs/blob/52d3eeb9b156e7ebf578c7fe2b3f1eac76a0fd00/src/core/shallowEqual.js#L20-L32
  This rebases #2271 by @syranide which fixes #1300.

The only change in the rebase is that the file moved.
I haven‚Äôt changed the logic.

@spicyj cleaned up the callsites internally so this should be good.
 Oops, I merged before it linted.
Fixed the lint in 4c804361e089844c65dad251a0a1c7860771b563.
  > It absolutely makes no sense for an extra network request for a library that's 900 bytes gzipped.

It‚Äôs only 900 bytes because it aims to keep the post-split compatibility in 0.14 for a version. Since before 0.14, `ReactDOM.render()` was `React.render()` and we still support this in 0.14 with a warning, the standalone React build had to include ReactDOM to avoid breaking people who haven‚Äôt updated their code yet. Since we don‚Äôt want to duplicate the code, we use this trick with re-exporting a hidden export of `React` from `ReactDOM` so that both old and new code works.

However, in the next versions we don‚Äôt have to support the old `React.render()` anymore, as it has been deprecated. There is an ongoing work on _really_ splitting the two packages which you can track in #5974. After the split, it won‚Äôt be 900 bytes anymore.
 @gaearon True, but even if we move the code around, you are still eating a second round trip for no apparent reason.  In the common case, a user will want `react.js` IFF they're using `react-dom.js` so it makes sense for the default to be that they are packaged together.  There are notable counterexamples (like react-art), but most of those people are using commonjs anyway (which will deduplicate).  It's easy to make the argument that they should be bundled by default.
 @jimfb @prasannavl 

Yeah, definitely seeing your points. On the other hand it feels like having different packaging for CommonJS and UMD might get really confusing: https://github.com/facebook/react/issues/5413#issuecomment-154491150.
 Yeah, but we could maintain that same API by having `react-dom.js` export both React and ReactDOM, as mentioned in that thread.  I'm going to close this thread in favor of reopening #5413.
  That would be awesome. One day we might change the way we do it, but for now just look at the other languages as a pattern and open a pull request. Ideally if you could find another native Spanish speaker who could review the translations, that would help us ensure the quality :) There are a lot of docs and they do get updated so you may want to find a few people to help - working in a branch in a fork that you all commit too / review would be my recommended workflow if you go that route.
 If you are going for Traditional Spanish then yes. If you're going to use a different locale then you'd use the appropriate code (eg `es-AR`).
 Keeping the translations up-to-date is an ongoing effort rather than an actionable issue.  We don't need a separate issue to track each language, and we are tracking improved translation management as https://github.com/facebook/react/issues/5810, so I'm going to close out the issue.  This is a valuable discussion, so please do continue the discussion on this thread or move it to [discuss.reactjs.org](https://discuss.reactjs.org/).
  Yes, you can technically do that however we don't like static getters if we can avoid them. One reason is that it doesn't match the behavior of static properties. With a getter you could do something mutative AND you'll be allocating for each call. You could return different things each time, which doesn't match the expected behavior. Our preferred syntax will be property initializers but that spec has not reached a point in the standardization process where we're comfortable recommending it in our documentation.
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 http://jsfiddle.net/72d51k3q/ :

> Warning: Hello(...): When calling super() in `Hello`, make sure to pass up the same props that your component's constructor was passed.

`arguments` is an array-like object, and passing it to super implies that your props are your constructor's arguments - it's just wrong.  You could make it a spread, but in this case, it's not necessary (you can just call super with no arguments and React will do the right thing).

There are also performance implications to using the `arguments` object, since using it generally results in an allocation that would otherwise have been unnecessary.
 The more nuanced response: You would need to use call spread `super(...arguments)` or apply here to do this properly. However since your component knows that if it will be consuming context, it's ok to keep the super call short. In the case where you are using inheritance and extending a component that uses context, you would need to pass all arguments because that base class might use context. But we strongly discourage ~~context~~ inheritance.
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 Seems good to me, thanks!
  Please do. I'm suspecting an issue on your end as we've never seen hidpi being anything special, but would love to be proven wrong
  @raineroviir updated the pull request.
 @raineroviir updated the pull request.
 @raineroviir updated the pull request.
 This looks great to me! Let‚Äôs hear what @jimfb has to say.
 @raineroviir updated the pull request.
 I looked into the failing unit test, it looks like a valid failure caused by this change (ie. needs to be fixed before we can merge).  That test is not invoking `setState()` during `getChildContext`, but the warning appears to be firing.

I'm not sure why it didn't fail travis (cc @zpao).
 @raineroviir updated the pull request.
 @raineroviir updated the pull request.
 Ping @raineroviir 
 @raineroviir updated the pull request.
 The earlier problem was likely due to `return` later in the method which caused `onEnd*` to be missing. You fixed it correctly by wrapping just the `getChildContext()` call.

Great job! Thank you for following through with this.
 Would you mind squashing it as a single commit?
 @raineroviir updated the pull request.
 @raineroviir updated the pull request.
 @raineroviir updated the pull request.
 This looks great to me, thanks @raineroviir!
  We try to include the name of the object which is currently rendering, so ensuring your components have `displayName` is important. Warnings also throw and catch an error so you can turn on the "pause on caught exceptions" option in your JS debugger and inspect the stack a bit. As for getting the exact line number, #6062 is probably something you want to follow along with. I'm going to close because there isn't anything else actionable we can do that isn't tracked elsewhere.
  Alternatively, I think we could take https://github.com/facebook/react/pull/5680 which would solve this by virtue of the fact that we can just use attributes everywhere, which makes `progress` just work.
  This was fixed by #6089 and the fix should be up on the site in the next few minutes.
  I'm not entirely sure what you are trying to do, but I think you are looking for `unstable_renderSubtreeIntoContainer`.  It is an experimental/unstable feature, so it's undocumented, but you can look through the unit tests and source code to find more info about it.

We use github to track bugs in the react core, rather than usage questions. A more appropriate place for usage questions is StackOverflow. This is a usage question (or duplicate of something like https://github.com/facebook/react/issues/4706), so I'm going to close out this issue, but feel free to continue the conversation on this thread or move the discussion over to StackOverflow.
  We use github to track bugs in the react core, rather than usage questions. A more appropriate place for usage questions is StackOverflow. This is a usage question, so I'm going to close out this issue, but feel free to continue the conversation on this thread or move the discussion over to StackOverflow.

With regards to your question, they should be roughly the same speed, but if you want super-accurate results, you should do your own benchmarking for your use case and data.
  We should warn if you call setState in getChildContext.
 @raineroviir Find the places that `getChildContext` is called, and the places that `setState` is defined, and warn if `setState` is called during `getChildContext`.  I think we already do basically the same thing for calling `setState` within `render`, so you can use that as a thing to copy.
 getChildContext might not be the immediate caller, so that won't work.  You're going to need to set some state before and after getChildContext.  We already warn when users call setState in render, take a look at that code.
 @dan-weaver No, I _think_ we only set the owner in render.
 FYI this is being worked on in https://github.com/facebook/react/pull/6121.
  cc @zpao 
 @kittens updated the pull request.
 `fbjs-scripts@0.6.0-alpha.2` is up
 @kittens updated the pull request.
 @kittens updated the pull request.
 Latest lint build is failing for a different reason - lots of lint failures: https://travis-ci.org/facebook/react/jobs/112105791

Add 

``` yaml
 ecmaFeatures:
   modules: false
```

into our .eslintrc and you'll be ok. There are a couple other new warnings due to changed upstream config too, but that'll fix the bulk of them (and you can ignore the rest if you want)
 @kittens updated the pull request.
 @kittens updated the pull request.
 Thanks üò∫
  suppress, not sur
 @mxstbr updated the pull request.
 Looks good, thanks @mxstbr!
  Appears to work for me on latest/future: http://jsfiddle.net/wwyabmyx/

Does the fiddle above have your desired behavior?
 Ok, thanks, I'm going to close this out as fixed in master.
 The issue is that `href` isn't actually a supported property on `button`s, it doesn't mean anything. So our support for it was focused on the valid case of anchor tags. So we set `node.href`. For anchors the property is linked to the attribute but that's not what happens with buttons. v15 changed the default so we'll use the attribute for more things than we did before. 15 will be stable soon.

Ultimately though this is a case I would generally argue should use `data-*` attributes if you really need to read data from the DOM. Even better would be to write the code so you don't have to write and read from DOM nodes and instead manage some state in the component.
  Correct, fixed in https://github.com/facebook/react/pull/6089
  Thanks @yaycmyk 
  Running `npm test -- --watch` seems to work fine in the React repository.

It looks like you are running tests in your own repository, and may not be providing sufficient test isolation for your tests.  If you can provide a minimal sequence of calls to React which demonstrate a bug in React, we can re-investigate.
 What are you using to mock out the global object / `window`? Whatever you're using is passing [the execution env check](https://github.com/facebook/fbjs/blob/c22a147a39b3e4caa2d85e37634c7343b371b966/src/core/ExecutionEnvironment.js#L14-L18), so it probably just needs to add `navigator` as well.
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 Yeah, I sort of agree that it's a bit confusing to talk about code that you've already seen as if it doesn't exist yet.  But the document is fairly consistent about showing the code and then discussing the thought process that leads up to that code in the present tense.  I don't think we can just change that one sentence/paragraph.  The entire section (and the entire previous sections) all have the same tense.  We would need to think about if/how we want to fix this.  One possible solution is to just move the code fragments to the end of the sections in stead of having them at the beginning.
 Thank you for contributing to the docs!
I agree with @jimfb:

> But the document is fairly consistent about showing the code and then discussing the thought process that leads up to that code in the present tense. I don't think we can just change that one sentence/paragraph.

I‚Äôm closing this particular PR as the feedback wasn‚Äôt yet addressed. However please feel free to open another one that does this:

> One possible solution is to just move the code fragments to the end of the sections in stead of having them at the beginning.

I think it‚Äôs a good solution and will make the most sense here.
  Creating a `ListItem` component is probably at least as much overhead as using bind.  When choosing between those two options, I'd personally just use bind at that point.

One solution is to define (in the constructor): `this.handleClick = this.handleClick.bind(this);`  Then you aren't re-binding with each render.

The problem with binding the event to the component is that the event might be passed up via the component API:

``` jsx
class Bar extends React.component {
    render() {
        return (
            <div>
               <Foo text={"baz!"} onClick={this.props.handleClick}/>
           </div>
        )
    }
}
```

When your app attaches an event handler to Bar, what would be the expected value of `e.component`?  Naturally, you would want it to be an instance of App, but it can't be an instance of App, since React has no way of knowing that App was the ultimate source of the event handler (the handler was just passed along).  Thus, I think the model you proposed is broken in the general case.  You're going to have to use one of the workarounds described above.
  This will require a migration plan including warning for a major release.  For this reason, the PR will certainly require another revision.  But before we invest the effort in updating this PR, let's decide if https://github.com/facebook/react/issues/6103 is even something we would want to do.  I'm going to close this out for now, we can re-open and update after we've figured out if this is a change we would want to make, but my guess is that we aren't going to do this.
  Conceptually, I agree with you.  However, Proptypes are mostly legacy and in maintenance mode, having been replaced by tools like Flow.  It's probably not worth the API churn for a feature that is legacy.
  Duplicate of https://github.com/facebook/react/issues/1739
  @joecritch updated the pull request.
  You can optionally pass `eventData` as a [second argument](https://facebook.github.io/react/docs/test-utils.html#simulate):

``` js
ReactTestUtils.Simulate.change(node, { type: 'change' });
```

It‚Äôs not just limited to `type`. You can add more data to the synthetic event exactly the same way. It will get attached to the event instance with an [`assign()` call](https://github.com/facebook/react/blob/3a4e1dbb5b2957875cab6af11a5e5934e125a0d8/src/test/ReactTestUtils.js#L502).

While there is no official way to also pass a fake `nativeEvent`, you should be able to use exactly the same technique for it:

``` js
ReactTestUtils.Simulate.change(node, {
  type: 'change',
  nativeEvent: {
    type: 'change',
    target: node,
  },
});
```

This would bypass [the normalization code](https://github.com/facebook/react/blob/3a4e1dbb5b2957875cab6af11a5e5934e125a0d8/src/renderers/dom/client/syntheticEvents/SyntheticEvent.js#L62-L77) but you probably don‚Äôt need it in tests anyway.

I am closing this but please let me know if I missed something.
  @joecritch updated the pull request.
 @joecritch updated the pull request.
  What do the red errors say?
 Can you show a little more of the devtools in your screenshot so that the document mode is visible, like this?

![image](https://cloud.githubusercontent.com/assets/6820/13296780/114e7d4a-dae4-11e5-951f-8f5b93e0ffa9.png)

It should say "IE8" and "IE8 Standards". I am guessing that one of those is not properly set.
 I don't know why that would be. You'll probably have to do more digging and figure out what's going on if you want this to be fixed since I haven't heard of anyone else hitting anything like this.
 There appear to be no other reports of this issue, and we don't have enough information to make this actionable.  If we can get a clear repro, we can re-investigate.
  Talked to @zpao about sending a PR for this. We prefer the React team have a discussion first whether they want to merge this.

We ran this transform quite successfully internally at Facebook and I figured it is time to convert React as well. I'm doing a talk in Tokyo (right now!) and figured it is a good time to do it live. Why the hell not?

All the tests are passing. I'm assuming the code in the React repo isn't clowny so eslint and the conservative codemod should handle all cases correctly. This is an RFC. I'm fine with any decision the React team is making with regards to the code style they want to enforce in this repo ‚Äì feel free to either merge or close this. To people following along I will ask them to not start a bikeshedding discussion please but instead recommend running the codemod on your own projects yourself. If you do, please report any issues you find!
- ran: `jscodeshift -t ../js-codemod/transforms/no-vars.js src`
- transform: https://github.com/cpojer/js-codemod/blob/master/transforms/no-vars.js (thanks @iamdustan and @forbeslindesay)
- jscodeshift: https://github.com/facebook/jscodeshift
 My only concern about this is it will require changes to pretty much every existing PR.
 I don't think that is a real issue. It's a one time cost and this should be easy to rebase.
 Just gonna close this for now.
  This looks fine to me ( :+1: ) , just one minor change requested.
 @yiminghe updated the pull request.
 @yiminghe Thanks for the ping!  And thanks for the PR, this looks great!  Might even be able to squeeze it into v15!
  Looks fine: https://jsfiddle.net/47zLu3jc/
 Thanks @AprilArcus!
 Thanks @AprilArcus! To answer your questions:
1. We test these manually. Our automated tests use jsdom which is not 100% consistent with browsers.
2. We've thought about making it scoped per node type but our ultimate goal has been to get rid of this whitelist entirely so we haven't invested in the idea (though there's a PR proposal doing that somewhere)
  Thanks!
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 We may want to keep the markdown pages around in order to avoid breaking links.  @zpao?
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 @joecritch updated the pull request.
 @joecritch updated the pull request.
 Seems good. Where did the icon come from (want to make sure we have appropriate permissions)?
 Ok, I'm cool with this, let's ship it.
 Thanks @joecritch!
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 I think this will be fixed when https://github.com/facebook/react/pull/3456 is cherry-picked to stable.  I'm going to close this, since it's unnecessary/fixed.

EDIT: Looks like it wasn't fixed yet :(.  It **was** fixed, but then the underlying URL changed.  Your fix was good, thanks!
 Thanks! This should fix the issue. The problem was that https://reactjs.github.io/react-magic/htmltojsx.min.js was redirecting to a non-https reactcommunity.org and then is blocked from redirecting to the https version.
  Your pen appears to demonstrate that React IS triggering `onChange` at the correct time.  At least, in my browser (Chrome).  What browser/version are you using?
 Ah, ok, so the event is firing.  It's just that the native event is of a different type.  There is a reason for this...

We listen to the native `input` event because we want it to fire for each character typed:

> Unlike the input event, the change event is not necessarily fired for each change to an element's value.  (details: https://developer.mozilla.org/en-US/docs/Web/Events/change)

So we will sometimes call your change handler when there is no underlying/native change event to pass to you.  Thus the reason we always pass an input event instead.

Why do you want the change event as oppose to the input event?
 > What if you want to handle onChange the way it's done natively, i.e when changing the value by clicking the arrows OR when bluring?

That is very very rarely the intended/desired behavior.  People generally want onChange to fire any time there was a change, which is why we have the current behavior.  You can always add a native listener if you want to bail out and get the other behavior (that's why we have escape hatches).

I'm going to close this out because this is intended behavior, not a bug, and therefore there isn't anything actionable here.  Feel free to continue the discussion on this thread, and we can re-open if our thinking on this matter changes dramatically.
  @koba04 updated the pull request.
  @srph updated the pull request.
 > is this supposed to be live on the doc site yet?

No, v15 has not been released. Our docs are based on v0.14 since that's the latest stable release.
  It's yours @AprilArcus! Let me know if you have any questions.
  I think what you're asking for is https://github.com/facebook/react/issues/1739.  Closing as a duplicate of https://github.com/facebook/react/issues/1739.
   @spicyj I think the opt-out is to grab a ref and set contenteditable attribute imperatively.  Is there a reason we need something more than that?  What did you have in mind?
 It is dev-only.
 Thanks, closing for that one. http://facebook.github.io/draft-js/ is our primary motivation here.
  It is intentional, though I don't remember the reasoning off hand.  Maybe @spicyj remembers

IIRC, It might have had to do with dead code elimination.  By wrapping the warning call in a `__DEV__` block, you avoid invoking a no-op function in an outside module, which makes the code path easier to optimize.  In many cases the `__DEV__` block is necessary anyway because you want to avoid doing work (like the warning deduplication logic, or creating values to print in the error message) if the warning is never going to be shown.
 Yes, this is so the warning() calls can be completely eliminated by the minifier.
  I'm not entirely sure what you are asking, but this looks like a usage question, rather than a bug in the React core. Usage questions are better answered on sites like StackOverflow, as we try to use github issues for tracking bugs in the React core. For this reason, I'm going to close out this issue, but feel free to continue the conversation here or move it to StackOverflow.

With regards to the specifics of your code...
- You mentioned that you are using `addEventListener`, but you should be aware that native events and synthetic events don't play nicely together.  It may work in this case, but the pattern should generally be avoided because you're going to shoot yourself in the foot.
- `valueLink` is going to be deprecated in v15.  My recommendation is that you just set `value` and `onChange` directly.
- I'm not entirely sure what you mean by "for select tag state.selectValue was changed only one time".  If you think you've found a bug in React, please create a simple jsfiddle that demonstrates the issue using an onChange handler, and we can re-investigate.
  Our recommended architecture is [Flux](https://facebook.github.io/flux/).  Facebook uses a backend called [Relay](https://facebook.github.io/relay/).

We use github to track bugs in the react core, rather than usage questions. A more appropriate place for usage questions is StackOverflow. This is a usage question, so I'm going to close out this issue, but feel free to continue the conversation on this thread or move the discussion over to StackOverflow.
  Fixed in https://github.com/facebook/react/pull/3456
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
  We use github to track bugs in the react core, rather than usage questions. A more appropriate place for usage questions is StackOverflow. This is a usage question, so I'm going to close out this issue, but feel free to continue the conversation on this thread or move the discussion over to StackOverflow.
  It is because `Math.random()` is executed when `App` (your `Parent` component's parent, the `Child`'s grandparent) is rerendered.  If you rerender the `App` component in the `setTimeout`, it should do what you want.

Also, we use github to track bugs in the react core, rather than usage questions. A more appropriate place for usage questions is StackOverflow. This is a usage question, so I'm going to close out this issue, but feel free to continue the conversation on this thread or move the discussion over to StackOverflow.
  The code in tutorial.md has changed, as have the highlighted lines.  It's probably worth copying the updated code (including highlighting) from the english version into all the translated versions.
 @nakazye You can just replace the code sample in all the languages.  The wording can be updated later if it is out of date - the examples themselves were refactored a little bit, but are conceptually the same, so it should be safe to upgrade them.
 @nakazye updated the pull request.
 Thanks!  Can you squash these two into a single commit (`git rebase -i`, `git push -f`) and then I think this is ready to go.
 Thanks!  Looks good!
  Duplicate of https://github.com/facebook/react/issues/4457
  At first glance, that actually seems pretty clever!  cc @sebmarkbage @vjeux 
 This is essentially what transition group is about. Except that one doesn't allow an abstraction in the child hierarchy to be in control over the animation. Consequently you want something like this.

However, if you do this, then the parent of this and the parent of that will have to be aware at some stage that this thing is still alive so that it doesn't delete it from its set. That's what "completion propagation" as mentioned here: https://github.com/facebook/react/issues/2928 is all about. To make this work we would also need some kind of completion propagation so that a parent can know when a child is supposed to remain undeleted and when it is safe to remove it from the parent.

Also, what happens if the same key gets restored while this is still happening? Are components above it? E.g. is a parent of this allowed to update its state while this is happening?

While something like this API is certainly something we need, it has a few dependent complexities to make that work.
 @chenglou thought about this a lot (which resulted in [react-motion](https://github.com/chenglou/react-motion)). I found his [thoughts on animation](https://gist.github.com/chenglou/40b75d820123a9ed53d8) quite insightful.
 After some discussions with Sebastian, and thinking on this issue, I agree that this doesn't elegantly handle the edge cases for the reasons mentioned above (classic problem with proposed solutions to animation).  For this reason, I'm going to close out the issue.  But feel free to continue the discussion on this thread, and we can re-open if our thinking changes dramatically.
  It's a little hard to tell without being able to run your code fragment (especially since you didn't tell us what error message/problem you were getting), but I assume you are failing on the `this.getCustomData()` expression.  Assuming that's the case, you should note that a mixin is just an object, so `this` is not accessible, so you are going to have to restructure your code to avoid using `this` in that context.

Also, we use github to track bugs in the react core, rather than usage questions.  A more appropriate place for usage questions is StackOverflow.  This looks like a usage question, so I'm going to close out this issue, but feel free to continue the conversation on this thread or move the discussion over to StackOverflow.
  @benjycui updated the pull request.
 Great, thanks!
  Create ms-unsafe functions in one place, simplifies code.
 I was wary about changing behavior.  I know that `ReactMount._mountImageIntoNode()` invokes `DOMLazyTree.insertTreeBefore(container, markup, null);` and `setInnerHTML(container, markup);` - do those go through `processUpdates`?  Are there others we might miss if we only instrument `processUpdates` for simplicity/performance?
 üëç
  Sure, looks legit, thanks!
  Yes, it is on my todo list.
 @mxstbr Honestly, this probably isn't the greatest first bug, until I first blaze the trail by providing an example that you can replicate.  The desired output would be something like `MyFileName.js:54`

You're welcomed to take a stab at it, but just know that you're probably in for a rough time in terms of a code review.  To get an idea of the structure, you will need to look at https://github.com/facebook/react/pull/5590.  You will want to emit an event when you start processing the element**, an event when you do an operation (I think that event already exists), and an event when you finish processing the element.  Then your devtool can grab the __source off the element (after enabling [react-jsx-source](https://github.com/babel/babel/tree/master/packages/babel-plugin-transform-react-jsx-source)) and use that to display the file/line information as part of the error.

** At least, that would be my first approach.  An alternate approach is to process the element by replicating the control logic that detects invalid props, but that feels sucky because it relies on two totally separate code paths having the same behavior and never getting out of sync.  I'm not sure which approach would ultimately pan out as preferred.
 @mxstbr `onSetValueForProperty` doesn't have access to the element (so it can't access the source), and passing it the element (or source) would require routing the data through the core internal APIs for the sole purpose of warnings and doesn't make sense from a DOMPropertyOperations API perspective (avoiding that was one of the motivations for moving the warnings into the devtools - we want to cleanup the core internals, which currently pass data allover the place).
 @mxstbr We have a whole list of recommended ones here: https://github.com/facebook/react/labels/good%20first%20bug

In particular, these jumped out at me: https://github.com/facebook/react/issues/5839 https://github.com/facebook/react/issues/6049 https://github.com/facebook/react/issues/1858
  http://facebook.github.io/react/blog/2015/10/07/react-v0.14.html#two-packages-react-and-react-dom
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 I think this would be okay since you shouldn't ever end up calling findDOMNode on the server (which is what the registry is for). As I said on Twitter, unlikely we'll do another 0.14 release ‚Äì but I'll leave this open until the next major.
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 @iancmyers can you verify (or @spicyj maybe you already know?) if the issue still exists on v15.
 Should be completely fixed in master since I refactored a lot of stuff.
 I wonder how we can catch these sorts of regressions.
 @iancmyers updated the pull request.
 Process note for reviewers: don't just merge this when/if it's accepted. We'll do that if we need to ship 0.14.8.
 @ljharb low.
 @ljharb Stability refers to us not making crazy breaking API changes.  We've been relatively stable for a while, and wanted to communicate that by bumping the version number (resolves issues like: https://github.com/facebook/react/issues/4998 and https://github.com/facebook/react/issues/5077).  As the community continues to grow (at an astonishing rate), we are becoming more and more focused on stability, and we can expect that trend to continue.  But stability does not imply backporting fixes to old versions - we still expect people to stay up-to-date.  This is already fixed in master and we will be releasing v15 soon.

With regards to IE8 - the post does not imply that we will intentionally break IE8 nor does it say that IE8 will suddenly break catastrophically in IE8.  It merely means we aren't going to invest effort in maintaining IE8.  AFAIK, React still works in IE8 (untested).  If IE8 support is important to you, and you find a bug, feel free to submit a PR and there is a good chance we would take it.  Keep in mind that IE8 is six years old, and IE8, IE9 and IE10 are all unsupported by microsoft.
 I'd be willing to do a 0.14.8. Memory leaks suck and we haven't even shipped 15 yet.
 @iancmyers updated the pull request.
 It's also a long-standing bug that's been around since v0.11 ‚Äì almost two years ago ‚Äì that no one has noticed until now, when at the same time we have it fixed in master as part of a larger refactor.

I appreciate that it can be difficult to upgrade and we can do a 0.14.8 if we are able to get a proper fix for this in. The fix proposed here is incorrect. Specifically:

``` js
var X = React.createClass({
  render: function() {
    return null;
  },
  componentDidMount: function() {
    ReactDOMServer.renderToString(<div />);
    console.log(ReactDOM.findDOMNode(this));
  },
});
```

will now log the `noscript` tag instead of `null`, as it should.

I would suggest instead using `transaction.getReactMountReady().enqueue()` to defer the `registerNullComponentID` call within `ReactEmptyComponent` so that the registration does not occur until `componentDidMount` time (which never occurs on the server). This is slightly slower overall but should fix the issue.
 @iancmyers updated the pull request.
 :+1: Fine with me now. @zpao if you want to cut a release.
 Thank you! This should be out in 0.14.8.
  I think that's an SVG attribute, should work on latest/future.  Try it in this fiddle: http://jsfiddle.net/9kungxn4/

We can re-investigate if you find that it doesn't work in the fiddle.
  @cauburtin http://stackoverflow.com/questions/2614473/does-it-make-sense-to-do-try-finally-without-catch

Also, at first glance, it looks like you're using the development build of React.  Try reactjs.min.js for better performance.  We generally try to avoid try blocks within production codepaths, to the extent possible, for performance reasons.

`_renderValidatedComponent` is using a try block to reset the current owner, which will probably go away when owners go away.
 Yeah, there are a few, but as far as I know they're all necessary.  If you can find one that can be removed, we'd love to accept a PR for it.
  Hiding via CSS is slightly faster, but it has the downside that it means your dom/react tree is bigger, which means your reconciliations are bigger (slower) and your app is using more memory - even when the tree is not visible.  If you can't tell the difference between the two, in terms of performance, we would recommend unmounting (since then you're cleaning up your memory and keeping your tree small).

Ultimately, this is a usage question, rather than a bug in the React core. Usage questions are better answered on sites like StackOverflow, as we try to use github issues for tracking bugs in the React core. For this reason, I'm going to close out this issue, which takes it off our radar, but feel free to continue the conversation here (or move it to StackOverflow).
  I've also observed some memory leaks in firefox, independent of React, but those are clearly browser bugs and not React bugs.  @syranide is correct, we do not want to waste cpu time during unload, as that would degrade performance when navigating away.
  @syranide specifying the `alt={true}` does indicate a usage error, should that be a warning?
 > I'm not saying I disagree, but true is intentionally stringified to "true" in React.

Agree, I'm not saying that behavior should change.  Only that `alt={true}` on an image probably makes no sense.  I actually don't feel super strongly, but I do wonder if it makes sense to add a warning for img.alt props (and probably a bunch of others that are similarly nonsensical).
 Personally, I lean in favor of being strict; they should all be warnings.  Not sure how the rest of the team feels.

Of course, the DOM has a bunch of edge cases which probably prevent it from being a blanket rule for all string props, in general I think the rule holds.
 @petetnt the problem though is that the result of the JSX transform _is_ giving a value. So even though you haven't explicitly provided `true`, the transform adds it. This was a shorthand enabled in the initial JSX transform and carried into Babel.

`<img alt />` becomes `React.createElement('img', {alt: true})`. In React we have no idea if that was intentional or not and we could end up firing a lot of warnings for false positives if we tried to determine intent.

So in order for you to insert a blank string you must explicitly do that. This is going to just be one of those quirks where JSX !== HTML.
  @satya164 and @syranide are correct.

This is a usage question, rather than a bug in the React core. Usage questions are better answered on sites like StackOverflow, as we try to use github issues for tracking bugs in the React core. For this reason, I'm going to close out this issue, which takes it off our radar, but feel free to continue the conversation here (or move it to StackOverflow).
  `console.error = function(message){throw message;};`

Or you can look at how we do it within the unit tests we have in our React repository.

Either way, this is a usage question rather than a bug in the core.  Usage questions are better addressed on sites like StackOverflow.
  Correct, the API has always required that events be persisted if you want to use them outside the scope of the event handler, this is now more strictly enforced.
  I think it would need to be added to the source code too.
 It goes into the UI category if it has the `detail` and `view` properties.  Otherwise, it would probably go into its own category.
  Eeeh, sure, thanks!
  NPM can be a beast the first time you try to use it.  If you're having troubles with the NPM distribution, you can try the guide without NPM: http://facebook.github.io/react/docs/getting-started.html#quick-start-without-npm 
 The NPM section is already getting really long.  The starter pack is designed to help you get started, it has all the working demos and files all pre-configured and ready-to-go.
 I think starting with browserify if you have no idea what it's doing is the wrong thing and we should make that more obvious. Really what I'm thinking we do is have a completely separate page for getting started with npm / browserify / webpack. Those are not prerequisites to get started and end up being an immediate distraction. I have some other issues about this so I'm going to close this one out in the mean time.

@meschbach The step you missed was probably putting that script so that it runs after the `<div id="container">` markup - you need to be able to find a node to render into.
 `$(fn)` is effectively just this:

```
window.addEventListener('DOMContentLoaded', function() {
  React.render(..., document.getElementById('container'))
})
```
 @meschbach

Paul already answered, when he said:

> I think starting with browserify if you have no idea what it's doing is the wrong thing and we should make that more obvious. Really what I'm thinking we do is have a completely separate page for getting started with npm / browserify / webpack. Those are not prerequisites to get started and end up being an immediate distraction. I have some other issues about this so I'm going to close this one out in the mean time.

Specifically, read the last sentence.

We don't use github issues to track usage issues/questions.  Usage questions are better addressed on sites like StackOverflow.
 #5679 was what I was thinking of, though it got closed with a PR by accident (I intended it to be longer lived). Ultimately it's not helpful for us with our hundreds of open issues to track slight variations of the same issue in multiple places so we've gotten more aggressive at closing issues right away if we know it's tracked elsewhere.

You were not wrong to create an issue.
  This is a work in progress on implementing new ReactPerf as discussed in #6015.

Per @sebmarkbage‚Äôs request, I decided to focus on removing dependencies on internal method names. Data will be explicitly passed to the perf tool from React methods, and we will attempt to not rely on the execution order.

Rather than refactor the existing code, I chose to create a new tool side by side so I can compare their output until I‚Äôm confident about correctness. I will later add `PROFILE` feature gates to the calls.
- [x] Add barebones implementation of new ReactPerf
- [x] It should count `totalTime` for flushes
- [x] It should not count `totalTime` twice for nested flushes (fixes a minor bug in ReactPerf)
- [x] It should not rely on the rendering and mounting stack matching parent hierarchy
- [x] Decide how inclusive measurements work
- [x] Add a safety mechanism to avoid accidentally forgetting `endMeasure()`
- [x] It should count exclusive time for every lifecycle method
- [x] It should include `displayNames` and other component information
- [x] It should reconstruct the parent tree
- [x] It should count `counts` and `created` for components
- [x] It should count `exclusive` times for components
- [x] It should count `inclusive` times for components based on parent tree
- [x] Make it _the_ DebugTool
- [x] Make sure teams that replaced ReactDefaultPerf with [wtf](https://google.github.io/tracing-framework/index.html) can keep doing so
- [x] It should implement `printDOM()`
- [x] It should implement `printWasted()`
- [x] Treat stateless components correctly
- [x] Expose the new `ReactPerf` as `react-addons-perf`
- [x] Make sure wasted measurements are useful (something‚Äôs off right now)
- [ ] Do we want to rely on owner?
- [ ] TESTS
- [ ] Remove the old ReactPerf code
- [ ] Introduce the new `PROFILE` gate and put calls behind it
- [x] Consider the implications of using `WeakMap` in `__PROFILE__` builds
- [ ] Expose `React.unstable_Instrumentation`
- [x] Make sure we have new `get*()` methods and deprecated `printDOM()` and `getMeasurementSummaryMap()` are still there
- [ ] Expose whatever React Native needs for systrace integration and enabling `PROFILE`
- [ ] Verify compatibility with React ART (e.g. add [stuff like this](https://github.com/facebook/react-devtools/blob/master/backend/getData.js#L87-L89))
- [ ] Ensure we throw a meaningful error when [`start()` is called inside the lifecycle](http://stackoverflow.com/questions/27279488/react-js-performance-tool-addon-throws-cannot-read-property-counts-of-undefin) or, better, consider providing support for that. See also #2095, #3436, https://github.com/lostthetrail/react-ssr-perf
- [ ] New ReactPerf is correct, tested, has no effect in production, is hard to break accidentally when refactoring, and does not rely on implementation details
 @gaearon updated the pull request.
 @gaearon updated the pull request.
 @gaearon updated the pull request.
 I want to verify whether my understanding of the constraints in https://github.com/facebook/react/issues/6015#issuecomment-182605114 is correct. Here is an example I came up with. @sebmarkbage @spicyj Can you please confirm whether this is right?

## Requirements

Say we‚Äôve got three components. `A` includes `B`, which includes `C` and `D`.
Let‚Äôs see how the Perf tool receives the events over time.

### Regular Recursive Batch

Components mount (or updated) recursively like they normally do. Numbers correspond to the current time, phrases to events the Perf tool receives. The columns show whether the time period is counted towards `inclusive` and `exclusive` scores of the corresponding components.

```
TIME                       A             B           C          D

0 (begin A)          
|                       exc+inc         
1                   
|                       exc+inc     
  2 (begin B)
  |                       inc         exc+inc
  3
  |                       inc         exc+inc
  4
  |                       inc         exc+inc
    5 (begin C)
    |                     inc           inc       exc+inc
    6 (end C)
  |                       inc         exc+inc
    7 (begin D)
    |                     inc           inc                  exc+inc
    8
    |                     inc           inc                  exc+inc
    9 (end D)
  |                       inc         exc+inc
  10 (end B)
|                       exc+inc    
11 (end A)
```

### Funny Batch

We need to make sure that it is easy to introduce out-of-stack updates later. For example, we want a top-level update of `C` to count towards `B` and `A` inclusive counters.

As an extra safety measure, we will absurdly include an update of `A` inside the `C` update. This probably doesn‚Äôt make sense technically but we want to make sure the calculations are _completely_ independent of the stack order no matter how bonkers it is.

```
TIME                      A             B           C          D

11 (begin C)
|                        inc           inc       exc+inc
12
|                        inc           inc       exc+inc
  13 (begin A)
  |                    exc+inc
  14 (end A)
|                        inc           inc       exc+inc
15
|                        inc           inc       exc+inc
16
|                        inc           inc       exc+inc
17 (end C)
```

Note how the `C` updates is still counted towards `A` and `B` `inclusive` time even though they are not on the stack. On the other hand, the `A` update is only counted towards `A` even though `C` is currently on the stack.

## Formal Input

### Relationships

```
A.owner = undefined
B.owner = A
C.owner = B
D.owner = B
```

### Events

```
(0, begin, A)
(2, begin, B)
(5, begin, C)
(6, end, C)
(7, begin, D)
(9, end, D)
(10, end, B)
(11, end, A)
(11, begin, C)
(13, begin, A)
(14, end, A)
(17, end, C)
```

## Desired Output

### Exclusive
- `exc(A) = (2-0) + (11-10) + (14 - 13) = 2 + 1 + 1 = 4`
- `exc(B) = (5-2) + (7-6) + (10-9) = 3 + 1 + 1 = 5`
- `exc(C) = (6-5) + (13-11) + (17-14) = 1 + 2 + 3 = 6`
- `exc(D) = (9-7) = 2`

`exc(A) + exc(B) + exc(C) + exc(D) = 4 + 5 + 6 + 2 = 17 = total`

### Inclusive
- `inc(D) = exc(D) = 2`
- `inc(C) = exc(C) = 6`
- `inc(B) = exc(B) + inc(C) + inc(D) = 5 + 6 + 2 = 13`
- `inc(A) = exc(A) + inc(B) = 4 + 13 = 17`

---

Do these calculations look right? Is this the desired output for these scenarios?
 @gaearon updated the pull request.
 Yea, this looks right. I can't see how steps 13-14 could possibly happen but if it could, then yea, that would be the right call.

The point of decoupling this is so that in theory, someone else could've implemented this perf tool without changing the core. Since you're effectively mapping the names of methods 1:1, it doesn't create much decoupling. If we change the algorithm, you would still have to go change the ReactNewPerf implementation.

A good guideline is to put things that are likely to change together into the same file. So, if we can't decouple, we might as well put all of ReactNewPerf into ReactCompositeComponent etc. to make it easy to refactor.

I understand that this is your later step "It should not rely on the rendering and mounting stack matching parent hierarchy".

One suggestion that I have is that you could, have start and stop timer associated with component time in ReactNewPerf. E.g. `startTime(internalInstance)` and then call `stopTime(internalInstance)` right before the recursive call. Then you call `startTime(internalInstance)` again right after the recursive call completes. You only calculate exclusive time. Then at the end, the summary, you sum them up according to the tree to get the inclusive time.

That way we can restructure the order completely without changing ReactNewPerf.
 > One suggestion that I have is that you could, have start and stop timer associated with component time in ReactNewPerf. E.g. startTime(internalInstance) and then call stopTime(internalInstance) right before the recursive call. Then you call startTime(internalInstance) again right after the recursive call completes. You only calculate exclusive time. Then at the end, the summary, you sum them up according to the tree to get the inclusive time.

We could pass something like `startTime(internalInstance, 'render')`, `startTime(internalInstance, 'mount')`, so that the profiler does not really _know_ about the lifecycle other than that ‚Äúwork denoted by some arbitrary label is being done for this component‚Äù. This makes it easy to add other ‚Äútypes‚Äù of work later that the analysis code can interpret as desired (e.g. ‚ÄúA spent X ms on render, Y ms on mount, Z ms on layout‚Äù). This also makes the profiler API easier to understand because, rather than memorize which methods require Perf calls you just remember to track whatever you think is worth tracking with `startTime` and `stopTime` methods.

Is this what you‚Äôre getting at?
 Even better!
 Ideally the tree information would be exposed through the new devtools API, so perhaps it would be sufficient for the perf tools to use that rather than building another one specifically for perf?
 This looks good so far. I'm going to mark this as `needs-revision` just because we don't want to land it until it is gated behind something.
 > Ideally the tree information would be exposed through the new devtools API, so perhaps it would be sufficient for the perf tools to use that rather than building another one specifically for perf?

Can do that. But it‚Äôs not exposed yet, is it? Meaning I‚Äôd need to add these events to the devtool code myself.

Currently I don‚Äôt have enough context about what kind of information DevTools want. I can start by firing notifications on the devtool for every lifecycle hook with the internal instance. Would that be sufficient? ReactNewPerf would tune in to "mounted" and "unmounted" events and use this as a chance to track the owners.

If I do this, we‚Äôll need to gate devtool API by something like `__DEV__ || __PROFILE__`. Right now it‚Äôs `__DEV__`-only.
 Currently these events are exposed through the devtools (search for `hook.emit`):

https://github.com/facebook/react-devtools/blob/master/backend/attachRenderer.js

(Note that the terminology is a bit confusing there. The `element` refers to an internal instance in React.)

The "backend" part of the devtools is an event protocol designed by @jaredly to be sufficient to track the tree. A good start might be to mirror that API.

> use this as a chance to track the owners.

I think you mean the parents. We use the term "owner" for the thing that created the element which is not the same as the thing mounting it - which is the parent. To track inclusive time you need the parent.

It is unfortunate that tracking the tree might add a lot of overhead but it is probably nice to be able to visualize this in terms of a full tree.

`ReactDOMInstrumentation` is only for DOM specific operations so you'd want to replicate it with a `ReactInstrumentation` file that does the same thing.

The idea is that we can check for `if (ReactInstrumentation.debugTool)` to quickly bailout if nobody is listening.

Currently the devtools work in production mode because it just uses monkey patching. That sucks for optimizations and package size. Maybe a `__DEV__ || __PROFILE__` check would be better.
 Note that a `__PROFILE__` flag might be difficult to add to our internal FB build but if we start deploying the from the npm package internally, that wouldn't be an issue.
 > Currently these events are exposed through the devtools (search for hook.emit):

Thank you, this is very helpful.

> I think you mean the parents. We use the term "owner" for the thing that created the element which is not the same as the thing mounting it - which is the parent. To track inclusive time you need the parent.

Thanks for correcting me. I thought owners should be used for the inclusive calculation but I trust you that parents make more sense here. I don‚Äôt really understand the problem well enough yet to see why.

> ReactDOMInstrumentation is only for DOM specific operations so you'd want to replicate it with a ReactInstrumentation file that does the same thing.

:+1: 

> Currently the devtools work in production mode because it just uses monkey patching. That sucks for optimizations and package size. Maybe a **DEV** || **PROFILE** check would be better.

Since this is all very confusing I‚Äôll finish the implementation first, and then we‚Äôll decide how to proceed with the feature flags both for Perf and tree tracking.
 > then we‚Äôll decide how to proceed with the feature flags both for Perf and tree tracking.

Sure. If you want, you can also just add a temporary constant flag (always `false`). That way you can incrementally land your changes in master so that you don't need to deal with merge conflicts.
 > The idea is that we can check for if (ReactInstrumentation.debugTool) to quickly bailout if nobody is listening.

Currently, in `ReactDOMInstrumentation`, `ReactDOMInstrumentation.debugTool` is always defined because it‚Äôs a thing that lets _other_ devtools register themselves. Is the plan to reorganize this in some way, or do it differently for `ReactInstrumentation`? Otherwise I don‚Äôt see how you could exit early by checking it.
 @gaearon updated the pull request.
 > E.g. startTime(internalInstance) and then call stopTime(internalInstance) right before the recursive call. Then you call startTime(internalInstance) again right after the recursive call completes

So far I haven‚Äôt been able to do this if `startTime(internalInstance)` and `stopTime(internalInstance)` are only called for composites. In this case it seems too hard to tell when DOM components below should have effect on the composite‚Äôs time. We can‚Äôt just ‚Äúexit before recursive call‚Äù because we want DOM component mounts to count towards closest parent composite‚Äôs exclusive time. So we have to thread the closest parent composite instance all the way down so DOM components can call `startTimer(closestParentCompositeInternalInstance)` while they do the DOMy things.

I‚Äôm not sure whether this is the approach you had in mind but it seems like a lot of changes so I want to double-check. Maybe we can use context for passing `closestParentCompositeInternalInstance` in dev. Another thing I dislike about this approach is it offloads logging the time for a composite onto the specific native nodes. So if DOM components do this, we need to teach iOS components to also do this. This feels off.

Alternatively we can change the logic so that _even DOM components_ get their own exclusive time measurements with `startTime(internalInstance)`. Maybe this is what you meant? Since we have the tree information, we should be able to calculate exclusive composite timing from their really-exclusive timings + exclusive timings of DOM components which have those composites as the closest parents. So this would be a three-step calculation based on the tree: first collect all really-exclusive timings, then map DOM components to composites and calculate exclusive-but-not-really-because-including-DOM timings of composites, then calculate inclusive-because-also-including-child-composites timings based on the parent tree. Does this make more sense? In this case other native components such as RN would still have time `startTime(internalInstance)` but at least they would pass themselves rather than some composite they received. Additionally they would have the freedom to specify something else as we discussed (`startTime(internalInstance, 'svg-node-update')` etc).
 I updated the PR to show my current approach with DOM instances reporting their own time.
 @gaearon updated the pull request.
 The mental model I have is that DOM components are just another composite component. Their time shouldn't count to the exclusive time of the composite above them. If it does in the old perf tools, that seems like an artifact/bug rather than desired behavior.

If a composite passes a bunch of children to another composite. Then it would be misleading to include those in the exclusive time of the parent when the owner really created it.

It seems fine to put these calls into the native components.

However, note that I also want to unify the way native components are rendered so that a lot of that wouldn't vary by renderer eventually. The recursion will move into shared code. That way we could put these measurements in a generic way. That would preclude renderer specific tags like `svg-node-update` but simplify each renderer. For now it is fine to put them in each renderer.
 > However, note that I also want to unify the way native components are rendered so that a lot of that wouldn't vary by renderer eventually. The recursion will move into shared code.

:+1: 

> If a composite passes a bunch of children to another composite. Then it would be misleading to include those in the exclusive time of the parent when the owner really created it.

This might be why I thought we should use the owner tree for calculating inclusive time.

> Their time shouldn't count to the exclusive time of the composite above them. If it does in the old perf tools, that seems like an artifact/bug rather than desired behavior.

Interesting. I definitely think that it does in the old perf tools. In the old perf tools, anything until the next composite is on the mounting stack counts towards the previous top composite on the stack.

What would be the point of exclusive metrics than don‚Äôt count DOM components towards the composites? Would information about DOM components be included in the metrics at all?

Currently, ReactPerf groups all information by composites only. Aside from the log of all DOM changes (which goes separately from the inclusive/exclusive tables), ReactPerf currently does not provide you specific information about the DOM components. If we include DOM components in the measurements, would we not have a useless table dominated by `<div>`s with thousands of entries? I‚Äôm not sure. (But I can check.)

Also, if we only measure composites‚Äô own time, what will we be measuring exactly? Time spent in constructor and `componentWillMount`? I would think that ‚Äúmounting‚Äù time for composites as reported by ReactPerf should refer to the DOM work of mounting. What are your thoughts on this?

(Now I decided to do my own homework and [read the docs](https://facebook.github.io/react/docs/perf.html). Apparently what you‚Äôre saying is exactly what we‚Äôve been promising all along:)

> "Exclusive" times don't include the times taken to mount the components: processing props, getInitialState, call componentWillMount and componentDidMount, etc.

So I guess this is what I‚Äôll do then.
 In the current table view you're right that we probably don't want to show DOM components as their own rows. But if we showed it in a tree view it could make a lot more sense. Maybe the ideal is that the visualization lets you enable and disable seeing DOM components when you're actually looking at the data.

We should really include all of those lifecycle methods in the measurements. I consider it a bug that we currently don't. componentDidMount is an example of one that runs later so that could give you an opportunity to make it work for out-of-order reconciliation. Ideally we can also split out the time for each lifecycle method so you can look if you notice a slow component and want to know what piece to optimize.
 Don't forget that the `render` method is the primary thing to measure for a composite. They all have one and sometimes it can be slow.

The DOM operation isn't necessarily the slowest part. Once diffed, the work that is actually touching the DOM, more often than not, is something that you have to do. So it is not very actionable.
 I‚Äôll be working on gathering all information and later we can iterate on different ways to display it.
 Sounds great. :)
 @gaearon updated the pull request.
 @gaearon updated the pull request.
 I‚Äôm measuring all lifecycle methods as well as native node mounts/updates/unmounts and attaching refs.
Am I on the right track?

The next step would be reconstructing the parent tree to calculate the actual numbers.
For now, I only call `onStartTimer()` and `onEndTimer()` without using the results.
 @gaearon updated the pull request.
 @facebook-github-bot chill out
 @gaearon updated the pull request.
 @gaearon updated the pull request.
 This is the granularity I have so far:

<img width="543" alt="screen shot 2016-02-24 at 15 57 04 1" src="https://cloud.githubusercontent.com/assets/810438/13291508/eb20b012-db0f-11e5-9a7d-889fd86a12af.png">

Next step would be calculation of render counts, inclusive times, and aggregation in batches.
 @gaearon updated the pull request.
 @gaearon updated the pull request.
 @gaearon updated the pull request.
 Added an initial implementation of the ‚Äúexclusive‚Äù table. It lacks formatting and is too detailed so I‚Äôll likely aggregate some of these details to be closer to [the information we currently provide](https://facebook.github.io/react/docs/perf.html#perf.printexclusivemeasurements) but I‚Äôll leave the data intact so people can build custom representations.

Note that we currently mislead people by [naming the last column ‚ÄúInstances‚Äù](https://facebook.github.io/react/img/docs/perf-exclusive.png) while in reality it [seems to refer to the total number of `render()` calls](https://github.com/facebook/react/blob/7a3009c2b4560b3db40f7b5a21cd70defe2b8c48/src/test/ReactDefaultPerf.js#L263-L264). The new table should fix this.

<img width="1087" alt="screen shot 2016-02-24 at 21 59 03" src="https://cloud.githubusercontent.com/assets/810438/13302452/dce78656-db41-11e5-82cb-ca2aaf14319e.png">

As I said before I‚Äôll tidy it up and only include the most actionable info but if you have insights regarding what we want to include there compared to [the current version](https://facebook.github.io/react/img/docs/perf-exclusive.png), please let me know. We have [data about every lifecycle hook](https://github.com/gaearon/react/blob/c8c5605eb881237201c8a293a20a7ff19b163a27/src/isomorphic/devtools/ReactPerfAnalysis.js#L54-L80).

cc @spicyj @sebmarkbage 
 @gaearon updated the pull request.
 @gaearon updated the pull request.
 Will this fix #5254? 
 Yes, it will.
 > Ultimately, for deriving certain scenarios such as: render function on D above being called significantly more than setState probably means that the D component is being forced to re-render by its parent B and thus D should implement shouldComponentUpdate or become an SFC

Isn‚Äôt this what `ReactPerf.printWasted()` already tells us (before this PR)? It doesn‚Äôt wrap `setState()` per se but it wraps the updating code, and checks for updates that did not have corresponding DOM operations.
 I think new methods will provide you with lifecycle information via `ReactPerf.get*()` methods, it just wouldn‚Äôt be printed in such detail by default.
 @gaearon updated the pull request.
 I‚Äôm still confused by the existing tables and how to change their output using the new data that we gather. Rather than be faithful to the existing tables, I decided to compile a list of use cases I discovered by talking to people.

**If you have a use case for ReactPerf that does not fit into this table please let me know. Otherwise I can nuke the aggregation you relied on as part of this refactoring.** :sweat_smile: 

## Wasted Render

### Symptom

React component is `render()`ed due to `setState()` inside it or up the tree but the update results in no DOM operations.

### Metric

For any update that did not result in DOM operations, calculate how much total time was spent in `render()` of composites above, and count that time against them. The goal is to find the components that have the best opportunity to short-circuit a tree by implementing `shouldComponentUpdate()` and display them highest in the ranking.

### Treatment
- Find the components that would be most effective at short-circuiting the tree.
- Add `shouldComponentUpdate()` to these components.
- Alternatively, make owners pass less frequently changing props.

### Aggregation

Group information by "owner > component" because owners may pass different children, and thus considerably affect the inclusive time. Owners also sometimes have the ability to make fewer updates.

## Expensive Render

### Symptom

A components slows down the mount or update path by doing expensive calculations in `render()`.

### Metric

How much time (both total and average per call) was spent in the `render()` method for a component. Total time helps find components whose `render()` time matters, and average per call time helps find the outliers that likely do something expensive.

### Treatment
- Find outliers with longer render() times than usual.
- Memoize expensive computations for unchanging inputs.
- Split a heavy component into smaller components and then profile wasted renders.

### Aggregation

Group information by component because if its render is expensive, only the component itself can fix it.

## Expensive Lifecycle

### Symptom

A components slows down the mount or update path by doing expensive calculations in the lifecycle methods.

### Metric

How much time (both total and average per call) was spent in the lifecycle methods for a component. Total time helps find components whose lifecycle time matters, and average per call time helps find the outliers that likely do something expensive.

### Treatment
- Find outliers with longer lifecycle times than usual.
- Remove, delay, or debounce the work in lifecycle methods

### Aggregation

Group information by component because if its lifecycle is expensive, only the component itself can fix it.

## Unintended DOM Operations

### Symptom

A component does more (or slower) DOM work than intended.

### Metric

How much time is spent on DOM operations by DOM components owned by a composite.

### Treatment
- Find the components that directly cause DOM updates but are not expected to.
- Remove or slow down (e.g. Math.round() for CSS floats) the DOM updates.

### Aggregation

Group by "composite owner > dom type" so we can see which composite is responsible for the updates.

## Stack Trace

### Symptom

The initial mount (or update) path is still slow in some particular case and we don‚Äôt understand why.

### Metric

All information that we gather.

### Treatment
- Visualize the call stack as it is rather than reconstructed from the parent hierarchy.
- Display time spent in React code vs time spent in the component in different colors.

### Aggregation

Provide data in a way that would be easy to feed into a tool like [wtf](http://google.github.io/tracing-framework/).

---

In case you missed the notice above:

**If you have a use case for ReactPerf that does not fit into this table please let me know. Otherwise I can nuke the aggregation you relied on as part of this refactoring.** :sweat_smile: 
 @gaearon updated the pull request.
 Yes, all data will be directly available through the API. 
 @gaearon updated the pull request.
 What I want to allow is to (optionally) let people use something like [web tracing framework](https://google.github.io/tracing-framework/overview.html) which has excellent visualization tools, and separately mark time spent in React code (traversal and reconciliation), DOM operations, and user code (lifecycle methods and render). This should be enough to give you a good idea of what‚Äôs taking time.
 Seems like combining WTF-like ‚Äúscopes‚Äù approach with ‚Äútimers‚Äù that measure specific chunks of work gives pretty good results. You get the big picture from ‚Äúscopes‚Äù (which correspond to the call stack) but you can see the details (including out-of-stack stuff like `componentDidMount` and, in the future, incremental reconciler updates) when you want to focus on them.

<img width="670" alt="screen shot 2016-03-02 at 20 35 35" src="https://cloud.githubusercontent.com/assets/810438/13474649/ed99651c-e0b6-11e5-829a-805557566e69.png">
<img width="766" alt="screen shot 2016-03-02 at 20 37 35" src="https://cloud.githubusercontent.com/assets/810438/13474651/f01afe22-e0b6-11e5-93eb-7f6dab79b6c8.png">
<img width="467" alt="screen shot 2016-03-02 at 20 38 12" src="https://cloud.githubusercontent.com/assets/810438/13474654/f2f3903c-e0b6-11e5-9ab9-ab869d9421c6.png">

I will continue with this mixed approach so that we can both have inclusive measurements independent from the stack _and_ nice stack-based visualizations for people who want them.
 If you have an idea for a good way to warn about multiple passes in the console table format let me know.
 Flagging root components for batches sounds interesting and maybe we should do that. Render count or inclusive chart alone don‚Äôt show this well. I was thinking about adding something like `ReactPerf.printBatches()` that would be like

```
Index |  Root component  |  Update Depth  |  DOM operations  | Duration | Is Cascade
----------------------------------------------------------------------------------------
547   |  Story           |  3             |  5               |  4       |  No
546   |  App             |  8             |  0               |  12      |  Yes
545   |  App             |  3             |  4               |  14      |  No
544   |  Connect(Link)   |  1             |  1               |  3       |  No
543   |  Connect(Link)   |  1             |  1               |  3       |  No
542   |  App             |  8             |  1               |  13      |  No
```

This might help find when we‚Äôre spending too much time rendering from the top and might consider moving often changing data sideways and wrapping components in Flux/Redux containers.

‚ÄúCascades Caused‚Äù might help us locate unintended additional flushes caused by `componentDidUpdate()`.
 It appears that WTF looks more useful when we color scopes by component names and keep method names as additional arguments. This was it‚Äôs easier to see exclusive time spent on component‚Äôs own code vs its children.

<img width="856" alt="screen shot 2016-03-03 at 21 58 46" src="https://cloud.githubusercontent.com/assets/810438/13511106/af131ae2-e18b-11e5-96e2-103453183894.png">

<img width="370" alt="screen shot 2016-03-03 at 22 02 00" src="https://cloud.githubusercontent.com/assets/810438/13511124/c2d206d8-e18b-11e5-80e2-eccf77c9fb57.png">

<img width="375" alt="screen shot 2016-03-03 at 22 02 04" src="https://cloud.githubusercontent.com/assets/810438/13511115/bb046d2e-e18b-11e5-86ab-cecc7028adcf.png">
 If anyone is interested, my wtf integration is hidden in https://github.com/gaearon/react/tree/new-perf-shame. It‚Äôs not in this PR because it‚Äôs super clowny and I want to settle on the events useful for visualization first before implementing this cleanly here. To run wtf integration you‚Äôd need to install the extension [from here](http://google.github.io/tracing-framework/), open a React page with `?react_perf`, enable wtf plugin in the address bar, and click "Open" on the bottom right pane injected by wtf.
 @gaearon updated the pull request.
 I pushed a few updates.

@sebmarkbage Can you please take a look to vet the direction?

What I have so far:

1) Timers are separated into lifecycle and reconciler timers.
2) Reconciler timers aren‚Äôt used directly but [a devtool like this](https://gist.github.com/gaearon/089f639467af2bbb6e93) can use them to generate profiles like this:

<img width="835" alt="screen shot 2016-03-12 at 03 35 16" src="https://cloud.githubusercontent.com/assets/810438/13720531/76b255cc-e803-11e5-87a4-82a63d51c18f.png">

This should satisfy @joshduck‚Äôs use case.

3) Unlike reconciler timers, lifecycles are tracked directly by ReactDebugTool and can‚Äôt nest.
4) Flushes are ‚Äúflattened‚Äù in the stats: both beginning and ending of flush are considered to be the reasons to push current operations and duration to the history. This way we don‚Äôt need to worry about counting total duration incorrectly during nested batches.
5) Dev tools have access to an introspection API, and direct access to internal instance is possible but discouraged. I can look into making `react-devtools` use this API and polyfill it on older versions, if you‚Äôd like.
6) Inclusive table is calculated by the parent hierarchy.

<img width="721" alt="screen shot 2016-03-12 at 03 50 57" src="https://cloud.githubusercontent.com/assets/810438/13720612/ab8fcbce-e805-11e5-96a1-328a94534ea8.png">

7) Debug tool hides a few quirks such as top-level wrappers and updates firing after unmounting.
8) Starting and stopping profiler should now be possible during reconciliation (#3389, http://stackoverflow.com/a/29040342). I also plan to add support specifically for doing it inside a lifecycle method too (should be easy with current approach).
9) DOM components are currently measured only by reconciler timers. We can add more granular lifecycle timers to them too if we want to but I haven't found a good use case so I skipped that.
10) The tree devtool is snapshotted right before the flush by the debug tool. After the flush, information about the unmounted instances will be deleted. Nevertheless the IDs of unmounted instances would be the same were those instances re-mounted if we ever support reparenting.

Things that are not here:

1) Tests
2) Measurement of DOM writes
3) Measurement of wasted renders
4) `__PROFILE__`
5) Functional components

I wanted to check with you regarding the current code, and if the approach is fine, I‚Äôll implement the rest in a similar way.
 @gaearon updated the pull request.
 @gaearon updated the pull request.
 @gaearon updated the pull request.
 @gaearon updated the pull request.
 @gaearon updated the pull request.
 @gaearon updated the pull request.
 @gaearon updated the pull request.
 @gaearon updated the pull request.
 @gaearon updated the pull request.
 @gaearon updated the pull request.
 @gaearon updated the pull request.
 @gaearon updated the pull request.
 @gaearon updated the pull request.
 @gaearon updated the pull request.
 @gaearon updated the pull request.
 @gaearon updated the pull request.
 @gaearon updated the pull request.
 @gaearon updated the pull request.
 @lostthetrail I don‚Äôt see any immediate problem with server rendering. Have you had a chance to try using this code with it?
 @gaearon updated the pull request.
 > I have with the original Perf module and it has some issues which I haven't begun to diagnose.

Can you try to give some more details on the kind of issues you got with the old module? Thanks!
 Thanks for the repro. I'll make a note to verify that this works with the new code. 
 Yeah this should work with both old and new versions, I think.
 Yay, this is finally green and not breaking any existing tests!
 Rebased this on top of #6549.
 @gaearon updated the pull request.
 @gaearon updated the pull request.
 @gaearon updated the pull request.
 @gaearon updated the pull request.
 @gaearon updated the pull request.
 @gaearon updated the pull request.
  Duplicate of https://github.com/facebook/react/issues/5742
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 Thanks!
  Please followup on stack overflow - we try to keep this focused on bugs, not usage questions unless they are linked to bugs.

In your case, it sounds like your script is getting inserted just fine and the code is being executed. From a quick Google search, it sounds like you left off the 2nd half of the error.

> Failed to execute 'write' on 'Document': **It isn't possible to write into a document from an asynchronously-loaded external script unless it is explicitly opened.**

Here's a blog post discussing this in relation to adwords (but the lessons are widely applicable): http://lucybain.com/blog/2014/google-adwords-async/. You can find other discussions by searching for your error. I don't think there's anything React specific to really think about here.
  For that 2nd example you're actually returning undefined due to automatic semicolon insertion (good thing to look up if you're doing lots of JS). There's nothing React can do. If you put the opening paren on the same line as return you'll be ok. Going to close out since this is inactionable but feel free to follow up if you have any questions.
  @Sawtaytoes As I have already mentioned to you on other threads, StackOverflow is the more appropriate place for usage questions.  This is most likely an issue with your code/configuration, rather than a bug in the React core.  For this reason, I'm going to close out the issue.  If you have a simple jsfiddle that demonstrates a bug in the React core, we'd be happy to re-investigate.
  `dangerouslySetInnerHTML` expects valid sanitized markup from a library like `marked`.  We may not be able to guarantee that the markup is sanitized, but we can spot many obvious errors which are an indication that markup is unsanitized.  Things like an `&` instead of an `&amp;` as per https://github.com/facebook/react/issues/5223#issuecomment-184373913.  This is also a good thing to warn about because we can catch subtle SSR markup checksum issues.  If the markup doesn't validate, we should warn.

The only tricky part here is that we don't want to have the markup validation library required in the production build.
 `&` is not legal, as mentioned in https://github.com/facebook/react/issues/5223#issuecomment-184373913.
 @syranide I just threw `<html><head><title>myhtml</title></head><body><a href="google.com?foo=bar&bar=noise">link</a></body></html>` into https://validator.w3.org/ and it gave me a validation error, despite the `&` not being followed by a valid entity.

It appears that it may be a function of doctype.  The validator's default doctype is "HTML 4.01 Transitional", for which the above code fails, but there are some doctypes that don't complain.

The mutation case I had in mind was markup that looks like this:
`<!DOCTYPE html><html><head><title>myhtml</title></head><body><div id="foo">&</div></body></html>`

Which Chrome automatically converts the `&` into `&amp;`.  I assumed chrome was mutating the markup to comply with validation rules (like it moves `<tr>` tags into `<tbody>` and does other markup cleanup).  But perhaps that cleanup is just the browser exercising its prerogative.

But you're right, the checksum is validated before the browser touches the markup, so that's a non-issue.  I think I got confused by https://github.com/facebook/react/issues/5223#issuecomment-184373913, which I'm now assuming is just wrong.

I think I'll close this out, since validating the HTML appears to be harder than I was initially thinking/expecting (in part due to doctypes validation differences) and the value-add is less than I was initially thinking/expecting.
  Sounds good.  One nitpick above.  Also, as you mentioned, would be good to update the translated docs too.  Then I think we're good-to-go, assuming there is no other feedback from others.
 @mxstbr updated the pull request.
 @mxstbr updated the pull request.
 Thanks!
  Thanks for the PR!  We have already accepted https://github.com/facebook/react/pull/5997 and will merge once we've determined that it's safe and doesn't require a migration plan.  For that reason, I'm going to close out this PR in favor if #5997 
  We update them every once in a while. Using the latest version is not important to the tutorial.

If you would like to submit a pull request to upgrade the references, we can update them sooner.
  For createElement the generated element has a `type` field which is assigned from the first argument (`Username`). `type` is then used internally to do some optimizations about if we can do an update or if we have to unmount and create a new instance. We just do identity comparison for that so when you are creating a new identity for `Username` on each render, you are making React think it's a teardown & recreate operation, not a simple update. This means tearing out DOM nodes entirely which is especially bad for form elements.

Since you aren't really applying state (in the `this.state` sense) you are really just setting some props. You can use JSX spread to achieve the same thing.

``` js
var partial = { dispatch, state: loginState }
return <UsernameComponent {...partial} key="username" placeholder="username/email address" />
```

We're really unlikely to be able to optimize for your case and it would come at other costs so I think we'll likely just maintain our current behavior here. Hopefully the above provides some insight and you can come up with a different pattern.
  Since this is a discussion topic, and not a bug in the React core, http://discuss.reactjs.org would be a more appropriate place for this discussion.  Other alternatives include reactiflux or IRC.  Regardless, this is not a bug in the core, so I'm going to close out the issue.  Feel free to continue the discussion on this thread, or move it to another medium.
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 Thanks!
  üëç thanks!
  I guess obsoleted in HTML5 is fine. Would you like to add it?
 Pretty much. The important thing to check is what updating the value would look like (even if your case is server rendering). My common way to test this is to load up a data uri and then manipulate the DOM via JS to set the property/attribute and then see what works.
1. Visit `data:text/html,<!doctype html><head profile="foo">`
2. Open console
3. use

```
var h = document.getElementsByTagName('head')[0]
h.profile // undefined
h.getAttribute('profile') // foo
h.setAttribute('profile', 'bar') // dom is updated in inspector
// can do the same with reading/writing h.profile but see that it doesn't work
```

So the result of that is that `MUST_USE_ATTRIBUTE` is right and that your diff ends up being pretty identical. You can leave out the docs update though - we try to batch those changes up at release time.
 @saiichihashimoto We recently changed from using `properties` to using `attributes` by default for a whole variety of reasons.  You can learn more about properties vs. attributes here: http://lucybain.com/blog/2014/attribute-vs-property/

Most values can be updated via attributes, so you can set the value to null.  Some html elements must be updated using the property instead of the attribute (otherwise, the changes won't take effect by the browser), in which case, the value must be `MUST_USE_PROPERTY`.  You should verify in browsers (especially something like IE9, which tends to behave weirdly) to verify that the browser is honoring the new value.

In this case, I'm not entirely sure if the browser even does anything with the `profile` attribute, does it?  Does the presence (or lack thereof) actually influence browser behavior at all?  If not, then using attributes is certainly fine.
 @saiichihashimoto Right, but if browsers don't actually use it, then it's almost certainly sufficient to set it as an attribute and not a property.  Therefore, to answer your question, `null` is probably the most appropriate value.
 Ah, my mistake. I forgot we switched to attributes by default. As I mentioned before with my test "code", the property doesn't work so we need to use attributes.
  @sambev updated the pull request.
 Looks good, thanks!
  Probably affects unstable_subtree also.

I don't think we need a fix this for the v15 milestone since it was a regression introduced in 0.14 and this is the first we're hearing about it, but it is a valid bug.
 @sambev Sorry, I'm not sure I understand your question.  The PR you linked was merged, but the problem still exists on master.  What specifically would be the fix here?
 Fixed in #6028 and verified in http://jsfiddle.net/uptxgjvd/
  Works in react-future / v15.  http://jsfiddle.net/1kdradt4/
  Yeah, I agree.  NPM is a super complex/confusing piece of software.  If you're not familiar with NPM (I was not when I first got started), it's an uphill battle.  Just installing NPM itself is hard.

> so the guide's missing a .jsx -> .js step.

The react-presets for babel is what does that conversion, so it's all there.  It's just that npm is hard if you've never used it before.  That's why I kind of wish that we made the non-npm instructions more prominent for new users (perhaps by reversing the order of the two sets of instructions).  Anyway, if you scroll down on the getting-started page, you'll find the non-npm instructions, and those are much easier to follow if you're just checking out React for the first time.
  This surprises me, I strongly suspect this is a usage error.  Facebook.com uses React.  Does that mean you are unable to load your news feed within a web view?  Do you have a simple repro?
 You left out the line number and debug info.  It would be helpful if you can jump to the appropriate line number in your bundle, and copy-paste the code (along with some previous and subsequent lines for context) so we can see where it is failing.
 I'm mostly certain we don't have that in React itself. One of the common cases I've seen that happen which is less obvious is duplicate props in JSX. eg `<div data="foo" data="bar" />` will result in a props object with duplicate keys `React.createElement('div', {data: "foo", data: "bar"})`. Be on the lookout for that, maybe enable a lint rule to prevent it.
 It's what I thought: you have 2 `ref` properties on that object. `<input ref="deviceName" ... ref="input" />`.

This isn't a React issue but something with your code so going to close out. We can't actually provide a better error because it's a syntax error that comes from the runtime.
 @zpao Well, babel could warn/throw at transformation time.  And no matter what, babel should probably produce valid/legal output.  Filed: https://phabricator.babeljs.io/T7100
 FWIW: It is valid in strict mode in ES6 but was not in ES5 (I think computed properties was one of the reasons reasons for that change). It's a sticky situation with different runtimes so we'll see what Babel ends up doing. In the meantime I suggest linting, like the [`react/js-no-duplicate-props`](https://github.com/yannickcr/eslint-plugin-react/blob/master/docs/rules/jsx-no-duplicate-props.md) rule.
  Probably not in a remotely performant way.  Performance of module initialization (which directly influences initial load time) would be fatal.  http://jsperf.com/sdfewfgwasd/2

Going to close this out, because...  it's an edge case that people rarely hit, I don't think we can support it in a performant way, and the workaround is to use ES6 classes.

Feel free to continue the discussion on this thread.  We can re-open / re-examine if our thinking on this matter changes dramatically.

That said, I am curious to hear about your use case.  What are you trying to do?
 There's some other discussion in #4450 & #2575 which should give more background. I don't think we intend to make any fundamental changes to the way createClass works so it's really unlikely we'd make setters work.
  This seems like a pretty reasonable first step, will just need to make sure we do the `@providesModule` bit right. Part of me wonders if this is quite worth it yet. Ideally we get to a place where we don't use `@providesModule` in React and then this fits in really naturally.
 @iamdustan updated the pull request.
 @iamdustan updated the pull request.
 I'm inclined to say that we aren't going to get to this this week and it'll miss v15 :( I think there are just a few too many unknowns with npm and how the 3rd package should be depended on and shared (eg, I would expect with npm2 that react and react-dom each install their own react-current-owner, which would not be what we want). I think requiring that react-current-owner becomes installed by apps would really awkward.
 > Based on my understanding, it would be more expedient and less invasive to the React codebase to deprecate and eventually remove the CurrentOwner concept than attempt to continue finding a way to create another package for React consumers to depend on.

Agreed. I‚Äôm closing for this reason. Thanks for checking the viability of this!
  cc @spicyj because he wrote the original comment.
 I don't recall the history ‚Äì it is a mix between this repo and RN. We don't currently use it in the browser but it is supposed to work.

Going to close this out since we don't really support it but if you send a PR (with unit tests) that makes it more compatible then we can probably take it. It looks like we set `.touchHistory` on the emitted events and we don't want to lose that (in RN at least) though.
  This is a very initial pass at the easy case of updates (updates that pass through the error boundary by themselves).  There are likely bugs and more testing is needed before this can be merged.  Don't feel obligated to code review yet, posting mostly for visibility.
 @jimfb updated the pull request.
 @jimfb updated the pull request.
 @jimfb updated the pull request.
 cc @spicyj @sebmarkbage I think this one is now ready for review.
 Ping @spicyj @sebmarkbage 
 Do we need to make a branch cut before we land?

> On Feb 26, 2016, at 12:01 PM, Jim notifications@github.com wrote:
> 
> Ping @spicyj @sebmarkbage
> 
> ‚Äî
> Reply to this email directly or view it on GitHub.
 That's probably a question for @zpao, I don't care either way (before/after branch cut).  I just want to make forward progress on this diff, so we should do a CR either way.
 There are mutations that happen during this phase.

https://github.com/facebook/react/blob/master/src/renderers/shared/reconciler/ReactMultiChild.js#L325

These are not applied to the underlying nodes until later:

https://github.com/facebook/react/blob/master/src/renderers/shared/reconciler/ReactMultiChild.js#L357

This will definitely leave the system in an inconsistent state.

I guess the strategy here is that we'll not touch the DOM nodes during the safe unmount and therefore it doesn't matter.

Can you add some tests that ensures that child removals, additions and reordering works when the error is thrown in the middle of all that?
 Tests and the null thing.
 Added some tests - let me know if they don't test what you wanted.  Also responded to the null thing.
 @jimfb updated the pull request.
 @jimfb updated the pull request.
 Works great!

![](https://s3.amazonaws.com/f.cl.ly/items/1W1x1S3X2Z1J2x3k3j2h/Screen%20Recording%202016-04-19%20at%2001.22.gif?v=2dc8de4f)
  Not a typo.  Different markdown parsers behave differently.  This is targeting the markdown parser used by our docs generator.  You can see that it appears correctly on the reactjs.com documentation.
  https://discuss.reactjs.org/t/documentation-of-props-children-type-is-inconsistent-opaqueness-etc/3178
 What is our official position on this now?  Do we still believe that children is opaque?

If so, you probably shouldn't say (online 245 of the tutorial) that the type is a string.  You should emphasize that we don't know the type of the object, and should not assume that it is a string.

Also, the discuss.react post specifically called out https://facebook.github.io/react/tips/children-props-type.html - which should probably be replaced in its entirety with the new note box from ref-01-top-level-api.md and a link to the children utilities.

Alternatively, if we're backtracking on our position that it's opaque, we should do the reverse and clean up the places where we're claiming that it's opaque.
 cc @sebmarkbage 
 Ok, let me see if I can clarify the messaging here and then we can see if we need to change the docs to line up:
- The type of `this.props.children` is whatever your component's `propTypes` says it is.
- We recommend that most of the time you use the general `ReactNode` type for your `this.props.children`.
- `ReactNode` is not opaque but it is a very broad type which requires a lot of pattern matching to get right so you are expected to use helpers to operate on it.
- JSX's child position behavior is predictable. Meaning that `<Foo>Bar</Foo>` is valid for `Foo.propTypes = { children: PropTypes.string }`.
 We also have:

> ./04-multiple-components.md:`Parent` can read its children by accessing the special `this.props.children` prop. **`this.props.children` is an opaque data structure:** use the [React.Children utilities](/react/docs/top-level-api.html#react.children) to manipulate them.

(I did NOT add that emphasis)

And:

> ./10.6-create-fragment.md:The return value of `createFragment` should be treated as an opaque object; you can use the `React.Children` helpers to loop through a fragment but should not access it directly. Note also that we're relying on the JavaScript engine preserving object enumeration order here, which is not guaranteed by the spec but is implemented by all major browsers and VMs for objects with non-numeric keys.

@sebmarkbage Your new messaging is different from our old messaging.  I'm not saying it's bad, but I think we need to be intentional about this change because it has real implications about our ability to change the types later, especially in light of our discussions about supporting non-zero-indexed children.  Let's hold off on this diff until after our weekly team sync.
 This isn't high enough priority for me right now to justify putting in the work to find something everyone is happy with since @jimfb seems to feel strongly about this.
  There are a few concerns that I heard about `ReactPerf`, in the order of importance:
- (1) It is gated by `__DEV__` but React Native wants to have a way to enable it in production builds and pass the accumulated info into systrace
- (2) It is often broken by refactoring
- (3) It appears generic but depends on specific module and method names
- (4) It has some obscure bugs that are hard to fix because of the coupling
- (5) The `console.table()` visualization is poor
- (6) We are working on a new DevTools API so they should align

If I‚Äôm mistaken here, please let me know!

In #5306, we started introducing a new set of APIs for first-class instrumentation. It makes sense that we transition `ReactPerf` to the new API, and fix some of these issues while we‚Äôre at it.

I talked to some¬†people on the React Native about this. What I understand so far is:
### ASAP
- We want to remove `ReactPerf` function wrapping completely (addresses 2, somewhat mitigates overhead from fixing 1)
- We want to create a devtool like `ReactDOMDebugTool`, e.g. `ReactPerfTool` (addresses 6)
- Unlike `ReactDOMDebugTool`, `ReactPerfTool` will _not_ be gated by `__DEV__` (addresses 1)
- `ReactPerfTool` will have `startMeasurement()` and `endMeasurement()` methods for profiling functions (addresses 1)
- It can have more granular methods for specific parts of React lifecycle if needed (addresses 2, 3, 5)
- Calls to `ReactPerfTool` will be gated by a runtime flag, e.g. `ReactPerfTool.isActive` (addresses 1)
### In the Future
- Rather than reach out into the profiled functions, `startMeasurement()` will accept arbitrary arguments (addresses 3)
- We would separate generating user-meaningful data from its accumulation so it would be easy to test (addresses 4)
- (Bonus) We can use a noop decorator + Babel plugin to insert `if (ReactPerfTool.isActive) ReactPerfTool.startMeasurement()` and `.endMeasurement()` calls (mitigates pain and potential breakage from addressing 1)
- (Bonus) Rather than `console.table()` API we can provide a component that interprets that data and displays it in an overlay, both on web and native (addresses 5)

The decorator + Babel plugin part is the one I‚Äôm not sure about because it would involve complicating tooling. On the other hand, it will allow adding performance measurement to any functions in the codebase without risking having early `return`s, missing `endMeasurement()` calls, and similar breakage during refactorings.

The first actionable step, in my opinion, would be to remove the function wrapping and the `__DEV__` gate from the existing `ReactPerf`, and replace `measure()` with explicit `startMeasurement()` and `endMeasurement()` calls gated by `ReactPerf.isActive` wherever it is used.

We would still pass the function as an argument so we don‚Äôt have to rewrite everything at once, but this would give the RN team more freedom, and unlock future refactorings. We can also combine this with introducing decorator + Babel transform if this is the way we want to go, to avoid adding manual `startMeasurement()` and `endMeasurement()` calls all over the place.

Does this make sense? What have I missed?
 An existing issue is that AOP style measurement isn't always very convenient because when we wrap recursive function calls it is difficult to measure the "self time" of a component.

Another issue is that the numbers are intuitive but not necessarily very actionable. That would probably require some more thinking around how we can design this.

Turning `measure()` into `if (ReactPerf.isActive) { startMeasurement(); }` seems like a good first step.

However, I'd like it even more if we did something like:

``` js
var isPerfActive = ReactPerf.isActive;
function foo() {
  if (isPerfActive) { startMeasurement(); }
};
```

That avoids an indirection in the runtime look up at each callsite.

This becomes a constant so that the JIT or compiler can safely exclude these code paths.

The downside is that you can't turn profiling on/off while it is already running. I don't think that is a required use case though.

Another alternative is that we simply build three different builds of PROD/PROFILE/DEBUG and then the packager can choose if it wants to profile in production or not.

In that case maybe we should have:

``` js
if (__PROFILE__) { startMeasurement(); }
```

or something.
 The points I care most about are:

A) ReactPerf should not reach into internal properties, event and component names etc. Everything in needs should be colocated with the code so that we can change implementation details without breaking it. One way to achieve that could be to fire events and then have the tree reconstructed by the perf tool. However, it should also not rely on execution order of those events. E.g. we will probably want to render children in a different stack frame from the parent. Therefore the inclusive/exclusive perf measurement of a parent can't depend on a child rendering within the stack of the parent rendering.

This might mean that the React code needs to have some high level knowledge about the use case rather than just spewing out events.

B) We should not make things slower because we add profiling. Not even temporarily. We need to have a way to disable it completely from day one.
 > Turning measure() into if (ReactPerf.isActive) { startMeasurement(); } seems like a good first step.

I‚Äôm on it then. :+1: 

> The downside is that you can't turn profiling on/off while it is already running. I don't think that is a required use case though.

@tadeuzagallo told me that this is a use case that RN team has. I don‚Äôt have the details but maybe he can provide them.

In the meantime, I can do as you suggested first. Then I can measure the perf impact from making it a lookup, and we can reconsider if the use case is compelling enough.

> Another alternative is that we simply build three different builds of PROD/PROFILE/DEBUG and then the packager can choose if it wants to profile in production or not.

One of the reasons RN team wants a revamp of ReactPerf is that there is unnecessary friction in getting the trace results. Adding another build would increase the friction compared to a runtime switch. (Even a runtime switched computed at start time would amount to less friction.) Therefore I‚Äôm going with the runtime flag, and we can reconsider later if we find good reasons to do a separate build. (For example, if performance regression from having a flag will turn out worse than our expectations.)

> ReactPerf should not reach into internal properties, event and component names etc. Everything in needs should be colocated with the code so that we can change implementation details without breaking it. One way to achieve that could be to fire events and then have the tree reconstructed by the perf tool. 

I‚Äôll keep in mind that this is a bigger priority than it seemed to me at first. Implementing this would require a significant revamp of ReactPerf. On the other hand it seems to require us to start emitting lifecycle events which may be useful to React DevTools Extension later. I will need to explore how much work it is to remove reliance on the implementation details in ReactPerf.

> We should not make things slower because we add profiling. Not even temporarily. We need to have a way to disable it completely from day one.

We can start by adding a one-time runtime switch and measure. If we regress above noise, we can resort to making a special profiling build. Then if it is very frustrating to the RN team to switch between builds we can make `PROFILE` build the default one for most cases (except shipping to AppStore I guess?).
 The thing that worries me about this is that the usage of this pattern inside React will increase plus when we have less noise and do more inside React (e.g. Layout) it will start being noticeable. This will become very hot paths.

That's why I'm not really satisfied with it being below noise _today_.

It also just seems wasteful if this switch is always off in production builds.

If RN wants an easy toggle, why not just always run the PROFILE build during development? No friction.

> On Feb 11, 2016, at 8:24 AM, Dan Abramov notifications@github.com wrote:
> 
> Turning measure() into if (ReactPerf.isActive) { startMeasurement(); } seems like a good first step.
> 
> I‚Äôm on it then. 
> 
> The downside is that you can't turn profiling on/off while it is already running. I don't think that is a required use case though.
> 
> @tadeuzagallo told me that this is a use case that RN team has. I don‚Äôt have the details but maybe he can provide them.
> 
> In the meantime, I can do as you suggested first. Then I can measure the perf impact from making it a lookup, and we can reconsider if the use case is compelling enough.
> 
> Another alternative is that we simply build three different builds of PROD/PROFILE/DEBUG and then the packager can choose if it wants to profile in production or not.
> 
> One of the reasons RN team wants a revamp of ReactPerf is that there is unnecessary friction in getting the trace results. Adding another build would increase the friction compared to a runtime switch. (Even a runtime switched computed at start time would amount to less friction.) Therefore I‚Äôm going with the runtime flag, and we can reconsider later if we find good reasons to do a separate build. (For example, if performance regression from having a flag will turn out worse than our expectations.)
> 
> ReactPerf should not reach into internal properties, event and component names etc. Everything in needs should be colocated with the code so that we can change implementation details without breaking it. One way to achieve that could be to fire events and then have the tree reconstructed by the perf tool.
> 
> I‚Äôll keep in mind that this is a bigger priority than it seemed to me at first. Implementing this would require a significant revamp of ReactPerf. On the other hand it seems to require us to start emitting lifecycle events which may be useful to Chrome DevTools later. I will need to explore how much work it is to remove reliance on the implementation details in ReactPerf.
> 
> We should not make things slower because we add profiling. Not even temporarily. We need to have a way to disable it completely from day one.
> 
> We can start by adding a one-time runtime switch and measure. If we regress above noise, we can resort to making a special profiling build. Then if it is very frustrating to the RN team to switch between builds we can make PROFILE build the default one for most cases (except shipping to AppStore I guess?).
> 
> ‚Äî
> Reply to this email directly or view it on GitHub.
 > If RN wants an easy toggle, why not just always run the PROFILE build during development? No friction.

OK!

> However, it should also not rely on execution order of those events. E.g. we will probably want to render children in a different stack frame from the parent. Therefore the inclusive/exclusive perf measurement of a parent can't depend on a child rendering within the stack of the parent rendering.

After putting some logs here and there I have a better idea about how `ReactPerf` currently works:

<img width="606" alt="screen shot 2016-02-16 at 15 44 35" src="https://cloud.githubusercontent.com/assets/810438/13081287/35fa0f72-d4c4-11e5-9ec8-ab52e2431033.png">

So what you‚Äôre saying is that it‚Äôs best we don‚Äôt rely on `_renderValidatedComponent` and `mountComponent` happening inside as part of the parent‚Äôs `mountComponent`. The future plan is to allow deferring some child updates to next batches. This would mean that a child could be reconciled during the next `flushBatchedUpdates()` while its parent is not on the stack.

However every change would still happen inside `flushBatchedUpdates()` so we can keep the existing `measurements` result structure where every single entry corresponds to a batch. The only thing we would need to change is to count `inclusive` and `exclusive` times differently without relying on the execution order of components themselves.

Would `inclusive` even make sense in a world like this? If child update is deferred to another batch than the parent‚Äôs reconciliation, does that count as inclusive time towards the parent?

Is my understanding of the issue correct so far?
 Superseded by #6046.
  Switching a component between controlled and uncontrolled is a bad idea, and is prohibited in React 0.15 (you will get a warning if you try).  You will need to convert your nulls to empty strings.
 The warning in 0.15 should help catch situations where you accidentally pass in null.  That's part of why it was added (user accidentally switching between controlled and uncontrolled components)
  Seems to me that this constraint is too tight:

> If the store is not present, I want it to render this way: `<Widget />`

Why wouldn't you just render: `<Provider store={window.MyApp.store}><WidgetContainer /></Provider>`, and have it behave "properly" (by your definition, render without a store) if `window.MyApp.store` is undefined/null.
 And why can the store not be present at the first render?

Could you pass in a fake store?  `<Provider store={window.MyApp.store ? window.MyApp.store : {...}}><WidgetContainer /></Provider>`
 You have a very constrained situation here :P.

> `store` is a required prop of `Provider`, and `WidgetContainer` requires the `store` to be present in `context` since it was created with `connect`.

This is where I would look.  You could write your own Provider that provides a default if the store is undefined (a wrapper around the current Provider).  Or you could write a wrapper around `connect` that provides a store if one is unavailable, etc.

Forcing React to reconcile two elements with different types as the same element is probably not good.  It would be a confusing edge case for people.  Among other things, keys are automatically introduced by things like arrays, so we can't use "just keys" for reconciliation identity.

Anyway, I don't see anything actionable here.  I think the problem is coming in because you are using a bunch of different technologies, including redux and AEM and others, which are imposing semi-contradictory constraints and the challenge ahead of you is to figure out how to mitigate one of those constraints.  I don't think there is any actionable fix within the React core, so I'm going to close out the issue, but you guys can continue to have a discussion on this thread.
 > However, I want to allow the user to interact with my Widget before the store is present. For instance, in my Widget example, they should be able to enter some text in the input and that DOM state should persist when the WidgetContainer is rendered in its place.

Where would this state be stored when there is no associated store? In some ephemeral storage like component state? How would you reconcile the changes there with the real Redux store when it becomes available?
  Try it in this fiddle: http://jsfiddle.net/9kungxn4/

Also, in your fiddle, you're trying to map over a prop that you never pass in, thus the error.
 Ok, I'm going to close, since it's fixed in master.

You could try cherry-picking some commits over, but honestly, I would recommend just waiting for 0.15 to be released.  If you're really in a hurry to play with it, you could try using a future build (eg. http://jimsproch.com/react/future/), but you should be aware that we don't guarantee that it will be stable.
  @mridgway updated the pull request.
 @sebmarkbage @spicyj 
 I'm not sure what the long-term goal is but maybe @sebmarkbage can confirm if this is on the right track.

ReactReconciler should not have any DOM-specific logic in it, so nothing about HTML like you currently have because other environments don't have any analogous concept. I agree with your note in https://github.com/facebook/react/issues/4012#issuecomment-180733460 that the lazytree/reconciler coupling here feels off. I think we shouldn't need to add an additional injection point for this. Maybe we can instead create the children before each parent instance and then pass the mount images (or instances?) to mountComponent so that the component implementation can handle the DOM operations/etc. Passing pre-instantiated/resolved children to the parent moves closer to what @sebmarkbage and I have been talking about. (The order here shouldn't be observable as long as composites still happen in the same order.)
 Sorry about the delay of review. I've been reading it on and off.
 I think it is probably rational for the reconciler to understand native vs composite components. That is also how it would distinguish whether it should instantiate any passed children into components vs. just passing the elements down in `this.props.children`.
  Seems to be working for me but cc @benigeri in case.

(closing because not a react bug)
  @fkling That's exactly what I was going to say :P.  Correct on all points. Thanks!
  @milesj updated the pull request.
 @milesj updated the pull request.
 @milesj updated the pull request.
 Thanks! Let's do it and thanks for sticking with it!
  üëç Thanks!
  Unmounting can take significant and unbounded time when we traverse the tree and call the life-cycles. This is the smallest problem of incremental reconciliation (out of: mount at arbitrary location > update a boundary > mount a boundary > unmount).

The theory is that we can remove the node from the tree first and then call the life-cycles later on during idle time. This means that the refs won't have access to nodes that are in the document anymore so reading any such information would no longer work.

This problem space might also be related to animations. Exit animations want a component/node to exist in the tree for as long as it needs to finish its animation offscreen, asynchronously get deleted from the tree and eventually get cleaned up by calling the unmount life-cycles.
  Does skew not support ES6 classes?  ES6 classes exist largely to allow for language interoperability.  Also, `createClass` is mostly legacy anyway.

With regards to the specifics of your patch, it seems fine to me.  Looks like there is virtually zero perf impact (http://jsperf.com/4v5ye45ybe5u6) so I see no reason not to take it.
 @jimfb if you're going to take the patch then let's be super thorough and see if there are other places that we should be supporting prototype-less objects.
 @ryankaplan Personally, I'm agnostic about the whole change.  If the change is helpful to you/others, and doesn't cause undue code complexity or perf regressions (which it doesn't appear to do), I generally lean in favor of taking it.  However, I'm not the only person on the team.  The value proposition in this case is fairly marginal, so it would be possible for someone to find a reason to block it.  Both your proposals seem fine to me.  My best guess is that we would likely take the change since I don't see a reason to not take it, but I can't make any promises.
 Ping @ryankaplan: did you want to propose a PR, or what's the status on this?
 Yes, there is a linter (see `npm run lint`).  You could also add a bunch of unit tests, which has a similar effect :).
  @shinnn updated the pull request.
 Thanks, but we're not going to do this right now - we'll wait for when we're closer to a release - we will have more fbjs releases before then. The changes in fbjs@0.7 are not strictly compatible so this definitely would not end up back on 0.14.x and I'd like to avoid updating this more than once.
  üëç Thanks!
  @ankeetmaini Can you create a unit test which demonstrates the problem?
 Two weeks with no response/repro, unable to reproduce myself.

```
  it('scroll event should have persist', function() {
    var evnt = null;
    var element = <textarea onScroll={(e)=>{e.persist(); evnt = e;}} />;
    var node = ReactTestUtils.renderIntoDocument(element);
    ReactTestUtils.Simulate.scroll(node);
    expect(evnt.target).toBeTruthy();
  });
```
  @truongduy134 updated the pull request.
 @truongduy134 updated the pull request.
 @truongduy134 updated the pull request.
 @truongduy134 updated the pull request.
 This is a breaking change. We might need a warning upgrade path. We should investigate first to know how likely this is to break and how bad it could be.
 @truongduy134 I'll need to do some checks internally and report back.  It will take at least a few days.
 Yep, we were just looking at the results, it looks like the impact is low enough that we are comfortable with it.  Will require one minor change internally when we sync.
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
  This is almost certainly a usage question, rather than a bug in the React core.  Usage questions are better answered on sites like StackOverflow, as we try to use github issues for tracking bugs in the React core. For this reason, I'm going to close out this issue, which takes it off our radar, but feel free to continue the conversation here (or move it to StackOverflow).
  Context is an experimental feature and is not documented outside of the page on context.  This is intentional.
  As far as software licensing goes, our license super simple and clear.

I am not a lawyer, and as such, can not give legal advice about the specifics of your situation.  My recommendation is that you check with your organization's legal department; they should be able to give you a clear answer.

But in general, yes, you can utilize React in offline commercial products for free, as long as you don't remove the copyright notice from the React code, as per the conditions mentioned in the license file.
  https://facebook.github.io/react/docs/getting-started-zh-CN.html

Duplicate of https://github.com/facebook/react/issues/4614
  The cursor should not jump to the end of the text field when editing text: https://jsfiddle.net/h89zmzp8/

It's `unstable_`, so it probably doesn't need to be fixed before the v15 milestone, but we should get it fixed at some point.

cc @jquense 
  For reference, @solugebefola is talking about https://github.com/reactjs/react-magic/pull/45

If you want to poke someone about a diff, creating a new issue in a different repository is not the correct solution.  A more appropriate technique would be to add a comment to the diff in question (like: "would love to get this merged, can I get a code review on this?  cc @Daniel15"), so people have context.  When leaving such a comment, Cc'ing the people who maintain the repository will help bring it to their attention, in case they missed it (you can tell who those people are by looking at the commit history of the repository).
  Yes, this is just a side-effect of inspecting the DOM node. For 0.14 in dev mode we have a getter on DOM nodes that are refs to support the previous pattern where those refs were React components. The Chrome devtools are reading every property which results in that warning. There's nothing to do about it right now but it will be gone in the next major release.
 @jenriquejr There is no open issue because it is already fixed in master: http://jsfiddle.net/zopwnwtc/
  `refs` != `id`.

I suspect user error.  If you can provide a simple jsfiddle that demonstrates the issue, we can investigate further.
 > `audioElement.currenTime = 0;`

Is it safe to assume that this was just was a typo here but not what your code actually looks like? (I'm assuming so since you said it works fine with `findElementById`)
 @nicolabortignon Are you working on a fiddle to demonstrate this issue?
  Hmm...

¬Ø_(„ÉÑ)_/¬Ø

Try:
`console.log('component did mount. The ribbon\'s width is', this.refs.ribbonSvg.offsetWidth);`
 Hmm.  I get 300 both times, even when I check a full second later (http://jsfiddle.net/r94vwoxr/).

Honestly, I'm not an SVG expert, but this looks like a usage question.  React is responsible for creating the DOM/SVG nodes before calling componentDidMount, but everything I'm seeing here seems to indicate React has done that correctly.  Beyond that, it's up to the browser.

To me, this looks like a usage question, rather than a bug in the React core. Usage questions are better answered on sites like StackOverflow, as we try to use github issues for tracking bugs in the React core, and I don't see anything here to indicate that React isn't doing it's job.  I suspect some kind of race condition, where the SVG nodes are created but the browser is still doing SVG layout or something.  Perhaps there is a command to force SVG to flush, or perhaps it's a bug in chrome, or something.  If you are able to come up with a clear example/jsfiddle that demonstrates a bug in the React core, let me know and we can re-investigate.  Otherwise, I'd recommend asking on StackOverflow.
 cc @sebmarkbage for ideas.
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Yeah, this makes no sense, correct as-is.
 Yeah, I wish we did a better job of making examples runnable directly in the browser.  However, that current code assumes you have a commonjs module system that provides a require function.  It's rather complex to setup (I had a teammate do it for me on my machine).

Anyway, just removing the `require` token might avoid the error message, but it won't make it "work".
  Thanks!
  Mostly for shits and giggles, but I was curious to see how often this would fire on my devserver (ie. curious if it actually creates a migration burden, because code wins arguments).

Fixes https://github.com/facebook/react/issues/5926, FWIW.  This would need lots more discussion before we could actually consider merging such a thing.
 If we were to change `className`->`class`, we would also change `htmlFor`->`for`.  But any such change is clearly in the 'exploration' stage rather than the 'implementation' stage.
 @jimfb updated the pull request.
 @mikeybox No, there is a long road and many discussions between here and there.
  Add `<script src="https://ajax.googleapis.com/ajax/libs/jquery/2.2.0/jquery.min.js"></script>` in your header.

This is a usage question, rather than a bug in the React core. Usage questions are better answered on sites like StackOverflow, as we try to use github issues for tracking bugs in the React core. For this reason, I'm going to close out this issue, but feel free to continue the conversation on this thread or move it to StackOverflow.
  Let's keep the discussion in the main thread, unless this is a distinct alternative proposal (this looks to me like a continuation of the same proposal/discussion).  Having a single proposal being discussed in multiple separate threads is confusing and harder to track.
 PR closed in favor of discussion here.
  To be clear, this is an exception handler intended for exceptions that were thrown only in an event handler, as per discussion in https://github.com/facebook/react/issues/5941

This introduces a top-level API change, which is a huge change.  It clutters up the API, and effectively signs us up to support that function indefinitely (or at least the foreseeable future), despite the fact that it is only interesting for legacy browsers.  At least if we did something like polyfill/override `window.addEventListener`, there wouldn't be an API change.  Not sure which @sebmarkbage would like better though.

Also, maybe it's just early and I haven't had my coffee yet, but the ramifications of the change in `ReactErrorUtils` are not entirely clear to me.  Can you explain?  Specifically, I want to ensure this doesn't mess with the devtools integration (which was the point of that code path) and that this doesn't cause behavior to diverge in dev/prod.
 @RandScullard

> It sounds like you have something in mind with your comment about polyfilling window.addEventListener -- can you give me more detail on how that could provide access to the Error object in window.onerror?

Basically, hook into the event listener registration.  Users don't need to change the way they register for event listeners, but an error which is thrown from a React event handler would result in an a polyfilled call such that onError would have the thrown error even on legacy browsers.

```
window oldAddEventListener = window.addEventListener;
window.addEventListener = function(type, listener, useCapture, wantsUntrusted) {
  if(type === "Error") {
    /* do something fancy here (your ReactDOM.onUnhandledException logic) */
  }
  else oldAddEventListener(type, listener, useCapture, wantsUntrusted);
}
```

Also, the custom fancy logic would need to properly register with `oldAddEventListener` to ensure non-react errors continued to work with the old/expected behavior.

It's a little treacherous, but at least it wouldn't be an API change and is inline with the event smooting/polyfilling that we already do.  Still not sure if we'd actually want to do this, but something like this is a potential option.

> P.P.S. Is anybody looking into the problem with eslint? See the build failure on this PR.
>  Hide all checks

Yeah, we're aware of the issue.  Paul is the best person to handle this, but he is currently in the process of moving 800+ miles away (all his stuff is packed into boxes), so we'll cut him some slack :).  In the mean time, we're just ignoring the lint error.  If someone else wants to take a stab at fixing the linter, I'm sure he'd appriciate the effort.
 We probably still need to call the window.onerror, since that's a global hook that lots of people use for logging production errors.  It's a well-known hook and is used by a lot of systems/people (we can't just break that).

When `addEventListener` is called, the error doesn't exist yet, so it can't "get access".  The point is that it takes the errorhandler that the user provides, and registers it with React using internal API.  When an error occurs within a React event handler, React could check to see if a custom errorhandler was registered, and call that errorhandler with the error information (ie. pretend that window.onerror was getting called).
 That is to say, `addEventListener('Error', ...)` is the API you use to register for an error event (whether it's a native browser error or a react error, both code paths will call the registered function).
 The first approach (overriding addEventListener to subscribe to React errors) feels like the best from an end user experience perspective.  It is treacherous, so we would need to be careful to not break other people's code, but it would allow existing error handling code to "just work".

Firing a custom React event in the event of an error... eeh, minor increase in api surface area, but could be ok.  I personally prefer polyfilling onerror, but I don't feel strongly one way or the other.

Either way, I think I'm going to defer to the rest of the team on this one.  Especially @sebmarkbage 
 @RandScullard updated the pull request.
 I‚Äôm a bit confused by this. What‚Äôs wrong with something like

``` js
window oldAddEventListener = window.addEventListener;
window.addEventListener = function(type, listener, ...args) {
  return oldAddEventListener(type, (e) => {
    try {
      return listener(e);
    } catch (err) {
      // report error
    }
  }, ...args);
}
```

I haven‚Äôt tested it so maybe I‚Äôm completely wrong but this should capture errors that React throws _while_ it is handling events as well. What am I missing?
 @gaearon Not all events are attached via window.addEventListener.  For example, you could have events fired within an iframe, or you could have progress events which do not bubble.  For this reason, I _think_ there are classes of events which you would miss.
 Hmm. What about `EventTarget.prototype.addEventListener`?

It would probably still miss iframes but seems good enough for exception reporting for most apps, which is what prompted this issue.
  Can you provide two jsfiddles (one showing that it doesn't work with React 0.14.1+ and another showing that touch events do work without React)?  I'll try to dig up a 4.1 phone to test on our end.
  Comes up with the word "true" for me: http://jsfiddle.net/mgzqbedr/

Do you have a jsfiddle that demonstrates it coming up as false?
  We'll need to do a little bit more than just hard code these since we'll actually want to generate these at release time. But we could at the very least manually generate those hashes now and do what we need in the docs to display it.

SRI: https://developer.mozilla.org/en-US/docs/Web/Security/Subresource_Integrity
  This repository is for React core, not react native.  The react-native repository is at https://github.com/facebook/react-native, but if gradlew is failing out of the box, my guess is that it's an environment issue on your end and not related to the react-native codebase.
  At first glance, I suspect this is probably a duplicate of https://github.com/facebook/react/issues/3298

Without a repro, there really isn't a whole lot we can do from our end.

Since I suspect it's a duplicate of https://github.com/facebook/react/issues/3298, and since there is nothing actionable on our end (since we can't repro your issue issue), I'm going to close this out.  If you're able to find a good repro (jsfiddle), let me know and we can reopen/reinvestigate.
  This looks good.  There are a bunch of others I mentioned in that bug.  Can you go through them (there are less than a dozen) and fix the ones that follow this same pattern (binding exists, but we are using typeof anyway)?
 @karczk updated the pull request.
 Looks great, thanks!

I'll leave it open for a day to see if anyone has any other feedback, and then we can merge!
 Thanks @karczk!
  Not a bug, duplicate of https://github.com/facebook/react/issues/4933
  We have a whitelist of attributes, but don't check to ensure they're used on the corresponding tags.  With regards to validation, are probably headed in the opposite direction with issues like #140.

However, this may be a reason to set the attribute even if we are already setting the property.
 Ah, you are correct.  FWIW, we also don't specify the other attributes such as `checked`/`selected` in 0.15, unless you are using server side rendering.
 I'm going to close this out in favor of https://github.com/facebook/react/issues/5966, since that's the only actionable part of this issue, as far as I can tell.
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 This is actually correct as is. `getRenderOutput` will return `null` until `render` has been called.
  @MarkMurphy updated the pull request.
 @MarkMurphy updated the pull request.
 Another kind of dumb question: what do I need to do to hide the modal?  I tried clicking the X and tried clicking outside the modal box, neither seemed to trigger this code path.
 I'm starting to think that we don't need the hide logic at all.  We could probably solve this entire issue by just deleting the line `$(this.refs.root).off('hidden', this.handleHidden);`

I'm not convinced it really adds anything to the example (beyond what's already there; we already handle a couple of different callbacks).
 @MarkMurphy updated the pull request.
 Ok, this appears to work.  Can you squash into a single commit (`git rebase -i`, `git push -f`)?
 Thanks @MarkMurphy!
  Introduced in: https://github.com/facebook/react/commit/7f8b2885d9f9feb396896f7d9d6086ac7731cf36
  The whole point of the warning is to be useful, and having a mixin that automatically calls `isMounted` is the opposite of what we would recommend.

For more details: https://facebook.github.io/react/blog/2015/12/16/ismounted-antipattern.html
 Without `isMounted`, you could just write 

`React.DOM.button({onClick: ()=>this.setState({modalOpen: true})})` (without mixin)
`React.DOM.button({onClick: this.setStateFunction('modalOpen', true)})` (with mixin)

The version without the mixin is syntactically shorter, and more readable (doesn't depend on the details of a mixin).  Therefore, I still wouldn't recommend the mixin.  But if you find the mixin useful, more power to you!
  Haha, browsers suck.  Want to submit a PR?

It looks like we do that `typeof` thing unnecessarily in a few places in the React codebase.

```
jsproch-mbp:src jsproch$ grep -R " === 'undefined'" .
./addons/link/ReactLink.js:    value: typeof linkType === 'undefined' ?
./isomorphic/classic/class/ReactClass.js:        if (typeof initialState === 'undefined' &&
./isomorphic/classic/element/ReactElement.js:      if (typeof props[propName] === 'undefined') {
./renderers/dom/client/ReactDOMSelection.js:  if (typeof offsets.end === 'undefined') {
./renderers/dom/client/ReactDOMSelection.js:  var end = typeof offsets.end === 'undefined' ?
./renderers/dom/client/ReactInputSelection.js:    if (typeof end === 'undefined') {
./renderers/dom/ReactDOM.js:    if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined') {
./renderers/shared/reconciler/ReactCompositeComponent.js:        typeof inst.props === 'undefined' || !propsMutated,
./renderers/shared/reconciler/ReactCompositeComponent.js:      if (typeof renderedComponent === 'undefined' &&
./shared/utils/traverseAllChildren.js:  if (type === 'undefined' || type === 'boolean') {
```

Note that we do need to use typeof if the binding might not exist, so we need to look at each case individually to make sure the change is valid there.
 As long as you tested it manually and it worked in IE, I think we can accept this change without a unit test.
 Fixed in https://github.com/facebook/react/pull/5965
 lol what even
 I can't reproduce `typeof document.all` being `"undefined"` in IE 8 or IE 9 on Windows 7, either in standards or quirks mode. What am I missing?
 Oh! Sorry I totally misread. Yes I can repro this.
  This looks like it is probably a usage question related to your environment/configuration, rather than a bug in the React core. Usage questions are better answered on sites like StackOverflow, as we try to use github issues for tracking bugs in the React core. For this reason, I'm going to close out this issue, but feel free to continue the conversation on this thread or move it to StackOverflow.

If you can reduce the problem to a demonstrable bug in the React core, we can re-investigate.
  Thanks!
  Does it work in this fiddle: http://jsfiddle.net/9kungxn4/ ?
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 @davidvgalbraith updated the pull request.
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 The HAS_SIDE_EFFECTS flag was supposed to be for this ‚Äì when set, we read the current value and compare. For this case it probably doesn't actually matter and I think we can be content with setting the value again. Like if you switch `width="3"` to `width={3}` we also re-set the value.

Let's just remove the "should be 1" comment?
 @davidvgalbraith updated the pull request.
 Ok, sure.
  @spicyj @syranide 
 Sorry, I'm having trouble understanding the issue here. ReactUpdates.asap is not public API, and if you were to use setTimeout or requestAnimationFrame then I would expect the behavior you describe here as incorrect. What are you using ReactUpdates.asap for in this case?
 @chrisdavies I think you're running into a different issue, try upgrading to React v15.0.1
  I think we'll opt to keep core clean of this and just provide the building blocks. We don't support every possible property that a node might have, focusing on the markup attributes (for markup generation). Another example of this is `scrollTop`, which could be described declaratively but is not supported.
  The problem with updating the examples on the home page is that the second two examples are stateful.  We want the three homepage examples to feel like a simple+natural progression.  We need to introduce stateful syntax for the second two examples, so there is no point in using a different syntax for the first example (it would just make it harder to follow the progression).

Personally, I would be open to having http://facebook.github.io/react/docs/transferring-props.html and http://facebook.github.io/react/tips/communicate-between-components.html upgraded to use stateless functions.
 I assume your comments (1-5, etc) above are referring primarily to the homepage.  Keep in mind that the homepage is a sales pitch (it's what users see when deciding which framework to use).  Ease of use/understanding is paramount at that stage.  When users are ready to learn about best practices, they can read the full docs and learn about all the various features and design patterns.

For this reason, I don't want to introduce two different component-definition styles on the homepage.  Two concepts is harder to understand than one.

If you wanted to submit a PR for the two pages I mentioned, that seems like the most appropriate place to surface stateless functions more prominently.
 Yep, thanks!
  @koba04 updated the pull request.
 Yeah, let's use Proxy objects, since that will allow us to detect writes when they happen, rather than when the event is returned to the pool, which will make the stack trace more useful.
 Ping @koba04
 @koba04 updated the pull request.
 @koba04 updated the pull request.
 @koba04 This looks good to me.  One minor nitpick (above), plus a rebase is needed to merge.  Also, if you could squash these into a single commit (`git rebase -i` and `git push -f`), that would be great.  Other than that, I think this is good-to-go.
 @koba04 updated the pull request.
 @koba04 updated the pull request.
 @koba04 updated the pull request.
 Thanks @koba04!
  Great, thanks!
  Thanks for the PR!  I'm going to take https://github.com/facebook/react/pull/5946 instead, because sometimes we have lines that are necessarily long (like the URL in http://facebook.github.io/react/docs/getting-started.html).  It's probably better to solve this by fixing the CSS, instead of hacking around the problem.
  For background, see: https://github.com/facebook/react/pull/1510/files#r44678597

Good first bug?
 Probably not, unless you already know what the cause and solution is.
  I agree with @texttechne:

> What you are doing here requires an implicit knowledge of how the <Parent> component works

In general, a component should be a black box.  As soon as you start peaking into the component implementation, things get really messy.

@esseswann said:

> Actually I kind of don't want to know how it works, I just want to set some props up if they occur, likewise I don't know when I make a selector in CSS.

I understand what you're going for there, but (IMHO) this is one of the worst properties of CSS (lack of style isolation).  At the very least, it's a double edged sword.

Imagine that you are designing a page, and you like big checkboxes, so you double the size of all the checkboxes on the page using a css selector.  But a component that used a checkbox internally was depending on the size of the checkbox to align with the size of another node.  Now things are broken.  You can no longer import any arbitrary components, because the components now depend on the ambient styles of the page.  This is the danger / bad practice.

It is an interesting discussion.  Thanks for proposing it!  But I'm going to close this out for the reasons @texttechne mentioned.  Feel free to continue the discussion on this thread.  FWIW, I think you could use [context](http://facebook.github.io/react/docs/context.html) to achieve the behavior your looking for.
 @esseswann A parent can reason about about all the possible props that it chooses to forward to its child, but it can't easily reason about all the things a grandparent might do if the grandparent is allowed to bypass the parent's API.
  For what purpose?  What is your use case?
  Yeah, I could see this fitting into the error boundaries stuff (https://github.com/facebook/react/issues/2461).
 Actually, now that I've had a couple days to think about it, I'm seeing some issues, and I don't see any real benefit.  Why would you want this feature?  What would this allow you to do beyond what `window.onerror` already allows?
 The biggest issue is performance.  It would require wrapping every event (even mouse-move events, which can fire super frequently) in a try-catch block, which causes the JSVM to deopt.

It also gets complicated because (if we used an error-boundary as the catch point), it's not clear what the semantics should be if the parent of an error boundary passes a callback into the child of an error boundary, and an exception is thrown when the child invokes the grandparent's function.  In that case, the grandparent is the broken component (ie. the one in a potentially erroneous state), but the child is where the exception pops out of the system (thus, we don't know to fatal the grandparent).

Probably the best solution would be to figure out a solution for https://github.com/facebook/react/issues/285 and then smooth out the interface for IE10 and Safari6.
 I think it is a fit:

> Probably the best solution would be to figure out a solution for #285 and then smooth out the interface for IE10 and Safari6.

It's just not a super high priority for us, since the only upside is the ability to log slightly more detailed error information (specifically stack traces) on legacy browsers.  It doesn't (as far as I can tell) affect the control flow of the program and doesn't affect any of the primary browsers.  Ultimately, I think this is a request for a synthetic version of a very specific global event, which is why https://github.com/facebook/react/issues/285 seems the most relevant.

I don't see any solutions that are cleaner than https://github.com/facebook/react/issues/285, but if I'm missing something, let me know!  If it is a simple change with no performance/api impact, submit a PR and we'd be happy to take a look!
  Rather than throw, I think it should generate a warning.
Here is a another work-in-progress PR you can use as a reference: https://github.com/facebook/react/pull/5744
 I think these lines might be relevant: https://github.com/facebook/react/blob/9c3f595597f167fef9b0679f716216bb56e25a14/src/renderers/dom/client/syntheticEvents/SyntheticEvent.js#L160-L162
 @kentcdodds updated the pull request.
 https://github.com/facebook/react/blob/master/src/shared/utils/PooledClass.js#L102-L111 is another place to look. That's what get's run to add pooling to a class, generating a new class with a static `release` method which calls the `destructor` (as @gaearon linked to).
 Another thing is you might want to put the warning code into a ‚Äúdevtool‚Äù which is a new work-in-progress API for doing dev-only things. See https://github.com/facebook/react/commit/251d6c30b51c6aa9a406f9076c0f895570a710b3 and https://github.com/facebook/react/pull/5590 for inspiration.
 Might be tricky as a "devtool" since you need to add getters, which doesn't fit so well into the devtool event framework (at least as I understand it). Definitely work looking into though
 @kentcdodds updated the pull request.
 @kentcdodds updated the pull request.
 @kentcdodds updated the pull request.
 @zpao 

> Might be tricky as a "devtool" since you need to add getters, which doesn't fit so well into the devtool event framework (at least as I understand it). Definitely work looking into though

Potentially worth emitting an event whenever someone attempts to access a variable on an event object.  In addition to solving this issue... That would open a bunch of doors, like having a devtool that warns if you persist an event but never subsequently read from that event, etc.  It would be totally doable, if we wanted to.

Anyway, probably not worth churning this PR at this point, but @gaearon is correct that it would be good to start shifting this stuff over to the devtool, and I think the devtool could be a good fit in this case.
 @kentcdodds updated the pull request.
 @kentcdodds updated the pull request.
 @kentcdodds updated the pull request.
 At this point I‚Äôve given all feedback I could give, and what I see so far looks good, apart from minor nits above. Let‚Äôs wait for the maintainers to give their further comments. Thank you for contributing!

cc @jimfb 
 @kentcdodds updated the pull request.
 @kentcdodds updated the pull request.
 @kentcdodds Overall, this looks great to me.  A couple of nitpicks.  Also, I think it would be good to add an "integration" test (ie. render a component, simulate a click event, save the event, read from the event at the end of the test, and assert the warning fires).  Just to sanity check that things are working.

Otherwise, I think we're good to merge.
 @kentcdodds A reasonable example is in ReactServerRendering-test.js, we have a test called "should have the correct mounting behavior".  Specifically, the most interesting line is:  `ReactTestUtils.Simulate.click(ReactDOM.findDOMNode(instance.refs.span));`

A test would probably look something like this:

```
var event = null;
var instance = ReactDOM.render(<div onClick={function(e){event = e;}} />);
ReactTestUtils.Simulate.click(ReactDOM.findDOMNode(instance));`
// TODO: assert warnings.length===0
event.nativeEvent;
// TODO: assert warnings.length===1
// TODO: assert warnings[0].contanis("error message text");
```
 @kentcdodds updated the pull request.
 @kentcdodds This all looks good to me, thanks!  But it looks like we broke lint (you can run locally with `npm run lint` or view the output here: https://travis-ci.org/facebook/react/jobs/109724188).  Just fix the lint errors and do a "git commit --amend", and we should be good to go.
 @kentcdodds updated the pull request.
 Thanks @kentcdodds!
  I may be wrong but I think this is by design (and equivalent to how it worked before a couple of versions back). You can grab the stuff you need from the event object:

``` js
  handleClick(e) {
    const { target } = e
    this.setState({
      clicked: this.state.clicked + 1
    }, () => {
      console.log(target)
    })
  },
```
 Why not shallow clone the event if you want to keep it around?

```
e = { ...e }
```
 Maybe I'm missing something, but... https://facebook.github.io/react/docs/events.html#event-pooling

Seems like you want to call `e.persist()`, right?
 I didn‚Äôt know `persist()` existed! This made my day.
 Can we warn on accessing `target` and other properties for the pooled events while they are not used?
 > Maybe in development mode we could replace them with getters that will throw a clear error indicating that those properties are removed after the initial handlers have been called and if you need access to them, you should find another way to do what you're trying to do or use persist.

Yeah, this is what I meant.
 Yeah, probably a good thing to do.
  Fixed in https://github.com/facebook/react/pull/5946
  I'm unable to reproduce.  I did an `npm install` inside the react repository, it went fine.  I also did an `npm install react react-dom eslint eslint-plugin-react` and that also went fine.  What exactly are you doing when you get this error?
 This usually happens on old versions of npm (eg under 2). You'll not the package in question is actually eslint-plugin-react-internal, which is installed via a file reference in package.json, which needs npm 2.

If you're looking to contribute to React and need to build, then you'll need to be using Node 4 and npm 2.
  - Yes, we're already migrating toward a configuration where React can be built with only the features needed by your chosen renderer.  That was one of the main points of 0.14 - it was the upgrade path as we migrate to such a system.
- No, synthetic events are required for a whole host of reasons, including performance (event listeners are registered at the top, instead of each element along the DOM tree).
- Proptypes are not checked in the production build.
  React does not guarantee to change the markup.  As long as the rendered value within the input box is correct (ie. what the user sees is correct), then React is doing its job correctly.  The markup is irrelevant.

FWIW, this behavior will probably be closer to what you want when https://github.com/facebook/react/pull/5680 merges.
 To clarify what @jimfb is saying - When React updates `value`, it currently does so via the property, which doesn't affect `outerHTML`. A super simplified example to show what React currently does: https://jsfiddle.net/1z2fey46/
  Thanks for the PR!

As per https://github.com/facebook/react/issues/5080#issuecomment-146373158: 

> propTypes are mostly in a sort of maintenance mode and we're not really planning to add more to them right now.

Proptypes are being replaced by static analyzers like Flow.  For this reason, I'm thinking we probably won't merge this.  However, I would encourage you to publish your proptype online so others can use it.

If you're looking for ways to get involved in React development, I'd recommend checking out the [good first bug](https://github.com/facebook/react/issues?q=is%3Aissue+is%3Aopen+label%3A%22good+first+bug%22) list, which has a bunch of things that need fixing :).
  I think this is a bug.

`createElement(Foo, {})` should pretty clearly be equal to `cloneElement(createElement(Foo, {bar: 'noise'}), {bar: undefined})`
 @mattzeunert Because otherwise you could create an element using `React.cloneElement` that could not have been created using `React.createElement`.
 cc @sebmarkbage - I don't recall if we talked about this before but what should our expected behavior here be? defaultProps resolution was explicitly only resolved during createElement but now we're adding a second pass for cloning.
 Yea, I think this is a bug. For the reason @jimfb mentioned above. `defaultProps` gives you a way to guarantee that the type of a prop is never going to be `undefined`.

The idea is that this should guarantee that you never get undefined:

``` js
type Props = { foo: number };
function Foo(props : Props) {
}
Foo.defaultProps = {
  foo: 123
};
```

Another example to explain this semantic is that `cloneElement` should be roughly equivalent to:

``` js
<element.type {...element.props} key={element.key} ref={element.ref} />
```
  Other than the character fix, looks good. Thanks! Can you make sure you squash any changes when you updated so we only have a single commit?
 @scjody updated the pull request.
 Thanks!
  This is almost certainly a usage error.  You are probably passing in a null (or other non-component value) somewhere.  Most likely your `Example` component, based on your code snippet, is not being required properly.

If you believe this is a bug in React, please create a simple jsfiddle that demonstrates the problem and we can re-investigate.  My fiddle: http://jsfiddle.net/1eqfp1vp/
  We don't want any dynamic injection but luckily we don't need to because there is only one implementation of CurrentOwner. You just need to make sure that the module instance is shared by all Reacts.

To do that I think that we probably want to break it out into a separate package on npm with a frozen version. That way it works with deduped packages even if there are multiple versions of the main React package.
 It doesn't look like this actually has a way to share the ReactCurrentOwner instance between the three packages. There is no coordination mechanism. You simply end up with three different ReactCurrentOwner if you use the react, react-dom, and react-dom-server packages on the same page.

This will break string refs and debugging messages. 
 Yea. It shouldn't go into fbjs. This is react-only. It can't go into the fbjs package anyway since it is versioned differently.
 @iamdustan updated the pull request.
 PR closed in favor of discussion in https://github.com/facebook/react/issues/5974
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 @puppybits updated the pull request.
 Thanks! Could you squash into a single commit?
 Thanks!
  Yes, that will fix this. I've marked it for 0.14.x so we'll grab that if we do another release before 15.
  That's weird‚Ä¶ what version of React? What does `document.documentMode` give you? (should be `undefined` in Chrome)
 Part of it, but it's a hard requirement. It's a property that is only set in IE. Maybe you have an extension or some other piece of code setting it?
 The doctype might matter but again, only if documentMode is set. I'm 95% sure even doctype-less iframes in Chrome won't have that set. If you could make a simplified test case, that would be helpful.
 @cdonohue ping
  Looks like an npm bug. Stepping through their code, they're referencing `data.dependencies` but if I log, that's not there for react-dom in with the --production flag (https://github.com/npm/npm/blob/2.x/lib/install.js#L180). It looks like they will only fill in `data.dependencies` with an empty object in dev mode (https://github.com/npm/npm/blob/2.x/lib/install.js#L328) - and `install()` explicitly sets `dev: false` when in production (a few lines above the first link).

So there's 2 things that should happen
1. We can add `dependencies: {}` to our package.json
2. Somebody can fix npm's bug. I don't know if it's present in npm3 (haven't looked)
 Looks like https://github.com/npm/npm/issues/6581 might cover it (but is missing the critical piece that this only happens when `dependencies` is missing from `package.json`
 The PR is marked for 0.14.x so will get picked up if we do another release on the branch. I think we will do that but no hard timeline for that.
 FYI: Shipped 0.14.7 with the fix so should be good now.
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 @zeke updated the pull request.
 We don't really care about the [ci skip](though we could and this would be a prime candidate). Could you squash the commits and then I'll merge. Thanks!
 Thanks!
  As per #5080 (comment):

> propTypes are mostly in a sort of maintenance mode and we're not really planning to add more to them right now.

This would be a breaking change, because we would be inverting the default requiredness of something in `PropTypes.shape`.  Proptypes are being replaced by static analyzers like Flow. For this reason, I'm thinking we probably wouldn't do this.
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 @RandScullard updated the pull request.
  Can you provide a simple usage example / component that creates this problem?
 I'm reasonably sure this is fixed in master/future, since our react-dataid is now numeric for SSR.
  Thanks!
  Can you file this in https://github.com/reactjs/react-magic, which is where that code lives? Thanks! (And cc @Daniel15 just so he sees it)
  Yea, that's fine. Can you update the translated versions of that file too?

> you can drop the parens around `props` as well

I'd prefer we don't do that in our docs, especially for this type of code. I hate it less for the single line use in `.map` and co but in general I wish the single argument case was not an exception.
 @rajatsehgal updated the pull request.
 Thanks!
  @spicyj It has been a week, can you take a look at this?
 (cc @azich too)
 I have very mixed feelings about this one.  Ultimately, I think @syranide is right.

This opens a large can of worms.  At least for now, this is probably better handled in user land by providing a custom component.  This doesn't merge cleanly, and there is no clear path forward, so let's close this out for now.  We can come back to this if/when our thinking on this matter changes.
  @jquense updated the pull request.
 I suspect this was fixed in https://github.com/facebook/react/pull/1510

At the very least, this will no longer pass tests if you rebase.
 @jquense Can you verify that the problem was fixed in master?
  Either method works, optimal solution probably depends on your use case.

Usage questions are better answered on sites like StackOverflow, as we try to use github issues for tracking bugs in the React core. For this reason, I'm going to close out this issue, which takes it off our radar, but feel free to continue the conversation here (or move it to StackOverflow).
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 I think I might just want to leave these as is to make the examples a little bit less daunting for newcomers who aren't familiar with ES6. I don't want to give the impression that it's required and instead focus on the pieces that are React specific. At least for now.
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 Thanks!
  Also removed object-assign. We only support building with node v4+ which has Object.assign.
  What you are looking for is [shouldComponentUpdate](https://facebook.github.io/react/docs/component-specs.html#updating-shouldcomponentupdate).  If `shouldComponentUpdate` returns false, that tells React that your component doesn't need to rerender.

For future reference, this is a usage question, rather than a bug in the React core. Usage questions are better answered on sites like StackOverflow, as we try to use github issues for tracking bugs in the React core. For this reason, I'm going to close out this issue, but feel free to continue the conversation here or move it to StackOverflow.
  Duplicate of https://github.com/facebook/react/issues/5455
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 Thanks @tmysz!
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
  It's not currently possible. I might be open to making it work but would likely say we should not use the `style` prop, and you'd need to consider what to do to make it coexist peacefully with the current expectaion of classes. If you're interested, please propose a complete solution before putting up a PR so we can hammer it out.
  There is no autobinding for ES6 classes so any binding issues are likely happening at the transform level (the `::` binding syntax is not a standard at this point). If you can reproduce in a test case on jsfiddle using more supported syntaxes, it will be easier to see if maybe there's a bug in React.
  Correct, the text/content of the page is licensed under CC BY 4.0.

We ask that you don't rip the styles (html/css) because we want to allow people to easily see when they are on an official facebook.github.io domain like https://facebook.github.io/flux/docs/overview.html#content or http://facebook.github.io/react/docs/ or http://facebook.github.io/relay/docs/getting-started.html#content
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 @danielrussellLA Thanks for the PR!  We love to see the community getting involved!  However, tiny fixups like this should be bundled with more substantive changes.  For this reason, I'm going to close out the PR, but we would love to see this change included as part of a future PR.  If you're looking for a way to get started, I recommend checking out the list of good first bugs: https://github.com/facebook/react/issues?utf8=%E2%9C%93&q=is%3Aissue+is%3Aopen++label%3A%22good+first+bug%22
  @TheBlasfem updated the pull request.
 What is the use case where you‚Äôd want to specify a timeout with `0` value?
  Are you sure you get the warning with `react.min.js` and NOT with `react.js`?  I would have expected it to be the other way around.  Warnings don't fire in production.

You can set your state in the constructor by saying: `constructor(){this.state = {number: 1}}`.
 You don't have an ES6 class in this code so we shouldn't even be warning about `getInitialState` regardless of if you have the min build or not.
 @jasonvillalon I tried running your example, but it didn't work for me out of the box (gulp failed on the import syntax, among other things), and I didn't have time to debug the errors.

Your example is still very complex.  You've got gulp, babel, jspm, and [God knows what else](https://github.com/jasonvillalon/get-initial-state-bug/blob/master/config.js).  Please simplify it to the minimal hello world example (ideally running in a jsfiddle) that demonstrates the bug.
  @ianobermiller updated the pull request.
 @ianobermiller updated the pull request.
 @ianobermiller updated the pull request.
 After the next release major release, which is probably less than a month away :).
  Looks like most of the videos must be purchased; there really isn't much useful content there for unpaid users.  I don't think we want to be pointing users to paywalls; those are easy enough to find without our help :P.
 Mmm, I don't think that would change my thinking on this.  The video on shallow rendering is less than two minutes long, and then you hit the paywall again.
  I think this was fixed in https://github.com/facebook/react/pull/5714

If you can create a fiddle using latest (http://jsfiddle.net/9kungxn4/) that demonstrates the problem, we can reinvestigate.
 Thanks @vlinder, correct, it will be part of 0.15.
  Appears to work for me.  http://jsfiddle.net/8ux1md6c/

If you can provide a fiddle that demonstrates otherwise, we can re-investigate.
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 This is literally the smallest PR I've ever seen.
 FYI: I'm going to revert this - sorry. This file is added automatically as part of the release process so this will just get overwritten unless we change the [source file](https://github.com/facebook/react/blob/master/vendor/react-dom.js).
  This is just a bug; we can support dangerouslySetInnerHTML if you don't have any other children specified (though of course you shouldn't have any elements in your HTML as that's invalid).
 How about just changing `nativeProps.children = content;` to `nativeProps.children = content || null;`? I think that should fix it. Also let's add a test so we don't accidentally regress this next time.
 @goatslacker updated the pull request.
 Looks great. Thanks!
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Sure, thanks.
  Enable null return values in plain functions by removing support for inheritless classes, as per #5355.
 @sebmarkbage @spicyj 
 @jimfb updated the pull request.
 Ping @sebmarkbage @spicyj
 I thought I reviewed this already. :+1: 
  Use the `class` prop instead of `className` for custom elements.

Custom elements are allowed to do arbitrary processing of their props, so in order to support the full range of attributes, the only viable option is to pass them directly through.  https://github.com/facebook/react/issues/4933
  `<noindex>my text goes here</noindex>` appears to work in master: http://jsfiddle.net/bL4zthpb/

The `<!--noindex>` syntax appears to be a duplicate of https://github.com/facebook/react/issues/1035
  There really isn't much to go on here, but it sounds like a usage error.  You might have one of your dependencies miss-configured or passing incorrect parameters.  Either way, this looks like it is probably not a bug in the React core, since `a.toUpperCase()` is happening in userland.
 You get this error if `<MyType />` isn't an actual component. Maybe it's `undefined`, maybe it's an object etc. I believe newer React (or master at least) provides a better warning for this.
  Took a stab at documenting this. Let me know what you think.

Fixes #3570
 ![catping](https://cloud.githubusercontent.com/assets/1730853/12693929/ff62e7c4-c6cf-11e5-8023-0d50826394c9.gif)
 We generally don't document the `unstable_` features.

Also, FWIW, this function is really only useful to react framework authors (ie. not the general public component authors), so top-level api docs are probably too prominent.  Most of the framework authors are tied into github and know how to find the unstable/undocumented functionality.
 Can I get a second opinion on this? @spicyj ?

We saw an over 25% speedup in a part of Instagram.com after using this hook, so I disagree with the notion that it's only useful to framework authors. This should be accessible to everyone to eke out perf wins.
 25% faster on what sort of operation?
 I don't feel strongly either way about documenting it so I am willing to follow @jimfb's lead in saying no.

We do want to move to automatically batching everything, at which time this hook is moot. Until then it will probably stay where it is.
 On rerendering when you navigate to a new post. This is easy to document (I've already done it), will enable people to write more performant apps and ship better UX, and is easily codemodded away if and when automatic batching comes to pass (which is probably at least months away from being in a release, yes?). Why not?
 > On rerendering when you navigate to a new post.

This doesn't help me to understand.  Specifically, what operations is the app doing that results in a benefit from batching (and why is the app doing whatever operations it is doing).  A single rerender would not benefit from batching.

> This is easy to document (I've already done it), will enable people to write more performant apps and ship better UX, and is easily codemodded away if and when automatic batching comes to pass (which is probably at least months away from being in a release, yes?). Why not?

It is not about how easy/hard it is to document - it's about the stability guarantees we're making.  If we want to release this as stable, we could consider that, but we shouldn't document something that is `unstable_`.  We also shouldn't release something as stable if we're just going to get rid of it in a couple months.
 @jimfb, N>1 Flux stores emit change events. Naively, this leads to N renders. You skipped over my key point as to why the benefits of documenting outweigh the downsides:

> is easily codemodded away if and when automatic batching comes to pass (which is probably at least months away from being in a release)
 @mxstbr:

``` .js
class MyDispatcher extends Dispatcher {
  constructor() {
    super();
    this._actuallyDispatch = Dispatcher.prototype.dispatch.bind(this);
  }
  dispatch(payload) {
    ReactDOM.unstable_batchedUpdates(this._actuallyDispatch, payload);
  }
}
export default new MyDispatcher();
```

This is from memory, may not be 100% right.
  I think we can't ignore `setState()` (I know that was @spicyj's idea, but I think he was mistaken about this point).  We should restore the 'allows setState in componentWillMount without using DOM' test, IMO.  cc @spicyj for confirmation

Also, we should think through the cases where `setState()` is and isn't legal.  I think `setState` within `componentWillMount` is legal but `setState` within a `setTimeout` is not legal.  Maybe the easiest thing to do is have `instance._isServerSideRendered` point to an object which is created at the beginning of SSR (`{warn: false}`) and mutated at the end of render (set warn to true) to enable warnings on those components.
 @mdolbin updated the pull request.
 Yeah, I think I agree with you.  cc @spicyj 
 Overall, I think this is good.  A couple of minor notes, then I think we can squash the commits together and merge.
 Hmm. I thought we were going to start using ReactNoopUpdateQueue for server rendering instead of ReactUpdateQueue and in that case it would be easy to swap out an implementation that warns for server rendering. Really that would be a much cleaner solution than this.

Also, if we do go with this solution, please use ReactInstanceMap instead of `_reactInternalInstance` directly, like all of the surrounding code already does.
 @mdolbin updated the pull request.
 @mdolbin updated the pull request.
 Looks good to me.  I'll leave it open for another day in case there are any other feedbacks, and then we can merge.
 Oh, but please do squash the commits before we merge.  You can do this using `git rebase -i` and then `git push -f`
 There should not be logic about server rendering in src/isomorphic. It is a concept specific to the DOM renderer.
 @mdolbin Do you want to update as per @spicyj's comment?
 @spicyj, any ideas on where you'd like the code to live?
 Like I suggested originally, we should change to use ReactNoopUpdateQueue on the server, which would probably mean having queue come from the transaction (since that differs between client and server rendering). Also open to other ideas but that's what I suggested 3 months ago and it's still the best option that I see.
  In its current form (0.14) React generates a string of markup in a single pass and then inserts it. Ultimately this is a single dom operation and historically has been faster. This goes for the style as well. Updates are applied individually.

In the next version we'll be using createElement instead of innerHTML but I think we still set initial style all together - not sure if that matters for csp since the element is already created at that point. Can you try a build from master and see if it works (http://react.zpao.com/builds/master/latest)

Also cc @spicyj in case he knows if we actually do set each style property individually on initial render (and if we should if we don't currently)
 We do set styles individually in master and it'll be in v15. Until then I suppose you'll need to add `unsafe-inline` to `style-src`.
 Note that server rendering will still generate `style="..."` markup by necessity.
  @cody is correct, the Simulate utilities take in a DOM node, not a component.
 @TinOo512 Usage questions like that are better addressed on StackOverflow, as we try to reserve github issues for bugs in the core.  With regards to your specific question: it's because most events don't fire when rendering into a disconnected dom node (like render into document).  I fixed your example here: https://jsfiddle.net/xr1qzttf/
  This is a usage question, rather than a bug in the React core. Usage questions are better answered on sites like StackOverflow, as we try to use github issues for tracking bugs in the React core. For this reason, I'm going to close out this issue, but feel free to continue the conversation here or move it to StackOverflow.
  Thanks.
  The second message was fixed in https://github.com/facebook/react/pull/5205

The first and third will probably be cleaned up as part of https://github.com/facebook/react/issues/2302, but I suppose we can keep this issue open until that happens.
  @SimenB updated the pull request.
 @SimenB We can replace all the text you added above the example with:

> When fetching data asynchronously, use `componentWillUnmount` to cancel any outstanding requests before the component is unmounted.

Other than that, this looks good to me :+1: 
 @SimenB Aren't all `promise-handlers` just handlers for asynchronous data requests?  It's a slightly different API, but it's conceptually the same, and we can't call out every possible API/permutation/usecase.

The title of the page is "Load Initial Data via AJAX".  The previous sentence (and whole page) is already assuming that we're talking about ajax, so I think it's reasonable to stay consistent.  It shouldn't be difficult for people to infer how the example would change if they are using a different API (like promises).
 @SimenB updated the pull request.
 This looks good, thanks!
 @SimenB I'm not worried about calling out edge cases (like pending requests for the purpose of logging), since the example is talking about fetching data.  In general, you always want to cancel anything that was initiated by a component.  I trust that people can decide for themselves if there are extenuating circumstances where they don't want to cancel a request.
 Yuck, good catch @SimenB and @cody.  Yeah, let's fix it to use `this.serverRequest = $.get(...)` instead.
  Would you be interested in creating a proof of concept of this in React?
 Unfortunately server rendering is not currently a priority for Facebook so we can‚Äôt dedicate enough time to optimizations related to it.

If you give it a try, we might be able to help you along the way. See #5753 as an example of an ambitious PR made by an external contributor that significantly changed how React renders text nodes. I would imagine that if you were to look into this, you might at least touch some similar files.

We plan to introduce some internal documentation (#6335) but we‚Äôre not there yet. We are however enthusiastic about seeing people contribute in some areas where we don‚Äôt have enough resources. Please let us know if you‚Äôd like to give it a try, and feel free to create a work-in-progress PR where you can ask questions as you stumble into problems or need a clarification.
  I appreciate the effort, but we're not going to support this in core. I don't think it's a widely applicable use case and arity isn't what is usually applied in a type system (usually it's the specific argument types). I like the initiative though and encourage you to publish to npm!
  I think @jquense makes a valid point about us needing a good solution here - it is currently overly painful to coordinate psudorandom identifiers for component.  The problem is exacerbated when different components choose different solutions for solving the coordination problem.  We see the exact same problem when components use the clock (for instance, to print relative times).  We also see similar use cases for things like sharing flux stores across component libraries.  Anyway, I think it would be good to find a real/supported solution for this use case.
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 Thanks!
  @TheBlasfem updated the pull request.
 @TheBlasfem updated the pull request.
 I'm not sure where we stand technically (do we still track owner?), but if possible the errors should include the responsible component (or source location) and be tracked individually per component? These generic warnings are incredibly hard to diagnose.
 @TheBlasfem updated the pull request.
 @TheBlasfem updated the pull request.
 @TheBlasfem updated the pull request.
 A couple of nitpicks, and then I think this is ready to merge.

Also, please squash the six commits into a single commit (eg. `git rebase -i` and then `git push -f`).
 @TheBlasfem updated the pull request.
 Thanks @TheBlasfem!
  I'm not entirely sure what you're asking.

If you want to render a React component to a string, you can use `ReactDOMServer.renderToStaticMarkup` on the client, as demonstrated in this fiddle: http://jsfiddle.net/d9ax06as/

If you want to get the `outerHTML` of a component, or otherwise work with the DOM node, you can attach a ref to the component (https://facebook.github.io/react/docs/more-about-refs.html).

Either way, this looks like a usage question, rather than a bug in the React core. Usage questions are better answered on sites like StackOverflow, as we try to use github issues for tracking bugs in the React core. For this reason, I'm going to close out this issue, but feel free to continue the conversation here or move it to StackOverflow.
  I don't understand what makes you think that behavior is incorrect.  It seems like a perfectly reasonable behavior to me.

Regardless, React uses a synthetic event system.  The interaction between native events and synthetic events is strictly undefined.  Sebastian wrote a post about this once-upon-a-time, how native and synthetic event systems are, by and large, inherently not interoperable.

I'm going to close this out, because I don't see anything actionable here.
  @alunyov updated the pull request.
 @alunyov updated the pull request.
 Something happened to the PR. Do you mind cleaning it up so there‚Äôs just a single commit?
 @alunyov updated the pull request.
 @alunyov updated the pull request.
 Hmm, this still doesn‚Äôt look right.
 @alunyov updated the pull request.
 Tagging this as to be reviewed after 15.0 release. If everything is fine we‚Äôll get this some time during 15.x. Thanks!
  I talked with @jimfb about this and this will hopefully lead to a clearer distinction of what is being tested when as we move towards that integrating that devtools api throughout.
 The goal isn't to pull out all warning tests, only the ones that are specifically provided by a "devtool" integration (which is an in-progress effort). I think we only have the 1 of them right now and you can see the diff which moved some tests in https://github.com/facebook/react/commit/30ef056731f10a094661b0d288c68fbe0c044161. We should move the tests that were moved in that commit into a new file - `ReactDOMUnknownPropertyDevtool-test.js` (testing explicitly that the devtool itself works).
 No, we'll handle moving other warnings as they are integrated into the same sort of tooling as the ones in that commit.
  Please see https://facebook.github.io/react/blog/2015/01/27/react-v0.13.0-beta-1.html#autobinding:

> `React.createClass` has a built-in magic feature that bound all methods to this automatically for you. This can be a little confusing for JavaScript developers that are not used to this feature in other classes, or it can be confusing when they move from React to other classes.
> 
> Therefore we decided not to have this built-in into React's class model. You can still explicitly prebind methods in your constructor if you want.
> 
> ``` js
> class Counter extends React.Component {
>   constructor() {
>     super();
>     this.tick = this.tick.bind(this);
>   }
>   tick() {
>     ...
>   }
>   ...
> }
> ```
> 
> However, when we have the future property initializers, there is a neat trick that you can use to accomplish this syntactically:
> 
> ``` js
> class Counter extends React.Component {
>   tick = () => {
>     ...
>   }
>   ...
> }
> ```

Alternatively you can keep using `createClass()` if this is too much of a nuisance.
  Mostly fine with me as long as it doesn't impact perf‚Ä¶ I didn't benchmark to check.
 Could look at

https://github.com/spicyj/innerhtml-vs-createelement-vs-clonenode

Particularly testCreate in Chrome/Safari/Firefox and testCreate2 in Edge/IE11.
 I wonder if instead of doing it like https://github.com/mozilla/react/commit/befab4ec31ce6b567cacb6a04d94ea7936cd7ec2 we made this injectible at some point so that instead of a fork of anything larger, you would just have to change the default injection (which was at one point the goal of that file).

If it was really important to keep the small perf (and assuming this counteract any wins), it could look something like this

``` js
// default
whatever.injectCreateElement(function(doc, type, ns) {
  if (ns) {
    return doc.createElementNS(ns, type);
  }
  return doc.createElement(type);
})

// mozilla "fork"
whatever.injectCreateElement(function(doc, type, ns) {
  if (!ns) { ns = 'xhtml ns' }
  return doc.createElementNS(ns, type);
})
```
  There isn't enough information here for us to reproduce the bug, so this really isn't actionable.  Furthermore, if the error occurred after installing an npm module, and you aren't doing anything fancy with refs, I would **strongly** suspect that something is somehow screwed up with your npm dependencies (npm seems to get confused more often than you'd think).  I'm going to blame NPM in this case; you can try reading the comments in https://fb.me/react-refs-must-have-owner and see if any of them help you.  I'm going to close this out as a usage question, but if you can provide a jsfiddle that demonstrates an issue in the core, we can re-investigate.
  I will admit I'm both confused and intrigued at the same time.

People are writing components in Scala, which presumably gets transpiled into an ES5 component and fed into React, do I have that right?

Why wouldn't your scala components just be a wrapper around a react component, like this:

```
function setState(immutableScalaObjectRepresentingNewState) {
  component.setState({key: immutableScalaObjectRepresentingNewState});
}
function getState() {
  return component.state.key;
}
```

It should be possible to support a purely-scala interface, with the setState semantics you want, just by wrapping in a new object before calling the actual react implementation.  From a usability perspective, it should be completely transparent, right?

So is the complaint that setting state requires an object allocation (ie. it's a performance complaint?).  Or what's the root of your issue?
 Is that even measurable though?

A setState is going to cause a rerender, which is going to cause a whole bunch of element objects to be allocated (entire trees of them, potentially).  And then React needs to run the reconciler to calculate a diff of the two element trees.  A single object allocation and a shallow compare of an object with a single key shouldn't even be detectable in comparison.
 The comparison/merge work of the single-key object only happens once per `setState()`, and the cost should be beyond negligible.  Ideally most (all) of your components should be stateless anyway, which means they won't ever have a state object allocated.  I'm reasonably sure that for all practical intents and purposes, the overhead is so small that you'd have a hard time even measuring it.

I'm going to close this out because there are much lower hanging fruits.  It's not worth an API change here if there is no evidence that it's actually a problem for anybody.
  Kind of related to the old #1612 and #5840, anyone trying to be smart and adding properties to a pooled non-persisted event will cause those to properties to remain in the pool, causing a memory leak of sorts. Could it make sense to `Object.seal(event)` the events, that way we ensure that users can't mess with the event object in bad or unsupported ways.

**Should probably do this instead:** https://github.com/facebook/react/issues/5853#issuecomment-171685664
 But you can't unseal when the user does persist the object, right?  You're suggesting that users are never allowed to add properties to synthetic events?
 @jimfb Yeah, that's obviously an issue. I would call it bad practice to modify events like that, so I personally wouldn't mind preventing it, but it might still be something we want to support. We could also clone instead of persisting events (same number of allocations), but it would obviously affect the API (`event = event.clone()`).
 Would it be sufficient to just detect the problem and warn?

We could check to verify that there are no extraneous properties on the event object after the event handler has completed, right?  Or we could wrap the event in a proxy object (in dev mode and where supported - firefox, edge, chrome-canary, etc) and warn if someone mutates an event before persisting it.  
 > Would it be sufficient to just detect the problem and warn? We could check to verify that there are no extraneous properties on the event object after the event handler has completed, right?

Yeah that should be fine too. Ultimately you're messing up the pooled events so it really should be an error. But then it couldn't be DEV-only and that's bad.

> Or we could wrap the event in a proxy object (in dev mode and where supported - firefox, edge, chrome-canary, etc) and warn if someone mutates an event before persisting it.

Tangentially, we could even use this to warn when accessing an event after it has been returned to the pool?
 > Yeah that should be fine too. Ultimately you're messing up the pooled events so it really should be an error. But then it couldn't be DEV-only and that's bad.

There are lots of things that I believe should be errors, but the javascript community seems to like things that fail soft.  That was one of my biggest culture shocks, coming from a java background where the community believes that things should always fail super hard.  I've given up on that fight, need to choose my battles :P.

> Tangentially, we could even use this to warn when accessing an event after it has been returned to the pool?

We could do that anyway, with `Object.defineProperty`, right?  Since we know what properties exist on events.

Anyway, overall, I agree this seems like a useful feature to implement :+1: 
 > There are lots of things that I believe should be errors, but the javascript community seems to like things that fail soft. That was one of my biggest culture shocks, coming from a java background where the community believes that things should always fail super hard. I've given up on that fight, need to choose my battles :P.

I agree, but this is more because we don't want the perf hit in production I would say.

> We could do that anyway, with Object.defineProperty, right? Since we know what properties exist on events.

Yeah I guess so... but it's probably a little involved and it technically changes the runtime behavior (they are now getters/setters instead of values), I doubt anyone would notice but still. IMHO it's fine if DEV-warnings for coding practices only work in modern browsers.

PS. Hmm, didn't we have something like this? Perhaps we already do... I remember @spicyj working on something like it, but perhaps it never shipped.
 @jimfb Good first "bug"?
 Yep.
  I think the documentation is pretty clear about what the two functions do.  FWIW, `scryRenderedComponentsWithType` does not allow you to assert props on the found component if the component happens to be a DOM component (thus consistent with `scryRenderedDOMComponentsWithClass`, which only finds DOM components).  Also, FWIW, if we could make props private (ie. not visible to the outside world, including test utils) - we would.
 @sahiltalwar88 DOM components are anything built into the browser, composite components are anything you write yourself (or import).
  Nah we're going to leave it. We'll talk more about version numbers in the future.
  This looks like a usage question, rather than a bug in the React core. Usage questions are better answered on sites like StackOverflow, as we try to use github issues for tracking bugs in the React core. For this reason, I'm going to close out this issue, but feel free to continue the conversation here or move it to StackOverflow.
 I think we don't want to encourage that pattern by documenting it, but we also don't want to prohibit it because people do use it sometimes (especially when cloning an element).  Personally, I thought that the top answer on stack overflow was pretty good.
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 @david0178418 updated the pull request.
 Looks great, thanks!
  Installing React from github is not supported. You can checkout the repo and build (should work with npm 3 but the team doesn't use that) if you want a build from master. Instructions for building are in the readme. The build artifacts (in `build/packages`) are what get shipped to npm.
  You probably have really long `key` prop specified on one of your elements.  If you are passing arbitrary data in as your key, you can probably hash the data before passing it in (which will limit the length, and ensure the value is alphanumeric).

This has been fixed in React 0.15 (master); React will no longer use keys when generating the reactid.
  `stopPropagation` appears to be working for me: http://jsfiddle.net/o2c6tt7c/

This looks like a usage question, rather than a bug in the React core. Usage questions are better answered on sites like StackOverflow, as we try to use github issues for tracking bugs in the React core. For this reason, I'm going to close out this issue, but feel free to continue the conversation here or move it to StackOverflow.

If you can provide a fiddle that demonstrates a bug in the core, we can re-investigate.
 My fiddle was demonstrating that stopPropagation does work for the child/parent relationship.

I think you might be confused about what `stopPropagation` does and doesn't do.  `stopPropagation` does not prevent the browser from responding to an event: http://jsfiddle.net/rajo091h/

You might be able to do something with `preventDefault`, but it's not entirely obvious what that logic would be (maybe "if is scrolled to bottom of child, prevent default").  Regardless, it's clearly a usage question and not a React bug at this point.
 @aseem2625 The second fiddle I provided does not use React, but exhibits the same behavior, so I don't think it's a React core issue.  `stopPropagation` should follow the spec (https://goo.gl/6MyhXy).  It should do nothing more, and nothing less.  In this case, I think we're doing the right thing, but if the behavior is different from Chrome without React, let us know and we can re-investigate!

We generally don't help with usage questions on github, since it's the wrong medium.  We use github issues for tracking bugs in the React core.  Every minute we spend debugging usage questions is one fewer minutes we can spend fixing React to make it better for everyone - which is why we generally redirect all usage questions to StackOverflow.  StackOverflow is a much better place for questions, clarifications, etc.  Sorry, but I hope you can sympathize the reasoning here!

Good luck with your project!
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 I think the location of that paragraph is correct as-is.  It is part of "Identify where your state should live".
  Duplicate of: https://github.com/facebook/react/issues/4939
Fixed in: https://github.com/facebook/react/pull/4943
Demo: http://jsfiddle.net/d0vvgssy/
 Actually, I think I may have miss-read the issue.  What is it you are trying to do?  Can you provide a fiddle?

As far as I can tell, adding a ref to a child of a stateless component does work: http://jsfiddle.net/zxkfpx37/
 My fiddle is using a future/experimental version of React, so it's possible the issue was just fixed and not yet released.  Either way, glad to hear it works in the latest fiddle!
  @yaycmyk I don't think it constitutes a memory leak.  Persisting the event just means it won't be returned to the synthetic event pool, which should be fine.  It will still get garbage collected when all the references are dropped.
 Persisting is generally an anti-pattern so I'm not too concerned about references there. Regardless, when you call `persist()`, that instance gets marked and it won't be returned to the pool. As a result, that SyntheticEvent will just get GCed like anything else and a good GC should release values as well if they aren't referenced anywhere else.

I think the current state of the world without this changes means we have a memory leak (albeit fixed size, so not an exponentially growing leaking)
 @koba04 updated the pull request.
 @koba04 updated the pull request.
 Looks great, thanks!
  Do these error events bubble? We might have to attach listeners directly if not (which is what we do for the video & audio elements)
 Great, and does source have any other events? My quick research only shows error but I suspect load is there as well and probably has the same non-bubbling (basically the same as an img element). I'll try to do some testing but any pointers to specs and whatnot would be helpful.
  @SimenB updated the pull request.
 cc @zpao is the proptypes person.
  Duplicate of https://github.com/facebook/react/issues/4662.  The warning is useful in most cases.  I'm pretty sure you get a paste event for nodes that are not contentEditable, so if you are capturing all the events and preventing the browser changes, why do you have `contentEditable` specified?

To avoid the warning, you can bail out of React (https://github.com/facebook/react/issues/2477#issuecomment-173315553) and then call React.render() in your contentEditable container node, which will not cause us to warn (afaik).
 You can capture input events without content editable (http://jsfiddle.net/vm9gjhs3/) and can simulate the cursor behavior yourself (which you basically need to do anyway in order to implement a good editor, as per https://medium.com/medium-eng/why-contenteditable-is-terrible-122d8a40e480#6497).  The browsers all have different behaviors with regards to how cursor position works.  If you want a truly nice editor, you will end up using almost nothing from contentEditable.  But I get it, you're trying to reuse the browser's functionality under the (very optimistic) assumption that contentEditable gets you most of the way there.

With regards to your hack: A better stopgap solution (hack) would probably be to set contentEditable imperatively (as demonstrated in my fiddle: http://jsfiddle.net/4q2p6ug8/).  That way, React doesn't even know you've set it, and you can share your component without overwriting other people's `console.error` method.
 We generally avoid global configuration like the plague, so we would almost certainly prefer that it be specified on the component itself.  At first glance, I kind of like your second proposal.  I'll bikeshed a little with Ben and see what we come up with.
 My two best naming proposals right now are `silenceContentEditableWarning` and `allowContentEditableChildren`, both of which I like a little more than `disableContentEditableWarning`.
 I like "suppress" better than "silence".  Or "allow" is also fine, but the problem with `allowContentEditableChildren` is that it implies a possible change in behavior, rather than merely disabling the warning.

For this reason, I think I'm in favor of `suppressContentEditableWarning` or `contentEditableWarning="disabled"`
 Fixed in https://github.com/facebook/react/pull/6112
 If you want to send a PR, sure.
  Sure.  I don't think our jsdocs are very complete, it probably makes sense to go through them in bulk rather than these one-off fixes.
  @spicyj @syranide 
 @milesj updated the pull request.
 @milesj updated the pull request.
 @milesj updated the pull request.
 @spicyj @syranide 
 @jimfb Can't you review this?
 @spicyj No, not intelligently.  The event dispatch is still an inscrutable mystery to me, and you guys (I guess mainly you and @zpao) always have strong opinions about the way we name events/attributes.  There are some diffs in this area that I can review myself, but this probably isn't one of them.

To me, if I had to decide between having this change and not having this change in my copy of React, I'd accept and fix later if needed.  But you and @zpao like things to be more perfect before merging, which means this diff needs some more eyeballs.

You and @syranide have the best understanding of this code, which is why I sent it your way from the very beginning.
 @milesj updated the pull request.
 @milesj updated the pull request.
  üëç
 @spicyj updated the pull request.
 The link works for me. Not sure what's up.
 Maybe some crappy geolocation or something?
 The URL appears to have been down temporarily, but it looks like it's up now.  I guess too many people are hitting microsoft's server today :).
  Correct as-is.  The `X` is a wildcard, intended to indicate a pattern... anything that starts with the prefix `internal`.
  cc @sebmarkbage 
 The downside here is that this is not a magic number. Meaning it is not unique among other frameworks nor within this framework if we add more. 
 @sebmarkbage A tad overkill and might impact performance, but having both (`[Infinity, 0xeac7]`) would work right? (the object should be reused)
 The guarantee here is not strong enough so I'm going to close out this PR. Let's continue in #5138 which has much more context.
  If `componentDidMount()` gets called before `renderTable()` or `renderMessage()`, that sounds like a bug.  I'm fairly skeptical that's actually happening, but if you can provide a jsfiddle (using console.logs) that demonstrates the issue, we can investigate further.
 `:%s/componentWillMount/componentDidMount/g`
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 @jacenko can you please sign the CLA so we can merge?  https://code.facebook.com/cla
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 Thanks!
  Good find, but it's really weird that it would exhibit `O(n^2)` running cost for something which intuitively should not have it:

https://github.com/facebook/react/blob/master/src/renderers/dom/client/wrappers/ReactDOMSelect.js#L117-L127

PS. Perhaps accessing the elements has a linear cost?
 Apparently `option.selected = value` has an `O(n)` cost as well.
 After further testing this is _entirely_ unavoidable, the cost is near identical to simply setting `innerHTML` of the `<select>` with all the options pre-`selected`. There's a native cost of `O(n)` for selecting an option is apparently for some reason.

So I don't see how this could possibly be fixed.

cc @jimfb
 Is that true on all browsers?  Can we file tickets against the appropriate browsers and then close this out as a React issue?
 @jimfb Primarily Chrome, IE is a lot faster and doesn't blow up as fast, don't have FF here. However, there's something else that is fishy, when I try it locally Chrome it is _a lot_ faster, I can do ~8000 in less than a second and after that it starts blowing up. But I'm using virtually the same code as in React... ???

``` html
<html>
<body>
<select id="select" multiple></div>
<script>
var select = document.getElementById('select');

var html = '';
for (var i = 0; i < 8000; i++) {
  html += '<option>' + i + '</option>';
}

var start = Date.now();
select.innerHTML = html;
console.log(Date.now() - start);

var l = {};
for (var i = 0; i < 8000; i++) {
  l['' + i] = true;
}


var start = Date.now();

var options = select.options;

for (i = 0; i < options.length; i++) {
  var value = l.hasOwnProperty('' + i);
  if (options[i].selected !== value) {
    var o = options[i];
    o.selected = true;

  }
}


console.log(Date.now() - start);
</script>
</body>
</html>
```
 @syranide Check out my nearly identical fiddle: https://jsfiddle.net/vr0vquag/

Updates take 10x longer than your fiddle.
 @jimfb Uuuuh...??? What the hell? Thanks for sorting that out fast, but that makes no sense to me. I take it all this is some browser weirdness at the very least and React is not at all to blame here.
 @liamgray Also thanks, yeah that's obviously Chrome doing something not so great.
 Yeah, I think we need to submit a chrome bug here.

Here is the repro:

> Fast: https://jsfiddle.net/h07a47t2/
> Slow: https://jsfiddle.net/nbrtqn7t/
> 
> Two fiddles perform virtually identical operations, but there is a 10x performance difference.
> We've discovered an even larger performance difference in real-world (React) applications due to this bug.
> Discovered in `https://github.com/facebook/react/issues/5825` (in case it's helpful additional context/information)

@liamgray Do you want to do the honors, submit the chrome bug?  Also, cross-post links between the two issues so we can track progress?
 Great, thanks!  I'm going to close this out in the React repository (since it's a bug in chrome), and we'll let the Google/chrome bug ([576459](https://code.google.com/p/chromium/issues/detail?id=576459&thanks=576459&ts=1452555254)) take over from here.
  `name` is only actually a supported attribute on form elements (eg `<input>`). In that case it's a property and React updates it with `node.name = newValue`.
  @mgmcdermott This looks really great!  Can you update the wording of the error messages, as per above, and then I think this is good-to-go.
 Looks good.

Can you squash these two commits into a single commit.  You can do this using `git rebase -i` and then squashing, then do a `git push -f` to update the branch.  We generally like single-commit PRs, because it makes things easier to revert if/when necessary.
 Oh, sorry, and one more thing I just noticed: `defaultChecked` is also a react prop, we should do the same check for that - can't specify both `checked` and `defaultChecked`.
 @mgmcdermott updated the pull request.
 Yes, this should also apply to select element :).
 @mgmcdermott updated the pull request.
 This looks great, thanks @mgmcdermott!
 @mgmcdermott If you're looking for another bug related to controlled inputs, you might take a stab at https://github.com/facebook/react/issues/5821, which would be a great next bug.
  A component should either be using uncontrolled inputs or controlled inputs, but not both (they should pick a single paradigm, for the lifetime of the component).  As a result, an instance of an input should never switch from controlled to uncontrolled (or vice versa).

We should warn when an input that was previously controlled becomes uncontrolled, or vice versa.
 @yangshun https://jsfiddle.net/sxqh5csz/
 newswim https://fb.me/react-controlled-components

Read about controlled components and uncontrolled components.  Choose one (preferably controlled components), and don't ever use uncontrolled components.  If you are using controlled components, make sure you never pass a `null` or `undefined` to React.

And yes, @brigand is correct, this is better addressed on StackOverflow.
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 I agree, this seems fine as-is.  Unless this is causing a problem for you (let me know and we can re-investigate).
  This should be illegal:

```
ReactDOM.render(
  <input value="foo" defaultValue="foo1" onChange={function(){}} />,
  document.getElementById('container')
);
```

Users need to decide if they are using controlled or uncontrolled inputs.  We should warn if both properties are specified.
 @jimfb I might be reading #5680 wrong, but doesn't that make it valid to use both? (Although, HTML defaultValue really should be separate from React defaultValue right?)
 @syranide No, afaik, https://github.com/facebook/react/pull/5680 is trying to fix https://github.com/facebook/react/issues/4618 when using uncontrolled components.  `defaultValue` is always meaningless for controlled components.  https://github.com/facebook/react/pull/5680 does add a unit test that includes an element with both `value` and `defaultValue`, but I complained about that and hopefully it gets fixed before that gets merged (seeing that PR was the reason I created this issue).
 @jimfb Ah ok I see now... Hmm, I don't advocate it at all, but if that PR is meant to fix `<input type="reset" />`, wouldn't it make sense to support both `value` + `defaultValue`, `defaultValue` being what it resets to when you hit reset... rather than the value it already has.

Anyway, wrong issue to have this discussion in. :+1:
  Can you provide two jsfiddles?  One to demonstrate that it is fast without React, and another to demonstrate that it is slow in React?
 No response for two weeks.  We can re-examine this issue if OP can demo the problem.
 The example above doesn‚Äôt demonstrate that the lag doesn‚Äôt exist without React.
Are you sure it is React-related? Can you show this with a fiddle?
  @rickbeerendonk updated the pull request.
 @rickbeerendonk updated the pull request.
 Isn't `isNaN` already available on all browsers? Also, `value !== value` is not a sufficient test.
 @syranide `isNaN` is available everywhere, but it has some nasty edge cases.  For instance, the String "NaN" will return true.  `Number.isNaN` is much better, but is not yet supported on all browsers.  `value !== value` is one of the recommended polyfills - why is it not sufficient?
 @jimfb Oh wow that's interesting, didn't know about that. Yeah my bad, it's correct. I was thinking of `0 !== -0` from the `Object.is` polyfill, but my brain fooled me, it was the other way around. :+1: 
 However, we don't want to polyfill `Number.isNaN` in the global namespace. We should require users to have the polyfill or make the polyfill internal.
 @rickbeerendonk updated the pull request.
 All the same things I said in #5811. We should pick one
 @rickbeerendonk updated the pull request.
  I don't think we pass a second argument anymore, as of React 0.15 / master.

http://jsfiddle.net/e47hj19q/
  Thanks @yangshun and @andrewgrewell.

@tnrich What they said is correct.  You should read through the docs on forms.  Although you'll probably initially prefer uncontrolled inputs, as you use React more, you'll discover that controlled inputs really are better (IMHO).
  @jontewks updated the pull request.
 @jontewks updated the pull request.
 @jontewks updated the pull request.
 @jontewks updated the pull request.
 @jontewks updated the pull request.
 @zpao just updated shallowEqual internally to use an Object.is polyfill which we should sync out soon.

Also why not use just `x !== x` to check if `x` is NaN?
 Yes. @zpao wrote a change for shallowEqual last week, just needs to be applied to fbjs.
 @jontewks updated the pull request.
 cc @zpao for release planning/scheduling.
 @jontewks updated the pull request.
 @jontewks updated the pull request.
 @jontewks updated the pull request.
 Looks great, thanks @jontewks!
  It's really ad hoc right now so we should make it better. It's not a huge deal since we do a shitty job of exposing the translations but there are groups of people actively contributing so we should do our best to make it easier.

@thejameskyle has had great success using CrowdIn so I set up a project there - https://crowdin.com/project/react. I'll do some more work over the next few days to get it syncing from GH based on his article (https://github.com/thejameskyle/crowdin-sync) and then we'll go from there.

Thanks for the inspiration James!
 Awesome, I might take you up on that. Right now they live alongside the English (eg https://github.com/facebook/react/blob/master/docs/docs/01-why-react.md and https://github.com/facebook/react/blob/master/docs/docs/01-why-react.zh-CN.md) but that might change if I ever get back to #4633 and do it differently. I think I need to do a little bit more playing with this to see what will be best for us.
  We actually do normalization so that you aren't getting the differences in platform that are shown in that table (looks like older browsers did return `"Spacebar"` but newer ones return `actual inputted character`, which is `" "` here. Looks like only Firefox and IE/Edge claim support of this draft spec (http://caniuse.com/#feat=keyboardevent-key) so I would say it might not be the most reliable thing but we are doing the normalization to what the spec is expecting (https://github.com/facebook/react/blob/master/src/renderers/dom/client/utils/getEventKey.js).

tldr; as expected, but also cc @syranide in case I was wrong.
 Here's the relevant section from the current draft of the spec: https://w3c.github.io/uievents/#widl-KeyboardEvent-key

> `key` holds the key value of the key pressed. If the value is has a printed representation, it MUST be a non-empty Unicode character string [...] If the value is a control key which has no printed representation, it MUST be one of the key values defined in the key values set [...] Implementations that are unable to identify a key MUST use the key value `'Unidentified'`.

In this case Spacebar has a printed representation so that's the value.
 @zpao Correct, `"Spacebar"` is the old draft, it should be `" "` as it is.

@yaycmyk It's impossible to polyfill `key` with characters for `keydown/up` from the virtual key codes reported because there is no way to reliably translate a virtual key code to a character, but we polyfill this where possible (IE mostly IIRC). However we do polyfill characters for `keypress` as it does report character codes. I spent significant time on the `key` polyfill and as far as I am aware (at that time) everything that can be reliably reported is (except for some esoteric keys not worth the added bytes).
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 Context is an experimental feature, and the API is likely to change in future releases.  It is documented on the context page, but does not show up in the other docs (like http://facebook.github.io/react/docs/component-specs.html) - this was intentional.  Until we change this decision, we want to keep all references to context exclusively on the "experimental context" page.  When this changes, we will need to change it everywhere, including component-specs.
  I'm a little surprised it works fine without React but fails with React.

@rogierschouten @syranide @spicyj Any thoughts on why?
 @jimfb Me too... I played around with a little bit earlier. Intuitively it probably has to do with the specific events used by React, Chrome is probably broken when setting the value during some of the other events.

Anyway, @rogierschouten you definitely do not want to defer setting the value, it will break your selection and introduces other subtle issues. Controlled inputs work on the idea that setting it to the value it would have normally become does **not** actually update the value, so the native behavior is kept (and selection is intact). If you deviate from that React has to update the value and then there is no knowledge about what to do with the selection. When you defer you effectively break this because you explicitly tell it to restore it to the previous value and later set it to the new (but there is no information about the selection now).
  Thanks!
  It's a good question but I'm going to redirect you to Stack Overflow or discuss.reactjs.org. We have a hard enough time keeping up with actual issues and PRs and so we really try to keep GitHub focused on bugs/improvements and not usage.
  Unfortunately TestUtils.Simulate does not behave identically to browsers. It creates an event that is fired in the React event system. If you'd like to simulate what a real browser does you would have to do that yourself.
  @spicyj @syranide 
 @milesj updated the pull request.
 @milesj updated the pull request.
 @milesj updated the pull request.
 @milesj updated the pull request.
 Ping @spicyj @syranide
 @milesj updated the pull request.
 @milesj updated the pull request.
  We try to use github issues for tracking bugs in the React core. For this reason, I'm going to close out this issue, but feel free to continue the conversation on this thread, or post on another site.  I feel like a StackOverflow post with the exact text of the error message (so people can search for it) tagged with ES6 and React and Babel is more likely to be findable than this github - posting there would be my recommendation.
  What version of React are you using.  Is this on 0.14.6 or on the master branch?  What mobile phone (android?) are you using, what browser, what version?  Can you create a jsfiddle that demonstrates the issue?
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 Thanks!
  Which link are you looking at?  It looks correct to me: http://facebook.github.io/react/downloads.html
 In the readme, like he said :)

I need to cherry-pick a couple commits to master, including the change to the readme. Will do that shortly.
 I guess I can see the confusion. The readme in the starter kit on the website references 0.14.6. But the readme in the repo was referencing the 0.14.5 starter kit. Regardless, I just cherry-picked the commits so master is up to date.
  I just did a build of a fresh checkout of master (ie. without this commit), and there were zero errors.

@davidpaulrosser What command are you running?  Presumably just `grunt build`?  What platform are you on?  What error (exactly) are you getting?

@spicyj @zpao Do I have `process` installed globally/locally somehow, or is this not an actual dependency?
 `process` is a built-in node module so nothing needs to be installed. I'm going to close out because this hasn't been an issue but if you have some more details about your environment that could reproduce this, that could be helpful.
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
  Thanks for the post!

Discussions/posts are better held on other sites (like facebook, irc, medium or discuss.reactjs.org), as we try to use github issues for tracking bugs in the React core. Since this isn't actually a bug in the React core, I'm going to close out this issue, but feel free to continue the conversation on this thread or move it to one of those mediums.
  I don't think we have a synthetic wrapper for the target; it's the real DOM node, right?  I'm surprised that `event.nativeEvent.srcElement` behaves differently, unless they are pointing to different elements.  Do you have a jsfiddle?
 cc @spicyj @syranide Why do we not provide `event.srcElement` on synthetic events?
 `.target` should probably match `.nativeEvent.srcElement` always. If it doesn't that sounds like a bug. We should not support `.srcElement` on synthetic events ‚Äì it is an IE-ism.
 @spicyj ic, it's an IE-ism that also works in Chrome, which is what threw me off.

@travisbloom can you provide a jsfiddle that demonstrates?
 Ok, I ran the fiddle in IE11.  Best as I can tell, `event.nativeEvent.srcElement === event.target`, and is the DOM node.  It looks like IE11 no longer supports `selectedOptions` on the select DOM node, which is odd because it appears to be supported by Edge, but that's life.  `selectedOptions` is not part of the spec, and even if it were, I don't think we'd want to be polyfilling the actual dom nodes.

Anyway, I think this has nothing to do with our synthetic events.  The "problem" is occurring when the browser reads directly from a DOM node.  Unless I'm missing something, no further action is necessary here.
 (Sounds like you want `event.target.value`.)
  This seems to be a recurring question.  People always want to know WHY we sometimes call `componentWillReceiveProps` even when the props haven't changed.  I've seen this in several threads now.

Blog post explains.
 @jimfb updated the pull request.
 @jimfb updated the pull request.
 @zpao Can I get the green light on this one?  Is it ready to go?
 @jimfb updated the pull request.
 @zpao done.
 As per in person with @zpao, we're good-to-go on this one.
  @brigand

> The majority of components should have PureRenderMixin-like behavior.

That's only true if you assume immutable data.  It's not true in general.

Immutable data is great, and we generally recommend using immutable data when possible (largely because it makes `shouldComponentUpdate` relatively trivial to implement).  Unlike Rust, the javascript language assumes mutability by default, so we can't presume that the user has an immutable data source.

Anyway, with that said, this idea has been discussed and is being considered.  However, the more I think about it, the more I become convinced the correct solution is to just import/require a pureRender function and use that as your `shouldComponentUpdate`.

Example:

```
React.createClass({
  shouldComponentUpdate: require('pureRender'),
  render() { 
    ...
  }
});
```

That pattern is fully generalizable (could use any function you want, not just pureRender), is already supported today, and isn't "magical".  The "isn't magical" is the most important point, IMO.
 cc @sebmarkbage - I know we've talked about this in the past but didn't see anything in react-future & not sure where it's come up.
 @brigand If we were to take the generalized path, perhaps the stateless function would participate in the `shouldComponentUpdate` but not the other lifecycles.  Honestly, it hasn't been at the top of our priority list because people can always use ES6 classes if they need access to the lifecycles.  For trivial components, pureRender can actually be detrimental to performance because you end up spending time doing the shallow compare (which can be as expensive as the render) and then ultimately update the component anyway.

@zpao It came up in https://github.com/facebook/react/pull/3995#issuecomment-127566694, as well as in-person design discussions with Sebastian.
 There are a few alternatives:

a) A flag to the existing behavior. This proposal. The flag wouldn't guarantee a bailout but React is allowed to us a heuristic for when to compare.

The problem with pure render is that it doesn't actually assume anything about your render. All renders should be idempotent. What it says is that the render becomes pure due to the properties of your parent components. Not this component. Which is kind of fragile. Once you start having these in your system, you're effectively subscribing to the notion of immutable data because it is very subtle when it breaks down.

b) An alternative would be to flag the provider of props. I.e. the parent would declare that the output of its render is immutable, and therefore any transitive child can safely bail out on its children. We can track this flag in the reconciliation.

c) Another alternative that I've thought about recently, is to always render everything... eventually. Basically, the idea is that we can always bail out on equality checks, but in spare cycles we keep rendering the branches that were previously cut off. What this means is that immutable data becomes the preferred and fast option. However, mutable data will still automatically eventually be consistent. So, if you do screw it up, it's not such a big deal.

The question now is just how many intermediate APIs do we release before we get there? If we go with A first, we should pick a name for both A and B so that we know that the naming makes sense.
 @sebmarkbage Flagging props as pure raises another interesting question, components need to know this and be able to pass it down (as they themselves are likely to pass those props on). Without further explicit knowledge of which props are pure, as long as you're passing any of them down all descendants should also have their props are flagged non-pure. Essentially `<Child pureProps={this.hasPureProps} />` should become a recurring pattern (in theory) it seems to me? But perhaps that's what you mean by:

> ...and therefore any transitive child can safely bail out on its children. We can track this flag in the reconciliation.
  Looks good to me.  We will probably want to squash before merging.  I'll tentatively accept, but will leave it open for a day or two to collect any additional feedback before merging.

@sebmarkbage @spicyj Calling `componentWillReceiveProps` upon context updates is the intended behavior, right?  FTR, `componentWillReceiveProps` does accept context as a parameter.
 Yeah, this change makes sense though the test case looks very complicated. I am not even sure it is testing the right thing ‚Äì aren't the props changing since you recreate the element each time?
 @milesj updated the pull request.
 Looks good now ‚Äì just a couple notes inline.
 @milesj updated the pull request.
 Ok, looks good.  Thanks @milesj!
 Thanks!
 @kayakyakr If it makes you feel any better, the first release candidate of v15 will be released within the next two days.  Also, Facebook is already running React v15 in production now.

Honestly, I don't think a 0.14.8 is likely, but @zpao keeps telling me that he is open to doing another point release, so what do I know?  If you're blocked and don't want to jump to v15, you could always checkout 0.14-stable and cherry-pick this commit over, build yourself, and use that - which is basically what we would do for a 0.14.8 release anyway.

I know it's not a perfect solution, but maybe one of those ideas will help.
  Known issue at the moment. Sorry about that. See #5779. 0.14.4 does have the issue with the browser builds but not the npm build due to the way things are packaged so we'll have to ship 0.14.6 most likely.
  One fundamental issue here is that React needs to update styles using `node.style.key = value`, here you cannot do the usual CSS trickery you're trying to achieve. I don't think anyone is denying that what you want is a bad thing, but it's far from trivial how to actually accomplish it in a sustainable fashion all things considered (**EDIT:** that includes updates and server-rendering).
 As mentioned, you can do browser detection or you can use CSS and classes. React isn't trying to be a complete solution for this problem. If you want to break out into more complicated inline-styles processors that actually generate stylesheets for you, that could also work (see [Radium](https://github.com/FormidableLabs/radium) for example).

I'm not sure what you mean about manually adding/removing classes - you'd be able to write that inline and let React handle it just like you would with styles. Eg `<div className={condition ? 'foo' : 'bar'} />
  I'm curious; should this apply to `<embed>` as well perhaps? What about the `error`-event?
 @ara4n updated the pull request.
 I've been playing around with this a bit and I can't get error events out of `object` elements, nor can I get `load` (or `error`) events out of `embed`s. Also, gets a bit tricky since the `load` event doesn't even fire consistently (can get it for SVGs but not others). I think this is probably fine pretty much as is. And if we need to we can always follow up. I'll give it a bit of a closer look shortly and merge tonight. Thanks (and sorry for the delay!)
  Have we thought about getting rid of these? https://facebook.github.io/react/docs/update.html

The API is pretty complicated, and it's probably a better idea in most cases to either use [Immutable JS](https://github.com/facebook/immutable-js) (more powerful and complete), or the stage-2 proposal for [object spread syntax](https://github.com/sebmarkbage/ecmascript-rest-spread) (simpler, will eventually be built into JS):

``` js
const original = {a: 1, b: false, c: 'banana'};
const copy = {...original, b: true};   // copy is like original but with b set to true
```

As long as we continue to have this immutability helper addon in the docs, I feel we'll be steering people new to React towards a solution that we know is a bad tradeoff.
 Yea, it's come up. I think they have some value to people. It's more powerful than object spread (see $push) and an API people might be more familiar with after working with Mongo. But I agree that for most people, they aren't useful.

They shouldn't be shipped with React though and if somebody came up with a better name I'd split them out tomorrow (I filed #2909 a long time ago but let it sit, but that's why I'm closing this). Or if somebody in OSS wanted to take what we had and ship their own version, that'd be fine too. That came up in another issue but I can't find it atm. We still use this in a few places internally too so we can't just up and kill it completely without some work.
  These sound like usage questions, rather than a bug in the React core. Usage questions are better answered on sites like StackOverflow, as we try to use github issues for tracking bugs in the React core. For this reason, I'm going to close out this issue, but feel free to continue the conversation here or move it to StackOverflow.
 Not a usage question and yea, this is getting fixed in fbjs. We'll have to publish something for React‚Ä¶
 @MikeMcElroy no, this isn't related. #5561 has not be merged to the 0.14 release. The issue here is an accidental change in a dependency that got picked up (https://github.com/facebook/fbjs/pull/96 for the fix, just deciding on the right way to version to fix this).
 Shipped 0.14.6 so this should get us back to the behavior we had before 0.14.4/5.
 0.15 will ship when it's ready. Probably not this month. #5561 was not shipped in 0.14.x because nobody thought about it nor asked for it to be.

This bug was really about a broken 0.14.5. #5561 solves the rest of your issue. If you have concerns about #5561, please discuss there so the conversation can be correlated.
  `TestUtils.Simulate.*` isn't meant to do what the browser would do as far as side effects go. Even `TestUtils.SimulateNative.*` doesn't actually work how you want I think (it does create an actual event but only dispatches it in the internal system).

I don't think this is a bug per se but a misconception about the scope of the test utils. You may just want to fire an event yourself in your test.
  Can you provide a simple jsfiddle that demonstrates the issue?
 This might be a case where using array indices for keys comes back to bite you. Since that's note actually stable between loops you might be assigning the same key to a different slide on the next pass which can confuse React's update optimizations (or rather, it's working exactly like it's supposed to just with confusing output). If you can use an id or something instead of the array index that might help narrow down the issue if it continues.
 A lot of DOM code changed between 0.14 and 15 so it might have been fixed by one of those updates.
I‚Äôll close but please let us know if you see this again.
  I don't see how this would help with #2517 or #3973 - they seem orthogonal.

More to the point, I don't think the solution is to add a new lifecycle here.  The solution is to fix https://goo.gl/xWSesX to ensure `componentWillReceiveProps` gets called if the context changes.  This appears to be the conclusion of https://github.com/facebook/react/issues/5756
 @milesj My understanding is that the intended behavior is for `componentWillReceiveProps` to fire when context changes.  Let's do that, since that's the spec'd behavior.  We can figure out any renaming / reorganizing of lifecycles separately, but that's likely a more involved conversation.
  Fix some confusion about why `input` would support `defaultChecked` (it's because you can have an input of type checkbox).  This has come up a couple of times (https://github.com/facebook/react/pull/5633, https://github.com/facebook/react/pull/5774) but both those PRs were wrong and it was just easier to fix it myself.
 @jimfb updated the pull request.
 üëç
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Original document is correct as-is, but could use a clarification as per https://github.com/facebook/react/pull/5633 if you want to update this PR.
 @atilacamurca

> likewise... `checkbox` and `select`.

This PR is wrong as-is, as is the other PR.  The original wording was correct, but admittedly a little confusing/misleading - thus my proposed alternate text mentioned in the other PR.
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
  Passing a value of NaN as the value of a css style seems to indicate an error.  Turns out that we don't warn on initial render, and give a confusing error on update (because `NaN != NaN` as per spec).  Discovered in https://github.com/facebook/react/issues/4877#issuecomment-168471074

```
ReactDOM.render(<div style={{marginLeft: NaN}} />, document.getElementById('container'));
ReactDOM.render(<div style={{marginLeft: NaN}} />, document.getElementById('container'));
```

Anyway, we should probably warn if someone passes in `NaN` on initial render, and not warn on update if both previous/next values are NaN.
 NaN is a fine (if weird) value to pass so we should probably just handle it explicitly like we did for props in #3148.
 As per team discussion offline, we should warn on initial render (NaN indicates error) and also do as @zpao mentioned to avoid the mutation warning on update.
 Fixed in https://github.com/facebook/react/pull/5811
  See #5320 for another discussion about this (from a slightly different angle) - namely @sebmarkbage's first comment about initialization vs updates. Note: that PR was merged but was backed out because of the discussion.

If you'd like to use default values for props (`foo` here) then you should use the `getDefaultProps` API.
 @dbkaplun Correct - The `this.props` is passed into the constructor as a convince for easy access within the constructor.  The component's props are controlled by React, not by the constructor, for the reasons discussed in #5320.

If you were using a more modern release of React, you should get a warning when you passed in the modified props: https://github.com/facebook/react/issues/5335
  Done. Thanks for catching that.
  Please keep github for bugs in React. There are other places for posting your related projects, like https://discuss.reactjs.org/
  This is not a React question but a general JS question. I encourage you to learn more about JS modules and how that relates to scope before trying to use modules.

The tldr is that each module is a new scope so nothing that was available in some other file will be available in Test.js unless you import it.
  `react-blessed` appears to be calling `ReactInjection`, which is part of React DOM.  I think the root of your problem is this erroneous dependency, whereby you are relying on global state within the core of the renderer.  Ultimately `react-blessed` is not rendering to the DOM and should therefore not be calling into the DOM code (it should be it's own renderer, using things from `renderers/shared` but not from `renderers/dom`).  I _think_ that's what @sebmarkbage would say (cc him), also cc @spicyj for comments.
 It is true that you can't (currently) have two renderers sharing the core React modules because we have this global state. (ReactInjection has nothing to do with it.) We would like to resolve this longer-term either by encouraging flat builds where each renderer has its own copy of React bundled in, or perhaps by changing the React core to make the modules instantiable and not store global state.

You may be able to work around this problem by loading two completely independent copies of React. Hope that will work for you ‚Äì though if it doesn't we probably won't be up for making significant changes to support this because alternate backends are not an active priority for us right now because of time constraints. Hopefully we can support this better one day though.
  We could change it all to `shallowRenderer` but let's take this. I think most of the uses I've seen also just name the variable `renderer` so not a big deal, but good point.
  Babel has removed their support for the browser version recently so I doubt they'll support it (unless they changed their mind), but you can try. They currently recommend https://github.com/Daniel15/babel-standalone though it doesn't do the script tag stuff that you're looking for, which is why #5497 exists here. There isn't anything for us to do outside of that linked issue so I'm going to close out. Sorry you had issues.

My other recommendation is really not to rely on the in-browser transform for anything beyond a quick prototype. It's handy for that but anything more serious will require a build step so you aren't sending 1.8MB of babel's JS to then transform and run again.
 FWIW, I think it's handled correctly by my unofficial/unsupported babel6-browser transform: http://www.jimsproch.com/react/

That's what I use myself when testing locally, so I thought I'd share.
 @ickata Appears to work for me: http://goo.gl/tQUx6V

Do you have a demo that shows otherwise?
 @ickata The execution order is correct.  The problem there is scoping.

Use `window.App = React.createClass({...` instead of `var App = React.createClass({...` to indicate that you want the variable to be accessible in the global scope (ie. outside the local file).  Let me know if that doesn't work.
 @jimfb - I think that used to work. `var`s like that are accessible outside the file (unless they're protected inside a function) so I think something isn't right with your script. Do you have the original source? Or is this just straight babel-browser?
 Tested quickly - execution order is correct but the transformed script isn't being run in the "right" (read: expected) scope, which is why `this !== window` and why `var App` isn't available outside of that file boundary. If you're going to suggest that to anybody, you should probably fix it (or just work on #5497 and then we can review it since we're probably going to support this in some way for the time being).
 @ickata Looks like this scoping issue is fixed, let me know if you run into any further issues.
  Not speaking for the React team here, but personally I enjoy using [Disposables](https://github.com/gaearon/disposables) (concept borrowed from Rx) for composing cleanup logic.

``` js
import { Disposable, CompositeDisposable } from 'disposables';

class MyComponent extends Component {
  constructor(props) {
    super(props);
    this.disposable = new CompositeDisposable();
  }

  doSomething() {
    const xhr = doXHR();
    this.disposable.add(new Disposable(() => xhr.abort()));
  }

  doSomethingElse() {
    const xhr = doAnotherXHR();
    this.disposable.add(new Disposable(() => xhr.abort()));
  }

  componentWillUnmount() {
    this.disposable.dispose();
  }
}
```

There is also a `SerialDisposable` that lets you switch disposables on the go, killing the old one as you "set" it to a new one. Useful for disposing resources in response to prop changes.
  @kidwm updated the pull request.
 Sorry for dropping the ball here. #6005 is more complete, so I'm going to work on getting that one merged. Thanks anyway though!
  All attributes will be passed through to svg in the next release now that #5714 has landed. We won't be adding anymore individual attributes.
 We'll ship 0.15 when it's ready. Rough estimate: probably not in January.
 That or manually calling setAttribute on your svg node are the alternatives. The escape hatches are there but they are obviously unfortunate. The situation will be better soon.
  @spicyj @syranide We really want to be more responsive to @jquense's PRs (he has been doing really good work, and has been very patient with us).  Can someone with expertise in this area of the core take a look?  Thanks!
 @jquense updated the pull request.
 @jquense updated the pull request.
  Yeah, simple fix is to abort the jqxhr in `componentWillUnmount`.

Although, I wonder if the whole page/example should just be eliminated.  The example has other problems (like not handling updates).  And having components do ajax is a bit of an antipattern anyway (they should use something like flux, which can ensure consistency across the page and can deduplicate requests for the same data).
 First we need to decide what actually needs to get done here.

@sebmarkbage thoughts on best practices here?  Should we just toast the whole example?  Doesn't seem like a super valuable page to me, especially given the shortcomings mentioned above.
 Yea, we should keep it just as an entry level example. Sometimes difficult to strike a balance between best practice and easy examples. Especially since this is a fairly complex thing to get right atm.

IMO, we should just fix the example to abort at unmount.
 > And having components do ajax is a bit of an antipattern anyway (they should use something like flux, which can ensure consistency across the page and can deduplicate requests for the same data).

While this may be true for big apps, beginners have repeatedly expressed concerns about this. They jump to overengineered solutions when all they want is to talk to some API and show a list of things as an exercise. Unless they see a component doing AJAX request in the docs they feel they _have to_ use Flux or some other complex data fetching solution, which isn't quite true.

So it's useful to show at least that this is _possible_ and hm-kay to do in the official docs.
 @ir-fuel The approach isn't scalable for several reasons.  If you have a thousand different components, you can't reasonably be making a thousand different requests (you'll need to implement batching of some sort).  If you have the same the same component multiple times, you'll want them to share a single value in memory (to avoid duplicate requests, or for consistency if the data is mutable, etc).  Also more difficult to subscribe to updates in case the underlying resource (on the server) changes (you would need to hold open a connection for every component, instead of a single shared connection).  Sideways data loading makes it more difficult for developers to reason about your application, since components are no longer a pure function of props+state (they are reading some outside data source).  The list goes on, but I'll truncate it there in the interest of time - the bottom line is that flux exists for a reason and it's a bad style for a component to make an ajax request directly.  This is a usage question, so if you are interested in that topic, feel free to discuss on an appropriate usage-question medium like StackOverflow.
 @ir-fuel I recommend StackOverflow, or discuss.reactjs.org, or reactiflux.com, or quora (in that order).
 Fixed in https://github.com/facebook/react/pull/5870
  I'm pretty sure this is expected behavior, unless I'm missing something.

When an event fires, the event is trapped by React, and React calls the event handler.  Multiple setStates within that cycle are batched together, because React is on the stack and will be able to process all the `setStates()` after the eventHandler has completed.  When a `setState` is invoked as the result of a `setTimeout`, React is not on the stack, and so the batch completes as soon as `setState` finishes (ie. it is effectively executed synchronously).

There are some talks about using `requestanimationframe` (or some similar solution, like `setTimeout`) to perform all operations asynchronously, but that is part of a much wider conversation about a new reconciler.  There is no actionable short-term task in this issue, so I'm going to close it out.
 Yes, state updates in event handlers are batched together.
 Not high.  There are talks, and it might happen as part of a reconciler rewrite, but nothing is planned in the short term.
 @jackielii It is documented pretty clearly in the big red NOTE box for `setState`: https://facebook.github.io/react/docs/component-api.html#setstate

Also, if your render function is a pure function of state without side effects (which it's supposed to be), you shouldn't be able to tell how many times it was called.
  This was meant to be safe against Closure advanced mode. Is this actually smaller after gzip?
 Because app code that does `React.DOM.output` will get crushed to something like `React.DOM.q`, but since we use quotes in an array `React.DOM.output` will actually exist.
 @zpao ~~We don't run GCC on React so `React.DOM.input` would still exist and work, but the element it creates would be `<q>` or whatever.~~ The other way around.
 Yes, _we_ don't but the goal with the GCC support was so that somebody could if they wanted (eg clojurescript).
 ```
Running "compare_size:files" (compare_size) task
   raw     gz Sizes
  1198    641 build/react-dom-server.js
   734    445 build/react-dom-server.min.js
  1179    632 build/react-dom.js
   715    436 build/react-dom.min.js
699327 157734 build/react-with-addons.js
150302  43356 build/react-with-addons.min.js
632976 142973 build/react.js
137902  39947 build/react.min.js

   raw     gz Compared to master @ 23167f287eda5ee23725a099e67d6086baa8e300
     =      = build/react-dom-server.js
     =      = build/react-dom-server.min.js
     =      = build/react-dom.js
     =      = build/react-dom.min.js
 -2603   -764 build/react-with-addons.js
  -912   -410 build/react-with-addons.min.js
 -2603   -757 build/react.js
  -911   -385 build/react.min.js
```

`mapObject.js` (1466 bytes) no longer gets packaged as a result so that's a bit over half the raw savings (which we likely wouldn't see internally). As far as perf goes we're talking about the difference of iterating 130 entries. Since we're all speculating, I estimate the difference is going to be on the order of ns (ie negligible). We could inline `mapObject` and get > half those bytes back and probably also a speculative perf win (could avoid the `.call`), while still maintaining GCC compatibility.
 @fabiomcosta Did you verify it works with GCC?
 AFAIK anyone relying on `React.DOM.input` and GCC will break, with this you have to do `React.DOM['input']`. Right? That seems like a bad idea.
 @syranide Yeah, I agree, we don't want to break that.
 @fabiomcosta `input` specifically is special-cased in GCC and is never mangled, try some of the other tags: https://goo.gl/qf1FWL
 @fabiomcosta I just looked at the example you posted, I think @syranide is correct, this doesn't minify safely for properties like `svg` and `progress` :(.
 mapObject preserves keys.
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
  No plans at this time - most of these components are very tightly integrated into our stack and styles. We may open source a couple things around complex patterns. [Fixed Data Table](http://facebook.github.io/fixed-data-table/) is one that we've already published.
  You might need to create a more complete DOM in the popup window before rendering into it. It would be helpful to know what the markup inside the popup looks like after that first render. My best guess is that IE has done something different (perhaps it's in quirks mode or something, not sure how the window.open API works with about:blank)
 I tested in IE11 and was unable to reproduce.  My fiddle: http://jsfiddle.net/nw47bc3h/
 @lucaspin can you verify that this doesn't work on your version of IE?  and/or provide a fiddle that demonstrates the issue?
 Ok, cool, I'm going to assume we fixed the issue in 0.15 :), unless I hear otherwise.  Let me know if you discover a repro on 0.15 and we can re-investigate.
 @lucaspin Current thinking is "probably about a month", but that's subject to change.
  Looks like you figured out the solution - `React.cloneElement`.

For future reference: This is a usage question, rather than a bug in the React core. Usage questions are better answered on sites like StackOverflow, as we try to use github issues for tracking bugs in the React core.
  Worth mentioning; https://bugzilla.mozilla.org/show_bug.cgi?id=194231, `Node.normalize()` and possibly other scenarios. While relatively unlikely it's apparently fragile to rely on individually created adjacent text nodes, the only truly safe option seems to be to treat all adjacent text nodes as one.
 @mwiencek updated the pull request.
 This breaks if you're rendering onto pre-rendered markup right? Adjacent text nodes would then be merged and empty ones non-existent.
 cc @spicyj 
 @mwiencek updated the pull request.
 @mwiencek updated the pull request.
 @mwiencek updated the pull request.
 Sorry for not commenting earlier:

I was thinking that the best approach here might be to add delimiting comment tags around each text node so

``` js
<div>{'a'}{'b'}</div>
```

would become

``` html
<div>
  <!-- react-text: 2 -->a<!-- /react-text -->
  <!-- react-text: 3 -->b<!-- /react-text -->
</div>
```

when rendered. When updating we could update everything in between the matching comment tags. This would immediately solve the merging/splitting problem and would also leave us more resilient to browser extensions that change the page, like the popular ["cloud to butt" extension](https://github.com/panicsteve/cloud-to-butt/blob/741619376f2baa047f516392d588b63962855b14/Source/content_script.js) or you might imagine an extension that bolds or highlights certain words on a page by adding tags. This seems more robust in my mind. (Technically we wouldn't even need the "closing" comments but I think it's simpler to have them.)

We also shouldn't add any DOM-specific logic to ReactChildReconciler ‚Äì that's used on React Native too.

What do you think?
 @spicyj It might not be a good idea for complexity/performance reasons, but I would imagine the best solution would be to simply merge adjacent strings (and remove empty strings) from the intermediate representation that gets rendered to the DOM. I.e. the DOM renderer only ever sees individual strings sandwiched between elements, never multiple or empty strings. Minimal markup and is completely safe, but intuitively it might demand some rather non-trivial logic.

As for `<!-- react-text: 2 -->a<!-- /react-text -->` I would say `<div><!-- react-text: 2 -->a<!-- react-text: 3 -->b</div>` should be sufficient no? The closing comment would not actually provide any benefit. The only downside to comments is that all elements do come with a "significant cost", so avoiding it if possible would be a good thing, but other than that it seems great to me.
 Yeah, I know things got better when we removed the react-data ids.  Using comments may be no worse than using spans, but it does seem like it would be better to merge the strings if it doesn't make the code substantially more complex. 
 We can consider merging adjacent text nodes in a separate diff; I don't think that necessarily needs to be attached to this.

@syranide Yes, we don't need the "closing" tags as I mentioned in my comment but I think the behavior is simpler and easier to reason about if we keep them.

@mwiencek Yes, let's do that if you're up for it. I would like to not have the comment tags but I think it's better to be safe here and do something that we can be confident will work in all scenarios. Let me know if you run into any problems.
 > @syranide Yes, we don't need the "closing" tags as I mentioned in my comment but I think the behavior is simpler and easier to reason about if we keep them.

@spicyj It seems to me that it's basically `if (node.isComment && node.text === '...')` (for closing comment) vs `if (node == null || !node.isTextNode)` (for no closing comment). Unless I'm missing something they seem pretty much the same to me and IMHO I would favor the second for less markup.
 I was planning to support replacing tags in case an extension adds them, like if it wanted to bold a particular word.
 @spicyj Hmm, an interesting point... previously we could test if a node was managed by React, is that not possible in master anymore? That would suffice if we could. Otherwise yeah that's not a bad idea, and realistically we could shorten the closing comment to `<!-- / -->`, it can't occur naturally and it's extremely unlikely that it would be inserted by whatever messed with the code.

However, I'm a little worried about `<-- open -->foo<!-- close --><-- open -->bar<!-- close -->`, if some external tool tried to bold that, wouldn't it break anyway? (Still a good idea though, this is rather less likely scenario)
 @mwiencek updated the pull request.
 This looks really good overall so far. Let me know if any of my comments are confusing or if I can help with anything.
 @mwiencek updated the pull request.
 I don't have time this moment to look at the code again, but the perf test is probably failing because replaceDelimitedText is not instrumented (see the bottom of DOMChildrenOperations).
 @mwiencek updated the pull request.
 Sorry for the long delay. This is really awesome and I want to get this in. Can we look at moving the unmounting logic to DOMChildrenOperations? I think we may also have a problem with reordering text nodes when keyed text nodes are involved. Specifically,

```
<div>{new Map([['a', 'alpha'], ['b', 'beta']])}</div>
```

renders a div with two text children: alpha (with key a) and beta (with key b). If we swap the order to b then a, the text nodes should get moved around. (Sorry this is a little subtle.) Can you make sure this works and add a quick test in ReactMultiChildText for it?

Other than that, I think this looks great.
 @mwiencek updated the pull request.
 @mwiencek updated the pull request.
 This looks great. Thank you so much!
 @mwiencek I also wanted to jump in and say thanks!  This has been one of our long standing todo items, and no one has tackled it because it was a tough one, but you did a great job!  I'm really excited to see this merged!  Thanks!
 @mwiencek Amazing work. Thank you so much for contributing!
 @alcedo You can try turning off "Auto Minify" via your CloudFlare Settings control panel.  Haven't tried it myself, but that sounds like the relevant setting.  If that doesn't work, I'd recommend contacting CloudFlare support - I'd be extraordinarily surprised if they didn't provide a way for resources to be served unchanged.
  If you have specific requests for the devtools, please file an issue against that project itself. https://github.com/facebook/react-devtools
  Oh, I forgot to tag the release. I pushed a 0.14.5 release because I messed up the fbjs dependency, but either should work for you.
  Need these (but with an actual fbjs version with https://github.com/facebook/fbjs/pull/83, I guess 0.6) and with https://github.com/facebook/react/pull/5749 picked too.
 üëç Just make sure you bump to 0.6 and re-shrinkwrap with that
 Gonna push manually.
  @zpao It does appear that RN does this, so presumably we can too?  Do we need to check with legal first, or can we just merge it?
 I've spoken with lawyers in the past and this should be fine.

Thanks @rickbeerendonk!
  @spicyj I know you had some thoughts on this topic, just wanted to raise this PR for your attention/feedback.  It's nearly NYE, so maybe we won't get to this reviewed before the new year, but I do think we should fast track this PR to the extent possible :).
 @jquense updated the pull request.
 @jquense updated the pull request.
 @spicyj @syranide Can someone with expertise in this area of the core take a look at this, as per https://github.com/facebook/react/pull/5746#issuecomment-167939675?  Thanks!
 https://github.com/facebook/react/pull/5746#discussion_r48592301 https://github.com/facebook/react/pull/5746#discussion_r48608800 are my thoughts on this.

I'd like to see this fixed, but unless you can 100% reliably track last value (which I don't think you can) then this seems dead in the water. We could kind of do it if we drop event bubbling (IMHO yes please) but we'd still have issues with external influences and AFAIK there is no event that reliably detects changes to the value across the board, even in modern browsers.

Please correct me if I'm wrong, but that's my understanding of the situation.
 > What strategy would you suggest to fix the noted issues?

@jquense Based on my (admittedly limited) understanding there is no 100% and reliable strategy for this problem, that's all I'm saying. AFAIK there are cases where we simply won't know the actual last value, that seems bad. I'm all for fixing this but _personally_ if I have to choose between:
- Don't fix; inputs sometimes fire for noop.
- Fix; inputs will fire for noop in edge-cases, inputs will fail to fire for actual changes in edge-cases, the fix involves a lot of code.

That's my understanding of the situation right now and based on that "don't fix" seems like the best candidate. Again, please correct me if I'm wrong. But I'm happy for your contributions and ultimately it's up to the FB devs to decide, I'm not intimately familiar with the React event system. 
 @jquense The other things you mention I have no issues with :+1:. I defer to @spicyj or someone "official", but personally I'm just against the fragile deduping logic.

> I am just saying we are already in the worst case option for some inputs.

True, but I feel like there is difference between such issues introduced by neglect and those introduced knowingly through added complexity.
 As per conversation with Sebastian, going to tentatively accept.  We will sync with a few people internally to let them know that this change is coming down the pipeline, and push to www early in the week to maximize internal testing and make sure we're not breaking things.

@jquense can you fix the minor unit test failure?

@spicyj can you take a glance, and flag anything that you think would be a show stopper here?

Note to self: verify that we've cut v15 branch before merging.
 It is hard for me to verify correctness here without a lot of thought, but I think this general strategy is okay. It would be better if we could refactor things to a point where ReactDOMInput could be responsible for tracking a lot of this data and logic instead of tacking on expandos in ChangeEventPlugin but that is probably significantly more difficult.
 @jquense updated the pull request.
 @jquense updated the pull request.
 Putting a 15.x milestone here. We should review this ASAP after 15.0 is out so this doesn‚Äôt get stale.
 We try not to pick stuff except for regressions after an RC, sorry.
 Whatever the conclusion is I think we should find a way to ensure this does not get stale. For example we could have a `next` branch where this gets merged before master, that is synced with master every week. 
 Way back when this was accepted, I had a "Note to self: verify that we've cut v15 branch before merging.".  Sorry if that was a bit unclear, this was intended to land after v15.0.0.
 > Note to self: verify that we've cut v15 branch before merging.

We still can‚Äôt merge in master after cutting 15, can we? Because presumably this would need to go into 16 while the master would be used for 15.x.
 @gaearon No idea, I don't we've figured out how things are going to work under the new versioning system.  My preference would be to merge into master and cherry-pick for the point releases, like we've always done historically.  Otherwise, where does new code (with potentially breaking changes) go?  We can't freeze all development until we think we're ready to do another major release.
 > My preference would be to merge into master and cherry-pick for the point releases, like we've always done historically.

:+1: Thanks for clarifying! I haven‚Äôt been watching closely how this happens so I didn‚Äôt know that.
 We've cut the branch, let's get this in.
 Thanks @jquense!
 @jquense We're getting "descriptor.get.call is not a thing" errors on Safari that looks like it blames to this diff.  Can you take a look?
 Ping @jquense 
  Any opinions @sebmarkbage? I'm inclined to just live with this a bit longer and let Chrome/V8 versions get out that improve this out of the box (especially since Chrome update uptake is so good)
 I agree with @zpao 

When I run the benchmark, looks like native bind is 2x-ish slower than the custom implementations.  On canary, there is no difference (native is 10x faster, custom are 5x faster).  Realistically, by the time we get 0.15 out the door, all the chromes will be fast anyway and it won't matter.
 That's a reason for us to use the native implementation because it is incentive for browsers to do this work. We can sacrifice a little perf in the short term to get long term greater wins.

In this case, I don't expect it to matter much since auto-bound methods are mostly there for callbacks which are single action. The only case it matters a lot is if you call a helper a lot but you really should just be using a local module scope function instead. The call to `.bind()` itself is much more interesting to optimize than the call to the produced function.
  @prometheansacrifice updated the pull request.
 @prometheansacrifice updated the pull request.
 @prometheansacrifice Can you add an explicit return statement as per above, and then I think this is ready to go.
 Don't forget to add it to both getters (key+ref), even though I just called out one of them.
 @prometheansacrifice updated the pull request.
 This looks great, thanks @prometheansacrifice!
  The props `key` and `ref` are reserved by React, and used internally.  Component authors may attempt to access these properties (thinking they could read the value, as per https://github.com/facebook/react/pull/5740).  We could use `Object.defineProperty` (in dev mode) to warn if `props.key` or `props.ref` is accessed, and point the user to a note/discussion somewhere.  That way, users who actually run into the issue will always get a timely message that sends them directly to the relevant explanation/discussion.

This would be a good first bug, if we decide we actually want to do it.
 This sounds like a great idea to me!
 Yeah this seems reasonable.
 @alayek Take a look at https://github.com/facebook/react/pull/5744, that should give you a good start and a good idea of what we would be looking for.
 @alayek
- The module achieves deduplication by setting a boolean if it has already warned.
- The comments about breaking tests are referring to the failing unit tests.  Just run `npm run test` and `npm run lint` to verify that everything is working before pushing your changes.
- There are many places where you can discuss, including the IRC channel and/or reactiflux.  There are also github issues (which is what our core team predominantly uses), as well as several other channels.  The community is pretty big, but nothing is quite as good as reading through the code and github issues, IMHO.
  üëç thanks!
  I worry that we are adding a ton of stuff to docs, often covering edge cases that most users never hit.  It creates a lot of clutter, and makes the docs harder to understand, since they are covering all the manusha in a page that is trying to communicate a basic high-level understanding.  I suspect that most users wouldn't try accessing the key, since it is a React reconciliation hint rather than a prop on the element.  And even if they do, I wonder how many of those people would have read+remembered this little note buried deep in the page on "multiple components".

I think it might be better to use `Object.defineProperty` (in dev mode) to warn if `props.key` is accessed, and point the user to a note/discussion somewhere.  That way, users who actually run into the issue will always get a timely message that sends them directly to the relevant explanation/discussion.  I created an issue to track that idea: https://github.com/facebook/react/issues/5742
 Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Closing in favor of something more like https://github.com/facebook/react/pull/5744
  As far as I know this is expected. By the time `componentDidMount` fires you can do DOM manipulation so it makes sense that parent only receives it after children are mounted. That said you can use `componentWillMount` which fires in the opposite direction, parents first. 
  Sorry for missing this, a few comments coming inline‚Ä¶
 @cody updated the pull request.
 Thanks @cody!
  I think this is the problem:

<img width="461" alt="screen shot 2015-12-25 at 15 21 38" src="https://cloud.githubusercontent.com/assets/810438/12003517/3b6ee5b8-ab1b-11e5-8aca-dce98b511ca5.png">

`createNodesFromMarkup` uses a [dummy `<div>`](https://github.com/facebook/fbjs/blob/4bbe1a1e6b7160b51494d47746362cd59de2666d/src/core/createNodesFromMarkup.js#L24-L25) so it can later [assign `innerHTML`](https://github.com/facebook/fbjs/blob/4bbe1a1e6b7160b51494d47746362cd59de2666d/src/core/createNodesFromMarkup.js#L67) and pull out the created node. 

However it seems like (some?) namespaced properties are only taken into account when SVG elements are created inside `<svg>`.

cc @spicyj 
 Presumably, the reason it works initially is because it _is_ inside `svg` when the markup is first assembled an rendered.
 Related: https://github.com/facebook/react/issues/5061#issuecomment-156361189
 This should work okay on master now since we use document.createElement(NS) for everything except server rendering.
  It mimics the DOM Event object API which also has [`currentTarget`](https://developer.mozilla.org/en-US/docs/Web/API/Event/currentTarget) and [`target`](https://developer.mozilla.org/en-US/docs/Web/API/Event/target).

From `currentTarget` documentation:

> It always refers to the element the event handler has been attached to as opposed to `event.target` which identifies the element on which the event occurred.
 @max-mykhailenko Can you provide a jsfiddle that demonstrates the issue?  It appears to work in my fiddle: https://jsfiddle.net/gpm18sqd/
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 @MatthewHerbst updated the pull request.
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 Hi, thanks for the PR! I would like to amend this a little bit.

The important part is not that `arrayOf` accepts a custom type checker‚Äîit‚Äôs that it accepts a `PropType` which is, after all, a function. So it‚Äôs not really specific to `arrayOf`. The same could be said about `objectOf`, for example.

The prop type function signature that `arrayOf` accepts is not really different from the ‚Äúnormal‚Äù one as far as I know. This is the reason you can pass any normal `PropType` there‚Äîprecisely because it expects a `PropType` as an argument.

We are cheating a little bit by passing `(array, index)` instead of `(props, propName)` as the first argument so that we can keep them composable. However ultimately the first two arguments are ‚Äúthing from which to read‚Äù (usually `props` but can be `array`) and ‚Äúthe key to read‚Äù (usually `propName` but can be `index`).

So while I think your edits are useful, it would help to clarify it `arrayOf` doesn‚Äôt really accept a function with a different signature than the existing prop types. The same is the case for the last two arguments (`location` and `propFullName`)‚Äîwhile they are not currently documented, they are passed both to top-level propTypes and to `arrayOf` or `objectOf` ‚Äúchild‚Äù propTypes so listing them only in the latter case seems misleading to me. I would probably omit them completely from the docs if the example doesn‚Äôt use them.

Sorry it took a long time to review, and thank you for contributing! I‚Äôll be happy to review an update, if you‚Äôd like to keep working on this. For now, marking as needing an update.
 @MatthewHerbst updated the pull request.
 <s>Did `objectOf()` not satisfy your use case?</s>
<s>It‚Äôs mentioned in http://stackoverflow.com/a/35791125/458193 too.</s>

Whoops, I get it now.
You want to check the keys (which are always strings in JS) for conformity to a specific format.
 As for your question‚ÄîI would probably write something like `objectWithKeysOf(childValidator)` that works just like `objectOf(childValidator)` but runs the `customValidator` for the keys instead. It would receive the array of keys and the current index as the first two arguments. This way you could use an API similar to React‚Äôs existing API: `MyPropTypes.objectWithKeysOf(MyPropTypes.stringRepresentingDate)`. Of course the approach you came to in the SO answer also works‚ÄîI‚Äôm just suggesting making the child validator an argument, just like it is for `arrayOf()` and `objectOf()` so you can potentially pass different child validators there.

As for your PR‚ÄîLet‚Äôs just remove the two last arguments? They are not used in the example and distract from the main point.
 @MatthewHerbst updated the pull request.
 :+1: This is looking good. I left a few nits and it‚Äôs ready to merge then.
 @MatthewHerbst updated the pull request.
 @MatthewHerbst updated the pull request.
 Looks great! Can you please squash these into a single commit?
If you don‚Äôt feel comfortable doing it please let me know and I can do this manually on my side.
 I usually do something like this:

git checkout mybranch
git fetch origin // assuming 'facebook' is your origin
git rebase origin/master

// fix conflicts if any
// make sure rebase is over and git status says "N commits ahead of master"

git reset --soft origin/master // remove all commits
git commit -am 'my feature'
git push -f // overwrite PR

There are probably simpler ways but that is what I do. 
 Thanks for sticking through with this!
The changes will appear on the website next time we sync (likely within a week or so). 
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 Note: we will probably not take this. We're working on an effort to allow all SVG attributes to pass through in #5714.
 üëç I'm going to leave it open for the time being and we'll close all of the SVG issues/PRs in bulk (to make sure we haven't missed anything).
 > In fact I believe that you shall let all attributes pass through and just convert them from CamelCase to hifenated forms if react doesn't recognize the attribute

The current thinking in #5714 is not to be smart about it and to pass them through exactly as the user specifies. This way we don't need to care whether we are aware of all possible camel cased attributes that really _are_ camel cased in the spec (there are quite a few!)

The existing camel cased attributes will work with a warning for another version.
 Verified that `stroke-linejoin` works in master when specified as is.
  We are currently addressing this in #5714 once and for all, so I'll close this issue. I will leave your PR (#5727) open until #5714 is merged and will make sure this property works before closing it. Thank you!
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 Sounds good. I don't think it's any less true and if it helps, then let's do it. Thanks!
  @iamchenxin updated the pull request.
 @iamchenxin updated the pull request.
 No, this is fine. Sorry for not getting back to you when you first reset!
  This is a usage question best answered in another place (Stack Overflow is where we usually direct people). I'm going to close out as a result unless we think it's a React bug. If there are any followups, please start elsewhere and come here not for support but for bug reporting.

But I'll still see if I can answer the question. My guess is that since you are using `rhs_component` as your variable, the JSX transform is actually treating that as a DOM element and thus a string type. So you end up doing `var component = TestUtils.renderIntoDocument({type: 'rhs_component'});`. The return value is then a DOM component, not a Composite Component (thus the error that's thrown).

The JSX transform in babel does this blindly for lower case JSX now so you will want to use a variable that starts with an uppercase letter. `<RHSElement/>` perhaps.

While we're here, I would also suggest starting with a newer version of jest (unless you're stuck on Node 0.10).
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 There doesn't appear to be anything in the diff. If you meant to submit a PR please send one from the correct branch and include a description for this PR. Thanks!
  Thanks! That was there because we used to allow some of those pesky in-browser tests to fail and I missed this option when removing them in your favorite PR :P (https://github.com/facebook/react/pull/4393/files#diff-354f30a63fb0907d4ad57269548329e3)
 I remember seeing something about that a while ago, so thanks for the reminder. We'll keep that in mind and probably crib from lodash whenever #5703 gets done.
  Looks legit to me, cc @spicyj for sanity check.
 @edmellum updated the pull request.
 Thanks @edmellum!
 @shastings86 care to elaborate?  Also, please watch your attitude; at first glance, your comment appears to be very negative and not constructive - which is not the type of community we want to foster.
  cc @sebmarkbage @spicyj 
 This might be #2410.
  @jineshshah36 There isn't enough information here to be actionable, but this error is usually a usage question.  Your components are likely doing something that causes the checksums to differ.  Sometimes the reasons are subtle, like an unprintable character.  Usage questions are better answered on sites like StackOverflow, as we try to use github issues for tracking bugs in the React core. For this reason, I'm going to close out this issue, but feel free to continue the conversation here or move it to StackOverflow.

If you can provide a minimal test case that demonstrates a bug in the React core, we can investigate further.
  We don't want to have a huge long history of one-line typo commits.  Please find all the changes you want to make and create a single PR with all the changes.  (eg. merge https://github.com/facebook/react/pull/5715, and any other corrections, into this PR).
 @jwworth updated the pull request.
 Thanks!
  We don't want to have a huge long history of one-line typo commits.  Please find all the changes you want to make and create a single PR with all the changes.  (eg. merge https://github.com/facebook/react/pull/5716, and any other corrections, into this PR).
  # Update: this was reverted in favor of a different approach in https://github.com/facebook/react/pull/6243.

# If any attribute is missing please file an issue and we'll add it.

------------------


All attributes defined on SVG elements will now be passed directly regardless of the whitelist.
The casing specified by user will be preserved, and `setAttribute()` will be used.

In the future we will remove support for the camel case aliases to the hyphenated attributes. For example, we currently map `strokeWidth` to `stroke-width` but this is now deprecated behind a warning. When we remove support for this, we can remove some of the code paths introduced in this commit.

The purpose of this change is to stop maintaining a separate SVG property config.
The config still exists for two purposes:
- Allow a migration path for deprecated camelcased versions of hyphenated SVG attributes
- Track special namespaced attributes (they still require a whitelist)

However it is no longer a blocker for using new non-namespaced SVG attributes, and users don't have to ask us to add them to the whitelist.

Fixes #1657

Reviewers: @spicyj @jimfb @sebmarkbage 
 This seems good.
- Can we make the warning here SVG-specific? Maybe "SVG attribute clipPath is deprecated; use the original attribute name clip-path for SVG tags instead."
- Instead of a new "deprecated" flag, can we just compare the attribute name in createMarkupForSVGAttribute and warn if it's different (and there's no namespace)? If I'm missing some reason that won't work, this way is fine too.

I thought I had a third thing too but I forget now.
 Amended the commit based on your comments. I added a completely separate code path for the SVG warning so it's easy to remove later and we don't have to think about `getPossibleStandardName` being broken in this case.
 @gaearon updated the pull request.
 @gaearon updated the pull request.
 I updated the PR with what I believe to be the complete implementation, but I haven't tested it in the wild yet. Does it look good to go otherwise?
 @gaearon updated the pull request.
 @gaearon updated the pull request.
 One thing that concerned me is whether I should add new `DOMPropertyOperations` methods to 

``` js
ReactPerf.measureMethods(DOMPropertyOperations, 'DOMPropertyOperations', {
  setValueForProperty: 'setValueForProperty',
  setValueForAttribute: 'setValueForAttribute',
  deleteValueForProperty: 'deleteValueForProperty',
});
```

at the bottom.
 @gaearon updated the pull request.
 I updated the PR to merge cleanly on top of #5590 but unlike #5590 it still uses the old warning system.
I'll look into updating this PR to use devtool but this can be done separately.
 I moved the warnings into a separate devtool to align with #5590.
I'm adding @jimfb to reviewers so he can evaluate whether I'm using it correctly.
 @gaearon updated the pull request.
 I think this looks good. Thanks for the new tests!
 @gaearon updated the pull request.
 No this will not be backported.
  Thanks!
  If you need a real-time solution, then you probably want to do diffing of some sort.  You may be able to convert the output of your markdown library into JSX elements using some code similar to https://facebook.github.io/react/html-jsx.html - which would allow you to have React to do the diffing. Or you may be able to modify your markdown library to produce JSX elements instead, which similarly allows React to do the diffing.  Or you may do the diffing yourself by writing some code to compare the source markdown, and only pass the changes into your markdown library, and do targeted updates.  Regardless of which solution you choose, this is a usage question rather than a bug in the React core.  Usage questions are better answered on sites like StackOverflow, as we try to use github issues for tracking bugs in the React core. For this reason, I'm going to close out this issue, but feel free to continue the conversation here or move it to StackOverflow.
  Sure, seems reasonable.  It's part of our official docs instead of just a blog post, so I think we can be a little more aggressive with the changes than we would have been to the original blog post (this isn't the most aggressive change we've made to this doc).
  @jdalton updated the pull request.
 Awesome, thanks for taking this on. I have a couple followups - I want to split this task into two so that we don't have the coverage overhead in the default `grunt test` case and only generate that when running on travis (`grunt jest:coverage` probably), and then the bits to hook it up.
 I guess one change before I merge here - can you add `coverage/` to `.gitignore` so we don't accidentally add those in later?
 @jdalton updated the pull request.
 > Added :D

Thanks!

> OT: Out of curiosity what's the typescript and coffeescript dev dependency for?

We have typescript and coffeescript class tests to ensure classes there behave as expected once compiled down to JS and then we also test that all of the specs stay in sync.

And yea, the trailing commas rule is only for multi-line objects and arrays. We'll probably turn it on for function calls once [that spec](https://github.com/jeffmo/es-trailing-function-commas) gets further along.
  Thanks.
  Jest can do this and we can report through coveralls or code climate, it doesn't matter). This shouldn't require too much work but will need some finishing touches by me or Ben for the TravisCI integration.

I'll plan to do this soon if nobody else jumps on it.
 Probably need the --retain-lines option for Babel. We already [do that](https://github.com/facebook/react/blob/master/scripts/jest/preprocessor.js#L39) when running the tests so that stack traces are usable.
 With #5707, #5713, 85e646015d1a9482858d04973472631c7ba12891, and 89a0ef4ff915ce1f95824000fc406a31b6ecda2f we're all done here. Thanks for the help!

And @yaycmyk, the reporting seems pretty accurate so the retain lines flag would be my recommendation to you.
 @yaycmyk yea, that option sort of sucks üò¢ - it doesn't support globbing as you've noticed. That's why @jdalton added code to expand those globs and write a separate config that gets consumed when including coverage reporting.
  We currently don't run the unit test suite in browsers in open source. We only run the internal Web Driver suites at Facebook, however, that isn't very helpful to external contributors nor is it helpful to browser vendors since they can't run these tests against their own builds.

We disabled it in #4393 but if we can solve those issues or replace it with a new runner that would be great for the community.
 We also want public regression benchmarks, tracked here #2154 but that is a separate issue from the unit test support.
 Ideally we would be running the existing tests since jest tests is likely what we will keep writing for.
 No one is owning this for Jest but the idea would be to turn Jest into a server that can do all of its resolution on the server and send modules to the client. On the client it would require isolated environments to match jest's behavior. It can be done and I'd be happy to mentor anyone who'd be willing to work on this. We don't really need this at FB but it would be pretty good for the open source community, so I'm supportive.
 Why is impractical for Jest to feed its information to Browserify/Webpack/FB-specific bundler? Even if it is just a server, can't it just deal with module resolution and mocking and leave the bundling to a tool specifically built for this?

_Edit: despite the new Collaborator badge I have very little idea about how Jest works with or without React, as I only worked with Mocha and Karma before. I'll say stupid things here!_
 This Jest PR is also focused on making module resolution more modular: https://github.com/facebook/jest/pull/599 Once that's done we can think of how to provide other module resolution implementations and how they may ship JS to the browser if we end up building this.
 This kind of behavior for Jest could never work for us at FB. We have thousands of test files and tens of thousands of modules and our bundler is completely separate from our JavaScript code. It is incredibly complex, unpredictable for humans and uses machine learning to optimize packages. Using this system to run **unit** tests would be incredibly slow and is reserved for integration tests that actually open up a web browser to load individual web sites and interact with them.

That being said and given what I said before, I'm completely open to any and all help if anyone wants to spent some time building this. Jest was designed to be modular but we never did a great job of presenting it that way. The PR mentioned above is going to help a lot and I'm going to focus more on making it actually modular and add documentation in the future to highlight all of this. I realize that a lot of projects aren't at Facebook scale and they can benefit from these features.
 How will changing the module resolution in jest solve the browser tests? Is this off-topic?

Seems like changing the runner would be much more viable, but it doesn't let us integrate the test into other FB infra and run them in React Native, so if we can avoid it and use a browser version of the jest runner, that would be ideal.

We could also carve out a space for a separate set of DOM related tests since most tests are generic enough that they don't add any additional test of the DOM. That makes contributing a bit of a pain since you need to learn two test runners.
 Wouldn't that be the opposite of a pluggable module resolution in jest? It would mean that you would want to use jest's module resolution in a different bundler, no?
 An in-browser runner would most certainly have to ship with its own require implementation. I'm quite convinced that you'd want Jest to play a part in the bundling for test runs. Unit testing generally doesn't want the same kind of bundling (or bundling at all) or the same set of transforms as prod. Please proof me wrong though.
 @oliverwoodings oh yes, I agree with that. Part of that PR is to make the transform function async, so that other transformers can be injected more easily.
 Jest is like a VM and virtualizes the JavaScript that is run inside of it. The require implementation can be found here: https://github.com/facebook/jest/blob/master/src/HasteModuleLoader/HasteModuleLoader.js#L510 ( https://github.com/cpojer/jest/blob/haste2/src/HasteModuleLoader/HasteModuleLoader.js#L538 contains a cleaner version and is from the haste2 PR) and is a large part of the module loader. `require` in jest does not mean entirely the same thing that it does in CommonJS. It has additional features, like mocking and allows to wipe away the cache more easily to be able to build tests that don't carry over state from one test to the next.
 Feel free to join us on discord (see http://facebook.github.io/jest/support.html ) if you want to discuss potential implementations.
  Thanks!
  @p-jackson Sounds like a reasonable approach to me.
 Note: the original PR that fixed this was reverted so this bug still exists.
  Stupid smart quotes‚Ä¶
  @kolodny updated the pull request.
 Looks great, thanks!
  Both of these cases can be summarized as follows: React on the client will blow away the existing dom nodes when rendering. That will take some time and you'd lose the data that was server rendered but not on the client. You'd also lose any state in the dom that was added by the user before React mounted. You can perhaps avoid the rendering difference if you just use noscript. Optimizing the markup so you don't have reactids might not be worth it either - those will be gone in the next major release.
 @zpao @spicyj Those react-ids will be gone for SSR?  Somehow I thought we were retaining those for SSR in 0.15, but maybe I'm just wrong.
  Whoops. Other examples seem fine.

cc @zpao
 Thanks @cody, fixed those too.
 @gaearon updated the pull request.
 ping @spicyj, can I merge this?
 Sure. Then `git cherry-pick -x` on the 0.14-stable branch (or tag it with "needs merge to stable" and someone will do it‚Ä¶ eventually).
 Just did this. Should I also do this for my other PR (#5702)?
 Just for the website. Shouldn't matter for the other one because everyone should be looking at master on github.
 Got it.
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 @adnasa updated the pull request.
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 ReactCSSTransitionGroupChild is considered internal to the addon and we don't support extending it. Extending React.createClass components is not even recommended in general. You can and should copy the code if you want to make a new version of it.
  Shallow rendering only renders one level deep.  `componentDidMount` means the component has fully rendered (and the component is allowed to do things based on this assumption), but since shallow rendering doesn't fully render the component, calling that lifecycle would be incorrect.
 @lovedota As per above, it makes no sense to invoke that method.  If you need that method, you should be using regular rendering instead of shallow rendering.  Regular rendering allows the render process to complete and can thus legally invoke `componentDidMount`.
  `dangerouslySetInnerHtml` should let you output arbitrary data to a node.
 To render it with React, you're going to need to get your latex into some sort of javascript form one way or another.  That's entirely outside of React's control.  Depending on your server or build architecture, you may be able to use macros or file generation/injection of some sort, or generate the file and insert with a variable who's value you read from another source.

Once you get it into javascript, it becomes the domain of React, and `dangerouslySetInnerHtml` should do what you want.

This is a usage question, rather than a bug in the React core. Usage questions are better answered on sites like StackOverflow, as we try to use github issues for tracking bugs in the React core. For this reason, the issue was closed.  You're welcomed to continue the conversation here, but you may want to move it to a site intended for these sort of questions (like StackOverflow).
  @jquense Would love to get a fix merged.  What is the status on this?  Are you blocking on us, or are we blocking on you?  Feel free to ping me on google hangouts if that would be helpful.
 Ok, if I understand this correctly (please correct me if I'm mistaken), https://github.com/facebook/react/pull/5746 is a superset of this PR.  We've decided that we want to take that one, so I think this PR can be closed.
 @jquense updated the pull request.
  I'm inclined to take this one and then turn #5685 into a separate document so we don't make the getting started page overwhelming. I commented over there to that effect. If you have any strong opinions either way, let me know!
 Thanks for the reminder, I totally dropped the ball here. Let's do this.
  @tgandrews updated the pull request.
 @tgandrews updated the pull request.
 @tgandrews updated the pull request.
 My original thinking here was that we would do something more like #5686 for this page and then have more in depth documentation on a separate page. With this as is (and the markdown formatting fixed), it's a really daunting page with a lot of scary information that is not necessary to "get started". Here's the full rendered page: https://cloudup.com/cOdkbVBRUoY

So I'm inclined to just take the other PR and then we can flesh out a full page on using bundlers (or 2 separate pages). Does that sound reasonable to people?
 We also shouldn't show the config for production mode separately from the development config. People will just copy whatever's on the page, and end up with a build that has no source maps, no propTypes checking, etc.
 Thank you very much for the effort.

Ultimately it seems that the result is indeed too in-depth for a getting started page. We merged #5686 and as a starting point, and there is some work in progress on separate bundler docs in #6148. I‚Äôll mention your PR there so it stays for the reference in case we want to cherry-pick some parts from it.

Cheers!
  Best bet will be to lint against this. Since JSX just gets compiled to objects (either with that constantElements option, otherwise just the props themselves), what you're actually having a problem with is that duplicate keys in objects is a strict mode violation. There's no way at runtime to know that you had duplicate keys (if you didn't get a strict-mode parse error), so React can't protect you. Since this is in JSX, built-in lint rules don't work so you want something like [this rule](https://github.com/yannickcr/eslint-plugin-react/blob/master/docs/rules/jsx-no-duplicate-props.md) from eslint-plugin-react which will warn you.

Sorry we can't do anything, but good luck! In case you can't tell, I _strongly_ suggest integrating eslint into your workflow if you haven't already :)
  Hmm, yeah, events are tricky.

> It seems as though React is keeping track of the X/Y coordinates of the click and applying them to whatever is there after the re-render happens.

Admittedly the event handling is a deep dark part of React, but I'm pretty sure we don't do this.  I suspect that what you're seeing is browser behavior.  My fiddle (https://jsfiddle.net/4kzkzxyv/) demonstrates by doing a bunch of work in a click handler, and then hiding the button, resulting in subsequent clicks being applied to the second button.

Of course @syranide and @spicyj would know better than me on this point, I could be just wrong.
 Yeah this behavior seems like native behavior and I would say entirely logical. If a click removes something from the screen then it should not be clickable after that (it no longer exists), the click should either be ignored or go to whatever is now at the cursor position after the update.

Although I would argue browsers should not buffer clicks, I'm not sure if there's a non-obvious non-fragile workaround to that (event timestamp is for when it's dispatched, not for the user interaction I think).
  Thanks for the heads up!
  It shouldn't be hard to make this work for textarea too, right? I guess select may be a bit harder.

Btw ‚Äì lint is failing.
 @hayesgm updated the pull request.
 I would like to have consistency between input and textarea here. I guess for textarea we need to change the children/textContent? :\

I do think this is better than #5666 even though it seems like more work.

Yeah, want to do a follow-up PR to remove HAS_SIDE_EFFECTS?
 @hayesgm updated the pull request.
 @spicyj I think I've said it before, but using attributes instead of properties for `value` seems really quirky if you ask me. If you type normally into a field then only the `value` property is updated, this is according to the standard, it's also standard practice to update the property (and not the attribute) for this reason. So as far as I can tell, this breaks with convention, introduces subtle edge-cases for those relying on it (because of timing and not all changes are cought) and makes React controlled inputs behave differently from all other inputs.
 HTML does not have a concept of switching from `<input value="a">` to `<input value="b">`. If you render from scratch then the property and attribute are both changed. When doing an update, we have to define the semantics and decide whether we want to update the property or the attribute. There are arguments both ways, but "breaks with convention" is not a valid one (except when comparing with the convention that React itself has set so far).
 @jimfb Do you want to take a look at this one?
 > There are arguments both ways, but "breaks with convention" is not a valid one (except when comparing with the convention that React itself has set so far).

@spicyj I don't agree, put an input on a page, type into it and inspect. That's the convention set by the standard/browsers, we will be explicitly going against that and controlled inputs will thus differ from uncontrolled inputs in behavior too. Any change to a controlled input that doesn't emit an event (like autofill) will also cause unexpected behavior as the attribute will then not mirror the property until updated. What is the argument for using attributes?
 I'm inclined to agree with @spicyj on this one:

> If you render from scratch then the property and attribute are both changed.

I'm fine with using attributes here, to match the behavior of a fresh render.  I left a few comments/nitpicks.  Conceptually, this diff looks fine to me ( :+1: ) .
 > I don't agree, put an input on a page, type into it and inspect. That's the convention set by the standard/browsers, we will be explicitly going against that 

@syranide Nowhere have we said that updating the value via React should have the same behavior as typing into an input, and I'm not sure why that should be the case either. It is cleaner and simpler conceptually to have it match what you would get on a clean rerender as long as that doesn't cause problems practically.

The motivation for this change is #4618 ‚Äì React currently fails to update the defaultValue property (which always matches the value attribute) which means it is not possible to change an input's "default value" after initial render, which is used by an `<input type="reset">` button.
 > The motivation for this change is #4618 ‚Äì React currently fails to update the defaultValue property (which always matches the value attribute) which means it is not possible to change an input's "default value" after initial render, which is used by an <input type="reset"> button.

OK, that argument I kind of get, but if you're using controlled inputs, I would think the solution is to reset the state, that's the point of controlled inputs. Anyway, that's HTML for you, I get it.

But if that's what we want then why not just set the `defaultValue` property? Why set the `value` attribute? I would also think the useful behavior here would be for it to reset to whatever value the input had when it was created unless `defaultValue` is explicitly set, not reset to the current value (because `reset` for controlled inputs really is a cheap shortcut).

**PS.** I also get the desire to have controlled inputs behave as if they're always fresh... but it's odd behavior for HTML. But that's my opinion.
 > But if that's what we want then why not just set the `defaultValue` property? Why set the `value` attribute?

@syranide `.defaultValue` and the `value` attribute are directly linked:

![image](https://cloud.githubusercontent.com/assets/6820/12245500/0d0786dc-b866-11e5-92b1-63254e61f287.png)
 > @syranide .defaultValue and the value attribute are directly linked:

@spicyj If you set the `value` attribute yes, not if you're setting the `value` + `defaultValue` property...?
 @syranide My screenshot shows exactly that.
 Ok, I'm not entirely sure where that discussion leaves us, but I'll let @spicyj and @syranide figure that out.  Are you guys still disagreeing about something, or are you guys just stating facts now :P.

Either way, there are a few inline feedbacks, plus this needs to be rebased.  @hayesgm, can you do that?
 @spicyj Oh my bad. @jimfb Heh, this was more complex than I initially thought, I would personally go for https://github.com/facebook/react/issues/5819#issuecomment-170701055 and managing `value` and `defaultValue` separately, with `defaultValue` being untouched if not set. It feels more like how browsers usually behave and makes it slightly more versatile... but I can't really argue for it without involving my own opinion so either is fine really. :+1: 
 @hayesgm Sounds great, thanks.

With regards to where the PR stands, I _think_ we're in one of those situations where there are two suboptimal alternatives and no visible optimal, so we need to just choose one of them.  To be honest, the discussion lost me a long time ago, but I'm hoping that after you rebase then someone will be like "ok, looks good" and click merge :P.  Either way, I hope that Ben and Andreas will figure it out (quickly), and rebasing should help move the discussion forward.
 > With regards to where the PR stands, I think we're in one of those situations where there are two suboptimal alternatives and no visible optimal, so we need to just choose one of them.

@jimfb I don't want to stand in the way and I'm fine with spicyj's all things considered :+1: 
 @hayesgm updated the pull request.
 I think the only other thing I'm worried about is if this can cause extra cursor jumps when defaultValue is set. Code comments indicate it might be a problem in IE9.
 @spicyj Does @hayesgm's response address your concerns?  Are we ready to go on this one?
 Not really. We shouldn't do this switch if it introduces behavior differences between browsers. I'm not even sure this is desirable and would feel more comfortable if the effective value did not change when changing defaultValue. I think that might be possible if we save the old value before each update and restore it after.
 I‚Äôm going to close this out because it doesn‚Äôt merge cleanly anymore and, more importantly, there is no consensus on how to proceed. Both this PR and #5666 can exist as a reference for both approaches but let‚Äôs continue the discussion in #4618 to figure out what behavior we actually want, now that we know drawbacks of either implementation.

Thank you for your work on this!
 We might want to keep this one open, at least until we come to a conclusion on v15.  I think this PR is a perfectly reasonable fix for https://github.com/facebook/react/issues/6119 and https://github.com/facebook/react/issues/6219, both of which are blocking v15.  As an added bonus, it happens to also fix https://github.com/facebook/react/issues/4618 :P.
 > I think this PR is a perfectly reasonable fix for #6119 and #6219, both of which are blocking v15. As an added bonus, it happens to also fix #4618 :P.

Nevertheless, unless I‚Äôm mistaken, it introduces a breaking change in how `textarea` treats changes to its children which can affect many apps. We have not warned about the new behavior anywhere so this might complicate adoption of 15.

More info on behavior change: https://github.com/facebook/react/pull/5680#discussion_r50323244.
  #5672 made it clear that we could do better. #5658 improved the situation slightly but we still don't discuss how to actually use these things together.

Quickest short term fix would be to explicitly describe how you would use DefinePlugin to do what envify is doing - https://twitter.com/dan_abramov/status/592692202335301636 is nice and concise.

Longer term I'd like to have some more flushed out docs around using React from start to finish with both browserify and webpack (and maybe more if needed). But let's start simple.
 Reopening to track the longer term ideas.
  For complex components, defining `shouldComponentUpdate` (eg. pure render) will generally exceed the performance benefits of stateless components.  The sentences in the docs are hinting at some future optimizations that we have planned, whereby we won't allocate an internal instance for stateless functional components (we will just call the function).  We also might not keep holding the props, etc.  Tiny optimizations.  We don't talk about the details in the docs because the optimizations aren't actually implemented yet (stateless components open the doors to these optimizations).
 Correct.  Such memoization would break any application that was not using immutable data, because the "optimization" would be making an assumption that the root prop reference changes when the data changes.  Imagine that the prop is an array, pushing to the array would not show up in a shallowCompare, which is why that optimization is not valid by default.
 There are discussions about having a `pureRender` flag that you could set on the function, or allowing it to participate in the shouldUpdate lifecycle, but that's currently not implemented.  At the moment, stateless functions can not be pure-render.

It is worth keeping in mind that sometimes people abuse/overuse pure-render; it can sometimes be as or more expensive than running the render again, because you're iterating over the array of props and potentially doing things like string compares, which is just extra work for components that ultimately return true and then proceed to rerender anyway.  PureRender / `shouldComponentUpdate` really is considered an escape hatch for performance and is not necessarily something that should be blindly applied to every component.
 Elm and Om are both far more functional/immutable than general javascript, which is probably why it makes more sense there.  We are supporting standard javascript as a target language, and javascript is a language where mutability is common.

My perf benchmarks have found string compares to sometimes be quite slow (just doing string-compares of the prop-names with pre-defined values that we need to handle specially, and that isn't even arbitrarily long data compares).  Hash comparison can only detect miss-matches, but can not guarantee that two strings are equal (due to collisions), so to prove equality you still need to walk the whole string, but your assumption is that the two strings are equal in the common case, otherwise why would you be using pure-render (ie. with hashing, you still need to walk the whole string in the supposed common case).  String pooling does a better job than hashing, but it starts to get complicated.

Anyway, we digress.  The simple answer is: no, we don't do pure render by default, but we may provide a way for you to opt-in in the future.
 I also come from a Java background.  Java's pooling works pretty well, but you still can't depend on `str1 == str2` in Java, for exactly the reason that pooling is not guaranteed by the JVM because "it starts to get complicated".
 I'm going to close this out, since it was mostly a discussion thread and there is nothing actionable here.
  This doesn‚Äôt seem like a very common use case, and can be arbitrarily slow so I don‚Äôt think it‚Äôs something we want to support in the core. I‚Äôm glad you found a solution that works for you! I‚Äôm closing but let us know if you have more thoughts on this.
  My assumption is that we don't want to do this, because it's easier to generate the changelog all at once just prior to a release (we'd have to go through the history at the end anyway, to ensure we didn't forget something along the way, and it's easier to organize the list when you have a holistic view of the final release).  Until then, that's the whole point of being able to do a git log, as you linked above.

We are generally provide fairly advanced notice for things like deprecations.  For instance, the docs indicate which methods we'd like to deprecate (eg. see: https://facebook.github.io/react/docs/component-api.html).  You can also watch the github issues and the pull requests, either of which would give you a pretty good indication of what's being done.

cc @zpao, who can reopen if he decides this is something we actually want to do.
 No plans to do this. I understand the desire and I've done it for some other projects, but I think we're mostly happy with generating this by hand after the fact.
  Thanks @yangshun!
 @yangshun's answer is exactly what any of us would have said for an "official" answer üòÄ
 @littlee Every minute we spend answering usage questions on github is one fewer minutes we can spend fixing React to make it better for everyone.  That's why we push people toward StackOverflow, where the answers are generally just as good (sometimes better) and don't consume disproportionate amounts of our time.
  üëç thanks!
  Our documentation here is not a step by step process and could use some improvement, you're right. Sorry you had trouble. I'm going to close out and I filed #5679 for improving our docs - your issues are relevant but are anecdotal and we'd benefit from a concise description with action items.

As for the file size - all you've done is some string replacement (`s/process.env.NODE_ENV/'production'/`). If you want to reduce the file size as well you'll need to use something that does dead code elimination to remove the `if ('production' !== 'production')` blocks.
  Please see https://github.com/reactjs/react-future/issues/40#issuecomment-142442124 and https://github.com/reactjs/react-future/issues/40#issuecomment-153440651.
 @gaearon is correct, duplicate of https://github.com/reactjs/react-future/issues/40.
  Fixed: http://jsfiddle.net/8uoohgxm/
  `react-tools` isn't supported anymore so we have no plans to push a new release to remove the `"preferGlobal"` setting.
 We did have a message actually for a little while but it interfered with React Native (which was still using react-tools for historical reasons). But that's no longer the case so I'll push that message back in. It doesn't require a new release so we won't change the preferGlobal bit.
  > If some components want react, and some components want react/addons

Can you change the components to depend on the individual addon packages released with 0.14, such as [react-addons-transition-group](https://www.npmjs.com/package/react-addons-transition-group)?
 The plan is to decouple these. We don't have a solid timeline for that but it's the plan. Sorry it's causing problems. I'm going to close out since there isn't anything immediately actionable here.
  @hayesgm updated the pull request.
 This requires fewer changes but #5680 is closer to where I'd like to end up since we're moving away from properties and towards attributes in most cases (e.g., see #1510). Plus with #5680 it looks like we may be able to kill "hasSideEffects" since that logic will be inlined into the form components that need it and no other properties do.

So let's go with that one.
  You can't have something like `return <div></div><div></div>` because you must return only a single jsx element, and there are two adjacent jsx elements there.  Instead try something like `<div><div></div><div></div></div>` which is a single jsx tag with two children.

This is a usage question, and we try to keep github issues for tracking bugs in the React core, so I'm going to close this out. Please ask usage questions on StackOverflow in the future.
  Not all `warning` calls are wrapped in `__DEV__` checks, eg https://github.com/facebook/react/blob/master/src/addons/ReactFragment.js#L38-L42. So we need to do this unless we get really strict (and write a lint rule enforcing) that we're always inside a `__DEV__` check.

Our internal transform just removes `warning` calls entirely for prod builds but we need to be more conservative here to support the hybrid dev/prod runtimes for npm.
  Thanks!
  I'm pretty sure this is just an artifact of the order that the document-level event listeners get registered.

React uses a synthetic event system. The interaction between native events and synthetic events is strictly undefined. Sebastian wrote a post about this once-upon-a-time, how native and synthetic event systems are, by and large, inherently not interoperable.
  I'm not sure why this issue is being filed against the React repository.  Static property initializers were not approved in ES6, though they may be approved in ES7+.  Either way, the syntax rules are part of Babel not React.

Also afaik, all our documentation uses the following pattern:

```
class MainApp extends React.Component {
  ...
}
MainApp.propTypes = ...;
```

Which afaik, is valid/legal ES6.
  No, afaik, there is no such optimization at this time.
  This is a usage question, rather than an issue in React.  For this reason, I'm going to close it out.  Usage discussions are better asked on StackOverflow, as we use github issues for tracking bugs in the React core.

This is a pattern known as "wormhole".  There are currently a couple of workarounds (like `cloneElement`, `context`, or data-driven), but they are admittedly imperfect.  We've been discussing the pattern for a long time, but we haven't yet come up with a "blessed" solution.  When we do, we'll be sure to communicate our ideas/design.

Cloning the element is usually a fine solution, using `context` would also work.  I'm not entirely sure what you mean by "breaks all the child lifecycle events".  Having `componentWillReceiveProps()` get called multiple times is expected, regardless of whether or not you clone.  Re-cloning really isn't very expensive.

The data-driven solution (which was one of the workarounds I mentioned above, but the one you didn't mention) is something like:

```
var myData = [new AccordionItemData("title", <p>body</p>), new AccordionItemData("other title", <p>other body</p>)];
<Accordion data={myData} />
```

Then you iterate over your data and render the accordion items with any data you want.  If you want to allow people to customize their accordion item, you can take in a function (as a prop) that takes in the title+body+whateverYourAccordionWantsToProvide and returns JSX representing the new AccordionItem with appropriate props.  That might look something like this:

```
var myData = [new AccordionItemData("title", <p>body</p>), new AccordionItemData("other title", <p>other body</p>)];
function MyCustomAccordionItemRenderer(title, body, isCollapsed, whatever) {
  return <div className={isCollapsed ? "invisible" : "visible"}><h1>{title}</h1><div>{body}</div>;
}
<Accordion data={myData} myAccordionItemRenderer={MyCustomAccordionItemRenderer} />
```

Anyway, good luck with your app!  Closing this out as per above, but free to continue the discussion on this thread or move the discussion to StackOverflow.
 > This makes it impossible to determine what the previous state was, since the cloned element is completely fresh. The same applies to will/did lifecycle events as the next and previous props/state are useless. I know this might not be fixable, as it's a side effect of cloning, but thought I would report it anyways.

This statement confuses me.  Cloning the element does not create a fresh instance.
  The "getting started" guide is intended to provide a minimal example to get the user off the ground, and the existing example already does that.  Providing too many examples/alternatives is just confusing, and makes the section too long.  That's my two cents.  cc @zpao for thoughts.
 I like it, let's do it.
 Thanks!
  This is third-party code which we aren't going to modify. Thanks though.
  As @iamdustan said, we use github issues to track bugs in the core.  @iamdustan listed a few good places to have discussions like this.
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 Yeah, I agree, especially since this is the first time that the `__html` is used, that should be part of the highlighted area, because it's pretty critical to using dangerouslySet.

Thanks @adraeth!
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 This is fantastic, thanks @jutaz!
  Thanks for the PR!

However, this copy of react.js is actually a derived resource, built form the `src` directory, and those typos are already corrected in the source.  We don't want to manually modify the derived resource, and the fixes will propagate over once we regenerate that file, so I'm going to close out this PR.

If you're looking for ways to contribute, I recommend taking a look at this list: https://github.com/facebook/react/issues?q=is%3Aopen+is%3Aissue+label%3A%22good+first+bug%22
  I actually just created https://github.com/facebook/react/pull/6059.  FWIW, I probably would have taken this change if I had seen it before creating my own PR :P.  Anyway, I'm going to close this out in favor of https://github.com/facebook/react/pull/6059 because it's easier for me to iterate there, and there are a couple things I don't like here:
- "In the child component, we can then invoke the callback via the `onCommentSubmit` prop:" talks about something that isn't in the code fragment that follows, which is confusing.  I would be confused and sit there studying the code, only to realize in the next paragraph that I haven't been shown the relevant code yet.
- This uses the word "properties" instead of "props" in the second sentence.

Thanks for your PR, sorry it fell off the radar.
  @milesj That is incorrect.  `componentWillReceiveProps` does not guarantee that props have changed, as I have already mentioned to you on your diff in https://github.com/facebook/react/pull/5776#discussion_r48784945

@volfied Your approach seems pretty reasonable to me.

Background: I understand that it's a little bit of boilerplate, but if the order of the two lifecycles were switched, users would have the opposite problem where you are calculating the new state in `shouldComponentUpdate` because you need to know if the state changed in order to decide if you were going to update.  Even worse, `shouldComponentUpdate` might return false, but the component might still need to know about the new props and save them into internal state.  Therefore, the order couldn't be switched.

Your original question was:

> Is there a cleaner way of approaching this where no resources are wasted on unnecessary state calculations?

I don't know of a cleaner way off hand, but perhaps someone else will have ideas.  Your solution seemed fine to me.  On a tangential note: Keep in mind that ideally your state should not be a function of your props (you should try to keep them separate and independent).  For more info on keeping props+state separate: https://facebook.github.io/react/tips/props-in-getInitialState-as-anti-pattern.html  Also, lifecycle methods are intended to be an escape hatch, rather than a recurring pattern in your code.

Your question is a usage question, rather than a bug in the React core. Usage questions are better answered on sites like StackOverflow, as we try to use github issues for tracking bugs in the React core. For this reason, the issue was closed. You're welcomed to continue the conversation here, or move it to a site intended for these sort of questions (like StackOverflow).

Anyway, hopefully you find the above info useful.  Happy coding!
 https://github.com/facebook/react/pull/5790
  > If we just forcefully include TestUtils with our production version of React, will that work?

I _think_ so. I can't think of anything off the top of my head that is reaching into dev-only internals.
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 The fact that you missed it goes to show how much room for improvement there is :) We appreciate the help!
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 @ashwin01 updated the pull request.
 Reading through this, it takes a long time to figure out what the doc is trying to say.  I wonder if we really need to provide a full-fledged example for sibling communication.  Would it be sufficient to say:

> For communication between two sibling components, you can usually create parent component that coordinates between the two children.  The parent component can receive messages (events/callbacks) from one child, update it's internal state, and pass the updated state/props to the other child.

I feel like that is simple and concise, and provides the necessary information.  Realistically, when people start hitting situations where they need to pass information outside of a parent-child relationship, they should probably start learning about Flux.

That's my two cents.  @zpao, thoughts?  @spicyj?
 Yea, I think I agree with @jimfb. I think a full-fledged example isn't quite helpful and (maybe it's just me) made me want to write it differently. Really what you've done is parent-child communication. The siblings still don't know anything about each other and it's not a great idea to start depending on that, even if they did.
 @ashwin01 We're probably not going to accept this PR as-is; it is too complicated.  Changing the wording around the example would not be sufficient - the problem is the example.  A couple of sentences could cover this topic, without introducing so much complicated logic for the user to read/understand.  As per my https://github.com/facebook/react/pull/5647#issuecomment-164043976 above, the changes in this PR could be simplified by replacing all these changes with the sentences from my comment.
  There is 1 lingering issue that I haven't had a chance to look too much into and that's the MetaMatchers. It does some hacky stuff Jasmine and at first glance doesn't appear to be compatible with Jasmine 2. I'll take a closer look at it shortly.
 @zpao Ping.
 @zpao updated the pull request.
 @zpao updated the pull request.
 @zpao Ping.  Jasmine2 has much better async support, which I'd like to start using.  Also, this PR is getting stale and will only get harder to merge as time goes on.
 @jimfb If you want to get this merged, do you want to figure out the metamatchers tests?
 You don't need to keep pinging me, I know this is on my plate. I'm also well versed in the difficulty of rebasing this, I've done it a couple times. The MetaMatchers thing is hard and requires a bunch of time that I haven't had. You are welcome to try to fix it yourself.
 It had been a couple months with no updates, which is fine, but we have a bunch of these open/lingering PRs, so I just wanted to bring it to your attention in case it had been forgotten.

Anyway, with regards to MetaMetchers - I agree it looks like some nasty jasmine logic in there.  The MetaMatchers is only used in one test, which is testing tests rather than testing React.  I agree it's useful/valuable, but I wonder if it is worth the weight, especially if it's the only thing blocking an update.  It might (in the interest of making forward progress) make more sense to just disable that test and get this merged.  We could always re-enable it later when someone has the time to make it work.  Anyway, just an idea, your call either way.
 As evidenced by my lack of finishing this, it's highly unlikely we ever come back to re-enable it. I think the test is pretty important to ensure we have the same set of expectations across TS, JS, CS classes.
 Thanks for the reminder!
  Sounds like the issue is not related to React.  If you disagree, let me know and we can reopen/reinvestigate.
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 It blows my mind that this is a common issue, but it does appear that a few people have hit it.  This seems reasonable.
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thanks!
  Thanks for the PR!

Unfortunately, any fix to the test utils must not depend on stateless components having internal instances.  We don't want to add anything that is going to make it more difficult to remove the internal instances.  A proper fix to this will be more complicated than this, and may require API changes with regard to the behavior of this test utility.
  No, short of forking React, there is currently no effective way of disabling the warning.  The problem with using `getInitialState()` is that even if you disabled this warning for yourself, if you ever decided to share your component outside of your environment, they would start getting the warning.  Better to just avoid that function name.  There are plenty of other names to choose :P.

You can achieve the same thing as `getInitialState()` by defining a constructor that sets state.

```
constructor(props) {
  super(props);
  this.state = {/*whatever*/};
}
```
 @aldendaniels We warn because 99% of the time, it's a mistake by a user upgrading their ES5 class to an ES6 class.  The benefit of the warning greatly outweighs the downside of reserving that one function name.  When ES5 create class is officially deprecated/gone (not in the near-term future), we can unlock that function name.
 @jimfb Just an idea, what if we warned after the constructor has finished and only if `state` does not exist on the instance. That should satisfy both problems?
 @syranide Sure.  Super low priority (so low that I'm not sure it deserves an open issue), but if someone feels strongly and wants to submit a PR, I don't see any reason not to accept that solution.

Side note: Using inheritance within a react component hierarchy is a bit of an anti-pattern anyway.  If you don't directly extend `React.Component` (ie. you extend your base implementation that calls `getInitialState()`), I think a few of the linters won't give you warnings about other bugs.  Also, I'm not sure it's wise to be re-using the names of es5 lifecycles, but it sounds like there isn't a technical reason that it wouldn't work, so I'm fine with allowing it.
 > Using inheritance within a react component hierarchy is a bit of an anti-pattern anyway.

@jimfb Agreed, I personally see _some_ sense in allowing this for `this.state = this.getInitialState()` in the constructor and it would allow you to reset uncontrolled components with `this.setState(this.getInitialState())` or something similar. I don't really care much myself either, but I feel like there are some _not so bad_ uses for this.
  Are you sure the react version is 0.14.3?  Can you provide a 0.14 fiddle that demonstrates the problem?

My fiddle: https://jsfiddle.net/4trs9u2r/
 Yeah, that's a issue in testutils.  This is only an issue in unit tests when you're using one of the ComponentWithType methods.  Tracking as duplicate of https://github.com/facebook/react/issues/4972.
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 We don't support extending Object.prototype so we don't need this. See #5621 for similar discussion.
  If the attribute is present in the source (which it should be), then this is the browser not having adopted this specific feature yet.
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 It has been nearly a month, closing in favor of https://github.com/facebook/react/pull/5775
  As mentioned these are not coming from React but from something else (use the stack trace to find the guilty party). Encourage react-router or whomever to do some improvements to dedupe warnings (eg, in React, to reduce spam we attempt to dedupe on the type and location of the warning).
  Typically this means you have two Reacts bundled on the page: https://github.com/facebook/react/issues/2402

Try checking whether you're having `node_modules/react` with 0.14 and some other package depending on React dragging its own outdated version as a dependency?

This situation will be better if you ask the maintainer of that package to specify React as a `peerDependency` instead. Then you can switch to `npm@3.x` which doesn't install peer dependencies automatically. This way you can't get the duplicates.

I also wrote about this problem [here](https://medium.com/@dan_abramov/two-weird-tricks-that-fix-react-7cf9bbdef375).
 That happens! Believe me, `npm@3.x` handles this better (and it has deterministic installs too, so install order shouldn't matter anymore). I fixed the link, thanks.
 Issue appears to be that user had a duplicate copy of React, as mentioned in the URL given in the warning (https://fb.me/react-refs-must-have-owner).  No comments for 7 days, closing.
 > That's kind of harsh to close for a week of inactivity at the end of the holiday week

We are always happy to reopen if this points to a legitimate bug.

Unfortunately your post didn't offer any specific instructions to reproduce so it is not actionable. Closing non-actionable issues helps put focus on the issues that are actionable.

If you find that the issue was not caused by a duplicate React, please let us know, and provide a way to reproduce.

> I asked for a reliable way to find out

I usually grep the build output for `var React = {`. If it's repeated several times, probably I have two Reacts.

Thanks for publishing details of your investigation!
  I think this warning is referring to the fact that Maps are not fully supported as children.  Map support within React is experimental; the warning was not commenting on it being an experimental ES6 feature.  For this reason, I think we want to keep the warning.
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 No activity for a month.  Doesn't merge cleanly.  And I'm not convinced that having the contents of the HTML file is really necessary for these docs anyway.  For these reasons, I'm going to close this out.  Feel free to continue discussing on this thread.
  @yungsters Is this something you would want to take?
 I think we should take this. The current behavior with a bad spec is unspecified and inconsistently broken in weird ways.

However this will be a breaking change so if we don‚Äôt do this before 15, we might as well deprecate `react-addons-update` and never do it.
 However I think the warning message is misleading. It claims that ‚ÄúYou provided a key path to update() that did not contain one of $push, $unshift, $splice, $set, $merge, $apply.‚Äù. However this is not the case for these invalid inputs:

``` js
[{ $set: 3 }]

{
  a: { $set: 5 },
  b: null
}
```

While these are also invalid, they are invalid for different reasons (specs and their nested specs should be plain objects). And I‚Äôm not sure we event want to error on a null spec, as just skipping it seems more useful for cases when the update object is created conditionally.

I‚Äôm marking this as needing changes. This might not land at all due it being a low priority and potentially breaking. However if you‚Äôd like to work on this, please make sure the error message reflects what the user needs to fix.

Thank you for contributing!
 Can we throw a different error when we encounter an array? e.g. `You provided an invalid spec to update(). The spec may not contain an array except as the value of $set, $push, $unshift, or $splice.` What do you think?
 @stefk updated the pull request.
 Personally I don't want to make any more changes to `update` ever while it's under the React umbrella. It should be an entirely standalone project if it's going to exist. There were a bunch of PRs and issues in this repo that would all be great to have but with nobody working on it, were just dropped out. I would still love to see somebody from the community pick this up, run with it and maintain it because we haven't. I'll even give you a free name for it too!
 @kolodny Do you plan to maintain https://github.com/kolodny/immutability-helper? We could make it an official new home of the `update()`. From what I understand it is already API compatible.
 @stefk updated the pull request.
 @stefk 

Thanks for the PR. We decided we won‚Äôt be taking more changes to `update()`. You can submit this PR to https://github.com/kolodny/immutability-helper which is a drop-in replacement for it.
  There is not enough information here for us to debug, but it sounds like a bug in user land.  It sounds like maybe your array isn't getting sorted correctly, or your `shouldComponentUpdate` is incorrect - though it's a little hard to imagine why either of those would be browser-specific.

Try removing your `shouldComponentUpdates` from all components, and printing your jsx tags from render immediately prior to returning them.  That may give some insight into what's going on there.

If you have a super simple testcase (jsfiddle) that demonstrates a bug in the React core, we can investigate further.
  SVG `<image>` is supposed as far as I know to support at least the same onload and onerror events `<img>` supports.

From looking at React code the events are handled on specific elements in `ReactDOMComponents.js` in `trapBubbledEventsLocal, mountComponent, unmountComponent`.

It would be easy to create a pull request to add 'image' to these cases, but it seems that there is a separation between js files that handle DOM and SVG in the codebase that this might collide with.

Am I correct and there is more to it than just adding more cases? Or these functions are the right place to also handle SVG image?
  @mattstyles is probably right. Peer dependencies should always be explicitly included in your `package.json` (`npm install --save react react-addons-update`)
  The property for autocapitalize is not a boolean, right?  Why should autocapitalize be changed?

cc @zpao 
 The autocorrect property is a boolean, the attribute is not. But the boolean values don't match the attribute values so that's why we need to change it.

autocapitalize‚Ä¶ looks like that doesn't matter too much. It's safe to use as an attribute and we can be consistent for these mobile safari-isms.
 @freddyrangel updated the pull request.
 Thanks!
  Our synthetic event system allows us to smooth out the events API.  We also make some minor changes where we think that our behavior is better than the browser's behavior.  In general, it's easy to ignore a bubbling event but it's harder to bubble an event up, so we bubble up and let the user ignore the bubbling event if they don't care about the event.  For more information, there is an interesting (semi-related) article here: http://www.bennadel.com/blog/2924-image-load-and-error-events-bubble-up-in-reactjs.htm

Anyway, I'm assuming this was an intended feature.  If @syranide or @spicyj disagree, they can re-open.  Feel free to continue the discussion in this thread.
 Yeah, all our events bubble. I don't feel great about this decision any more but this is intended behavior.
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 @spicyj @sebmarkbage Thoughts?
 Like most libraries (e.g., jQuery), we don't support extending Object.prototype.
 I assume the intention was to support properties with names that happen to match ones in Object.prototype, so that our config could support properties with names like `toString`. We're not super consistent about this but supporting extension of Object.prototype is a pain and we don't have any plans to support it right now.
  I don't think the presence of refs on the elements is what those docs are referring to when they say refs aren't supported.  But regardless, using string refs is a legacy pattern that will likely go away eventually, so I would try to avoid relying on them (the code you linked appears to rely on them).
  As mentioned you can't do this with React so closing.
 It's impossible for React to support this with inline styles. Perhaps some other way of inline styles will be possible in the future and pseudo-elements would definitely be considered then. It would be impossible to miss that feature. We don't need a specific issue to be kept open for a specific pseudo-element.
  Hmm, this wasn't really a problem prior to stateless components, since classes generally had names.

@spicyj @sebmarkbage We could attach the element name in dev mode, and warnings can pull the name from the elements instead of pulling it off the class.  Any reason we don't do that already?
 ES2015 specifies a strategy for adding implicit `.name` based on the variable or property that a an AnonymousFunctionDefinition gets assigned to.

Ideally this would be solved at the Babel level, at least in the DEV mode, so that these functions get a name assigned to them.

Assigning it JSX is not ideal for cases like:

``` js
let Component = this.props.componentType;
return <Component />;
```
 Ok, as per in-person conversation, the current thinking is that it might be useful to have both pieces of information.  Then warnings and devtools could print things like `'AdsCreatorTypeAhead' known as 'TypeAhead'` when components are referenced by a name that differs from their created name.  It would also allow us to print a sensible name when someone exports an anonymous component.  To achieve this, we would probably upgrade the https://www.npmjs.com/package/babel-plugin-transform-react-jsx-source transform to add the jsx tag name.
 Babel 6's babel-plugin-transform-es2015-function-name (or Babel 5's spec.functionName) adds names to functions.
  Now that #5714 is merged, starting from the next release all SVG attributes will be passed through as is, just like `data-*`, `aria-*` attributes, and attributes on custom web components.

DOM attributes are treated differently because React occasionally normalizes their behavior across the browsers and does some other magic which it doesn't do for the cases above.
  It doesn't decode the entities. It puts them into the markup, directly (that's what `dangerouslySetInnerHTML` does). The browser sees the entities and renders them as text (that's what browsers do). This is not a bug. I modified your fiddle to do what I believe you wanted: https://jsfiddle.net/b5Lt87kb/
  Normally I'd be inclined to say that people should fix their environment rather than inserting hacks into React to work around issues with their infrastructure/tooling.

However, in this case, I actually think this PR makes the code more readable (ie. better).

Looks like it is neutral on perf (http://jsperf.com/key-regex-compare).  I don't see any reason why we shouldn't take this, so I'll tentatively accept but leave it open for a day or two so that other people (especially @spicyj) get a chance to raise any objections before we merge.
 Okay, this is fine. No promises we won't use negative lookaheads in the future though.
  DOM property equivalent of CSS filter
 Yeah, this is fixed in #5714, thanks.
  Thanks @dittos!
  We should check the protocol and only mention the "`file://` url" if the protocol is not http/https already.
 @yangshun updated the pull request.
 Ok, thanks!  This looks good to me, but let's give @spicyj a chance to take a look before merging.

Here is my reasoning for wanting the check: We want to keep error messages/warnings as relevant as possible, which is why I don't think it's a good idea to show the full message in this case (unless it's necessary/meaningful).  In my mind at least, not having a check creates a WTF moment, where the user is like:

> my page is already served over http; isn't it?  am I missing something?  use an http server for devtools?  what are they talking about?

Mentioning http when they're already using http is also just a needless distraction for people who get the message, and it makes the message look like it was just blindly printed, rather than indicating a relevant action item for them to fix (people are pre-programmed to ignore spam).

Anyway, that's my thinking.  Just wanted to explain, because I don't want you to feel like I was requesting changes for no reason :).  Thanks for updating the diff!
 @yangshun updated the pull request.
 Does Firefox have the same issue? Might not make sense to show this message there if we don't need to.
 @yangshun No, I think @zpao is correct, the current code would show the `file:// url` message on a Firefox browser that doesn't have the plugin installed, right?  But we don't want to mention the `file:// url` stuff in firefox because it isn't relevant to a firefox user, even if they are using `file://` for their page.
 @yangshun updated the pull request.
 @yangshun This looks good to me.  I think our normal style is to only have two additional spaces before the `navigator.userAgent.indexOf('Firefox') === -1;` (you have a whole bunch of spaces; can you do a quick update?).  Other than that, I think this is good to go, unless anyone has objections.
 @yangshun updated the pull request.
 Ok, thanks @yangshun!
 Kind of silly to do the .indexOf('Firefox') twice but I guess this is fine.
  @vitorbal updated the pull request.
 @vitorbal updated the pull request.
 Great, thanks!
  Seems reasonable to me.  I'm a little surprised eslint is so concerned about case sensitivity, and that it seems inconsistent with regards to the capitalization of `string` and `Array`.  cc @zpao for a sanity check.
 That's just a jsdoc-ism, probably because of this:

``` js
"" instanceof String === false
[] instanceof Array === true
```

We shouold make sure this won't break any internal tooling before merging. I don't care too much about enforcing JSDocs via lint, they aren't used for anything here and we'll probably eventually start using Flow annotations. But it could be good to enforce in the meantime so we have fewer PRs fixing them up.
 This doesn‚Äôt merge cleanly now. I think there isn‚Äôt enough either internal or external interest to get this fixed so I‚Äôll close it but if somebody opens another PR maybe we‚Äôll merge it quick enough before it‚Äôs outdated again :smile: . Sorry for the long time to response, and thanks for contributing!
  @thekevlau updated the pull request.
 Instead of the current text, how about:

> Since `class` and `for` are reserved words in JavaScript, the JSX elements for builtin DOM nodes should use the attribute names `className` and `htmlFor` respectively (eg. `<div className="foo" />`).  [Custom elements](http://www.html5rocks.com/en/tutorials/webcomponents/customelements/) should use `class` and `for` directly (eg. `<my-tag class="foo" />`).

The reason we were avoiding `class` and `for` has more to do with Javascript than with XML.  JSX is not XML (even though they look very similar), and XML doesn't have any such restriction on attribute names anyway.

Or actually, maybe we should just forgo the justification entirely:

> The JSX elements for builtin DOM nodes should use the attribute names `className` and `htmlFor`, instead of `class` and `for` respectively (eg. `<div className="foo" />`).  [Custom elements](http://www.html5rocks.com/en/tutorials/webcomponents/customelements/) should use `class` and `for` directly (eg. `<my-tag class="foo" />`).

I think I'm leaning toward just omitting the justification, but I don't feel strongly either way.
 @thekevlau can you update as per above and then I think we can merge this.
 I kind of like my original wording (though, if you want to hyperlink the text, that's fine with me), but I'll defer to @zpao 
 @thekevlau updated the pull request.
 Ok, looks good, thanks!
  This is a usage question, rather than a bug in the React core. Usage questions are better answered on sites like StackOverflow, as we try to use github issues for tracking bugs in the React core. For this reason, I'm going to close out this issue, but feel free to continue the conversation here or move it to StackOverflow.
  üëç thanks
  Implements error boundaries for initial render, which allow React components to become isolation boundaries.  If a child of an error bounadry crashes, the error boundary has the ability to handle the error and render something different (like an error message or a frown face).  This allows application authors to partition their app into regions, and a crash in a single region won't take down the entire page/application.

Fixes #2461
 @jimfb updated the pull request.
 Now with setState support :).  @sebmarkbage @spicyj 
 @jimfb updated the pull request.
 @jimfb updated the pull request.
 @sebmarkbage Now with a unit test to assert the event handlers (eg. `onClick`) never get added.
 shipit
 @mhart Should be virtually none.
 Is there an intention to also add error boundary checks for component updates?

I really want to kill [react-transform-catch-errors](https://github.com/gaearon/react-transform-catch-errors) but unfortunately the current error boundary implementation doesn‚Äôt satisfy my use case.

I am interested in catching errors occurring when a person hot reloads `render()` function and introduces an exception to it. I would then ‚Äúretry‚Äù rendering the failed component on the next hot reload.

It would look like this:

![feb 15 2016 18 54](https://cloud.githubusercontent.com/assets/810438/13057661/939b2cc4-d415-11e5-909c-954461865161.gif)

Currently, error boundaries only handle ‚Äúbroken, later fixed‚Äù part of the equation, but not the ‚ÄúOK, but later broke‚Äù. From the technical point of view, it is equivalent to `render()` throwing only on the first update:

``` js
let calls = 0;

// ...

render() {
  calls++;
  if (calls === 1) {
    throw new Error('Yo');
  }
  return <NormalStuff />
}
```

If there is a desire to support this I can look into implementing this.
 @gaearon @ericclemmons https://github.com/facebook/react/pull/6020
  @zwhitchcox updated the pull request.
 @zwhitchcox updated the pull request.
 @zwhitchcox updated the pull request.
 Thanks, but I'm just going to leave this as is, I'd rather finish moving over to gulp than make more changes like this. Also, we'd have to get grunt-jest to upgrade it's peerdeps instead of just updating our version of jest here. That's why you're hitting build problems.

```
npm ERR! peerinvalid The package jest-cli@0.6.1 does not satisfy its siblings' peerDependencies requirements!

npm ERR! peerinvalid Peer grunt-jest@0.2.0 wants jest-cli@^0.7.0
```
  @zwhitchcox updated the pull request.
 Thanks. Can you squash to a single commit? Then I'll merge
  lgtm, will leave it open for a few more hours in case anyone wants to suggest changes before we merge.
 Nope, Thanks @zramaekers!
  Related to #2185 perhaps?
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 @remko updated the pull request.
 I'm kind of curious why it's done using `Boolean(var)` instead of `!!var`, cc @spicyj ?
 I probably thought it was clearer in the expression `wasMultiple !== Boolean(props.multiple)`. Either would work.

@remko Looks good. Do you know offhand if this is a regression?
 @remko Actually, did your test fail before this change? I would have expected that you would need to set the value before dispatching the change event in order for it to have caught the original bug.
 Got it, I understand now. Thanks!
 Looks like this logic was fine in 0.13:

https://github.com/facebook/react/blob/76c87da026bdab63b5b109e3c073a1db74896ed6/src/browser/ui/dom/components/ReactDOMSelect.js#L70

cc @zpao in case we do another 0.14 release
  Maybe more useful would be for you to use something other than toEqual‚Ä¶ though it's unclear what the semantics here should be. Maybe you do actually want to test the keys.
  @zwhitchcox updated the pull request.
 Can you squash this one too? Thanks!
 @zwhitchcox updated the pull request.
 @zwhitchcox updated the pull request.
 Thanks!
  In general, this should **never** happen; you should not be doing anything remotely related to modifying any component's state within a render function.

I'm curious what your use case is, for having a callback which does a setState; mind sharing?
 If I'm understanding your flow correctly, I still don't see how/why a `setState` would be occurring within a component's `render()` function. Do you just mean within a single reconciliation cycle?  Keep in mind that `render()` is not recursive (that's a common miss-conception; the child's render function is not called during the parent's render function).

@mikkoh wrote:

> When the Component that sets styles updates it fires a callback.

I assume you're using `componentDidUpdate` for this?  Can you provide a simple JSFiddle example/testcase that demonstrates the error you're running into?
 > Again this is an oversimplification and what `Foo` might be doing is dumb but `react` still shouldn't call `render` immediately after `setState` in the same reconciliation cycle.

The fact that we support calling `setState` in `componentDidMount` or `componentDidUpdate` is not an accident ‚Äì doing so in order to trigger an update is sometimes useful.
 @mikkoh Can you provide a specific code example here? I'm not sure I understand exactly what your issue was.
 I'm still failing to understand why what you're doing causes an infinite loop but that you say adding a `process.nextTick` alleviates the problem. In either case, if you call setState repeatedly, the component should continue to rerender.

If you can post a working code example (in jsbin, for example) that shows the problem, I'm happy to take another look ‚Äì but as is since I can't understand what you're doing this is not very actionable for me. I don't understand what the intention of your code is if you're trying to update the parent's state whenever a child renders. Wouldn't you expect that to cause an infinite loop?
  Thanks!
  Added post about upgrading your code to avoid `isMounted()`

Fixes https://github.com/facebook/react/issues/3417
 cc @sebmarkbage as per internal diff.
 FYI I have another blog post I'm putting up today - let's get this up net week
 @jimfb updated the pull request.
 The first sentence of the original post read: 

> As we move closer to officially deprecating isMounted, it‚Äôs worth understanding why the function is an antipattern, and how to write code without the isMounted function.

I kinda like the sentence (I think it does a good job of setting up context for the rest of the post).  @zpao @spicyj Do you guys like this sentence or think it's better with or without that sentence?  Any other feedback on the post?
 Ping @zpao 
 @jimfb updated the pull request.
 @jimfb updated the pull request.
 @jimfb updated the pull request.
 @jimfb updated the pull request.
 @jimfb updated the pull request.
 Ok, I responded, rebased, etc.

@zpao Does it look good now, or do you want further changes?

Also, can I put back the first sentence (which explains the point of the post):

> As we move closer to officially deprecating isMounted, it‚Äôs worth understanding why the function is an antipattern, and how to write code without the isMounted function.
 Yea, let's add that sentence back in. It's pretty awkward without it.
 @mridgway I think the advice in the blog post still holds - namely that unmounting should ideally result in all references being dropped (including from the event emitter, which is part of your flux setup).  If there isn't already an issue tracking that in your preferred flux implementation, I think the recommendation would be to file an issue.
 As per in-person conversation with @zpao, let's do this.
 @twoRoger If I understand your example correctly... You appear to be upset that you can't cancel the promise in response to the promise having been accepted (resolved).  That **almost** sounds like a paradox.  I don't think that's something we need to worry about :).
  Yes, `use` needs to be added to a list so that it's created specially. https://github.com/facebook/fbjs/pull/76 exists to address that, though we're planning on fixing SVG more broadly in React itself soon (right @spicyj?)
 This should be fixed in master already.
 Our point releases only have small bug fixes. React v15 will have the fix.
  I'm not sure why this would be. Can you post the Portal component definition you're using?
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 Sure, seems good.
  You don't have a DOM on the server side (you only have the html markup that is being sent to the client).  Thus, you need to render-to-string instead of render-to-dom.

Isomorphic code generally allows for lots of code reuse, but there are always going to be edge cases.  For instance, your datastore implementations might be slightly different to account for caching/security differences on server/client.  You'll also need to do a little wiring to revive your markup on the client side (ie. the `ReactDOM.render`), as you pointed out.

This is a usage question, rather than a bug in the React core. Usage questions are better answered on sites like StackOverflow, as we try to use github issues for tracking bugs in the React core. For this reason, I'm going to close out this issue, but feel free to continue the conversation here or move it to StackOverflow.
 I'm not sure what you mean by "detailed docs for this npm package".  The docs are the same for React with/without npm.

If you are just getting started with React, and haven't used npm before, the npm stuff often adds unnecessary confusion/complication.  You might try downloading the starter pack and playing with the code there: http://facebook.github.io/react/downloads/react-0.14.3.zip and follow along in the docs here: http://facebook.github.io/react/docs/getting-started.html#quick-start-without-npm

Once you get the hang of React and how to write a simple React app, then you can worry about making your app isomorphic and setting up your infrastructure.
  Not sure if it is called out somewhere. We don't do a very good job of discussing suggested tooling.

I think babel might complain if React isn't in scope (or maybe it used to). As for linting, I would recommend using ESLint and the eslint-plugin-react package with [react/jsx-uses-react](https://github.com/yannickcr/eslint-plugin-react/blob/master/docs/rules/jsx-uses-react.md) and [react/react-in-jsx-scope](https://github.com/yannickcr/eslint-plugin-react/blob/master/docs/rules/react-in-jsx-scope.md) enabled. Those will ensure you have React available and that ESLint doesn't complain about React being unused in the case you described.
  Makes sense. Thanks!
  It's possible but might be slower if we weren't careful to query it at the appropriate time (due to forced style recalc). Also unclear what to do if there is more than one transition on an element. I think it would take a fair amount of work to make this really bulletproof and I don't think the gains are large enough. You could make your own version of the component that does this.
 FWIW we don‚Äôt plan to make more changes to `ReactTransitionGroup`. Our current plan is to hand it over to somebody in the community because we don‚Äôt have enough internal users at Facebook to meaningfully evolve its API or spend a lot of time on it.
  Ah, sorry about that. The directions in there are for Babel 5 but Babel 6 has different behavior.

We'll get that updated but in the meantime, http://facebook.github.io/react/docs/getting-started.html#offline-transform has up to date directions (you need the `react` preset to transform JSX).
 The instructions in the example are updated (#5387) but we didn't update the starter kit for 0.14.x. I updated that PR so that if we do another release we'll get it updated. Thanks for the reminder.
  My fiddle: http://jsfiddle.net/ucrjxjv5/

FWIW, I'm **unable to reproduce** this issue on my chrome/linux (`Chrome Version 47.0.2526.73 (64-bit)`).  `Linux ubuntu 3.16.0-50-generic #67~14.04.1-Ubuntu SMP Fri Oct 2 22:07:51 UTC 2015 x86_64 x86_64 x86_64 GNU/Linux`.
  @pnuzhdin Have you had a chance to verify whether #5028 fixes this issue for you?
  @3den updated the pull request.
 Thanks, but we don't have any intention of adding more to addons. In fact we're (very slowly) working on getting rid of them / release each on their own outside of React. I would suggesting releasing this on your own.
 At the moment, no plans. Our hope is that something will shake out in TC-39 with class properties (https://github.com/jeffmo/es-class-fields-and-static-properties). We're actively involved with that spec but it's definitely not final so it's unclear where exactly we'll end up.

``` js
class FooComponent extends React.Component {
  handleClick = () => {
    this.doSomething()
  }
  // ...
}
```
  Looks like both your first and second snippets are resulting in parse errors. At least they are for me when I drop them into a React component in the Babel repl (http://babeljs.io/repl/). I haven't tested with anything else (perhaps Babel 6 behaves slightly differently, though I don't think it's supposed to). Maybe you're using something else to parse?

This is unfortunately one of those areas where JSX gets weird. Since it's all a bit made up, there are edge cases with the behavior, and maybe we can define things a bit better.

I'll walk through each of these though and try to explain why they're parse errors and why the last one works.

## 1, 2

These are both parse errors for the same reason. It boils down to not knowing that you're in a piece of JSX when you put the comments inside the braces. At that point the parser hasn't switched over the treating the block as JSX (it hasn't encountered something it believes is an opening tag) so it thinks you just have an object. `{ /* comment */ }` is just parsed as `{}`. So stepping past that, it does see some JSX but it doesn't matter because it ultimately looks like this: `return {}React.createElement(...)` which is going to be a parse error. #2 is just an extension of that, except you have 2 empty objects.

## 3

For this one, the opening `<div>` indicates to the parser to start treating `{...}` as something besides objects and to drop the expression in there. `{/* comment only */}` blocks are removed because that's what we decided would make sense when we introduced comments. `{'foo'}` will drop the literal in there instead.

I'm sorry that you hit one of the cases where JSX breaks down but hopefully that clears it up for you. There isn't much we can really do. We don't really own the tooling anymore and unfortunately since we're building this on top of JS, until the parse sees something to indicate JSX, it has to assume you're still in JS.
 @emkolardev Probably not; specifying a `renderType` on the class spec would not be sufficient to disambiguate the grammar.

It would be trivial to disambiguate if you had some obvious start and end token:

``````
var Foo = React.createClass({
render: function() {
return (jsx```
{/* could this work? */} 
...
```jsx
...
``````

But since JSX is just javascript with a couple extra token types, the `{/* could this work? */}` is effectively just an empty floating block which is not legal in javascript.  The empty block is too similar to other javascript blocks (like `if(true) {/* could this work? */}`) for us to have a reasonable chance at disambiguating them.  

Ultimately, one could write a parser that used some clever backtracking and heuristics to "figure it out", but there is something to be said for managing complexity and keeping something reminiscent of a [LL Grammar](https://en.wikipedia.org/wiki/LL_grammar).  If you are interested in this stuff, you should take a class on compilers!
  We try to keep GitHub reserved for bug tracking as much as possible. Please use other places (eg Stack Overflow) for usage questions. We can reopen if you diagnose and think you've uncovered a bug with React.
  Duplicate of https://github.com/facebook/react/issues/3951
  Thanks for giving this a shot. I'm going to come back to this shortly. There are a couple other changes to PropType handling that I'd like to get in first. I also don't know that I agree with what you've done in practice (objects and functions are valid values in enums).
 @shuaibiyy updated the pull request.
 This hasn‚Äôt been updated in a while in response to a request for changes so I‚Äôm closing.
Functions and objects are indeed valid values and `oneOf()` shouldn‚Äôt restrict their usage.
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 I think bourbon is an external dependency, and I don't think we want to fork it here.

Looks like this has already been fixed upstream: https://github.com/thoughtbot/bourbon/blob/master/app/assets/stylesheets/functions/_strip-units.scss

I'm going to close this out, since one-off fixes in an external library is probably not the approach we want to take here.  If you wanted to update/upgrade the entire library to latest (which includes a fix for this), that would probably be fine (we can open a new PR when that fix is ready), but check with @zpao first to see if he has any thoughts around this before investing work into a large upgrade.
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 Correct as-is.  http://grammarist.com/spelling/its-its/

English is hard.
  Please file React Native issues in their repo: https://github.com/facebook/react-native
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 This PR makes no sense (empty diff with single merge commit), no CLA, hasn't been updated since being opened.  My assumption is that the original author didn't intend to open this PR.  We can re-open or create a new PR when the remote repository is in a mergeable state.
  Thanks @jackiewung!
  This has come up a few times so I'm just going to point you towards the canonical issue and close out here. #1587
  I actually prefer not having nested describes because it makes it more difficult to add new tests. Can you revert that so the only test change is adding the new test? Otherwise this is good ‚Äì feel free to merge after fixing.
 Womp womp. Done. For later, maybe a better refactor would be to move the shallow renderer out to its own file (and own test file)?
 @graue updated the pull request.
 Should be in the next one, since this now has the 0.14.x milestone on it (look up):

> zpao added this to the 0.14.x milestone 15 days ago
 This is in the new 0.14.7 release, for folks watching the thread.
  See #4616 and #4608 for some other discussions. My best guess here is that you're hitting an enumeration order issue. And I think that's supported by the warning message - you can just see that beginning of the `data-reactid`. I'm going to close this out and point at #4616 for followup discussions.

I'm not sure if there's a great resolution yet - might need to ensure any `Object.assign` polyfills you have are up to date (or we might need to make a change to our code).
 > I did some debugging and I don't see the `style` attribute in the markup rendered server-side.

Well, that sounds like a problem.

> I just created a minimal app that just attempts to render a single div with a `style` attribute and that does work...

If that's working, I'm far less inclined to blame React. But I really don't have enough to go on.

I was going to say maybe there's something with your initial state that results in Nashorn treating a value differently. But you said adding `style`to any component results in this warning... except not in the minimal app. This makes me want to blame your app in some way. Do you have something else in your app code that would do something here, like Radium or some other inline styles library that's missing on the client?

We've never seen something like this reported so I'm really hesitant to blame React, but it's possible. I would suggest taking things out until you stop seeing this. Or trying to build up a reduced test case until you can repro, and then share that. Otherwise I'm not sure there's too much more to go on.
 Alright, well let us know regardless. I'm curious & ee like to have knowledge of the tricky to diagnose issues, even if they aren't with React itself. React Router is wildly popular so it's likely we'll get some more cross-cutting issues like this.
 Hmm, I guess I never posted my initial theory about Nashorn & somehow getting 0, null, undefined mixed up (since `style={{height: undefined}}` wouldn't render anything). But that didn't make sense with other styles so I didn't say it. Maybe something like that actually is happening though. Or the reference in Java-land is losing some state in the casting. It's odd either way. Glad you've sort of figured it out though and good luck!
  I'm ok adding this here but only if we fix the rest of the wording where we talk about adding this later. Could you do that?
 @shogunsea updated the pull request.
 @shogunsea updated the pull request.
 There's one more in the paragraph above your first change.

> It should look something like this (with perhaps some minor differences, we'll add an additional `<script>` tag later):

We don't need to say that we're adding an additional script tag later.

And then lastly, could you squash these into a single commit for condensed history.
 @shogunsea updated the pull request.
 Looks great. Thanks!
  This looks like a usage question, rather than a bug in the React core. Usage questions are better answered on sites like StackOverflow, as we try to use github issues for tracking bugs in the React core. For this reason, I'm going to close out this issue, but feel free to continue the conversation here or move it to StackOverflow.

With regards to your question, my personal recommendation is that you avoid singletons.
http://stackoverflow.com/questions/137975/what-is-so-bad-about-singletons
 React component instances have internal state that is needed to know where inside a tree that instance is. You can't have the same instance rendered in multiple places. Therefore the idea of singleton instances doesn't make sense in the React world.

What is shown in that fiddle is not really what I would call a singleton mostly because of the single instance argument - it's more like a module with it's own state. Then when an instance is rendered, it uses the enclosed (but really "global") state. It's cheating and storing a reference to the mounted instance in its global state and forcing an update on the mounted instance. Now there's nothing actually stopping you from rendering more of these, which would result in the first one not being updated. You could easily do something similar and support rendering more than 1.

As for us making a reference to this in our docs, we won't do that. There are lots of patterns that could be achieved with React but we're not going to talk about all of them.
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 @oguzzkilic updated the pull request.
 @oguzzkilic updated the pull request.
 That syntax is valid for node 4, which is what we require to build. As for the `process` module - that's a node built-in and isn't an external dependency. Browserify and webpack will both polyfill if you don't use something like envify.

I appreciate the initiative but this is already fine as is.
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 üëç thanks!
  @camjackson Yes, we're tracking this (I just realized we have https://github.com/facebook/react/issues/4972, so I'm going to close this one out and we can redirect discussion to that issue).

The difficulty is that this is a little non-trivial to fix the testutils (as per the PR), and will likely require an API change.  In the mean time, the work-around is generally to wrap the stateless component in a simple ES6 class, as described in https://github.com/facebook/react/issues/4972.

Tracking issue as duplicate of https://github.com/facebook/react/issues/4972
  As @andersekdahl mentioned, you should be able to include the individual addons.  If your configuration is correct, all the addons/components/whatever should share a single copy of React.  If this were not the case, you would run into the same issue for all the components you use (each of which also depend on React).

As @andersekdahl also mentioned, this is just a temporary configuration, until the addons are completely pulled out.  Addons frequently need to interact with React, so many of them may retain references to React - just as imported components have references to React.

No response for over a month, so I'm going to close this out.  If you have any additional details to provide, we can re-investigate.
 @TheLudd We maintain backwards compatibility for major versions.  So migration became possible in 0.14 and will likely become required in 0.15.  Releases tend to occur roughly every six-ish months.

The idea is that you should always fix the red warnings, and then you will be able to safely migrate up to the next version.  This is the same strategy we take for all our breaking changes.
  That answer still holds true.
  Yeah, @laskos's solution is probably the best here.
  [.](https://gist.github.com/spicyj/3a051c6da98f1d429bb6)
 Since createClass doesn't take that much time, the absolute gains here aren't great ‚Äì maybe a few ms for a typical app with a hundred components ‚Äì but this should still be an improvement.
 k
  I'm going to close this out as a duplicate of #2461; let's keep the discussion in that thread.
  @Daniel15 Are you still experiencing this issue internally?  If so, can you create an internal task with details and repro steps?  Assign to the oncall, cc the React team.

Our internal configuration is a bit different, and we don't want to discuss internal code/details/configurations on github.  I'm going to close this out, and we can help you debug using internal tools if you're still running into problems.
 @sverrejoh Are you running `ReactPerf.start()` before using it?
 Let‚Äôs reopen until we hear more.
 @Danita 

Thanks for the info, do you also have the same stack trace and error message as the first post?
 Any chance you have a public project where you can more or less consistently reproduce this?
 Technically this means there was [a write](https://github.com/facebook/react/blob/0b1fd186855a48dff78987f13466cec1e579b78c/src/test/ReactDefaultPerf.js#L197) for which there was no [hierarchy record](https://github.com/facebook/react/blob/0b1fd186855a48dff78987f13466cec1e579b78c/src/test/ReactDefaultPerf.js#L351). This code is super fragile so it‚Äôs hard to pin it down without having a specific component hierarchy that happens to cause this.
 If someone wants to spend some effort tracking it down, I would recommend:
1. Add 
   
   ``` js
   if (!measurement.hierarchy[id]) {
     console.log('missing hierarchy for', id)
   }
   ```
   
   just before [this line](https://github.com/facebook/react/blob/0b1fd186855a48dff78987f13466cec1e579b78c/src/test/ReactDefaultPerfAnalysis.js#L183) in `node_modules/react/lib/ReactDefaultPerfAnalysis.js`.
2. Add
   
   ``` js
   console.log('write for id', id, 'with args', fnName, args)
   ```
   
   just before [this line](https://github.com/facebook/react/blob/0b1fd186855a48dff78987f13466cec1e579b78c/src/test/ReactDefaultPerf.js#L199) in `node_modules/react/lib/ReactDefaultPerf.js`.

Then please share the relevant `write for id` logs that correspond to the ID you see in the `missing hierarchy for` message.
 @Danita Yeah, I thought this might be the case. Thanks for taking the time to investigate.
 Thank you, this is very helpful! I‚Äôll dig into it and see if I can repro this given the new info.
  It's not a subheader of Prop Validation, though it is a very related topic so this flows a bit better. thanks!
  Workaround: Use a different name, like `getMyInitialState`.  Get initial state is a reserved function name, and emits a warning in order to avoid confusion with the component lifecycle function defined on ES5 react classes.

This looks like a usage question, rather than a bug in the React core. Usage questions are better answered on sites like StackOverflow, as we try to use github issues for tracking bugs in the React core. For this reason, I'm going to close out this issue, but feel free to continue the conversation here or move it to StackOverflow.
  Well said @seekshiva.
  reactjs/react-tutorial#103
 @brianzelip Is this clearer?
 Thanks!
  Unconfirmed for over a month.  If this is still an issue, please provide a simple jsfiddle that demonstrates the issue and we can reinvestigate.
  Yes, key is used to signal to React the identity of an object, and React.Children.toArray changes the key so that the identity semantics can be preserved. For example:

``` jsx
<div>
  <span key="header" />
  {items.map((item) => <span key={item.id} />)}
</div>
```

If any item has an `id` of `header`, that's okay ‚Äì they won't be mixed up with the first element because the keys are scoped to the array that they're in. When you flatten `[<span/>, items]`, each item gets its key prefixed to preserve this behavior.

If you want to read the key back off and have it unchanged (or to read it from within the component in `props`), please use another property name.
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 üëç thanks!
  Ok, let's close this out.

@benwiley4000: If you do ever find out what went wrong, and can provide steps to reproduce, we can re-investigate.
  I can only reproduce this if I don't set the charset of the document to utf-8 (unfortunately w3schools page is actually decent here - http://www.w3schools.com/html/html_charset.asp). Can you still reproduce if you've done that?
  As mentioned, this seems like it's in line with the spec. There may be some inconsistencies because I think we fake it. Focus is one of those things that is really tricky to do declaratively because it's part of a shared global state. If 2 unrelated components declare that they should be focused in a single render pass, who is right? So we give you the hooks to manage that state yourself but we won't do it for you. Sorry that this has cause you troubles!
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
  This appears to be working as expected
  Thanks.
 For reference: https://code.google.com/p/chromium/issues/detail?id=506801
  Thanks for sending the PR!
Please see https://github.com/facebook/react/issues/5322#issuecomment-202620254.
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 `Object.defineProperty` isn't available on IE8.

Also, `this.dataTransfer` should be set using the same principle as in (or is there a reason not to?):
https://github.com/jansedivy/react/blob/drag-fix/src/renderers/dom/client/syntheticEvents/SyntheticMouseEvent.js#L34

It also seems problematic as this doesn't polyfill functionality universally and, as far as I can tell, will simply error if you try to use this API on a lesser browser. So it seems to me that this deviates from existing event polyfills provided by React and it's not immediately clear to me whether going this route is a good idea or not (long-term/maintainability/etc).
 @jansedivy updated the pull request.
 Thank you for taking time to contribute. I‚Äôm closing as this PR has not received updates in response to the feedback in https://github.com/facebook/react/pull/5529#issuecomment-169029359. Please feel free to open another one if you plan to get back to this!
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 cc @sebmarkbage 
 The concern here is performance. try/catch at every level down the tree can negatively impact performance and will deopt this function (at least in otherwise good conditions).

The idea was to use try to place these at "anchor points" like entry points into the middle of the tree or error boundary roots. The problem is that there are mutations along the way.
 @globexdesigns We avoid global configurations like the plague.  Often bugs only show up due to the complex interactions of having certain flags enabled, and it becomes a nightmare to debug/maintain.  Not to mention the added overhead of explaining to users which flags they should enable when, etc.
 We do have different renderers. We could create a stand-alone build for this. As a work around you can just use/publish your own fork.
  Can you show how you were using this? I don't think Component Classes should have been valid for `node` either. `node` is supposed to accept anything that can be rendered. Classes can't be rendered directly - you would pass an element with the type set.
  Thanks!
  @hejld updated the pull request.
 @hejld updated the pull request.
 Thanks!
  We don't currently have any plans to change this now. You are welcome to maintain a fork if you would like.
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
  @mhujer updated the pull request.
 Thanks!
  This is intentional. `null` is an intentional value whereas `undefined` is the lack of a specified value.
 @zpao If that's the case then IMHO we should escape it properly, as it is now `"null"` and `null` are treated equally by React (this should be trivial by translating it to `.!` or whatever. Although personally I'm not sure when it ever makes sense to have `null` as a key, how about a warning too?
  üëç Thanks!
  No and unfortunately this won't be possible - proptypes are done early on the elements and don't have access to the rendered result.
  We only publish from our latest `-stable` branch. All documentation changes land in `master` and we cherry-pick them over to the stable branch. `gh-pages` is built from that. This avoids the docs + code changes since we'll only get those if we cherry-pick that code change into the stable release.

We care less about having long-lived docs for each version - they aren't well set up for that and I'm not sure there's enough value. But thanks to the cherry-picking the last published markdown is always available for that version. Eg, if I wanted to see the 0.10 API docs, I can do that easily: https://github.com/facebook/react/blob/0.10-stable/docs/docs/ref-01-top-level-api.md.

I personally think this is a pretty good process (cherry-picking can be annoying but it allows the docs to be pretty stable but still receive updates).
  This is a great question for [Stack Overflow](http://stackoverflow.com/questions/tagged/reactjs). We try to keep GitHub focused on bugs and issues with React itself and keep usage questions elsewhere.

That said you may gain some insights from http://facebook.github.io/fixed-data-table/
  @laskos updated the pull request.
 Thank you for taking time to contribute. I don‚Äôt think we want to take this particular PR as a part of the shallow renderer but you are welcome to raise an issue to explain the motivation behind this in more detail.

Shallow renderer tests components one level deep by design. If you want to split components, you are also expected to split the corresponding tests. You can use rendering to something like jsdom if you would like to run tests on the whole component tree. Something like https://github.com/airbnb/enzyme/ can help smooth over the API differences between regular and shallow rendering.

Partially deep rendering may be something we want to support but it is better to discuss this as an issue first, and reach a consensus on the API as well as explain the use cases there. Please feel free to raise such an issue if you think this is an important missing piece in React. Thanks!
  @zpao usually handles the website stuff, passing to him.  cc @spicyj 
 I don't like the scrolling header. The jest docs fit on one line I guess:

![image](https://cloud.githubusercontent.com/assets/6820/11856555/89d1dbbe-a406-11e5-90ac-2296df2199c7.png)

If we can't fit on one line I would prefer just breaking into two or three lines. I don't see the nav in your screenshot ‚Äì how is it triggered?
 Ping @yangshun, would you like to update this in response to the comments above? Thanks!
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Looks good.  Please sign CLA and then we can merge.
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 Thanks!
  Removed unnecessary variables/assertions.

instance.getAnchor() is a DOM node, so `actualDOMAnchorNode` is meaningless, and asserting that `anchor === anchor` is also pointless.  Unless I'm miss-understanding something.  I think this is just noise from back when internal instances were not DOM nodes?  cc @spicyj 
 Yes, we have a lot of this in our tests.
  I feel like this is expected behavior (albeit perhaps slightly confusing).

For the class `input` with the same parents, you are just changing the `type` attribute (the instance doesn't change), so `defaultValue` would not be evaluated.  If you change the ancestor component class (eg. from `div` to `span`) the instance is thrown away and a new input instance is created, thus `defaultValue` gets evaluated.  This is expected behavior given the way React keys work.

cc @spicyj @zpao 
 Yes, you can work around this by changing the `key` attribute on the input so that it gets recreated.
 @DesignByOnyx Yeah, but the same argument could be made about a whole ton of things.  Changing one attribute (eg. `src` on a video component) could "imply" that other attributes (eg. the component's play/scrubber position) should also change/reset.  And while someone could make an argument for any one of these changes, the rules that result from such a wackamole game become too complicated for anyone to understand.  It is better to have a simple set of rules (a change in "tag type" results in a new instance, attribute changes do not) that are honored everywhere.

FWIW, keep in mind that these problems all evaporate if you use controlled components, which is the more "reacty way".
  üëç Thanks!
  It looks like we're going to make `null` actually render to comment nodes in #5451 so this should become a non-issue in the future.
  @electricmonk There is no `volume` _attribute_ for `<audio>` as far as I can tell:
http://www.w3.org/TR/html5/embedded-content-0.html#the-audio-element

**EDIT:** The `volume` _property_ exists, but it can only be controlled through javascript, so you have to control that yourself manually, using a `ref` to the node.
 For `volume`, I wonder if it makes sense for React to expose it as an attribute.  It also seems reasonable to suggest it to the W3C, since I can't think of a reason why it shouldn't be an attribute.
 @jimfb Because it's user-controlled and the best initial value is what the user last had, not a developers arbitrary judgement I would think.
 Ah, yeah, unless the developer intends on providing their own volume control.  But yeah, makes sense.

Sounds to me like we should close this issue, unless someone sees a reason to keep it open.
 > Ah, yeah, unless the developer intends on providing their own volume control. But yeah, makes sense.

@jimfb React only deals with attributes, in-part because of server-rendering I would say. Personally I think it's best if React just stays out of these things anyway; it can be trivially implemented in user-land via a wrapper component.
  @mridgway updated the pull request.
 @mridgway updated the pull request.
 In what engine? Conveniently, I just put up some benchmarking scripts earlier today in #5503. I just ran them and this seems ~1‚Äì3% faster in jsc (depending on exactly which number you look at) but slower in node. Not sure why.

In any event, this is a behavior change because we had intended to not crash on inputs like `<div valueOf={...} />`. I think this also prevents you from passing props that coincide with `Object.prototype` names because the loop in ReactElement will no longer copy them.
 > I think this also prevents you from passing props that coincide with Object.prototype names because the loop in ReactElement will no longer copy them.

Primarily, IE8 doesn't have a concept of non-enumerable keys, so all keys are iterated. So to support IE8 you _must_ use this in for-loops.

Having keys with names such as `valueOf` shouldn't be a problem?

The only other problem is broken setups where someone has done `Object.prototype.foobar = 1`, `foobar` is enumerable and will appear as present on all objects. However, I'm not sure if this is actually a problem, I'd expect a lot of problems with various modules if you've done this, and you really really should never ever do it.
 @syranide I'm having trouble parsing your comment. What I meant was

```
var config = {toString: 'yolo'};
var props = {};
for (var k in config) {
  if (!RESERVED_PROPS[k]) props[k] = config[k];
}
```

will not copy `toString` from `config` to `props` (unless I'm missing something).

Like most libraries (e.g., all versions of jQuery), we don't support adding keys to Object.prototype.
 `RESERVED_PROPS['toString']` is truthy while `RESERVED_PROPS.hasOwnProperty('toString')` is falsy.
 How did you benchmark?
  Thank you!
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 If we're going this route (which I agree with), then it could also be a good idea to lead by example and put it outside the component class, because it's generic and doesn't have anything to do with that specific component. Perhaps?

@zpao Thoughts? Perhaps just added complexity for newcomers?
 I agree that if we make this change, we should pull `rawMarkup` out of the component.  Given this change, there is no reason to have `rawMarkup` on the component.

However, as a newcomer, I'd be trying to figure out what is happening in `rawMarkup` instead of figuring out what is happening with `dangerouslySetInnerHTML`.  I feel like this whole change is just added complexity.  I'd be tempted to leave the example as it was.

I don't feel strongly either way.
 Yea, let's just leave it as is. I appreciate the effort though @ParanormalCoder!
  I guess we could reinstate JSXTransformer but I don't really want to‚Ä¶ @sebmck whyyyyyyyyyyyyyy
 @sebmck Am I missing something obvious here?  The in-browser transformation is fairly critical to new users getting started.  It is used in sample code to give people a first taste of JSX, is used in fiddles for debugging/testing/demoing, is used in a lot of places.  It is even used on the reactjs homepage.  `browser.js` seems like a fairly critical feature to me.
 @sebmck feel free to point me elsewhere to have this discussion. The main reason I want it is to keep it simple when starting with React. "load this script and use type='text/babel' and it'll work" is a nice story and eases people into the need for server-side transformation. It would also be pretty bad to require a build pipeline for hello world. I want people to focus on React initially, not the tooling.

Could we compile our own to get the same story? Yep. We did it before and we can do it again (though maybe we won't ship it anywhere this time, just on our site, examples, jsfiddle). It was just nice to say that you were owning it :P
 As noted you can still use babel 5 in the browser. I wouldn't recommend using it for anything except test cases or quick examples though. If you have a whole app and build pipeline, you should rely on that.
 @otoinsa unofficial/unsupported, but... http://www.jimsproch.com/react/

That's what I use myself when testing locally, so I thought I'd share.  It works pretty well for my needs.
 babel-standalone doesn't actually do any transforming of script tags on its own, you'd have to write a wrapper (which I have done just need to get it shipping somewhere).

We can update the docs or just stop linking entirely.
 Here's what I wrote with the intention of just building for us to ship in our docs: https://gist.github.com/zpao/7f3f2063c3c2a39132e3 (though I think I need to fix something, haven't tested in a couple weeks)

The nice thing is that it is 95% the same code we had before with JSXTransformer, mostly just a changed transform call.

The problem with throw-in-the-towel is that it doesn't do all the things that we learned along the way with JSXTransfomer. The biggest thing is going to be actually creating script tags and doing that in the right order - it's vital for sourcemaps and `new Function()()` will have some fun issues (I forget exactly what). (You can figure all that out in your PR, not worth going into here but feel free to CC me).
 Nope, was just handle as they come, never felt the need to write tests for it.
 > Here's what I wrote with the intention of just building for us to ship in our docs: https://gist.github.com/zpao/7f3f2063c3c2a39132e3 

Is it okay if I pull something like that into `babel-standalone`? It seems reasonable to have an extended version in Babel-standalone

It's got a differing license (BSD on that script vs MIT on Babel and Babel-standlone) and the Facebook copyright header so I'm not quite sure how that works. I guess I'd have to keep the copyright header, unless you relicense the script under MIT too?
 @satya164 If you're looking for something to use for testing/development, you can take a look at http://www.jimsproch.com/react/

It's completely unofficial/unsupported, but it will transpile inline scripts in html; it works pretty well for my own needs.
 @Daniel15 that code is BSD and unlikely to change - it's essentially just the old JSXTransformer we wrote for React. You should be able to redistribute and just maintain the license but I'm not a lawyer and all that. Alternatively we just make a new package here and do the inverse.
 Yes, that's a result of Facebook (and thus fb.me) being blocked. We could probably get around that by making the fiddles use a different location (eg cdnjs), but is otherwise unrelated to the issue here.
  Is there any way you could reduce this to a runnable test case? My gut on cases like this is usually something about keys but that shouldn't be necessary here.
 Also, what version of React are you using?
 Okay, if you can list steps to reproduce this including how to clone your repo and what items to add, I can take a look.
 I don't have mysql. Is it possible that you can make a smaller example? Try deleting all the parts of your code that aren't necessary to make the issue appear. It shouldn't require any database.
 I am not sure if I am reproducing this correctly but I do see a warning:

```
Warning: validateDOMNesting(...): <a> cannot appear as a descendant of <a>. See Menu > Link > a > ... > a.
```

If I change Menu.jsx to use a `span` inside .listlogs-logo inside the Link instead of an `a` then I think the error goes away. Can you confirm?

If so, how could we have made this clearer? (Did you not see the error? Did you see it and ignore it?)
 > Warning: validateDOMNesting(...): <a> cannot appear as a descendant of <a>. See Menu > Link > a > ... > a.

Changing that nested anchor to anything else seems to fix this. The problem is that React can't help you when you create invalid markup. The browser moves nodes around.
  I'm going to close this out and point to #3995 which was an initial PR for functional components. There's some good discussion around the ideas to make them "pure".
  I always find these confusing as hell, but `react-leaflet` is announcing itself as not compatible with React 0.14 and that's probably the source of the problem.

`npm ERR! peerinvalid Peer react-leaflet@0.6.2 wants react@^0.13.0`
 @AlexHandy1 It's not trying to install 0.8 for you though, possibly locked dependency?
 @AlexHandy1 0-versions are special.
 Closing this out since it's a not a React issue but feel free to continue working through it here.
  @zpao This keeps coming up.  We should come up with a more legit solution than "go build/package it yourself"
 I'm going to close and since you mentioned Nashorn, point you to another issue on the topic. ~~#5490~~ #5311. Perhaps we'll do something more.
  Thanks! I'll send a PR completing the comment you linked.
 #5493
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 I don't know what you were intending but I'm certain it wasn't what you did. Please be careful when using github to avoid noisy actions like this in the future.
  Not sure this is going to be exactly the issue but you're probably going to have an issue with references when using spyOn.

`onClick={this._clearAllSelectedCategories}` will reference the original function, even after spying (which will replace the `'_clearAllSelectedCategories'` property with a new function).

But beyond that, it's pretty hard to tell. Perhaps with a standlone test repo / gist that could be `npm install`ed
 @andrewheppner I generally recommend testing end behaviors, not internals.  When the button gets clicked, does it call a callback handler?  (If so, have the test pass in a callback and assert that it gets called).  If not, what function is getting called.  Can you test that the result of that button click has happened?  Or verify that all the categories are cleared?  Generally, IMHO, you shouldn't be testing something that isn't observable from outside the unit - otherwise it's an implementation test instead of a unit test.

Anyway, as far as I can tell, this is a usage question, rather than a bug in the React core. Usage questions are better answered on sites like StackOverflow, as we try to use github issues for tracking bugs in the React core.  Also, there has been no activity on this thread for over a month.  For these reasons, I'm going to close it out.  Feel free to continue the discussion here or move it to another site like StackOverflow.
  @chicoxyzzy updated the pull request.
 Are you interested in coming back to this @chicoxyzzy?
 Just update typescript. Unless you really want to take over #5646, I haven't had a chance to come back to it in the last couple weeks (just rebased and pushed though)
 Ping @chicoxyzzy, would you mind changing this to only update TS? Thanks.
 @facebook-github-bot 

![b2ap3_large_istock_000011918649_small](https://cloud.githubusercontent.com/assets/810438/14399520/546c8864-fde5-11e5-9ecd-868e9ef0d187.jpg)
 I have no idea how the typescript stuff works, so no clue if the compilerHost is important.

There are 2 requirements:
1. We can use TypeScript (duh üòÄ)
2. Tests fail if the code doesn't typecheck. This is the case on master right now but did not hold true with your change (thus this discussion back in November: https://github.com/facebook/react/pull/5485#discussion_r45021573)
  As per https://github.com/facebook/react/issues/4948#issuecomment-157237775, I think it is supported for SSR FPR.  Maybe we could warn if it ever happens via the createElement path.
 Eeh, I think I agree, the bulk of this bug is already handled by dom nesting validation.  Let's close it out until/unless we have a driving use case/need.
  This looks like a usage question, rather than a bug in the React core. Usage questions are better answered on sites like [discuss.reactjs.org](https://discuss.reactjs.org) or [StackOverflow](http://stackoverflow.com/), as we try to use github issues for tracking bugs in the React core. For this reason, I'm going to close out this issue, but feel free to continue the conversation here or move it to one of the previously mentioned sites.
  The simple solution is to trigger your events in a different event loop (eg, setTimeout your for loop). Or even better, communicate differently so that this is achieved with state and not through triggering events.

That said, It's not clear to my why this triggers too much recursion as is though.
  Well, the good news is, we can ask the original author ( @spicyj ) what he meant.  But for the record, @yangshun is correct, the term "iff" is used pretty commonly in formal mathematics and computer science.  If I had to guess, I'd say the use of "iff" there was intentional rather than an unfortunate typo.

I'll let @spicyj make the final call on this one, since he is the original author.  My intuition is that the `iff` is correct as-is, but we can remove the duplicate "the".
 Yes, "iff the selection" please.
 (Also I don't think I actually wrote this.)
 @hejld updated the pull request.
 Thanks!
  I'm assuming this should be filed against https://github.com/facebook/flux
  Yea, this should be fine. I get confused all the time when I'm telling people what to use.

But I think we might not want to support 2 ways to do it (well, for more than a release) which would mean having a deprecation notice for `.{bool,func}`. Let's add that. But also cc @sebmarkbage - we were just talking about some proptypes changes and trying to avoid churn (we were talking about renaming oneOf or oneOfType to avoid some confusion, maybe we can do a bunch of cleanup around this in one release)
 Sigh.
 We talked about this in our sync last week and we're just going to leave these. Not worth the churn at this point (even if it is better) :/
  **Note:** [This](https://github.com/facebook/react/pull/5475) is the same pull request. I've cleaned up the commit history.

Following [this](https://github.com/facebook/react/issues/5468) bug report, the PropTypes are now checked in development mode when the class is created, so that, for instance, the call:

``` javascript
var MyComponent = React.createClass({
        displayName: 'Component',
        propTypes: {
            optionalNumber: React.PropTypes.number,
            optionalEnum: React.PropTypes.oneOf('foo'),       // Invalid.
          },
          render: function() {
            return <span>{this.props.prop}</span>;
          },
        });
```

will result in a warning being logged, and _optionalEnum_ being cleared from the **propTypes** object.

Up to this point, this check only occurred when **ReactElement.createElement** was called in development mode. Some refactoring might be needed in order to avoid unnecessary tests when **ReactElement.createElement** is called in development mode.

Test cases were included in the file [ReactClass-test.js](https://github.com/rppc/react/blob/changed/src/isomorphic/classic/class/__tests__/ReactClass-test.js#L384) (see the last test).
 You're probably right. My knowledge of React is very limited, as this is my first contribution ever.
 @phss That's a point I was going to bring up while reviewing :)

I appreciate you taking the time to do this and I know it was a pain to work through git issues but I have a fundamental change to make.

We should simplify this and just put some `if (__DEV__) { if (invalidPropType) { warning(‚Ä¶) } }` blocks inside ReactPropTypes. ReactClass shouldn't need to be involved at all. All tests would stay with PropTypes.

Basically, if I were to call `React.PropTypes.oneOf('foo')` outside of any React component, I should see a warning. This would ensure that contextTypes would also warn.
 @zpao Thanks for the review!

Like I said, this is my first contribution to React, so I apologise if I missed some important details.

What you said made sense. I will try to look into it when I have the chance.

Are we supposed to just log a warning in case the PropType is found to be invalid?
 @rppc updated the pull request.
 @rppc updated the pull request.
 @rppc updated the pull request.
 @rppc updated the pull request.
 @zpao Is this what you had in mind? If so, I did over-complicate things a bit...

I'm so sorry... I accidentally merged all those unnecessary commits back in... Please tell me if should clean them up and I'll go on and just create a new pull request.

Two unit tests are failing because they expect the calls to ReactPropTypes functions not to warn. I've decided not to change those just yet.
 @rppc updated the pull request.
 Please don't make another PR, just clean up your branch (strip that merge commit and don't run `git merge master` again (and/or fix your master branch)). It's important to use a singe PR so that we can track review comments and discussions. Looking across 10 PRs for that is super difficult, especially when you do it a year or 2 from now.

Please use the local environment to run tests and don't use Travis CI. Since we have a comment come in for every change, it gets noisy. `npm test` will run the tests.

Otherwise yes, this is on the right track for what I meant.
 Yes, I shouldn't have merged that master branch... Silly me! I think I've got it now!

I'll fix the tests that are failing as soon as I can.
 @rppc updated the pull request.
 @zpao As promised, I fixed the tests that were expecting functions `React.PropTypes.oneOf()` and `React.PropTypes.oneOfType()` not to warn and also some of the code so that all tests would pass.
 @rppc updated the pull request.
 @rppc updated the pull request.
 @rppc updated the pull request.
 @zpao Done!
 @rppc updated the pull request.
 Ping @zpao 
 Hey @rppc! We are sorry this got under our radar and doesn‚Äôt merge cleanly now. Someone else took a stab at it in #6316 which looks fairly similar so we‚Äôll probably go ahead with it. Thank you for taking the time to contribute, and sorry for spending your time on the back-and-forth without merging the result.
  cc @spicyj and @syranide because: events.

actually, calling setState on SSR might not be legal/valid, is it?
 Yeah, I suppose setState should warn and do nothing. What did you expect would happen though?
 In dev mode, we could mark a component as having been rendered using SSR.  If `setState` or `forceUpdate` is ever called on such a component, print an intelligent warning.
 @mdolbin That looks reasonable to me.
  Flow is open source, so if you find that something is wrong or out of date, I'm sure they would appriciate a PR to fix it - feel free to submit one to the Flow repository!

My intuition is that this file should remain in the `flow/lib` repository/directory (at least for now), along with all the other flow libs.  Changing the location of the file won't fundamentally change anything - maintaining the file will still require exactly the same amount of work.  We ran into a nearly identical issue with typescript in https://github.com/facebook/react/pull/5454, ultimately concluding that a request for such a change would need to come directly from the project maintainers, along with appropriate update and testing infrastructure as per https://github.com/facebook/react/pull/5454#issuecomment-155982256
 I think ultimately this one does belong in the React repo. We've gone back and forth on this for a while and the big difference from TypeScript is that the primary contributors (FB) are using Flow extensively. There's a far greater chance we'll know when we do something that's not compatible with the typedefs. The better move for Flow long term is not to have any libraries included in its core (node, dom, etc are fine because they aren't libraries). I'm going to reopen since the whole Flow issue here is definitely an issue cutting across multiple projects and cc @sebmarkbage since he's been thinking about this a bunch lately.
 For context, most of the Flow team sits one desk over from the React team at Facebook and both report to the same resource allocation which is seamless. The repo isn't what will make or break this collaboration.

The Flow team build and prioritize features based on the requirements of the React API or other core frameworks so it's a feature that they're able to maintain it and add new features as they deploy. They have a lot more context on how this can be typed and configured than we have.

We're currently looking at how Flow types can be deployed in npm packages. At that point it might make more sense that the React definitions are deployed with a React release.

Ultimately this isn't about maintainability but about how deploys and releases are made.
  As per @cody's jsfiddle, it does appear to work. @liuhong1happy, can you create a simple jsfiddle that demonstrates the issue?
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 This is correct as is - the links are meant to be consumed on the rendered site. Unfortunately that means links inside the raw markdown won't always work
  Warnings are being tracked as https://github.com/facebook/react/issues/3596 and https://github.com/facebook/react/issues/4695
 For a bit of clarity, if you want warnings in the console at JSX compile time then you'll want to file that against whatever you are using to transform (probably Babel).
 @zpao For the warning(s) that would require transform support, do we want to just file those against babel instead of React?
 Yes, that's what I just said. Only exception would be if it's something that we would want to write an additional babel plugin for.
  Right now we validate some of our proptype definitions, but we don't surface the issue until that component class is consumed. We should instead validate these, in `__DEV__` only as warnings when the class in created. This means that a call to `React.PropTypes.onOf('foo')` results in an immediate warning logged.

This is a relatively contained bit of code so would be a good candidate for somebody looking to start contributing to React.
 @antoaravinth the code you linked validates proptypes on element creation. So assuming a test case like

``` js
var MyComponent = React.createClass({
  propTypes: {
    foo: React.PropTypes.oneOf(1, 2)
  }
  render() { return null; }
}
```

I want that to warn right away. I've written an invalid proptype (`oneOf` must take an array).

But the current behavior is not to do that. Instead you won't know that the component has defined proptypes improperly until you do `ReactDOM.render(<MyComponent />)` (this is what I mean by the class being consumed - poor phrasing on my part)
 @iam-peekay Looks like this one is nearly done (https://github.com/facebook/react/pull/5476).  If you're looking for a good getting-started issue, https://github.com/facebook/react/issues/5773 should be relatively easy and I don't think anyone has started it yet.
 #6316 is the valid PR for this.  This is my first contribution.

Sorry for the terrible commit noise.  I made the initial mistake of doing a PR on my master, and being new to github, didn't realize this would happen.

I started over with a new master and now I'll branch per PR.
 I think @rppc should get this one.  @rppc feel free to copy the code from #6316 into your own PR, it is essentially the same code.  I thought your PR has been rejected since it had been untouched for around 2 months.  I'm still learning how things work here and thought you would get notifications of all that happened on this thread.  Sorry for stepping on your work.
 :+1: Glad you resolved this. It happens :smile: . No worries please.
 @rppc Thank you!
  This code is intended to be internal to React, and is not part of our public/supported API.  It is an implementation detail, and we reserve the right to make changes at any time, so it should be considered unstable - thus the reason we don't export it.

Duplicate of https://github.com/facebook/react/issues/1639#issuecomment-140133010
 FYI: Key mirror is now shipped in fbjs, which react and other Facebook projects consume. It's available there but there are no top level APIs - only require(fbjs/lib/keyMirror) - in that package and the rest of what Jim said holds.
  I'm a little surprised you are seeing a flicker if nothing is changing - that shouldn't happen.  My guess is that something is changing in some way, but without a simple example that demonstrates the issue, there isn't much we can do here to investigate.

I'm going to close out the issue because it's not actionable in it's current state.  My guess is that there is a bug somewhere in your code, rather than a bug in the React core.  If you can create a simple example (jsfiddle) that demonstrates a bug in the React core, we'd be happy to re-open and investigate further.
 Let's keep it open and close if we can't get a test case together or find its nothing. We don't have enough info to confidently close this.
 You should be able to set a breakpoint inside render in your component and see what `state` is there.

> calling setState from outside the element

I don't think that matters but my gut reaction to that is _don't do that_. Expose a method that calls setState maybe but my recommendation is that you should really consider state private.
  `isMounted` is already unavailable on ES6 classes, and we already have a warning saying we "might" remove them, but we don't actually have a github issue to deprecate them.  As per our discussions today, we are basically agreed that we're going to start moving away from `isMounted` and deprecate it.  We still need to figure out some good stories around promises (and related use cases).

This issue is to track progress toward that goal.

For background, please read:
- https://github.com/facebook/react/issues/2787#issuecomment-68738793
- https://github.com/facebook/react/issues/3417
- https://github.com/facebook/react/pull/5420#issuecomment-155577641
 @yaycmyk Thus the line:

> We still need to figure out some good stories around promises (and related use cases).

Please read the background issues I listed, in particular: https://github.com/facebook/react/issues/2787#issuecomment-68738793
 This is a longer term goal, not something that is happening immediately. But we want to track the planning and discussions in a single place and not across comments in every issue when this comes up. We are aware of the problem of Promises currently being uncancellable which is a major reason we haven't already done this.
 @yaycmyk To over-simplify a very complex issue... the comments are saying... using `isMounted` to avoid `setState` for unmounted components doesn't actually solve the problem that the `setState` warning was trying to indicate - in fact, it just hides the problem.  Also, calling `setState` as the result of a promise is a bit of an anti-pattern anyway, since it can cause race conditions which won't necessarily show up in testing.  Thus we want to get rid of it, and figure out a "best practice" recommendation for using promises with React.

I agree the issues are a bit inscrutable, but that's largely because it's a complex issue that we're still figuring out and don't yet have a canned response for.
 @dtertman Fixed in https://github.com/facebook/react/pull/5870, will be online when the docs get cherry-picked over.
 @vpontis Thanks, I'll fix!  (https://github.com/facebook/react/pull/6152)
  Thanks @fkling!  Closing this out in favor of #1851.  Also, see https://github.com/facebook/react/issues/3236#issuecomment-76456970 which has a somewhat related discussion.

@colllin For future reference, usage questions are best addressed on StackOverflow.  I know this was somewhat bug like, so this wasn't a bad place, but just something to consider; we try to keep github for tracking bugs in the core.
  Posting primarily to get feedback/thoughts/comments, and catch concerns early rather than late in the process.

The basic idea is to use a [CQRS](https://msdn.microsoft.com/en-us/library/dn568103.aspx) (or more specifically, [Event Sourcing](https://msdn.microsoft.com/en-us/library/dn589792.aspx)) pattern whereby the core will emit an event every time it does something (starts a render, ends a render, registers a dom-event-handler, resolves a ref, etc).  The devtools can listen to each of these events, and derive a shadow copy of any state desired.  This allows devtools to "follow along" with everything React is doing, and emit very information-full error messages, without us actually routing things through the core for the sole purpose of warnings.

Devtools are registered with React, which is global state, but is effectively what was happening before (except the current devtools uses monkeypatching, this is an explicit public API)

The "devmode" build of React (ie. the one that emits warnings) would simply be a copy of React bundled with a default devtool that registers its self with React, and keeps the necessary state to emit warnings.  This means that the production and dev code paths become more similar, because the only difference is that in production `emitEvent` is a no-op.

This was built with lessons learned from other tools (hot-reloading, people wanting to customize the warnings module, etc) in mind.  It allows other people to build custom devtools/warnings/etc.  See https://github.com/facebook/react/issues/5306 for details on the objectives.
 @sebmarkbage has context on this.  cc @spicyj for reference.
 cc @gaearon, #4593
 @gaearon 
Obviously you should try to attach all devtools before first render.  However, attaching mid-way is permitted, and the newly-attached devtool would miss the history.  There are a couple of options here.  The simplest is that the newly-attached devtool ignores events until it finds a "synchronizing event" such as a root-level call to `React.render` that it understands, and can start building internal state from that point forward (This strategy is stolen from the idea/way that compilers recover from invalid parse trees).  With such an approach, once all the root components on a page have done a full re-render, the devtool is "caught up".  We could force a rerender of all components on the page upon a devtool being added, or at the very least emit "welcome" event announcing that the new devtool has been attached and providing a basic synchronization event that lists the current React roots.  So my answer would be: yes, still figuring out the details though.  Do you have any thoughts on how best to do this?

Forcing rerender is easy - you will already know the React root's "container" node (from the previous render events your devtool witnessed) and you will already have the element that was rendered to that node (from that same previous render event), so you can just invoke `React.render`.  Alternatively, you could store the instance that resulted and invoke `forceUpdate()`.

Regarding read only: This API is intended to provide one side of the [CQRS](https://msdn.microsoft.com/en-us/library/dn568103.aspx) flow.  Specifically, this API handles QUERY (all data that React provides will come in the form of these events).  It does not provide the command side/flow, which is completely independent by definition of CQRS.  For now, the command side would require utilizing the existing public API (or reaching into internal/private API) until such time as we can design+expose an intelligent set of commands for devtools.
 @gaearon That question is slightly orthogonal to this API (it's a matter of what is doable in the React core, regardless of the communication mechanism).  That said, functional components will not have internal instances and so there is no way to reference/rerender only a functional component.  You would need to rerender the closest parent ancestor.
 Merged in https://github.com/facebook/react/pull/5590.
 @oliverwoodings Correct, dev only.

FWIW, due to the nature of e2e tests you only want to test user visible behaviors.  You shouldn't need a devtool (which is specifically for the purposes of peaking into internals) in your e2e tests, IMHO.
  Already done in #5396. The next publish for 0.14.3 will update that (there's currently no way to update npm metadata without a new version). No timeline on 0.14.3, but looks like we have a few things to put in there so perhaps soon.
 npm treats that as github (https://docs.npmjs.com/files/package.json#repository)
  This should probably get better when incremental rendering is implemented. If you‚Äôre interested in this work, you can track #6170.

There was also a suggestion about using a neat hack to ‚Äúfake‚Äù the stack in #3586, and another suggestion to make Chrome async stack trace debugger ‚Äúsee‚Äù React components in https://github.com/facebook/react/pull/3586#issuecomment-90302210. You are welcome to explore those ideas if you‚Äôd like.
 This might be better directed at the Chrome team though.
@paulirish might be interested in this.

Stack traces should get smaller after we start tackling #6170.
  Thanks @mjackson!  I agree, that was a fantastic answer!

I'm going to close out this issue as "answered", but feel free to continue the discussion on this thread if you guys so desire.  We can re-open if the thinking on this topic changes dramatically, or if we find anything actionable on React's end.
  At the very least, we'll need to squash these three commits into a single commit before merging.

Staying up-to-date seems generally good.  Just curious if there was anything that forced/motivated this change, or was it just cleanup?

@zpao and @spicyj because npm.
 Normally we squash, but there are sometimes exceptions.  I'll let @spicyj or @zpao decide about squashing and/or merging this one.
 FYI: No changes to eslintrc have been made in fbjs-scripts and the changes that have been made there don't affect us. The only actual change is to del, which now uses promises. Your change in the gulpfile should be right but I ran into issues in the past when using it with dependent tasks (but just testing again locally can't repro my original issues so meh).

We're not going to cherry-pick any of these to stable so let's squash.
  Thanks for posting on StackOverflow - that is a much better place for usage questions!

Original question was: 
http://stackoverflow.com/questions/33668088/animating-non-existant-elements-in-react-js/33670565#33670565

If you're able to reduce it to a simplified test case that demonstrates a bug in the React core, please do let us know!
  @marocchino : The two translations look a little bit different.  Which one do you prefer for the Korean docs?

> Ïù¥ Î™®ÎìàÏùÄ ÌèêÍ∏∞ÏòàÏ†ïÏûÖÎãàÎã§. ÎåÄÏã† [JedWatson/classnames](https://github.com/JedWatson/classnames)Î•º ÏÇ¨Ïö©ÌïòÏÑ∏Ïöî.

 or

> Ïù¥ Î™®ÎìàÏùÄ Ïù¥Ï†ú [JedWatson/classnames](https://github.com/JedWatson/classnames)Ïóê ÎèÖÎ¶ΩÏ†ÅÏúºÎ°ú ÏûàÍ≥† ReactÏôÄ Í¥ÄÎ†®ÏóÜÏäµÎãàÎã§. Í∑∏Îü¨ÎØÄÎ°ú Ïù¥ Ïï†ÎìúÏò®ÏùÄ Ï†úÍ±∞Îê† ÏòàÏ†ïÏûÖÎãàÎã§.
 Thanks! Let's followup in another issue if the Korean translation needs to be updated.
 Pushed 72d9a8bc15e1c1bdddef59a8db0f8747f43f55d5 with the shorter one. Thanks!
  Documented in [several places](https://facebook.github.io/react/docs/top-level-api.html#reactdom.render):

> Render a ReactElement into the DOM in the supplied container and return a reference to the component **(or returns null for stateless components).**

As well as mentioned in big [red boxes](https://facebook.github.io/react/docs/reusable-components.html#stateless-functions):

> NOTE:
> Because stateless functions don't have a backing instance, you can't attach a ref to a stateless function component. Normally this isn't an issue, since stateless functions do not provide an imperative API. Without an imperative API, there isn't much you could do with an instance anyway. However, if a user wants to find the DOM node of a stateless function component, they must wrap the component in a stateful component (eg. ES6 class component) and attach the ref to the stateful wrapper component.

Duplicate of https://github.com/facebook/react/issues/4936
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 This looks super cool!

Was it generated in some way, or did you build it by hand?

The reason I ask is that there are a few things we need to figure out:
- How do we maintain it (ideally we could just re-run a script.  Or maybe we just accept PRs as they come - but this would compound the whitelist hell we already face with attributes)
- How do we verify it (for correctness)
 Looks like this is just copied in from https://github.com/DefinitelyTyped/DefinitelyTyped/blob/master/react/react.d.ts, which is manually built & maintained.

Jim brings up a good point - it would be awesome to have a way to verify and / or autogenerate this. The latter is probably not going to happen so the former would be ideal. If we can't do that then I don't think we'll take this. We don't use TS and so we wouldn't know when we break things without something automated telling us.

A few further (more specific) points:
1. We don't use that package.json to ship to npm (look inside `packages/react` to find the right one).
2. We'd want this for react-dom and each of the addons. all or nothing.
2. We're well past v0.13.3 now and would need these updated for master

cc @sebmarkbage because TS and modules
 It wouldn't be unreasonable to have this work live inside the React repo since it is being well maintained already. That request should come from the primary team maintaining it with appropriate testing infrastructure and licensing information associated with it. We won't take this without those things.

Even at Facebook, our React definitions are maintained by the Flow team itself. In its own repo. So it's kind of up to those teams if they want to source of truth to live here.

Might be nice to include them in npm releases.
  You have a lot of code here.  It might be helpful to try to simplify your example before asking about it.  If you can provide a simplified example that demonstrates a bug in the React core, we can re-investigate.  Also, if you haven't already, don't forget to check out https://fb.me/react-refs-must-have-owner

This looks like a usage question, rather than a bug in the React core. Usage questions are better answered on sites like StackOverflow, as we try to use github issues for tracking bugs in the React core. For this reason, I'm going to close out this issue, but feel free to continue the conversation here or move it to StackOverflow.
  ``` js
controller = React.createElement(SelectionsController, values: ['one', 'two', 'three'])
```

All you've done here is create an element, not a rendered instance of the component. Elements are lightweight objects that React then uses to render - basically it looks like this:

``` js
{
  type: SelectionsController,
  props: {
    values: ['one', 'two', 'three']
  }
}
```

In order to have an instance to work with, you then need to render it and the returned value is an instance.

``` js
var instance = ReactDOM.render(controller, node);
console.log(instance.getSelections())`
```

The docs you linked to don't need to be updated - they are working with refs, which is another way to access rendered components within another component.
  This makes more sense and avoids DOM nesting problems.

![image](https://cloud.githubusercontent.com/assets/6820/11098713/952348ca-885b-11e5-9757-e4a76467b0b8.png)

(ReactSimpleEmptyComponent isn't used here but React Native can use it as it currently does, with View.)
 Only reference I can find is #4550 which shouldn't actually be an issue because we work around it in our `setInnerHTML` module.
 I thought Knockout is a client-side library only?
 Got it ‚Äì thanks for the explanation! I don't think this will be an issue for us.
 ![doit](https://cloud.githubusercontent.com/assets/8445/11289098/855c1d5c-8ede-11e5-8021-c6b231c5e328.gif)
 @martijnrusschen This will be released in v15, coming soon.
  The first example you gave is expected, and is one of our small performance updates.

But `forceUpdate` should - you know, force an update!  Sounds like a bug to me.
 cc @sebmarkbage @spicyj, this sounds like something that came up not too long ago but I don't recall the resolution.

The root of it is that the element that gets passed in is === to the one previously rendered so presumably we made the decision to skip that. That's fine when things are pure but is confusing when breaking out and using non-deterministic method calls in render.
 I should have mentioned this in the changelog, sorry.

When you call forceUpdate, your `Foo` component _does_ rerender, but `Hello` does not, as if `Hello` had a `shouldComponentUpdate` method that returns false.

I don't think we plan to make any changes here ‚Äì I hope it's not too hard to update your code.
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Yeah, I'm going to close this out in favor of #5444 

See #5257 for a discussion about why we would want to specify an ID in the data rather than use the index as an identifier.
 @svgpath If you're looking to contribute, a great place to start is here: https://github.com/facebook/react/issues?q=is%3Aopen+is%3Aissue+label%3A%22good+first+bug%22
  `<title>` only allows a text node as its child. You're putting a `<span>` in there which becomes rendered into the text node and thus cannot be found by React. You must do `<title>{...}</title>` instead (caution, it cannot be `<title>Foo{'bar'}</title>` either at current, due to React internals).

PS. I'm not really familiar with these parts of HTML, but are `<title>` tags even valid inside body?

cc @spicyj update validateDOMNesting?
 The initial render (currently) just does an innerHTML. a `<title>` tag in the body of the document actually results in a child node that is text, regardless of the markup in there. So the `<span>...` isn't actually a node. So when React tries to find the node with the data-reactid we assigned, we can't find it, thus the error. this is what @syranide explained (though leaving out the initial render part, which is important to explain why that first render worked without a warning).

<img width="563" alt="screen shot 2015-11-11 at 3 12 12 pm" src="https://cloud.githubusercontent.com/assets/8445/11105876/c2c3a164-8886-11e5-9b28-76a92c0e1633.png">

Inside SVG, `<title>` is a valid child that works differently than it does in HTML and it seems to be valid to have child nodes there, even if they are ignored.
  I remember @spicyj and @sebmarkbage did a lot of thinking+discussing on this topic.

I don't remember the details, but I do recall that the decision was pretty intentional.  For this reason, I'm going to label this as a question regarding the reasoning.
 Refs to child components are resolved before a parent's componentDidMount/DidUpdate, which happens before refs to that parent are resolved. For example,

child A did mount
ref to child A resolved
child B did mount
ref to child B resolved
parent did mount
ref to parent resolved

This is the only order that ensures that a component is fully initialized when you receive a ref to it and that it can use its children during its initialization. You should avoid accessing siblings or ancestors in a componentDidMount because they will often not be mounted yet.
 Ah, yes, that was it.  Thanks @spicyj!
 @jedwards1211 I believe @MalucoMarinero was trying to access sibling components in a componentDidMount (via a synchronous callback to the parent) which isn't kosher.
  For legal reasons, an official answer to questions like this could only come from a lawyer; I am not a lawyer.

This is a question which is best posed to your company's legal team - they should know what to do or who to ask.  Because there isn't much that our team (of non-lawyers) can contribute to this discussion, I'm going to close out this issue.

cc @jamesgpearce, who may be able to give a more authoritative answer.
 CC BY 4.0 allows the modification and redistribution and that is what our documentation is licensed under (just give the license a read over and make sure you comply).

Are you also looking at using the design? I'm not sure where that falls in the scope of things, but I'd be happy to check in with our legal team and clarify if needed.
  Thanks for taking this on!

This is a lot of code to introduce all at once - I think we might need a bit more in the paragraph preceding that first big code change to tie it together more.

> Let's make the form interactive. When the user submits the form, we should clear it, submit a request to the server, and refresh the list of comments. To start, let's listen for the form's submit event and clear it.

It's technically accurate - that is exactly what we're doing. But then you see a whole lot of code changing to do something that on the surface seems pretty straightforward. So I think saying something about the fact that we're going to use `state` to store the user input as it is entered - another use of state that we didn't discuss above when we talked about state. We're also definitely doing more than "listen for the form's submit event and clear it".
 @yangshun updated the pull request.
 Otherwise, this looks really awesome, thanks! Could you fix that one bit and squash the commits, then we can merge this. Would you like to update the tutorial repo as well (https://github.com/reactjs/react-tutorial/blob/master/public/scripts/example.js)? I'm happy to do that but figured I'd give you the chance if you wanted :)
 @yangshun updated the pull request.
 No, let's let the translators do that. Unless you happen to know Italian, Japanese, Korean, and Chinese‚Ä¶
 Yea, that'll be fine. We don't do a good job of surfacing those translations so it's not a huge deal.
 Awesome, let's get these in and I'll update the site :)
  Based on some discussions had outside of github, we're going to move away from the use of refs in the tutorial and use controlled components instead. This is the most "reacty" way to do what is done in the tutorial and avoids the escape hatch of refs.
 I agree. I think I might try to avoid bind for the purposes of the tutorial and just have 2 explicit handlers.
 Awesome. It's going to require more than just the code change - we want to make sure the concept is adequately explained as well. Looking forward to it!
 Great, thanks!
  Looks good, will let it sit for a day to collect feedback before merging.
 üëç
  I'm not entirely sure what this question is asking, but it sounds like a usage question.  I don't see any actionable bug at the moment.  If you suspect a bug in the React core, please provide a simplified case that demonstrates the issue and we can re-investigate.

Since this looks like a usage question, rather than a bug in the React core. Usage questions are better answered on sites like StackOverflow, as we try to use github issues for tracking bugs in the React core. For this reason, I'm going to close out this issue, but feel free to continue the conversation here or move it to StackOverflow.
  Yes, totally feasible.  That's the reason that we split react-dom from react-core in 0.14 - to allow custom renderers like this to be written easily.  The best approach is probably to fork react-dom, and build on top of that.  From your description, it sounds like `src/renderers/dom/shared/HTMLDOMPropertyConfig.js` would be a good place for you to start making your changes.

It sounds like a usage question rather than a bug in the React core.  I'm going to close this out, since we use github issues to track bugs in the React core.  Usage questions are better addressed on sites like StackOverflow.  Feel free to continue the discussion on this thread.
 @nickdima My recommendation is that you always remain as close to the original as possible when forking a project.  Always push any changes that make sense to upstream.  Otherwise, you'll likely fall behind.  That said, ultimately, you need to make whatever changes are required for your rendering target.
 I don't know enough about the differences to have an opinion on that.  I suspect that a bunch of your issues may be solved by #140 (actually, that might solve nearly everything for you), but I just don't have enough context to make an educated statement on TVML.
  @spicyj @syranide I know we intentionally don't/can't normalize everything.  Is this something we care about normalizing?
 @jimfb I think it makes sense to normalize it, but unless we solve _all_ of these problems then it seems kind of fruitless... and last I checked solving entirely in the event system didn't seem realistic. So that leaves solving it inside a wrapper-component which is trivial but would leave out the DOM bubbling (relying on that is a bad idea IMHO, but people do it), but it's trivial and safe to implement this wrapper-component yourself, so it doesn't seem very high priority to me.

That's what it seems like to me at least.
 Ok, sounds like we probably won't invest time in solving this at the moment, but if @edmellum wants to file a pull request, it would be considered.
 #4051 fixed this and will be in React v15.
  Looks good!

Can you squash all the commits into a single commit?
 Note: we have specific lines highlighted when rendered as you can see when viewing the tutorial online. Please make sure the same lines are highlighted with this change by running the server locally (or just doing the subtraction). See the line opening the codeblock, it contains `js{N,J-K}` where those numbers indicate the lines to highlight in the block. You are removing a line so please adjust accordingly.

@jimfb please coordinate with me so we get this in and synced out and get the tutorial repo code updated as well.
 And after thinking about it some more, I'm going to opt to just leave these as string refs. See my comment in https://github.com/facebook/react/issues/5427#issuecomment-155584274

I appreciate the effort though. We'll revisit this when the fate of string refs is final.
 @ramiruhayel Thanks for taking a stab at this one!  We decided that if we're making a change here, it should probably be to completely rework this example: https://github.com/facebook/react/issues/5443
  `autocorrect` is only supported in mobile Safari AFAIK, which explains your results. FYI your test passes in iOS 9(.1 in a simulator, didn't test on real device but I trust the simulator).

On desktop, the attribute is ignored and actually, it looks like `spellcheck` does pretty much the same thing in Safari.

Now that said, the property is a boolean and the attribute supports `'on'` and `'off'` as values (corresponding to `true/false` for the property). With our markup generation code, we don't currently support booleans properties corresponding to specific values in the attributes so the best course of action here is probably to do what you suggest and just make this `MUST_USE_ATTRIBUTE`
  Yeah, we dropped support for phantomJS a while ago.

See: https://github.com/facebook/react/pull/4393#issuecomment-121857904

> phantomJS (old, not a real browser, even with shims...
  Can you link to a spec or something about the `hash` attribute? I don't see it referenced above.
  @rpominov No, I don't think this is related.

@blainekasten I think you want to have your render function produce an empty div and set the html in the callback ref.  The following is untested, but is roughly the idea: `<div ref={function(mydiv){ if(mydiv != null) mydiv.innerHTML=mymarkup}} />`.

This looks like a usage question, rather than a bug in the React core. Usage questions are better answered on sites like StackOverflow, as we try to use github issues for tracking bugs in the React core. For this reason, I'm going to close out this issue, but feel free to continue the conversation here or move it to StackOverflow.
 @rpominov Ah, you're right.

> My problem comes in that when the routing changes, it re-renders the tree, and wipes out the custom DOM put in by the third party api.

Does look like a reparenting request (duplicate of #3965).  Thanks!
 You're trying to reparent some markup that wasn't generated by React.  I think you're going to need to do that manually using javascript.

You can probably remove the child node from the tree in `componentWillUnmount` and save it somewhere (in your flux store or whatever).  Then in `componentDidMount` you can re-insert that node into an empty div when the new component renders.  I'm not positive if that would work, but I think it should; that's the approach I'd try next.
  Instead of using a span as the child, you could create a child component that expects that prop to be set when that child renders, and fails the test if the prop isn't set properly.

This is a usage question, rather than a bug in the React core.  Usage questions are better answered on sites like StackOverflow, as we try to use github issues for tracking bugs in the React core.  For this reason, I'm going to close out this issue, but feel free to continue the conversation here or move it to StackOverflow.
 Looks like you're already pulling `parentElement.doStuff` to get the function that you expect.  So...

```
class Child {
  render() {
    expect(this.props.whatever).tobe(parentElement.doStuff);
  }
}
```

Just make sure parentElement is defined in the current scope prior to defining the Child class that you are using for testing.
  Should use callback refs in the tutorial.
 After thinking about this some more, we're going to keep the tutorial as is and use string refs. They aren't deprecated yet and its one less thing to learn right away. We should improve the wording on the refs page though to make the current support status clearer.

String refs are still valuable and much easier to use in some cases, especially in the context of forms.
 To follow up on this issue, our discussion resulted in a decision to do https://github.com/facebook/react/issues/5443 instead.
  Duplicate of https://github.com/facebook/react/issues/4517
  `setState` takes in an object and does a shallow merge of the properties on that object (it does not completely replace the current state with the state you pass in).  See the docs here: https://facebook.github.io/react/docs/component-api.html#setstate

This looks like a usage question, rather than a bug in the React core. Usage questions are better answered on sites like StackOverflow, as we try to use github issues for tracking bugs in the React core. For this reason, I'm going to close out this issue, but feel free to continue the conversation here or move it to StackOverflow.
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Looks good.  Can you sign the CLA and then we can merge?  https://code.facebook.com/cla
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 Thanks!
 If you're looking for other ways to contribute, you might consider some bugs off this list:
https://github.com/facebook/react/labels/good%20first%20bug

In particular, this one looks like it might be a good next bug: https://github.com/facebook/react/issues/5427
  As @yaycmyk, this is a discussion best had on Stack Overflow.
  @laskos updated the pull request.
 @laskos updated the pull request.
 Explicitly tracking isMounted status seems reasonable to me, but @sebmarkbage or @spicyj should take a look and sanity check.
 No, this would be bad for perf. I'm not even really convinced that either return value makes sense in this case. But if we care about fixing this it might be best to go through enough of the unmount process that `_renderedComponent` gets set back to false.
 Wouldn't going through the unmount process be even worse for perf?

I think the component is clearly not mounted.  The mount image has been generated but until that mount image gets parsed into the DOM document, but IMO it isn't mounted.  What is your reasoning for neither return value making sense?
 Should we just deprecate isMounted already? We generally don't like to be forced to get keep state around for the off chance that someone might want to read it.
 Not worse than always adding to the transaction mount-ready queue like this does.
 @laskos updated the pull request.
 This is also not good because it relies on the DOM implementation whereas ReactUpdateQueue is used on all platforms (like React Native).

What change are you proposing, sorry? The recommendation was to not use isMounted, which is a change you would make in your own code.
 @sebmarkbage I'd be fine with deprecating it (I'm always a fan of removing features).  But it is used an awful lot internally (hundreds of components), which is going to be a beast to codemod away.  Also, we need to make sure there are no legitimate uses of `isMounted()`, though I suppose the workaround is to manually track mounted state.  Probably a good topic for Friday's agenda.
 React Native does not use a DOM at all.
 I think that ultimately the correct solution here is that there shouldn't be an "internal instance" for server rendered components. To do that, we would have to create a separate mount path for them, which we intend to do at some point and in that case.

Actually, they wouldn't even call into ReactUpdateQueue because they would only get ReactNoopUpdateQueue injected.
 @laskos `componentDidMount` means that users are allowed to do things like imperatively add children to their placeholders and perform other dom operations.  It can't be called until after `findDOMNode()` becomes accessible/valid.  Also, unless I'm miss-understanding what you're saying... `ReactDOM.findDOMNode()` doesn't get called by React (it gets called **from** user code, so you can't wait for it to get called before allowing user code to run).

If we're ready to do it, I think the correct solution is to deprecate `isMounted()`, but I suspect that won't get decided until this week's team meeting.
 What, in that case, is the purpose if `componentDidMount`?  What would you want to put in there?
 It makes no sense to have `componentDidMount` as a lifecycle event before the DOM node is available, unless there is something you would want to do there (I can't think of anything).  This means `componentDidMount` needs to be called after "mounting" into the DOM.  That's effectively what mounting means anyway (the "mount image" has been materialized).

@laskos I think it is incorrect to think that mounting has occurred from an isomorphic perspective.  We have created a "mount image" (a description of what needs to be done to mount) but haven't actually materialized it.  That string could just be thrown away (in which case, it is never mounted anywhere) or the markup/string could be duplicated and sent to a thousand rows of a table (in which case, the image gets mounted into a thousand different places).  From an isomorphic perspective, the "mount image" is rarely materialized into a serialized form (so it skips that phase), but mounting still hasn't happened until the view nodes have been materialized.

@laskos You can't call `componentDidUnmount` (or `componentWillUnmount`) because you didn't call `componentDidMount`, and unmount is often used to cleanup things that were allocated in `componentDidMount`.  Also, componentDidUnmount (or `componentWillUnmount`) means the component lifecycle is done and the component can throw stuff away (when in fact, the lifecycle hasn't even started).

Anyway, the entire discussion is academic if we end up getting rid of `isMounted`, so let's loop back Friday evening.
 I‚Äôm closing this because we can‚Äôt introduce DOM dependencies in `ReactUpdateQueue` as described in https://github.com/facebook/react/pull/5420#issuecomment-155594445, and we plan to get away from `isMounted()` anyway as described in #5465.

Thank you for taking time to contribute and sparking this discussion! This one did not get through but we hope to see more pull requests from you in the future.
  Probably best submitted and discussed here: https://github.com/facebook/jsx
  @Agrosis updated the pull request.
 Seems good to me.  I'll leave it open for a day to collect any feedback before merging.
 A couple comments:

First off, the big one: _Technically_ accepting PropTypes inside oneOf isn't incorrect. I could come up with a contrived use case where I would. Typically though, you probably didn't mean to pass PropTypes in here. So there's the question of whether or not this should be an error. Maybe it should be a warning saying you _probably_ didn't mean to use it like this.

Second. As is, you can have validation pass if you did `oneOf(['foo', PropTypes.string])` and then passed `'foo`' as the prop value since you are checking each expected value in order. However if I passed them into `oneOf` in the opposite order, validation would have failed even though I passed a valid value. We shouldn't do any of this checking in `validate` here - we aren't checking the actual values but are validating that you used `oneOf` correctly. Right now you'll get a runtime error checking the props when somebody uses your component. What you really want is an error when you define your component. We already have a check a few lines up doing another usage check, I would do this sort of thing with that code.

Third: Regardless of what we do here, we need tests for a change like this before we can merge it
 > What you really want is an error when you define your component. We already have a check a few lines up doing another usage check, I would do this sort of thing with that code.

Well, I misread that code a little bit, we still don't fail early in that case but will just always fail validation and short-circuit a more involved check. I would still prefer that happen earlier when defining the component but oh well.
 @Agrosis I think @zpao's first point needs to be resolved before we tackle the others, since it decides the overall fate of the diff.

Is it reasonable to expect a component to expect proptypes as a proptype?  My intuition is that it's fine to say Proptypes are not allowed (people can write their own validator if they really want that), because it's such an edge case compared to the probability that it's a usage mistake.  However, that should be decided before you invest too much work into this diff.
 A few lines above where your PR starts there a check to see if the argument to `oneOf` was an array. https://github.com/facebook/react/blob/master/src/isomorphic/classic/types/ReactPropTypes.js#L205-L211

You could do something similar.

> Regarding the error message, it does show up as a 'Warning: ...' in the browser console, but with a red background (in Chrome). You want it to show up with a yellow background, yeah?

Well, it's more about when the warning comes. Since PropTypes never actually throw (it's soft validation, we just warn and tell you that you used an invalid value but continue execution), it's about the timing of the warning. In an ideal world, I would want the warning to show up when calling `PropTypes.oneOf(...)` (which happens when defining the component class). However nothing does that so you as a component author won't know you wrote an invalid proptype until you try to use your component (when React does the typechecks at instantiation time).

Anyway, the point there is that we should ideally move this outside of `validate` so that we don't have a mixed validation happening and it will just "fail" consistently.

Both mechanisms would go through `warning` which is a method we have that does `console.error`, so it will be red in the Chrome console regardless.
 But yea, maybe we could wind it back and ask how how you concluded that `oneOf` would work the way you thought and why you didn't use `oneOfType` to begin with?

(I really hope that doesn't come across as judgemental in any way - you aren't the first one to make this mistake and that means there's a problem on our end. Maybe it can be solved with code or maybe we just write better documentation to avoid special cases in the code.)
 @zpao I think the only way we could fix that is to rename it `oneOfExactValues` or something.  When I read `PropTypes.oneOf` in the context of type validation, I would assume I could pass in types.  I can easily see how other users arrived at that same conclusion.  Just my two cents.
 We would need to warn for a release.
 If we want to go down the renaming path: `PropTypes.enum` - it's an accepted term for this thing and it's what we already call it inside this file.

FWIW, it's been called `oneOf` forever - `oneOfType` was introduced later and there was some indecision with the name (it was brought up that it was confusing, `any` was one of the original ideas dismissed because it was also confusing).

> When I read PropTypes.oneOf in the context of type validation, I would assume I could pass in types.

I can totally see that too. But I think you would have to see it with the incorrect usage to draw that conclusion OR just never have seen either in use and somehow found a `oneOf` property without seeing `oneOfType` as well.

It's still not clear to me where the miscommunication came in? Are there docs somewhere showing incorrect usage? Is it easier to see `oneOf` in our docs and not see `oneOfType`. I'm trying to understand that side of things so we can improve elsewhere as well.

Anyway, I'm not attached to the `oneOf` name, but I think it probably makes sense not to have an intentionally generic "type checker" that then has opinions about what values you're allowed to use.
 I can very easily see how reading through an alphabetical list, you would stop as soon as you saw a function called `PropTypes.oneOf`.

Vaguely remember that there was something called "oneOf".  Type "PropTypes.one" in Sublime/Nuclide, oneOf is the first suggestion, you see it, it looks reasonable, accept it, and keep writing, never having seen or consciously thought about the other suggestions in the list.
 Hey @Agrosis, thank you for the PR! Sorry we didn‚Äôt communicate any resolution on this for a long time.

I will close this due to the reasons described in https://github.com/facebook/react/pull/5418#issuecomment-155949060.

I also would like to add that this solution is also not very consistent for another reason. It will warn for `React.PropTypes.oneOf([React.PropTypes.number, React.PropTypes.string])` but not for something like

``` js
React.PropTypes.oneOf([
  React.PropTypes.number.isRequired, // .isRequired will give a different proptype
  React.PropTypes.shape({
    x: React.PropTypes.number
  }), // creates a new proptype
  MyCustomPropTypes // is not listed on React.PropTypes
])
```

In other words it ‚Äúsees‚Äù only top-level `React.PropTypes` whereas the proptypes system is meant to work with any custom function and produces new functions in some cases.

I will close for these reasons but please don‚Äôt feel discouraged from sending more PRs! In general it‚Äôs best to discuss the issue first without diving into the implementation. For example, we can discuss whether we want to add a warning or to rename PropTypes to solve the confusion.

In any case, please know that your contribution is appreciated. Watch out for [good first bugs](https://github.com/facebook/react/issues?q=is%3Aopen+is%3Aissue+label%3A%22good+first+bug%22) as well!

Kudos.
 @Agrosis updated the pull request.
  @bbrooks Yea, this is a good idea, let's do it.
  Version 0.13.x is out of date, please update to 0.14.2 and retry.

If you are on an older version of 0.14, possibly related to: https://github.com/facebook/react/issues/5323

If (after updating) you still believe this is a bug in the React core, please provide a simple testcase that demonstrates the issue and we can re-investigate.
 More likely to be related to #554
  Because we wanted to keep the usage as similar to node as possible. `react.js` is the `react` package on npm. `react-dom.js` is the `react-dom` package.

There are a non-trivial number of people doing global replacement in their builds with webpack. This replaces `var whatever = require('react')` with `var whatever = React`, so it's actually a good idea to keep the objects aligned.

This also works towards the eventual goal of being able to swap out renderers. We may not be there quite yet but if somebody wanted to build an alternate renderer, they would just drop the `react-dom.js` and use `my-custom-dom-renderer.js`.
 As @Daniel15 mentioned, we could export two globals.  This issue keeps coming up (eg. https://github.com/facebook/react/issues/6128), and for a good reason: In the common case, a user will want `react.js` IFF they're using `react-dom.js` so it makes sense for the default to be that they are packaged together. There are notable counterexamples (like react-art), but most of those people are using commonjs anyway (which will deduplicate). It's easy to make the argument that they should be bundled by default.  At the very least, we could provide an optional bundled build for the CDNs.
 > At the very least, we could provide an optional bundled build for the CDNs.

This sounds better than providing just a single build to me.
You‚Äôd need not one but two new builds though: `ReactWithDOM.js`, `ReactWithAddonsAndDOM.js`.

I‚Äôm confused how UMD would work for such builds. I think a library can have two ‚Äúindependent‚Äù exports (`window.React` and `window.ReactDOM`) only in the global environment. This wouldn‚Äôt work exactly like this in CommonJS which UMD builds currently support.

Today you can 

``` js
import React from 'react/dist/react'
import ReactDOM from 'react-dom/dist/react-dom'
```

using our UMD builds.

For the hypothetical `ReactWithDOM`, if it is UMD, it would either look like 

``` js
import ReactWithDOM from 'react/dist/react-with-dom'
```

with merged public API (potential name clashes), or

``` js
import { React, ReactDOM } from 'react/dist/react-with-dom'
```

(inconsistent with how we import them in vanilla builds).

Not saying importing CommonJS from UMD build is a common use case but I‚Äôm worried about the potential confusion here. Or maybe I just don‚Äôt understand how UMD builds work :sweat_smile: .
 We won't do just a single build and replace what we have now. If we do this, it will be another bundled build. It will probably not be UMD and just set 2 globals.
 Imagine that there was another renderer on the page such as `react-art.js`, then you would need them both to use the same `react` (because there is still shared global state). There still needs to be separate distributions of each one then. `react`, `react-art`, `react-dom` as well as `react-with-dom`. Maybe you can combine `react-with-dom` with `react-art`, but what if you only want `react-art`? Then you have to add `react`.

Seems complicated.
  Up to this point, the only mention of context has been on the context page.  My intuition is that we should keep in that way (at least for now) - so this should go on the context page instead of the spec page.  My reasoning being that putting it on the spec page makes it feel a little too supported.  I kinda like that you could read all the React documentation without knowing about context, and then if/when you decide you want to use context, you can read through the context page and have an understanding of that feature.  But I could be convinced otherwise by @spicyj; @spicyj  thoughts?
 We should also document context on functional components at the same time, as per the bug that is relevant to this diff: https://github.com/facebook/react/issues/5399
 @yangshun updated the pull request.
 Looks good to me!  I'll let this sit for a day so we can collect feedback/comments from everyone, and if it's all good-to-go, we can merge.
 Two changes, otherwise good.
 @yangshun updated the pull request.
 Thanks @yangshun!
  I don't think we have any chaining APIs at the moment and I'm not sure it's worth the inconsistency to add one now. cc @spicyj @sebmarkbage who have more knowledge on the shallow renderer
 Maybe `render` should just return the `getRenderOutput`?

cc @graue that might remember why we didn't.
 cc @sebmarkbage who merged #4918 which added `getRenderOutput` (with relatedish discussion in #4056)
 cc @zpao who commented twice on this issue
 We have fun üòÇ (sorry to distract from the main reason we're all here, which is to review this pull request)
 cc @zpao who didn't realize that #4918 added `getMountedInstance` and not `getRenderOutput` which was added in #2497. 

@simonewebdesign Would you prefer if it just returned `getRenderOutput` immediately since that seems more convenient for your use case and it's probably fairly common?
 @simonewebdesign updated the pull request.
 Thanks!
  > How to trigger the eventListener that is registered outside of the react component?

I'm not sure what this question is asking, but it sounds like a usage question, which is better addressed on other sites.  We use github issues to track bugs in the react core.  Since this is not a bug, I'm going to close it out.  Feel free to continue the discussion here.
  @jdlehman updated the pull request.
 Can you provide some more context on why you see this beneficial in apps? What problems does this solve? Would that be a breaking change, and if so, why is it justified?
 What if there is one current item, and then we add a second one. Wouldn‚Äôt switching to `span`s while the first one is displayed cause the first item to lose its state?
 > If we're going from a single child to multiple children, we'll have the problem.

This is the main reason I‚Äôm inclined not to take this. Losing the state and changing DOM structure during a very common transition (most lists may sometimes contain one element) is problematic. 

I think that if you want to have full control over the rendered children you might be better off with something like [react-motion](https://github.com/chenglou/react-motion/) which provides you that by letting you ‚Äúspecify‚Äù the rendering function as a `children` prop so you have full control. I wonder if we could do something similar?

``` js
return (
  <ReactTransitionGroup render={children => children}>
    <MyComponent />
  </ReactTransitionGroup>
)
```

By default `render` prop could be `children => React.createElement(this.props.component, { children })`.

Would this satisfy your use case?
 > Would resolution to #2127 help?

Yes but my gut feeling is that by the time it is implemented we‚Äôll have something better than `ReactTransitionGroup` for animations. I wouldn‚Äôt count on fragments coming any time soon.
 Do I understand correctly that you always use TransitionGroup for a single element only, and that your use case is not so much a ‚Äúgroup‚Äù but as a way to animate mounting and unmounting of a single component?
 I‚Äôm closing because, per the reasons above, this particular API is inherently problematic.
Let‚Äôs continue the discussion about this use case in #6361. If it isn‚Äôt fruitful we‚Äôll need to create an issue to track this.
 For posterity, it seems that this was achievable with the current API as well: https://github.com/facebook/react/pull/6361#issuecomment-202587067
  This is odd‚Ä¶ On the surface it seems like your code shouldn't be running anywhere.

JSX desugars to React.createElement - `<div />` becomes `React.createElement('div')`. So you generally need `React` in scope. With `import { Component } from 'react';` you don't get React in scope.

Is this only an issue in IE9 but fine everywhere else? Which version of Babel? It might be helpful to have a gist with the minimal repro with your config (multiple-file gists are good for this), and then we can just npm install and repro locally.

Honestly this seems like it's mostly likely somewhere in the combination of babel + browserify + shims, but maybe that in combination with something we're doing is making it worse.
  Thanks for following up :) You cool with this wording @sebmarkbage?
 I guess that's a yes :P.  Thanks @acdlite!
  Can you fix such that the colon is consistent also?  `found: 0` instead of `found 0`
 @yangshun updated the pull request.
 Thanks!
  @joecritch was also interested in this. We want to keep at least some semblance of similarity between the different Facebook project sites and we're more concerned about improving the content and organization of the docs than the color scheme. I also don't think there's too much value in making the sidebar collapsible. Mobile styles would probably be okay.
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 I think the whole point of that sentence is to provide an example of unstable keys.  It is explicitly calling out something that newbies sometimes try, and saying DON'T DO THIS.  I don't think removing that parenthetical solves the problem.

If you really believe it should be more explicit, maybe we could say:

> If you don't provide stable keys (by using `Math.random()` for example), all the sub-trees are going to be re-rendered every single time (which is bad - don't do this).
 I agree it doesn't read super well. Perhaps pulling the example out of the sentence.

> If you don't provide stable keys, all the sub-trees are going to be re-rendered every single time. `Math.random()` is an example of an _unstable_ key - it will be different on each render. By giving the users the choice to choose the key, they have the ability to shoot themselves in the foot.
 @zpao That still doesn't explicitly say it's bad to have unstable keys, so it's still subject to the miss-read that @yuyokk originally raised.  It might not be obvious to a new user that re-rendering every time is a bad thing.
 Yeah, it's worse than just "bad performance" because you also loose internal state of all the decedents.  Someone might be like "whatever, that's fine, performance is not an issue here" but then their code is actually wrong from a correctness perspective.  Having said that, it's fine with me, subject to @zpao's go ahead.

Maybe:

> Keys should be stable, predictable, and unique.  Unstable keys (like those produced by `Math.random()`) will cause many nodes to be unnecessarily re-created, which can cause performance degradation and lost state in child components.
 I like it, thanks @yaycmyk. Let's not use the word "node" though since it already has meaning in the DOM and React and neither of those is what you really mean here. All the terminology is confusing though‚Ä¶ maybe just "component"? It's mostly correct since we use that to talk about instances. Or do whatever, this is definitely better regardless.
 @yaycmyk Technically it is a component (just a trivially simple one).  I'm fine with "component" or "node".  Element probably isn't what we want (`element` refers to the JSX tag, which is always re-created regardless).
 Yeah, that's why I'm fine with either one.  Node is often used a little more loosely, but component is technically a little more accurate.
 @TechyHouseWife557 the post by that bot is directed at the author of the pull request, which is not you. I admit that isn't completely clear, perhaps we should include the author's GitHub username.
 Ping @yaycmyk: Do you want to update this PR so we can merge?
 Oops, sorry @yaycmyk 

Intended to ping @yuyokk
 @yuyokk updated the pull request.
 @yuyokk Looks good.  Can you squash the two commits into a single commit (I use `git rebase -i` to squash and `git push -f` to push), and then I think we're ready to merge.  Thanks!
 Excellent, thanks @yuyokk and @yaycmyk!
  The rest of our documentation is written in a way that provides more context. The API reference is just that, reference. The tutorial is a good thing to start with to teach you a lot of the core concepts you need to know to use React.

> also does it allow me to use " " for string encapsulation on render function because for me is more clear.

I don't know what you mean by this. Can you clarify?
 No. You can call `React.createElement` if you don't want to use JSX.
  Probably was just overlooked when writing up the context docs; we can add a note about it to the context page.
 Yes, probably.
  Should be fixed by #5714. Can you please verify with master?
  Based on the discussion in: https://github.com/facebook/react/issues/5030#issuecomment-153803552

Currently, we diff css properties and imperatively set individual properties for each value that differs from the previous render.  We've long claimed that "performance" was the reason, but the benchmarks don't seem to support this claim.  For instance, consider Ben's perf test (http://jsperf.com/style-vs-csstext-vs-setattribute/8 (from https://github.com/facebook/react/issues/929).  Realistically, there are cases where one technique is faster than the other, and vice versa.  It's probably a wash.

But using `cssText` has several advantages over our current approach.  Most notably, it solves correctness issues related to the various css shorthand properties (as noted in https://github.com/facebook/react/issues/5030).  It also cleanly solves vendor prefixing, and a variety of other edge cases.  Plus, as an added bonus, it means that the React core is doing less work and is therefore simpler/cleaner/moreMaintainable.
 My gut feeling is that this is going in the wrong direction and that it makes no sense to serialize CSS just so that it can be reparsed by the browser (just as we're moving from innerHTML to createElement). This will become even more true as CSS values become more structured in the DOM which there are plans for. But if this really seems better then I'm not really opposed. I think at least some people are relying on the fact that we don't reset inline styles that you don't specify in React though‚Ä¶ (e.g., for animations).
  Change log is here: http://facebook.github.io/react/blog/2015/11/02/react-v0.14.2.html

I'll copy it into the master branch now.
 Synced over so it's up to date in `master` now.
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 @zjjw updated the pull request.
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 This looks good. Can you squash your commits?
 Thanks!  Looks good.
  Thanks for doing this, I think it's a great idea. I sort of wish I had pushed for making #3963 actually throw an error (since it would throw at require time, not component creation time). We have less contextual information we can provide but the error would actually be thrown earlier, preventing bad proptype definitions from getting committed‚Ä¶ maybe we can do that in another pass.
 @chicoxyzzy updated the pull request.
 Alright, let's do it. Now that I'm thinking about proptypes again, I might have some followup ideas to try but this puts us in a better spot.
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 Thanks @darul75!  The change looked good, and we would have taken it, except for the other large diff  :). Anyway, thanks, and welcome to the React community!

If you're looking for a way to contribute, I'd recommend grabbing something off this list: https://github.com/facebook/react/labels/good%20first%20bug
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 Seems legit.  Will leave it open for a day so everyone gets a chance to take a look, but otherwise looks good.
 @MattijsKneppers updated the pull request.
 @MattijsKneppers I see you added a couple of additional commits.  Please squash into a single commit.
 @MattijsKneppers Ping.  Would love to get this in.
 @MattijsKneppers updated the pull request.
 Seems good.  Let's give it a day for any final comments/blockers and then if all is good, we can merge.
 @MattijsKneppers updated the pull request.
 Thanks!
  This is an unsolvable problem without explicitly setting the selection yourself.

Setting the value asynchronously is practically equivalent to setting it to an arbitrary value. A string has no selection information and there is no generic transformation of the selection that makes sense, so this behavior is unavoidable. Your only option is to manage and set the selection yourself if this is something you want to do.

Also, beware that setting it asynchronously implies that multiple timeouts may be scheduled simultaneously with unintended results.
 > In the general case it seems fine by itself, but in the specific, doesn't react just sort of sometimes throw asynchrony at you? setState in the parent may be async, rendering into a new subtree as well...is there something special about those cases that React handles it correctly but not others?

Loosely speaking, `setState` is only asynchronous within the current transaction. They're still executed before React surrenders execution back to the DOM, so it still appears synchronous to the input. Again, loosely speaking.

> Is the problem too general for ReactDOMInput to handle restoring the selection on flushed value changes (which is how I've handled it in our app)?

Once React surrenders execution back to the browser it's no longer meaningful for a string to be implicitly associated with a selection I would say. It _could_ still be done, but it's really stretching the definition of what is sane and as I mentioned above, it starts becoming really muddled/fragile if multiple events occur simultaneously. So even _if_ it would be possible, deferring user input degrades the user experience and opens up a can of worms.

Personally I would argue that even the current way the selection is implicitly tied to the new string is a hack, but it simplifies the vast majority of use-cases so it makes practical sense. I've wanted to write a component that exposes the selection too, but haven't entirely gotten around to it yet.

Makes any more sense?
  @marocchino updated the pull request.
 @marocchino updated the pull request.
 @marocchino updated the pull request.
 Cool, @marocchino can you squash the commits into a single commit so we can merge?
 Great, thanks @marocchino!
 Thank you!
 @arkist Yeah, Paul likes everything to be squashed before merging.  Single commit PRs keep the history a little more linear and makes it easier to revert changes if something goes horribly wrong.
 We like to ask for squashed commits so that we don't have lots of "lint fix" or "update based on review" commits in the repo but if each commit stands on its own we can take it without squashing. Having commits from different authors definitely seems to fall into that category. (Sorry about this time ‚Äì next time we can take it without squashing if the individual commits are clean.)
  I'm not entirely sure what you're asking, but the following should solve deep merging for you:

``` js
setState(state => {
  styles: myDeepMergeClone(state.styles, newStyles)
});
```

Multiple `setState`/`forceUpdate` are batched/queued if called during an event, you can achieve the same behavior outside of events too by wrapping them as:

``` js
ReactDOM.unstable_batchedUpdates(function() {
  setState(...);
  setState(...);
});
```

However, this shouldn't generally be needed and you should design your components so that there is only a single call to setState.

> So in the end having deep merge for state would be the best however this obviously is a huge change and may create large performance drawbacks.

This might make sense for some special use-cases but is most definitely not a desirable default behavior. So managing it yourself like above is how it needs to be done.
 > Lets say you want to transfer props of the component to styles. For instance lets say a prop you could set is x and y. You most likely would have two functions that look like this:

It's definitely arguable and certainly depends on the context, but I would generally recommend a different approach:

``` js
var newStyle = Object.assign({}, this.state.style);
parseXInto(newStyle);
parseYInto(newStyle);
this.setState({style: newStyle});
```

This way you can perform batching yourself and you may also find other benefits. Anyway, this is somewhat irrelevant to the problem (`setState` may still be called multiple times for various reasons).

> In this case I'm merging the same way you suggested however if in one execution frame both functions would be run and setState would end up shallow merging in the end.

That's why you need to use the callback-method I showed above, it receives the current state object as mutated by the last `setState`, so multiple pending `setState` are safe.
 @mikkoh Just so that there isn't a misunderstanding, the "`setState` with callback" should solve all your problems. You will still want to avoid multiple calls or batch for performance reasons, but it should not affect behavior.
 (Closing since I don't think there's anything actionable here for React. The setState function style should give you the control you need.)
  I'm a little curious how you ran into this, but yeah, looks like a bug to me.
 (Very unlikely to be a good first bug.)
 @spicyj 
 @RickWong is correct, we certainly don't want to call `componentDidMount` or `ComponentWillUnmount` on the server.  The lifecycle is that the component will mount, but the component is not yet mounted (`isMounted()` should be false) on the server side.
  1) Yes, this is intended.

2) Yes, React doesn't do a deep copy of your props. Doing so for every component would be prohibitively slow. If you want this behavior you can copy it yourself (or simply not mutate it in the first place).
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 Alright, we're going to do this - thanks for making it easy for us :). I'll give it a closer look shortly but I wanted to CC some interested parties so they know. @Download @aantono @JaRail @Daniel15 @aantono.

We won't be building a combined bundle so you'll need to load 3 files into your environment (eg Nashorn) or build your own bundle that exposes globals. That's an exercise we'll leave to the reader ([I did it too](https://gist.github.com/zpao/b736e79d7d40aa304a87))
 Cool :+1: @zpao, thanks
 This looks good, let's do it. Thanks again!
 @aantono Yes you are correct. Following up
  Please use `htmlFor`. We mention this in the documentation: https://facebook.github.io/react/docs/tags-and-attributes.html#supported-attributes
  We don't have a supported way to do this yet. You can look at what react-native and react-art do but the APIs are still frequently changing (which is why we don't support it and haven't documented it). When we've stabilized it, I'm sure we'll publicize it broadly.
  Would you be interested in writing some documentation for the website? If so, let's not reference the previous existence of `shallowEqual` since it was never part of our public API.
 Awesome!

The documentation and website all live in the repo: https://github.com/facebook/react/tree/master/docs with the bulk of the docs in https://github.com/facebook/react/tree/master/docs/docs. The 10.x pages are the addons docs so you'd want to make a new markdown file around there. There's a readme in the root of docs describing running the server (it's jekyll) so you can test the changes locally.
  It's a little difficult to follow everything that's going on here.  Can you create a simple jsfiddle that demonstrates the issue?
 This isn't actionable for us as-is so I'm going to close this out. If you can post a repro case we'll be happy to take a look. If you're seeing an infinite loop my first guess would be a `setState` inside `componentDidUpdate` in your code that's causing infinite rerenders. I haven't heard any other reports similar to this so it's at least not a widespread problem.
 @ashtonwar We treat warnings as errors.  It's a little hard to know where to draw the line in terms of a render limit.  It's easy to imagine a component that is doing syntax highlighting on a bunch of source code.  Each token in the source file would be a component (because it needs to be a different color/style), which would mean rendering potentially tens of thousands of components.  Obviously this would be a perfectly legitimate use case.

I suppose we could print some useful information about little red flags (eg. large arrays, slow render functinos, etc) in cases where renders took greater than X seconds.  But the logic could start to get complicated, and we would still be setting some pretty arbitrary thresholds.  Seems like it would be better if we could just provide some good devtools that provide insight into what's going on in React (we have an umbrella issue for a new devtools API, which will open a path for better tooling).
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 We're already discussing in #5257. Thanks for sending this in though!
  It doesn't look like it returns anything:

https://github.com/facebook/react/blob/a4b5f2fffafb36693a8350e7837625578e7a6cba/src/test/ReactTestUtils.js#L415

If I'm missing something, let me know and I can reopen.
 No, they're different methods that happen to have similar names.
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 cc @marocchino 
 Thanks all!
  I'm not sure what you mean. Can you post a code sample?
 Closing unless I hear back.
  Thanks for the answer @jimbolla!
  No, we don't support this currently because the spec is still in flux (and there hasn't been much demand for it).
  @yiminghe updated the pull request.
 Looks good to me.  Will leave it open for a day or two so everyone can take a look before we merge.
 We should call getNativeProps and mountWrapper in the same order for all components ‚Äì it is too confusing to call getNativeProps first in some cases and mountWrapper first in other cases.
 @yiminghe updated the pull request.
 @yiminghe updated the pull request.
 If we warn inside flattenChildren, and flattenChildren gets called twice, it seems like we would warn twice, right?  We might want to move the warning logic out of flattenChildren.

Also, let's squash into the two commits into a single commit before merging.

Otherwise, looks good to me.  @spicyj?
 Yeah. Can we just set a global flag so that we only warn once?
 @yiminghe Maybe I'm missing something, but isn't flattenChildren also now being called in `mountWrapper`?
 @yiminghe updated the pull request.
 @yiminghe Sorry we dropped the ball on this one, but I'd like to try to get this merged.  Can you rebase and add a unit test to demonstrate that it only warns once, and then I think we can merge.
 Can you set a _global_ (file-level) flag so that we only warn once, even if many children are the wrong type? Because we don't give information about the callsite it's not currently useful to warn many times.

A similar example is here:

https://github.com/facebook/react/blob/1d49baff636ee331797f85f8f36781b196e85a89/src/renderers/dom/client/wrappers/ReactDOMTextarea.js#L43

Then you don't even need the `needWarning` parameter.
 @yiminghe updated the pull request.
 Thank you!
  @ali updated the pull request.
 Looks good ‚Äì thanks so much! Just a couple nits inline. If you could fix those and squash your commits, I think this is good to go.
 @ali updated the pull request.
 Looks great, thank you so much!
  If you can reproduce this you may want to file an issue against react-native (https://github.com/facebook/react-native). We're not directly involved with their `init` process.
  @conorhastings updated the pull request.
 Looks great, just a couple nits ‚Äì if you could fix those and squash your commits that would be perfect!
 @conorhastings updated the pull request.
 @conorhastings updated the pull request.
 Looks great! Thank you.
  So I guess a couple questions‚Ä¶
1. You're goal is just to get rid of an assignment? I wish you could do full destructuring in `import`s but you can't. You could with plain `require`s though: `let { DOM: { main } } = require('react')`
2. Is there a reason you prefer to use factories over what JSX desugars too? It's ok if you do, I just wanted to bring this up since you mentioned you're new to React.

```
import React from 'react';
import users from "./users"
export default (props) => React.createElement('main', props, users)
// or in JSX: (props) => <main {...props}>{users}</main>
```

The factories are mostly just there to support direct function calls, but we really do prefer the direct createElement calls (which we can and have been optimizing such that object literals can be cached and inline, avoiding function calls and GC). I consider the factories legacy but perhaps not everybody agrees. However they don't allow the same flexibility that createElement provides. With createElement we just pass the string through to markup / DOM. So you can start using custom elements (`createElement('my-custom-element', ...)`). Otherwise you'd have to make a factory for every custom element.

It sort of seems like if you continue down the path of your argument that there should effectively be no nested objects exported from any module so that everything could be pulled off with a single line import. I don't think that's reasonable. (And maybe you don't intend that argument)

So your PR as is won't happen. But‚Ä¶

> `import { main } from "react-element"`

Maybe (we'd call it something else since they aren't React Elements, but that's just me being pedantic). There's nothing stopping somebody from writing that today with 1 line - `module.exports = require('react').DOM`. We could pull that out to a standalone package but so far the main argument seems to be to get rid of a line of code. The deprecation bit you mentioned seems like it could be stronger but since createElement lets everything through, I don't foresee anything getting deprecated from `React.DOM`.
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 Yeah, this is more correct. Thank you!
  @hnordt `<noscript />` is what React currently uses when you return `null`.
 Yeah, this is currently a limitation because React constructs every class (`new MeetingMembers()`) and if you return a non-object then you'll get the instance of the class back instead of `null`. We added the requirement that every class extend from React.Component to solve this issue, but 0.14 only deprecates the old behavior and doesn't change it outright. 0.15 will solve this.

Not sure if we have another tracking issue though so we can use this one.
 Fixed in https://github.com/facebook/react/pull/5884
  Babel 6 came out and the docs need to be updated to reflect that. We'll finish getting those updated today.

Here's the minimal bits you need, assuming you have any es2015 code that needs to be transformed.

```
npm i -g babel-cli
npm i babel-preset-es2015 babel-preset-react
babel --presets es2015,react --watch src/ --out-dir lib/
```

For anybody having specific issues using babel, this is not the right place to file issues. More than likely that will be an issue you need to bring up against that project.
 @wpcarro no idea, that's what browserify is supposed to solve for you.
  Yeah, I've run unit tests with v5, haven't seen any issues.  I'll leave it open for a day in case @zpao or others want to raise a flag, otherwise, let's take it.
 Yea, alright. But same goes as for the npm 3 bit. We don't use it so if we run into issues, we'll drop it back down to LTS.
  @chicoxyzzy updated the pull request.
 Since you're dealing with lint stuff‚Ä¶ want to update to eslint 1.8 as well and make sure we don't have other changes needed? Thanks!
 @chicoxyzzy updated the pull request.
 @chicoxyzzy updated the pull request.
 Thanks!
  As mentioned the browser bundle uses UMD so it will work in multiple environments. I would recommend either bundling a version of React that you build yourself from npm or detecting the environment of the page. We won't be changing how our build works.
  @ludovicofischer updated the pull request.
 Thanks!
  @DylanPiercey There are a few benefits:
- when a component is passed props, it is explicitly passed from the owner.  It is very clear what data that component is/might read.  With context, variables are passed implicitly and thus there is no easy way of seeing which variables a component is potentially accessing.  contextTypes provides that visibility to the developer.
- props come directly from the owner/parent component, whereas context can come from almost anywhere.  Props is easy to get right because it's a direct ancestor, whereas context is indirect and thus easier to screw up.  It is easy to have an ancestor somewhere that has a variable name collision and provides incompatible implementations of a particular context variable.
- it allows us (the react core) to see what context variables are going to be utilized, which allows internal optimizations.  Context is super tricky to optimize, and these hints will open paths for optimizations in the future where we can see which context variables are updated and not rerender components that don't read from those variables.  Most components will never want to read from most context variables.  With props, a component is likely to read all its props, so this isn't a concern.

There are perhaps other ways we could have solved this, like my ReactDataTracker proposal, but contextTypes made the most sense at the time (and maybe still does).
 Keep in mind that the community currently uses `context` fairly sparingly (largely because we've aggressively made comments about the `context` feature being unsupported/unstable).  At Facebook, we use React pretty heavily (both in terms of number of components, number of programmers, and number of users) - and we also use the features (like context) long before they're rolled into a public release or publicly documented - so we sometimes see the usability/scalability issues before the outside world does.  I can say with confidence that context is more difficult to reason about than props, which is at least part of the reason we decided to make contextTypes required.

But usability isn't the only advantage of contextTypes.  Allowing the core to make optimizations based on knowledge of a component's use of `context` was also a key factor in our decision.

Anyway, I was just trying to explain our reasoning for making context types required.  If our thinking on this matter changes substantially in the future, or a large number of people agree that it's confusing/inconsistent, we can always reconsider.
 The current behavior (required contexttypes, optional proptypes) is currently the expected/desired behavior (for the reasons listed above).  As a result, there isn't anything actionable in this issue at the moment.

Feel free to continue the discussion on this thread, and we can re-open if our thinking on this matter changes substantially.
  @hzoo updated the pull request.
 @hzoo updated the pull request.
 @puhastudio Please check your entitlement. This is an open source project, it's Saturday morning, Babel 6 came out 2 days ago, and we have lives. We're not all here 10 minutes after every pull request.

@hzoo Thanks for this! I wouldn't be surprised if people use that as source of truth so it's probably worth adding a link to the blog post (since the docs aren't all updated) or adding something about es2015 preset as well for those using it, even if the example here doesn't.
 @hzoo updated the pull request.
 Thanks @hzoo!
  You're almost definitely overriding `window.Event`, especially if you're in a Rails env where basically every component becomes a global (at least out of the box). You may want to look into a module system so that your variables don't leak out from each file.
 Oh and to answer the root question, no there are no reserved component names.
  @prometheansacrifice updated the pull request.
 Also, are you sure this works?  I thought we set `inst.props` to always be `publicProps` (the diff that proposed changing this is what spawned the whole discussion).  Anyway, we should add a unit test to assert the warning fires as expected.
 @prometheansacrifice TopLevelWrapper is created at the top/root of each render tree.  It is a temporary (?) hack so that we can store all top-level pending updates on composites instead of having to worry about different types of components.

I'm a little surprised that TopLevelWrapper warns, since I wouldn't expect it to be doing anything fancy with props.  The entire definition (in ReactMount.js) is literally only a few lines:

```
var TopLevelWrapper = function() {};
TopLevelWrapper.prototype.isReactComponent = {};
if (__DEV__) {
  TopLevelWrapper.displayName = 'TopLevelWrapper';
}
TopLevelWrapper.prototype.render = function() {
  // this.props is actually a ReactElement
  return this.props;
};  
```

Anyway, we should fix so it doesn't warn for TopLevelWrapper.
 @prometheansacrifice updated the pull request.
 Let's also not warn if you pass up undefined (e.g., `super();`). In examples we've indicated that you only need to pass up props if you want to access `this.props` in the constructor (same with `context` as a second arg).
 TopLevelWrapper doesn't call super at all (which is allowed). Look at its definition in ReactMount. You should not ignore it with a check for its displayName.
 @prometheansacrifice updated the pull request.
 @prometheansacrifice updated the pull request.
 @prometheansacrifice updated the pull request.
 @prometheansacrifice updated the pull request.
 @prometheansacrifice Sorry for the delay. This seems good ‚Äì thank you.
  I'm assuming this is a duplicate of https://github.com/facebook/react/issues/5324

cc @spicyj 
 Maybe if we left the node attached to the body forever that could work. But that wouldn't be ideal. Constantly inserting and then removing on each event also wouldn't be ideal either(probably worse).

I think as long as we get the benefits, what we're doing now is fine.

If you could test with a build from master (http://react.zpao.com/builds/master/latest/) and make sure things are working in Edge, that would be awesome! 
 Thanks for testing @timgardner!
  Thanks!  Can you squash into a single commit so we can merge?
 Ok, great, thanks!
  @acdlite updated the pull request.
 @acdlite updated the pull request.
 @acdlite updated the pull request.
 A constructor is the same as a render method from certain types of components. E.g. stateless functional components. That's why the owner is set up there. I don't think this solution is accounting for that.

Would it be enough to simply rephrase this error message as `Cannot trigger update from a render function nor another component's constructor.`?
  A design question raised in another bug: https://github.com/facebook/react/issues/5313#issuecomment-152668532

What is the ideal behavior?  Why don't we support `setState()` in the constructor?  It seems better than having people manually add `this.state = {...}` in the constructor, since the current method encourages the imperative pattern that can't be used elsewhere in the component.  cc @sebmarkbage for an answer.
 Just talked with Sebastian, and we agreed that this is probably a pattern that we will never want to support.  In most cases, calling `setState` in the constructor is an anti-pattern.  The intended "story" for the future is to use property initializers once they land in ES7-ish, and then the `this.state = {...}` will go away.

I'll leave this issue open for another day or two in case people want to continue the discussion.
 `componentWillMount` exists as an escape hatch.
 Dan did file https://github.com/facebook/react/issues/5313, but his concern was more about the error message than about the legitimacy of calling `setState()` in the constructor.  I wonder if @gaearon would consider it an antipattern (the code where he first discovered that the warning-message was wrong).

In general, it seems like a huge code smell if creating/rendering a component is having side effects on other components.  I'm a little skeptical of the use case where you would want to fire an action creator within a constructor; do you have a specific use case or example in mind?
 Even componentWillMount is an anti-pattern. Another scenario is callbacks to a parent in componentWillMount. Where it may reach into a ref before the ref is uninitialized. It causes all kinds of strange artifacts.

Better to just move it to didMount.

Side-effects that change state due to a component being rendered is even more of an anti-pattern and may break scheduling etc. 
 @yaycmyk You can use componentWillMount. What else is different?
 I'm confused. Are you calling `setState` from your `getInitialState`? That's not possible on the ES5 side of things.
 Ok, this was mostly a discussion thread, since Sebastian and I are in agreement that `setState` within the constructor is probably not something we want to support.  I'm going to close out the issue (as per https://github.com/facebook/react/issues/5342#issuecomment-152675459), but feel free to continue the discussion here and we can re-open if our thinking on this matter changes substantially.
  @iamdustan Thanks! Couldn't have said it better myself.

Yes, totally ok to use React without flux.  Yes, please use sites like StackOverflow for usage questions, since we use github issues to track bugs in the React core.
  Without more info, I'm don't think we can tell you what's going on. We haven't heard any complaints from the people using it at FB. You might want to do a bit of debugging yourself or work with the folks from working on FDT.

I'm going to close out for now but if we get something concrete to go on, we can reopen.
  I don't see it on the list: https://facebook.github.io/react/docs/events.html

Yes, it would be good to support all the browser events.  Would you like to submit a PR?
 This was added recently but is not a part of a release. https://github.com/facebook/react/pull/5187
  The property `checked` is forces the checkbox to have the provided value (a controlled input), you need to change `this.state.checkAll` for them to update. To get the behavior you're expecting you need to use `defaultChecked` (uncontrolled input). I would recommend the use of controlled inputs, but that's up to you.
  Having the constructor passing super a props object that differs (in object equality and/or shallow compare) from the original is... illegal, because: https://github.com/facebook/react/pull/5334

We should have a warning for that, because it's reasonable for someone to assume they could extend a component and modify the props, without considering the ramifications, and the bug won't show up in their initial render test but will show up when the component updates.
 I think shallow is fine.  Deep equality is too difficult/expensive because of cycles.

Note that we should only do the check in dev mode, so surround your logic with a `if(__DEV__)` block
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 Eeh, this page already says:

> The result of `getDefaultProps()` will be cached...

And we have a full explanation in the function lifecycle spec:
https://facebook.github.io/react/docs/component-specs.html#getdefaultprops

> Invoked once and cached when the class is created. Values in the mapping will be set on this.props if that prop is not specified by the parent component (i.e. using an in check).
> 
> This method is invoked before any instances are created and thus cannot rely on this.props. In addition, be aware that any complex objects returned by getDefaultProps() will be shared across instances, not copied.

Anyway, it's already pretty well documented, and it's not an issue that people run into super often.  I think adding a flashy note here just adds more noise than value.
  Your example is still really complicated and I'm suspecting the error is somewhere in your code since onLoad works in my jsfiddle: https://jsfiddle.net/65zfsqwy/

Can you simplify / create a minimal test case and post a link to a new fiddle?
 To better simulate the same thing @varungupta85 is doing, just change the `src` to the same file. You'll see the same behavior. But using an html document will work correctly.

It appears that Chrome isn't firing the load event and is just initiating a file download. It's unclear which behavior is actually correct or if we can do anything about this.
 AFAIK, there is nothing actionable here.  Assuming I'm understanding the comment correctly, this is browser behavior, and there isn't anything on our end.
  PS, thanks for coming in and helping out with the Windows stuff! I don't know if you can tell but uhhh we don't have a lot of people doing that :)
 @tbroadley updated the pull request.
 Awesome, thanks!
  I haven't been following along with some of this refs stuff but this seems sane to me. @spicyj?
  Hi, sorry I messed up your PR with my changes before we got a chance to review this.

I think it might be planned to actually do the DOM operations more aggressively. I think @sebmarkbage mentioned this in one of the recent issues but I can‚Äôt find where exactly. On the other hand, if this impacts performance (https://github.com/facebook/react/issues/5295#issuecomment-151687767), it‚Äôs not good, and I agree we should fix it.

If you were to resurrect this fix, the test would probably need to go [in this file](https://github.com/facebook/react/blob/master/src/isomorphic/devtools/__tests__/ReactNativeOperationHistoryDevtool-test.js).
 @tbroadley Might be worth waiting until after https://github.com/facebook/react/pull/6406 merges, as I suspect there might be merge conflicts.  Just don't want you to have to do the work twice :).
  Thanks!
  We have observed substantial increases in developer happiness+productivity with JSX and believe the benefits outweigh the downsides of extending Javascript.  JSX is optional and you're free to use pure ES5 if that is your preference.

I'm going to close out this bug, since deprecating jsx is not something we're likely to do in the foreseeable future, but feel free to continue the discussion here.
  cc @zpao @spicyj, seems bad.
 Fix incoming. Worth noting (as @spicyj reminded me) that this is only an issue in dev mode.
 Yea sorry about the issues, we'll be shipping 0.14.2 tomorrow with this fixed.
 All elements.
  Did 0.14.0 cause issues? We did make 1 change around the defineProperty usage in 0.14.1 but it shouldn't have resulted in issues.

Let us know what you find!
 Related‚Ä¶ https://github.com/facebook/react/issues/5324.

I think at least part of the issue is that we changed how we check for the ability to use defineProperty. es5-sham explicitly supports the simple use of defineProperty but throws when trying to set a getter. Previously our try/catch used a getter, so we were treating es5-sham the right way. We simplified some code and removed the getter in 0.14.1. That is almost certainly what's causing this issue, though perhaps there is another.
  While the docs claim it is necessary, it doesn‚Äôt appear to be in my testing. I can put a single child conditionally inside `ReactTransitionGroup` and animate its (un)mounting without assigning a specific key to it. Is that not the case in your testing? Perhaps we should amend the docs.
  Yeah, this behavior does seem more correct to me, and the PR looks good.

I'll leave the PR open for a day or two so everyone gets a chance to take a look and raise any red flags before we merge.
 cc @sebmarkbage What level of support are we giving this inheritance pattern?
 I got the idea from other threads that we are "strongly encouraging composition over inheritance", but will generally make a best-effort attempt to have composition work reasonably.
 @drdelambre updated the pull request.
 Ok, looks good!  Thanks @drdelambre
 No, we should revert this. This pattern only works for the initial set of props. It doesn't work for updates. So you end up violating an important invariant for React.
 @drdelambre I was in the process of filing https://github.com/facebook/react/issues/5335 to add a warning as you were writing this comment.
 When a property isn't defined?  `getDefaultProps` happens before props is available: https://facebook.github.io/react/docs/component-specs.html#getdefaultprops
 Right, `getDefaultProps` is cached anyway.  Even with the function variant, if you return a complex type, all instances of the component will share the same instance.

You can think of getDefaultProps as a static function on a Java class, if that's helpful to you.  Or as an immutable public static final global.  It is used to specify the "defaults" and is completely independent of instances.  It is generally used to specify intelligent defaults for a component configuration, not to initialize state (that's what `getInitialState()` does).

Props and state are intentionally separate.  See: https://facebook.github.io/react/tips/props-in-getInitialState-as-anti-pattern.html
 The `getDefaultProps` name is just there for legacy reasons. Could be `statics: { defaultProps: ... } }`
  Are you sure you're not just confused by javascript's string escape character?

This string contains only a single slash:

```
var str = '\/';
console.log(str);
```

This string contains two characters:

```
var str = '\\/';
console.log(str);
```

If you believe that you've found a bug in React, please provide a simple testcase / jsfiddle that demonstrates your issue, we can investigate further.  Otherwise, please note that we use github issues to track bugs in the React core; usage questions are better addressed on other sites.
  I don't think there is enough information here for us to debug.  Keep in mind that we try to use github issues to track bugs in React.  Usage questions are better answered on StackOverflow.  If you believe there is a bug in the React core, please provide a simplified testcase/jsfiddle that demonstrates the issue and we can dig further.
 Sounds like maybe you weren't binding functions properly or something.  Sounds like a usage question which are better addressed on other sites.  If you believe this is a bug in the React core, let us know, and please provide a simplified jsfiddle that demonstrates the issue.
 It's not binding. It's probably an issue of timing. I don't know what your Dialog component looks like but it probably has its own render root (calls ReactDOM.render, probably in show()), resulting in the ref resolution not being timed quite right because they don't exist until the end of the event loop, which is why `setTimeout` works.

You might be able to take advantage of the callback that render takes to thread a callback through show()

eg: `show(cb) { ReactDOM.render(whatever, cb) }`
  Thanks!

According to grammar-monster (http://www.grammar-monster.com/lessons/an_or_a.htm):

> Abbreviations that start with the consonants F, H, L, M, N, R, S, and X attract an because they start with vowel sounds.
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 Looks good, thanks!
  Can you elaborate on what you mean by "accessibility API"?  Where are you seeing the wrong value?  Is the issue that the screen reader is verbally reading off the wrong value?

cc @spicyj Maybe the screen reader is looking at the attribute instead of the property?
 A fiddle for my own sanity, and @spicyj's convenience:  https://jsfiddle.net/b4pe8jhn/
 Your fiddle calls setState from within render, which is against the rules.  I updated the fiddle.

https://jsfiddle.net/kqfvafuk/

Based on your latest description, are you thinking that it's a bug in React or a bug in Firefox?  I'm still not entirely clear on how we can best reproduce the issue / see what value is being supplied by the accessibility API.
 I can confirm that internal state of the internal state of the firefox combobox appears to be inconsistent when the value is set from javascript, and inconsistent with what is visually displayed; this appears to be a bug in firefox and is independent of the screen readers.

I can also confirm that it doesn't matter if we use attributes or properties; the inconsistency in firefox appears to be persistent.

I can also confirm that the combobox behavior differs from user expectations given what is visually rendered.  Realistically though, this is looking like a bug in Firefox and I don't see anything actionable on our end, unless someone sees a workaround.
 Perhaps someone (maybe @zpao) can ping the appropriate person at mozilla.
 Ok, I found a workaround.  It appears that setting `a.selected = true` is insufficient but that setting  `a.selected = false; a.selected = true` does work.  Fiddle: https://jsfiddle.net/otgxg4av/

Pure speculation based on zero knowledge of firefox code: this leads me to believe/suspect that Firefox is trying to be fancy and bail out of a change if the value is unchanged, but their cached value is incorrect and thus they erroneously bail out.  I filed a bug with mozilla (https://bugzilla.mozilla.org/show_bug.cgi?id=1219825) though I don't have the time to follow it closely.

Anyway, we now have a potential workaround.  #goodfirstbug.
 @ezufelt I think there are minor differences in what you observe and what I observe.  Possibly because I'm on FF 41 (not latest) or possibly because you have a screen reader.  But either way, I think the description is sufficient to be actionable.  You might want to put your additional info into the bugzilla report.
 Ultimately it looks like this boils down to a Firefox bug that doesn't affect just React so I'm not sure how much we should do in React. If somebody comes along and wants to pick this up, let's make sure we should do anything before you start.

Firefox, like Chrome and others, doesn't commit the visual change until enter is pressed. However, because Chrome pops the options into a new view which you can't dismiss without committing or canceling, it can't get stuck in an inconsistent visual state. The goal of all of this is probably to not fire a change event on every key stroke here, simulating what the event stream would look like if interacting with a mouse (you don't select every intermediate value).

Thanks everybody for the report and tracking it down, getting a bug filed in Bugzilla.
  Proptypes are mostly legacy and in maintenance mode, having been replaced by tools like Flow.  My guess is we aren't going to change this, but @zpao can decide if the issue should be closed.
 @pke If you don't want to use flow, there are a few other options:
- you can use another static analysis or type checking tool (like typescript).
- you can do as javascript programmers have done for a long time - go without typechecks.
- you can check proptypes manually in your components (constructor / componentWillReceiveProps).
- you can write your own proptype validators as we did for React (ideally as a library, and/or share those validators with others who may also find them valuable).
- you can continue using proptypes as-is, since we aren't getting rid of them in the immediate future (though they are likely on their way out as other tools like Flow start to become more complete).
  Good first bug, diff should include a unit test to verify we don't regress this again in the future.
 Currently, I think setState is ignored (ie. a no-op) if invoked during a constructor.  Assuming we keep the same behavior, we would just display a different error message.

Tracking "what is the correct behavior" in https://github.com/facebook/react/issues/5342.
 @acdlite Not too many, I hope.  We're trying to get rid of `owner` in the core.

Yeah, a `ReactCurrentRender` module sounds like as good an approach as any.  I don't think it actually makes the `owner` situation any worse.  cc @spicyj for ideas.
 I have a todo list document outlining all the uses of ReactCurrentOwner and alternatives that I want to replace it with. Basically, isCurrentlyRendering that is only set in `__DEV__` because they're all used for warnings.
 ReactCurrentOwner, and subsequently `_owner`, should only be used for string refs and nothing else. When we eventually deprecate string refs, it will be gone completely.
 Thanks! (Tip: If you write "Fixes #5313." in your commit message then the issue gets closed automatically when the PR is merged.)
  Yep, sounds like another reason to include renderToString on ReactDOM.  This is also causing problems for testing (on jsfiddle), ClojureScript, bower distribution, etc.
 Just as for a browser, you can use browserify to create a bundle that Nashorn will understand.
 @JaRail I'm not sure what you mean, but no, there's nothing actionable here.
 React doesn't use require internally so I don't think that would make much sense. I'm hopeful that people who write a `require()` call and immediately see that it doesn't work will realize that they need a module loader.
 You should use a module bundler like browserify to make a single bundle that you can load, much like people do when using React from npm and sending the result to a browser. It sounds like something like jvm-npm might work too.
 Most people using React are targeting a browser, which also doesn't support `require` natively. We highly recommend using a CommonJS system like browserify/webpack/etc to manage your assets regardless of what platform you're targeting.

> I mean if you grab the bundled version of ReactDOM, ReactDOMServer is already in there. It's just not exposed. That's very silly actually isn't it? This bundle contains code that can never be used...

This is true in the current release but will not be true in future versions.
  Just added in #5304. It will be a part of 0.14.1
  As per conversation with @sebmarkbage, it would be cool if React emitted events that allowed any attached devtools to listen for relevant events occurring in the core.  The emitted events could be just descriptive enough that devtools could track whatever internal state it wants.  For instance, a devtool could track perf by seeing how long various operations are taking (marked by start and end of the operation).  Or a devtool could emit useful warnings (all our core warnings could be rolled into a devtools module/package, and by tracking state internally we could avoid routing the only-useful-for-warnings data throughout the core).

Anyway, the following are relevant:
- [ ] https://github.com/facebook/react/issues/5302 - User wants to emit custom warnings when potentially slow operations are executed during render.
- [ ] https://github.com/facebook/react/issues/4302 - Users want to clear warnings for unit testing and/or hot-reloading
- [ ] https://github.com/facebook/react/issues/5254 - Users want to track/monitor calls to `shouldComponentUpdate` and get statistics on the results.  Gather other per-component statistics like number of setState calls and renders.
- [ ] https://github.com/facebook/react/issues/5924 - Users want to fail unit tests when specific warnings fire, like an invalid checksum warning.
- [ ] https://github.com/facebook/react/issues/6239 - User wants to render errors using a pluggable logging framework.
  There were a number of approaches presented there. Yet another is to just do everything as JSX, assuming 'First' and 'Second' are there to demonstrate "dynamic" content:

``` js
<div>{'First '}<span>&middot;</span>{' Second'}</div>
```

While yes, a warning is not ideal (and I'm actually a little surprised there is a warning, cc @spicyj), the goal is to demonstrate how you can begin to solve the specific issue of entities in dynamic content with as little code as possible. I'm ok with there being a warning in simple code snippets if it gets the point across without having to then explain other things.
 @zpao Sorry, why wouldn't there be a warning?
 text, <span>, text - which yes renders down to all the same things but I thought our warning about keys only looked at arrays of the same type or something (since you don't actually need keys when they are different types). But looks like we warned in 0.13 so meh.
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 Thanks!
  Sounds like a really good use case for the new devtools API to support.
  It's time. Let's do it.

I don't think anything left open on the milestone list is enough to block but if fixes come in we'll take 'em.
- https://github.com/facebook/react/pull/5081
- https://github.com/facebook/react/pull/5085
- https://github.com/facebook/react/pull/5164
- https://github.com/facebook/react/pull/5157
- https://github.com/facebook/react/pull/5166
- https://github.com/facebook/react/pull/5174
- https://github.com/facebook/react/pull/5263
- https://github.com/facebook/react/pull/5250
- https://github.com/facebook/react/pull/5297
- https://github.com/facebook/react/pull/5237
- https://github.com/facebook/react/pull/5304

---

Changelog (could probably be cleaned up a little bit, maybe organized differently):
### React DOM
- Fixed bug where events wouldn't fire in old browsers when using React in development mode
- Fixed bug preventing use of `dangerouslySetInnerHTML` with Closure Compiler Advanced Mode
- Added support for `srcLang`, `default`, and `kind` attributes for `<track>` elements
- Added support for `color` attribute
- Ensured legacy `.props` access on DOM nodes is updated on re-renders
### React Test Utils Add-on
- Fixed `scryRenderedDOMComponentsWithClass` so it works with SVG
### React Transition Group Add-on
- Fix bug preventing `0` to be used as a timeout value
### React on Bower
- Added `react-dom.js` to `main` to improve compatibility with tooling

---
- [x] cherry-pick the commits
- [x] finalize changelog
- [x] ship it
- [ ] update fiddles
 Good catch, got closed after I started making the list.
 Will update the fiddles and whatnot soon but in the mean time, go forth. http://facebook.github.io/react/blog/2015/10/28/react-v0.14.1.html
  Thank you for submitting the PR!

The downside of this is that the rendered element no longer uses the `children` we pass to it directly. This may break other people‚Äôs tests that rely on referential identity, e.g. when people do something like `expect(result.props.children).toBe(element.props.children)` (rather than `toEqual`). I‚Äôm not sure which pattern is more common.
 An alternative solution would be to hide `_owner` from being enumerable. I submitted a PR that does this in #6355. If there are no issues with this approach, I think it would be a simpler fix that wouldn‚Äôt affect other scenarios negatively. Thank you for getting this rolling!
 I fixed this in a slightly different way in #6362 so that we avoid having `_owner` in the test environment in the first place. Thank you very much for taking time to contribute!
  `is` means something in HTML, that the element is inheriting from another element. This is a part of the custom elements / web components spec. https://developer.mozilla.org/en-US/docs/Web/Web_Components/Custom_Elements. See more discussion in https://github.com/facebook/react/issues/4933.

I think the right move for that library is either to remove the `is` prop (though that could be risky as `is` is has a valid use in the DOM) or use a prefix such that you know you aren't reusing a prop that has valid use in the DOM. You'd run the same risk if you were using `title` for example - making it mean something special for a specific library isn't awesome (we run the same risk with `key`, `ref`, and `children` fwiw).
 (since the rest of this overlaps with the other issue, I'm just going to close out)
  @quadrupleslap updated the pull request.
 Thanks! (and thanks for the review @syranide!). We'll put this into 0.14.1.
  This should have been fixed in 0.14.3.
 Verified that the user's code is still throwing using 0.14.3

http://jsfiddle.net/fk7dey0u/ (the user's fiddle is using react-dom-0.14.0, not that it matters)
 I think we fixed a different variant of this.
 @lovedota @re6exp It looks like you are hitting an error because the `done()` callback is called three times because you are animating three `td` elements. If you refactor your code to only call `done()` once, it will work better.

We should be more resilient to this behavior in ReactTransitionGroup though so that the original code you have also works.
  I'm seeing the same thing. Interesting.

cc @spicyj Could something have changed with the unwrapping of the special DOM components?
 Ah, yes. Before, we were enqueueing a force update of the component which wouldn't run twice if it had already updated; now we call ReactDOMInput.updateWrapper directly in forceUpdateIfMounted so it can happen twice. Not sure the simplest fix. At least this shouldn't make a practical difference‚Ä¶
 Not sure if I'm doing something wrong, but that example is perfectly responsive for me.
  > A common type of React component is one that extends a basic HTML element in a simple way.

Your example doesn't demonstrate that - it's just passes everything along with no extension. I'm inclined to just keep what we have, even if it is more contrived than a donkey's ass.
 No hard feelings üòÄ

You're right, the docs are not great and the examples don't always help. We know but we haven't had a chance to properly deal with it. For the most part our docs are pretty much how they were written 2.5 years ago and at that point the way we told our story was different. New docs and changes have come in piecemeal and often written by different people, not with a cohesive voice.

We've slowly been thinking about how we can rewrite the docs but it's not a small time investment and we've had some other things to do so it hasn't been high priority.

---

Now back to that particular example‚Ä¶

The point of it is that you're wrapping a DOM component with some more data. In this case what's happening is that instead of just passing the children straight through, you make the children a checkbox and then the provided children. That's the only modification happening here. Yes, it's contrived. It could be made less so with less unicode.

``` js
<CheckLink href="github.com" id="baz">foo<CheckLink>
```

Gets rendered into the DOM as

``` html
<a href="github.com" id="baz">‚àö foo</a>
```

Again, just prepending a "check mark" (which yes, isn't actually a check mark) to the content of an anchor.

Anything else is not super easy. Eg, if you wanted to add a className, you actually should make sure it gets combined with the existing one if it was provided and then the point of the example gets lost in the supporting code.

``` js
render() {
  var {className, ...otherProps} = this.props
  className = [className, 'my-default-class'].join(' ');
  return <a className={className} {...props} />
}
```

Ok, but why did we join like that and not just `+ ' my-default-class'`? Also what's that other `...` syntax? It looks the same but it's different‚Ä¶

And then we're explaining all the things that are not the most important thing here, which is that you can pass along props with a small modification _in the simple case_.

Sorry to write so much, docs are a frustrating topic because we know they're bad but making them better is a big effort. Finding the right level of detail to explain things to a broad audience is tricky (we get a lot of requests across our projects for pure ES5 examples because they aren't writing _any_ ES6, so assuming people are familiar with new syntax is not a given).

---

So could we take your example and do something to it to make it fit into the goal? yup. Would it be less contrived? maybe. You probably want a default class on it like I wrote up above. Or inline styles which is a similar exercise. To get the point of the text across you need to add _something_. Maybe an `alt` attribute would be fine? It would wipe out a provided `alt` attribute but people are bad at accessibility so meh. Hopefully the goal of this is clearer and that gives you the perspective to make this a better example üòÄ
 Just going to leave as is for now unless you want to come back to it. We'll plan to make examples better in a docs overhaul in the future though.
  @chicoxyzzy updated the pull request.
 @chicoxyzzy updated the pull request.
 Thanks!
  This should be fixed by #6362.
  Can you combine your multiple edits to this file into a single pull request?
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 @jonathanp updated the pull request.
 Thanks!
  > In 0.14, do we have to explicitly define displayName in each component?

That will depend on you compiling toolchain. By default you should not need to specify it when using Babel, though there may be some cases that aren't handled.
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 We actually aren't affiliated with Reactive, could you drop that? (As much as we'd like to have every conference with React content on here, it's not something we want to maintain right now)

And for ReactEurope, it looks like they have their dates nailed down to June 2 & 3, can you update that?
 Talked with @zpao, let's keep Reactive ‚Äì mind updating the dates for React Europe though?
 @benhalpern updated the pull request.
 Thanks!
  I think I initially didn't do this because I wasn't sure if there were other parts of the tutorial that would need to be updated as a result. But it's probably mostly ok. Thanks!
  Can you provide a test case, what you did, what you expected to happen, and what actually happened. Otherwise we can't determine if there is a bug in React as we have nothing to go on. Thanks
 Looks like this is likely the same issue as #5153, which we have a fix for going out when we ship 0.14.1, which should happen in the next day or so.
  I'm not up to date with what the interaction is supposed to be with the shallow renderer these days so cc @spicyj ‚Ä¶

But when you use the shallow renderer you aren't working on a real rendered tree. `TestUtils.Simulate.click(output.props.children[1])` especially doesn't look like it should work - remember that props are not rendered output. `props.children[1]` will be a React Element, not a component instance.

So as your test case seems to be written, yes this is expected.
 That's expected. We should probably give a better error message ‚Äì changing this issue title to reflect that.
 The docs/ directory has markdown files that turn into the website. Each page should also have an "Edit on GitHub" button at the top that links you straight to it.

In the ReactTestUtils.js file, you could add an invariant that makes sure React.isValidElement returns false on the passed-in node.
  > react-dom includes react as a child dependency.

As far as I understand it; yeah it should be a peer dependency (cc @zpao ?). But dependencies are not _child dependencies_ that's simply a result of how NPM2 unfortunately resolves version issues, so peer dependency is preferable, but a regular dependency is not wrong, you just have to be careful to avoid multiple installations.
 It can happen quite stealthily when updating/etc in NPM2. I ran into the same issue recently.

I'll reopen this for now because it really seems to me that it should be a peer dependency.
 It probably should be a peerDep. I don't remember why I put it as a regular dep there‚Ä¶ (I did addons-\* with React as a peerDep).
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 I think we'll leave this one as is for now. We're planning a docs overhaul in the near future and we'll try to be consistent with how we describe this dynamic content. Thanks though, I appreciate the effort!
  Could you report this over in the devtools project? Thanks! https://github.com/facebook/react-devtools
  Can you give a complete standalone test case that isn't working. We haven't had any other reports of `onClick` not working in 0.14.

Or is this is exclusively about the dev tools not showing the right thing?
 @LucioFranco Can you could provide a testcase/jsfiddle that demonstrates the issue?
  Numeric keys can be used correctly. For example, an `id` field on your model that comes from a unique autoinc column in you database. That's fine. The problem is usually that people use the index of an array (eg in a `for` loop). Those will be unique but they won't be stable.

The discussion you linked to is actually about a tangential topic, which is for a pattern we no longer support in React (where you could pass an object as your child and we'd use the object keys as keys in React - numbers caused issues due to how they are treated in key enumeration order).

I'm going to close out since specifying non-numeric here isn't actually correct. I hope I cleared it up for you!
 @christopherbalz See the last bullet point at the bottom of the page.  Also, we're clarifying it even further in https://github.com/facebook/react/pull/5403.
  `keyOf({__html: null})` should be the correct approach and this indeed seems like a bug to me. Do you want to submit a PR for it?

cc @zpao @spicyj 
 Fixed with #5297.
  Good catch, thanks!
  Sounds like you need to require whatever "dom" is. That's nothing we officially support so you'll want to work it out with whatever provided that.

Also, you really shouldn't export factories. Those aren't compatible with others who decide to use creatElement.
 Closing since dom is not a thing made by us.
  I'm curious, could it not make sense for Immutable.js to have an alternative `map` function that returns a regular object/Map instead? Seems like it could be used as a performance optimization.
  @AnuragRamdasan dude what's the +1 for :) I gave an update saying "my bad, I needed to pull in the correct dependency and all was good"
 @gaearon my fault if I sounded like a scumbag troll - totally venting from my 2014 experiences w/ React (if I'm honest about it). In the last month, my experience has been totally different as you stated. All good now :)
 @AnuragRamdasan ah yes -to that point lets keep this issue open :)

I almost forgot (as it took nearly 1 full month to get a response from anyone) 
  What did you do to see this error?
 It has been a month with no response, closing.
  Thanks!
 Cherry-picked to 0.14 - e0f74c6c6c8b84a14db96a70e4a00162aafef356
  @zertosh updated the pull request.
 @zertosh updated the pull request.
 @zertosh updated the pull request.
 @zertosh updated the pull request.
 cc @nickdima.

@zertosh - is this something you're going to continue working on? I think @nickdima had also started so I'd like to make sure we aren't wasting anybody's time‚Ä¶
 No activity in a couple of months, all checks failed, merge conflicts.  I'm going to close this out.  We can re-examine if/when the PR is in a better state.
  Yeah, we can't really do anything better here. You can set `.selectionStart` and `.selectionEnd` on the DOM node manually.
  @gfogle updated the pull request.
 @gfogle updated the pull request.
 @gfogle updated the pull request.
 @gfogle updated the pull request.
 @gfogle updated the pull request.
 @gfogle updated the pull request.
 @gfogle updated the pull request.
 We've just recently started work on a new perf tool. #6046 

This will allow us to do refactoring to the code base without breaking the perf tools all the time. Could you maybe check if your issue can be solved in #6046? Sorry for the inconvenience. We didn't plan for this new tool to replace the old one at this point.
  Thanks for the detailed write-up. I get where you're coming from on the naming but I think we're unlikely to change this in the short term. As we flesh out the direction we're heading with multiple renderers and third-party rendering, we'll see where we end up.
 Thanks for the great discussion!

The name `server` kind of makes sense, since everyone calls the most common usage/technique `server-side-rendering (SSR)`.  Although it can be used on the client side, that's far less common, and no name will be both completely generalized and completely precise (specific/meaningful).  I'm going to close this out, because there is nothing actionable at the moment, but we can continue bikeshedding here and reopen if/when a name change seems imminent.
  Your assumption is a good succinct way to explain. The other reason we advise caution is that ReactLink has the downside of hiding the two-way binding so it becomes really easy to get stuck with harder-to-diagnose behavior. We'll likely move support for ReactLink out of core soon and move it into user land.
  @romainneutron updated the pull request.
 Hm. We should probably introduce some sort of `id` property here. We shouldn't use the text of the message. I could see arguing for skipping over this and leaving the warning, but understanding `key` is fundamental to using React effectively so we should probably work it in properly.

@zpao What do you think?
 Yea, we really should have ids, I was just looking at this - looks like this warning has been around in the tutorial here for a while but in our finished product we use array index. https://github.com/reactjs/react-tutorial/blame/master/public/scripts/example.js#L87

We could make the servers generate ids, maybe be really dumb and use timestamps? Or we could change the format so it's like an autoinc column and store the last id (`{id: 5, data: [{id: 1, name: 'Pete' ...}]}`). API endpoint still works identically just has an extra id field.

As for this PR‚Ä¶ let's keep it focused on the tutorial and not make changes to any other pieces of documentation. Not clear what we'll change it to yet though.
 The problem with index is that if a comment gets added/deleted from anywhere except the end, the indexes all shift.  It works, but is perhaps not the best practice.  Normally you would want to use a commentId of some sort.  Just using `index` sends a suboptimal message.  Anyway, I'll let @spicyj and @zpao make the final call here.
 The problem is that if we just use `index` and add a note saying "actually, this is wrong, don't do this", that's almost worse than not saying anything and leaving it as a warning (user is still equally confused about what they **should** do, and we haven't actually made the code any better).  Adding real IDs means that the example becomes unnecessarily complex and the ID logic is distracting.  That's why we're not entirely sure how to fix this, and why it might be ok to leave this as a warning and let people learn about keys later.
 We're going to add real ids. See my in-progress update in the tutorial repo - the changes to the actual code here is pretty minimal. https://github.com/reactjs/react-tutorial/pull/96/files#diff-43fd6de5aa6bfed98ce8f78b5494a419R47
 Thanks for the PR and sparking a good discussion. It was a bit easier for me to make the changes in both places and coordinate any updates so I have #5444. As a result I'm going to close this out. Thanks again!
  There is no such plan for `update()`. You can use `$apply` to apply a custom function that would do what you describe. Alternatively you can use https://github.com/kolodny/immutability-helper which has the same basic API but also lets you define custom operations. I hope this helps!
  Correct behavior is to change the property as it does, **not** the attribute. The attribute only indicates the initially selected option. The attribute is also correctly set for the initially selected option. This sounds like a bug with `getFirstSelectedOption` unless I'm misunderstanding something.
 @StJohn3D Please try 15.0.2, it might contain the fix you need. If not, please create an example reproducing the issue. 
 Your first example is missing the `value` attribute on the `option`. From [the documentation](https://facebook.github.io/react/docs/forms.html), this is the correct usage:

``` js
  <select value="B">
    <option value="A">Apple</option>
    <option value="B">Banana</option>
    <option value="C">Cranberry</option>
  </select>
```

Otherwise React thinks none of them have `value`s, so it can‚Äôt match your `select`‚Äôs `value` to any of the `option`s.
 Hmm, or maybe I‚Äôm wrong. Perhaps #5362 should fix it?
 This is still a bug probably so let‚Äôs keep it open until #5362 gets merged.
  #6046 is going to offer much more granular stats so I‚Äôm closing this issue in its favor.
  ~~This doesn't apply to older IE?~~ Reading fail.
 Curious, any rough benchmarks to share?
 @spicyj updated the pull request.
 I haven't benchmarked React with this, but it looked 2-3x faster in my tests that @iamdustan linked (for just the DOM time). Note that this is compared to the existing document.createElement mode which is still behind a flag, not against HTML generation. My goal is to be at parity with the current HTML approach. From my benchmarks, createElement is still slower in IE8 but is faster in IE9+, which we're willing to live with.
  The automatic updating really sucks here as bugs are fixed / behavior of rules changes. Local versions are updated, cached versions on Travis aren't. It's messy. Now we must explicitly update for any thing to change.
 No but I definitely see that every once in a while when using eslint inside Atom.
  React does a shallow copy of props so you don't maintain the prototype. So `manifests` in your ctor is not `===` what you're passing to createElement. You're better off passing it as a single prop, eg `{manifests: manifests}`.

I've seen this pop up once or twice but can't find an issue where we've answered this before so I guess this might be it. I'm going to close out because I think we intend to continue with this behavior but cc @spicyj who might be able to back me up.
 Yes, @zpao's right here. We have to inspect the object you pass to pull off `key` and `ref` if they're provided.
  Great, thanks!
  You could write your code more generically or request the data at a higher level and pass it in so the List component stays dumb.

In the future, please post questions like this on stack overflow or elsewhere. GitHub issues is not a support forum but is used for tracking bugs and improvements to React itself.
  This sounds like a bug.
 Yes, as @yiminghe said, optimizing context is hard.  You can't bail out with a `!internalInstance.hasOwnProperty("_context")` check because the DOM component may have children which are composite components; such a check would lead to erroneous behavior.  To avoid reconciling the DOM nodes, we would need to save the previous context on the internal instance (ie. `_context`), which we can't do if most DOM nodes are going to become stateless components.  There might be some fancy magic we could do if we knew that none of the deep children were composites and/or if we utilized some glimmer-like diffing, but I think that's out of scope of this issue.

Anyway, the decision to not skip DOM components was an intentional one.  Not a bug.

We can leave this issue open for a few days to see if anyone has ideas/solutions, or if @sebmarkbage (or others) wants to jump in.
 I bumped into this when hand-optimizing `connect()` from [React Redux](https://github.com/rackt/react-redux/blob/master/src/components/connect.js). In the end I used a combination of constant element and `shouldComponentUpdate` to do the optimization I wanted.
  At the very least would need to be rebased to fix the travis build error.
 @spicyj @sebmarkbage 
 Can you add a test case? Otherwise this looks fine.
 @neelance updated the pull request.
 If you expect the state update to go through, can you make sure the test covers that (by checking the children on the returned element)?
  kind and srcLang were added recently in https://github.com/facebook/react/pull/5174. They'll be a part of a future release (likely 0.14.1). I didn't see default then though so I guess we still need to add that.
 Related to #140
  There may be something we're doing that is causing this. I opened #5258 to track.
  React Native is in a different repo so you may want to discuss your issues there: https://github.com/facebook/react-native
  Unfortunately some of the addons use internals of React which aren't exposed in the browser build so this isn't really possible for us. We recommend consuming the addons from npm so you have control over exactly what gets bundled. #5388 sounds doable though.
 Oooh, webjars; that's pretty fancy :).
  @gaearon yea, but that still means integrating node into your workflow. I think the ask is more about separating the minification part from the prod/dev split. And honesty I've thought about doing this for a while, making it clearer that `react.min.js` is not simply `react.js` minified (which is a different pattern than a lot of libs).

```
react.dev.js
react.dev.min.js
react.prod.js
react.prod.min.js
```

But apart from making it clearer for people who are inadvertently using the dev build in prod, I'm not sure what the real wins are. Minifiying an already minified lib isn't ideal but it should be harmless.

@jochenberger could you explain _why_ this would be helpful?
  https://github.com/facebook/react/issues/5240 was fixed in another commit.  This one is failing lint, and hasn't seen any activity in months.  I'm going to close it out.  Let me know if there is a reason to still merge this one and we can re-consider.
  I think #5391 fixed this.
 Not sure when we're planning a 0.14.3. Is this a regression in 0.14? I didn't realize that.
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 Thanks, but this is correct as is since `this.handleAdd` will already be autobound when using `React.createClass`.
  Closes #5125 -- incorporates essentially the same fix with a much simpler test case. Thanks @yiminghe for reporting!
 Your test case already passes with my code here. You can see that in my test case I tested both the case that the type changes (and you get a new instance) and when it doesn't. The public instance for an internal instance never changes, at least with our current design.
 @spicyj updated the pull request.
  :+1: 
 :+1: 
 I'll merge this over to the site tomorrow with a couple other things. Thanks!
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 The original wording was correct.  It DOES change over time as users modify those fields, and thus IS state.

You quoted Question 2, but left off the most critical part of Question 2.

> Does it change over time? **If not, it probably isn't state.**
  This seems good to me. Thanks!

cc @jimfb for a quick sanity check
 Looks good to me, thanks @davidkpiano!
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 Thanks!
  Switching to prod mode isn't a great long term solution. Luckily, we fixed this already and will ship that fix in 0.14.1 - see #5157
  This sounds like a really specific problem to your setup and we can't help you without code. I'm fairly certain this isn't a bug with React so I'm inclined to say you should start this as a question on Stack Overflow or somewhere and come back when/if you think you have found a bug with React (and have specific steps to reproduce). Feel free to link to your SO post and maybe somebody paying attention here will help you there.
 What's your package.json look like? What version of react & react-dom did you install? We have a ton of code that looks like what you posted and it runs fine.
 Something with packaging is probably going wonky and you might have multiple Reacts or something. If you can make a standalone example (maybe in a repo or gist) then I could probably help track it down further. Keep an eye out for errors in the console too. But otherwise there's not much to go on, sorry. Good luck.
 @bazo Many users (including all of facebook.com) have upgraded to 0.14 without a problem.  We are unable to reproduce your problem.  If you think you've found a bug in React, please provide the simplest possible testcase that demonstrates the issue.  Without a valid repro, there is very little more that we could do.
 @jimfb that's not true entirely... A test case was provided we just didn't have enough information about the full environment. The last part of this, Firebug not playing nicely, was reported recently. My money is on it being something Babel related but haven't had a chance to look into it, and I don't really care so much about Firebug these days so it's not super high priority.

@bazo, thanks for hunting it down further. I'm not sure what we'll end up doing about this but I filed #5258 to start tracking (this issue here has a bit too much noise to be a valuable place for people to land).
  > Is there some sort of issue when the test utils won't have access to the correct React instance if they are not bundled together?

Potentially. You're essentially doing bundle splitting and would need your packager to know that React/ReactDOM is already available. There are docs around the internet on how to do that with webpack and browserify. The other concern might be if you're running in dev or prod mode (NODE_ENV=production). I'm not sure if all of our testing utils will end up working in prod mode.
 I wouldn't expect it since react-addons-\* just require deeply into the react package, as does react-dom (_for now_). But I've definitely seen some unexpected cases of multiple Reacts.
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 Yes, this is correct as written for v0.14. I appreciate the initiative though!
 Good catch. I just updated step 5 to remove those calls.
  This might be red herring due to the way the browser represents markup. We improved the way the message works in 0.14. Could you test there and see if you get a different message.
  #1387 is probably the best place to follow along with this ongoing discussion.
  This sounds like a usage questions.  We use github issues for tracking bugs in the React core, so I'm going to close out this issue to take it off our radar.  Feel free to continue the discussion on this thread or move it to another site.
 There is nothing specific to React in this question - this is a general npm issue. You should try to hoist your dependencies to the app level and run npm install from there. Trying to explicitly install things inside folders in node_modules is going to be a nightmare. You should ask for help on [Stack Overflow](http://stackoverflow.com/questions/tagged/npm) or some other place.
  Generally squash and force-push is preferred but we're not consistently sticklers.
 @jadekler updated the pull request.
 @jadekler updated the pull request.
 Local lint is right, I think CI dependency caching screws things up (or more likely since our dep is a `^`, it doesn't upgrade the cached version unless we explicitly bump our dep). I bet if I clear caches and re-run your build it fails. I'm going to do a couple linting changes in the next couple days so hopefully it locks down better after that. In the meantime, sorry for the churn :(
 Hey @jadekler, sorry to do this to you but I merged another PR that also fixed the lint issues since it was updated and the failures on travis were annoying (that's what I get for clearing the cache üò¢). I'd love to still take the other style changes if you rebase though.
 It's been a couple weeks without a response so I'm going to close out. Feel free to reopen / make a new PR with the stylistic changes if you come back to this.
  > The interesting thing to note about pure function components is that (2) no longer applies to them.

I think this is inaccurate.  Stateless components themselves don't have `this.state`, but stateless components may have stateful children which is mathematically the same as having a `this.state` themselves.
 Meh, pretty sure this is a dead end and not worth pursuing.
  @nLight Can you update as per @Prinzhorn 

@spicyj This PR has been open for nearly two weeks.  Any objections to us merging?
 It's not even done yet.
 @nLight Ping.  Would love to get this in.
 @nLight updated the pull request.
 @nLight updated the pull request.
 Looks good to me.  I'll leave it open for a day so everyone has a chance to see this before merging.
 The code points U+10000 and beyond are represented in UCS-2 as two Unicode characters:

![image](https://cloud.githubusercontent.com/assets/6820/11074807/910f0d24-87a6-11e5-9544-7c90c84401ed.png)

See https://mathiasbynens.be/notes/javascript-encoding for more details. I think you should be able to test that emoji in attributes like "data-üòä" works. I don't think your current code works with this. If you can't get this to work properly, I would be okay dropping the `\u10000-\uEFFFF` range (since it doesn't work like this) and adding a TODO to handle surrogate pairs.
 Well now I'm really confused. I did not expect

```
/^[\u10000-\uEFFFF]*$/.exec('üòä')
```

to match anything‚Ä¶
 Yes, mine does that too. That's why I'm confused. But @zpao is confused about why you're not hitting this check:

https://github.com/facebook/react/blob/d6a547f7934edce9ea411d681c94357cd6842939/src/renderers/dom/shared/DOMPropertyOperations.js#L23-L45
 `<p {...{'data-üò¨': seconds}}>{message}</p>` will trigger that warning. It seems like it only occurs for updates, which your test didn't trigger.
 Ugg, this is why I wish we didn't have to do our own validation.

Ok, sounds to me like the next step is to write two unit tests (one for a div, one for a custom-component) which performs initial render and an update render, verify no warnings are emitted.  That will likely include expanding the whitelist that @spicyj and @zpao mentioned.
 Good with me.
 @nLight updated the pull request.
 @nLight updated the pull request.
 @nLight updated the pull request.
 Ok, this looks good to me.  @spicyj Any comments?  If not, let's leave it open for another day and then we can merge.
 I'm fine with this if @jimfb wants to merge.
 Looks good, thanks everyone!  I know this one had a bunch of back and forth, but you did a great job @nLight, Thanks!
  No, there are no plans for this. We generally suggest a static type checker, like flow, for things like that.
  üëç
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 cc @gaearon - I'm going to put you in charge of making sure anything else that isn't normal/hyphenated works :)

cf. #5714
 This will "just work" after #5714.
Everything that's not on our list will just pass through as is so I think we can safely close this.
 Verified that `startOffset` is passed through in the master.
 > I'm using "react": "^0.14.3".

This is fixed in master, but that master refers to v15 release.
It‚Äôs going to drop very soon so stay tuned!

Cheers.
  @antoaravinth Looks like there is a failing unit test.  Also, we should add a unit test that asserts the intended semantics.

@spicyj is probably the best person to review this PR, since he added the processing of event handlers to printDOM() in the first place.
 I would just not instrument putListener/deleteListener at all.
 Yes, we can remove that test.
 @antoaravinth updated the pull request.
 @antoaravinth updated the pull request.
 Just remove the instrumentation from EventPluginHub entirely ‚Äì we don't need it any more.
 Sorry for the back and forth.
 Can you reference #5189 in your new test case too? It would also be fine to combine them into one test, I think ‚Äì but two is fine too if you prefer that.
 @antoaravinth Yes, that's right ‚Äì all that code can go away.
 @antoaravinth updated the pull request.
 Thanks!
  Please read our documentation about forms: https://facebook.github.io/react/docs/forms.html.

Filing issues here if you don't get a response on Stack Overflow isn't awesome, please avoid doing it in the future.
  You probably want to unmock React and it's dependencies in your jest config. See the config example in the React tutorial: http://facebook.github.io/jest/docs/tutorial-react.html#setup
  Now that #5714 is merged, all attributes on SVG elements will be passed through as is, with no need for the whitelist. Thanks for the PR though!
  Builds on #5190. So... ignore the first 10 commits.
 @spicyj updated the pull request.
 @spicyj updated the pull request.
 Good luck!
 @spicyj updated the pull request.
 Good question. I think this should probably be fine alongside 0.14 but didn't test.
  @quicksnap If you need to do something with the output, you can just render into a div.

```
var container = document.createElement('div');
ReactDOM.render(<MyComponent><Child id='foo' /></MyComponent>, container);
```

This is basically all that `renderIntoDocument` does anyway.

For future reference, this is a usage question, rather than a bug in the React core. Usage questions are better answered on sites like StackOverflow, as we try to use github issues for tracking bugs in the React core. For this reason, I'm going to close out this issue, but feel free to continue the conversation here or move it to StackOverflow.
  Thanks!
  I haven't looked at it, but that sounds reasonable to me.
 Fixed via https://github.com/facebook/react/pull/6226
 As discussed in #6226 and as @mxstbr noted above, adding them explicitly probably wasn‚Äôt the right call after all.

We already support `onFocus` and `onBlur` in a cross-browser way, and we should tell people to use them instead. Internally they [already use `focusin` and `focusout` on IE which implements the bubbling behavior](https://github.com/facebook/react/blob/c3b7f937b062a0afbdd404ba5ada51043a753808/src/renderers/dom/client/ReactBrowserEventEmitter.js#L300-L313).

We should probably consider adding a warning that tells you to use `onFocus` if you attempt to define `onFocusIn`.
  @samerbuna is correct. It was never an official api,just an internal runtime dependency, so the removal never was included in any change logs.

Fwiw, the key mirror use in that tutorial is completely extraneous - simply assuming values to the constants is enough.
  Glitter looks like a startup clone of Slack.  Similar features, better pricing model, etc.

My intuition is that we don't want to do this, but I'll leave the issue open for a few days to collect feedback.  My reasoning is: Having too many underutilized communication channels is substantially less valuable than having a few very concentrated/active communication channels.  It's just one more thing for us to setup/maintain/etc.

Maybe @spicyj has thoughts.
 If we really need we can open up gitter but let's give discord a chance.
  Bind generates a new function, so it's not going to be triple equals equal.  I'm not sure how we can get around this.

The good news is: from a performance perspective, we do not actually update the DOM node when a callback function changes.  We do some fancy magic internally to call the correct event handler when the event is processed.

Have you been running into performance problems due to bound functions?
 Personally I use a special PureRenderMixin:ish base class that ignores functions when comparing prev/next, far from perfect, but works well enough.

@jimfb The problem is that if every component you create receives a bound function, then _all_ components will re-render every time.
 @syranide Yeah, I agree, but...

> Bind generates a new function, so it's not going to be triple equals equal. I'm not sure how we can get around this.

Do you have any ideas?
 @jimfb WeakMap seems like the best near-term solution, but it's a bit cumbersome to use for this for something that should be trivial (or JS getting its shit together and offering better utilities for comparison).
 @ccorcos You'll have to make sure to always bind the same function and arguments, if something needs to be dynamic you'll have to bind a local method which holds the logic instead.
 This is a great discussion, but I'm not seeing any actionable react-core bugs in this thread (unless I missed something, let me know and we can re-open).  For this reason, I'm going to close the issue, since it's not an actionable bug in the React core.  However, I encourage you guys to continue the discussion in this thread, or move it to StackOverflow / discuss.reactjs.org / reactiflux.com / whatever.
 @ccorcos Is there an actionable feature here?  As far as I can tell, there is nothing actionable within the core.  Anything that could be done can be an external addon (we're not adding more addons to the repository; eventually we'd like to get them all into separate repositories).  Anyway, let me know if there is something that we can/should do in the core to make this better.  Otherwise, let's solve this outside the core.
  This is not enough information for this issue to be actionable.  Furthermore, it sounds like a usage question.  Usage questions should be asked on StackOverflow, as we use github issues to track bugs in the React core.  I'm going to close out this issue.

If you believe there is a bug in React, please create a simple testcase (jsfiddle) that demonstrates the issue and we can look into it.
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 Sure, thanks!
  #5154
 Merged #5154 so this should work now.
  @conorhastings updated the pull request.
 Thanks @conorhastings, this looks great!

In javascript most things are objects (so this protects against `string` and `number` but not much else).  It probably makes sense to put the keys in parenthesis.  So the message becomes: `...with a callback of type object (keys: foo, bar, noise)`.  If you want to be fancy, we wouldn't print the keys if there are none or if there are more than 20 of them.
 @conorhastings updated the pull request.
 @conorhastings updated the pull request.
 @conorhastings updated the pull request.
 @conorhastings Yep, that looks great!  Thanks!
  @line-o updated the pull request.
 @line-o updated the pull request.
 This happened in #5174 (along with other attributes for `<track>`) and was shipped with 0.14.1. Thanks though and sorry for not getting back to you sooner!
  New module! With this, we have a new module that uses the component tree to store DOM nodes. Most of the logic in this file relates to markup adoption -- if we were to drop that (along with server rendering) this file could just be a `return inst._nativeNode;`.

This works with useCreateElement only because we need to reference each node as it's created.

Events is now the only thing using hierarchical IDs and `ReactMount.getNode` -- I'll use `ReactDOMComponentTree.getInstanceFromNode` to make that work.
 @spicyj updated the pull request.
 @spicyj updated the pull request.
 @spicyj updated the pull request.
 Getting rid of hierarchical IDs (replacing them with numbers, probably) and the giant hash map we have in ReactMount. We can probably kill data-reactid entirely when not using server-side rendering.
 @spicyj My hope is that we can kill `data-reactid` entirely **especially** when using server-side rendering.  Rehydrating a markup tree does not benefit from having `data-reactid` afik.
 @jimfb I'm operating under the assumption that browser extensions will insert extra nodes into our markup and we need to skip over them.
 Make sure you do your react-native homework
 > My hope is that we can kill data-reactid entirely especially when using server-side rendering. Rehydrating a markup tree does not benefit from having data-reactid afik.

@jimfb FYI, we can already kill data-reactid for server-rendered markup, it's rather trivial as long as you're ok with doing a fast pass over all the nodes once when starting the client.
 @spicyj updated the pull request.
 We can do that trivially here too by changing precacheChildNodes to not look at IDs and just match up the nodes ‚Äì but I'm worried about finding extra nodes.
 @spicyj We can always mark the nodes with just `data-react`, but leave out the ID. That should give you most of the benefits, while also tolerating foreign nodes. Personally I think we should just be super strict and simply not allow unexpected nodes, they are crashes waiting to happen.
 That's true, but I don't think including a numeric ID (`data-reactid="17"`) is much overhead over that.
 > Personally I think we should just be super strict and simply not allow unexpected nodes, they are crashes waiting to happen.

I tend to agree - if we find an unexpected node while restoring a SSR DOM tree, we can just kill it with fire.  We don't even need a flag on the nodes to do that.
 > That's true, but I don't think including a numeric ID (data-reactid="17") is much overhead over that.

@spicyj `data-react` compresses trivially to virtually nothing, but yeah the overhead of the ID should be minimal too. Both are miles better than the current reactids anyway.
 @spicyj updated the pull request.
 @jimfb @sebmarkbage The last two commits (edit: more by the time you read this, start with the one called "Events:") add events support so we don't rely on hierarchical IDs for events either. (Sorry for piling it all into the same PR ‚Äì but github sucks at stacking PRs and I didn't want to merge this to master quite yet.) Either of you want to take a look? I'm a little nervous but all the FB test flows worked the first time with this applied.
 @spicyj updated the pull request.
 Did a quick benchmark of rendering [a PE-like hierarchy](https://gist.github.com/spicyj/36f063272e4849c0e0a3) with Electron (Chrome) with a cold and warm JIT using my perf-counters as the timestamp.

With a warm JIT (rendering the hierarchy 100 times before measuring anything):

This PR is 3.3% faster than master.
Switching to numerical IDs (will be a separate PR, not quite done yet) brings us to 7.9% faster than master.
Numerical IDs with createElement instead of HTML generation is on par (also 7.9%).
Numerical IDs with createElement and not setting `data-reactid` at all (since we don't need it) gives another 1.4% boost for a total of 9.1%.

With a cold JIT, createElement looks a little bit slower (but this PR helps more compared to master!).

Our deltas of
[3.3%, 7.9%, 7.9%, 9.1%] with a warm JIT are
[4.9%, 9.6%, 8.3%, 8.9%] with a cold JIT.

Not sure if there are things we can do to improve the speed of createElement.
 @spicyj Just for context, I assume those are React rendering times + `innerHTML` but do not include browser rendering/painting? PS. Also that's awesome :)
 ```
var a = now();
React.render(React.createElement(Benchmark), container);
container.offsetHeight;
var b = now();
```

There's probably some painting involved. I intentionally forced layout: I wanted to make sure all the markup was parsed to make sure the HTML mode wasn't doing stuff lazily. Any ideas on how to keep that guarantee while avoiding painting (and layout)?
 @spicyj I'd assume that would just force layouting, realistically rendering/painting should only happen after JS execution ends. I'm pretty sure `innerHTML` is not deferred as you can measure differences in time by the number of tags/attributes/styles/etc present. It probably doesn't really make sense to defer it in practice either I would think.
 You're probably right. I tried it again without the forced layout and it's about 24ms (on master: 210ms vs 186ms) faster on all five numbers, so the percentages are proportionally the same but go up a little because of a smaller base. Cold JIT, just React.render (no layout): [5.5%, 10.8%, 9.2%, 10.0%].
 Numerical IDs are in #5205. Also, devtools don't work with this because they currently rely on `ReactMount.getNode`.
 @spicyj updated the pull request.
 Merged in #5205.
  @STRML Can you provide a simplified jsfiddle which demonstrates the issue (too many putlisteners) so we can take a look.
 Yea, this looks like the workaround for removing the tap delay. cc @spicyj 
 This all appears to be expected behavior to me. When you pass a different function instance that counts as a change. Maybe we should ignore event listeners? Those updates are usually less costly and are often no-ops.
 Yeah, if interacting with the DOM is slow, we could probably set a callback proxy that, when invoked, reads the actual handler off the internal instance.  Then "updates" due to a `bind` in render would not result in a call to the DOM.
 These already don't actually interact with the DOM.
 If they don't interact with the DOM, then it seems erroneous to have them print in 

```
Perf.printDOM(measurements)
Prints the underlying DOM manipulations, e.g. "set innerHTML" and "remove".
```
 I mean, that method lists every other side effect of returning a new element from `render`. Perhaps it's technically incorrect.
 Ok, TLDR: 

Conceptually the DOM is changing due to the `render` which creates a new function via `bind()`.  Under the hood, React does fancy magic that avoids actually flushing those changes to the DOM.  This makes the "expected behavior" of `Perf.printDOM` a little ambiguous.

In practice, the 97% use case is probably binds (rather than someone swapping out an event handler, which would be possible but slightly unusual).  In the interest of making ReactPerf "useful" rather than "correct" @spicyj and I are in agreement that it **probably** makes sense to suppress logging updates to the event handlers if/when the previous value and new value are both functions.
 Fixed in https://github.com/facebook/react/pull/5209
 I haven‚Äôt dived into how printDOM() or event dispatching works so I can‚Äôt say.
Interested in conclusions too.
 @1000hz 

The fix from #5209 was merged into master and not into the 0.14 branch. [The calls are still there in 0.14](https://github.com/facebook/react/blob/88543cec199c48df77a61a2d6e24eeb69ae10431/src/renderers/dom/client/ReactBrowserEventEmitter.js#L377-L380). This is why you‚Äôre seeing them.

Give 15.0 RC2 a try. It should contain the relevant fix.
  StackOverflow is the best place for these usage questions since we use github issues to track bugs in the core.  In the interest of keeping all the conversation in one place, let's redirect this discussion to your StackOverflow post (http://stackoverflow.com/questions/33157904/how-to-avoid-loaded-two-copies-of-react-error-when-developing-an-external-comp) that you made a couple hours ago.
  I don't see anything wrong here; looks good to me.  @tomduncalf Did you test it manually in a browser to verify it works?  It is possible to write tests that fire mocked events, but honestly it's pretty fragile.
 Ok, looks good to me.  Thanks @tomduncalf!
  ReactDOM is another file in the `react` package for Bower.

`<script src="/bower_components/react/react-dom.js"></script>`
 Looks like we can just add react-dom to main and that should do it. https://github.com/reactjs/react-bower/pull/15
  This upgrades all expectations of `invariant`'s error message to exclude the "Invariant Violation: " prefix when facebook/fbjs#71 lands.
 Otherwise, üëç. I'll coordinate the landing of this with however we version fbjs.
 @yungsters updated the pull request.
 Template strings would screw with indentation of the code ‚Äî shrugs.
 You can use whatever you want :) But I think we'll leave them as is.
 @yungsters updated the pull request.
  Yea, this automocking stuff is now more annoying‚Ä¶ yayyyy. I tend to have more issues with automocking than gains from not using it, so my first move is pretty much always to just disable it for everything. This isn't going to be React specific - anybody who had disabled mocking for a dependency with dependencies will have problems - but will definitely be part of the story of testing React. It's probably worth bringing up in the jest repo so it's on people's radar. I'll bug @cpojer about it too :P

> Or more immediately react could not depend on fbjs and just use it's own keymirror implementation.

keyMirror is only 1 of the things that got moved to fbjs. We'd have to move a bunch of things back into the react repo and that's really unlikely.
 Can we just kill keyMirror? We don't need it at all.
 That can be a separate discussion. keyMirror is a symptom here but the root of this issue is jest + npm.
 I agree this situation is really annoying. I don't have a good solution for this yet and I would recommend for the React team to provide a list of modules that should not be mocked until we come up with something good. Sorry for the trouble.
 Yea, we should make this a jest issue but with a React specific work-around - unmock react and fbjs, and hopefully don't use any dependencies of fbjs. Basically anytime you unmock something you need to walk down it's deps and unmock all of those or you're in potential trouble.
 @justinwyllie Personally I suggest either unmocking everything or downgrading to npm2. Unfortunately we don't have the time to play whack-a-mole.
 This will be fixed in jest 0.8.0 or 0.8.1 towards the end of the year. I have a clear solution in mind but I need to make sure it will work out fine.
 I recommend adding all of the modules from here: https://github.com/react-bootstrap/react-bootstrap/blob/master/package.json#L114 to your unmock patterns.
 Not yet! I have a fix that I need to add tests for and tests for performance. It will definitely be fixed with the final 0.9 though :)
 I'll publish a new version of `jest-cli@next` (0.9 pre-release) that fixes this issue today.
 Jest 0.9.0 was published along with a complete overhaul of the website: facebook.github.io/jest/ This problem should not be an issue again :)
  It all depends on the specifics of your application.  Ultimately if performance is an issue, you should run your own perf tests to figure out which option is the fastest for your app.

In general, the first option should be faster.  Additionally, the first option is preferred because it keeps component state attached to the current component.  If you shift IDs as in your second example, not only do you have to update every DOM node... you are also re-mapping existing components (and their internal data) to new values.  Suppose the user inputs text in item D's text box (`{id:3,t:'D'}`), and you push a new item to the end, the text would now appear in item E's text box (`{id:4,t:'E'}`) which is not what you would want.

If you are ever unsure, you almost certainly want the first option.

This is a usage question, and we try to keep github issues for tracking bugs in the React core, so I'm going to close this out.  Please ask usage questions on StackOverflow in the future.
  @stepancar We can't see your MyComponent implementation, but I suspect @titoBouzout is correct and has answered your issue.

Either way, this sounds like a usage question rather than a bug in the React core.  We're trying to keep github issues to track bugs in the React core, so I'm going to close out this issue.  Usage questions are better answered on StackOverflow.  Feel free to continue the discussion on this thread.
 @stepancar I wonder if you are mixing up custom elements with custom components.  Custom elements (like `<my-custom-element data-test-id="foo" />`) should work as you described.  Custom components (like `<MyCustomComponent data-test-id="foo" />`) do not necessarily have any markup associated with them, and can do arbitrary things with their props.
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 We're going to leave this as is to reduce the number of things people need to learn. The "browser" code still needs to be packaged with something like browserify or webpack to work so we're not using native `import`.
  There's not a lot for anybody to go from here to be helpful. I suggest working this out on stack overflow until you can narrow it down to a case that you think indicates a bug in React. And when you have that, please provide a test case so that we can try to diagnose. I'm going to close out in the meantime.

A quick suggestion: turn on "break on caught exceptions", which will throw you into the debugger on React warnings. Go back up the stack for that createElement warning. That's a big red flag to me. You may be using a factory in JSX, or have a require that failed to resolve.
  defaultChecked is never updated, only used on initial render. It could be that your component is never unmounted due to the usage of react-router so the second render is really an update, not a completely new instance.

In the future, please use other places like Stack Overflow for specific use case issues. Only come here when you have a test case indicating a bug in React. Good luck!
 Paul is correct, usage questions should be asked on StackOverflow, as we try to keep github issues for tracking bugs in the core.

@DWboutin Depending on what you're trying to do, you might find that the `value` prop works better than `defaultValue`.  Of course, you'll have to specify a change listener, as that would make your component controlled.  https://facebook.github.io/react/docs/forms.html#why-controlled-components
  Well, the typecheck happens with that exact typecheck, just not directly in forceupdate. Here's forceUpdate: https://github.com/facebook/react/blob/master/src/renderers/shared/reconciler/ReactUpdateQueue.js#L109-L114 and where the invariant happens: https://github.com/facebook/react/blob/master/src/renderers/shared/reconciler/ReactUpdateQueue.js#L109-L114

FWIW, `this.forceUpdate.bind(this)` is not the same as `() => this.forceUpdate()` due to an important distinction. The former makes a new function that is bound but it will pass along any arguments. The latter also is a new function but it explicitly doesn't pass any arguments. So the former gets the event passed along while the latter just drops it. The event isn't callable, thus the invariant.

We need to do the typecheck so I guess we could discuss whether we keep it as an invariant or a warning. But it is a misuse of the API.
 To follow up on that, the more "equal" thing would be:

``` javascript
window.addEventListener(
  'resize',
  (e) => this.forceUpdate(e)
);
```

Which should throw the same error that you see with your first bind example.
  cc @yungsters - any input from the Relay side of things? Presumably this is handled there in some way.
 @zpao In Relay, no one uses default prop values.

Props with accompanying GraphQL fragments are completely managed by Relay. If applications want to default to a value (e.g. if a field happens to be `null`), they need to do that in `render()`.

If you think about it, arbitrary fields in GraphQL can be `null`. What makes the record that happens to be passed into a React component as a prop any more special than a field that happens to be nested inside that prop? (In other words, if we're going to apply default prop values to props, why not apply them to arbitrary tree paths in the GraphQL object?)
 Closing as per @yungsters answer, which seems perfectly reasonable.  I don't think there is anything we could reasonably do here; current relay+prop behavior seems correct.
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 Now that #5714 is merged, all attributes on SVG elements will be passed through as is, with no need for the whitelist. Thanks for the PR though!
  I'm pretty sure that was an intentional/conscious decision.  Test utils aren't supposed to be used in production.  They aren't optimized for performance.  They exist to make it easy for you to test your code and debug in dev mode.  If you really need them, you can always create a custom bundle of React.
 Yep, it's long been the case. It's not well documented but we do call it out on http://facebook.github.io/react/docs/addons.html
  It's part of the React package. https://github.com/reactjs/react-bower/blob/master/react-dom.js
  @zpao I ran into this also.  Having a browser version of `renderToString` is super useful for debugging purposes if nothing else.  I tend to think we should just put it on ReactDOM; does it really add enough bloat that we feel the need to take it off ReactDOM?
 I have mixed feelings (and also, see #5134). I've also found it useful but entirely for debugging which isn't a great argument. It's also not hard to create your own bundle.

ReactDOM corresponds to `require('react-dom')` so putting it on there directly won't happen. Maybe we can make a `ReactDOMServer` bundle. Or something awkward to make it obvious.
 We added react-dom-server.js to bower in 0.14.3
  Looks good, can you squash the multiple commits into a single commit?
 Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 No, you can use `git rebase` to combine commits (known as "squashing"). https://github.com/ginatrapani/todo.txt-android/wiki/Squash-All-Commits-Related-to-a-Single-Issue-into-a-Single-Commit gives a pretty succinct explanation in the context of pull requests. http://eli.thegreenplace.net/2014/02/19/squashing-github-pull-requests-into-a-single-commit also explains well.
  cc @cpojer, @RReverser ‚Äì is this clearer?
 :+1: we should probably update the README in react-codemod to explain changes for different versions.
  I think you can say something like `if(typeof ReactDOM === 'undefined') ReactDOM = React`.  Then you can use ReactDOM, which will sometimes be backed by the old version, right?

I think that will work - and you can do this in your library code, so users don't need to do anything fancy with their build configuration.
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 @spicyj @zpao 
 This is probably ok, but we're currently sticking to 2.x for ourselves (there are issues in other projects - see https://github.com/facebook/relay/issues/396 as an example). I'll do some testing for React.
 Ok, we'll do this. It seems to work fine for now but we may run into issues and clamp it down. Thanks for taking it on.
  @spicyj @sebmarkbage 
 Hm. That's unfortunate. I guess we'll try to find a feature test for this and patch it.
  We should match the DOM and fire it on the element (not the form). We already have support for these events which don't bubble. Most of our events are added at the document level and then delegated but the ones which don't bubble need to be added to specific elements on creation. Here's how we're doing it for forms and the submit & reset events: https://github.com/facebook/react/blob/master/src/renderers/dom/shared/ReactDOMComponent.js#L403-L416

Thanks for taking this on! Feel free to get a PR up before it's completely ready if you have questions / need help.
  Haven't seen that before - Have you done a git pull to latest? (ie. presumably it's still failing today?)  What version of node are you running?  What operating system?
 Interesting.  We don't support building on node 0.10.25.  I'm actually a little surprised you were able to do an npm install of the React repository.

I just ran the tests ten times on my Linux machine (`Linux ubuntu 3.16.0-37-generic #51~14.04.1-Ubuntu SMP Wed May 6 15:23:14 UTC 2015 x86_64 x86_64 x86_64 GNU/Linux`, node v4.2.0) and was unable to repro the issue.

@jalejos Can you upgrade your version of node to v4.2.0 and let me know if you're still able to reproduce the issue?
 @spicyj any ideas?  This is a mystery to me.

Is anyone else able to reproduce the issue?
 No idea.
 @jalejos At this point, I'm not sure what we can do to fix.  This is the first I've heard of the issue, and I'm unable to reproduce.  If you get a chance to investigate, I'd be super curious to hear what you discover.
  That's just a case not well explained in the docs. We don't traverse into nested ReactElements, only into nested arrays and (previously) object literals.

``` js
var nested = [
  [<span />, <a />]
  <div />
];
<form>
  <div>
    <span>Username</span>
    <input type="text" />
  </div>

  <input type="password" />
  {nested}
</form>
```

That's what's meant by nested children. We would traverse into `nested` and pull out the span, anchor, and div. We won't traverse into your literal div's children as those aren't children of the form but of the div.
  We will not be adding this to addons, we're actually trying to stop having these things bundled with React. You are encouraged to release this as a standalone package.
  Fixes #5132 so people can build on Windows. This is only necessary until we switch entirely to gulp (#4927).

Note: I haven't actually tested this on Windows but https://nodejs.org/api/process.html#process_process_platform implies this should be correct. It still works on OS X so we're no worse off regardless.
 Weird. Okay.
  @jimbolla This is a usage question rather than a bug in the React core.  We use github issues for tracking bugs in the React core.  Usage questions are better answered on StackOverflow.  Since this is not a bug in the React core, I'm going to close this issue.  Feel free to continue the discussion on this thread.
 `PropTypes.node` isn't correct but there isn't a great type for this as it could be one of a number of things. A simple function (for stateless functional components), a `class` which is also a function (which we're making required to extend React.Component), or a React Class which is also a function. Since _any_ function can be passed here, that's the closest type you'll get. Further, since any function can be valid, we can't accurately check what the return value will be. This is where a static type checker will come in handy.
 `PropTypes.oneOfType([React.PropTypes.string, React.PropTypes.func])`

This also captures the native element case (eg `"div"`).
  Thanks, just the one nit ‚Äì do you mind squashing your commits too?
 Thanks!
  Ok, thanks!
  :+1: lgtm, @spicyj 
 We need to do this with a warning for a release to give people the chance to upgrade their code.
 Yeah. It's a little tricky because ideally you want to also log the containing component and you don't want to log thousands of times so some sort of deduplication is needed (probably based on the component name and CSS property).
 You can change the API for CSSPropertyOperations to pass in the necessary context if that's helpful.
 @pluma We probably wouldn't want to expando on DOM nodes.  You could use ReactInstanceMap which is currently implemented as an expando on internal components.  Or it would probably be sufficient to warn once per style-key (ie. just create an object and set `object[styleKey] = true` if you've already warned for that style).  That would mean that fixing the warning in one component could result in a similar warning starting to be emitted from another component that has the same bug, but that is probably acceptable (@spicyj to confirm).
 @pluma You're right, looks like it is just using expando; so if you wanted to use instances, you could do something in the same vein.  Or just do a single object of css keys; I don't have a strong preference.
cc @spicyj incase he has a preference.
 @pluma updated the pull request.
 Instead of doing it per component instance, can you deduplicate based on component name? Most of our existing warnings do that already. Sorry that wasn't clear. In most cases you can get `._currentElement._owner.getName()` which will be the component that created it. Rendering one component 20 times shouldn't make 20 warnings in the console.
 @pluma Ben is suggesting that you call `component._currentElement._owner.getName()` to get the NAME of the current component (the name will be a string) and use the name of the component as part of your object-key for deduplication.
 See, for example, ReactElementValidator:

https://github.com/facebook/react/blob/51c0f86ec7f596c1514956665c5637689055ed1b/src/isomorphic/classic/element/ReactElementValidator.js#L104-L106

It is true that this makes a small memory leak but it shouldn't be an issue in practice because it grows with the size of your code and doesn't grow as you render more components repeatedly (and is dev mode only).
 @pluma updated the pull request.
 @pluma updated the pull request.
 @pluma I found a couple more things.  Sorry for all the churn on this diff, but it is looking good now :).  I think we're close!

Also, you'll want to squash all the commits into a single commit before we merge.  You can use `git rebase -i HEAD^^^^^^` to assist in squashing the commits and then do a `git push -f` to override the branch rather than adding new commits to it.
 @pluma updated the pull request.
 @pluma updated the pull request.
 @pluma Na, you don't need to create a PR for 0.16 yet.  The PR would just get old / we would forget about it / there would be merge conflicts / etc.  Once we're getting close to the 0.15 release date (you'll know because we will create a 0.15 umbrella issue and start checking things off) then we can start generating PRs for 0.16.

I think the only two remaining changes for this PR (in 0.15) are:
- We should not warn unless the string value specified is a unitless number in the form of a string.  That is to say: it parses as an integer, as oppose to being something like `5px` or `5em`.
- We should not append 'px' unless it is a unitless number.  This is a non-breaking change (so we can add it now) because previously it would have resulted in something like `5pxpx` or `5empx` which would have made no sense.
 Ah, got it!  Looks good to me.
 @pluma Thanks again!
 > We have styles such as margin: '0' or top: '0' throughout our codebase - shouldn't the warning be skipped for zero values?

Yes, this was merged, just isn‚Äôt out yet. See https://github.com/facebook/react/pull/6458.
  @yaycmyk Sounds right to me, thanks for answering!

@Volodymyr128 This is a usage question rather than a bug in the React core. We use github issues for tracking bugs in the React core. Usage questions are better answered on StackOverflow. Since this is not a bug in the React core, I'm going to close this issue. Feel free to continue the discussion on this thread.
 warningDialog is probably not the problem. We give you the keys (status, data, operationId, correlationId) so that the real callsite is easier to find.
 We want to be able to treat an object as if it were a react element, which would allow a JSX transform to transform to objects directly instead of React.createElement function calls. We can't do that well if objects also have other meaning.
  cc @sebmarkbage 
 The `Symbol` solution ensures that multiple npm packages or instances of React can coordinate the same identity seamlessly. Even across realms. None of the proposals here address that concern. (It also makes us compatible with a theoretical future Value Types proposals.)

If React can coordinate with multiple versions of itself, then Babel can as well.

One possible solution would be that Babel depends on a module that exposes this or somehow opts out of inlining the polyfill so that it gets the same fallback as React itself.
 How does this work with `Symbol.iterator` which is also a shared symbol that need to be handled the same way between `for...of` and library code?
 The inlining is only part of the story. The point is to decouple this from the React package itself and not needing that dependency.

I think you're missing the point though. The point is to explore a generic solution around nominal branding. E.g. for Polyfilling pattern matching. Not just for React's particular value type but any number of similar data structures. That's why we wouldn't use `Infinity` because only one library can use that trick and then it is used forever.

There is also a larger issue about how polyfills should work across these boundaries. I suspect that this partial polyfilling solution is the thing that is broken and will break down in more ways than this particular case. Others will have similar problems. `Symbol.for` is a feature that library authors should be able to use. Therefore the transpile/polyfills story should be fixed.

It is not obvious to me why React's fallback is different from other feature tests that is standard practice. E.g. we also use `var assign = Object.assign || function() { /* internal polyfill */ }`. It is obviously not the problem with feature testing per say. It is that there is global identity required so it needs to be the same polyfill.

What would be the best way to polyfill `Symbol.iterator` in library code? E.g. both React and immutable-js check for the string `"@@iterator"` as a possible property name. Why doesn't this cause the same problem? https://github.com/facebook/immutable-js/blob/d94141223d56ac5bd6f541b06baa3161c4edd01b/dist/immutable.js#L185

A similar problem would occur with anything that requires global state. The spec has intentionally tried to avoid global state but for example the Zones proposal would have a similar requirement. I suppose that when you have global state, you really need to have a shared object reference and a global polyfill is the only solution. So, maybe global polyfills should be best practice?
 I'm hoping that we will be able to find a way to share objects across the `postMessage` API. Between workers or even cross-origin. Part of that would be to allow symbols to transfer between these workers.

If the `toStringTag` is shared across workers then this is `object[Symbol.toStringTag] === 'ReactElement'` spoofable. However, the same is true if `Symbol.for` shares identity so maybe neither should share identity. There is a lot more research needed for this space.

I admit that this is a long shot and many pieces need to fit together but something to consider.

In the meantime, the way I read this is there are three variables:

1) Using global polyfills everywhere or only local polyfills.
2) Using `Symbol.for('react.element')` as a branding strategy.
3) Using `Symbol.iterator` to detect iterability.

If you use local polyfills, then both 2 and 3 breaks and your code is broken. So we have to fix something.

a) If we fix only 2, then 3 still breaks and your code is broken.
b) If we fix both 2 and 3, by changing how `Symbol.iterator` works then your code works.
c) If we avoid the use of local polyfills and ensure that everyone uses global polyfills, then both 2 and 3 work fine.

Option A doesn't fix anything so it is not very helpful.

Option B won't work unless we can change how all libraries do this feature detection of `Symbol.iterator`, or if we can change the specification. Neither seems realistic.

Option C seems the most plausible to me. If we manage to fix Option C there is no point in changing how React works.

Are there any other options?
 The idea is that they would not work across `postMessage` _by default_ - unless you explicitly provided a way to share the symbol.
  Thanks!  Seems good.  There are a couple of lint failures to fix.  You can check for lint errors by running `grunt eslint`
 We already fixed the warning in SyntheticEvent.js, if you rebase that warning should go away.

This looks good.  Can you squash the two commits into a single commit and then I think we'll be ready to merge.
 @vipulnsward updated the pull request.
 Thanks @vipulnsward!
  React 0.14 generates XML-compatible markup #2842
 Whether or not it's technically valid, this works in all browsers that I know of and (IIRC) gets around some other issues that crop up when using the attribute name as value.
  In any event, this is very unlikely an issue in React. If you're still having trouble, try asking on Stack Overflow.
  > Should I just have my own Webpack/Browserify bundle?

I think that's best.
  This regression was unintentional.
  Thanks for the heads up by the way. You should be able to build now but let us know if you encounter other issues! Nobody on the team is currently building on Windows so I wouldn't be surprised to see a couple more things like this pop up.
  It's a bit quirky but intended behavior, you're effectively providing a new ref-callback every time it renders. So to safely dispose of the old ref-callback React calls it with `null` and then the new ref-callback will be called with the instance. Store and re-use your ref-callback and this goes away.
 The docs say this too.
  I'd rather go with argsForCall which was already the predominant style. It's easiest to type.
 We can do argsForCall.length too if you like.
 @matiassingers Thank you! Would you be interested in adding a lint rule for this? We have a couple custom rules already.
  Thanks.
  @brigand I think that's actually unrelated in this instance.

@localnerve I meant "custom component" to be synonymous with "composite component". We don't actually support rendering `html` except with server rendering because browsers all behave differently, and renderIntoDocument simply renders the component into a div. Sorry for the trouble‚Ä¶
 Shallow rendering should work, or you could try to render to string and then create a new document with that HTML ‚Äì the exact details of that will depend on how you're running your tests.
 Oh, I missed that this was a regression. I'll look into what this is to see if it's fixable for a point release.
 Can you paste an example of what your tests look like?
 Unfortunately I don't think our public API supports that right now. :\
 @localnerve The issue here is nothing with findRenderedDOMComponentWithTag, but that renderIntoDocument creates a div and you can't render an HTML tag inside a div. Not sure why there isn't a HTML nesting warning for that at the moment. You can do something like this which creates a new iframe with the given HTML:

https://jsbin.com/qeyifedave/1/edit?html,js,console

Hope that helps.
  We still support IE8 so this unfortunately won't work. Thanks for the initiative!
  Thanks. There are a handful of places where trailing whitespace is important but I think those are contained to a couple blog posts.
  So the callback is getting called with the TopLevelWrapper as context? Yes, that's wrong. Not sure if this is the best fix but we can make sure that a fix for this gets into 0.14.1.

Thanks for reporting @yiminghe!
 @yiminghe updated the pull request.
  Looks great! Would you mind squashing the commits?
 Thanks!
  Ultimately I want to get rid of that page but this is a nice quick fix. Thanks!
  Not Linux specific; broken in all browsers / operating systems.  This is probably a good first bug if someone wants to submit a pull request.
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Looks good, thanks!  Once the CLA is signed, we'll be ready to merge.
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 Great, thanks!
  This works fine for me if I run your code through the Babel repl (after fixing the arrow function in you property initializer and extending React.Component)
 Original code + transformed: http://bit.ly/1NwaP7S
Then run: https://jsfiddle.net/hz9dr8qw/1/
 Ok, at this point, it's sounding like it's not a bug in React, so I'm going to close out this issue.  I'm curious to hear what actually went wrong here.  If it turns out to be React's fault, we can re-open the issue.
  Ah! That's what the lingering "I'm forgetting something" feeling was. Thanks for the reminder. I pushed be90351add34c2a47328a2b7a0786c5c00d991c8 to update (and will update the `0.14-stable` branch in a moment)
  Good catch. If anybody wants to grab it, let us know. Otherwise we'll get to it very soon.
  This is correct as-is.
  Fixes #580.
  Can you run `npm ls` and paste the output?
 You shouldn't have a react inside of react-dom. I'm not sure why it's there, but if you `rm -rf node_modules/react-dom/node_modules/react/` your problem should be fixed. You should also not have an extra copy of `react` inside `react-masonry-component`.
  Thanks!
  I think we want to provide most or all of those things and will keep them in mind as we update the docs but this issue isn't super actionable so I'm going to close it. Thanks for the suggestion!
  I think the old wording was also correct (in order to save typing, you want to copy all of them instead of listing manually which to copy) but this is clearer; thanks.
  @zpao @spicyj 
 Done.
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 Sure, can you squash these two commits into a single commit?
 Looks good, thanks!
 Bah, this isn't the website and didn't need to get merged to stable‚Ä¶
  Thanks!
  We only want to show this warning if React added the span automatically. That validation happens here:

https://github.com/facebook/react/blob/3f5747009d83c72176f320ce34486043b0534050/src/renderers/dom/shared/ReactDOMTextComponent.js#L75

Also, it isn't necessarily whitespace (`<table>hello<tbody/></table>` would also make a `table > span`) so we shouldn't say that it is in that case.
 It appears that this was fixed by #5753 so I‚Äôm closing. Thank you for the PR!
  I think the only thing we could do is warn if you call setState in componentDidUpdate (which I think we know about). But there are valid use cases when done with care and it would be pretty annoying for those.
 We could warn if you do more than a few nested updates. Even if it's not an infinite loop it's probably slow and should be avoided.
  Thanks!
  Can you make this change against `master` (https://github.com/facebook/react/blob/master/docs/_posts/2015-10-07-react-v0.14.md). The `gh-pages` branch is automatically generated.
  Sounds like a valid issue; I don't think that was intended.
 Yes, a pull request would be very much appreciated :).
 @maxlapshin What browser/device are you using?  Also, can you provide a simple test case / jsfiddle?
 Closing until then ‚Äì if you repro feel free to comment here and we can reopen.
  This is not nearly enough information for me to have a hope of helping you. If you are still having a problem, please post a simple repro case in jsbin or jsfiddle that shows the problem, including what behavior you expected and what you see instead.
  @thomasp9 updated the pull request.
 Squashed and merged. @thomasp9 Thanks!
 d17ad0f0c0ef44371a260964b9b8f6e45d3eeace
  You can use `class` instead of `className` for custom tags.  This is intended behavior.  This behavior was chosen because we needed to support arbitrary attributes on custom tags.  That's what #4933 is discussing, and we're probably going to keep that behavior unless someone comes up with a better idea.  We'll keep that discussion in that other thread.

However, the `children` attribute is being set to "[object Object]" - that seems like wrong behavior to me.  We can use this issue to track that regression.
  Yes, it is completely safe and legal.

For future reference: usage questions are better addressed on StackOverflow.  We try to keep github issues for tracking bugs in the React core.
  Could you reduce this a bit further to a reproducible example that runs on jsfiddle (can fork from https://jsfiddle.net/reactjs/69z2wepo/)? Ideally without Radium and with the simplest form of your logic.
  Should be fixed in master.
  Hack: `PropTypes.oneOfType([ThingList.propTypes.things, PropTypes.oneOf([])])`. You could also make your own wrapper that does this same thing.

propTypes are mostly in a sort of maintenance mode and we're not really planning to add more to them right now.
  @spicyj @zpao 
 Yeah, they seem to be lagging a bit. Try https://cdn.jsdelivr.net/react/0.14.0/react-dom.js.
 jsdelivr updated very quickly‚Ä¶ we might want to switch our docs over to using that in the future. cdnjs says "up to 30 hours" which is a long time for our tutorial to be in a semi-broken state.
 Yeah‚Ä¶ or set up builds.reactjs.org ‚Äì I think @terinjokes offered to help?
 From the cdnjs readme (emphasis theirs):

> cdnjs automatically updates libraries that are known to be hosted on `npm` or git repo, e.g., Lodash. npm auto-update relies on each release and git auto-update relies on the [tags](https://git-scm.com/book/en/v2/Git-Basics-Tagging) in git repo. This auto-update script runs every hour, but the update result **won't be committed until one of our maintainers audit the updates**, because many libs will change the naming or directory structure during different versions, and we may need to minify the lib without pre-minified dist files, so **it'll be reasonable to delay for at most 30 hours**, if you think there is a lib didn't been updated, please wait at least 30 hours for the process to audit it.

The commit adding React (https://github.com/cdnjs/cdnjs/commit/9bfeaddfe22aacd83f66384848e0f2bcc1c61cc5) went in at 18:18 PDT, 8 hours after we shipped at 10:21.(https://github.com/reactjs/react-bower/commit/f4e97c67e6adf209da8aff329a8f7eb1239be3f7). jsdelivr went in at 10:35 (https://github.com/jsdelivr/jsdelivr/commit/a5259fbdfc52967170c13b1d8130d0046980046a). Perhaps we just got a bad break in the cdnjs update cycle and a good break in jsdelivr. I have no connection with any of these and will ultimately just do what's best for us (which is probably just to have our own `builds.reactjs.org`)
  Thank you!
  Every stable (a release that we would expect people to use) includes breaking changes - changes which we believe make the product substantially better.  We use React in production at Facebook, so we'll do our best to remain as stable as we can, but we are still figuring out the optimal API.  At some point, we will transition past 0.*, and then we'll continue to follow semver.

Duplicate of https://github.com/facebook/react/issues/4998
 We've explained things in the past and this isn't a fruitful discussion. If you put that much stock into a version number then you don't need to use React.
  Can you post a minimal repro case please?
 Sounds like what @ericf mentioned here: https://github.com/facebook/react/commit/e9c571acc6c87c7b1d14db1635f36bba7082d192#commitcomment-13650087.
 We'll try. In the meantime, you could copy the definition from here since it doesn't rely on any React internals:

https://github.com/facebook/react/blob/4fb39ce9842811b39314503874b56d925bd28a09/src/test/ReactTestUtils.js#L181
  Are you confused because it doesn't return a DOM node? Only built-in DOM components give the DOM node; composite components are unaffected.
  Thanks!
  When a user puts a textnode (whitespace) in an illegal location, our warning complains about a `span` element (because we wrap text - including whitespace - in a span).  This is confusing for new users, since there is no `span` present in their code and the introduction of the `span` tag is an implementation detail of React.  We should fix the warning to better align with the code the user is looking at.

```
var rows = <tr></tr>;
React.render(<table><tbody> {rows} </tbody></table>, document.getElementById('container'));
```
 @spicyj I think this might be a bit advanced to be a good-first-bug.  Specifically, we need to handle three general cases:
- The user actually specified a span: `<table><span>foo</span></table>`.  In which case, we should indicate that there is a span.
- The user did not specify a span, but did specify child text: `<table>foo</table>`
- The user did not specify a span, but did specify only whitespace: `<table> </table>`.  In which case, we should call out the whitespace, because if we just call it text, it'll be easy to miss and be confused about what's going on.  Whitespace includes tabs, newlines, and spaces.
 I could take a guess on these, but I think it would be best if @spicyj could jump in here, as he wrote the validation code and knows it best.
 Thanks, that's a bug, fixed in #5198.
 Yes.
 You can change the signature of validateDOMNesting if you have to. Also, your check for whitespace isn't right: it should only refer to whitespace if all of the text is whitespace, not if there's any whitespace character (which is what you have).
 We don't explicitly call out whitespace but yeah, hopefully this is clear enough now.
  React itself relies on this behavior and all known browsers behave this way, this will eventually be phased out when `Map`-support is better, but there's no present danger here. Stay away from numeric indices and it's safe.
  If you could repro in a small case and/or supply some of the surrounding code, that would be helpful (and the react version, etc). This is the first I've seen of this error coming from code we control, where it shouldn't ever be the case.
 In any event, we removed this call to invariant in 0.14.
  IIRC this will emit a warning in 0.14. Text nodes (spaces) are not allowed inside `<tbody>`.
 cc @spicyj
 Yeah, closing this out because we now warn in 0.14.  Though... the warning could be better: https://github.com/facebook/react/issues/5071
  Proptypes are mostly legacy and in maintenance mode, having been replaced by tools like Flow. My guess is we aren't going to add this, so let's close it out. We can re-open if our thinking on this matter changes substantially.
  We're cutting a release atm, will merge once that's done.
  We're moving towards the use of `createElement` which would sidestep the issue of `innerHTML`. In the meantime I don't think there is much we can do here, sorry :(

If you wanted to get fancy you could do something hacky that updates your svg but otherwise renders into something else‚Ä¶ in theory something like this (caveat that I haven't run it nor will I support it):

``` js
function renderReactIntoSVG(element, node) {
  var mynode = document.createElement('div');
  ReactDOM.render(<SVGReparenter into={node}>{element}</SVGReparenter>, mynode);
}

SVGReparenter = React.createClass({
  reparent: function() {
    // assume you only have a single child node which would map up to
    // expectations if you're subbing this code in for a React.render().
    this.props.into.replaceChild(
      this.props.into.firstChild,
      this.refs.root.firstChild.cloneNode(true)
    );
  }
  componentDidUpdate: function() {
    this.reparent();
  },
  componentDidMount: function() {
    this.reparent();
  },
  componentWillUnmount: function() {
    // cleanup after ourselves
    this.props.into.removeChild(this.props.into.firstChild);
  }
  render: function() {
    // TODO: maybe use callback refs
    return <svg ref="root">{this.props.children}</svg>
  }
})
```
 @zpao Could this be related to #2340? `createNodesFromMarkup` should take care of creating SVG-elements inside the right namespace (mostly at least).
 Yea, that would solve this too (that's effectively effectively what I wrote above üòÅ). But I do think we'll be moving away from innerHTML, hopefully before next release.
 I think it works in master/future.  http://jsfiddle.net/zcotr9hm/

If I'm wrong, let me know and we can re-investigate.
  Are you in a directory with a package named `react` already? That's what that warning message seems to imply is happening.
 You need to call your package something else (npm is looking at the `name` field in package.json). This is just how npm works, which is why it gives you that warning.
  Can you fix this so it fits in 80 chars across and squash your commits?
 Thank you!
  Thanks, we should fix that.
  Proposal: New life-cycle that fires after `componentDidMount` and after the event-loop has returned but before any other reconciliation has started.

Effectively, this give you a `componentDidMount` that doesn't block the visual output. It could be a good place to set up timers, subscriptions etc.
 Just a question: Why do we need two lifecycle methods?  Why would you want a componentDidMount that **does** block the visual output?  Just so you can apply imperative DOM manipulations before a repaint?  Is that a sufficiently important use case that we care?
 @gaearon, `componentDidDisplay` maybe.

@jimfb, yes, all the layout thrash reads have to be executed before repaint. I.e. when you render, measure, rerender to position. Otherwise you end up with an inconsistent view tree. It is equivalent of "tearing" in display technologies. It will flicker. Integrated layout would fix that but not for legacy.
 @mridgway Effectively the same, yes. Although with consistent execution order.
 cc @leebyron for API design
 Using `componentDidDisplay` when you should use `componentDidMount` will show itself as flickering so I'm not too worried about that.

Using `componentDidMount` when you should've used `componentDidDisplay` is trickier. We could potentially catch `componentDidMount`s that doesn't mutate the DOM in anyway (by refs or second render pass) and warn for those.
 componentDidDisplay would be a better name for a windowed list view thing. (We already have DidEnter and DidAppear for transition group though‚Ä¶)
 > Using componentDidMount when you should've used componentDidDisplay is trickier. We could potentially catch componentDidMounts that doesn't mutate the DOM in anyway (by refs or second render pass) and warn for those.

Warning might be a little weird, since the dom mutation might be behind some sort of if-check (`if(refComponentIsTooLarge()) { moveChildIntoOtherBox(); }`).
 This is a perf optimization but almost all use cases should be using this new hook so something additional is too much boilerplate. Ideally no work should be done after the initial view is already done.

`setTimeout` (or something like `setImmediate`) might not be batched properly and is difficult to reason about with regard to other things that call them. We also can't schedule them appropriately when we have a scheduled reconciler.

Additionally, just queueing these callbacks, traversing and invoking them can be significant overhead in it self (at scale). I'd prefer not requiring that, but allow React to collect them in a second pass to make the initial mount really quick.

We'd not even check for the property the first pass.
 The problem is that one direction leads to broken behavior and one is slower. If we change the API behavior now, we'd have to apply a codemod and potentially break everyone.
 `componentDidPaint` sounds like it could make more sense perhaps? `Display` sounds like it's part of being displayed/hidden (i.e. like the CSS-property).

I might be missing something here, but it sounds kind of error-prone to postpone things until after paint, possible race-conditions and what have you if you're not careful (say a store being updated between you rendering its data and subscribing to it).

I'm also curious why this is being proposed, intuitively these things would normally take immeasurable time in relation to the rendering? It also seems to me that you would want to fire off network-requests as _early as possible_, i.e. in `componentWillMount` rather than later. I'd rather delay painting by 1ms than a network request by 100ms. So I'm curious, do you have use-cases where there would be measurable benefits? (For which setTimeout would not be sufficient).
 Intuitions are often wrong. 

> On Oct 6, 2015, at 2:43 AM, Andreas Svensson notifications@github.com wrote:
> 
> componentDidPaint sounds like it could make more sense perhaps? Display sounds like it's part of being displayed/hidden (i.e. like the CSS-property).
> 
> I might be missing something here, but it sounds kind of error-prone to postpone things until after paint, possible race-conditions and what have you if you're not careful. I'm also curious why this is being proposed, intuitively these things would normally take immeasurable time in relation to the rendering? It also seems to me that you would want to fire off network-requests as early as possible, i.e. in componentWillMount rather than later. I'd rather delay painting by 1ms than the network request by 100ms. So I'm curious, do you have use-cases where there would be definite benefits of this? (For which setTimeout would not be sufficient).
> 
> ‚Äî
> Reply to this email directly or view it on GitHub.
 @sebmarkbage I've mentioned it elsewhere for other purposes, but could an API like say `React.defer(callback)` be more versatile and intuitive perhaps? It would queue all callbacks and execute when React is finished with all processing (i.e. after events, transactions, etc).

**EDIT:** But of course for this use-case instead where you want to do it after display/paint.
 @syranide We would like to avoid global APIs and make them tied to a component so that we can better control scheduling such as deferring execution of offscreen content etc. `this.defer(callback)` would work but that lacks the pit-of-success factor. You have to do something extra and more work to do something that is best practice and you always should do.

It also requires at least a function call and allocating a bound callback. The point is to crazy optimize the initial render since that's the most critical one.

It also encourages an imperative pattern for managing your async actions.
 > this.defer(callback) would work but that lacks the pit-of-success factor.

I'm not sure if I agree entirely, unless you have read the documentation you will not know about or understand the intended purpose of `componentDidDisplay`. `setTimeout(cb)`/`setImmediate(cb)` is a very common pattern in JS for deferring.

> You have to do something extra and more work to do something that is best practice and you always should do.

I agree, but `componentDidDisplay` only works for mount and not updates. Isn't that worth supporting too? Or is this _only_ about the initial subscription to stores basically? And shouldn't we have an equivalent for unmount too since we shouldn't want to block there either? That seems equally important for page switches.

> It also requires at least a function call and allocating a bound callback. The point is to crazy optimize the initial render since that's the most critical one.

That seems petty in the context of instancing all the components, rendering all the components, setting up the DOM and then drawing the DOM. Nor is every component is going to need to use it.

...

If all we want is `componentDidDisplay` then it makes sense to go that way, but it seems like a partial solution?
  The primary component strategy for React will never be Web Components. It runs counter to functional paradigm of React by providing a mostly imperative API. It doesn't help solve any of the problems we have building apps. In fact it makes it more difficult. It does little to nothing to solve the integration problem with other libraries. It doesn't have a solid story around server-side rendering. It doesn't help at all for cross-platform environments like React Native because the overhead of implementing a full DOM spec that we're then going to have to side-step anyway.

It is unlikely that Facebook will ever use Web Components at scale and therefore unlikely it will be a priority for us. There has been a lot of excitement about Web Components as an interop layer. Mostly unwarranted IMO.

However, we like to support our users so we've made a best effort to try to support interop in the edges. We would like to support as much as possible without compromising the API and vision of React itself.

It has turned out that the spec is incomplete with regard to things like event delegation and there are still major changes being pushed from various sides, such as Mozilla. What was in Polymer/Chrome is not the final incarnation so we've had to revert some of the support that we already added (e.g. support for event handling in shadow trees).

In terms of strategy, we'll go forward with as if it didn't exist and try to improve interop at the React or React-like component layer instead. I've talked with members of other popular UI frameworks and they seem to feel the same. In fact, we probably have a better chance at implementing solid interop in user land.
 @cosminnicula The key difference is that custom elements (web components) often expose an imperative API.  As an example, consider a video tag/element.  There are some relatively declarative attributes (like `src`) but there are also a bunch of imperative functions (eg. `addTextTrack()`, `canPlayType()`, `load()`, `play()`, `pause()`).  These functions do not play nicely in a declarative application.

We touched on this a bit in our most recent blog post: http://facebook.github.io/react/blog/2015/10/01/react-render-and-top-level-api.html#object-oriented-updates

We try to support interoperability where possible/practical.  For web components that support a purely declarative API via HTML attributes, they should already work reasonably well with React.

With regards to wrapping React components as custom elements (or vice versa)... Yes, wrapping is the current recommendation for anyone who requires such interoperability.  Since the programming models are different, it's hard to have a seamless API that is automatically generated, so our recommendation is that you write the wrapper class by hand (rather than using an automatic wrapper library), but ultimately it's your choice and you should do whatever works for you.  It should be possible to wrap any custom element in a React-wrapper for use in a React application, and vice versa.
 @cosminnicula That's a misconception. WebComponents in Accelerated Mobile Pages is the SLOW path. It is deferred until the last possible point. It is intentionally the opposite of giving them a performance boost. It is to make everything else isolated.

At best it could be the interop layer where you start your component, however, once you're inside the Web Component it is still as slow as the DOM and React will be faster inside of it. It doesn't mean React should render Web Components as its output. Potentially only placeholders for server-side rendering into a AMP document.
 We have merged some docs on using Web Components within React: http://facebook.github.io/react/docs/webcomponents.html

Those docs, combined with our posts in this issue, is roughly all we have to say on this topic at the moment.  Unless there are further questions, I think we can close out this issue.
  ReactLink is getting deprecated as per https://github.com/facebook/react/issues/2302.  Assuming valuelink is something you find useful, I encourage you to publish a npm module or git repository that provides this functionality as a wrapper component so other people can use it. Since this is not something we plan on supporting in the core, I'm going to go ahead and close out the issue.
  Dupe of #2127.
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 I think this is supposed to say "set or". Do you mind changing it and squashing your commits? Thanks!
 You should be able to squash by using command line git (even if the commit wasn't originally made using the command line).  The command you're looking for is probably something like `git rebase -i HEAD^^`.
 squashed and merged: 761921499c2b8e23f3f98f1b9c2c64b07c4b8844

Thanks @xelad1!
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 We should make sure we only warn once for each error message.  Otherwise, for an app that renders often, we will fill the error logs with 10,000 copies of this message.  See how I did this in https://github.com/facebook/react/pull/5032/files with variables like `didWarnCheckedLink`
 @antoaravinth Ok, we're merging 0.15 stuff now.  Can you rebase and fix the feedbacks above?  Thanks!
 @antoaravinth Most of the 0.15 stuff is merged.  I don't see any merge conflicts yet (I'm actually a little surprised, I expected https://github.com/facebook/react/pull/5032 to conflict).

Anyway, we should go ahead and update this PR with the feedback above before merging this change in.  You can do that by pushing your changes to the same branch in your github fork.
 @antoaravinth updated the pull request.
 @pluma Looks like there are still two commits in this PR.  Maybe try squashing one more time?

@spicyj This looks good to me.  Any last change requests before we merge?
 Oops, correct PR, wrong person.  I meant to ping @antoaravinth 
 @antoaravinth updated the pull request.
 Looks great, thanks @antoaravinth!
 This warning should really include the owner.
 @spicyj Yeah, that would be good.  How would we feel about including the parent/debug path from https://github.com/facebook/react/pull/5167?
  We don't recommend inheritance for building your components.
 While it is true that we believe in composition over inheritance, I think the original question is still valid, so I'm tempted to leave this issue open.

> would it make sense to implement default (empty) lifecycle methods in the base React.Component class?

The main reason I see for doing this: it allows static tooling to better reason about the code, rather than being forced to rely on implicit knowledge.  For instance, I could mark a method as `@Override`, as I always do whenever I'm overriding a method... and then if I spell it wrong or that function gets removed from the parent React.Component in a future version or whatever, I get tooling support.  Also allows code assist to give me the lifecycle methods when I ask for suggestions of things to override, etc.  It might even improve performance by keeping the implicit classes more similar within the core.  Overall I think this would still be a good change, even for people who are using composition over inheritance.
  Ok, sounds like you guys figured it out.

For future reference, we try to keep github issues for tracking bugs in the React core.  Usage questions are better addressed on StackOverflow.
 Thanks @stenrap. We've since changed the message.
 @timbur Currently you need to expose document and window globally before requiring React. See the other comments.
  üëç thanks!
  Simulate only simulates an event within React's event system. You should use an ordinary `.dispatchEvent` or similar if you want to create and dispatch a real browser event.
  If you're trying to catch scrolls of the whole page, you need to attach a scroll event handler to `window` by hand. See also #285.
 I meant the former. If that doesn't work, it's hard for me to imagine how it could be a React problem.
  Yeah, we can probably add a warning for this.
 Another report of this being confusing internally:

![image](https://cloud.githubusercontent.com/assets/6820/12654746/668e67b0-c5aa-11e5-8a1c-674fd30eb208.png)
  Seems reasonable, thanks!
  Is this still noticeable if you use `React. unstable_batchedUpdates(...)` around the source of update? Which is kind of best practice anyway.
 @sebmarkbage I think the issue is that we (in this component) do a setTimeout for each child and trigger a rerender from there.
 wut? I give up.
 Hi @beckiechoi, thank you for the PR.

Unfortunately there aren‚Äôt enough eyes on the addons right now, and ReactTransitionGroup is especially problematic because it is pretty complicated already and is known to have some edge cases in correctness. My impression is that we‚Äôd rather not risk introducing changes like this unless there is a dedicated person who is ready to support it‚Äîat which point that person might as well publish their version as a third-party package. We plan to separate addons from React, and publishing a fork that works for you and maintaining it might be the best way to fix it.

I‚Äôm sorry I don‚Äôt have a better reply. If somebody on the team is willing to test this extensively and support it later, we can reopen this, but I don‚Äôt think this is the case right now. Especially because this only seems to fix a performance issue, but it might introduce a correctness issue. (I‚Äôm not claiming that it will‚Äîit is just not obvious to me that it won‚Äôt, and we don‚Äôt have the resources to vet it thoroughly.)

Tangentially, you might want to switch to using https://github.com/chenglou/react-motion which has a wide community adoption, [better test coverage](https://github.com/chenglou/react-motion/blob/master/test/TransitionMotion-test.js), and doesn‚Äôt depend on CSS animations. Cheers!
  .nativeEvent is just what the browser passes us so if those properties aren't right then it's not anything React's doing.
  Please don't perform tests against our repo.
  I think this is related to https://github.com/facebook/react/issues/5031

Your owner is the bigGpsButtonElement component, and then you are expecting the ref to appear on that component's parent.  The ref is attached to the owner, as Ben mentioned in the other issue you opened.

Closing out as not a bug in React.  You can read more about refs in the [documentation](https://facebook.github.io/react/docs/more-about-refs.html#completing-the-example). Please ask usage questions like this on StackOverflow.  Github issues are reserved for tracking bugs in the React core.
  Currently, refs are organized based on "owner" which is the component whose "render" method was on the stack at the time the element was created. For reasons like this one, this is unpredictable so we're trying to get rid of uses of "owner" all over. String refs are basically the last one. We'll look at deprecating them completely sometime, but for now you best workaround is to move those elements into render or do `ref={(c) => this._mapNode = c}` instead.
  This is a known issue with CSS shorthand expansion. For now the recommendation is to list each explicit property and not rely on the shorthand. Usually these bugs only surface on update because initial render simply creates an inline style as a part of setting innerHTML. Updates work on individual properties so when you set `background` on the update we notice that you only changed `background` so only set that property, which since it's a shorthand, clears out the `backgroundSize` property.

See #4661 for more discussion.
 @zpao @spicyj @syranide  Could we solve all these correctness issues/concerns if we were to use `cssText` instead of setting the properties individually?

My understanding is that we've always claimed that diffing the css ourselves was faster than letting the browser do it, but Ben's perf test (http://jsperf.com/style-vs-csstext-vs-setattribute/8) from https://github.com/facebook/react/issues/929, on chrome, seems to indicate that `cssText` isn't actually any slower (in fact, maybe faster than diffing ourselves) and I **think** it would solve all these concerns in one fix.  Thoughts?
 > @zpao @spicyj @syranide Could we solve all these correctness issues/concerns if we were to use cssText instead of setting the properties individually?

Yes, but performance-wise that is near identical to setting each property individual like we do now, except we can cheaply skip unchanged properties, so you definitely do not want to do that for this reason. I could be proven wrong here, but that's the last I remember when messing around with it.
 Right, so if performance is nearly identical but the 'correctness' is easier (since we punt to the browser), it seems like a pure win.  We could still cheaply skip if all the properties are unchanged, which covers the common case.

Based on my reading: It seems to me that the performance difference of `cssText` vs. properties is a toss-up.  Sometimes one wins, other times the other wins, it depends on the specifics of your microbenchmark.  But overall, it's a tight race.  However, there are a bunch of other (very measurable) disadvantages to manually diffing+setting css properties... things like these 'correctness issues', vendor prefixes, unnecessary code/cruft in the core, etc.  I guess my intuition is that if performance is nearly identical, the other factors should be taken into account, making `cssText` seem like a pretty clear win.  Anyway, maybe that's a debate for another thread/issue, it sounds like the answer to my initial question is "yes, it would fix the correctness issue/concern".
 > Right, so if performance is nearly identical but the 'correctness' is easier (since we punt to the browser), it seems like a pure win. We could still cheaply skip if all the properties are unchanged, which covers the common case.

With `cssText` you cannot skip properties, all properties must be present in the string. That's the problem.
 > With cssText you cannot skip properties, all properties must be present in the string. That's the problem.

Yeah, that's true, `cssText` might loose that pathological case, but it wins in some other cases, so my argument is that it's a wash.  Overall, it's not clear that one technique is faster than the other, so I don't think the performance argument holds water here (maybe I'm wrong).

I don't have the numbers, but if we are already updating a css property on that element (ie. repainting that element anyway), I suspect that the additional cost of parsing a couple additional properties out of a `cssText` really isn't a big deal, especially when the cost is offset by perf wins in other cases.

If it is in fact a wash, then I argue that `cssText` is better from a simplicity perspective, because then we aren't trying (and failing) to simulate behaviors that the browsers already have implemented/optimized.
 Please move any discussion about `cssTest` to a new issue, it's not helpful to have it buried in the comments of another issue that is already closed.
  Thanks!
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 If this fixes issues like #5575 maybe we can get this in. Nobody had a chance to review this yet so I want to give it a try. Sorry it took so long.

The problem is it‚Äôs not immediately clear (at least to somebody like me who isn‚Äôt intimately familiar with how TransitionGroup works internally) how this reflects on the real apps. I looked at your test case in https://github.com/jedwards1211/react/blob/react-transition-group-patch/ but I found the test case a little too abstract.

It would help if you tweaked it to look more like a problem a real app can face with some common UI pattern (e.g. an accordion). Otherwise it‚Äôs hard to tell if this is a bugfix or a feature request for different behavior. Also lack of tests makes it hard to tell whether this is going to be a breaking change. Is old behavior undisputedly a bug, or can people actually be relying on it? What about people who use `ReactTransitionGroup` directly without the high-level CSS wrapper? Is there any reasonable use case for the existing behavior that this would break?
 We‚Äôre not in a very good state right now regarding changes to TransitionGroup due to the reasons I explained in https://github.com/facebook/react/pull/6149#issuecomment-203029156.

Unfortunately I can‚Äôt promise anything right now other than we will discuss the plan for TransitionGroup this week and come back with some plan moving forward after shipping React 15.

I think that it would help strengthen your case if you added tests but I can‚Äôt guarantee we‚Äôll take this PR. Sorry for being inconclusive. This is something we should get better at.

Thank you very much for contributing.
 I would suggest trying out https://github.com/chenglou/react-motion.
I don‚Äôt think we use it internally at the moment though.
  Thanks!
  @cosminnicula React's virtual dom diffing does things like guaranteeing that if a node with a particular type-keyPath-pair appears in both the first and second render, the DOM nodes will be reused (thus preserving imperatively added children, etc).  This is a serious expense that inferno doesn't incur because they are using simple templating and can just throw away nodes if it's too inconvenient/expensive to calculate an absolutely minimal diff.  This is just one of many key differences.

One might argue that the performance differences exceed the value of the additional features in React, but that's a different argument.  It's hard to know one way or the other.  In practice, React is pretty fast for most real-world applications, and we think the features we support are valuable.

This is why we only use perf tests for regression testing, and not to compare frameworks.  I have a post here in https://github.com/facebook/react/issues/4974#issuecomment-143924915 which touches on the topic in detail.
 @trueadm Here is what I mean:

```
Inferno.render(
  t7`<div><div id='widget' /><div>foo</div></div>`,
  document.getElementById("app")
)

document.getElementById('widget').innerHTML = "this should be retained";

Inferno.render(
  t7`<div><div id='widget' /><div>bar</div></div>`,
  document.getElementById("app")
)
```

As of today, Inferno does not retain the widget.  Retaining the widget is important because it allows people to mount non-react stuff into a react render tree, which is critical for interoperability with other libraries.  But even if that were fixed, it's not the only difference.

What you've done is very cool and I encourage you to pursue those ideas (or better yet, please do contribute them to the React core!), but it's certainly not a drop-in replacement.
 > leverages on the concept of virtual fragments (chunks of virtual elements) and value diffing, rather than vdom diffing

@trueadm I don't know what this means. Can you help me understand?
 @spicyj He is hoisting the jsx up out of the render function, and using triple equals equality on the elements rather than walking the vdom.  Sort of similar to Ember's glimmer stuff. 
 In React, 

```
<div><span>{value}</span></div>
```

becomes essentially

```
{
  type: 'div',
  props: {
    children: {type: 'span', props: {children: value}}
  }
}
```

and React compares these objects. Isn't that the same thing?
 Got it. Thank you.
  Works at least on a CentOS 7 machine after running `sudo yum install
webkitgtk webkitgtk-devel`.

The only globals you get are `print` and `PerfCounters`. No `console` nor the other globals provided by the `jsc` command-line tool (load, readFile, etc) though they're probably not hard to implement.

You can disable the JIT by setting the environment variable `JSC_useJIT=false`.

Test Plan:

```
~/local/react/scripts/perf-counters$ make
~/local/react/scripts/perf-counters$ build/jsc-perf <(echo '
  PerfCounters.init();
  var a = PerfCounters.getCounters().instructions;
  print("moo");
  var b = PerfCounters.getCounters().instructions;
  print(b - a);
')
moo
72182
~/local/react/scripts/perf-counters$
```
 Just flagging this so we don't land it since it lacks copyright header.
 (Fixed the header.)
 any reason not to just land?
 Hey, I was waiting for someone to stamp it.
  No, we'll land it on master if we take it (and it will be after 0.14, whose release is imminent).
  cc @sebmarkbage 
 We could potentially bail out if you return the same state object. It's probably what you would do if you mutate it but that's bad practice anyway. Returning `undefined` is not nice because it lets accidental implicit returns continue. `false` makes it a union type. Returning `null` is also not nice for types. You have to declare it as nullable.

I'm not sure this is a pattern we should encourage to check for manually though.

`shouldComponentUpdate` exists to let you avoid reconciling based on previous state and next state. So you can always bail out the reconciliation.

The only thing you're bailing out from is calculating the new state value. So, what are you doing that is expensive to calculate?

Btw, IMO, RN (and other event systems) shouldn't fire multiple events in a batch but fire a list of events as a single callback. Like iOS does for touches.
 btw `this.setState()` with no argument also triggers a rerender.
 `requestPendingState` was discussed as a possibility but it's tricky because you may be encouraged to do other side-effects.

All of this leads to a very imperative way of coding and any optimizations you add can have fragile assumptions about what could affect what. `shouldComponentUpdate` is a funnel that ensures that you don't do those assumptions.

Could you add some more context? It seems like if you need information about why something happened, then the system might be relying too much on imperative programming already. I.e. is it leaky?

And if you do need to rely on an imperative style, you're probably better off putting it on an instance variable `_myImperativeStateIKnowWhatImDoing` instead of using `setState`.

Would the same optimization be possible/relevant in these pure patterns? https://github.com/reactjs/react-future/tree/master/07%20-%20Returning%20State
 Philosophically, I'm worried about multiple `setState`s. My ideal would something like:

https://github.com/reactjs/react-future/blob/master/09%20-%20Reduce%20State/01%20-%20Declarative%20Component%20Module.js#L32

That way you can follow any possible path that could've effected the state.

I've seen way to many patterns that effectively lead to:

``` js
handleClick() {
  this.setState(..., () => doSomething().then(() => this.setState(...)).then(() => this.setState(...));
}

iHopeThisDoesntFireInTheMiddleOfSomething() {
  this.setState(...);
}
```

Yet, covered by abstractions. This hides state in closures and is constantly relying on an implicit "action" being traced through the state changes to take shortcuts.

> I'm not sure how I would bail out from shouldComponentUpdate since there are other props and state fields that are mutable values.

React doesn't work properly with mutable values if you rely on a props mutation triggering a deep state update for consistency. I.e. the component that mutated a value needs to call `this.forceUpdate()` or `this.setState(...)` so that the parent updates and the flushes down. Additionally, React bails out if you try to reuse a ReactElement with mutated props. This means that for mutation to work, you will always get a new props object if your parent rerendered.

Therefore this solution should work for you:

``` js
shouldComponentUpdate(nextProps, nextState) {
  var stateChanged = nextState.refreshing !== this.state.refreshing ||
                     nextState.progress !== this.state.progress;
  var propsChanged = this.props !== nextProps;
  return stateChanged || propsChanged;
}
```

If the only change was due to your `setState` then `propsChanged` will be `false`. If you're at a positive scroll position you'll keep setting the same state so `stateChanged` will also be `false`.

If you rerender with mutated props, `propsChanged` will be `true`.

That way your state transitions can be described completely in terms of a reducer and any optimizations/shortcuts are completely isolated to `shouldComponentUpdate`.
  Now we don't repurpose context for our own secret needs (hi Dan). In this diff I avoid storing the native parent on native (DOM) components and store it only on composites, but we'll probably want to store it on native components too soon for event bubbling.
 @sebmarkbage Can you review this? We'll need this before testing createElement again at Facebook because some internal tools use SVG.
 While understanding this diff, I noticed that `updatedAncestorInfo` has a line `ancestorInfo.parentTag = info;`, and while I understand why the name parentTag was chosen, it's very confusing because the ancestor info is added to a component instance and `instance._ancestorInfo.parentTag` is NOT the parent tag of the current instance... it's a cyclic reference back to the current instance.

I'd assume that `parentTag` was intended to be a reference to the parent instance not to the current instance.  Having a reference to the current instance actually makes very little sense / adds very little value, as far as I can tell.  Either way, the name is very confusing.
 Next major. I'll update react-art but other projects will need to update themselves. I'll remind you that these internal APIs are currently not supported still since we haven't had time to really stabilize them, and we'll probably keep changing them for a while.
  Passing `null` indicates that the user tried to specify a value (eg. from the database) but didn't notice the value was null; seems like that should be a warning.  Normally we treat null and undefined as the same, but in this case passing null indicates an error and should therefore be discouraged.  The user should decide if they want an uncontrolled component (in which case they should pass undefined) or if they want an empty controlled component (in which case they should pass the empty string).  

@spicyj said he would be fine with this being a warning and/or with treating null as an empty string.  Making it an error/warning has the advantage that there is now an easy upgrade path (fix the warning) without us introducing subtle changes in behavior that will break people's apps.
 (see also #2533)

To be clear, we should treat null as the empty string eventually regardless of if we have a warning. Makes sense to preserve behavior for a release though.
 Yep, ok, :agree:.
 @antoaravinth Sounds roughly correct to me.  You'll want to do the same thing for `TextArea` and `Select`, since they can also be controlled inputs.
 @antoaravinth You may find this diff very helpful, since it's almost exactly what you're trying to do: https://github.com/facebook/react/pull/5032/files

For the warning message, we should say something like:

> `value` prop on `textarea` should not be null.  Consider using the empty string to clear the component or `undefined` for uncontrolled components.

Also, just fyi, we're in a code freeze 0.14 so your change will land when we're ready to merge 0.15 stuff.  You're welcomed to take a stab at it now, but will likely need to rebase once we're ready to merge 0.15 stuff.
 @antoaravinth That error is basically saying that the test wasn't expecting any warnings to fire, but some warnings were printed.  You can either add some checks for the warnings (as I did in my linked diff above) or you can modify the test such that it doesn't warn (eg. update the test to pass `undefined` instead of `null`).  Either way, we should have at least one test that verifies the warning fired correctly and at least one unit test which passes undefined and shows that the error does not fire.
 Fixed in https://github.com/facebook/react/pull/5048/  Thanks @antoaravinth!
  I think you can use React.Children.toArray now and key off of the resulting `.key` properties to build your own map.
  The fix for #3878 landed in 0.14.

This sounds like something you should report to Alt.
  The mixin system was/is flawed in more than one way.  In most cases, higher order components do solve the common use cases for mixins.  I would recommend reading https://medium.com/@dan_abramov/mixins-are-dead-long-live-higher-order-components-94a0d2f9e750

It sounds like you have a solution that utilizes higher order components, so (without having actually looked at it) that's likely the solution we would recommend.  If you have a problem which is normally well-solved by mixins but is not well-solved by HOCs and/or sideways data loading (https://github.com/facebook/react/issues/3398, https://github.com/facebook/react/issues/3858) then we would LOVE to hear your use case, please open a new issue that describes the use case.
  Thank you for the PR! Unfortunately this seems like patching around the problem rather than fixing it. We still don‚Äôt know _why_ the callback is being called‚Äîthe fix would be to unsubscribe wherever it is being subscribed to avoid leaking memory rather than doing an `isMounted()` check.

#5391 fixed instances of #4876 that we could reproduce. If you still experience this bug in React 0.14.5 or later (best to check the most recent version of React including RCs‚Äîat the time of writing it‚Äôs 15 RC2), please create a JSFiddle reproducing it and post it to #4876 so we can reopen it.

Thanks again, and sorry for the trouble!
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 Thanks!
  Yes, you should trigger each event you want manually. It only dispatches that event; it doesn't do anything fancier than that.
 @lovedota You can consider using the native dispatchEvent if you are working in an actual browser. React won't get into the business of simulating how browsers work and how the different native events behave.
  Yup, this is a bug. The prod mode behavior is correct.

In dev mode we don't bail out because the contexts differ ([code](https://github.com/facebook/react/blob/249e0f7331c79c4fd30d141faaf61b2596cdefdd/src/renderers/shared/reconciler/ReactReconciler.js#L71)) because of secret validateDOMNesting tracking we do. Hmmmmmmmm.
 I feel like we knew about this "issue" and it was well documented at the time that the diff was merged.  We were using context for our own purposes and didn't have a good workaround at the time.  We decided to not worry about it, since renders should be deterministic (and side-effect free) it should have no influence on the rendered output.  It sucked that we had a different path in dev/prod, but that was life.  I think this is going to be fixed when we stop using context for our own hidden purposes, right?
 The "bug" is that your render function is not side-effect free (it prints something).
 @jimfb I didn't know about this issue. Did anyone make a comment to that effect on my diff? I don't see any notes on #3467.
 @spicyj https://github.com/facebook/react/pull/4344#issue-94421088
 @AlexGalays How did this surface? I.e. how did you notice the change? Is there some kind of behavior change or is it just slower in development mode?
  At least some of this code would need to go in ChangeEventPlugin, because the event is already going to bubble by the time _handleChange is invoked in ReactDOMInput. _currentValue should also go within the ReactDOMInput-specific _wrapperState object; you shouldn't need to add anything to every ReactDOMComponent. I think it's hard/impossible to get the ReactDOMInput instance from ChangeEventPlugin though.

We don't run our tests in browsers any more. It wasn't something we used often and it got lost in one of our change to extract common modules to https://github.com/facebook/fbjs.
 #4051 should have fixed this.
  Yep, completely legit!  Sounds great!  Let us know when you're ready to merge.  We'll ask that you squash your commits into a single commit before we merge.
 @claudiopro Start a local jekyll server as per the readme (the docs readme is in `/react/docs/README.md`, not the `/react/README.md`), then the translated docs follow a pattern like http://facebook.github.io/react/docs/getting-started-ja-JP.html which in your local browser would be `http://localhost:4000/react/docs/getting-started-ja-JP.html`
 Yeah, you'll also need

``` sh
$ cd react/docs
$ bundle exec rake
$ bundle exec jekyll serve -w
$ open http://localhost:4000/react/
```

etc
 Right now I think they're requested directly.  I think @zpao was looking into serving based on locale, but I don't think that's ready, though he might tell me I'm wrong :).
 This is awesome. Could you rebase on top of master here so that there's only the docs commit? Looks like there are a couple stray commits showing up right now.
 Thanks! We'll probably be making some changes in the next few days as we fix up some documentation for 0.14. We may ping you to see if you're interested in updating this translation as well :)
  Sure. Can you update the readme and html so that they say the right commands to run. I made them say `npm start` which works. Or just leave the `watch` script as `start` (or have `start` run `watch`) and then you don't need to change any docs.
 I merged this and added the requested change in ba76649c3b452dec30366a67900d782c8f56b1ba.
  > the change wasn't documented

I don't think this change was intentional. What do you expect findDOMNode to return inside componentWillMount? What did it return before?
 In terms of expectations, it seems like findDOMNode SHOULD throw if invoked before mounting, shouldn't it?  The component isn't mounted yet, so there wouldn't ever be a DOM node, or would there?
 Yeah, I'd never object to having a more helpful error message.  Just wanted to confirm though, because your sample code indicates you were somehow using it before mounting, which seemed... odd.  Just wanted to confirm I wasn't missing anything obvious.

Task is to add a new error message for using findDOMNode on an unmounted component.  Probably a #goodfirstbug?
 > But it previously worked

@dantman What did it do before? I can assure you that it did not return a DOM node since none has been created yet.
 Maybe there are circumstances around what you were doing (eg, maybe something with the same exact key was not properly cleared from the cache after a previous render) but in the simple case, `React.findDOMNode(this)` in `componentWillMount` throws in 0.13 as well.
 This doesn't look like a regression so I'm unmarking 0.14.
 Yes, it's possible. But React's event handlers aren't attached until just before componentDidMount is called, so componentDidMount would be a better place to check anyway. In any case, we haven't hammered out the exact details of how supporting that use case (responding to events that happened in between server rendering and client mounting) should work.
 No, React basically doesn't ever read from the DOM and in server rendering it just leaves the DOM as-is as long as the checksum (of the original generated markup) matches. We might reconsider exactly how this works but that's what currently happens.
 If this is fixed in master, let's just add a test to make sure that it continues working. Any interest in sending a PR?
  @salehe is correct, we are below 1.0.0, so anything is allowed to change and we're still semver compliant.  I'm going to close out this bug, since there is no correctness issue with regards to our semver compliance.  Eventually we will release a version greater than 0.*, but not today.
 We don't make breaking changes in patch versions. Think of 0.13.3 more like 13.3.0. or 13.0.3.
  IE8 doesn't support those features so there is no way for React to do so.
  Thanks @gregrperkins!
  You need to use the correct prefixes. See https://facebook.github.io/react/tips/inline-styles.html

```
style={{
  order: 1,
  msOrder: 1,
  WebkitOrder: 1
}}
```
  I think this looks good. Probably we'll wait until after 0.14 is released to merge this though.
 Thanks!
 I'm going to have to revert this in #5394, sorry ‚Äì more details there.
 As I mentioned in the linked pull request, it's a little unclear how shallow rendering should work with lifecycle methods, especially with refs, since there is nothing to hold a ref to (since we're shallowly rendering) and we usually promise that child refs are resolved before a parent's componentDidMount. If someone proposes a solution that doesn't have this problem I'm happy to entertain it.
  React Native has a feature/library called Animated which can help with this problem:

https://facebook.github.io/react-native/docs/animations.html#animated

I know @vjeux plans to port it to the web too ‚Äì not sure what the status of it is though.
 @Prinzhorn Animation is still a relatively unsolved problem AFAIK.  The current strategy is to have a whole bunch of people iterate on their own ideas/solutions, and see what sticks.  Trying to combine efforts prematurely may cut off lines of research that would otherwise have been fruitful.  That's why you see several independent implementations rather than a single unified effort - it's a good thing.

If you have ideas on how to make better animations, we encourage you to pursue them.  If you are looking for a good place to discuss such things and share ideas/designs, I believe the most appropriate location is https://discuss.reactjs.org/
  It does in 0.14 already. There's also a React.Children.toArray method.
 Yes, thank you.
  I realized this last week and didn't get a chance to test it. Glad to know it's not entirely in my head. We'll figure out a fix.
 Merging into #4990.
 @spicyj Merging into self?  Is there a different issue you intended to link?
 Thanks, I meant #4836.
 It hasn't been fixed. #4836 will have updates when it is (which will happen before 0.14).
 Both of those are fine. In prod mode we skip the check but your code will break in 0.15 if it's triggering the warning now.
  Yea, this is pretty well covered in previous discussions so I'm going to close out.
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 Thanks!
  FWIW if you're truly doing prop validation, this is what propTypes is for and that will automatically show the parent component name.
 React does not catch any exceptions. If your exceptions are being swallowed then it's something else in your toolchain (likely promises) doing it.
  @iamchenxin Looks good, can you squash these into a single commit?
 Great, thanks!
  Thanks!
  cc @zpao Contrary to popular belief, we do get these fairly frequently.  Related to #140 
 Yea "related", the underlying goal of that issue is to really get of the whitelist as much as possible, entirely would be good. I don't know that we called that out explicitly but they're mostly the same problem.
 @terinjokes Yeah, my comment was directed at a conversation we had at our last team meeting when figuring out our priorities for the remainder of the year.  Basically, there are a whole ton of attributes that we keep adding one-at-a-time, and I was/am pushing for us to solve #140 and wipe them all out (past present and future) with a single swipe.  But #140 is a slightly non-trivial change with several dependencies and was thus demoted off the prioirty list :P.
  So #4976 was a lie. Fixes #4870 for real (thanks @STRML).
 Don't screw it up this time üòâ
 I just wanted more commits.
  We've discussed this internally before, and while no binding decisions were made, the general consensus was to not do this.

There were a few reasons:
- Performance benchmarks rarely tell the whole story.  Suppose you measure the cpu runtime of your library, and it's the fastest... does that make you the best?  Maybe.  But maybe not... what about the amount of memory your library uses?  Or the download size of your library?  Or a whole host of other factors that can have substantial impact on the overall quality of your website experience, but aren't measured by cpu runtime alone.  It's virtually impossible to define reasonable benchmarks which correctly incorporate all the variables with the correct importance coefficients.  Indeed, the very definition of importance depends on your use case.
- Optimizing synthetic benchmarks can actually be detrimental to overall performance.  You can optimize the re-rendering of a single node a million times, but unless that is actually what happens when you render your site (pro tip: it never is) then your benchmark is measuring the wrong thing.  Optimizing that benchmark can actually encourage writing code that performs worse on real sites.
- Performance is a race to assembler.  You want to choose the right balance of developer productivity, code maintainability, with other variables like performance.  React does so much more than simple templating, but that comes at the cost of performance.  We believe that providing higher-level abstractions which are more maintainable and easier to work with is worth the tiny bit of overhead introduced by these abstractions.  But it's a balance.  You can always do better by removing layers of abstraction, but ultimately computer science is all about controlling complexity.  If you eliminate all abstractions, you end up with something like assembler (asm.js) which is great for machines but which humans can't read.  You're going to have a hard time building a website if you can't read your own code.  Competing on performance would lead us to eliminate abstractions which we believe are worth the cost.
- Comparing apples and oranges.  There are very few frameworks which do everything React does, and vice versa for every other framework.  A benchmark is only fair if it is comparing equivalent frameworks, but the feature sets of various frameworks varies so widely that it's virtually impossible to find an equivalent framework and thus impossible to create a fair benchmark.
- Ultimately, the performance metric that matters is: Is it going to be easy for me to build a fast website with React?  We believe the answer is yes.  And our rapid growth across the industry (and internally at Facebook) seems to imply that others agree with us.

Of course, we might change our minds in the future, but the thinking at this point is that we are not going to create a page that tries to compare React performance with other frameworks.  We believe that React is fast for real-world use cases, and we believe you'll like it if you try it.  We can re-open the issue if our thinking dramatically changes on this issue.  Feel free to continue the discussion on this thread.
 @toddparker Am I reading your data right that React was much faster than Angular and Ember in your test, and competitive with Backbone, with these times? 

| device | React time |
| --- | --- |
| PC, Cable | 0.26 s |
| PC, 3G | 1.10 s |
| Nexus 5, 3G | 1.26 s |

![image](https://cloud.githubusercontent.com/assets/6820/10210514/a78e41e8-679c-11e5-80b5-3a7baa6710fb.png)
 > Right, closing the issue so quickly and dismissing it doesn't look great. I kind of don't care about other frameworks in comparison to React. I care about what impact it's going to have in the context of what I'm building, and more importantly, who I'm building it for. For that, I need numbers.

@kevinSuttle My opinion. Benchmarks are almost universally skewed towards measuring specific synthetic micro tasks, intentionally or not. Micro benchmarks are trivial but also meaningless in this context, benchmarking realistic workloads for frameworks is incredibly hard. There are also meaningful thresholds that benchmarks consistently overlook, 5ms vs 10ms is largely irrelevant, but 50ms vs 100ms is an enormous difference... these are often lumped into the same result, without any consideration to fair weighting either.

Then you also have to consider developer time, manual DOM interaction will always win hands down, but you'll never see someone apply that for large-scale apps. So consider the cost of implementing and maintaining UIs made in different frameworks as well; given too little developer time then you will find React components will always outperform manual DOM interaction, and probably look and feel a lot better too, also be far more maintainable and less error-prone, how do you quantify this in a benchmark?

Take it with a grain of salt, but consider that many Angular projects will at some time encounter problems with performance and will resort to various hacks to get performance back up to acceptable levels. React users may face the same problems but I would argue that these problems are far more intuitive to solve in React and the solutions largely come out much more robust. Developer time is important too, and lack of developer time is usually what causes performance problems to crop up in the first place.

Anyway, if you want to know whether React is a good choice for you I would suggest quickly prototyping various aspects of your UI and _feeling_ it, those are the only factually accurate results you're going to get. Personally I will always choose the React model, the advantages for our developers and code base is far more important to me, if we encounter demanding use-cases where React isn't performing well enough we can easily break out of React briefly without degrading the quality of our code.
  `renderIntoDocument` doesn't actually insert the node into the document (it is probably not well named, sorry). Here's exactly what it does:

``` js
  renderIntoDocument: function(instance) {
    var div = document.createElement('div');
    return ReactDOM.render(instance, div);
  },
```

As you can see, we don't actually append `div` to document, so positional properties won't be useful.

In your case you can do this yourself. Something like

``` js
var div = document.createElement('div');
document.body.appendChild(div)
var component = ReactDOM.render(instance, div);
// test things
ReactDOM.unmountComponentAtNode(div);
```

The reason we don't do this is because we wouldn't be able to unmount reliably and then your tests would be tripping over each other in the DOM. Unmounting is critical in that case. But if we don't actually attach to the DOM then we can just let our test framework cleanup the documents when we're all done.
  Conceptually, what you're trying to do should work.  You've got a few bugs in your code (for instance, you have a self-closing jsx tag and then you close it again at the bottom.

I created a fiddle that demonstrates: https://jsfiddle.net/j8uq4vv7/

It looks like you might be new to the React community, welcome!  For future reference, we try to keep github issues for tracking bugs.  General usage questions are better answered on StackOverflow.

I'm going to close out this issue, but let me know if I miss-understood your question and we can re-examine this issue.
  Thanks for your feedback. We'll update when we're ready.
  If you rebase, the lint errors should be fixed.
 FYI, this tool is deprecated in favor of immutable-js. I'm don't think we'll keep maintaining this repo. We can take this after we've cut our branch. However, if you want to keep using this tool I suggest you fork it and release your own npm package.
 @sebmarkbage Are we ready to merge this, or do we just want to deprecate it and let @davidmason take the code from here?
 Ping @sebmarkbage.  Are we ready to merge this, or do we just want to deprecate it and let @davidmason take the code from here?
 @jimfb Feel free to merge this if it looks good to you.
 @davidmason updated the pull request.
 Thanks for contributing, @davidmason! I merged your PR locally but then tried to refactor it to avoid function allocations and the need to call `getCurrentValue` and `getNextValue` every time.

I submitted it in #6353 and kept all your commits attributed to you. I am keeping this PR open so when/if #6353 gets merged, this PR should appear merged as well (if I understand GitHub correctly :sweat_smile: ). Please check out #6353 and leave a note if I missed something. And thanks for getting this ball rolling!
 @davidmason updated the pull request.
 I‚Äôm going to close this for the same reasons as https://github.com/facebook/react/pull/6353#issuecomment-204219214.
I think this direction will be best for everyone involved.
 @davidmason updated the pull request.
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thanks!
  Does this work correctly outside of React? This just sounds like an IE bug.
 Sorry for the delay on this. We don't use SVG with React much so this hasn't been a big priority for us. Do you have a suggestion for how React could fix this?
  When you stop rendering a component it gets destroyed. If you want to keep its state around you can render it with `display:none` CSS.
  Thanks. The Liquid preprocessing can be annoying and I always forget about this. In the past we've just done `{{"{{"}}` to make Liquid print the literal double brace.
 @zhuyan730 there are issues rendering `{{` in Jekyll due to its parser which runs before markdown processing. This avoids it.
  Thanks!
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 Thanks!
 As per @sebmarkbage, let's take this in 0.15, since we're trying to cut the 0.14 release now and won't have enough time to let this bake.
 Unfortunately GH is annoying and doesn't reopen PRs. Could you create a new one so that we can merge it after branch cut? Thanks! (and sorry for the confusion)
 Already done. https://github.com/facebook/react/pull/5063
  I don't suppose you're using Flash to call into JS? Haven't ever seen this otherwise.
 Put a setTimeout 0 around the JS that Flash executes. It does crazy things and interrupts the running JS code in the middle of what it's doing when you try to call it, so if you don't do a setTimeout then literally all your code needs to be reentrant and threadsafe. I don't see how we can reasonably work around this in React.
  Can you share what your code looks like?
 Yea, multiple React versions seems the likely culprit.
 @Zacqary Yes, also: https://gist.github.com/jimfb/4faa6cbfb1ef476bd105
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 Thanks!
  I have this and more in #4846 which we'll get out shortly. We appreciate the effort though!
  No, this is probably unintentional.
  This wasn't the best API before and wouldn't always work then (if the node had another classname in between the 2 you specified, it wouldn't work.

This is unfortunate and I suppose we could make this better. We could also just revert #4058.

@spicyj I'm pretty sure I know your feelings here but should we make this work better since it is a regression?
 Wow, I don't know my feelings here. I guess I would probably make it actually work.
  You shouldn't be able to specify currentTarget; it should get set automatically to correspond to the event handler receiving the event. If that's not working then it's probably just a bug.
 Sorry for the delay here. currentTarget is set as the element bubbles and is always going to point to the DOM node that has the listener attached, no matter what element you dispatch the event to. Simulate does the bubbling like real events, so this can't be changed. So if you do

```
<div onClick={foo}>
  <span />
</div>
```

and do `Simulate.click(span)`, the div should receive a click event with `.currentTarget` pointing to the div DOMElement and `.target` pointing to the span. If that's not happening then there is a bug but if you are seeing this behavior then it is expected.
 Can you give an example of a component you're struggling to test?
 That condition can only be true if you add it to a ul like `<ul onClick={onClick} />`, and if you dispatch an event to that ul or any of its descendants, then `event.currentTarget` WILL point to the `ul` node when it bubbles up to the `ul` event handler.
 If you have onClick on the ul, then when you simulate an event on the li, `e.currentTarget` will point to the ul. Same as for non-simulated events.
 The target will always be the element that receives the event, and currentTarget will be the element that has the event handler. This is true whether or not you're simulating events. I'm not quite sure the use case you're describing. Maybe you could provide a code example?
 How are you simulating events on the option at all? It's not obvious to me how you would with that structure.
  RenderIntoDocument creates a div and renders into that element. The DOM is almost certainly unhappy in that case and moves things around resulting in that error. Using body is tough since it's only valid as a child of documentElement and I think we actually warn when you try to render there. You can try doing that.

Fwiw, this issue should not be new in 0.14 and ultimately I don't think we can do much for you - you're fighting the DOM.
 @graue Sometimes for SSR FPR, people want to render a body tag.  We generally discourage it, but it's a semi-common use case and is supported IIRC.
  cc @spicyj. Whatever happens here I don't think we want to take this into 0.14 - definitely sounds like a behavioral change from RC.
 Yeah, probably not for 0.14. @fabiomcosta just wants it internally.

Will take a closer look tomorrow, but you can (and should) get rid of the injection now and require the two modules directly.
 I think this change is minor enough that it probably doesn't need to be documented, but we shouldn't take it before 0.14. (If you need it at FB before then we can figure something out.)
 Names are fine as-is.
 Can you squash your commits together?
 We're already using this so I guess it is accepted in some form.
  Fixes #4929 

I left the couple places in tests where we set `nativeEvent.path` for whenever we decide to enable that codepath again.
 :+1: 
  Yea, don't worry about any unrelated lint issues.
 We could possibly bring this in tomorrow for 0.14 if we feel like it.
 :+1: 
  It'll be in 0.14 (due soooooooon).

@darobin if you have any issues building, file issues :) I know there are some funky things but we're love to make it easier.
  This is a little simpler (and a teeny tiny bit faster). The one in ReactCompositeComponent stays because of the way we create ReactCompositeComponentWrapper inside instantiateReactComponent.
 Fix ART etc. if needed.
 Ping @spicyj 
 Ping @spicyj - deadline is getting awfully close if we want this in the 0.15 milestone.
 @spicyj updated the pull request.
  Warn if ref attached to stateless component.  For background, see: https://github.com/facebook/react/issues/4936
  These are not truly separate yet. 0.14 is deprecating the DOM APIs but they are still there so that we can do this gracefully. I think the plan is to separate more / entirely for the following release.

As for React Native, there are still some special overrides happening there. We're working on getting that all working well but there are probably issues with using React Router there.
 Cool, going to close out in the meantime.
  Feel free to continue using `createClass`, it hasn't been removed nor deprecated.

This is a great topic for the discussion forums but is purely noise in our issue tracker, please move to https://discuss.reactjs.org/ if you'd like to carry on.
  > A component is never going to reasonably be able to know if a parent needs access to its DOM node.

That's exactly the point. A component should be able to define that its internal structure is opaque and outer component shouldn't mess around with its DOM nodes. In fact, it may chose to render null, multiple DOM nodes, nested nodes, change tags, render a Custom Element.

Therefore, `React.findDOMNode(ref)` in general is considered a bad idea since it breaks the encapsulation of the component.

There is another use case for refs of course. You can use them to call imperative methods on a class instance. However, that doesn't make sense on plain functions since they have no imperative methods associated with them.
 Haha, internally at Facebook we've had some long discussions about this, but it's true that we should find a way to highlight the discussions externally.  I really like your idea of having refs on stateless components throw/warn.  Just created an issue for that.

You are correct, the root of the issue is that stateless components don't have instances (for performance reasons, we may never instantiate the component).  There is no instance for us to return, because no instance was created.

As @sebmarkbage mentioned, findDOMNode breaks encapsulation and really is an escape hatch, so you need to be super careful with it anyway.  If you need to get a DOM node, you can always safely wrap a component (stateful or stateless) in a composite component, and then you can attach refs to the composite component.
 Technically we could have refs on these objects expose a placeholder object that can only be passed to `findDOMNode`.

However, I guess what is really going on is that I'm trying to constrain and discourage the use of `findDOMNode` because of its flaws. We couldn't kill it immediately because it is so frequently used, but once we have a new surface like this, we shouldn't expose more uses of it.

I guess we should be clear and honest about that. In the stress of a 0.14 release we didn't message this very well.
 > To which react offers no real good story for other then make ever single component that may need to be measured implement some sort of interface for this and how would you even do that?

The story is that the parent component can wrap whatever component they're trying to measure/position in a composite component, to which a ref can be attached.  The wrapper can just return the child and get the dom node by calling findDOMNode(this).  And the wrapper can even expose functions/abstractions (like `getMeasurements()`) to isolate the parent from touching actual DOM nodes, or expose the actual DOM nodes.  Ultimately everything is still completely within the control of the parent/owner, even if some third party implemented a component as stateless.
 Yea, that's not a great story though.

The full story is: We had to finally release 0.14 which was long over due and doing so we chose the most restrictive API because it is easier to go from restrictive -> loose than the other way around. It seems like a good idea but we can reevaluate if this is a huge problem.

I'd like to evaluate the use cases though. Parent context allow us to do some new ways of communication that can help this.
 @fabiomcosta https://github.com/facebook/react/pull/4943
 @vlinder Yes, that's a common strategy we recommend.  You don't need a DOM node in between.
 @taion It has been discussed (https://github.com/facebook/react/issues/4936#issuecomment-142384665).  It means you are creating instances, which means you loose out on the benefits of making them stateless functions in the first place.  Attaching refs is really more of an escape hatch anyway, and should be avoided to the extent possible.  People use refs more often than they probably should, largely because refs give them access to an imperative API, which aligns with the way they've historically been trained to write programs.  But if you get into the functional midset when writing React code, your life will be much easier.  Anyway, that's a whole other discussion.
 @taion I think you are missing the point / missing what @vlinder said.  You don't need to burden your users because you can wrap the user's component in your own stateful component, and attach the ref to your stateful component.  https://gist.github.com/jimfb/32b587ee6177665fb4cf

@jquense Yes, future optimizations.  No, it can't be a DOM node reference, because the referenced dom node could change when the stateless component rerenders, so it would need to be a handle to the component which could be updated by React as part of a rerender (aka: an instance).
 If we in the future allow multiple components to be returned from render, findDOMNode won't work. Likewise it might return null if a component chooses. Drilling through it using findDOMNode is really the thing we recommend against.

However, due to the artifacts of CSS it can be a convenient way to handle layout. Likewise focus can be useful. However, we're currently rethinking layout and focus and we should be able to handle that using React concepts alone in the future.
 > Right now refs are the only mechanism for reliable access to a child's DOM node, aside from annoying: findDOMNode(this).children[2].firstChild sort of stuff in the parent. 

Note that you can pass refs in props if you need this kind of access.

``` js
function ComponentWithInput({ inputRef }) {
  return <div><input ref={inputRef} /></div>
}

function Parent() {
  return <ComponentWithInput inputRef={input => input && input.scrollIntoView()} /> // or whatever
}
```

It‚Äôs breaking encapsulation but it‚Äôs pretty much an explicit equivalent of `findDOMNode(this).children[2].firstChild` which is breaking encapsulation in a worse way.
  cc @salier 
 > Firefox is crazy.

Every engine is crazy in its own special way üòâ
 @saifelse - could you rebase and squash the commits?
 Thanks!
  When using ref inside a child as a function, refs set inside the result of the function are undefined in the owner. Is this normal ?

``` js
class Container extends Component {
  render() {
    return this.props.children();
  }
}

class Demo extends React.Component {
  componentDidMount() {
    console.log(this.refs.inner); // undefined
  }

  render() {
    return (
      <Container ref='wrapper'>
        { () => (
          <Container ref='inner'>
            { () => <div/> }
          </Container>
        ) }
      </Container>
    );
  }
}
```
 @frederickfogerty Did not know about this, thanks, amazing.

@syranide I was thinking about this today and it became obvious that the owner in this case is Container, which is perfectly logical. Yes I know this is somehow tricky, I'll let you know how I use this and why.
 @frederickfogerty Any reference on this ? If I try, I get `Uncaught TypeError: Can't add property inner, object is not extensible`, with both 0.13 and 0.14.
 Okay, it seems you have to affect refs to a custom object instead of using this.refs, so : 

```
<Container  ref={ ref => this.containers.inner = ref }/>
```

@see https://facebook.github.io/react/docs/more-about-refs.html#the-ref-callback-attribute
 Yes, or even just `this._inner = ref`.
  cc @jimfb 
 @syranide is correct, there is a difference between DOM nodes and webcomponents (which are much more like React components).  For standard DOM nodes, we know a priori that there is no `className` attribute, so we can commandeer the namespace for our own purposes.  For web components, there is no such guarantee, so we can't steal the namespace.  In fact, web component authors may prefer `className` over `class` for the same reasons we stole it for standard dom components, and to remain compatible, we need to pass it through unmolested.

Another way of thinking about this: For standard DOM nodes, we conceptually have a react-component defined for each node, that happens to take `className`, just as we happen to take `defaultValue` for uncontrolled form elements and happen to use camel case for attributes.  We happen to follow some consistent naming conventions in our framework-provided components.  The fact that we do most of our markup transformations at the framework level instead of inside react-component definitions is an implementation detail.  Web component authors are free to follow those same conventions (or not), but we need to pass them through without transformations or we'll confuse the web components.

**TLDR: Custom elements DO work in React.  You must use `class` instead of `className` because the custom element spec requires that we allow users to specify a `className` attribute and we need to preserve that functionality for custom elements.**
 @hellosmithy Using a component with a dash _is_ the escape.  As per the specification, a node with a dash in it may have arbitrary attributes defined.
 Semantics.  Custom element is a subset of the web component specification.  We use the term "web component" loosely, but I believe the statement holds if you replace "web component" with "custom element"; namely that the custom element may define arbitrary attributes and process those attributes using arbitrary rules.
 You'd have to special case/escape a whole ton of attributes including every possible camelcase attribute that could ever (past, present, or future) occur on a native DOM component, not to mention dealing with event handlers and other complexities.  It would not be as simple as escaping a couple special-cased attributes; the rules would be complex and confusing (certainly more so than the current attribute whitelisting) - I can't see a way to do such a thing in a way that's better than what we currently do (pass attributes straight through).
 @hellosmithy I can't see how to make it work in a way that's better than what we currently have.  If you have an escaping solution that you'd like to propose, we'd be happy to take a look.

The constraints are:
- Must allow people to specify all possible attributes in a case sensitive way.  Users must be able to specify any combination of `class` and `className` (zero, one, or both).  Users must also be able to specify any combination of `onclick` and `onClick` (zero, one, or both).  This is because custom elements can impose arbitrary processing rules on their attributes, and case sensitivity matters.
- Must be intuitive for users.  Ideally, the first thing people try should work.  If it doesn't work, users must have an obvious "next step" to try so they can fix their code (ie. what happens when an attribute they wanted to use gets rewritten?  do they get a useful error message?  how do they intuitively know what to try next?).
- Must allow us to do basic sanity checks (like preventing/mitigating XSS attacks) in a way that minimizes the impact on performance.
- Should not require modifications to the JSX syntax, which is already becoming a defacto standard as other languages/editors/IDEs/parsers understand and implement the syntax, so any changes would break all of them.  You can read the specification here: https://facebook.github.io/jsx/
- Should play nice with #140 and futureproof us from maintaining an ever-growing whitelist as browsers add new elements/attributes.
 **To be clear: Custom elements DO work in React. You must use the `class` attribute instead of `className` because the custom element spec requires that we allow users to specify arbitrary attributes (including `className`) and we need to preserve that functionality for custom elements.**

There is no conflict with Sebastian's comment in https://github.com/facebook/react/issues/5052#issuecomment-145594782.  Web components are NOT our primary use case, but we will still do the best we can to support the DOM technologies for anyone who wants to use those technologies.  Same goes for custom elements.  This is why we've added support for them, while consistently recommending you use React composite components instead.

If someone would like to propose a solution that is better than the one we've implemented, subject to the [constraints I mentioned above](https://github.com/facebook/react/issues/4933#issuecomment-143836508), we'd be more than happy to take a look.
 @gargantuan That does not allow custom elements to play as first class citizens.  You've effectively turned React into a templating system at that point because your AttributeEscape component destroys the virtual dom.  You are eliminating React's ability to do diffing (because you convert the virtual dom to dangerouslySetInnerHTML), eliminate the ability for the parent components to make decisions based on the children, eliminate the ability to attach refs and event handlers, etc.
 @gargantuan as per my comment above, it means that elements within AttributeEscape will not play by the vdom rules.  This DOES break lots of things.  And it's a huge problem if your render tree has an AttributeEscape with an arbitrary tree of children placed inside.
 I think the primary motivating factor for allowing something is simply to make it easier once you hit an edge case where you need to consume a custom element and wrap it somehow.

We have escape hatches that you're not supposed to need but still might need for practical reasons.

> On Oct 7, 2015, at 3:42 PM, Ben Smith notifications@github.com wrote:
> 
> @jimfb the solution suggested by @gargantuan is one option, with it's own merits and considerations.
> 
> The point being made here by me and several other commenters is that the RC1 changes related to custom elements also have their pros and cons and should also be justified to the same stringent standards you are requesting for alternative solutions. Several of us have raised concerns related to consistency, backwards compatibility, explicitness, and developer control. Specifically there are concerns about attributes such as className and all of the React events such as onClick, onDrag etc, which will behave in unexpected and non-declarative ways with the proposed RC1 changes.
> 
> I think the point being made here is that the proposed changes at jimfb@b1db817 require some further consideration.
> 
> Given that "the primary component strategy for React will never be Web Components."...
> 
> If it were up to me, I would apply the following constraints:
> 
> Must not break existing React behaviour with regards to events and React attributes such as className and React events.
> Users must be able to explicitly specify when they want a DOM elements attributes to be controlled outside of React.
> Should be explicit and declarative
> Now I appreciate that there has been a vocal request for the ability to support web components, and specifically to allow attributes to be passed through to them. However I would appeal to your better judgement to consider, is this change really the right solution?
> 
> Lets not forget, we are not suggesting to add a feature here, but in fact to hold off form hastily adding in a change without due diligence.
> 
> ‚Äî
> Reply to this email directly or view it on GitHub.
 @hellosmithy If you have a better solution, please do propose it.  But please consider that we really did spend an enormous amount of time discussing options&alternatives; this was not a spur-of-the-moment change.  We can't hold back all development for an indeterminate amount of time.  At some point, we need to bite the bullet and make changes in order to make React better.  Ultimately it's just code, and there isn't anything that can't be undone if we find something better in the future, but we did do our due diligence in this case.

If you have a **solution** that you think is better, let us know.  We implemented the best thing we've seen to date, but we're always open to new ideas.
 Using native attributes (instead of the react flavors) for custom elements is the best solution we've seen.  Better event support is still planned, but was blocked by a couple of browser bugs that prevent us from supporting them reliably.  Event support is tracked by several other issues, most notably https://github.com/facebook/react/issues/4751.
 Yes. We need a way to render the nodes themselves somehow so that nested React children can work correctly.

It is not possible to map props properly. The only thing that we can safely map automatically is attributes. The rest have to be applied imperatively. So we could either allow no props or at least do attributes automatically.

It turns out that a lot of custom elements work with attributes alone. So it seems like a decent trade off.
 If you don't use custom elements then you're not affected.
 Yea, you just have to manually recreate those properties on your components. Sorry. There has been some talk about making these special behaviors composites instead of built-ins but that doesn't seem likely short term.

With a custom element you can probably do better and avoid some of the weird special cases that browsers have to deal with.
 @gargantuan I'm having trouble understanding what you mean, sorry. FWIW, we recommend you use the React dev tools when debugging React apps because they show the React component structure. If they don't fit your workflow for whatever reason, maybe we can fix that instead.
 > I think that focusing on the React Dev tools to fix the shortcomings introduced by making custom-elements second class citizens would be over engineering.

Now I'm really confused as to what you mean.  Second class citizens in React or second class in the browser?  All React does is render the elements, with all the attributes, as they're passed in.  What happens after that point, in the inspector view, is outside React's control.

The issues you listed above sounds like general React devtools issues, which should probably be tracked in https://github.com/facebook/react-devtools
 @gargantuan I'm still having trouble understanding exactly what your specific complaint is here. I'm not an expert in web components so please forgive me if this should be obvious. Is the issue only that you could previously write

```
<my-x className="foo" />
```

and now must write

```
<my-x class="foo" />
```

instead? Am I misunderstanding completely or just missing something else that has changed?
 I can assure you that the changes made to how custom elements work in 0.14 were intended to make them more useful, not less.
 As I mentioned earlier in this thread...

> Better event support is still planned, but was blocked by a couple of browser bugs that prevent us from supporting them reliably. Event support is tracked by several other issues, most notably #4751.

We want to support events on custom elements - that is on our todo list - but there are some nuances regarding custom-element events that need to be considered and handled properly, and some browser bugs/inconsistencies that were making that infeasible.  The current workaround (until events on custom elements can be officially supported by React) is to attach a `ref` and add the event handlers imperatively.

gargantuan, regarding your prior post, you said:

> @jimfb... It's clear that you don't see the merits of custom elements...

Please keep these comments in check; you weren't in the room when these topics were being discussed, and you couldn't be more wrong on this particular point.  If you were at our developer meetings, you would see that I've been the strongest proponent of custom elements.  You would see that I've been pushing incredibly hard to provide custom element support.  You would see that I'm always pushing to keep React as compliant with the new web standards as is humanly possible.

We make every attempt to listen to all the feedback and continue to improve React to meet everyone's needs, but you need to understand that custom elements are still considered an [experimental technology](https://developer.mozilla.org/en-US/docs/Web/Web_Components/Custom_Elements) and the details are much more nuanced than you might expect.  When browsers start to converge on the semantics, we can re-introduce some of the diffs that fix the rough edges.
 @hellosmithy Yes, it was considered.  That approach does not meet constraint numbers 2 and 5 from https://github.com/facebook/react/issues/4933#issuecomment-143836508
 This thread has been going on way too long, and is circling back to points that I've already made previously in the thread.  I don't think it's useful to keep rehashing this issue.
1.  Rendering exactly what the user typed is intuitive because a user can type `className`, see that it literally outputted `className`, and then try `class` (because, well, it appears to be outputting exactly what they typed) and see that it works.  It doesn't take long to realize the pattern that custom elements get outputted directly, but even if you do miss the pattern, you'll quickly arrive at the correct solution through a single trial-and-error attempt.  With an escaping solution, you would type `className`, it would get rewritten to `class`, and you would not have any intuitive way of knowing that the magic escape prop you need to use is called `setAttrs`.
2.  No, the whitelisting would be extensive.  You would need to whitelist `className`, `htmlFor`, `value`, all the other dom attributes that have boolean values and/or otherwise behave in intelligent ways, all the dom properties that would need to be applied as a property instead of an attribute, all the various dom event handlers, etc.
 Ok, I think it's time to call it a day.  We've had a pretty good discussion, but this conversation is looping back on its self and is past the point of being productive.  The thread is just rehashing points that have already been made.  I think we fully understand the concerns mentioned in this issue, and we will update the thread when we have new information to provide.
  I don't think we want to add this. Thanks for sending in the idea though.
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 Cool, thanks! I'll update the tutorial repo as well to match.
  I dug into this for like half an hour and couldn't figure it out. Very weird.

cc @zpao @syranide 
 `e.preventDefault()` in your `change` handler is doing this. We have to actually hijack the `click` event to make `onChange` work for radios and checkboxes. The downside of this has come up a few times - that `preventDefault` in there actually prevents the browser from updating its state. See some prior discussions in #3005.

You don't actually need to call `preventDefault` here, and we've actually seen a lot of people blindly calling it without actually knowing why. I would recommend doing a spot check of your own handlers and seeing if they're actually needed throughout.
 @zpao Thanks.
  I believe you'll already get a warning in 0.14.
  Our build process sort of resembles Frankenstein's monster at this point. My bad. We shouldn't shell out to gulp from grunt and move utils out to `fbjs`.

@zertosh is already working on this.
 Once I wrapped my head around it, I just found gulp to be easier to work with. The streams match up better with the way I was thinking about the process. We'll likely lose a couple of the nice things (like the `compare_size` task which was easy to configure and throw in) but we'll survive. A couple things also probably make more sense as explicit npm scripts. We'll see. The other goal was to align our open source tooling and others were interested in using gulp, which helped force us to look into it.

Both are great tools, we're just doing what hopefully will make the most sense for us.
 @zertosh - do you have anything in progress to point to or would it be ok for @nickdima to pick this up?
 Awesome, thanks @nickdima. The build process started out nice and clean 2.5 years ago but it's gotten unwieldy and confusing. I have a lot of the blame there so let me know if you have questions.

Please make use of gulp & the scripts we have in fbjs-scripts and go from there. npm scripts are definitely useful but let's mostly reserve that for one-offs and aliasing and otherwise use gulp. This is technology we're aligning on across our open source projects to reduce the project specific code and make it easier for each project to start and improve. Feel free to make any requests here and I'm happy to help.

I suspect that Babel won't take that PR but I could be mistaken. It could be useful but we've already solved that problem so I don't think it's too important in the grand scheme of this task.
  Hmm, there's whitespace in your text area‚Ä¶

@spicyj @syranide - does this have anything to do with that newlines thing in text areas we did a little while ago? Or is that a red herring
 No comments for over a month, closing.  If you believe this is a bug in React, please try to provide a simplified jsfiddle/example that demonstrates the problem and we can reinvestigate.
  In that case you probably don't want to use `renderIntoDocument` - that's just a convenience method for testing that covers 80% of what people usually need. I don't think we're going to change this as it's trivial to implement - you can do exactly what it's doing and just hold a reference to the new node.

``` js
var node = document.createElement('div');
var component = React.render(<Component />, node);
// ...
React.unmountComponentAtNode(node);
```
  There is not a guide at this point. We're still working out the details and the story about how to do it.

I'm going to close out since there's nothing really actionable at this point, we'll definitely put something up when we're ready.
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 looks like a good addition, thanks!
  I'm going to close this out, in favor of tracking it via the issues @syranide linked.  Thanks.
  We've generally said no to a lot of custom proptypes checks but this one feels like it's probably ok. In theory it's a 1 line change. However we aren't applying the [Symbol transform](https://babeljs.io/docs/advanced/transformers/es6/spec-symbols/) (which changes all `typeof` checks) so we'd have to do something similar with the type (already have that in place for `RegExp`s and old browsers) - not hard but just a little bit more work.

Thoughts @sebmarkbage @spicyj 
 Yea. Seems reasonable. The .constructor === Symbol as a fallback is ok. Not ideal since it doesn't work cross-realm but we should use whatever is standard practice among popular polyfills. 
 Yes, we just never got back to it. If you're interested in working on it, this is something that would make a nice addition in 15.1.
 GitHub doesn‚Äôt make it very obvious :cry: 

Usually when people start working on a feature they reference it, and it appears in the issue.
You can see the existing PR above:

<img width="969" alt="screen shot 2016-03-31 at 14 20 27" src="https://cloud.githubusercontent.com/assets/810438/14176981/d4e98eb0-f74b-11e5-99a5-ba119fc32ef6.png">
 Also, you can't assign issues to people who don't have commit access, making it much harder to communicate that somebody outside the core team is working on it.
 We‚Äôre still ironing out how we‚Äôll move on with cutting branches on 15.x but once it‚Äôs decided I expect this to get in.
 Looks like #6377 was merged. Should be in 15.1 or 15.2.
  React doesn't do the transformation but feel free to file an issue against babel. If there's something React needs to do differently we can reopen.
 You shouldn't minify in development mode anyway.
 @silvenon I wouldn't recommend it. Why not compare the type to the object exactly?
 @dminkovsky I haven't tried but I would expect that to already work?
  Assuming we keep this behavior, it's worth noting in the documentation that React.render() may return null in cases where the component doesn't have any instance state.
 (removing "good first bug" since this would be best done by somebody with more knowledge about React)
 Correct, thanks!
  Yes, just the number of times the component was created.

![image](https://cloud.githubusercontent.com/assets/6820/10087859/8183a87e-62cb-11e5-903b-6a1648d4fa9c.png)
 Because the current implementation is buggy. In reality it reports the number of times `render()` has been called. This is being fixed in #6046. Since that code is being rewritten completely we won‚Äôt fix it in the existing version. 
  This is not the error you threw, but it is a second error that gets thrown later because React (currently) doesn't gracefully handle thrown errors (#2461).

As for why you're not seeing the first error, something else is catching the error ‚Äì probably promises are getting you. See http://blog.taylormcgann.com/2014/08/21/catch-errors-javascript-promise-chains/. (dupe of #2912 and several others)
  In 0.14 you should get the component name but it is also a hard error that will break your app. This would have been good for us to do but we're not planning another 0.13 release ‚Äì sorry.
  We changed this in 0.14 so you have to specify a duration now. #1326 
  Please investigate your case further. This message is somewhat unreliable at pinpointing the problem so it's likely elsewhere in your app.
  You have a mistake in your code. You have `onEnded={this.onEnd}` but `this.onEnd` doesn't exist, it's `this.onEnded`. When I change that your code is logging fine (Firefox 43, Chrome 46)
  I think I've seen this when setting `process.env.NODE_ENV` at runtime. Are you by chance doing that?
 Ah, I was thinking of something else. In this case the `inlineElements` transform isn't compatible with the dev version of React (which you're running by default on the server but you can force it into prod mode with `NODE_ENV=production node app.js`).

I'm going to close this and point you to #3285 which also brought this issue up and we have slated to fix up before 0.14 goes final.
  Fixes #4841
 I realized over the weekend that if we remove `react-dom` from `dist/` in the `react` package, we're probably going to have to have 2 packages on [cdnjs](https://github.com/cdnjs/cdnjs/blob/master/ajax/libs/react/package.json#L17-L25) and [jsdeliv](https://github.com/jsdelivr/jsdelivr/blob/master/files/react/update.json)‚Ä¶

Thoughts on leaving `react-dom` in the react package for now (and putting it into the new package as well)?
 Ultimately there should be no trace of `react-dom` left in the `react`package. The PR as it stands now takes that step for the UMD build, removing `dist/react-dom.js` from the `react` npm packages and putting it into the `react-dom` npm package. This lines up with what we've done for the the rest of the npm packaging but would make it more difficult to use React in some cases.

Right now the CDN autoupdaters maps libraries on their end to a single package on npm (or bower is possible too I think). That means if we do remove `dist/react-dom.js` it won't show up on https://cdnjs.com/libraries/react/ and we'd have another library on the CDN (eg https://cdnjs.com/libraries/react-dom).

I'm not sure what you mean by keeping the library authors in mind‚Ä¶
 @gaearon See #4814 for the addition of `dist/react-dom.js`. We're sidetracked from the point of this PR but I'll explain it since we're all here anyway.

`dist/react.js` - The same as it was before. But as with `require('react')` in node, this will warn when using deprecated APIs, eg `React.render`.
`dist/react-with-addons.js` - Also the same
`dist/react-dom.js` - This exposes a new global `ReactDOM` with the APIs there without warnings (`ReactDOM.render`). _With 0.14 it requires that either of the 2 above files are also already on the page (because shared state and all that fun stuff)._ This is the reason we added `__SECRET_DOM_DO_NOT_USE_OR_YOU_WILL_BE_FIRED` ([we didn't trick you](https://twitter.com/dan_abramov/status/644283294960472064)). In only has the APIs that `require('react-dom')` has.. This should place nicely with UMD (you can see the wrapper in the above PR). **This is the file in question in this PR**.

> This confuses me because `react-dom` NPM package is just a link now (for compat reasons) and I expect the actual move to occur with 0.15.

I hope the above makes it clear that the UMD build is also just a link right now with the plan to separate better so that this isn't the case.

> Do libraries whose UMD builds currently depend on `react: 'React'` need to adjust for 0.14?

The don't need to, _but if they are using deprecated APIs they may want to_. In that case `react-dom: ReactDOM` would need to be added to that externals map and you would tell users to have both files on their page.

Does that all make sense?

> I'll happily wait for 0.14 to actually figure this out.

Noooo that's why we have RCs, to try to get this all sorted out before we screw it up :wink:. If we ship and you tell us we did it wrong after the fact, then that's no good.

---

So the root of my question was just what to do with `dist/react-dom.js` - should it stay in the `react` npm package and duplicate it into `react-dom` package or if it should exclusively be the `react-dom` package and see what we can do about CDNs?
 I thought cdnjs used our bower package. If it doesn't, I think it can.
 (y)
 cdnjs can use github or npm. Using github is exactly how bower works anyway so yes that's possible.
jsdelivr can use github or npm or bower. Also possible.

**edit:** it's not clear how these will picks versions‚Ä¶ both are using npm right now and seem to just use the `latest` tag as the source of truth. Using our bower repo will be interesting if they don't pre-process the versions to look for "stable-ness" like bower does. (eg, would rc be the default when looking at the React page?)

Based on that response you're saying "remove it from `react/dist`" and get the CDNs to update differently.

Eventually we may want to stop doing that so we can version these things separately. Then we would want multiple CDN packages. But we can cross the bridge later.
 Oh, I had sort of assumed this did remove from react/dist. I guess not‚Ä¶
 It does - that's the change in `grunt/tasks/npm-react.js` (I've done a terrible job of communicating what's happening)
 Alright, jsdelivr already merged their change. I don't expect problems with cdnjs. So I'm going to merge now and if any issues arise, it's just code and we can change it.
  Please contact `legal@fb.com` with your concerns, we won't be having more patent discussions here.

FWIW, note that the patent grant was updated between v0.13.0 and 0.13.3 (https://github.com/facebook/react/commit/78cca021f3cf203f0452e940f03d3eb1ab46cfeb) and the language was refined - more on the topic: https://code.facebook.com/posts/1639473982937255/updating-our-open-source-patent-grant/
  Thanks! Heads up: we should have a number of changes coming up in the near future as we prepare for launching v0.14. So there will always be more translations to do if you're interested :)
 We're going to do an overhaul of the underlying technology (and want to do it across our projects). Improving i18n support is very important for this (I have some in-progress work for that using Jekyll in #4633) which we may just use before switching underlying tech. I'd prefer you didn't do that yourself but would be interested to hear your thoughts.
  If you have more issues with React Native in the future, please file issues in their repository - https://github.com/facebook/react-native. Thanks and good luck building you apps!
  If you're using 0.13, this is almost definitely fixed in 0.14.
 (If not, please post a repro case so I can debug.)
  `npm` is treating rc1 as a prerelease even though it's stable. We haven't removed the old version of the package so it still gets install since it's "stable".

I just added a deprecation notice on npm so you'll see this in the future:

> npm WARN deprecated react-dom@0.1.0: The old react-dom package has been deprecated. Until React v0.14 is officially released, please installed react-dom with npm install react-dom@latest

So just run `npm install react-dom@latest`
  What @iamdustan said. You're handler is getting called but if you don't prevent the default behavior of the browser (navigating) then it doesn't really matter.
 I'd be very interested to see a test case showing onClick not getting called. I can't reproduce the issue you're reporting.
  @zpao I assume this is ready to merge?
 Yea, can we squash to a single commit?
 Thanks!
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 Thanks!
  What you want is https://github.com/facebook/react/issues/2127

You can modify your function above to be:

```
  render: function() {
    try { return React.Children.only(this.props.children); }
    catch(e) { return <div>{this.props.children}</div>; }
  }
```

Which isn't perfect by any means (for one thing, try-catch blocks are a slow path), but it's probably the closest you can come without returning multiple elements.  It'll handle the single element, and best effort for multiple elements.

Closing as a duplicate of https://github.com/facebook/react/issues/2127, feel free to continue the discussion here.
 You're right that it's not a straight duplicate but making that work would allow what you want. And the root of what you're describing is to return 1 or more items from render, so I think it's covered by the same thing.

In our experience doing this we've effectively said these container components must have a single child and that's the only way they will work, so they use `React.children.only`. Relay makes extensive use of this idea. See [react-static-container](https://github.com/reactjs/react-static-container/blob/master/src/StaticContainer.react.js) for example.

That doesn't work with your table example so that's a trickier case and we would probably just say "make the whole table a standalone component / wrapped in the container".
  Good catch, thanks!
  Good catch, that should point at http://facebook.github.io/react/tips/dangerously-set-inner-html.html. I'll fix it in a little bit.
 Fixed. Thanks again for the heads up.
  Stateless components have no public instance (return value of `renderIntoDocument`). If you were to wrap it in another (stateful) composite then you could use that instance.  There is some relevant discussion in https://github.com/facebook/react/issues/4839.  At this point, I think we're going to keep this behavior.  I created an issue to document it: https://github.com/facebook/react/issues/4913
 @happypoulp That might just be a different issue. Can you open it separately?
 Actually never mind we can use this one.
  Yeah, perhaps we can add a warning for this (until we fix #4592).
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 Thank you for the PR! Now that #5714 is merged, all attributes on SVG elements will be passed through as is, with no need for the whitelist, so I'm closing this.
  Please us other venues like https://discuss.reactjs.org/ for discussions like this.
  Inheritance also includes "static" properties. I.e. properties on the constructor.
 Try `Object.assign(ReactSWF, React.Component)` first.
  Looks like your fontSize is getting set to NaN. If you have it as any other value then you won't get the warning.

We can probably have shallowEqual treat two NaNs as the same.
 ``` js
JSON.stringify({a: NaN}) === '{"a":null}'
```

So I'm willing to bet @spicyj did his debugging right :)
 Sure, I'm saying the language doesn't make that easy for us to do. `NaN` doesn't have a representation in JSON. We _could_ sub in `"NaN"` when stringifying and trade one lie for another - maybe that's not as bad as `null` but it's still a lie since the value isn't a string either.
 @thanzen We could probably make an error message that is a bit more informative (https://github.com/facebook/react/issues/5773), but specifying a margin of NaN seems like it should always be an error/warning.  Can you elaborate on what you mean by  "I have no access to marginLeft prop directly"?  If you mean you are using a third-party component that sets the property incorrectly, that component author should fix the issue.
 @jimfb Tangential, perhaps we should explicitly warn whenever `NaN` is passed to a style, it's wrong and very obviously a user error (but not always easily spotted).
 @syranide https://github.com/facebook/react/issues/5773 :)
 @essekia You added fontSize: 15px. You need to create a new style object instead of changing the existing one.
  (not sure we'll fix this for 0.14 but marking the milestone to remember to investigate)
 As far as I can tell, none of these are regressions in 0.14 so we'll fix them in a point release or after, not before 0.14.0. Can you post repro cases for these errors? It's difficult for anyone to look into fixing it otherwise.
 I already said in my comment that we wouldn't fix this before 0.14. We can look at this for 0.14.1.
 Since it was merged after 0.1.4.2 was released, no.
 We fixed the issue that I knew about in 0.14.3. If you can post a small example that repros the problem we can see what else is causing this.
  We've had a huge number of issues come in here and in the tutorial repo about inconsistencies and confusing parts, especially when it sort of works fine without a server initially and then requires it half way through. We've talked about maybe rewriting it entirely and maybe we will, but in the mean time we should clean it up and make it easier for people to learn React without getting tripped up

Any ideas are welcome, especially from people on the front lines (mailing list, IRC, Slack, Stack Overflow, GitHub)

A couple ideas:
- Provide a running API server that people can use (probably with a randomly generated API key to make sure people have their own clean environment)
- ~~Just require a local server from the beginning~~ Done!
- Remove the `tutorialN.js` bit
- Paginate so that steps are separated better
 It would probably require a bit more effort, but yea, I think something like that could be really cool.
 > What are people's thoughts on dropping jQuery in favor of window.fetch?

I was sort of against it when that was proposed before (it was actually the 2 of you in #3498) but meh. I'm game. We'll still have to include a polyfill but at least it's focused. My only concern is that Promises will probably be a new concept to a number of people who might not be paying close attention to JS. I think we should be ok, but wanted to mention it.

> What do you think about moving the tutorial to be a directory within the actual React codebase?

Definitely upsides and downsides. Things don't change _that_ often and while cloning the whole React repo could be good, I don't really want to put that on people. Having a pretty clean place to start is nice.

> how about having more than one tutorial?

On board with that too, just need to figure out what they should be :) Fits in nicely with the knockout idea too.
  A bit blunt but that's ok üòâ, thanks!

(any other feedback you might have for the tutorial, please let me know in #4875)
  I think the official recommendation at this point is to have a top-down data flow, rather than having components manage their own data requests.  That is to say, all the data a component utilizes should be passed down from the parent.

That said, we do acknowledge that sideways data loading is a hammer that we want to provide.  Duplicate of https://github.com/facebook/react/issues/3398 and https://github.com/facebook/react/issues/3858
  I added a deprecation notice on npm for v0.1.0. In the mean time just run `npm install react-dom@latest`.
  Note that this simulates the ES Value Types proposal which would allow you to do:

``` js
var symbol = typeof element;
```

It is our hope to be able to make these Value Types and therefore overloaded interfaces are not ideal.

Additionally, overloaded interfaces are not good for VM optimizations since current VMs optimize heterogeneous function signatures very poorly.

In fact, we considered using a symbol for the `$$typeof` name (e.g. `{ [TYPEOF_SYMBOL]: REACT_ELEMENT_SYMBOL }` which is different than what you're proposing but still better). However, the perf just isn't there:

http://jsperf.com/constructing-symbol-props

(One of several examples, the rest are on Twitter which is down for me now.)
 I'm hoping that `$$typeof` becomes the canonical name to polyfill value types like objects similarly to how `@@iterator` is used to polyfill the iterator hook.

As for multiple `virtual-dom`, yes, I'm hoping to be able to find agreement on a common interface. We're not quite there yet but I'm working hard on removing React specific pieces from this interface piece by piece in hope of eventually being able to unify.
  cc @spicyj 
 I haven't decided how best to fix this. You can see I already marked it for the 0.14 milestone though.
  :thumbsup: thanks!
  Awesome, thanks so much!
  There are reasonable situations where users might want to have the nulls when mapping over elements, and it seems bad for map to skip elements.  Implementing filter as mentioned in https://github.com/facebook/react/issues/2956 would be the better solution, if we were to do such a thing, but filter does have its own set of issues as mentioned in the bug.  Specifically, the effects on reconciliation performance.

Closing as a duplicate of https://github.com/facebook/react/issues/2956, since that solves this use case and is tracking the use case.
 The new toArray removes nulls, btw.
 @yordis See syranide's comment: https://github.com/facebook/react/issues/2956#issuecomment-72001075

Basically, by preserving the nulls in the array, you preserve the implicit keys that React uses to track instance identity.  This ensures that the state of stateful components gets properly preserved when items are added/removed from the list.  It's a fairly advanced topic, but it's a valid use case.  The fact that nulls aren't removed from map means it "accidentally" works more often for people who aren't familiar with how implicit keys work.
 @jimfb That's not a real concern since things get rekeyed by React.Children.map.
 @spicyj Since React.Children.map rekeys, do we want to reopen?  My intuition is we should retain nulls, since that's how array.map works and I don't see adding a null-check as that burdensome, but I did close under the understanding that retaining nulls was advantageous for reconciliation but apparently that's not necessary, so I'm fine with reopening if you think this is something we might do.
 Sure, we can. It's hard to imagine what could break. I guess it would be kind of weird if you have a component like `<LeftRight>{a}{b}</LeftRight>` if a/b could be null.
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 cc @cpojer 
 Thanks! This was built before we used nomnom in jscodeshift :)
  This invariant was new in this release. We also hit one case at FB that I haven't yet investigated. Probably need to change something for the final release.
  Thanks, @andreypopp.
  @towry I can't repro this with your example in 0.14.

@trusktr re `_.map`, use `React.Children.map` instead, it'll handle the abstractions for Arrays and what not for you.

And try dropping the `key` inside the map - that could be screwing things up and I don't think you need it.
 In 0.14 these will preserve state, as the warning message sort-of implies.
  I tested this with arrow functions in Chrome (just modified the non-transforming basic example).

We could simulate part of the issue with arrow functions in the test (undefined prototype), but not the newable part. So we'll want a proper test when we can switch to node 4 and have some tests that don't transform.

Fixes #4856
 cc @sebmarkbage @spicyj 
 That's a good point. We won't be able to test at all in that case but perhaps that's ok‚Ä¶
 Native `fn.bind()` also gives you a prototype less function. Should be able to use that to test even with transform and older VMs. 
 Updated for comments. I didn't say it in a comment but I explicitly used `.bind` instead of of using an arrow function and letting Babel transform since we don't know what that will do (right now it's not high compliance mode so won't actually call `.bind`)
 lgtm 
  Sorry, I missed this!
  Hmm, that doesn't sounds good. It's because we `new` it up before falling back to assuming it's a stateless component. Maybe we can check for `Component.prototype === undefined` before `new`ing in [`ReactCompositeComponent#mountComponent`](https://github.com/facebook/react/blob/master/src/renderers/shared/reconciler/ReactCompositeComponent.js#L139-L153) cc @sebmarkbage @spicyj 
 Babel doesn't polyfill that. In 0.15 we will check that it extends React.Component before newing. We can't do that yet in 0.14 because we didn't warn about not extending until 0.14.

> On Sep 12, 2015, at 4:33 PM, Paul O‚ÄôShannessy notifications@github.com wrote:
> 
> Hmm, that doesn't sounds good. It's because we new it up before falling back to assuming it's a stateless component. Maybe we can check for Component.prototype === undefined before newing in ReactCompositeComponent#mountComponent cc @sebmarkbage @spicyj
> 
> ‚Äî
> Reply to this email directly or view it on GitHub.
 I guess checking for undefined in 0.14 would be reasonable as an intermediate step 
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 @iamchenxin Thanks!
  I would just add an empty option with `value=''` then everything will work without any extra work.
  I don't think we'll do this but we'll keep this sort of change in mind as we update the tutorial.
  Yea, that looks a bug to me. Looks like we could get away with just escaping the `\r`, at least on Firefox on OS X. It's probably safer to escape `\n` as well.

At https://github.com/facebook/react/blob/master/src/renderers/dom/client/ReactMount.js#L920 `targetID === ".1.$\r\n"` but `childID === ".1.$\n"`. Escaping both of these in traverseAllChildren worked for me (haven't written a test for it yet though so if anybody wants to jump on that).

@spicyj this isn't a regression, but should we take this fix in 0.14?
 Note: I took the test @ikeyan wrote above and pulled it out of React to do pretty much the same thing. It'd definitely DOM thrashy (sorry for the slow run times) but should give us a good idea. It looks like we'll be ok with just adding `\r\n\0` - the higher codepoints as referenced above are outside of what will realistically happen (and we could deal with them later if we really need to). I could probably drop to a lower number in the test to speed things along‚Ä¶

@smonev Thanks btw! That's exactly what I was looking for. Hopefully IE11 doesn't deviate too much.
 I just ran it in IE8 under wine and got:

```
DONE! 43 failures reported

FAILED: codepoint=64976
FAILED: codepoint=64977
FAILED: codepoint=64978
FAILED: codepoint=64979
FAILED: codepoint=64980
FAILED: codepoint=64981
FAILED: codepoint=64982
FAILED: codepoint=64983
FAILED: codepoint=64984
FAILED: codepoint=64985
FAILED: codepoint=64986
FAILED: codepoint=64987
FAILED: codepoint=64988
FAILED: codepoint=64989
FAILED: codepoint=64990
FAILED: codepoint=64991
FAILED: codepoint=64992
FAILED: codepoint=64993
FAILED: codepoint=64994
FAILED: codepoint=64995
FAILED: codepoint=64996
FAILED: codepoint=64997
FAILED: codepoint=64998
FAILED: codepoint=64999
FAILED: codepoint=65000
FAILED: codepoint=65001
FAILED: codepoint=65002
FAILED: codepoint=65003
FAILED: codepoint=65004
FAILED: codepoint=65005
FAILED: codepoint=65006
FAILED: codepoint=65007
FAILED: codepoint=65520
FAILED: codepoint=65521
FAILED: codepoint=65522
FAILED: codepoint=65523
FAILED: codepoint=65524
FAILED: codepoint=65525
FAILED: codepoint=65526
FAILED: codepoint=65527
FAILED: codepoint=65528
FAILED: codepoint=65534
FAILED: codepoint=65535
```
 FYI
55296 is `U+D800` which are non private use surrogates, range `D800-DFFF`
64976 is `U+FDD0` which are non-characters, range `FDD0-FDEF`
You also have two additional non-characters `FFFE-FFFF`

These should be the only ranges that are unsafe from a unicode perspective.
 PS. These should probably replaced by `FFFD`. However I'm not convinced this is something that should be fixed by React (expensive and exploitable behavior), this should be part of your sanitizing procedure that should prevent these from making it through at all.
  It actually does, just comes with a warning telling you to use the new one. We did this for all of the addons, so I'd prefer updating docs for them all in a single pass. Would you be interested in doing that?
 Closing this one.
  Partly just because no one asked for it. We won't do this for 0.14 but it's possible we could for the next release.
 @spicyj I'm not sure if this is a good idea, unless we plan to drop keys from SSR, because there is no way to serialize the symbols.  We want components to be as isomorphic as possible, and this would break that for no good reason.
 @jimfb keys don't appear in the DOM so it should be fine.
 @spicyj They don't?  Aren't they part of the react-data-id when doing SSR?
 Not any more.
 We do still use them internally though as strings I guess.
 Well :hankey:, that's :fire: 
  ![default](https://cloud.githubusercontent.com/assets/13243/9842121/4e7fff4c-5a5e-11e5-849f-3bfb03495239.png)
 Looking for feedback and additions @yuzhi @yungsters @josephsavona @wincent @kassens.
  Can you provide more info about why componentWillMount doesn't work?
 As for changing the order, that's a non-starter. `componentWillMount` is right before render (`componentDidMount` is right after). You can call `setState` in cWM. Generally we've said that other initialization happens there, usually it's the fetching of data from other places (which might be synchronous, which is why setState here affects initial render).

It's not clear what "some code" or "cleanup" is so it's a little hard to understand what use case you're trying to solve.

One option is to use ES6 classes - you can make use of the constructor for anything else in addition to setting of initial state.
 Closing until we hear more. If you do want to discuss more, a code sample would help.
  It includes the display name, which in your case looks to be "index". I don't know of anything we can do better.
 The Babel `react.displayName` transformer (enabled by default) should add displayName automatically to your components too.
  Yes, this is the case where you're rendering an Object with keys, which is what we are deprecating. You should just stringify that yourself.

In this case you don't want to actually use `createFragment` so I could see the warning being a bit misleading. But we can't do typechecks to special case Date (could be your own types, etc). Maybe we should add something like "or convert to a primitive" to the warning.
 We can improve this error a little bit.
 I doubt we're going to start coercing here (eg, why wouldn't `{toString: function() { return 'foo' } }` be allowed) and the `instanceof` check isn't good enough (`Object.create(null) instanceof Object === false`).

Another helpful step with debugging: turn on pausing on caught exceptions. We throw and catch an error when warning to help with specifically this case.

Having more information in the warning is probably the best thing.
 Converting to a string is the solution, not a workaround. Trying to render objects that are not ReactElements is no longer supported.

I actually see this error when rendering `<div>hello {new Date()}</div>`:

> `Error: Invariant Violation: Objects are not valid as a React child (found: Tue Oct 13 2015 10:02:35 GMT-0700 (PDT)). If you meant to render a collection of children, use an array instead or wrap the object using createFragment(object) from the React add-ons. Check the render method of Hello.`
  The test (to save a couple clicks):

``` js
  it('render', function() {
    var React = require('react');
    var findDOMNode = require('react-dom').findDOMNode;
    var StatelessComponent = require('../stateless');
    var TestUtils = require('react/lib/ReactTestUtils');

    var spy = jasmine.createSpy();
    var component = TestUtils.renderIntoDocument(
      <StatelessComponent text="Hello" onClick={spy} />
    );

    expect(findDOMNode(component).textContent).toBe('Hello');
  });
```

I would also expect this to work‚Ä¶ cc @spicyj 
 Stateless components have no public instance. If you were to wrap it in another (stateful) composite then you could call findDOMNode on that component.

cc @sebmarkbage for verification
 You can use Shallow testing to avoid needing to reach into the DOM:

https://facebook.github.io/react/docs/test-utils.html#shallow-rendering
  Thanks for the heads up, I'll clean it up. Luckily it's git :)

We actually have the wiki set to public intentionally so that we can have people add their own sites without us having to handle it.
 Fixed and reported the email address responsible.
 Not possible from our end.
  These are internal functions and we don't support using them except as they exist in our codebase. If we care to change it, it would probably make sense to check for `!= null` instead.
  @tonyhb no that would be unrelated. Can you file a new issue with code to reproduce.
 @luisrudge Guessing react-pivot has its own copy of React. Try rm -rf `node_modules/react-pivot/node_modules/react/`.
 Need to investigate how IE9 and IE10 behaves with these static properties. For anyone in this thread who's not on IE and not using scala-js, please file separate issues with repro steps.
  Thank you for the PR! Sorry about the long wait‚Äîthe whole approach to this was changing. Now that #5714 is merged, all attributes on SVG elements will be passed through as is, with no need for the whitelist. I'm closing but please let me know if you still have problems with master.
  Thanks!

cc @marocchino @sairion @reactkr for a translation review. 
 Great, thanks to both of you!
 @zpao is so fast, race conditions :P
  Fixes #3473

I tag each React element with `$$typeof: Symbol.for('react.element')`. We need
this to be able to safely distinguish these from plain objects that might have
come from user provided JSON.

The idiomatic JavaScript way of tagging an object is for it to inherent some
prototype and then use `instanceof` to test for it.

However, this has limitations since it doesn't work with value types which
require `typeof` checks. They also don't work across realms. Which is why there
are alternative tag checks like `Array.isArray` or the `toStringTag`. Another
problem is that different instances of React that might have been created not knowing about eachother. npm tends to make this kind of problem occur a lot.

Additionally, it is our hope that ReactElement will one day be specified in
terms of a "Value Type" style record instead of a plain Object.

This Value Types proposal by @nikomatsakis is currently on hold but does satisfy all these requirements:

https://github.com/nikomatsakis/typed-objects-explainer/blob/master/valuetypes.md#the-typeof-operator

Additionally, there is already a system for coordinating tags across module
systems and even realms in ES6. Namely using `Symbol.for`. (thx @sebmck)

Currently these objects are not able to transfer between Workers but there is
nothing preventing that from being possible in the future. You could imagine
even `Symbol.for` working across Worker boundaries. You could also build a
system that coordinates Symbols and Value Types from server to client or through
serialized forms. That's beyond the scope of React itself, and if it was built
it seems like it would belong with the `Symbol` system. A system could override
the `Symbol.for('react.element')` to return a plain yet
cryptographically random or unique number. That would allow ReactElements to
pass through JSON without risking the XSS issue.

The fallback solution is a plain well-known number. This makes it unsafe with
regard to the XSS issue described in #3473. We could have used a much more
convoluted solution to protect against JSON specifically but that would require
some kind of significant coordination, or change the check to do a
`typeof element.$$typeof === 'function'` check which would not make it unique to
React. It seems cleaner to just use a fixed number since the protection is just
a secondary layer anyway. I'm not sure if this is the right tradeoff.

In short, if you want the XSS protection, use a proper Symbol polyfill.

Finally, the reason for calling it `$$typeof` is to avoid confusion with `.type`
and the use case is to add a tag that the `typeof` operator would refer to.
I would use `@@typeof` but that seems to deopt in JSC. I also don't use
`__typeof` because this is more than a framework private. It should really be
part of the polyfilling layer.

Test Plan:

`examples/basic/index.html` works in Chrome and Firefox which both have native Symbols - and in Safari which doesn't.

`React.createElement('div').$$typeof // Symbol(react.element)`.
  This looks like a usage question, rather than a bug in the React core. Usage questions are better answered on sites like StackOverflow, as we try to use github issues for tracking bugs in the React core. For this reason, I'm going to close out this issue, but feel free to continue the conversation here or move it to StackOverflow.
  Dupe of #1881.
  You can achieve the same effect by providing a childFactory to ReactTransitionGroup and adding custom hooks there. And CSSTransitionGroup is intentionally simple. If you want custom behavior you can implement it yourself so I don't think we'll take this, sorry.
  Two things determine whether a component is reused: the type and the key. If either changes, the component is unmounted and remounted. See:

https://github.com/facebook/react/blob/3dbdb63a7dbdf31522a623bd627a64c230cdfdcf/src/renderers/shared/reconciler/shouldUpdateReactComponent.js

Since your `view.reactComponent` value is different in the two cases, the component gets remounted.
 No, there's no way (currently) to separate the unmounting process from the actual DOM manipulation. From your code it looks like you can have a different `Thunk` for each key and cache the ones you've created so far. Would that work?

Adopting server rendering is a special case for the initial render and there's no way to get that behavior on an update.
  Try using the same version of react and react-dom. When you do `npm ls` you should only see one react (i.e., not any underneath react-dom).
 (From the beta blog post: "For now, please use the same version of react and react-dom in your apps to avoid versioning problems ‚Äì but we plan to remove this requirement later.")
 @shaikhussian That is a completely unrelated error. It means that you're passing a container that isn't a DOM node ‚Äì likely undefined (if the element you're looking for doesn't exist on the page).
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Please make this change in the original markdown files (https://github.com/facebook/react/blob/master/docs/docs/02.1-jsx-in-depth.ko-KR.md). I'm going to close out since you need to make the change against a different branch and GH won't let you do that in the same PR.

Also, cc @marocchino who has done a lot of the translation work and can help guide you.
 You don't need to refork but yes, you will need a new PR using a new branch. You can do this easily using the "edit" feature on GH directly (that will create do the things for you, just edit the file linked above).
  ```
ReactDOM.unstable_renderSubtreeIntoContainer(this, el, container);
```

should work.
 Not yet. Context as a whole is still undocumented and will remain so until it's stable enough for us to support it.
 Right now it passes context, that's all. Unclear if it'll be expanded to include anything else in the future.
  Maybe it really is combatability mode because we're fighting the browser üòâ

Thanks!
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thanks but as mentioned more work needs to be done. See #4658.
  dupe of #4326 
  We haven't had any other reports of this. This works correctly in my copy of Chrome 45 as far as I know. Perhaps you can debug and see what part of that condition is returning true and how that differs from your own machines.
  This won't work in 0.14 where we actually freeze the props object. I'll leave this open for now in case we want to discuss more (@sebmarkbage) but this is probably out of scope for React and would be more appropriate as a general JS type checker, perhaps one that could integrate with Flow.
 Looks like there isn't any more discussion on this topic, out of scope, more appropriate for a general type checker.
  Both of these suggestions are good. This isn't a React-specific issue so I'm closing this bug.
  (discuss.reactjs.org is not appropriate for code-level debugging questions.)
  Would be nice indeed!
 We probably wouldn't do an Algolia logo (and certainly not on every page), but we could link to you on our acknowledgements page:

http://facebook.github.io/react/acknowledgements.html

Let me know if that would work for you. This would also likely be a pretty low priority for us. We do plan to revamp the website eventually though.
 Hey @pixelastic - thanks for getting this started. We have a bunch of things going on and this is still pretty low priority for us at the moment. I wouldn't spend much more time on it until we've had a chance to circle back and take a look.
 Done.
  Do not use inheritance to build React components. Try:

``` js
class Circle extends React.Component {
    render() {
        return <Shape {...this.props} shapeType="Circle" />;
    }
}
```
  Dupe of #761. Your best bet is probably to add a wrapping element whose classes don't change.
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 Merged in c6ecda7503ecac374f941fdf7af75755b467f449 (made a small change to fix the paren characters), thanks!
  Apparently we did a lot.

To curious onlookers: Please no tweeting about this yet; we're not quite done. :) We'll try to cut the release soon.

Preview:

![](https://cloud.githubusercontent.com/assets/6820/9695868/7640aabc-531b-11e5-9b94-7e512645adf5.png)
 Thank you, good catch.
 @alexeyraspopov It's not in beta3. Please wait for the RC.
 @alexeyraspopov That landed after beta3 was cut. It'll be in the RC that goes out sometime soon.
 (marking accepted per 1:1 chat)
  wtf hub.
 I don't really care but I'll update the docblock anyway.
 @zpao r?
 r+
  @abritinthebay Can you elaborate more on the sorts of things you like to introspect?
 FWIW we use https://github.com/reactjs/react-docgen at Facebook.

We're not going to build this as part of React but perhaps something like Flow will have optional runtime typechecks eventually which could incorporate some or all of this functionality.
 We work closely the people maintaining that - if / when we get to that point, we'll already have worked with them to get things into shape :)
  Thanks!
  The warning and error is already clearer in master.
 It'll be in 0.14, hopefully out soon.
  You may be imagining that the virtual dom is a large data structure that gets materialized on the client.  That updates result in a second virtual tree being created, and the two are diffed as a second step.  I know this was my initial interpretation upon reading the documentation.  And while that's conceptually true, it's not actually how the internals work.  There isn't really a virtual dom image (certainly not a serializable one anyway) that could be provided by the server, at least not with our current implementation.

However, there is some good news, if you have the ability to run code on the server.  React supports rendering markup on the server, and then React will mount into that markup (reusing the markup created on the server).  This means that the initial http payload sent to the client will contain fully rendered html (which is also great for SEO, and makes the page look/feel super fast), and React will jump into action on the client as soon as all the dependent javascript has been loaded.  For more information, I would recommend googling [react isomorphic](https://www.google.com/search?q=react+isomorphic&oq=react+isomorphic&aqs=chrome..69i57j69i60l5.3487j0j7&sourceid=chrome&es_sm=91&ie=UTF-8).

As a side note: While it's a bit different from what you're describing, a related discussion topic is [inline elements](https://github.com/facebook/react/issues/3285), which is on our short-term roadmap and one of the things we're looking to better support in the future.
  Going to go with #4786 which was submitted earlier.
  :thumbsup: thanks!
  We're getting close to that time of the release cycle so time to update the authors. If I mentioned you below, it would be good to hear if I made the right decision (either selecting an email address or name) or if you'd like something changed.

I'll run this all again right before we ship to catch anybody else that comes in. But as of right now we have _186_ new names since we cut 0.13. Thank you to all of you who have contributed over the past few months.

---
### I pulled name from your GH profile. Is that ok?
- [x] @Wildhoney
- [x] @codesuki
- [x] @oluckyman
- [x] @mheiber (well, I figured it out from your email address)
- [x] @katzoo
- [x] @himkt
- [x] @eriklharper (ditto on email address)
- [x] @Smert
### Your names mostly match your GH username. Would you like to use a different name? (non-latin characters ok!):
- [ ] @Youmoo
- [x] @yiminghe
- [x] @xmo-odoo 
- [x] @thorn0
- [x] @sugarshin
- [x] @matchu
- [x] @lili21
- [x] @laiso
- [x] @jiyeonseo
- [x] @iamdoron
- [x] @wibud
- [x] @mbrookes
- [x] @zhangjg
- [x] @jw-00000
### You had commits from multiple email addresses. Are you ok with email address I mapped to (first one in `.mailmap`)?
- [x] @AnSavvides
- [x] @bhamodi
- [x] @jeffchan
- [x] @KevinTCoughlin
- [x] @Yeti-or
- [x] @mmoss 
- [x] @mihaip
- [x] @MichelleTodd
- [ ] @undernewmanagement
 Thanks for the heads up about the dupes @syranide. I only found a couple obvious ones (dupe name or dupe email) with https://gist.github.com/zpao/788bca0a4ea29b703b8c, but let me know if there were others you saw. "A bunch" implies to me that you might have seen more than 3.

Let me know if I made good choices!
- @mihaip
- @MichelleTodd
- @undernewmanagement
 @mmoss those are in hie maul
 Ughh mobile is hard‚Ä¶

@mmoss those are in there to map the commits with those email addresses back to a single entry with the correct email address in the authors file
 @syranide That's the `.mailmap`, it needs to be duplicated. Standalone lines (eg `Alex Pien <alexpien@gmail.com>`) make sure commits with the same email but different names get mapped to a single name. The lines with multiple email addresses make sure commits that were done with the 2nd email are mapped to the first one. Here's what happens when I remove his entries: https://gist.github.com/zpao/78a447ed1a26d37bf598
 Every bit helps!
 Nothing wrong, just wanted to give the opportunity to use something else if
you wanted!

On Friday, October 2, 2015, zhangjg notifications@github.com wrote:

> @zpao https://github.com/zpao Is there some things wong using my GH
> name zhangjg?
> 
> ‚Äî
> Reply to this email directly or view it on GitHub
> https://github.com/facebook/react/pull/4785#issuecomment-145014180.
  Trying to use `<input type="file" capture="camera"`/ >`and the`capture` attribute is not getting rendered

Doesn't look like its supported in the list at:
https://facebook.github.io/react/docs/tags-and-attributes.html#html-attributes

More information on capture at: 
http://www.w3.org/TR/html-media-capture/#introduction
 What version of react are you using? The support for it is here: https://github.com/facebook/react/blob/master/src/renderers/dom/shared/HTMLDOMPropertyConfig.js#L60 and testing it really quickly kept the capture attribute on the rendered element. If you read the more information link you provided you'll see it expects an "accept" attribute on the input element, perhaps that's the issue you are experiencing?
 You were right about it missing from the docs tho, so I submitted #4788 to resolve.
 This was added in React 0.14, which you can play with in the beta, and the final release should be coming very soon now.
 @milesj No, sorry. We'll release 0.14 soon (RC this week, probably) but before then you can simply access the DOM node with a ref and set the attribute manually.
 @ccorcos As per https://github.com/facebook/react/issues/4784#issuecomment-137654227, it appears to be in the code.  Do you have a simple jsfiddle that demonstrates your issue?
 According to the spec, capture is a boolean attribute: http://www.w3.org/TR/html-media-capture/#the-capture-attribute

There are some sources places that specify string values for the capture attribute (http://mobilehtml5.org/ts/?id=23) and some browsers appear to honor that, but it doesn't look like it's part of the spec.  Furthermore, the spec seems to indicate that users specify the `capture control type` using the `accept` attribute.  As far as I can tell, supporting the string value of capture goes against the specification and provides no value above/beyond what is already provided by the accept attribute.

Do you know of a situation where the `capture` attribute's string value is meaningful, and the `accept` attribute is not a viable alternative?
 @zpao Is there any harm in specifying this as a `must_use_attribute` that takes in a string?  Seems like that would allow us to support legacy browsers, and the boolean_attribute logic is only really useful if you're using properties instead of attributes, right?
 No harm. (@syranide's pending DOM removeAttribute pull request should change everything to use attributes.)
 It's unrealistic to support all quirks in all old browsers. It would be helpful to know which ones and if we should support then.

> No harm

Not quite true (at least not based on my understand of what @jimfb was saying)

The boolean logic currently allows us to specify `capture={true}` and then we can output the correct thing in markup, which is either the empty string or `"capture"`. Other values aren't valid. If we remove the `HAS_BOOLEAN_VALUE` then `capture={true}` will output `capture="true"` which is invalid. https://html.spec.whatwg.org/multipage/infrastructure.html#boolean-attributes. We could make it `HAS_OVERLOADED_BOOLEAN_VALUE` (which is what the spec for the `download` attr requires). It will handle true/false correctly and pass the string through if it gets that.
  This is probably fixed on master. If you can still repro this on 0.14.0-beta3, let me know and I'll reopen.
  This is not a React issue.
  Heh, sure. Thanks. Generally we try to use `prop` when talking about `key` but I can see this being a potentially confusing point.
 @zpao But `key` isn't a prop!
 String. And iunno.
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
   Works on master.
 Yes, hopefully. Not sure what metrics we'll be able to share but I would like to test it.
  Well, the good news is that if this is already on enough pages, then introducing iterable numbers may not be web compatible anyway.

I think that this is only in DEV only code. Unfortunately a lot of pages incorrectly uses the DEV build of React.
 "good news"
    It is currently expected behavior with our code (our regexp: `/^(data|aria)-[a-z_][a-z\d_.\-]*$/`) but‚Ä¶

I was going to say that it doesn't actually work and `data-0` isn't valid according to the spec but I think I would be wrong. It looks like it would be (`data-name` as a whole must be XML-compatible, not just the `name` part, so `NameStartChar` only applies to `d` in `data`). Hopefully there was a good reason (like lack of support in IE8) but I don't remember off the top of my head. I knew we discussed a lot around capital letters in there but decided not to support that intentionally.

@syranide - do you remember if we ever talked about numbers?
 I'm not sure what dense.js has to do with this issue, but I think this is a duplicate of https://github.com/facebook/react/issues/2329 which was fixed in https://github.com/facebook/react/pull/5216 and appears to work on latest http://jsfiddle.net/8pLf9dbw/
 @cody is correct.

@imgarylai Yes, it works on es5: http://jsfiddle.net/1LgLy7mL/
  `<div style={{'{{width:10}}'}}` isn't JSX so the compilers will complain. You want to make sure whatever transform you're doing before JS transforming converts to valid JSX. This isn't something we're responsible for so I'm going to close. You'll probably have better luck asking this question on a Twig forum or stack overflow.
  Can you give more information about what you mean?
 What do you mean by "destroyed"? All JavaScript objects are garbage collected when there are no more references.
 Yes, React never reuses an instance after it's been unmounted.
  Why are you using Number objects instead of numbers?
 I don't think we're going to support this, sorry. You can use `<span>{+item.get('unbilled_value')}</span>` which hopefully isn't too inconvenient.

> Note that there is actually no problem rendering the value, but the warning is raised.

We usually warn for things that will break in future versions. This particular pattern will break hard in 0.14.
  Now that #5714 is merged, all attributes on SVG elements will be passed through as is, with no need for the whitelist. Thanks for the PR though!
  TestUtils.Simulate only uses React's internal event system; it does not touch the actual DOM at all so it can't use any of the DOM event handlers. I'd be happy to take a pull request improving the docs to make this clearer.
 Yes, the listeners are at the document level.
  React does initialization based on the environment. So after you require/import React, the environment at that point should never change. We don't handle the changing case and we likely never will.

The suggested way to make use of NODE_ENV is via an environment variable `NODE_ENV=production node app.js`. If that's not possible, then ensuring that `process.env.NODE_ENV='production'` ASAP in your app, before you require/import.
  @amasad Will this work? We have `"main": "react.js"` in package.json.
 This won't work yet anyway. fbjs support in React Native is the primary blocker.
 Thanks.
  We'll follow up there.
  Duplicate of https://github.com/facebook/react/issues/140
  Thank you!
  This is intentional. componentDidMount of a parent gets called after componentDidMount of its children, so you know your children are fully initialized before using them. Likewise, componentWillUnmount is called _before_ children (the reverse of componentDidMount) so that you have a chance to reverse anything that you might have done in componentDidMount.

For react-famous, probably an alternate rendering backend is more appropriate, more like react-art or react-canvas or react-native but we don't yet have a good supported way to do that. (Unlike the lifecycle method, that would allow you to do the _actual_ unmounting in the order you prefer.) Your solution of removing the children from the parent sounds pretty reasonable though.
  Currently React implements its own plugin system and event bubbling rules. This is important for systems like the responder system since the DOM event system is incapable of implementing proper event negotiation support.

However, on desktop, we don't really take full advantage of our custom event system other than to polyfill mouseenter/leave and implement more bubbling.

There are plenty of other things that are wrong with the DOM but instead of patching it, maybe it would be better to build a new view system on top of the DOM that integrates with the custom event system. Similarly to how React Native handles things.

That way, the lowest level could just do what the DOM would do, however broken it may be.

Question though: How do we handle things like onChange?

cc @spicyj and @syranide since I know you always wanted this.
 The problem is that I think that the DOM events and a custom event system will never integrate well. You can already see this in frameworks since the jQuery days. You can also see this in the DOM itself where events doesn't cooperate between iframes. They're whole boxes that steal the events and doesn't bubble for example.

For example, the responder event system will need to conditionally block certain events from occurring elsewhere.

That's why I think that a good custom event system is eventually going to be mutually exclusive with integrating well with the DOM event system. Basically, mixing two in the same box/window/frame is probably going to lead to a bad time regardless and is likely not going to be supported.

It's easy to say that virtual-dom does the right thing because it just offloads the problem to someone else to solve. Once you start trying to solve these interaction problem it gets messy.

Custom hooks into a global namespaces becomes a compatibility nightmare when the same name is used in slightly different versions and slightly different packages. Great if you write all your own components but not great if you're trying to cooperate in an ecosystem or large company. We could potentially make scoped extensions somehow, but it seems better to just wrap your commonly used components. Opting into using `<Text />` instead of `<span />` shouldn't be a big price to pay for compatibility.
 > I was not necessarily suggesting integrating them but rather providing two levels for users to hook.

@Gozala Yea, that is basically what this issue is meant to address. You would have two different View systems. One that is just pass-through to the DOM, and one that is an abstraction layer with a built-in richer event system.

> Hooks don't reserve any names you box prop values with hooks so there is no naming conflicts as it's by identity rather than name. 

By global name I mean the namespace on `<htmlelement ... />`. All the property names on "props", for HTML elements share the same namespace globally. I meant that if you claim the name `MozSwipeGestureStart` for all events on the page, and add custom logic to it, and then someone else tries to do the same, there is no way to scope them differently.

We could potentially have a whitelist for things that doesn't get special logic. E.g. just SimpleEventPlugin is allowed. That way it is not possible for two different component systems to collide in terms of logic. It is either on or off. However, we might need to break them between versions to be able to intercept the event system for events that we have special logic around, or special synthetic events.

> There is no single container makes sense across the board UI entities it's being used so boxing event hooks into special component

You can use mixins to reuse the same logic on all your base components. You can also have a component that wraps the bubbled events inside your base components.

E.g. `return <EventHandler onSwipeGestureStart={this.props.onSwipeGestureState}><div ... /></EventHandler>`

If you're like Facebook/Netflix/Yahoo etc. and build your abstractions on TOP of the DOM this is easy because you end up with a few bottom layer primitives that you build everything else on. However, if you're like Mozilla/Polymer and build all your abstractions into the DOM, this is a bit of a pain because you have to wrap them every time you add a new abstraction.

The Facebook/Netflix/Yahoos of the world can't build our abstractions into the DOM because we can't wait for a new cross-browser event that plays nicely with the rest of the DOM event system. E.g. Apple's "3D Touch" would need some integration with other DOM events like `mousedown` so we can't just have them pass straight through.

However, it seems fair that we should decouple that event system so that it become easier to use DOM-heavy abstractions.
 @Gozala Thanks a lot. This is great feedback! It's a slightly different take (and more thoroughly thought through) than we've heard before.

I've considered having a special element that can register event listeners but doesn't actually contribute to the DOM.

``` js
<tr><EventHandler onClick={...}><CustomTd /></EventHandler></tr>
```

I've been wanting that for a while and it would be trivial for us to add since we have our own custom event bubbling but without that it's tricky. It would be nice to have special DOM elements that are non-semantic contributions as well. That's one of the problems we have with Web Components.
 That's the problem with event bubbling in general and this doesn't make that worse.

It is just a hassle to add listeners to every little node that may or may not be capturing something.

You can use pointer-events: none to make non-hit target surfaces like your border.

I think that this is a problem that goes much deeper into the DOM model.

Ideally you would render hit targets completely separately from rendering IMO.

> On Sep 15, 2015, at 12:51 AM, Andreas Svensson notifications@github.com wrote:
> 
> I've been wanting that for a while and it would be trivial for us to add since we have our own custom event bubbling but without that it's tricky. It would be nice to have special DOM elements that are non-semantic contributions as well. That's one of the problems we have with Web Components.
> 
> That seems like a too generic approach to me, especially when you consider overhead of components. It also seems to me that it kind of breaks down in non-trivial cases.
> 
> <TouchHandler ...>
>   <MouseHandler ...>
>     <PenHandler ...>
>       <Comp />
>     </PenHandler>
>   <MouseHandler>
> <TouchHandler>
> That doesn't seem very nice at all. It also breaks component isolation in a way, I shouldn't reach inside opaque components, but I should attach event handlers without their permission?
> 
> Wouldn't it make more sense with an approach along the lines of:
> 
> <div events={[TouchHandler(...), MouseHandler(...), PenHandler(...)]} />
> That way generic components could instead pass the events along to wherever it should go. Say you have a button with a decorative frame, the decorative frame shouldn't respond to events but with the proposed solution there doesn't seem to be a way around it?
> 
> ‚Äî
> Reply to this email directly or view it on GitHub.
  This is known. More or less a dupe of #2517.
  Sorry for the trouble. This was an unfortunate problem but we're in the process of deprecating `react-tools` so won't be fixing anything more. I suggest switching to another tool (our preferred one is babel).
  Can you post a small reproducible example in https://react.jsbin.com/ or jsfiddle? I can't help you unless you give more information.
 Bug occurs when the click target is the glyph instead of the button.  Original  browser mouse event has target correctly set, synthetic event does not have the target set.  Reproducible in both 0.13 and 0.14.
 It looks like a bug that this is undefined, but after we fix it it'll be the span element which probably isn't what you want. You want `e.currentTarget.value` to get the button, which already works correctly.
 Wait, what? `e.target` is correctly the button or the span in my testing. If you want the button, you do definitely want `e.currentTarget.value`.
  @nikolaymatrosov, you're answer is perfect/correct on all points.  Thanks!

@HelloYie You will want to pass the props from the owner to the child component, as nikolaymatrosov mentioned.  If you're looking for prop changes, you may also want to read about componentWillReceiveProps (https://facebook.github.io/react/docs/component-specs.html#updating-componentwillreceiveprops), which may apply to either/both the parent and child, depending on your use case.
  I'll leave this open until we figure out our longer-term plan for test utils, but we're unlikely to get to this.
  Try setting global.document and global.window from jsdom before requiring React. This report is similar:

http://stackoverflow.com/questions/26867535/calling-setstate-in-jsdom-based-tests-causing-cannot-render-markup-in-a-worker
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 Thanks. This page will be going away soon but might as well fix the grammar while it's still live.
  Please read the error message.
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 It's in fbjs: https://github.com/facebook/fbjs/blob/master/src/core/shallowEqual.js.
 Thanks!
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 cc @tako-black 
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
  Thanks. Dupe of #3659 probably.
  `.type` on a React _element_ still works. It does not work on React classes. It sounds like you're doing `.render(Foo)` instead of `.render(<Foo />)`.
 Okay.
  You can return the element, like you said. renderToString doesn't include the event handlers and there's no real way for us to make that happen. If you give more details maybe I can be more helpful.
 This is hard to do without support from the markdown engine. You can try using https://github.com/Khan/simple-markdown or https://github.com/spicyj/marked-react.
  If the keys stay the same, the components will update and won't be unmounted/remounted.
 (In the future, please don't ask usage questions about React here ‚Äì this issue tracker is for bugs in React.)
 @trusktr Stack Overflow is also a good choice for questions that have a simple answer, like this one.
  While it's not explicitly used in this example, that piece of code is important to the idea of the lesson of the example, that you will almost certainly have to handle `componentWillUnmount` since that can happen without an explicit call into your modal component (eg if the parent unmounts or just decides to stop rendering the modal component). In this case we don't hit that path and that actually calls a method that doesn't exist, but I'd much prefer an improvement in that direction.
  Yeah, I'll close this in favor of #4302.
  I like it, let's do it.

If you're at all interested in doing a pass through our other API docs to make them consistent, that would be awesome :). I know you mentioned the top level docs are formatted like this but it looks like the [component docs](http://facebook.github.io/react/docs/component-api.html) aren't.
  Yes, JSX always makes an array. In 0.14 React.Children.map() will return an array too.
 Yes, I merged it in #4700. Nothing is changing about how key works ‚Äì why would it be redundant?
 When you write the elements inline in JSX like `<div><p></p><p></p></div>`, React doesn't ask you to add `key` attributes since it's unlikely you'll reorder them. When you write `<div>{paragraphs}</div>` you do need the keys. React.Children.map copied over the implicitly-added keys in the first case so you didn't see the warning, but mapping the array yourself wouldn't copy the keys. In 0.14, React.Children.map will still copy the keys automatically but it will return an array.
  This will work in 0.14.
  cc @spicyj - this is likely a result of you getting rid of the wrapper components we had here. Can we add a check in the shallow renderer or somewhere so we get a better error?
 Yeah, I knew about this but we can add a better error. Note that for this you don't need shallow rendering and 

``` js
var el = React.createElement('h1', {}, 'Hello');
console.log(el);
```

does what you want already.
  Thanks! Can you add a unit test that uses transitionName like this?
 Thanks for the quick PR. Let's do what @Daniel15 said (in addition to the test and fixing the other one) - will help make sure we don't diverge :)
 Thank you!
  The ref you're adding in FeatureMapView overrides the one set outside. There's no way right now to have two refs to a single component, unfortunately.
  I'll update this when we release. Those names are lowercase in the git commits, which is why they are lowercase in the authors file and sorted to the bottom (git shortlog is doing the sorting)
  This would be called elementOfType if we do want it, though I'm not sure we do since if a component is expecting a `<Button />` element you should (ideally) be able to pass `<PurpleButton />` and have that work too.
 It's important to support composition but also important to support good helpers when a component doesn't make sense in certain contexts. This gets pretty complicated to get right though so I'd rather leave it to user space now.
  They are (or rather we add all the prefixed versions to our lookup table first) - https://github.com/facebook/react/blob/master/src/renderers/dom/shared/CSSProperty.js#L58-L70.

However we're using `WebkitFlex` and `MozFlex` to be JS property compatible (thought it appears `webkitFlex` might be the thing we need to support now too - see #4557). So quick fix (presumably for GraphiQL) is to just use the PascalCase version)
 Years ago `WebkitFoo` was the way to do this and showed up in the autocomplete, style object inspection. Everybody thought IE was the special case with `msFoo` (there was `MozFoo`, `OFoo`). There was a "standard" and only IE broke it. But now Opera is gone, `webkitFoo` is what the browsers seem to want, and so `MozFoo` is the odd one out :(

PascalCase was awesome because it made the conversion to stylesheet rule easy - replace capital letter with `-` + lowercase version. Done. But oh well. /rant
  This is probably more a flow issue than anything, but definitely annoying. We'll want to have this documented in some way soon. I think what we need is the ability to compose flowconfigs so that we could stack ignores, though maybe it's something we can address in fbjs. It was brought up there the other day so let's continue over in that issue (https://github.com/facebook/fbjs/issues/44)
  We don't have any supported way to do this. Your best bet is probably to add more wrapper components so you have

```
<div ref="target">
  <div ref="foo">
    <p>Foo</p>
  </div>
  <div ref="bar">
    <Bar />
  </div>
</div>
```

or similar. (If you can explain more about your use case, perhaps I can suggest a better solution.)
 We don't have any supported way to do this because you're breaking encapsulation of the inner components (e.g., Target) and changing what it renders to something other than what it intended. You can look in the DOM for nodes with a certain class but you're more or less on your own then.
  Good catch, thank you.
 I wonder what we should do with references to "React.render" in ReactClass.js and ReactElement.js.
  Test failure is just because we actually test the output of that message and you're making it longer so we'll need to adjust the test expectations as well.
  This is not at all a React error. Please try to read the error message and figure out what project is related instead of opening three issues.
 Sometimes it's your fault, not any of ours.
 @cmelion Thank you.
  ```
ReactDOM.unstable_renderSubtreeIntoContainer(this, <Foo />, container)
```
  Store it in a some intermediate structure, maybe on the instance itself.
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 Can we lowercase "component" in this sentence? Otherwise good. If you fix that and squash your commits I'll merge this.
 This PR is six months old and isn't squashed.  Honestly, I haven't seen this as being a major point of confusion (which surprises me a little bit, but apparently people figure it out or just don't run into this).  It is documented elsewhere on [reactjs.com](https://facebook.github.io/react/docs/jsx-in-depth.html#html-tags-vs.-react-components).  Adding the sentence here adds clutter to the top-level api reference documentation.  Having it here is especially weird because the component name capitalization isn't actually part of the `createClass` call, it's about the name of the variable that you save the component to when it's returned (the sentence as-is is weird because it makes me think that it's discussing the parameters to the function call).  Also, perhaps most importantly, this is the type of thing that's trivial to detect at transform time or via a linter, which provides real-time feedback at the moment people hit the issue, and so that seems like a much better solution than adding preventative/speculative documentation to `createClass`.
  Per https://github.com/facebook/react/commit/1db20999f0336cfacc6af5ee6f5a77803d74381b#commitcomment-12865588.
 Do you think this might imply that you have to use an ES6 arrow function?
 @zpao Maybe it does, but honestly this syntax is pretty cumbersome if you don't use an arrow function that I don't think anyone will want to.

@syranide Already did ‚Äì see line 119.
 Yea, if you use inline functions. The other way I could see people doing this with a prebound function, eg`<TextInput ref={this._setInput}>` (which is honestly what I would probably write, I tend to not like creating functions in `render()`). The important part of this is that it's bound. But yea, this is fine. I'll point anybody who is confused to you :P
  Lifecycle methods are bound as our methods that are a part of the base class (eg, setState). Nothing planned that would change this.
  I'm trying to get an ascii art to be properly rendered by my React application.

After jsx-transformer is executed my art looses the format and renders pretty strange in the browser. It seems to be related to not identifying line breaks properly.

```
<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Hello World!</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/react/0.13.3/react.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/react/0.13.3/JSXTransformer.js"></script>
</head>
<body>
  <div id="content"></div>
  <script type="text/jsx">

    var App = React.createClass({
      render: function() {
        return (
          <pre>
            <code>
              +--------+   +-------+    +-------+
              |        |   + ditaa +    |       |
              |  Text  |   +-------+    |diagram|
              |Document|   |!magic!|    |       |
              |        |   |       |    |       |
              +---+----+   +-------+    +-------+
            </code>
          </pre>
        );
      }
    });

    var element = document.getElementById('content');
    React.render(React.createElement(App), element);
  </script>
</body>
</html>
```

This is just an example, and the real context is in a website generator that starts with markdown -> html -> jsx. That said, I cannot change the React.createClass element.

Someone proposed this:

```
var App = React.createClass({
  render: function() {
    var ascii = [
      "+--------+   +-------+    +-------+",
      "|        |   + ditaa +    |       |",
      "|  Text  |   +-------+    |diagram|",
      "|Document|   |!magic!|    |       |",
      "|        |   |       |    |       |",
      "+---+----+   +-------+    +-------+",
    ].join('\n');

    return (
      <pre>
        <code>
          {ascii}
        </code>
      </pre>
    );
  }
});
```

It fixes the problem, but I cannot edit the markdown elements to reflect this. I'm more interested to know why JSX transformation is not identifying to line breaks inside code blocks.

Alan
 JSX collapses whitespace which is almost always what you want but is obviously inconvenient in this case (sorry). If you're using an ES6 compiler like Babel (just swap out JSXTransformer.js for https://cdnjs.cloudflare.com/ajax/libs/babel-core/5.6.15/browser.min.js and use text/babel instead of text/jsx) then you can use an ES6 template string

```
<code>{`
  +--------+   +-------+    +-------+
  |        |   + ditaa +    |       |
  |  Text  |   +-------+    |diagram|
  |Document|   |!magic!|    |       |
  |        |   |       |    |       |
  +---+----+   +-------+    +-------+
`}</code>
```

which may be more palatable.
 Thank you so much @spicyj!
 Actually it turns out that adding only {`...`} fixes the problem, I did not have to switch to Babel. Any idea why it works?

This is the final version that works using jsx-transformer.

```
<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Hello World!</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/react/0.13.3/react.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/react/0.13.3/JSXTransformer.js"></script>
</head>
<body>
  <div id="content"></div>
  <script type="text/jsx">

    var App = React.createClass({
      render: function() {
        return (
          <pre>
            <code>{`
              +--------+   +-------+    +-------+
              |        |   + ditaa +    |       |
              |  Text  |   +-------+    |diagram|
              |Document|   |!magic!|    |       |
              |        |   |       |    |       |
              +---+----+   +-------+    +-------+
            `}</code>
          </pre>
        );
      }
    });

    var element = document.getElementById('content');
    React.render(React.createElement(App), element);
  </script>
</body>
</html>
```
 JSXTransformer also supported template literals. @spicyj was trying to sneakily get you to upgrade since we deprecated JSXTransformer :)
 smart move hahahah, thanks guys! In [Grommet](http://grommet.io) we are using babel and react, but for the sake of the example I used JSXTransformer.

Again, thanks for this awesome technology.
 Sorry guys, I'm trying to understand this issue better. Sorry if I'm out of context here.

Could you please explain why React collapses whitespaces **inside** `pre code` tags? I've checked this PR https://github.com/facebook/react/pull/480 and I definitely agree that we should collapse for cases like this:

```
<div     className="testing">Adding unnecessary whitespace.</div>
```

But for the pre tag code seems weird to me.

I did a quick test on how github handles the pre code tags and they do preserve the spacing I provide.

See the ascii art here:

```
            +--------+   +-------+    +-------+
            |        | --+ ditaa +--> |       |
            |  Text  |   +-------+    |diagram|
            |Document|   |!magic!|    |       |
            |        |   |       |    |       |
            +---+----+   +-------+    +-------+
                :                         ^
                |       Lots of work      |
                +-------------------------+
```

The template literal works for a standalone scenario. But I'm trying to build something that converts markdown to JSX to be able to easily create websites based on React. I cannot control the user markdown to decide whether to put the template literal or not. And putting the template literal inside the markdown also sounds strange.

Also, I'm trying to replicate [this markdown](https://github.com/adam-p/markdown-here/wiki/Markdown-Cheatsheet) in JSX, all the pre code tags that explains markdown are in one line after the transpilation process.

For example, I'm expecting this:

```
  # H1
  ## H2
  ### H3
  #### H4
  ##### H5
  ###### H6

  Alternatively, for H1 and H2, an underline-ish style:

  Alt-H1
  ======

  Alt-H2
  ------
```

But I get this:

```
# H1 ## H2 ### H3 #### H4  ##### H5 ###### H6 Alternatively, for H1 and H2, an underline-ish style: Alt-H1 ======  Alt-H2  ------
```
 thanks @browniefed I will definitely check this plugin!
 Hey @browniefed I've successfully integrated the plugin into my pipeline, but the same problem persists.

Can you try this in your environment?

``````
import React from "react";
import Markdown from "babel-plugin-markdown-react/markdown";

export default class RenderMarkdown extends React.Component {

    render() {
        return (
            <Markdown>
                ```
                  # H1

                  ## H2
                ```
            </Markdown>
        )
    }
}
``````

It could be something wrong with my env, but the execution of this results in a single line element, as in:

```
  # H1 ## H2
```
  When descending element.props.children, you can check `typeof element.type == 'function'` or `typeof element.type == 'string'`.  That will tell you if this is a custom component or a native component.  For custom components, you can (more or less) just say `var cls = element.type; var instance = new cls(); instance.props = element.props; var newElements = instance.render()` which will give you whatever that component would render to.  Obviously if the child components expect their lifecycles to be called, you'll need to call those, and similarly merge the component's default props if the child component expects those.  Getting all the detailed semantics right is slightly non-trivial but very doable.  If you're always trying to get to native elements, you might try using `renderToString` which will do all the heavy lifting for you.

For future reference, questions like this are better addressed on StackOverflow.  Github issues are reserved for tracking bugs in React.
 Eventually we may be able to support this by letting you implement a custom renderer. It's difficult right now, sorry.
  @kmeht Yes, you're correct.  It has always been a convention that classnames start with an uppercase, and it's one that JSX enforces.  Otherwise, there would be namespace collisions and no way for us to determine if the user intended to insert a component or a DOM node.

It's documented here: https://facebook.github.io/react/docs/jsx-in-depth.html#html-tags-vs.-react-components

And the design justification is discussed here: https://gist.github.com/sebmarkbage/f1f4ba40816e7d7848ad
 @giantelk Want to send a PR to make the docs clearer?
 We did warn in a previous version but we only kept it for one version. We no longer support our transform tools so we won't be adding any more warnings about this.
 We can probably warn if you have a lowercase displayName‚Ä¶
 @jimbolla That's true. We recommend doing

```
var UserDashboard = ...;

module.exports = UserDashboard;
```

though.
 I‚Äôm closing this as it doesn‚Äôt appear like we‚Äôd have a good way of warning for functional components or classes anyway, and supporting this only for `createClass` seems inconsistent and not very useful.

We can‚Äôt warn on the declaration site because the components are defined by the user, and we can‚Äôt warn in `createElement` because if the person used the lowercase tag, it‚Äôs too late anyway, and they will get a custom element.

This can probably be implemented as a lint rule in https://github.com/yannickcr/eslint-plugin-react so please feel free to suggest this idea there.
  - Having `children` on props is not only a bit awkward/random as per prior conversations with @jordwalke (ie. why is the prop "children" special cased?).  Not a deciding factor, but certainly a bit irksume from a theoretical computer science perspective.  `element.children` feels cleaner than `element.props.children`.
- The current API is a bit ambiguous with regards to the result of `React.createElement('div', {children: ...}, ...);`, since children is now specified with two potentially conflicting values.  Imagine that the third argument is `null` or `[]` or just a different value.  I don't actually know what would happen off the top of my head, especially in the null case (is the null treated like undefined or does the third argument override the second?)
- Having `children` on props means that the props object saved in the ReactElement can't be hoisted up by an intelligent runtime, which would otherwise be possible for runtimes/transpilers that can see that the non-child props don't depend on that particular render.  This could save thousands of allocations per render.
- **Most importantly:** String compares are expensive.  Because children occurs in props, it means we need to do an additional string compare for each property we iterate over, since we need to handle the children prop as a special case.

This is mostly an RFC issue, it's something to consider before doing inline elements.  cc @sebmarkbage 
 @syranide It's not just createElement that's weird.  Even for JSX users, they can specify children as a prop on the jsx element (possibly via ellipsis) and simultaneously provide child nodes in the JSX element.  You have the oddities for both jsx and non-jsx users alike.  Changing the createElement signature doesn't solve the weirdness for jsx users.

But that's not even the most powerful argument.  The most powerful ones are both technical:
- Both JSX and non-JSX users are taking a perf hit, because every prop key needs to be checked to see if it stringcompares to the string "children", because we need to skip "children" when rendering node attributes.  This means we do a needless stringcompare for every prop on every element for every render.
- And as if that weren't bad enough, we take another perf hit.  Having children on props means that a super common case (an element with static props but non-static children) can't have the props object hoisted up out of render.  This results in thousands of needless allocations (and the associated garbage created) for a single large render.  So there is a second perf hit.

@jimbolla Yes, componentShouldUpdate is hard to implement if a component accepts children.  This doesn't really solve that problem.  But yes, I agree, processing `children` in `componentShouldUpdate` is another case where they often need to be treated differently.
 @gaearon Correct on all counts.  The props of `B` and `A` would be hoistable if it weren't for the fact that `C` becomes a prop.  But don't forget about the stringcompares, which are equally important/expensive.
 > irksume from a theoretical computer science perspective

What does that even mean? Care to be more specific? :)

`this.props.children` isn't the weird part. It's `this.props` that is weird. In normal OO you would just put everything on `this`. E.g. `this.children`, `this.style`, `this.className`. The right mental model is to think of `props` as the main object (`this`) and in the functional style we'll just get rid of `this` completely.

The only thing that makes this weird is because of XML and specifically the XML object model.
The XML model special cases child elements in its parsing. However, a deserialized DOM is represented by `.propertyName` and `.childNodes`. They're on the same object.

The only thing that screws this rule up is that the DOM also allowed access to the serialized attributes through `.attributes` and `getAttribute()` which is nested.

If anything, if we want to be consistent we would add `this.props.attributes` to give you a reflective API of the original source text. Ofc, we won't do that. This is generally considered a mistake to expose the serialized form in the object model.

I think that it is this mental connection to "attributes" that trips people up. However, it is also the most broken part of the DOM and something we've tried hard to get away from.

So, no, from a "theoretical computer science perspective" the current model makes as much sense.

Another thing that trip people up is that children are not "instantiated" before their parent. Meaning that you don't have access to the instances. The general misconception around children is related to that and not the nesting.

E.g. people expected to be able to treat `this.children[0]` as if it is a `ref`. This is how you would do it in the DOM or XHP, and many other traditional models. However, React doesn't work like that and it gives us many important/interesting opportunities. Even if we added the elements to `this.children` it would be confusing because of this difference.

We might want to have that ability to pre-instantiate children at some point though. See for example: https://github.com/reactjs/react-future/blob/master/04%20-%20Layout/02%20-%20Layout%20Components.js#L23 I wanted to keep that open name for that potential purpose or something like it.

> Even for JSX users, they can specify children as a prop on the jsx element (possibly via ellipsis) and simultaneously provide child nodes in the JSX element.

This is theoretically confusing if you're trying to do this. However, think about it, why would this happen in practice? What would the user do to end up in this situation?

If you try to do this, while intentionally knowing that they're the same namespace, you might not know which priority or merging behavior applies, so you just avoid it.

If you accidentally do this because you assume they're different namespaces, then you're probably not targetting HTML (since `children` is not a valid attribute). So you're trying to build a composite component, but then when you try to use the prop you realize that there is no way to access them as separate things.

Besides, we could simply lint for this, or even disallow it in the transpiler.

> Having children on props means that the props object saved in the ReactElement can't be hoisted up by an intelligent runtime

That's incorrect. The `ReactElement` will never be hoistable if you have dynamic children. You could potentially hoist the secondary `props` object but you will need the wrapper object around them.

This is the issue that @jordwalke has pointed out in the past. However, it is unclear how often this would actually be beneficial and how large the impact would be since you have wrapper objects around things anyway. Your maximum saving would be n / 2 - 1 for the rare case that it is actually possible to hoist. So it's not like you would be able to hoist the whole tree anyway. Being able to hoist is rare because of things like `props` being passed and event handlers.

We have the same issue with `style`, so should we just move that special case up to `ReactElement` too? What about `data`? Where does it end? We could just merge it all onto `ReactElement` but then it would be a pain to use spread (`...`) etc. to forward properties, which is also true for `children`.

Besides, if we end up using value types for props, they'll likely just merge onto the same allocation as the outer `ReactElement` allocation anyway. Think struct fields in C++ or C#.

> Because children occurs in props, it means we need to do an additional string compare for each property we iterate over, since we need to handle the children prop as a special case.

Iteration and reflective APIs are expensive and does not JIT very well. So the solution is to try to avoid that as much as possible anyway. See for example:

https://github.com/facebook/react/issues/3227

For known props on HTML elements I always wanted to create a function that reads all the props instead of iterating. E.g.

``` js
function update(oldProps, newProps) {
  if (oldProps.foo !== newProps.foo) {
    element.setAttribute('foo', newProps.foo);
  }
  if (oldProps.bar !== newProps.bar) {
    element.setAttribute('bar', newProps.bar);
  }
  // ...
}
```

> processing children in componentShouldUpdate is another case where they often need to be treated differently

That doesn't solve the `sidebar` and `content` scenario. You just need to do a shallow compare on any known children-like properties. That's not just the case for children but `style` and any other object that is likely to be recreated during a rerender of a parent. The point of `shouldComponentUpdate` is to bail out on whole subtrees so it wouldn't make sense to just skip one component while still proceeding to its children. We also don't have any way of doing that for composites since we don't know which property path corresponds to the next set of props for the child.

For these reasons, we've rejected this proposal in the past and there's no new knowledge here so I'll close it out. Maybe if we get some actual numbers on perf impact in real apps we could reconsider if we don't think that alternative compilation strategies (e.g. value types) are likely to be realized soon enough to warrant a massive codemod/upgrade path.

There is, however, another reason we might want to do this. We might change this as a compromise / concession if we try to standardize the ReactElement data structure as part of JSX. We don't really care about preserving XML's idiosyncracies but it is likely that other people using JSX to target XML might want to do that.

If we ever get to a point where we can join others in standardizing JSX's data structure, then they might want to special case children and events. However, that is a big maybe and there are other quirks like `key` and `ref` semantics that have to be dealt with first.
 @sebmarkbage 

> > irksume from a theoretical computer science perspective
> 
> What does that even mean? Care to be more specific? :)

It's odd that `<MyClass childNodes='foo' children='foo' childElements='foo'>bar</MyClass>` would have the `children` property randomly overwritten by 'bar'.  Why is it overriding `children` and not some other prop (like `childNodes` or `childElements`).  It just feels dirty/arbitrary, making props feel a bit impure.

> That's incorrect. The ReactElement will never be hoistable if you have dynamic children. You could potentially hoist the secondary props object but you will need the wrapper object around them.

The ReactElement will never be hostable, but the `props` object is hoistable, and that's what I'm talking about in this issue.  The keys of ReactElement are uniform and thus much more optimizable, so hosting the element is less important anyway; the critical part is hoisting the `props`.

> We have the same issue with style, so should we just move that special case up to ReactElement too? 

Maybe we should, yes!  Or stop treating style as a special case (object instead of string), but that's a different discussion.  In practice, the style objects are oftentimes constant and thus already hoistable.

> For known props on HTML elements I always wanted to create a function that reads all the props instead of iterating.

That solves the update props but not initial markup/render.

> Maybe if we get some actual numbers on perf impact in real apps we could reconsider if...

On a real component rendered by a real github user (chosen more or less at random), taking children off props and hosting the props object improved initial render time for my SSR renderer by more than 10%.  It brought a 36ms render down to a 29ms render.  Not a huge improvement, but very measurable, and the milliseconds add up.  This was on a different JSVM (ie. not V8) so the relative costs could be a bit different and numbers should be taken with a grain of salt, but still, it's a valid data point.

> to warrant a massive codemod/upgrade path.

The relative size of a codemod is debatable, depending on how far we would want to take such a change.  It only NEEDS to affect the representation of inline elements and the OUTPUT representation of `React.createElement()`.  We COULD change the public component API of ReactComponent, but this is not required to realize much of the performance benefit here.
 > That solves the update props but not initial markup/render.

For a known whitelist it still works, and for the `__t` optimization it works without a whitelist for elements that all use the same property names, which for HTML nodes is frequent.

> We COULD change the public component API of ReactComponent

If we change the inline representation, or output of `createElement` we would have to create a new object that gets passed into the public component API which would be much slower. Therefore, I think we would HAVE to change the public component API. I'm not sure what solution you're proposing? Do you mean special casing the "string" `type` element so that only native elements have this property?

> On a real component rendered by a real github user 

Can you point us to it? Is this a complex component or one that gets rendered a lot of times?

Also note that hoisting isn't free. We might need to lazily initialize the elements since otherwise we can negatively impact the load time of the modules, or come up with another optimization. That's probably something can overcome though.
 @sebmarkbage 

> For a known whitelist it still works, and for the __t optimization it works without a whitelist for elements that all use the same property names, which for HTML nodes is frequent.

You're still iterating to generate the markup, unless I'm failing to understand/see something (which is entirely possible).

> If we change the inline representation, or output of createElement we would have to create a new object that gets passed into the public component API which would be much slower.

Well, it's a dirty hack, but we could mutate the props before passing them to the component and then mutate them back when we're done, maintaining the illusion that ReactElements are immutable for the lifespan of the element.

> Can you point us to it? Is this a complex component or one that gets rendered a lot of times?

It's the component discussed here: https://github.com/facebook/react/issues/2608

I've found it to be a particularly good one to benchmark against.  I got my SSR render time down to 29ms, but without a couple of features (like `context`) which are not used here, and using some black magic like aggressively rewriting ReactElement.
  Yea, I think npm is treating this like a prerelease and ignoring it, even though it's published at `latest` (which I thought npm used by default but apparently not). Sorry for the confusion. I don't think there's a good way to handle this unfortunately :(
  Yes, this is a breaking change and you'll need to change your tests to be different, sorry. See 4070c4ca20b1d08a00fe278d561642e87373c09f. `detachedCoponent` is actually a DOM node now so the test utils can't look into it to find the React component tree any more. This rarely comes up because you'll almost always be testing your own components (it's our job to test that the DOM components work, not yours :)).
 @benhughes Can you paste a sample test so I can see what you mean?
 @sheepsteak That sounds like a different warning, but I'm glad you got it to work.
 I have not tried https://github.com/airbnb/enzyme but it looks promising.
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Can you update the tutorial repo instead to match the website? There's no reason this needs to be in a callback.
  React.isValidElement.
  This is extremely unlikely to be a React issue. If you can reproduce a problem using just React, please file an issue with a repro case that we can run easily.
  Yea, I agree. Thanks!
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 The `mountComponent` call of ReactDOMComponent also gets measured.

https://github.com/facebook/react/blob/master/src/renderers/dom/shared/ReactDOMComponent.js#L512

You could intercept it similarly to this:

https://github.com/facebook/react/blob/master/src/test/ReactDefaultPerf.js#L209

That should let you log the ID of newly mounted DOM nodes without needing to parse the HTML content. That's a bit safer. We're also actively trying to get rid of both IDs in the DOM and generating innerHTML content so that solution would help a lot.
 Does it work equally well if you call `_recordWrite(rootNodeID, 'mount', 0, [])`? If so, I think that's a little cleaner since you don't need to introduce a separate list to track. If not, this way is okay too.

I can merge this if you squash your commits.
 I agree that that is pretty noisy. Let's keep it how you have it ‚Äì mind squashing your commits into one?
 Try: `git rebase -i upstream/master`, then change all but the first line to read "squash" instead of "pick". After rebasing you'll need to force-push to your fork.
 Looks like you figured it out.
 (Thank you!)
  There are no parameters or flags, it will involve basically forking React. This is why nothing is documented. It's really not worth it for us to guide you through this so I'll point you in the right direction and leave you to it.

For the checksum related stuff, look for uses of the `ReactMarkupChecksum` module.

As for disabling sanity checks, we have a bunch of invariants and other checks throughout the codebase. There's no 1 place to disable these. You would have to decide which ones are important and which aren't.
  This isn't a typo, just a different way of saying the same thing. I don't think it really clarifies so I'm just going to close. Thanks for the effort though!
  http://www.oxforddictionaries.com/us/words/cannot-or-can-not

But yeah, the former is more common, so let's go with it.
  Thanks!
  Yea, this is annoying. It's not wrong at the beginning (before you need the server) but then it is wrong. We need to tweak this part of the tutorial and probably just require a server. See more discussion in https://github.com/reactjs/react-tutorial/issues/67.
  Repro: http://jsfiddle.net/trtz1y99/
  Did you actually try it?  We only pass the DOM node instead of the instance for DOM components (not composite components, like the one in this example), since finding the DOM node was the only thing you could do with a DOM component anyway.  In your case, I believe it'll all just work the way you're hoping.  Let me know if you're actually running into a problem in your code with 0.14.

In general, questions like this are better addressed on StackOverflow.  We use github issues to track bugs in React, so I'm going to close this out.  Feel free to continue the discussion here.
  Questions like this are best addressed on stack overflow.  Since this is not a github issue, I'm going to close it out.

Rendering a script tag is probably not what you want to be doing.  The biggest question is, why are you trying to render a script tag inside a div?  If you're trying to render an outside module, you should probably be invoking that module via javascript in your `componentDIdMount` function.  It's hard to tell exactly, since you didn't provide much background about what you were trying to accomplish.  I'd recommend posting a more detailed statement of your goal on stackoverflow and see what people there think.
 The problem is that `<script>` elements created with innerHTML don't execute, which also means they don't fetch the external resource. This is an issue with React, but it is longstanding and there are workarounds. There is also the issue that if we ever use createElement, those scripts will suddenly start executing.

@Jensyn - Since there's no way for us to do this reliably right now, what you might want to do is do the element creation manually after mounting, or maybe pull out that functionality so that you can create script elements in a shared way. Eg‚Ä¶

``` js
var _loaded = {};
function addScript(url) {
  if (!loaded[url]) {
    var s = document.createElement('script');
    s.src = url;
    document.head.appendChild(s);
    _loaded[url] = true;
  }
}
```
  The biggest problem when this happens is when you have two different Reacts that are unaware of each other. I.e. two different npm packages. Perhaps even of the same package and maybe even same version. It seems difficult for these two coordinate the ID even if they could set it manually.

It'd be better if we could auto-gen this ID so that it is unique. However, if a tree is server rendered, these IDs are already in use so that pattern have to be picked up potentially.

Another solution is something like we added in 0.14 where we look up the root ID to see if it belongs to this React and otherwise ignores it.
 #1939 is closed so we shouldn't need this any more. If more issues pop up we can address them separately.
 Is there any particular problem that prevents you migrating to 15? We‚Äôve been delaying 15 for a while now and really want to get it out. RC2 should be solid enough for you to try adopting.

Spending more effort on 14 branch right now is possible but will negatively affect development of 15.x, especially as it may introduce more issues which are not even relevant to 15 anymore. What do you think?
 :+1: Stay tuned, it‚Äôs coming soon!
  We definitely won't do this for 0.13 so I'm just going to close out so we can focus on the other PR.
  It's the semicolon in `})};` that you don't want.
  In conjunction with #1953, fixes #2407. This seems to be all of the shorthand style properties that IE8 supports, excluding a few nonstandard ones.
 Yea, we want trailing commas for consistency now (with the exception of things in `packages/` since they don't get transformed).
  Fixes #4599.
 This almost works, except MockedComponent here doesn't end up with the flag:

https://github.com/facebook/react/blob/2f96d70087494dd1b8e725abc4a0609d3985dbe6/src/renderers/shared/reconciler/__tests__/ReactMockedComponent-test.js#L53

@sebmarkbage ideas?
 If you use an object, jest will mock it. You would potentially set it to an object during **DEV** or testing maybe?
 Fixed by changing isReactClass to not have an underscore‚Ä¶

https://github.com/facebook/jest/blob/9d726ed478ecff19acc5bf04a2600e559818cfb6/src/lib/moduleMocker.js#L311
 Another thing we could do is:

``` js
element.type.prototype instanceof React.Component
```

That locks it into a by-reference equality (and therefore a single `react` package). Not sure if that is good or bad. Certainly more idiomatic.
 I like `instanceof`; feels cleaner than checking for magic properties.
 I thought the whole point (one of the whole points) of 0.14 (0.15 maybe) was that you can use more than one React. 
 @spicyj You can use more than one react-renderer without using more than one react-core.  `React.Component` lives in the shared core, and I think it's very reasonable to assume a single shared react-core.
  We won't take this as-is since setting all of the styles regardless of if they've changed will be bad for perf. It would probably be okay if we do this only in the case that the keys change, though it might be even better to do it only for shorthand properties (though I'm unsure if there's a way to do that without hardcoding them all). Maybe we could do something sneaky like looking for a prefix match.
 (Could've sworn we had an issue for this but I can't find it.)
 #2407 is the other issue.
 I was probably thinking of #2013.
 I agree with @syranide 
 > background is NOT shorthand for backgroundSize.

Yes it is. https://developer.mozilla.org/en-US/docs/Web/CSS/background#Formal_syntax
 @dheuermann It seems it behaves entirely as it should (it being part of `background`), it's just not serialized into the `background` property when read for some reason, but it _is_ serialized into the property if `backgroundSize` is set first and then changed it seems, in chrome at least. It doesn't really matter to React though, but it's a really weird discovery you made...
 @linmic updated the pull request.
 Thank you for sending the PR! I‚Äôm closing it as it hasn‚Äôt been updated in a few months, and it seems to me from this and other discussions that the consensus is that we should warn on mixing shorthand with normal properties. I opened #6348 so we can all agree on the implementation strategy that wouldn‚Äôt compromise performance, and discuss what we learned from other libraries like Radium and React Native, before diving into a specific implementation. I‚Äôm sorry this pull request didn‚Äôt get through but I hope to hear your thoughts in the discussion in #6348. Cheers!
  Thanks!
  I see no harm in taking this; it's a trivial change and allows us to be more compatible with people who are trying to move towards the new es6 spec.

@spicyj The linter is unhappy.  How can we work around this lint rule?
 Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 When I run React 0.13.3 through advanced mode in the web service, `.done` doesn't get munged. See the pretty printed output: http://closure-compiler.appspot.com/code/jscb00599ea343a44b366134a3ff8d03374/default.js (lines 2125, 4163, 4167). IT also didn't get munged in a small test case (used a Set and recreated the same while loop condition).

Are we sure they don't support this? I also see some mentions of iterators in their ES6 externs (https://github.com/google/closure-compiler/blob/0c09d82ab71f5518d6334692d279615e59c2b455/externs/es6.js#L86-L90)
 Ok, sounds like closure does support the existing code, so there is no need to merge this.  Let me know if this is the wrong conclusion and we can re-open/evaluate.
  Thanks!
  B is correct. See also #4433, particularly my reply.
  This is intended ‚Äì when the component is unmounted or the ref changes, the old ref gets called with null before it's called with the new value (or the same component instance again). If you store the instance on your component, this effect should be unobservable as long as your component is mounted, but it prevents memory leaks. If you want to do something with `c` in the ref handler, you should check if it's null.
  No we're not going to do that (keeping 2 documents in sync is not worth the trouble) but we could do a better job of making that message at the top easier to see. Sorry you had trouble though!
 May as well just delete it and set up a redirect? That's what we did for Thinking in React.
  Is this safe or is this potentially an XSS hole in hour demo? E.g. if the domain gets compromised. Does jQuery do a JSONP fallback?
 we can rely on a server running this demo. I believe some other demos doesn't work without a simple http server. We could just store this in a JSON file.
 Meh, I don't really care about hitting a random API server. It looks like it's only setting and image src which is escaped (unlike the element case). We could also change it entirely so it hits a service we trust more - could make it get an provided user's public github information.

I would probably do this differently though and only initiate the request on a button, with a clear "this is going to make a request to <endpoint> and load some data when you click here".

That said, requesting a local file is ok too. That would definitely require a running server in some browsers.

I didn't look at this much when it came in because our tutorial does XHR so we already provide code doing this.
 The issue is that $.getJSON does an indirect eval via JSONP. Probably.
 http://api.jquery.com/jquery.getjson/ seems to say that JSONP is only used if there is a `callback` query param.
 Meh, our tutorial does pretty much exactly this already so I'm just going to close out. Thanks anyway!
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 See more discussion in #4646 - not sure this is the right change to make.
  I think the correct way of catching `checked` state in CSS is actually using the `:checked` pseudoclass. For example, take a regular checkbox and toggle it. `input[checked]` doesn't get applied. See https://jsfiddle.net/dz76f7yn/ (yours plus one w/o JS)
  This has been asked for many times before. See discussion in #4751.

It might make sense to allow any function to pass through and become a "simple event plugin" by default. That way there is no whitelist necessarily. This would make it a breaking change if we ever added custom logic to that particular event. Which we likely will. However, that's the stance we've already taking with other attributes in general.
  React is trying to keep it's API as simple as possible
You can always pick something like https://github.com/JedWatson/classnames as described in docs @sairion referenced
 Thanks for bringing it up. It's a valid question and one we've discussed before. For now, our current behavior exists to stay inline with expected DOM behavior. `className` is a string. If we did make a change like suggested, we would probably just use `classList`, which is another DOM property more like an array. We'd still need to convert from a vanilla array and make add/remove calls (we also then need to do more work to make sure we clone the array you provide as props - simple equality will no longer work since it would be very possible to pass the same array reference as props on 2 render passes)

Regardless, this is really only important at the DOM element level. You composite components can take whatever props they want and convert to strings when rendering DOM elements.
  Seems fine to me, thanks.
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 @johngoren Are you interested in finishing this off?
 Superseded by https://github.com/facebook/react/pull/6059
  Sure, sounds good. Thanks.
  I just tried it in a fiddle (http://jsfiddle.net/5861bszr/).  Tested in both chrome and firefox; we are not swallowing the reference error.  I don't think this is a bug in React, but I'm happy to re-open/re-investigate if we can get a repro in the fiddle.
  React doesn't swallow exceptions, I promise you. Probably promises are getting you. See http://blog.taylormcgann.com/2014/08/21/catch-errors-javascript-promise-chains/.

Related issue reports: #2626, #2912, #4199, #2665, #4368.
  Dupe of #3131, more or less. I don't know yet whether we want to support this.
  Looks good, thanks!
  Looks pretty good.  One minor thing: we should mention `event.persist()` instead of having the user manually copy the event.

I'm also going to let the PR sit for a couple days so everyone has a chance to take a look before we merge.
 @edvinerikson Thanks!
  We went past the tipping point on this a while ago and we need to surface our translated docs. I spent some time this week looking into other options for generating our site but this gets us there way faster with minimal changes. It's only half the work though - there but there's still a bunch to do. The infra is here now but we're still going to have some hacks we have to do to make links work right.
### How it works (we're using http://jekyll-langs.liaohuqiu.net/):
- translated files live side by side like we already have with the exact same file naming convention (though perhaps we will end
- translated phrases live as key-value pairs in `_i18n/lang.yml`. I've done as much of the Korean as I can (copy + paste from the titles in the docs files)
- We can use these keys in a lot of places, `{% t string|key %}` outputs the value and will fall back to English (default).
- Due to limitations in how Jekyll passes things around there unfortunately a lot of duplicate keys in these files. I tried to cut it but couldn't make it work.
- English is unchanged (well except for 1 tiny thing which actually is broken on 1 page)
### Give it a try:

I set up a testing server - http://reacti18n.zpao.com/react/ko-KR/docs/getting-started.html

Links are definitely broken right now so no need to remind me :)

But I wanted to get some feedback before I took it any further, namely from the people who have been doing the bulk of the translation work - @tako-black, @makky3939, @marocchino, @sairion (and many others, perhaps you can spread the word amongst the translators you've been working with?), @spicyj . Does this approach so far seem like it's more maintainable for you moving forward? All of your current links will be broken but I'm not too worried about that (are you?).
### TODO:
- [x] make next / prev / sidebar links actually go to current language. Might need to do full paths in next/prev, needs more investigation
- [ ] link to other language entry points somewhere
- [ ] decide if we want full locale in the url or the short version (`/ko-KR/` vs `/ko/`, `/ja-JP/` vs `/ja/`, `/zh-CN/` vs `/zh/ (or cn?)`)
- [ ] Make header fragment links work
- [ ] language specific CSS (eg, font-size)
 @zpao
Thank you for your activities.

I checked the testing server. I think it looks good.
I think the short URL is good because it's simple.

Please tell me if there is I can do.
Thanks!
 Thanks for the feedback, I think we'll move forward with this and get it into shape for 0.14 launch (if not before). And it sounds like the general consensus is to use the short urls. I'm not sure how many North Koreans are using the site but they'll have to survive for a bit longer ;) We can always move to a longer url if we need.

There's nothing for you all to do just yet, but stay tuned here - we'll have a little bit to do soon.

> It would be also great if this approach can be applied to other libs like Relay, Flux, React Native, whatever lib React developers usually gets into.

I'm hoping we land on something that can at least conceptually be shared. Right now we're using a different site generator than those projects. I'd like us to converge on a shared stack soon so that we can solve these things once but we haven't yet.

> The docs website does not really look good when it is written in Korean

Ah, I hadn't even thought about that! Thanks, will definitely see what we can do about that.
 @sairion Good catch. I'll see what we can do about that.
 Sorry, no update here yet. I'll try to come back to it later this week. Feel free to update translations in the meantime!
 @zpao updated the pull request.
 Came back to this for a little bit tonight - luckily rebasing was pretty painless since I'm mostly just touching the metadata. Sidebar links and next / prev work and stay within the language you're already on.
 It seems likely that we‚Äôll revamp the docs completely in the coming months so maybe this isn‚Äôt worth the effort at this point. I‚Äôll leave it open though.
 Nothing actionable at this point. I'm still considering options that aren't Jekyll to make this better. I also want to get an external service setup with will help translators know what needs to be translated - the situation we're in with partial translations and not picking up updates to content consistently is rough.

I'll leave it open because I think what I've spent time on is valuable at least as a reference for whatever happens next, and it's good for people to know it's (at least sort of) being worked on.
 @gaearon Can you say more about which revamp you mean? I know @joecritch is interested in helping out with docs updates.
 I was referring to one of the weekly meetings but maybe I got it wrong. I thought at some point I heard that the existing docs were not written very cohesively, and somebody (from the Parse team?) might eventually help us write some of them from scratch.
 FWIW, there's nothing set in stone in regards to a content revamp, just some general hopes that it'll happen.
  Thanks :)
  Lint wasn't you, seems like a fine change otherwise. :thumbsup: Thanks!
  Is there something wrong with the old version / is there any motivation for us to upgrade?  (other than just generally good to be up-to-date?)
 Ok, I'm going to go ahead and close this bug out.  Not because we don't want to stay up-to-date, but because there isn't currently a "bug" that results from us being slightly out of date.  We don't ship the webcomponents polyfill to users (it's just for our own testing).  Since we won't get much value from updating, the return on investment is low, so it's probably not worth fixing at the moment.  When there is a new version that has changes which affect us, we can go ahead and update.
  I pushed 5395c815deea6bff0bb01a4e803800dc69c29886 and 989caa870d614458aee2f40fb08b2c1229a04248 (flattened your commits into one) so this should work now.
  cc @cpojer
 We should probably warn in that case or wrap it. Thank you!
 This should probably use ClassProperty behind a flag and throw/warn if that flag is not enabled.
 Constructor means something different than inlining it though. Most of the time I guess it is fine but the correct fix is probably

``` js
MyClass.prototype.foo = fooBar()
```
 I finally got around to do this. I solved this without an automated codemod but I'll see what other patterns I can find in the wild and might reconsider. I think this is usually an indication of doing something in an obscure way so I'll leave it up to the developer to fix the class before running the codemod. They can then pick whether they want to put something on the prototype, inline it in the constructor or use class properties ‚Äì it would require better static analysis tools to infer whether that function call or non-simple function declaration will have side effects etc.
  @tako-black updated the pull request.
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 Thanks!
  This was fixed in #5714.
  Thanks.
  Sorry I talked to myself in there‚Ä¶ I think this seems reasonable. There could still be some false positives  - eg, two different c'tors that both have `Cat` as their name, or more likely problems with primitives (eg `5 instanceof Number` will fail the proptype check but then the message will say that it expected Number and got Number) but that's why we have the other primitive proptype checkers.
 Thanks!
  Currently, it is not possible to define methods on a Class inheriting from a `React.createClass` component constructor, without having any colliding methods [automatically replaced](https://github.com/facebook/react/blob/d7b59de1c39c509aaf0d9d3f16999dc14fc5bd14/src/isomorphic/classic/class/ReactClass.js#L816-L818) by the methods which have been designated for autobinding.

This adds a simple check to ensure the function in the `__reactAutoBindMap` is === to the method on the component it intends to replace, otherwise the auto-binding does not replace the method on the inheriting class body.

To visualize, adapted from the included test:

``` js
var ParentComponent = React.createClass({
  testMethod: function() {
    throw new Error();
  },
  componentDidMount: function() {
    this.testMethod();
  },
  render: function() {
    return <div />;
  },
});

class ChildComponent extends ParentComponent {
  testMethod() {
  }
}
```

Previously, `testMethod` on the ParentComponent always replaces that of the `ChildComponent`, and `Error` would always be thrown.
 Never mind, just discovered #4612 which would also fix this nicely.
 Actually, this is slightly different than #4612 in that it disables auto-binding if the method is defined outside of `createClass`, which might be preferable behavior.
 I think it's probably just a _bad idea_ to combine createClass with ES6 classes (in the extension sense, composition is ok). Our "classes" are not regular JS classes and we've never made that promise.

cc @sebmarkbage
 I wasn't super happy with the amount of magic / internal state going on inside `react-native`'s Navigator class, specifically around transitions. I was looking to augment/replace the behavior of a few methods, specifically [`_transitionTo`](https://github.com/facebook/react-native/blob/56059e92dfa568a3d741da600d9c4cbef75a6422/Libraries/CustomComponents/Navigator/Navigator.js#L373), `render`, and `setState` without needing to reimplement the entire component.

I recall attempting to do it with a ref / HoC to make it more of a declarative stateless API but it required stubbing out the the entire external api and there were still a few things which prevented that approach from working correctly.

Interested to hear any suggestions which might make this easier.
 This is super complicated. I'm just not sure we can continue to support this use case. Inheritance is a mess which is why we prefer composition. However, if you want to use inheritance, just use ES6 classes all the way down.

As for the use case of overriding the navigator. If you're calling into private APIs you're effectively just forking anyway so you might as well just fork that file. Anything in the implementations can change anyway. For example, we'll like switch it to use ES6 classes or even just make it opaque with no instance (such as stateless function components).
 Makes sense, I've come up with a better solution for my case which doesn't involve inheritance.
  You can specify a dynamic `key` on your uncontrolled input, and when you want to reset it, you can bump the key value (with the new defaultValue being empty string or being whatever "default/reset" value you want), which will effectively reset the component's internal state.

You could also break out of React and use plain javascript to manually reset the input's state (since you're using an uncontrolled input anyway, the component is effectively expecting triggers outside of React to modify it, so this doesn't break the component's mental model/contract).

Or you could just "use a controlled input" as you mentioned before, which is the correct solution IMHO.

Anyway, there are several options at your disposal.  Your job as an engineer is to choose the one that's best for your use case.
 `defaultValue` is, in some sense, the hack (for people who want a "fire and forget" solution to implementing their `input` tags).  Think of it as an "initialValue" instead of "defaultValue" and it may make more sense to you.  The point is that you get a single opportunity to specify the value at component creation time, and then the component takes over from that point forward.

React pushes you to top-down data flow for a reason.  When you have siblings randomly influencing a node's state, it becomes very difficult to reason about the state of your application, and even harder to understand the ramifications of a given change.

If you need to be able to influence a component's state, then that state is no longer internal to the component (by definition).  Modeling it as internal state is a violation of the abstraction because touching a component's internal state is a violation of the abstraction.  If you need to control the component's state, you should probably be using a controlled component, IMO.
 @DylanPiercey I'm saying that resetting the form currently "resets" the form elements to their initial values, which is the currently expected behavior (conceptually, the component is saving the initial property into state on first mount, and using that state variable from that point forward; you can't go back in time, so you can't change that initial value, because it was already sent).  If you want more control over the state of your `input` components, I would recommend using a controlled input, which exists for the exact purpose of giving you the control.

You could always implement your own component which behaves like an uncontrolled input (does anything internally) and implements whatever semantics you'd like.
 @DylanPiercey You can also grab the native DOM node and set `.checked` on it manually if you prefer. Honestly, I'm confused what API you're proposing though. How would React know when to reset the value and know when to keep it as what the user entered?
 Maybe we can make `defaultValue` update the DOM too. Few people use reset buttons so this hasn't come up.
 I'm happy to take a pull request that passes defaultValue through to the DOM. It looks like that is linked directly to the `value` attribute. Probably the best way to do this is to change our code so that `value` is treated as an attribute (using `.setAttribute('value', x)` instead of `.value = x`) in the property config which is equivalent to setting `.defaultValue`, then ReactDOMInput can manually set `.value` instead of going through DOMPropertyOperations. Open to other suggestions.

![image](https://cloud.githubusercontent.com/assets/6820/11078149/dc4eefae-87b8-11e5-9bbf-73a7a9675795.png)
 (Marking as good first bug ‚Äì instructions are in my earlier comment; feel free to ask for clarification.)
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 Thanks!
 In the future, please make docs changes to the `master` branch. The `gh-pages` branch is a compile target and this will get wiped out by future builds.
  This is likely a red herring, the warning here didn't do the best job of detecting differnces like this, but we've improved it on master. Can you try with the latest betas and see if it still repros?
 Or rather, it would still report that something is different, but it should point you at the actual difference and not a random encoded entity (see other discussion in #4608)
 That's weird, I would expect both to use the enumeration order.
 Yeah, that should just use this for/in loop: https://github.com/facebook/react/blob/master/src/shared/stubs/Object.assign.js#L37. 
 Good sleuthing.
 @Spy-Seth your issue is unrelated. Make sure you have charset as utf-8 and if that doesn't resolve it please work it out elsewhere or file an issue if you can pinpoint a bug in React
 @Spy-Seth if you read the rest of the issue, I said the entity piece was probably a red herring and then the original reporter never responded. The rest of the discussion is about ordering of attributes (with some other discussion in #4608). If your issue is actually about encoding, then please file a new issue with a complete example to reproduce. It's otherwise impossible to help.
 @spicyj @mridgway what was the outcome here - did we need to make a change to `React.__spread`?
 Can anyone seeing wrong attribute orders re-install and make sure you have object-assign@4.1.0? That should fix the issue.
  Hmm, cc @sebmarkbage @spicyj.

This is sort of interesting in that the default prop resolution is a pretty major difference between `createElement` and plain JS objects as elements.
 This was an intentional change in c419cce5c9eeaf4d41f226016c852500bdcb4f71. At the time, @sebmarkbage said (in an internal FB group):

> More importantly, this change will mean that defaultProps can in the future get a perf boost. It will have similar performance characteristics as not using it (it used to be slow). Once we know that it works, it gives the option to use optimized descriptor construction. This is the missing piece: https://github.com/reactjs/react-future/blob/5874879a02ac0f0f81c2ea81a1f6dcaaf7ef7be7/01%20-%20Core/05%20-%20Elements.js#L58-L85

You'll have to find another way to do what you want. The upcoming "context" feature will provide another way for parents to pass data to children but we still haven't settled on an API and semantics we're happy with so we don't recommend using it widely.
  cc @zpao since he is the one who manages this stuff.

Our pages are mostly static (maybe with the exception of a little javascript), but...  Seems like the ideal thing would be to detect the user's preferred language from the browser headers, and if it's one of the translated languages, let them know that the translated docs are available and nudge them in that direction (put up a notice banner or something with a link to the appropriate translation).  This way, users see the translated docs regardless of how they reach the site (search engine results, links from forums, etc).
 This is definitely high on my list of things to do for the docs. I've actually been looking into this recently. Right now the situation isn't awesome and I'd like to get us to a slightly better place before we do this. My biggest problem is that even if you get to the Japanese/Korean/Chinese docs, it's hard to stay there. The sidebar only links to the English docs. It works if you click through the next buttons but that's fragile. #2876 started to solve this but never got got traction, and it's also really fragile (design changes need to be made in 4 places!)

So I'm looking into alternatives and will keep you updated.
  Behind a feature flag. This is a relatively simple change; adopting this strategy universally would mean that we could clean up a lot of code but this doesn't attempt to restructure more than necessary.
 oh üí©!
 If you turn it on, some of the tests fail because the nodes are from the wrong document and jsdom throws some exception. Not sure how best to thread the document through‚Ä¶ for the mount case we could attach it to the transaction but that seems wrong for the update case when we update multiple roots. Context? :D 
 But Facebook (the website) seems to work fine with it on so‚Ä¶
 What's the goal of doing this incrementally instead of creating two big forks?

The forks could compete on their own merit instead of trying to please each other.
 Well, this was less typing and makes it easier to run them side by side for an A/B test or similar. I figured if createElement shows comparable or better metrics then we can rip out the HTML code entirely and not worry about it (though I guess we might still need to keep it for server rendering and rehydration?).
 Let's give it a go.
 \o/
  :thumbsup: thanks!
  This is almost certainly a red herring. The warning message was improved to (probably) show the real cause in #4324. 
 Yeah. :\ Might be best to log it manually and use your favorite diff tool.
 (Easiest to call renderToString on server and client and compare after making the root IDs the same with find/replace. I'd love to make this nore automatic if you have ideas‚Ä¶)
 No, canReuseMarkup just looks at the checksum which is of the HTML before the browser touches it at all. There shouldn't be any cross-browser differences so if you have some maybe it's your code doing feature detection of some sort?
  Thanks!
  If you do this instead of using `renderIntoDocument`, does it work?

``` js
var div = document.createElement('div');
document.body.appendChild(div);
var component = React.render(<div className=... />, div);
var node = React.findDOMNode(component);
...
```

`renderIntoDocument` doesn't actually attach the node it creates to the `body` and my suspicion is that getBoundingClientRect is then reporting all dimensions to be 0 (which would make sense if it's not actually in the DOM).
  No, they get different keys in this case since they are in different slots ‚Äì a null placeholder exists when the components are not shown so A essentially has a key of 0 and B has a key of 1. If you had something like

```
var children = [];
if (showA) children.push(<A />);
if (showB) children.push(<B />);
return <div>{children}</div>;
```

then you would need keys. 

In the future, please only use this issue tracker for bugs in React.
  Please report this issue to https://github.com/facebook/react-native. They have their own packaging system which would need to understand this.
  Workaround is to setAttribute in componentDidMount but that's not awesome.

It was probably skipped because it's marked as deprecated and not suggested for use (I think `<caption>` is probably the best alternative. But if there's still some value then we could do it. Want to give it a shot?
 #4607 is in so this will be a part of 0.14.
  Thanks!
  We'll update the docs to clarify that this is a shallow merge. We won't change to do a recursive merge.

Thanks for bringing it up @mik01aj!
  To support arrow functions and plain functions as "components" we need to know if we can call new on them. Examples that won't work:

``` js
function PlainFunctionComponent(props) {
  return null;
}

var ArrowFunctionComponent = (props) => <div />;

class ClassComponent {
  render() {
    return <div><PlainFunctionComponent /><ArrowFunctionComponent /></div>;
  }
}
```

We need to detect if a component is a "function" or a "class" before calling `new` on it.

We can call `new` on everything if they're plain functions as long as they return a `ReactElement`. However, that won't work for null/false/string return values and we want to support those too. We also can't call `new` on arrow functions. Likewise, we can't NOT call `new` on classes.

Unfortunately ECMAScript doesn't have a way to detect if something is `new`able or not.

The current plan is to add our own static flag to React.Component so that we can detect if something is a class.

Any class pattern that doesn't require `new` should still be possible:

``` js
function ModuleComponent(props) {
  return {
    render() {
      return <div />;
    }
  };
}
```

I'm not sure how we can distinguish this pattern from one that requires `new` for warnings though. :(
 @rads That might be enough. A bit fragile. It also means that classes in ECMAScript can never have a default `render` function. :)

We might have more than one way of rendering in the future. E.g. `prerender` / `postrender` / `renderAtIndex`. That might still work though.

Will need to check if there's any difference in terms of engine optimizations between these options.
 Another solution would be to only allow arrow functions as plain functions since they have undefined prototypes they're easily detectable. E.g. `function Foo(props) {}` would be `new`:ed but arrow functions would be `call`:ed. Kind of sucks for transpilers since they don't follow this part of the spec.
 @threepointone No, that's still the case. This is unrelated.
 @sebmarkbage Want to do the prototype check or the static flag?
 `typeof Class.prototype.render === 'function'` wouldn't work on property initializers with an auto-bound `render` or some decorator that auto-binds everything.

Extending `React.Component` seems unnecessarily strict though. :/ Don't know...
 @sebmck Any plans on giving arrow functions and concise methods `.prototype = void 0` in babel?

Basically, we're working around the fact that we can't distinguish them from a plain function which is ambivalent with regard if it should be constructable or not.

I would go as far as saying that function expression/declarations should be considered deprecated as of ES6, and best practice should be to use any of the other forms of creation a function.
  React provides the notion of implicitly allowing a child component to store state (using the `setState` functionality). However, it is not just used for business logic state. It is also used to remember DOM state, or tiny ephemeral state such as scroll position, text selection etc. It is also used for temporary state such as memoization.

This is kind of a magic black box in React and the implementation details are largely hidden. People tend to reinvent the wheel because of it, and invent their own state management systems. E.g. using Flux.

There is still plenty of use cases for Flux, but not all state belongs in Flux stores.

Manually managing the adding/removing of state nodes for all of this becomes a huge burden. So, regardless you're not going to keep doing this manually, you'll end up with your own system that does something similar. We need a convenient and standard way to handle this across components. This is not something that should be 100% in user space because then components won't be able to integrate well with each other. Even if you think you're not using it, because you're not calling setState, you still are relying on the capability being there.

It undermines the ecosystem and eventually everyone will reconverge on a single external state library anyway. We should just make sure that gets baked into React.

We designed the state tree so that the state tree data structure would be opaque so that we can optimize the internals in clever ways. It blocks many anti-patterns where external users breaks through the encapsulation boundaries to touch someone else's state. That's exactly the problem React's programming model tries to address.

However, unfortunately this state tree is opaque to end users. This means that there are a bunch of legitimate use cases are not available to external libraries. E.g. undo/redo, reclaiming memory, restoring state between sessions, debugging tools, hot reloading, moving state from server to the client and more.

We could provide a standard externalized state-tree. E.g. using an immutable-js data structure. However, that might make clever optimizations and future features more difficult to adopt. It also isn't capable of fully encapsulating the true state of the tree which may include DOM state, it may be ok to treat this state differently as a heuristic but the API need to account for it. It also doesn't allow us to enforce a certain level of encapsulation between components.

Another approach is to try to add support for more use cases to React, one-by-one until the external state tree doesn't become useful anymore. I've created separate issues for the ones we we're already planning on supporting:
#4593 Debugger Hooks as Public API
#4594 Hibernating State (not the serialized form)

What else do we need?

Pinging some stake holders:

@leebyron @swannodette @gaearon @yungsters @ryanflorence
 I don't (yet) buy the argument that this shouldn't be solved in userland.  As an alternative, I think it might be a better to teach about state hoisting, rather than trying to implement something as part of the core.  Personally, I'm still a fan of the state-hoisting pattern (similar but different from https://github.com/facebook/react/issues/4594):

``` javascript
class View {
  state = { childStates: [ new ChildViewInternalState(), new ChildViewInternalState(), new ChildViewInternalState()] }
  render() {
    return <ChildView state={this.state.childStates[this.props.index]} />;
  }
}
```

Component implementations provide a black-box state object which may be retained by the parent.  If the parent does not provide the component's state, the component will initialize one internally (in which case, the parent forfeits the option to preserve that child component's internal state).

This also solves all three use cases described in https://github.com/facebook/react/issues/4594, without any special logic within the core and without increasing our API surface area.  It has added benefits (for instance, allowing the parent to query a component's internal state without getting a ref to the component, if the implementor chooses to expose that internal information as part of their public API - useful for things like form `input`).  Serializability is decided by the implementor of ChildView.

If we recommend this pattern, it can become the defacto standard, and then you can preserve entire subtrees by saving the root's internal state.

IMO, we should more aggressively utilize this design pattern to solve this problem.  If this state-hoisting pattern becomes the defacto standard, many of these problems just evaporate.

It doesn't require any universal library/framework; it only requires that components provide a way of passing in an internal state, which may be treated as a black-box by the parent.
 @jimfb I disagree that it is simple. Everyone doing this is building a library around it because of the boilerplate to deal with diffing lists etc. Edit: If this was the case, it would've been a solved problem in user space by now.
 @sebmarkbage Yeah, diffing lists sucks, but that can be solved with clever diffing libraries.  The implementation remains internal to the component and doesn't need a global external state library.  Components can swap out a diffing implementation without breaking other components/libraries.  Various diffing libraries can coexist perfectly without stepping on each other's toes and without requiring conformance to a global data loading interface (therefore, not harming the ecosystem).  We could even release an officially supported/recommended list-diffing implementation.  IMHO, people are developing their own frameworks because they don't know of anything better and we haven't sufficiently taught them about data hoisting (the pattern is never mentioned in any docs).
 @gaearon We can implement hot reload and time travel for the purpose of devtools / debugging with any model. People even do that with mutation. Reducers simplifies the implementation but isn't a feature in itself. The use case is solved by #4593.

To put it another way, some of the features you get is purely because you have your own framework. If you maintained React (or sent a PR :P ) you would have the same flexibility to add those features.

Do you have any other examples of use cases for reducers in production environment? We see a use case for declarative programming to solve timing issues. E.g. allowing execution to be deferred based on the tree being in an inconsistent state. https://github.com/reactjs/react-future/blob/master/09%20-%20Reduce%20State/01%20-%20Declarative%20Component%20Module.js#L32 However, this allow us to defer the tree resolution (and therefore props) before invoking the dispatch. This is not a use case that is solved by state reducers per say since any transformation of props is still synchronous. So what is the use case that make them valuable?

#4594 Solves the rollback scenario, I think.

The big difference between Flux patterns and the React component state tree is the divergence between the two hierarchical models. They seem inherently incompatible since one is optimizing for componentization and the other is optimizing for domain modeling. Perhaps, the top of an app should be modeled as a domain and then the leaves are opaque component state somehow? Except, how do you then deal with the same "user" form being open twice in different dialogs with different state. You have to refactor your domain model to model the view concepts which loses the appeal of the domain model to begin with. So perhaps they should remain parallel?
 Let me clarify a situation that I really want to avoid. I often hear arguments that goes something like:

Expose A, B, C. Then let the user implement however they want. It's totally flexible.

Except of course, once you only have A, B and C, there is only really one reasonable way to implement it. I think you alluded to this, @brandonbloom.

One data structure becomes defacto the implementation, or you have many small ones that are effectively the same. Then the only value they provide is for those authors to understand the inner workings.

We're not short on experimental implementations that can by-pass any React logic anyway. Especially with the decoupled renderers. Allowing room for experimentation isn't necessarily a primary goal. We already have that.

So, what would optional data structures for the state store try to solve? Better language interop? Are there app specific perf tradeoffs?

I'm leaning towards the idea that they don't really matter.

I don't think we'll restrict what can be put as values into state. For user space content there is obviously a lot of different data structures that might be useful. (Although immutable and serializable would be nice.)
 Yes but the key issue is: Is this a dev mode debugging tool or also a production API?

That strongly informs the implementation of this because this API limits the short cuts we can take. 

> On Sep 15, 2015, at 10:27 AM, Ryan Florence notifications@github.com wrote:
> 
> I get excited about redux because of time-travel debugging and eventually creating test cases out of dispatched actions ... but I really like how components encapsulate state.
> 
> Trying to create a place in redux state for each component instance is cumbersome and pretty ridiculous when the component already has a place for its own state.
> 
> Also, it turns out that component state is the state that the time-travel debugging is most useful! So the state I keep in redux is boring, the state I don't put in redux doesn't get time-travel. Feels weird.
> 
> What I love about redux is the middleware to create tools around the app's state. I'm sure this API has 8 trillion holes in it, but just to prime the conversation what if we had stuff like:
> 
> React.render(<App/>, el);
> 
> let tree = React.getStateTreeAtNode(el);
> 
> React.onStateTreeChangeAtNode(el, fn);
> 
> React.renderWithStateTree(<App/>, tree, el);
> That would be enough to build some time-travel debugging tools, yeah?
> 
> ‚Äî
> Reply to this email directly or view it on GitHub.
 @briandipalma Just my comment here: https://github.com/facebook/react/issues/3653#issuecomment-92526513

It is a pattern well-known to the team, but one which we haven't talked about much in the docs.  The basic idea/tldr is that you "hoist" the state up and out of the child component.  The child component defines some sort of black-box data type, which the child (optionally) accepts from the parent.  The child component stores all internal state into that object.  If every component does this, then the entire state tree is effectively bubbled up to the root node.

This gives the parent component full control over the state of the subtree.  Parents can "reset" their children by passing new/empty state objects, can "snapshot" a child by saving a copy of the state object, can "reparent"/"clone" a child by restoring/reusing a state object, etc.  Basically, it allows components to have fine-grained control of their children's internal state without breaking any abstractions.

In my example at the top of this issue, I defined a view that shows on of three child views (eg. a tab view).  The child views can be arbitrarily complex and retain any internal state even when the user changes tabs and then goes back to the first tab.

This pattern already allows users to pull state out the state tree, and avoids introducing new APIs.  IMHO, the pattern is woefully underutilized, largely because we've never documented it.  The "downside" is that state is effectively managed in userland rather than being managed by React, but that's the natural/unavoidable outcome if you're externalizing the state tree.
 @dantman Restoring a serialized/copied state allows you to re-render at any prior state in time.  Re-using the "current" state object allows you to re-render a component with the current/latest state.  Child components can trigger a re-render of themselves by calling `forceUpdate()` (or friends, like empty `setState`) after updating the current state object.

Not sure I completely understand the question, but let me know if the above didn't answer it :).
 @dantman Well, that "hack" would/could be solved by https://github.com/facebook/react/pull/3920 but that's a whole other discussion :P.
But regardless, that's why `forceUpdate` exists (to trigger an update when state isn't tracked by React).
 > serialize its state, re-hydrate it, ignore some of the actions, even react to them from other components, etc. Total freedom.

Is this the essence of your point? I.e. is seems like freedom to do those things is what is the goal.

However, there is nothing that needs to change from the React programming model is there? Or is it too opaque?

> On Oct 4, 2015, at 1:48 AM, Dan Abramov notifications@github.com wrote:
> 
> Just throwing in an example I bumped into today.
> 
> Here's a React component called Subdivide that has really complex internal state. Basically it lets you split a view into recursively nested views as many times as you like. (It's really cool, you should watch the video!)
> 
> All of this is abstracted away‚Äîyou just drop <Subdivide DefaultComponent={MyContents} /> and it renders <MyContents /> in every nested part of the UI which you can drag to create or destroy.
> 
> However we have another use case: persisting its state. Of course only the parent component(s) would be responsible for this.
> 
> The usual React answer in this case is ‚Äúmake it controlled‚Äù. We could accept value and onChange and pass opaque data structure there. This works for simple things (inputs) but I don't think this works for something as complex as Subdivide.
> 
> The reason I think it doesn't is because the data structure is too opaque, but the actions are actually not. The user may ‚Äúsplit panes‚Äù or ‚Äúunite panes‚Äù or ‚Äúresize panes‚Äù. All of these might potentially make sense for the consuming application, and it might want to react to these things. What if an app might want to ignore (only) some of these actions?
> 
> The way I'm proposing to solve it now is to export a reducer. If the consuming app is not using Redux (or similar reducer-based library), it can use <Subdivide> as a ‚Äúreducer-uncontrolled‚Äù component. In this case it manages its own state. If the consuming app is using Redux, we let you mount the reducer somewhere in your reducer tree, and connect <Subdivide> to this slice of state. <Subdivide> would then notice it's being connected (because it receives dispatch prop), and instead of changing its internal state, it will dispatch() actions that make sense to it. Then, the parent app can choose to serialize its state, re-hydrate it, ignore some of the actions, even react to them from other components, etc. Total freedom.
> 
> I'm not a huge fan of not using React state‚ÄîI agree it's a nice abstraction. But I think it's hard to hoist it up the tree unless you also export a computation (reducer in my case) so the caller may choose to use it in any way they like, and understand what's happening instead of receiving an opaque data structure in onChange. This is also the approach that Elm Architecture takes: any component exports both view and a computation (‚Äúupdate‚Äù).
> 
> ‚Äî
> Reply to this email directly or view it on GitHub.
 > rewiring child state changes to contribute to state changes somewhere up the tree

Can you give examples of what this is useful for?
 Good read: https://www.safaribooksonline.com/blog/2015/10/29/react-local-component-state/
  Relay and others currently abuses some internals to get some persistent identity of a component. This effectively is used to restore the state of a component after it has been temporarily unmounted. It is also common to abuse Flux stores for this use case. Basically, since this capability doesn't currently exists, you're encouraged to use Flux for everything just in case you need this capability later on.

The purpose of this issue is to discuss a public API for hibernating the state of a component and then restoring it once the component remounts.

The use cases can be broken down into three scenarios:
- **List Item Out of View**:  E.g. Infinite scrolling (such as "table views") where one row eventually needs to be reclaimed to save the memory used by the tree that is out of view.
- **Detail View**: In a master-detail view, clicking one item in the list switches the state of the detail view. When you click on the original view again.
- **Back/Forward Button**: You want to save a snapshot of the state when you navigate. The new view can then change the state and when you hit the back button to return to a previous state, you want to restore the original state of the subtree.

We would like to support this at least in a non-serialized form. You could imagine having an API that serializes this to JSON or some other data structure too but that's a potential follow up and not necessarily part of this.

One potential API:

``` js
class View {
  state = { stateKeys: [{}, {}, {}] }
  render() {
    return <ChildView key={this.state.stateKeys[this.props.index]} />;
  }
}
```

Basically, an object is used as a key. Unlike the normal key semantics, the state of the subtree is kept in memory indefinitely. We use a WeakMap to keep the state. If the object ever goes away, the GC will collect the state of that subtree. This solves all three use cases.
 Personally, I'm still a fan of the state-hoisting pattern:
https://github.com/facebook/react/issues/4595#issuecomment-129611074

The pattern is almost identical from a usability perspective (the difference is very subtle), but doesn't require any special support from React.
  The idea is to have a multi-version extension that allow you to attach a "debugger" to a running React instance. This debugger protocol injects intercepted functions into a particular version of React which exposes development hooks.

Effectively this: https://github.com/facebook/react-devtools/tree/devtools-next/backend/integration

This is not intended to expose stateful reflection APIs in production use since it will negatively affect performance.
 Yes please. The new devtools was designed with this in mind.

We would like to move the integration part into React's core and expose that API.

https://github.com/facebook/react-devtools/tree/master/backend/integration

The key to this design is that React should not need to maintain any state itself. Other than the component state. The API could force a complete rerender to get a replay of changes but the API should not require React keeping the previous render in memory.

> On Oct 8, 2015, at 2:35 PM, Dan Abramov notifications@github.com wrote:
> 
> I'm very interested in this.
> 
> With the advent of stateless components there's no easy way for my library to get internal instance of the root component to traverse the tree and force update it.
> 
> The important part for me is that multiple tools should be able to hook up to this API. Both DevTools and my library should be able to register independently without interfering with each other.
> 
> Would you like me to propose a straw man API based on what DevTools uses now?
> 
> ‚Äî
> Reply to this email directly or view it on GitHub.
  We have a few use cases that we support which shouldn't rely on `document` or other DOM specific globals to be available.
- Shallow Rendering
- Worker Renderers (e.g. react-native like environments)
- Server Rendering (setState etc shouldn't look for document)

Unfortunately we often screw this up. Which leads to work arounds:
- https://github.com/gaearon/library-boilerplate/pull/6
- https://github.com/facebook/react-native/blob/master/Libraries/JavaScriptAppEngine/polyfills/document.js#L28
- https://github.com/facebook/react/issues/3620

Part of the problem is that jest comes with JSDOM always on. We need to have a test environment that allow us to execute in a DOM-less environment.

We also need to add separate unit tests for these three test cases that execute in a DOM-less environment.

We could potentially add a lint rule against using globals in files in the `shared` folder.

We should also get rid of all uses of `canUseDOM` since it varies by render tree, not environment.
  We do make a best attempt here at including a reference to the owning component. If you have a specific case that isn't warning, please include code and we can try to help better.
  @springuper AFIK, `grunt test` still works in latest.  Have you done an `npm install` recently?
 I've got grunt test breaking for me to on master. fresh node modules, I tried iojs, node 0.12, and node 0.10.
:(
 This is a result of using iojs / node 0.12. We don't currently build with either. We use node 0.10 and npm 2.x. (1.x will have a different issue).
  You can already define your own proptype in user land, and use that in your components, so this shouldn't be a blocking issue.  We aren't working on the proptypes feature anymore (everything is moving to static analysis tools like Flow), so proptypes are on their way out.  I'm not sure if we'd accept a PR, but I do know it's not something we'd actively develop internally.
  Stateless pure-function components give us more opportunity to make performance optimizations. For now, we'll do a minimal implementation which has similar performance characteristics to other components in the interests of shipping 0.14 and allowing people to begin writing code using this pattern; in the future we can refactor to allocate less and avoid other unnecessary work.

This adapts @vslinko's tests from #3995.
 cc @sebmarkbage

@vslinko: Thanks for your work in #3995. We're planning to go with a minimal implementation for now but let's keep your other PR open to see if we want to pull it in for 0.15.
 lgtm
 @epsitec You can read the relevant discussion is here: https://github.com/facebook/react/pull/3995#issuecomment-123353574
  We're more likely to be able to reproduce if you give us a contained and ideally reduced example. As is, it's impossible to say if there's something wrong with the code you pasted, the mixins, or jquery. If we can't run the code, there's a really good chance we can't figure out the problem.

The only thing jumping out at me initially is that you need to have a "tbody" around your "tr"s. That might be the cause (would result in the browser modifying the DOM but usually there's a different error)
 If that doesn't fix your issue, please file a new one with a simple repro case that we can use to test.
  Yea, this seems reasonable, thanks!
  Calling `setState` on a component should cause it to re-render.  You can force a re-render by using the `forceUpdate` function.

This sounds like a usage question rather than a bug in React.  We use github issues to track bugs in React, so I'm going to close this out.  Feel free to continue the discussion on this thread, or take such discussions to StackOverflow.
 @trquoccuong take a look at the documentation on controlled components (http://facebook.github.io/react/docs/forms.html#controlled-components). You will likely want to handle the user checking a box so you can set the `checked` prop.
  Looks good, thanks!
  See https://github.com/facebook/react/pull/4311#issuecomment-128385681.

cc @jimfb @syranide 
 @syranide Thanks for testing.
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 Just the one change and otherwise it looks good. thanks!
 @marjan-georgiev Looks good, thanks!
  Thanks for the PR! Now that #5714 is merged, all attributes on SVG elements will be passed through as is, with no need for the whitelist. I'm closing but let me know if you still have problems with master.
  I understand where you're coming from. We've switched to console.error in the latest version so you get a full stack trace in the console, and you can put a breakpoint at the warning callsite to catch it in your debugger. (Or check "Pause on Caught Exceptions" and you should get stopped in the debugger.) We should document this better.

We don't throw for a subtle reason: we want to allow inlining elements at compile time so that your example would be (approximately) equivalent to `{type: null, props: null}`, which wouldn't throw. Since we want to have the observable behavior match identically between dev and prod in all cases, we don't want to ever throw in createElement. Sorry that this makes debugging a little harder.
  @chandu0101 Thanks for flagging. I understand the pain but I'm also not sure this is actually the right thing to do.

@sebmarkbage do we want to support all the ways non-JS can compile to JS or just say scala-js needs to fix this? Do we expect that displayName as an instance property will be the path of least resistance in future JS classes?
 My intuition is that once ES6 classes become utilized in the wild, this problem will solve its self.  In the mean time, we should probably make a good faith effort to support the most popular compile-to-js languages (coffee script, scalajs, etc), and have the less popular ones conform to one of the compile outputs of the bigger ones (which realistically, they'll probably do already anyway).
 This is something that needs to be solved at the scala-js language compatibility level. Ideally it should preserve the "function" `name` when it exports a JS class.

It has the notion of object properties so perhaps something like this could work:

``` scala
object Test {
  val displayName = "Test"
}
class Test extends ReactComponent {
  def render() = React.createElement("div")
}
```

I don't know.
  As per @JohnyDays, the flow repository would be a better place for this.
 You might have an issue with the `jsx` command line too not transforming properly. If that's the case, I encourage you to start using babel instead.
  React.Children.map should work fine on a single child. Please file an issue with a repro case if you find otherwise.
  I'm a little surprised the code above doesn't work.  Are you sure that's the only code in your app?  Specifically, the error message seems to reference a "Paper" component, which I don't see used here, though maybe it's part of RaisedButton.  If you could create a simple jsfiddle that demonstrates your issue, we can investigate further.

We're trying to use github to track bugs in React.  Questions like this are better addressed on StackOverflow.  Since this is not a bug in the current version of React (master has switched to parent context and so this warning is gone), and since this appears to be a question rather than a bug, I'm going to close out for tracking purposes.  Feel free to continue the discussion on this thread, or move to StackOverflow.
 In addition, context is not and has never been documented or supported. Please don't file issues asking how to use it.
 They shouldn't use it either.
  As a workaround I would recommend getting a `ref` on it and manually setting the attribute.

``` js
function attachCustomAttributes(domNode) {
  if (domNode) {
    domNode.setAttribute('webkit-inline', ...);
  }
}

class Video {
  render() {
    return <video ref={attachCustomAttributes} />;
  }
}
```
 See #140 for the long history of custom attributes.
  I think you'll want to file this in https://github.com/strml/react-grid-layout, this isn't a React issue.
  Yea, this makes to me. Just the one comment.
 > `value` is always evaluated as `true`

I'm pretty sure that's not correct. Eg, `checked={false}` Though maybe that doesn't get down this codepath?
 :thumbsup: Thanks!
  Thanks. FWIW, `npm test <filter>` is the equivalent
  Yup not React. We moved some files into a different project for sharing deps (fbjs). We've long said that requiring into `react/lib/` will probably break. And that is now starting in force.
  @syranide is correct.  You can do whatever you want within the children of a leaf node of a React render tree.  React does not prohibit you from using mutative APIs, as long as you don't interfere with nodes that were rendered by React (that is to say, don't mutate a node that was rendered by React, because that would confuse React's reconciliation algorithm).  You can add/mutate children to a leaf node, but don't modify the children to a non-leaf.

We're trying to use github issues to track bugs in React, rather than questions.  For this reason, I'm going to close out this bug.  Feel free to continue the discussion on this thread.  For future reference, questions like this are better answered on StackOverflow.
  They really shouldn't be entirely separate bundles - `react` requires `lib/React`, `react/addons` requires `lib/ReactWithAddons` which requires `lib/React` - but the issue has definitely come up before with various packagers. There isn't really anything we can do here so closing out. For usage questions like this, you'll probably have better luck on stack overflow.
  We shouldn't support both, just one or the other. I recommended this approach at KA and since it solves everyone's problems I'm fine just changing it to duration for everyone in React. We could support both for a release with a warning.

We could also look at using getComputedStyle and looking at the resulting transitionDuration. That might be better.
 Okay, let's plan to go for durations always and for now, warn when no duration is specified. In the next release we can remove the automatic duration support completely. Thanks @djrodgerspryor.
 Regarding your first point: I don't think there are plans to change the prop validation logic.  Prop validation is mostly being replaced by flow anyway.

Regarding your second point: I'll create https://fb.me/react-animation-transition-group-timeout for you, you can go ahead and use that.
 @djrodgerspryor This looks great ‚Äì just a few inline comments. If you can fix those up and squash your commits, I'll merge.
 Thank you!
 0.14.
  What we have here is actually just an antipattern - you shouldn't be modifying props, you should consider them immutable (and we actually do freeze in dev). That is information that you actually want to store in state and use. Then you would cloneElements in render so that the children get rendered with correct style. Something like this (obviously a lot is still missing): 

``` coffee
React.createClass(
  _distributeHeights: ->
    # Want to be careful with this, otherwise you'll get stuck in an infinite render loop
    # when used with componentDidUpdate
    this.setState
      height: @props.height - React.findDOMNode(@refs.tabbedArea.refs.tabs)

  render: ->
    children = React.Children.map (child) ->
      React.cloneElement(child, {style: height: this.state.height})
    TabbedArea(props, children)
)
```
  Alternate method of jumping to the root of the render tree.

https://github.com/facebook/react/issues/4511 is a nasty bug to fix, but the recent event work makes it slightly more likely that we'll hit this bug.  This change helps mitigate the issue by avoiding the calls to `ReactMount.getId()` that do invariant checks, thus allowing us to tiptoe around the underlying issue.

On a side note, there are some thoughts that this might be slightly faster too, so it might even be a perf win :).
 cc @sebmarkbage @spicyj 
 @sebmarkbage Updated.  Manually tested it in chrome and firefox, both with and without webcomponents.  Also tested with the polyfill.  All looks good now.
 We should put this on hold: https://groups.google.com/a/chromium.org/forum/#!topic/blink-dev/8_x0OHYQdx0

https://w3c.github.io/webcomponents/spec/shadow/#widl-Event-deepPath

This is getting renamed and/or deprecated. It seems like there might be edge cases where even deepPath isn't enough. I think we should keep this disabled in 0.14 until there is at least a second implementation and the spec stabilizes.
 I think I've also found another edge case that we're not testing for.

Something like: `<div><x-custom><div onClick={...}>...</div></x-custom></div>`

Where the shadow DOM created by x-custom could've used `<content />` or similar to render the child at a different path that doesn't line up with our expectations. Especially if that shadow DOM is also using React.
 It appears that the code path that was introduced in #4150 was later completely removed by f470cb88f88b4667419f170fcc7971dad4298494 so this no longer merges. 

I am closing per @sebmarkbage‚Äôs comments above. If we plan to get back to this let‚Äôs create a separate issue describing the problem, and reach a consensus on how this should be handled.
  cc @spicyj who added a warning against this. #2504
 Well, previously Safari autocompleted both and we assumed they would do the "right thing" and use `Webkit`, leaving `ms` as the only one not following that pattern (MozTransform, WebkitTransform, OTransform, msTransform) but I guess now Moz is the odd one out (O is effectively dead).
 Sigh.
  Locale is one of the intended use cases of context, and dynamically changing it (occasionally) is expected (and supported to the extent that context is supported).  Keep in mind that changing context may be somewhat expensive, so avoid setting it every frame or whatever, but yeah.

Only known bug that you might run into is: https://github.com/facebook/react/pull/4344

Closing this out, since we use github issues to track bugs in React, and this is a question rather than a bug.  A better place for questions like this would be discuss.reactjs.org or StackOverflow.
  Thanks!
  Feel free to add it directly to the wiki :)
  We render `<noscript>` elements in the DOM too, so you'll have issues with those pseudo selectors client-side too. This is how we make it possible for `render` to return `false` and `null`. Right now we need each component to map to a node. While this restriction is in place, we'll continue to insert `<noscript>` elements. There isn't really a fix in sight for that and there are couple other issues so I'm going to close out.
 A little bit more clarification since I didn't initially notice this was specifically for `renderToStaticMarkup` - we're trying to keep that code path and output the same as `renderToString` as much as possible. This makes it so that somebody could switch and mount on the client without having to revisit they're stylesheets and other assumptions like DOM structure.
 IIRC there are issues with that though I don't know off the top of my head. Perhaps @chenglou does?
 Eh, I think comment would accidentally disappear in older browsers? @syranide knew
 We still support IE8, but yeah.
 I don't recall us considering comment nodes (which sounds like a good idea!), though I would also believe @syranide if he says we did.
 https://github.com/knockout/knockout/commit/664886162ac08483f0bc5391857d0ef8a0272de3 is the closest I can find.
  Questions like this are better addressed on StackOverflow.  We're trying to keep github issues for tracking bugs in React.  This is not a bug in React, so I'm going to close it out.  Feel free to continue the discussion on this thread, or move the conversation to StackOverflow.
  As mentioned, this is working as intended, you actually want a controlled component.
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 Thanks! Can you link to http://babeljs.io/docs/usage/browser/ instead of JSXTransformer.js too?
 Awesome work. Do you mind squashing your commits together?
 Thank you @rgbkrk!
 Would you be interested in doing a scan of the rest of our docs and see where else we are talking about using JSXTransformer (and `text/jsx`) and see if we can update those too? We should be consistent with our communication here. If not, I'll probably do a pass later tonight.
 I started to and I can finish it up today (I'm going to make some other related changes so will try to get them all in together).
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 Good catch, thanks!
  I got caught up with some other work yesterday but they're up now. Thanks for the reminder.
  Creating a div inside a table is invalid html, the browser will actually rearrange DOM nodes when this happen. Tables are especially fragile like this.

React always renders into a node, it does not replace. You could render into a thead or a tbody, or even a tr or td, but you can not render a single node into a table and keep the existing children.

This is a known limitation of React that we can't get rid of at this point so you'll need to design your structure a bit differently to work. Sorry.
  You bring up some good points.

> Lack of documentation

Absolutely. We don't document everything as we go. Sometimes we get some in there and it lands in master. We usually file an issue close to release to list out the things that still need to be documented.

As for a place to discuss, I'm not quite sure if an issue is the right place. It might be, but I want to say that this would be excellent for https://discuss.reactjs.org/ (though @spicy might tell me I'm wrong).

> No JsFiddle

Yea, this hasn't been awesome. We've mostly chosen not to ship the browser builds of alphas and betas, only doing RCs and finals. Especially for 0.14 where we aren't 100% sure on what we're doing with the package (now that we're trying to split react and react-dom). We do have an unadvertised fiddle that uses the latest builds from master which I have on my server (http://react.zpao.com/builds/master/latest/). We intended to get the builds to a more sanctioned location with https but haven't yet, so go wild: https://jsfiddle.net/reactjs/ghmpo42k/

> peerDependency problem

I think the dependency problem is "solved" using the pattern @syranide mentioned, but it can still be annoying. I've used `"react": "^0.13.0 || ^0.14.0-beta1"` and I'm pretty sure it's working. Though if it's not that's unfortunate. We do publish to the `next` tag. Perhaps we could also tag with `next-0.14` so you can at least scope (as opposed to picking up 0.15 alphas when they come out).
 > It seems there are quite a bunch of spammers :)

Uggh, that's new‚Ä¶ Let's crank the spam protection up to 11 @spicyj.

> @zpao the JsFiddle you give, is it always the same address for the latest pre-release?

That is always the latest build from master, which will likely be ahead of the latest pre-release. But it is always the same address. We can update the original it if we move the location of the builds.

> So what I want is basically to set a semver range for supported stable versions, but still also allow any alpha/beta/rc be used by users without having too much pain dealing with shrinkwrap.

Unfortunately this isn't really a problem we can realistically solve. We can make a suggestion about what to put as a dependency as mentioned for prereleases but that's still something a library author has to do. The dependency management is all npm here. I mentioned the `next` tag that we're publishing to. Perhaps `>=0.12.0 || next` will work?
 I didn't expect that but on rereading that part of the spec, it's right there.

> Precedence for two pre-release versions with the same major, minor, and patch version MUST be determined by comparing each dot separated identifier from left to right until a difference is found as follows: identifiers consisting of only digits are compared numerically and identifiers with letters or hyphens are compared lexically in ASCII sort order

And backed up with the semver module (tested with caret ranges since those are default):

```
> s.satisfies('0.15.1-beta9', '~0.15.1-beta9')
true
> s.satisfies('0.15.1-beta10', '~0.15.1-beta9')
false
> s.satisfies('0.15.1-beta.9', '~0.15.1-beta.9')
true
> s.satisfies('0.15.1-beta.10', '~0.15.1-beta.9')
true
> s.satisfies('0.15.1-beta9', '^0.15.1-beta9')
true
> s.satisfies('0.15.1-beta10', '^0.15.1-beta9')
false
> s.satisfies('0.15.1-beta.9', '^0.15.1-beta.9')
true
> s.satisfies('0.15.1-beta.10', '^0.15.1-beta.9')
true
```
  Yea, this looks good but can you make sure that lint knows not to apply that rule in this file. `/* eslint-disable comma-dangle */` at the top of the file should do it. Perhaps one day we'll run this through babel and it won't matter but we don't right now.

FWIW, you may want to run all code through a transform when packaging. Depending on 3rd party code to be IE8 compatible isn't super realistic these days (even if just for things like using reserved words as object keys).
 Ah, I missed that this got updated. Thanks!
  Going to merge this into #1657. It's a known issue that we're missing a lot of SVG support. See particularly my comment (https://github.com/facebook/react/issues/1657#issuecomment-47708471) where I explained why we haven't added everything. I still don't want to do each of these as 1-offs. Does this suck? Yes, absolutely. Sorry :(
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 Thanks @afhole!
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 Thank you for the PR, and sorry about the long wait. Now that #5714 is merged, all attributes on SVG elements will be passed through as is, with no need for the whitelist. I'm closing this but please let me know if you have any troubles in master.
  Possibly a namespacing issue?  I have no reason to say that, other than it sounds intuitively reasonable to me.  (May therefore be tangentially related to https://github.com/facebook/react/issues/3420)
 `getMarkupWrap` was moved out of this repo and is now a dependency. It already supports `mask` (https://github.com/facebook/fbjs/blob/master/src/core/getMarkupWrap.js#L71). I don't think we're going to backport to 0.13 (I don't foresee us doing any more releases there).
  We only link to 19/25 talks. What about the other 6? It might also be good to mention the lightening talk participants (maybe just embed that playlist?).
 Ah sorry GitHub is terrible at alerting when new commits come in (aka, it doesn't). I made a couple more changes and pushed 0b07fed32cb095fa65f6f34c1408bd07cc4bc991 (and cherry-picked to stable).
  Sounds like a bug to me, cc @spicyj just in case this is expected behavior.  Marking as 0.14 milestone under the assumption that this is a regression.
 Yes, this seems wrong. refs should only be called when a component is mounted or unmounted.
 Never mind, this is actually right after all (and the same as 0.13). The function instance is different so we pass null to the old one and the component to the new one.
  I can't tell what's going on here without the implementation details of your tab code, but I suspect that `TestUtils.Simulate.click` isn't outright broken, since we have many unit tests that rely on that functionality.  For a usage example, I recommend: https://github.com/facebook/react/blob/master/src/renderers/dom/client/wrappers/__tests__/ReactDOMButton-test.js#L25
  Fixed in https://github.com/facebook/react/pull/4513
  This is called `renderSubtreeIntoContainer`.  That solves the problem of a conceptual child that is rendered at (for instance) the body so it can be positioned like a `Popover/Dropdown/Dialog` but still needs access to context.

Also, to be clear, the "wormhole" pattern is a completely different pattern.  "Wormholes" are when a parent needs to pass information to a child (usually ~1 level deep) that the parent didn't directly create.  For instance, a `Table` component that takes in a `TabelCell`, so someone creates a `JimboxTableCell` that renders into a `TableCell`, passes that `JimboxTableCell` as a child to `Table`, and now the `Table` component wants to pass a style or whatever to the `TableCell`.
 Or rather, I suppose the name is now `ReactDOM.unstable_renderSubtreeIntoContainer`.
 Because `context` isn't supported, and, you know, doesn't actually exist.  It's all a myth :).
 `renderSubtreeIntoContainer` also hasn't been shipped to a stable release so we haven't mentioned in the docs yet.
  I think he is looking for `it.only` which lets you specify a single `it` to run within the test.
Documented in https://www.npmjs.com/package/jest-cli#globally-injected-variables
 Yea, this is a result of us changing out testing infra a little bit. We're now using `NODE_ENV === 'test'` to determine if we should apply certain transforms. This is why both of our sanctioned testing methods now set that before running `jest` (eg `npm test === NODE_ENV=test jest`, `grunt test` does similar). Running `jest` on it's own will result in `__DEV__ = true` being transformed to `process.env.NODE_ENV === 'production' = true`, which is indeed an invalid left-hand side in assignment.
 Oh but to also answer your question about running a single test‚Ä¶ `npm test src/isomorphic/deprecated/__tests__/cloneWithProps-test.js` will work (at least in npm >= 2, which I think we require now anyway)
 Comments like that are inappropriate in this space. I deleted another you made previously. Please read through https://code.facebook.com/codeofconduct and refrain in the future. This is your 1 warning.
  Duplicate of https://github.com/facebook/react/issues/4216.  Fixed in 0.14.
  We shipped this in 0.13 but then exposed it as `React.unstable_batchedUpdates` (or `require('react-dom').unstable_batchedUpdates`) in master. We should deprecate the usage in `React.addons` (separately from other deprecation notices because we aren't shipping this as a standalone addon).
 `require('react-dom').unstable_batchedUpdates`. As of right now, the batching is a part of the reconciler which lives in `react-dom`, even if it's used by non-dom event handlers.
  If your problem is due to a consumption of a 3rd party code (Alt) then you'll probably want to bring this up with them. It looks like you're pointing at the `Alt.bootstrap` callsite.

Something is passing an object with keys as children. This won't work (already? soon?) so the warning is fired.
 Hmm, that warning should have been there in 0.13.3.

What are next steps?  Do you want to confirm that you weren't getting the warning in 0.13?  Or should we close this out under the assumption that this warning is correctly printing a warning?
  Yes, this is still a goal and a lot of the work in 0.14 is a setup for this. You can read through the 0.14 beta blog post for some more info (though we didn't explicitly call out react-native) - https://facebook.github.io/react/blog/2015/07/03/react-v0.14-beta-1.html#two-packages.

I think the more likely scenario at this point is probably that we'll have a react-native package with its own ReactMount-like implementation. And in fact it's likely that each renderer package will ship its own ReactMount. One of our upcoming goals is to spec out this renderer stuff so that we can give you a more definitive answer.

So I think at this point actually changing ReactMount in react-dom might not be worth it. But let's loop in @sebmarkbage and @spicyj who might have some more context.
 @madjam002 This is the plan yes. We need to keep it in the `react` package for now to avoid breaking everyone using it. However, in 0.14 it is marked as deprecated.

The plan is to get rid of all the dynamic injection completely and only rely on static dependency injection. E.g. overridable module resolution.

You'll probably see a lot of changes in this area the next few months since our goal is to clarify the API for what the "official" way to make renderers should be.
  You posted a self-referential link back to this pull request; I assume you intended to link to: https://github.com/facebook/react/issues/4521

The unit tests aren't passing, as per Travis.

Conceptually this feature seems reasonable to me but we should confirm with @spicyj and @sebmarkbage
 This is only wrapping it in ReactClass which doesn't work with ES6 classes etc. It should be done in CompositeComponent if anything. However, I'm not sure if these necessarily are makes sense as part of ReactPerf or some more complete profiling solution.
  You can't put a text node inside a checkbox node.  Browsers will change that for you on the fly (specifically, they will pull the text out of the checkbox), which is what is confusing React.  To solve your test case, pull the text out of the input, where it belongs: http://plnkr.co/edit/j8dM7af9RWgrpUztPkjk?p=preview

I'm going to leave this bug open because we should warn in this case.  Issue is to add a warning when a checkbox contains markup.
 Yeah, I didn't see a warning in the plunkr, which appears to be using React 0.13.3
 The warning wasn't in 0.13; it will be in 0.14.
  We can't just create an instance of the class using the constructor and use that as an element because a single element can be inserted into the DOM in several places.  We need to create an instance of that class for each insertion point of the element.  This is why elements are not instances of the class.

It's worth reading Sebastian's post on the motivation for the factory pattern: https://gist.github.com/sebmarkbage/d7bce729f38730399d28

I'm not particularly familiar with scala.js, but rather than using the @JSExport annotation (I'm assuming that's an annotation) you might be able to create your own annotation (@ReactComponentExport) that automatically wraps the output in a call to createFactory before exporting.  That would basically get you what you want.

Short of that, we've tried to keep the burden as low as possible.  Calling a single function (createElement) is about as low as we know how to make it.  If you're looking for something even lower friction (like jsx for scala.js), my guess is that you would need to implement a transformation/extension of some kind for your language.

Since this was/is the best design decision we know of to date and isn't actually a bug in React, I'm going to go ahead and close out the issue.  Feel free to continue the discussion in this thread.
  The license is specified in package.json. Do you mean the actual license file?
 FWIW, each file header also shows that it's BSD. I know what dealing with legal is like though so let us know if there are concerns.

``` js
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */
```

It's probably a good idea to ship the license and patents file regardless (will put that on the list for the next release).
  If we're going to add such a thing, it should probably be added to ReactDOMButton.js rather than to createElement.

Having said that, the default behavior for a button is, I believe, 'submit'.  Defaulting to 'button' sounds like the wrong behavior to me.  I'm assuming that IE 9/10 is finding the next button of type `submit` and emitting an event on that button, in which case, specifying the default value explicitly wouldn't change that behavior.

I would think the best practice is to always specify a type for button.  If we want to "fix" this, I think the best we could do is warn if a user doesn't specify the type.  cc @spicyj 
 Yes, this is in the HTML spec and not an IE bug. Buttons default to `type="submit"`. I recommend you create your own `<Button />` component that has the behavior you want and use it instead. Though I agree that the spec is a little stupid here, this isn't really React's place to change it.
  #2549 was not merged to the stable branch, the fix was applied to `master` and will be a part of 0.14. The code for the fix was not removed, it was updated in 08e4420019f74b7c93e64f59c443970359102530.
  Yeah, I think warning is appropriate here.
 Yes, event pooling should/will be documented.  Feel free to submit a PR.

We should add a warning to let the user know that the event has been returned to the pool and so invoking methods on it makes no sense.  Once the docs are written, we can add a link to the end of the warning.
  We're Facebook and we have an open source code of conduct.
  The nodeCache contains the old node despite the new DOM element having been created.  AFAIK only a single node exists in the DOM.  Presumably the node cache just hasn't been updated.

There is a race condition between the setState invocation and the event handler walking up the DOM, presumably that's the cause, though it's not clear to me how the node cache is out of date after setState completes (some sort of batching @spicyj?).
 Probably related to, and possibly a duplicate of, https://github.com/facebook/react/issues/3790
 I think it's a dupe.
  Looking at the stack‚Ä¶ this is coming from react-hot-loader, you'll want to make sure you're up to date and / or report it to them. They are accessing `Class.type` - https://github.com/gaearon/react-hot-loader/blob/master/isReactClassish.js#L38 - but `Class` is actually a factory.

Now that said, I strongly encourage you not to export factories and instead convert classes to factories in the consuming component module. By exporting a factory, it can only be used that way, not with JSX (in other words, our primary JS API: createElement).
  We'll update the website with more complete documentation soon.
  I think the intent is that getting a ref means the referenced component has mounted into the dom and is available.  This allows the owner component to do things like measure the size of the referenced component.

If your Align component needs to access the parent dom node, can't you use `.parentNode` in your `componentDidMount`?
 But what if the child component renders to an empty div (and holds a ref to the div) and then in `componentDidMount` fills the div with some contents (maybe a jquery widget or whatever).  The child component's DOM node may not be fully rendered until after `componentDidMount`.  This is a fairly common use case.  If you have the ref fire before componentDidMount, it means you get a ref to something prior to that component fully initializing.
 cc @sebmarkbage and @spicyj since I know they spent like half a day on the whiteboard trying to figure out the order of events for refs.  Maybe they'll have some input/thoughts/conclusions.
 The current ordering is deliberate. This way, when a ref to a component is resolved, you know that it is fully initialized (i.e., its componentDidMount has executed). Is it possible in your case for the child component to ask the parent to send it a signal once the parent is mounted? (Though executing callbacks on a parent component during the mount phase is tricky to reason about and is not recommended due to this timing issue.)

Long-term we'd like to support layout using a solution such as this:

https://github.com/reactjs/react-future/blob/master/04%20-%20Layout/02%20-%20Layout%20Components.js

Unclear yet whether we'll adopt that solution though.
  We got rid of those. See #4393.
  Personally, I like it; somehow it does feel cleaner and more declarative.  Especially when the common case can be transpiled to a stateless function, this syntax feels particularly nice.

Having said that, I think the biggest "problem" is that we already support the ES6 class syntax, and the current plan is to also support the stateless function syntax.  These were chosen primarily because they are javascript standard constructs.  Adding other officially supported syntactic alternatives makes the documentation fragmented, and since this is semantically equivalent, it's not clear to me that this improved syntax justifies the additional cognitive load for users.  For this reason, I suspect we are unlikely to take this change, even though I like the spirit of the change.

You had mentioned that this "works when JSX is as statement (not expression)".  Can you elaborate a little more?  When paired with something like https://www.npmjs.com/package/jsx-control-statements, does that mostly solve your concerns on this front?  Or is there a more subtle concern?

My intuition is that your best bet would be to package this up as a separate NPM package as a transpiler plugin (ideally a babel transform) that people can pull in (just like jsx-control-statements).  Then, people can vote for your syntax by using it in their own projects.  If it becomes sufficiently popular/useful, we can consider pulling it into React core.

Anyway, that's my two cents.  Doesn't necessarily reflect the wider opinions of the rest of the team.
 As a side note: We can only accept pull requests against master (this PR is against stable).  Normally we'd need to close it out (since it's not possible to change the merge branch of a PR), but I'm going to leave this one open since it's just an RFC anyway.
 We're not going to do this in any official way. Our goal is to make component definitions be JS as much as possible (with a little bit of sugar with JSX).

If you would like to maintain and support a custom transform tool, you are more than welcome to.
 @thr0w Not a problem.  PRs are fine, they generally get more attention than issues, so keep up the good work.

As @zpao said, to the extent possible, we try to stick with standard javascript constructs, so this feature is not likely to make it into the core any time soon.

If you want to continue building out this type of feature, I'd encourage you to create a repository/npmModule just like https://github.com/valtech-au/jsx-control-statements and release it independently.

If you are looking to help contribute to React core, I'd recommend taking a look at one of these issues: https://github.com/facebook/react/issues?q=is%3Aopen+is%3Aissue+label%3A%22good+first+bug%22
  Fixes #4279
 Should either of these be called `dom`?
 Good question. We didn't do that for the transition group addons but maybe we should‚Ä¶
 Meh, let's leave it as is for now for parity. We can rename things later.
  This is doable in userland but it's definitely awkward and requires some tree search to find all roots (or overselecting nodes - `qSA('[data-reactid']` and check each for `!node.parentNode.dataSet['reactid']`).

It might be handy to expose roots in same way, this has come up before in other tooling. But it's awkward to do. cc @sebmarkbage 

So what I might suggest for you is an imperative wrapper around React.render - basically have something that tracks when you call render, store a reference to the target node, and then you can call into that to unmount. Here's a really simple way you could do it.

``` js
var Renderer = {
  _nodes = [],
  render: function(element, node, cb) {
    Renderer._nodes.push(node);
    return React.render(element, node, cb);
  },
  unmount: function() {
    Renderer._nodes.forEach((node) = > React.unmountComponentAtNode(node));
  }
}
```

We actually use a very similar pattern at FB. I suspect that @sebmarkbage or @spicyj will probably close this and suggest something what I did.
 Yea, what @zpao said.

I think the rationale is that we don't really have any good "magic" way of doing this. Trying to expose an API would be broken, flaky or unnecessarily slow. This is better solved in an environment specific way. So, I'll close this out with @zpao's suggestion. Let's revisit if we come up with some other clever idea.

I suggest @jimfb takes this example on for his upcoming blog post.
 @sebmarkbage For the blog post: do you want a passing reference to this use case or do you want an exploration with this code in the blogpost?  Blogpost already has code for (and talks about) ReactComponentRenderer.  On that note, if you have feedback for the latest draft, let me know - probably good to get the ball moving on that blog post; it has been a while.
 @winterbe React blog post will appear here: http://facebook.github.io/react/blog/
  Sounds like too much magic to me.

You could always do:

``` javascript
childsWrapped = childs.map(function(c) { return <Wrapper key={c.key}>{c}</Wrapper>; });
```

You should get a key warning, so that should help you when you forget.
 That's `key={c.key}`.
 @spicyj Thanks, good catch, updated.  Sucks that `key` is special cased; I wish we had a good way to keep `key` on props without interfering with user code.
  This is intentional; validating props at element creation time produces more useful errors. It also more closely matches the behavior of static type systems like Flow. Best for now is to simply mark those props optional. We also may introduce a feature in the future called context that will give another supported way to pass props from a parent like A to a child like B.
  Does casing matter for any SVG tags? I vaguely recall something about that but not sure.
 I played around a bit more and it's definitely the case that SVG elements have case sensitive tagNames (eg `linearGradient`) but perhaps we don't really care and this is _ok_ (even if not perfect). Any opinions @spicyj?
 I think this change is good. @sebmarkbage said that e.g., `<lineargradient>` in your HTML is valid.
 Ok cool, merging then. Thanks @dmatteo!
  Didn't you write React?
 Best guess: the top-level onMouseOut doesn't fire on the removed node (which is basically what you said, sorry).
 Well that's just lovely. Time to file a Chrome bug?
 @pswai You're testing a different scenario, my fiddle shows that this is not a problem with the React event system, it's a "problem" with browser behavior when the hovered nodes are replaced/removed.
  whyÔºü
 @browniefed Thank you very much! It works! 
 This should work better in 0.14 when it's released.
  The problem is that you are changing `process.env.NODE_ENV` at runtime. React does a lot of initialization at require time based on the value of `NODE_ENV`. So React starts up thinking its in dev mode, does some initialization in ReactElement for prop mutation tracking and warning messages, then you switch it to prod mode which leaves us in a not so great state. Some dev code gets skipped but since we did setup some things before, those are still running (Eg, the use of `this._store`).

So the best thing is to not change environment variables during run time. I generally think that's a good rule of thumb in general, but it's especially true for React in node. `NODE_ENV=production npm start` is fine and the recommended way to run a production app.
 Ah, well as long as you set NODE_ENV before the first require of react I think you should be ok.
  Moving the transition to the active class seems to work. I'm not really sure of the details but others have had the same issue (see #3186) and our docs actually do that in the example as a result (http://facebook.github.io/react/docs/animation.html). I don't think there's really anything we can do here, we're simply adding or removing classes from the DOM node and this might just be one of those browser quirks.
  :thumbsup: thanks!
  What does this give us?
 Do you have intentions for us to use `--mangle-regex`?

FWIW, `^2.4.23` will install `2.4.24` and if we're not actually using the new feature I'm not convinced we need to update the version string.
 > Actually you bring up a good point and I have a question about that. Do we want to be implicit and use ^ to allow people to upgrade to the latest minor version? I know some repos that don't necessarily follow semantic versioning and introduce breaking changes in minor versions. How do you feel about being more explicit about versions and using ~ to only allow patch version upgrades?

Meh. Historically if it becomes an issue, we address it then (eg #4474). For releases we always delete node_modules folder and reinstall fresh, shrinkwrapping in our stable branch to ensure our dependencies are locked. We don't have any issues with updated packages then.

> And also, doesn't npm install on ^2.4.23 just install v2.4.23? I thought it would only upgrade to 2.4.24 if you run npm update.

That depends on if you already have 2.4.23 installed or if nothing is there. 2.4.23 satisfies ^2.4.23. But installing without any version there will grab latest (or look at nested deps and try to do the smartest thing to install the fewest things, which is how npm3 works). Otherwise yes, `npm update` should update to latest. Also explicitly installing with the new version range works over the existing one (`npm i uglify-js@^2.4.23` will install 2.4.24 if 2.4.23 is already installed).

---

Soooo ultimately I think I'm just going to say no here.  If there were something specific in that version we had to have, then yes. But making this sort of change for every package update is noisy.
 I really appreciate the initiative though! I think this is a great way to get involved and I hope to see you around some more :)
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 @niole I only glanced at it briefly, but I think your test error message may be missing the prefix 'Invariant Violation:' appended to invariants before throwing.  It's often helpful to copy-paste the message into a monospaced text editor, line the messages up, and see where they differ.
 And yes, you're missing the 'Invariant Violation:' prefix.
 @niole No, just the test.  The issue is that the actual code adds it automatically when you invoke invariant but the test does not.
 Please run your tests locally before pushing. You can iterate much more quickly that way instead of waiting for travis to tell you there are failures.
 You can run your tests using `npm test`.

If you read somewhere that you should use `npm run jest`, be aware that has been removed in favor of `npm test`.
 `npm install` should do it. You may need to install npm >= 2.0 though for that to work. If you're on npm < 2 you might be able to do `npm install ./eslint-rules` to pick it up.
 Sorry for the delay, GitHub doesn't send notifications when there are new / changed commits added.
 I squashed, cleaned up the unrelated changes, and pushed (your commit: 70c07c67b74b7c62c524f80f7e7b27a8e09eb7f1, merge: bdc7ce9f01bce3b4ebf363fcef20dd3534e614ca). Thanks for sticking with it!
  I see no harm in having more unit tests.
 With regards to the unfathomable jasmine expectation, I'm at a loss to explain it; that test looks perfectly reasonable to me.  Perhaps @spicyj or @zpao will have an idea.
  For reference, fixes https://github.com/facebook/react/issues/4465
 Thanks for bringing it up @berkerpeksag!
  Thanks @cody.  Closing as per #4311.
  This allows classes to avoid the performance hit associated with autobinding on a per class basis, allowing a migration path for applications trying to increase their throughput. I added tests to ensure that even if a class opts out, its mixins are still autobound.

Internally, while all of the usage of `createClass` within core have been removed (:fireworks: :tada: ), many of the addons are still using it and fully rewriting them does not seem like a priority. This PR would also allow these components to be optimized to remove autobinding as well.

I'm leaning towards making `autobind` be part of `statics` rather than doing the `RESERVED_SPEC_KEYS` noop, but thought I'd see if there was any input.
 Perhaps ironically we just removed the support we had for opting out of autobinding on a per-method basis (#3628). Turns out nobody used it (granted, it wasn't really documented).

If we do re-add this, `statics` is probably the best place (that's where we really should have had `getDefaultProps` too). Though if we move it to `statics`I think there might be some additional work to do.

But that hinges on if we want this. If used it could throw off the assumption that people have about method calls on refs, which are currently expected to be autobound. `this.refs.foo()` (which at least can be fixed with a bind). Props too, and you can't fix those. `<FancyButton onClick={this.handleClick} />`. Though that's not really worse than the class syntax‚Ä¶

It is worse for mixins which might be expecting `this.handleClick` to just work. Continuing to support mixins is the only reason to have this right? Otherwise you could just migrate to class syntax.

cc @sebmarkbage @spicyj 
 > Continuing to support mixins is the only reason to have this right?

Exactly. We have a large codebase with an unfortunate number of mixins at this point. Currently, we maintain a small fork of React that removes autobinding on the server-side, but it would be nice to get away from this.
 @zpao, this flag is not on a per-class basis but on a per-mixin basis which mitigates the portability/refactoring hazard. This change is small and isolated.

I wonder what would be best though. Should we restore it on a per property basis like we used to have?

Btw, if you have a codebase specific way to do optimizations, I would actually recommend that you fork `createClass` (`ReactClass`) since it is effectively standalone anyway. You can build it completely on top of public APIs.

I also have another idea. Since the autobinding map is known ahead of time, we can generate a function to create an optimized function to do this work. E.g. something like:

``` js
function buildBinder(autoBindMap) {
  var src = '';
  for (var unsafeKey in autoBindMap) {
    var key = JSON.stringify(unsafeKey);
    src += 'instance[' + key + ']=function(){return map[' + key + '].apply(instance, arguments); };'
  }
  return new Function('instance', 'map', src);
}
```

This should be much faster than the current deopted loop that does key iteration and native bind (which is slower than polyfill). If that is still not fast enough, we could also create a few of these bound instances ahead of time so that they can pulled from a pool.

Just a thought. However, I feel the pain of having legacy mixins slowing you down unnecessarily, so I'd be fine with this some opt-out mode in the legacy system if @spicyj and @zpao agrees.
 > Btw, if you have a codebase specific way to do optimizations, I would actually recommend that you fork createClass (ReactClass) since it is effectively standalone anyway. You can build it completely on top of public APIs.

:+1: This is what we're doing for now, but it's a lot of functionality/code to maintain when there are essentially 3 lines that we want to change and still be BC. 

> I also have another idea. Since the autobinding map is known ahead of time, we can generate a function to create an optimized function to do this work.

I can play around with this to see what kind of gains we see in our app.
 > `return new Function('instance', 'map', src);`

I'm fine with making things faster (duh), however using the `Function` c'tor violates default CSP in Chrome extensions (https://developer.chrome.com/extensions/contentSecurityPolicy) specifically the `unsafe-eval` option. I don't have a good idea of how much it matters. It looks like as an extension author you can change the CSP to allow this but it's strongly discouraged. We know React is getting used in extensions and we're bound to get a pile of these. I think the problem is that the script as a whole won't get executed so we couldn't try/catch something.

We got rid of our 1 use a long time ago (`Function('return this')` is a great way to get the real global) in response to CSP. I'm hesitant go back on that.
 I think you can put the `new Function()` call in a try/catch.
 We have a huge list of things that could potentially be made faster with this technique so we shouldn't limit ourselves to CSP support. We can feature test and fallback. Worst case we create a special renderer.

Besides, this particular case is targeting server rendering.

> On Jul 24, 2015, at 4:34 PM, Paul O‚ÄôShannessy notifications@github.com wrote:
> 
> return new Function('instance', 'map', src);
> 
> I'm fine with making things faster (duh), however using the Function c'tor violates default CSP in Chrome extensions (https://developer.chrome.com/extensions/contentSecurityPolicy) specifically the unsafe-eval option. I don't have a good idea of how much it matters. It looks like as an extension author you can change the CSP to allow this but it's strongly discouraged. We know React is getting used in extensions and we're bound to get a pile of these. I think the problem is that the script as a whole won't get executed so we couldn't try/catch something.
> 
> We got rid of our 1 use a long time ago (Function('return this') is a great way to get the real global) in response to CSP. I'm hesitant go back on that.
> 
> ‚Äî
> Reply to this email directly or view it on GitHub.
 So using `new Function` improved my test application's throughput by about 4-6%. Seems like a good result, but still not enough to reconsider opting out of autobinding.

Should I move the `autobind` flag to statics or do we want to keep this as is?
 Let's move it to statics and we can get it merged.
 Bah. It's a little weird when mixins get involved since it's not _actually_ a class-wide property though. Let's just take it like this. Sorry for the indecision.
 And thanks for this, great work especially on the test cases.
  Can you explain how you installed react? There's pretty much no way this is happening unless you `npm link`ed react (but linked from the wrong folder, the root would be react-tools).
 I don't know where you read that, it shouldn't say that in any of our readmes.

If you're talking about `react`, you should just be doing `npm install react` (`react@0.14.0-beta1` if you want the beta). Unless you are working on patch to React you should not be cloning and building.

If you're talking about `eslint-plugin-react-internal`, you shouldn't be using that. Those our custom rules for linting our own code.
 If you are trying to submit a PR, clone the repo into a separate folder and follow the instructions in the README for building. You should probably never clone this repo into your node_modules folder.
 @gfogle `npm install` shouldn't fail if you're submitting a PR. I meant that nobody should be be building their own copy of React unless they are submitting a PR (or are an expert)
 We only support npm for this beta. The blog post explains how to install it from npm:

http://facebook.github.io/react/blog/2015/07/03/react-v0.14-beta-1.html

For the final release we'll have a browser build, as with all our releases.
 npm > 2 is required (the `file:` dep syntax was introduced then). I'll make sure this is documented.
  Oops, thanks for finding & fixing that!
  Added note about multiple Reacts, since this error commonly implies that.
 @spicyj you have context on this diff.  For those following along at home, we've seen a bunch of github issues where people are confused, which means it's probably confusing a bunch of people who don't report it to us.  We want to point users in the right direction with a helpful/timely message.

Lint failure is from a different file, unrelated to change.  Should be fixed independently.
 (lint is some false positive thanks to build caching, cleared and retriggered - I hit it on master too)
 @maoziliang We tried that, but it ended up warning people in unit tests and we had to revert the diff (https://github.com/facebook/react/pull/3646).

@zpao or @spicyj ready to merge?
 Ping.
 @zpao or @spicyj Is there a reason we are not moving this forward, or should I keep pinging the thread?  Soon I'll get as good at this as pingbot!
 I want to criticize the too-long wording but haven't gotten around to it yet‚Ä¶
 @spicyj Comment overall or specifically my addition?
 Mostly it's just really long now.
 @spicyj Better?  It is now 4 lines instead of 7 lines :P.

@syranide That's not a bad idea.  If the root node is a web component, it might respond badly to having a random property set on it, but maybe we skip the check for web components?  It's worth looking into, but not worth blocking this fix.  This is a trivial mitigation that will catch the most common case.
 Okay, I guess this is fine. Can you shorten the remove message too? (Not sure I've ever seen it though since you'd always hit the add invariant first in practice.)
 @spicyj Yeah, done.  Is it even possible to hit that remove path?  Seems like you'd need to add the ref in order to remove it, so it would be impossible to hit.
  @KevinTCoughlin Thanks!  I'll let this sit for a couple days so people have a chance to see it, and if there are no objections, we'll merge.
 Looks good.  Thanks @KevinTCoughlin!
  Please reserve GitHub issues for bug reports and feature requests in React only.
  We're trying to keep github focused on issues with React and keep usage related questions to stack overflow. You may also have luck in the [slack channel](http://www.reactiflux.com/) or IRC.
 You asked a specific question about a config for your use of React + Webpack. FWIW, we also don't talk about using browserify or jspm or requirejs. I'm not arguing against more documentation (in fact, I think it would be great to have a section about these things), but that's not what was asked for.

The best answer to your question right now really is "ask other people" because you'll find more people with more expertise out there.
 Facebook uses a custom packager.  I believe we do not use webpack internally.
 React isn't built with Webpack (nor has it ever been, though there was a PR at one point) and we don't actually use Webpack at FB :) (though Instagram does). I understand why you think we would be experts but we actually haven't tried what you're trying and I genuinely think you'll have better luck asking elsewhere.

FWIW, even if I was an expert, I would probably have pointed you elsewhere anyway (with maybe a short answer) - we really are trying to use GitHub for bug reports, not support. I apologize that this came out harshly, just trying to be active in pushing certain types of discussions to a better place.
  @jedwards1211 We do our best to include context. Feel free to file bugs for others that are unclear. 
 #4561 will probably make this unnecessary.
 #4561 landed so closing out. Should be much better.
 The fix is in the RC that we released a couple weeks ago; the final release should be soon.
  If a node's presence is implied, it does seem like React could add it without violating the spec, just as the browser does now.  That might be a cute way to get around the fact that browsers add these elements.  Save some engineers a little headache/confusion.
 Well, if they're part of the spec, then it's well-defined, which means we could fill them in.  I'm not saying it would be easy, but it's an interesting idea.  Especially since we're likely to move away from markup on initial render and use createElement instead, this could be the perfect time to add such logic (or not).
 I don't think it's worth the complexity. We already don't allow optional end tags in JSX. The handful of optional start tags (is `colgroup`, `tbody` really it?) doesn't seem worth supporting, especially since we'd then have to do a bunch of additional tracking in prod.
 If we can add tbody and colgroup implicitly without a lot of extra work, I think that would be nice. I don't care much about any of the other cases since I think they're all invalid when omitted.
 @joshdmiller To be clear, validateDOMNesting warns you about cases that are currently problematic in React. If you don't have a tbody (for example), you'll run into problems during reconciliation.
 If you try to update the `<p>` tag, React will expect to find it as a child of `<html>` and will be confused to find a `<body>` tag there. It's better to write `<head>` and `<body>` explicitly.
 @joshdmiller Also, if you're running React client-side, full page rendering is discouraged because it's so common for extensions and other code on your page to add elements to the body of your page, thereby breaking reconciliation.
  @syranide @spicyj 
 cc @chenglou 
 We're going to just go with #4561 instead with manual timeouts.
  @KeKs0r If you could create a simple example that demonstrates the issue, that would be helpful in helping us investigate.
 I don‚Äôt know if this specific case is still accurate, but ReactPerf has been rewritten from scratch in 15.1.0, so this particular bug report is very likely no longer accurate. Since there is no described way to reproduce, I‚Äôm closing, but feel free to follow up if this still happens after 15.1.0!
  Who would be best to answer this one?  @spicyj @graue
 Seems like a valid bug report ‚Äî thanks @drabinowitz, and the test case is rad. I may not be able to look at this for a while, unfortunately.
 Sorry about the slow response from us (FB) here. I'm the principal author of the shallow render feature, but React core isn't my main gig and I've been swamped with product work. I don't have an offhand answer for you, @tnrich, but I've just put time on my calendar to look into this next week.

Jim, Ben, Paul ‚Äî if by chance one of you happened to take care of this before then, I wouldn't be mad :)
 Closing in favor of #5561 which should merge soon.
  Just curious, I noticed you don't translate variable names.  I would imagine that for people reading the translated docs, having random variable names they don't understand would make the code harder to understand.  I know I use variable names to help understand the code.  Just thought I'd throw that out there, totally up to you.  I'd totally understand if it didn't make sense to translate variables.  @zpao 

Thanks for all your hard work!
  I think we already have some logic to disable this for buttons, should be doable.
 PRs welcomed.
 AFAIK this was fixed by #6215.
It should be a part of 15.0.2 (not 15.0.1, so @janusch you‚Äôll need to update). 
  Thanks!
  Regarding number 1:  See: #4368, #2626. #2912, #4199, #2665. etc.  No catch block because we don't want to swallow the exception.  Exceptions are good/useful for debugging.
Regarding number 2: I wouldn't recommend changing the source code, as it would be difficult to predict the ramifications of such changes.  Would be much better to provide us with a test case that demonstrates the issue so we can fix it and test internally.

I am unable to reproduce.  If you're able to provide us with a simple testcase/example, I'd be happy to re-open this issue and investigate.
  @zpao Looking at this again, I see very little reason to use a fake target object instead of mutating the dom node.  Mutating the dom node is closer to what the real browser would do, and it means you get all the other properties of using a real dom node for free.  It works better with alternate event handling implementations (like using path), and seems all-around better to use a real dom node rather than a fake.  I'm inclined to accept unless you still disagree.
 I'm trying to avoid promoting practices which aren't optimal. Modifying a node directly is a practice that would ideally not be needed so I'd rather not have it be there in code as the first option in our docs.

Now that said, it is actually required to do this because we set `fakeEvent.target = node` in `Simulate`, overwriting the value you pass in (which is why it doesn't actually work). That might just be a bug with simulate (since everything else should be overridable).

So let's do it and perhaps we'll change this in the future and if so we'll change the docs.
 Setting value like this is what I've always recommended.
 Fixed in 66881ae, thanks.
  Hmm, surprisingly I don't think this has come up before.

I'm not sure if we want to support getters/setters in mixins. It wouldn't be terribly hard but it would probably be slower (we'd have to use getOwnPropertyDescriptor). We could guard against it in **DEV**  and warn though. Any opinions @sebmarkbage @spicyj?
 Non-enumerable has come up before. Our mixin system is flawed in more than one way. Personally, I think that coming up with a whole new mixin system that works with any ES6 class would be much better leverage than upgrading React's old class system to support it.

The only reason I don't like this change is because it would cause people to have to do upgrade work to ensure this doesn't break their code. It seems like adding this to a new class system would be better since this allows people to optionally opt in to the new and better system.
 I'm going to close this out and just say that we aren't going to do this.
  5.7 and 5.8 are having issues with linting and I don't want to deal with that.
 [Supposedly the infix operator issue is fixed in >5.8.0](https://github.com/babel/babel-eslint/issues/149).
 A bunch of other things are broken though (looks like a lot of comment-related issues, but haven't looked into it). 
![screen shot 2015-07-21 at 1 21 48 pm](https://cloud.githubusercontent.com/assets/8445/8811552/85ae233c-2fab-11e5-8b03-89ab72ece05d.png)
(there are a couple unrelated things in there due to local untracked files)
 Okay, I guess we can merge this then.
 (cc @sebmck)
 Wow. That was fast. Thanks @sebmck.
 Since others are referring here, there's still a problem with comments so we'll stay at 5.6 for a bit longer. https://github.com/babel/babel-eslint/issues/153
  You can't delay componentDidMount; it will be executed immediately after Render.  What you can do is avoid doing the initial render (the call to `React.render()`)until your components are mounted into the DOM.

This sounds like a usage question rather than an issue with the React codebase.  I'm going to close the issue to take it off our bug-tracking radar.  I would recommend asking on StackOverflow or discuss.reactjs.org
 You might consider `renderToString`, inserting that markup, and then doing a `React.render()`.  That will allow you to have the markup and insert the markup, and the second render (delayed) should be fairly fast.
 This is a known issue with the DOM's CSS model. The preferred solution is to always render into a node that is already attached to the document. However, depending on the scenario it is a legit use case to want to create your DOM tree ahead of time, only to later add it into view.

We couldn't automatically detect when something gets attached to the DOM. So we couldn't make any solid guarantees of `componentDidMount` firing. I guess that's not reason to disallow the use case if you can guarantee to call it. We would do it ourselves if we had to DOM hooks, so if your framework around React has those hooks, it might be viable. For example, web components does have that hook.

It's also interesting if what you want is to actually generate the nodes ahead of time or not. E.g. we could generate the HTML string but not apply it until later.

@aleskafka Could you elaborate on your use case and why you're not rendering into the existing document immediately?

Another related scenario that I've considered is temporarily adding a node to the document for measurement and then ripping it back out. For example, this would allow you to measure a subtree (assuming your CSS doesn't rely on position in the document) and then generating the parent wrapper/position after you know the size of the children.

This would cause React to temporarily insert the tree, calculate the layout, fire the componentDidMount callbacks etc. and then rip it back out. Would something like that be interesting to your use case?

@jimfb I'm going to reopen because it's not a question about how to use React. It's pointing out timing issues that can't be solved any other way.
 @sebmarkbage If web components have the hook, could we inject a webcomponent into the markup, setup a callback, and use that to trigger the `componentDidMount`?
 @aleskafka The latter.  It attempts to re-use the markup and just creates the backing component instances.
  Yea, we don't special case script content so it runs through the same escaping code as everything else. We strongly recommend using `dangerouslySetInnerHTML: {__html: 'alert("hey")'}`

I don't think we have plans to change this escaping behavior.
  @brigand The official recommendation is to use Babel as you specified.  Thanks!
  The primary issue with the code above is that you are trying to mutate `state.data` directly in the ajax callback function.  You will want to move the `$.get` call into your `updateData` function and call setState from within the callback that you pass to `$.get`.  For example usage, I recommend reading through the "updating state" section in the tutorial: http://facebook.github.io/react/docs/tutorial.html#updating-state

This is more of a question rather than a bug in React.  We use github issues to track bugs in React, so I'm going to close out the issue for tracking purposes.  Feel free to ask questions like this on StackOverflow or discuss.reactjs.org
 (Ideally Stack Overflow. discuss.reactjs.org is better for architecture questions and other high-level discussion.)
  Going to close and just point at #1657 where we're tracking discussion about SVG
  Is that better than using `style={backgroundColor}`? The article didn't really explain (just said use `bgcolor`).

Anyway, `bgcolor` will be supported if/when we switch to allowing arbitrary props on DOM elements. I don't really want to explicitly support something removed from the spec 16 years ago so we won't add it to our supported attributes list right now.
  This was fixed in #4311 (after beta 1). currentTarget or event.nativeEvent.target should work.
  Looks good to me.  Since here are a bunch of changes here, I'll let this sit for another day so people have a chance to look at it, and if there are no further objections from @zpao or others, we'll merge.  Thanks @gajus!
 @gajus Sorry we let this one slip through the cracks, and now it has a merge conflict.  Can you rebase/fix and we can get it merged?
 Ping @gajus 
 Ping @gajus
 @gajus updated the pull request.
 @gajus updated the pull request.
 @gajus updated the pull request.
 Looks great, thanks @gajus!
  This is an empty commit...
  There are conflicts. Can you rebase onto the lastest master?
 Thanks!
 I assume it meant to take "a ref to a component" and remove it, but this does seem a little clearer.
  No issues with Edge that I'm aware of, but I don't know that we've done extensive testing. cc @spicyj @sebmarkbage 
 I also don't know of any incompatibilities in any version, and I don't think we currently have any workarounds for Edge.
 Great, thanks @csuwildcat!  I'm going to close this issue, since there are no known bugs at this time.  We'll be sure to ping you if we discover anything :).
  Copying from [my Quora answer](https://www.quora.com/Why-do-I-have-to-use-className-instead-of-class-in-ReactJs-components-done-in-JSX/answer/Ben-Alpert):

> We certainly could have done it the other way around. I argued for that for a while. There are transforms that convert `this.props.class` to `this.props['class']` and so using the names `class` and `for` would be nearly seamless. Babel includes one. We're sticking with `className` and `htmlFor` for a couple of reasons:
> 
> First, we tend to look at HTML properties (like `el.className = ...`) when possible, as opposed to attributes (like `el.setAttribute('class', ...)`). Attributes are always string-typed, while properties can have any JavaScript object value, which gives more flexibility in some circumstances. One example is the `.classList` property, which arguably is a better fit for the data model than `.className` is. React doesn't support `classList` right now, but it certainly could. Given that React's `className` behaves like the HTML property of the same name, it makes sense to keep that name.
> 
> Another reason is more forward-thinking. In the future, idiomatic React may use object destructuring to pick apart `this.props`. The react-future repo [shows one example](https://github.com/reactjs/react-future/blob/297d67157bc07d9b4581134f4ff09c88808f23c5/01%20-%20Core/08%20-%20Transferring%20Props.js#L21) of how this could work. Even in modern browsers, this wouldn't work with `class` and `for` which are keywords and can't appear as standalone identifiers even though they can appear as property names.
> 
> Third, our thinking is that JSX's primary advantage is the symmetry of matching closing tags which make code easier to read, not the direct resemblance to HTML or XML. It's convenient to copy/paste HTML directly, but other minor differences (in self-closing tags, for example) make this a losing battle and we have a [HTML to JSX converter](http://facebook.github.io/react/html-jsx.html) to help you anyway. Finally, to translate HTML to idiomatic React code, a fair amount of work is usually involved in breaking up the markup into components that make sense, so changing `class` to `className` is only a small part of that anyway.
 @cmmartin Your suggestion might make sense for DOM components but would be utterly surprising for a user-defined component if you write `<Foo class={...} />` and that means className. A very old version of the JSX transform did do this transformation and it was scrapped because it is way too surprising.
 Maybe use https://facebook.github.io/react/html-jsx.html instead.
 The JSX transform used to do that, but we don't recommend it because it's confusing if you ever try to pass `class=` or `for=` as a prop to your own components ‚Äì you wouldn't expect to access them with a different name.
  You probably want pageX or clientX and if you want it relative to another element you can use getBoundingClientRect on that element ‚Äì if you do that it should work well across browsers.
 That seems reasonable enough if we can do it with no performance compromise so I'll reopen this, but it won't be a high priority for us.
  I agree this should exist, but maybe it should be opt-in (per-component)? Or at least let there be an opt-out.
 @yaycmyk in the wrapping case, you could do

```
MyWrapper.propTypes = {
  ...WrappedComponent.propTypes,
  myNewProp: stuff
};
```
  Yea, we're killing react-tools / jsxtransformer so any requests like this should end over in babel or whatever other transformer you happen to use.
  I tried to write

```
var foo = [{
  bar: 1,
  baz: 2,
}];
```

but our linter wants a comma after the `}`. Kind of annoying. Anything we can do here?
 @kiki-le-singe We do want to require commas when on separate lines though.
 @spicyj I think updating eslint should solve it: eslint/eslint#2778
 @bgw Thanks, good find.

@dcousens I don't think so. The goal of this lint rule is to make it possible to add another item to a list without changing what was previously the last line. In my example, that holds true for the object because I have the trailing comma, but it doesn't hold true for the array because of the way I've formatted it; this holds true regardless of whether a trailing comma is added. Since I know this array will only ever have one element, I think formatting it like this is clearest instead of adding another level of indentation.
 This particular case was for a unit test of a function that takes a list of operations:

https://github.com/facebook/react/blob/57d14ec33a3393c8d37f9230428c9ac35a5c8059/src/renderers/dom/client/__tests__/ReactDOMIDOperations-test.js#L49

Just as `[1]` and `[1, 2, 3]` don't require trailing commas, I don't want one here either. There's no use discussing more over this.
  `Children.only` is intended to be called on an opaque `Children` object (eg. `this.props.children`).  Best as I can tell, `Children.map` is intended to return an opaque `Children` object.  But `Children.only` can't be called on the return value of `Children.map`, as per https://github.com/facebook/react/issues/4410#issuecomment-122199087

It seems very reasonable to want to map your only child to another element (clone element, for instance), and then grab the only child from the map and use it to render.  It is also very surprising for the identity operation to be passed into map, but the thing that comes out to not be semantically equivalent.

Issue demonstrated here: https://jsfiddle.net/9Ldyq5jk/4/
 The intention of `Children.only` is to be used with the result of JSX where the child is guaranteed to be a single child. The reason for it is as an upgrade safety if JSX would change this behavior in the future.
 @sebmarkbage But isn't the intent of map that it return a data structure that's semantically equivalent to `this.props.children`?  Specifically, the opaque `Children` data structure?  Otherwise, isn't the return value of map completely useless? / how do you use it?  What's the contract for the return type of map?
 ```
type SingleChild = ReactElement;
type SetOfChildren = Array<OpaqueChildren> | Map<string, OpaqueChildren>;
type OpaqueChildren = SingleChild | SetOfChildren;
```

JSX produces a children property:

```
createElement(type, props) : { props: {} }
createElement(type, props, child : SingleChild) : { props: { children : SingleChild } }
createElement(type, props, child : OpaqueChildren) : { props: { children : OpaqueChildren } }
createElement(type, props, child1 : SingleChild, child2 : SingleChild) : { props: { children : OpaqueChildren } }
```

`only(children : OpaqueChildren) : SingleChild` is a downcast that "warns" for the wrong type.

`map(children : OpaqueChildren, fn) : OpaqueChildren` doesn't promise to return anything that is compatible `SingleChild`. However, it is always compatible as a child of a div for example because it is compatible with `createElement`.
 Well, the documentation states:

> Return the only child in children. Throws otherwise.

And since the signature is `only(children : OpaqueChildren)` (as per your comment above), it means that at the very least the documentation is wrong, since the function is not `returning the only child in children`.

I think the downcast behavior is unnecessarily complicated and incorrectly documented.  At the very least we should fix the documentation, but my preferred solution is to fix the implementation.  Regardless of our solution, I think this is a valid bug.
 The point is that the whole thing is unnecessarily complicated since it is purely a perf optimization and an upgrade path if the perf optimization becomes unnecessary. However, people are likely relying on `this.props.children` being an element anyway, since we don't enforce it through a static type system. So I think that this whole utility is probably unnecessary.
 @sebmarkbage Ok, well, I've made my points here.  I still feel like there is some sort of action item required (deprecate, fix, or document).  

@gaearon It is my understanding that you are correctly using the `React.Children.only` helper in your example.
 This is still helpful as a "safe" downcast for type systems so it's not great to deprecate it. However, it is also meant to effectively remove all runtime information. The runtime type check is not great to have for perf when you don't need it.

That runtime check is also not equivalent to `React.Children.toArray(x)[0]` because of how keys are preserved in nested arrays.

I think the fix is to fix the docs.
  @tinganho I'm not entirely sure what you mean by "I need to define them as static methods".  Lifecycle hooks are defined on the class and invoked on the instances.  Can you elaborate on your concern?

Also, @brigand is correct; we use github issues to track bugs in React, rather than support issues.  I'm going to close the issue in order to take it off our bug-tracking radar; feel free to continue this discussion here, but in the future, StackOverflow is a better place for posts like this.
 componentWillMount (https://facebook.github.io/react/docs/component-specs.html#mounting-componentwillmount) is an instance method that gets called before mounting the component.
  I don't think we use any of these directly. What was the failure message?
  Seems reasonable to me, cc @zpao 
 lgtm, thanks!
  I love when other people say what I would have, thanks @cody & @yaycmyk. #2127 is an issue to follow if you're interested in the return case.

FWIW, the error that you should have seen from both react-tools and babel say that adjacent JSX elements aren't allowed and must be wrapped.

Closing out since this seems solved but we can reopen if there's a React issue somewhere. In the future, Stack Overflow is an excellent place for support questions (though I can understand suspecting a bug in this case).
  @cody is correct, will be in 0.14.
 @mdibaiee Maybe I'm miss-understanding the question, but using React 0.14-beta2...

`console.log(React.renderToString(<input type="text" />));`

renders to...
`<input type="text" data-reactid=".0" data-react-checksum="159780004"/>`

On Firefox.  Why are you using the alpha instead of the beta release?
 @mdibaiee Ah, this might help you: https://facebook.github.io/react/blog/2015/06/12/deprecating-jstransform-and-react-tools.html
 @mdibaiee - that's a great question to ask in a babel support group. It's not clear to me if they removed some of the optimizations or if they just bury mentions of them on the site .
 @sebmck - not the original issue, but the last question in the thread, which is specifically about using Babel.
  You can store the result of React.render outside of React. `renderedHeader = React.render(<Header/>, node)`
 (Ideally Stack Overflow. discuss.reactjs.org is better for architecture questions and other high-level discussion.)
  @leozdgao I agree with @cody, that seems likely to be the issue.  I tried to reproduce based on the info you provided, but couldn't find any bug.  If you can provide a fiddle, we can investigate further.
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 We could probably stop ignoring `docs/_js/*.js` from eslint. I bet there are a bunch of other things in there that we could fix. Would you be interested in doing that?

I'd prefer to have that done in bulk and not just eyeball some lint violations.
 Fair enough, we'll take this as is and make the effort for the rest later.  I appreciate the help!

If you could just sign the CLA (link in comment above from our bot), that would be great. Thanks!
 Thanks! (manually confirmed, beating the bot)
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 I'm getting rid of this file and cleaning up some things like this. Thanks though!
  The `Children.map` function differs from `Array.map` in that it is intended to take in a valid `Children` object and return a valid `Children` object.  `Children` should be treated as an opaque datastructure, and your code should never rely on the underlying type/implementation of `this.props.children`.  When working with children, always use one of the `React.Children.*` helpers.

If you are trying to get out an array of children, you can use the following code:

``` javascript
var myArray = [];
React.Children.forEach(this.props.children, function(child){myArray.push(child);});
console.log(myArray);
```

You should treat `Children` as a black box, never looking inside.  I'm going to close out this issue, because the implementation of `React.Children.map` correctly returns a valid `Children` object.  For more details: https://facebook.github.io/react/docs/top-level-api.html#react.children
 > It is OK, if I just return this.props.children(See this). But if I return the result of React.Children.map, an error will be threw.

Yes, `this.props.children` is a weird and special thing, which is why there are helpers to deal with it. Your case happens to work with returning because you have a single child. If you had multiple, then returning `this.props.children` would have thrown.

render must return a valid ReactElement. a single child is one such element. The return value of React.Children.map is not.
 You're calling `React.Children.only` on the return value of `React.Children.map`, which is incompatible. The error is admittedly nonobvious and misleading. `React.Children.only` expects to receive `this.props.children` and does its best to handle the different types that may be (single element, array of elements, or (for now but deprecated) and object with keys - it specifically is failing on the last case due to the return type from map)
  Thanks!
  Can you provide code that isn't working for you?
  :thumbsup: Thanks Jason!
  Validating checksums is surprisingly expensive.  For a reasonable render, we're wasting 10ms+ generating an adler32.  Double that, because the checksum needs to be generated twice (once on the server, once on the client).

I'm creating this bug more to test the waters than anything else... how do we feel about only doing this check in dev mode?  And failing harder in dev mode if we fail the check (since it would become a very serious problem in production because we would no longer be validating the checksum and thus the expected markup could differ from actual).

It's hard to justify spending so many valuable milliseconds generating a sanity check that we fully expect to pass if developers write their code correctly.
 cc @mridgway
  Generating markup checksums is a surprisingly expensive part of the render process.  This implementation is approximately twice as fast as our previous implementation, which can save us a dozen milliseconds server-side and another dozen milliseconds client side, amounting to real savings.
 @syranide Totally agree, if you can find a better checksum implementation, I'm happy to run with it.  In my benchmarks, ADLER32 outperformed any CRC32 implementation that I could find.

ADLER32 also outperformed `c += str.charCodeAt(i) ^ i;`, because exponentiation of large powers can be computationally expensive.  That said, if we limit exponentiation by applying a modulus (`c += str.charCodeAt(i) ^ (i%100);`) then we can beat ADLER32 by a couple of percentage points.  The downside is that no one has done any collision analysis on this checksumming algorithm, so it might be pathalogically bad.  If we're going to use an unanalyzed algorithm, I might propose `checksum = (checksum+data.charCodeAt(i))^2;` which outperforms anything I've tested to date (it's twice as fast as ADLER32).  I have no problem updating this PR to use my newly invented checksum (or any checksum, really) if someone can convince @sebmarkbage that it's not a horrible idea :).

@yaycmyk If you're measuring times on the order of 0.008ms, you're well within the noise of your system.  A single context switch is going to kill your results.  I recommend running your checksum benchmark on a megabyte of markup.
 I don't know why the new one is faster either, but it is twice as fast.  I tried your other two variants; they weren't faster.  This is why I like to re-use rather than re-write.  Whomever wrote that algorithm implementation clearly spent a lot of time/effort to optimize it; they did not choose the naive approach, and it looks like we now know why :).  It beats everything by 2x.  At this point, I think I'm in favor of merging this diff as-is.

@zpao @sebmarkbage Can we get a second pair of eyes, if everything seems reasonable, let's merge this?
 My intuition is to re-use rather than re-write.  Ideally I'd like to find an implementation that someone else wrote, rather than having us maintaining our own fork.  Re-using also means we won't accidentally introduce a bug that causes collisions.

Having said that, your new version looks fine to me.  I didn't test on non-ASCII, the performance benefits on my markup corpus were detectable but within the noise of my performance test.  Since it does appear to be an optimization, I'll take it and update the diff.
 I strongly encourage that any optimizations are contributed upstream: https://github.com/SheetJS/js-adler32. We may be able to consume from npm instead of packaging our own file here.
 @zpao they wouldn't take this upstream because they want to maintain adler32 correctness semantics.  @syranide's optimizations rely on the fact that we don't actually care about maintaining those semantics (unless I'm mistaken).
 The performance benefits on my markup corpus were detectable but within the noise of my performance test; did show a slight performance improvement, so this is good! :).  I've updated the diff.

Ready to merge?   @zpao @sebmarkbage 
 To confirm, this works the same as before, just faster? Good with me then.
 I don't think we have any other third party code, do we? We need to make sure this license is compatible and, if it is, ensure our build tooling to preserves the header, or at least colocate it with the build.
 We do have https://github.com/facebook/react/blob/38acadf6f493926383aec0362617b8507ddee0d8/src/renderers/dom/client/utils/isEventSupported.js#L38. Good point though.
 Ok, I think we're good to go on this diff.  If anyone wants to read it over one last time, make sure I didn't do anything crazy, I think we're ready to merge.
 Otherwise good.
 Ok, great!  Thanks @syranide and @spicyj!
 `0xfffffffc|0` is also `-4`, so they're equivalent for bitwise ops I think (which always return a signed 32-bit int).
 @syranide Does this value need to change?
  It currently isn't possible with inline styles. What we suggest you do is feature detect at runtime which browser you're in and use the right value.
  This doesn't sound like a React bug to me so I'm going to close this issue. If you do find that it's caused by React, let us know and we'll revisit.
  If you log what `React` is, what do you see output? Is it just that `TestUtils` is missing from `React.addons` or is something more going wrong?
 Based on that, React or maybe your module is getting mocked (`_isMockFunction: true`). Make sure you set the rootDir in your config, play around with some jest options. They can be confusing (I've definitely been bitten by bad configs). It doesn't seem like a React issue but more jest related. I'm going to close out but can still help out a bit here
  `npm install react-dom@0.14.0-beta1`. It's not published to the `latest` tag yet.
  Thanks!
  We don't use decorators. Maybe after the spec has stabalized and it's on its way to standardization.
  Rely on jest for now until we get a better and less hacky solution to running tests in the browser, probably a totally different test suite with different behavior/goals.

For some additional context, I've already spent a bunch of time in #4167 trying to make things work with populist+jasmine. It's been pretty painful and really not something we need to be investing in right now.
 Yea, at least to me the burden isn't worth it. We're only looking at the instance run in phantomJS (old, not a real browser, even with shims (though honestly the jsdom we have isn't much to speak of)). We've had failures in the "modern browser" saucelabs run for a long long time, AFAIK not actually due to any bugs in our code but some infra-related issue. Not that we've looked because we said that was an allowable failure. We stopped running the saucelabs tests in other browsers.

Trying to shoehorn the same tests written for a framework with features that extend beyond what we can do easily in the browser has been painful and not entirely reliable. I'd rather not spend a single second looking at all of that and figure out a solution that will hopefully be more maintainable. Perhaps Jest will become runnable in the browser or we'll just write proper-webdriver-but-not-jasmine tests. We'll upgrade Jest soon (0.5 is coming with iojs, new jsdom).
 @sebmarkbage told me he was ok with this, so I'm just going to merge it.
 @zpao updated the pull request.
 @jdalton Having an easy to use automated browser test runner that work on TravisCI would be helpful. Presumably you have a set up if you could run this. Anyway it can be open sourced (or explained if it is) and made work with common CI tools?

We'd be happy to maintain the test suite itself but the headless browser tooling was too much of a burden.
 For anybody coming in from Twitter‚Ä¶

This is not as simple as just hooking into saucelabs. Due to the fact that our code in original source form is a custom module system and that there are jest-isms (on top of Jasmine) in our tests, we're currently tied to using Jest. We had a more complex testing build-step which did work in the browser and did run on saucelabs but it was fragile, slow, not entirely accurate, and wasn't really used as a result. Without significant investment, we wouldn't have been able to upgrade to newer Jest nor start using Node v4, putting us at another disadvantage for contributors. We've considered making it such that Jest can start a server and do the module resolution and other stuff while actually running the tests in the browser, but it's pretty low priority for us.
 The reason we felt comfortable removing them is because there wasn't much gain from having them. It didn't catch bugs that we had, didn't help refactoring and whenever we changed the behavior we resulted to manual testing. Whenever we do a major change thousands of people and real use cases immediately test a variety of use cases on Facebook. Those catch problems every once in a while. That provides a level of confidence to the changes.

It is not as good as rigorously writing Web Driver tests for every edge case but a lot easier and cheaper. We could do it to be nice citizens to you guys. However, it wasn't helpful to us.

Perf regression tests would be more interesting.
 I think @sebmarkbage may have been referring to internal product tests catching those cases rather than users.
 > You mean nice citizens to developers right?

I mean a nice citizen to browser developers because you wanted it track your own regressions.

> They take the hit when you don't test.

As I said, over two years, it didn't catch anything and was distracting for other better testing that was catching problems. It's simple priorities. We have a very small team.

No need to debate this. Time will prove whether it was time well not spent when we find a regression.

I've been wanting to extract more of the tests from the DOM renderer and run it against a noop renderer. It is important that we retain the internals working for other environments like React Native which has even less testing.

Then we could have have a separate test suite for the DOM rendering alone which would make it easier to test browser quirks as a separate test suite.
 I think it is because almost all of the work we're doing right now is in the internals of React and the things that touches the DOM is pretty small and stable. If that shifts, it is likely we'd have to restore browser testing. For example, we currently do very little shimming work. We might want to start automatically prefixing inline style properties. That would probably require cross-browser unit tests.

Believe me, I'm as surprised as you are. Growing up in a world of ever changing browsers and quirks something feels off about it. :)
 I want to apologies for my tone earlier. I didn't mean that we shouldn't do this nor that it wouldn't be valuable. I felt that it was important to add context to why this decision was made and @zpao totally made the right call at the time. However, @jdalton is also completely right that this would be useful to have regardless. My snarky comments didn't help. Sorry about that. I created a new issue to track this #5703
  Closing so we can keep discussion in 1 place
  Realistically, we probably aren't going to do this.  In fact, we're pulling all the ReactLink stuff out of the core because it's not really a beneficial pattern (https://github.com/facebook/react/issues/2302).  We threw some of the ReactLink stuff into an addon (https://github.com/facebook/react/pull/5718) for now, and will try to pull it out even further later, in an effort to make it easier for the community to fork it and provide their own utilities (if the community finds them useful) or let them die (if the community doesn't find them useful.

Anyway, feel free to fork and add your own improvements :).
  We only ever had a couple internal users of this, and now we have none. Removing it from the repo for cleanliness.
 :thumbsup:
 @spicyj updated the pull request.
 I don't know; this was never supported. I haven't used https://github.com/yahoo/react-i13n but it might be useful for you.
 If you happen to use Redux, people find https://github.com/markdalgleish/redux-analytics helpful.
  Let's do this. I think there's still some more we can do later but this is definitely helpful.
  TravisCI clones into /home/travis/build/facebook/react, which /build/ matches so we never ran any of our tests.

Is "victoriously idiotic" a phrase? I think it probably should be.
 <img width="642" alt="screen shot 2015-07-14 at 6 33 58 pm" src="https://cloud.githubusercontent.com/assets/8445/8688965/0851ca96-2a57-11e5-9488-b528f69f119e.png">
 I think there's `<root_dir>/build/` or something? Serves me right for not pushing jeffmo harder on making all those paths repo-relative back when jest came out‚Ä¶ :)
  Thanks!
  Wow, that is confusing.  That's what happens when documentation is maintained over time and people keep making changes.

@zpao  I think one of the main ideas is also to "Build Composable Components".  So maybe there are three main ideas?  The main ideas are little more than a sentence each; maybe we make the three ideas be bullet points:
- **Keep things Simple** - Simply express how your app should look at any given point in time, and React will automatically manage all UI updates when your underlying data changes.
- **Keep things Declarative** - When the data changes, React conceptually hits the "refresh" button, and knows to only update the changed parts.
- **Build Composable Components** - React is all about building reusable components. In fact, with React the only thing you do is build components. Since they're so encapsulated, components make code reuse, testing, and separation of concerns easy.

That's my two cents.  We'll let @zpao or @spicyj gatekeep this change.
 Another option is that we just remove the whole "React has N main ideas" sentence and let it flow into the next heading.
 Ok, let's do that.  Ping @mikrofusion 
 Ok, looks good, thanks!
  cc @zpao and @spicyj
 Also, if we do this, can we PLEASE call it `findRenderedComponentsWithAttr`.  https://github.com/facebook/react/issues/3951
 We're not adding more methods like this these days. There've been a bunch of issues about it. Use findAllInRenderedTree like you found.
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 To be clear, setting the `value` prop and the `initialValue` prop have very different behaviors.  If you are using `value`, your component is a controlled component, and the user will be unable to change the value of that component unless you specifically implement the ability to edit the value.

A better phrasing might be something like: 
`*Note:* the defaultValue prop is only applied when the component mounts for the first time.  If you need to programmatically update the value after initial mount, you will need to use a controlled component (see section on controlled components).`
 Looks good to me, thanks!
  You probably just shouldn't test minified code. Our code there is depending on identity (at least for composite components) so it would have to be packaged together to properly work anyway. Even if they had the same name but were different copies of the same function, the test would fail.

I don't think there's anything for us to do here so closing out.
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
  dupe of #3972 which is fixed in 0.14
  Take a look at the uses of `TestUtils.Simulate.change` in https://github.com/facebook/react/blob/master/src/renderers/dom/client/wrappers/__tests__/ReactDOMInput-test.js

Specifically, we call something like `node.value = 'giraffe';` or `React.findDOMNode(instance).value = 'test';` before simulating the event.  Similarly, you are going to need to set `inputNode.value = 'whatever'` before firing the event.  I suspect that'll solve your problem.

For future reference, we are using TestUtils.Simulate in our tests/codebase, so if the entire class of events is not working for you, it's likely to be a support question rather than a bug in React.  Support questions are better addressed on StackOverflow rather than in a Github issue.  We try to use Github issues to track bugs in React.  For tracking purposes, I'm going to close out this bug, since I believe it's not actually a bug in React; that will take it off our radar from a bug-tracking perspective.  If the idea of specifying the value before firing the event doesn't solve your problem, feel free to continue discussing on this thread (or on StackOverflow).
 Sure, we'd be happy to review a pull request on the docs.  That would be great!

I'd recommend you try to get it working locally before updating the docs, just so you can see how it's working, etc.
  I think the official recommendation at this point would be to use [context](https://facebook.github.io/react/docs/context.html) for things like this.  That also allows you to simulate a server-side render for initial mount on the client side, which is a pretty handy trick/feature to make the nodes/checksums align.
  This is a great question for stack overflow or discuss.reactjs.com. We're trying to keep GitHub issues for actual bugs or problems with React, not general questions, so I'm going to close out.
 Writing `{this.props.isHidden ? null : <SomeComponent/>}` (or simpler, `{!this.props.isHidden && <SomeComponent/>}`) is easy and reduces the number of magic props you'd need to remember.
  I don't see any reason not to add them, might as well include all the events.  cc @zpao 
 Sorry for the delay! A few things...

What about `<audio>`? Do these overlap 100%? Might be good to get support for both at the same time.

As for Synthetic events, yea, we should stick to spec.
 Last call for feedback on this PR.  Otherwise, looks good to me.

@blainekasten There are 12 commits in this PR; can you squash them together so we can merge?
 Great, thanks @blainekasten!
 @blainekasten Correct, that's the plan!
  Good catch & thanks for the heads up! I'd definitely call that a bug :)

We really need to go through the tutorial and make sure it's all cohesive. After 2 years of ad hoc updating it's definitely showing its age. If you have any other feedback (especially as somebody who is relatively new to programming), we'd definitely appreciate it.
  That's not how try-finally blocks work.  A try-finally block does not swallow an exception.

See: https://github.com/facebook/react/issues/2626.  and https://github.com/facebook/react/issues/2912, https://github.com/facebook/react/issues/4199, https://github.com/facebook/react/issues/2665. etc.

If you can create a simple example in jsfiddle that demonstrates an issue (React swallowing exceptions), I'm happy to re-open and investigate this issue.

On the off chance you're using promises... http://blog.taylormcgann.com/2014/08/21/catch-errors-javascript-promise-chains/
  Thanks!
 Nice, much better.
  @cody I bet that's the issue.

@waltonseymour You probably want to have HTML that looks more like `<label><input ...>{genre}</label>`
  Sounds like the likely culprit. Feel free to reopen if that's not it.
 If you can reduce that example to something simple then we can try to help you. As is, it's too complex to determine if it's something going wrong with React or SVG or Chrome. You could try reproducing an identical DOM and behavior with vanilla JS and see if the problem persists to help narrow it down.
 You're giving us an app where something goes wrong but it's several layers deep. I don't really care what language it's in but the fact that I need to look at several components spread across several files with a bunch of state and interactions makes it much more difficult to diagnose and debug. I'm asking you for a [reduced test case](https://www.google.com/search?q=reduced+test+case) so we don't have to spend a ton of time figuring out the real problem from app code. Can you make this happen with a single component? I bet it doesn't only happen with 16 nodes and a whole bunch of minesweeper logic.

> A major clue we have though, in that Firefox is not experiencing any problems whatsoever.
> So it would seem to be some combination of React and Chrome that is the problem.

That's why I said you could try reproducing it with vanilla JS (again, a reduced test case means you don't have to write a ton of code). If you can show that the same DOM works in Chrome but still doesn't work with React then I could say it's React. Right now I could say you've found a bug in Chrome's SVG implementation. There's a non-trivial chance you're right and something that's happening in React is upsetting Chrome but can't prove that right now.

> I realise also this last is a technically distinct issue from the one that opened this ticket.
> So I think I should open a different issue altogether.

It's fine. Once we have it reduced to a test case we can do that.
  Thanks!
   cc @tako-black 
  Anyone who doesn't know how to start their preferred webserver is going to have a really hard time making a website using any framework.  We don't specify because it is orthogonal to the framework, and we are agnostic to what web server configuration people use.

I'm going to close out this issue because the only actionable comment is that we don't specify how to start a webserver, but I don't see that as a blocking point.  We need to assume some minimum threshold of prior knowledge.  If you have other actionable feedback as to how we could make the getting started guide more amenable to new users, we can re-examine this issue.
 Eh, I think this is pretty much the same as #4354 and we'll add something to the docs (#4357).

@ysihaoy - Sorry you had a bad experience. The server piece for compiling JSX files is annoying and not well documented (it also doesn't apply to all browsers). We'll make this a bit better.
  This issue hasn't seen any activity in six months, and is fixed in ES6 classes.  I don't think we're likely to make a change to this for the old style classes.
  I was actually thinking that this comment would go above the source code provided in the starter kit.  I tend to think it doesn't need to go in the online documentation, since I think most javascript developers will have run into this before (it's standard javascript sandboxing) and will know what the browser's error message means.  The comment is not intended as a unique thing about React that we are telling all readers about; it's intended more so that if someone runs the code in the starterpack, gets the error, and looks through the source code, we have a little note for them.

Also, the gatekeepers for this change should probably be @spicyj or @zpao anyway.
 SInce this is a newbie mistake, it's probably more readily findable in the html markup right above the script tag for the transform.  The bug https://github.com/facebook/react/issues/4354 mentions helloworld.html, so that's a good place, there may be other intro-examples (the advanced examples probably don't need it, since people will work up to the advanced examples and anyone who hits it should hit the issue fairly early in their learning of React).

That's my two cents anyway.  Ultimate gatekeeper for this change is @spicyj or @zpao.
 This (as written at time of comment, in the JS) will probably help maybe 1 in 10 people who have the issue. It might be more effective to add to the documentation in the "Getting Started" section where you had issues. I didn't see what you had initially but it sounds like that's the direction you headed. Let's do that, and just do it in English (let translators pick up the changes in other languages). It's not a unique thing about React but it is definitely related to the use of JSXTransformer (though of course you can hit the issue with any local XHR).

Also, we're not going to be building JSXTransformer in 0.14 and we're unlikely to ship anything more to 0.13 so this won't end up in user's hands.

@jimfb FWIW, it's not really _standard_ sandboxing. Different browsers have different security settings. The `file://` url works fine in Safari and Firefox. I don't remember about IE. Chrome is the one that we know doesn't work (unless you check a box somewhere).
 By standard, I meant it's a browser thing and not react-specific, but yeah.  The specifics of the rules vary browser to browser, but protocol sandboxing is implemented in every browser.  I figured people would have hit this in the past (when first learning ajax, for instance).  But yeah, if people are hitting it for the first time because they're using the React transform, then we should document it for them.

I have no objections to it being in the online docs if @zpao likes it there.   :)
 :thumbsup: That sounds good to me. If people have more issues we can always expand on the topic.
  Examples that use the in-browser transform can not be run from the `file://` protocol for security reasons.  The examples should run in chrome on osx if you throw them into a simple web server and load via `http://`.  For more details: http://stackoverflow.com/questions/20904098/react-js-example-in-tutorial-not-working

As a side note: we're going to stop building JSXTransformer in favor of using babel/browser.

I'm fine with adding a comment/note above the browser transformer explaining that: `For security reasons, some browsers will not run the jsx transform unless the files are served up from a simple http server.`
  Nice! This is a bit of an unnecessarily generic solution to a simple problem.

Can't you just feature test inside ReactInputSelection instead? It is generally bad practice to rely on a generic feature test to determine something more specific about the environment.
  @andersekdahl is correct, set state is queued.  I'm going to close this out since it's not a bug in React core, and we use github issues to track core bugs.  That said, feel free to continue this discussion if you're still running into an issue with this.

In the future, usage questions like this are better addressed on StackOverflow.
 Re 2: When you are reading `{this.state.data.dag.firstkey.secondkey}`, there is no variable on data called `dag`; there is only `dag1` and `dag2`.  I suspect your other errors are similar.

Re 3: setProps is about to be deprecated, do not use it.  Props are usually better than state, but if your component is setting it's own data, it needs to be state.  If the application (or a parent component) is loading the data, it can be a prop, which is usually ideal.

Your `loadJSONCallback` does not appear to be calling setState or otherwise performing a new render, so my first guess is that your issue is you're not rerendering after getting the data.
 > I'm confused about the comment:
> 
> > Your loadJSONCallback does not appear to be calling setState...
> 
> ...since loadJSONCallback is itself called by setState.

Yes, that is my point.  setState() has already happened before loadJSONCallback gets called (that's why you're getting the callback).  If you set a local variable after the last call to setState, your component will not re-render because nothing told React that your component's state has changed.  Setting a local variable in the setState callback is a really weird thing to do, not recommended.  If you call setState again from within loadJSONCallback, I think it'll force another re-render and display the data for secondkey2.

Same for for secondkey3, that line occurs after the last call to setState(), so again, it's not going to show up in your render.
  As always, much appreciated, thanks!
  In the future, we might be able to do something like this: https://github.com/facebook/react/pull/3920 or https://github.com/facebook/react/issues/3398 (both options still in discussion, feel free to let us know which you like better!)
 I'm going to close this out since it's an architectural question. Check out other issues and consider discussing this on stack overflow or the discussion boards (discuss.reactjs.com)
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 Ok, thanks!  cc @tako-black 
  No. The state is part of the instance. If state should be maintained then it probably doesn't belong in the component itself and should live in some data store, or the parent (and passed in as props).

You could do something a little bit clever and have a `hidden` prop instead of unmounting. Then just render null when hidden or something. But that still involves moving _some_ state back up to the parent.
 @ccorcos If you render null as hidden, you will loose the child component state.  If you need full control of internal state, you can always pull it out as per https://github.com/facebook/react/issues/3653#issuecomment-92526513
 If you can get/set the 'internal' state, you can save it in your component/application, and use it to restore the child component tree whenever you want.  It's the fully general/flexible solution, but requires a little extra work.
 @dcousens, I don't know, that's probably a question for @zpao or @spicyj 
  This adds a reconciliation bailout condition asserting that context has not changed, which fixes the other half of @ryanflorence's discovery in https://github.com/facebook/react/issues/4218.

For those following along, the first half of this bug was fixed in https://github.com/facebook/react/pull/4221.  The assertion that there may be a bug in the reconciler turned out to be due to a bug in jest: https://github.com/facebook/jest/issues/429 (if you're bored and want to have fun, see if you can identify the 'fix' in this diff that avoids that bug).  But I digress...

This diff results in a divergence between dev and prod behavior (specifically, more components will rerender more often in dev) because we no longer bail out of reconciliation in dev mode due to https://github.com/facebook/react/pull/3516/files causing there to always be a context variable change.  This means not only that we should start running React unit tests in both dev and prod mode, but also has ramifications for developers who only test in dev before shipping their components to prod.

@sebmarkbage @spicyj 
 @sebmarkbage @spicyj Ping.
 @steveorsomethin I don't remember what @sebmarkbage's reason was, but I vaguely remember there being a reason.  The optimization does still apply if the context provider is not in the render path (eg. updating due to a setState).  I'm happy to change it if @sebmarkbage (or @zpao / @spicyj) would like it changed.  Either way, we should move this diff forward.
 It is not always a new object for the same reason the element isn't always a new object. It is because of subtree state updates where you start deeper in the tree.
 @steveorsomethin Nothing insurmountable, except that @sebmarkbage hates anything that smells like a subscription :P, but he is very reasonable and willing to give PRs a fair chance.  If I recall correctly, a internally-subscription-based implementation was the only viable alternative that was examined.  That was back in https://github.com/facebook/react/pull/3973.  The followup discussion was that, if we were going to do that, we might as well do https://github.com/facebook/react/pull/3920 and use that to manage the context subscriptions.  But then we're not even sure we want to do that, and we'd also need to look at the ramifications on https://github.com/facebook/react/issues/3398.  And then React Conf Europe rolled around and we decided to table all the discussions.  In the mean time, we released a 0.14-beta, and this bug needed to be fixed :P.

Anyway, you're welcomed to look into it.  https://github.com/facebook/react/issues/2517 and https://github.com/facebook/react/pull/3973 would be a good place to start.
 The reason for this PR is to avoid a regression between 0.13 and 0.14. It's not better but at least it's not worse.

#3973 or something like it is the real solution. 
  Duplicate of https://github.com/facebook/react/issues/2402

TLDR: It's more complicated than you might think, but something we want to do eventually.
  Thanks! I thought I fixed that last night but merged the wrong branch locally, oops!
 It did :) https://travis-ci.org/facebook/react/jobs/70339132 (but my human error bypassed that)
  Yeah, we strive to implement the most general and explicit solutions, so long as we don't introduce excessive burden on the developer.  A single call to `concat` when you want to merge properties does not constitute excessive burden.  Automatically merging styles is particularly bad if the MyComponent creates a wrapper div (for instance) and the styles are intended to apply to the nested element instead of the wrapper.

I'm going to close this out, since I'm fairly certain this is not something we want to do.  Feel free to continue the discussion on this thread.
  Thanks!
  Thanks!
  Looks great, thanks!
  Well, that's annoying.  https://jsfiddle.net/pgtf6aym/
 Fixed in 0.14 by #3595.
  The wording there is a bit confusing but here's a short answer:

Our DOM components use (mostly) the JS API so we opted to use the JS properties (`node.className`, not `node.class`).

You're welcome to use `class` and `for` in your own components. Not all JSX compilers quote keys (eg react-tools) so just be aware of your own constraints and tool choices.
 If the docs are confusing, we should leave the issue open to fix them.
  Your unit test passes even without your changes to ReactMount :/.
 Ok, all looks reasonable to me.  Thanks @drd!
 @leolannenmaki We don't generally backport anything except critical fixes.  React 0.14 should be out soon :).  In the mean time, you can develop/test against master, or use one of the prebuilt packages mentioned in https://github.com/facebook/react/pull/4311, or do what you're already doing now.
  This came up while diagnosing #4321 - https://github.com/facebook/react/issues/4321#issuecomment-120064258

This is because we just look for the closing `>` when adding the checksum.

```
> ReactDOM.renderToString(React.createElement('img'))
'<img data-reactid=".yxoueqje2o"/ data-react-checksum="-951841932">'
> ReactDOM.renderToString(React.createElement('div', null, React.createElement('img')))
'<div data-reactid=".2d7dcluvuv4" data-react-checksum="-890562330"><img data-reactid=".2d7dcluvuv4.0"/></div>'
```
 No, indexof is not sufficient because an attribute might contain a `<` character.  I have a fix, pushing now.
  Dear all,

I've faced an issue about testing collaboration between label and checkbox elements.
#### Context:

I have a custom checkbox with label:
![image](https://cloud.githubusercontent.com/assets/2273613/8599001/3ca2f6d2-265e-11e5-9e02-6db5ae8d04b6.png)

My goal is to test few behaviors, and one of them is "Component should fire `onChange` when user click on title". Title in our case is "Create link hotspots...". So in browser everything is fine, but when I started cover it by tests I faced that click emulation on label doesn't lead to change checkbox's value _immediately_, but works if I hack it with `setTimeout(..., 0)`.
#### My testing stack:

```
‚îú‚îÄ‚îÄ babel@5.6.14
‚îú‚îÄ‚îÄ chai@3.0.0
‚îú‚îÄ‚îÄ chai-spies@0.6.0
‚îú‚îÄ‚îÄ jsdom@0.3.4
‚îú‚îÄ‚îÄ mocha@2.2.5
‚îú‚îÄ‚îÄ react@0.13.3
```
#### Question:

Why it happens and do you have any plans to improve this behavior?
 In reading your problem description, nothing jumps out at me.  Do you have a simple jest test that we can run in our repository to reproduce the bug?

As a side note: TestUtils is mostly internal API, intended for us to be able to test React code.  Just be aware that it isn't stable external API, and isn't technically supported.
 I'll do my best to provide you Jest example asap, but even now I can't assert it'll happens using Jest, because I'm **not** using it. As you can see above, it's about `mocha` + `jsdom`. 

About TestUtils - I think now everybody who do unit testing for their React components use TestUtils, not sure it's so "internal". 
 Actually, you are correct, they are documented: https://facebook.github.io/react/docs/test-utils.html

Yeah, if we can reproduce the bug, that'll be the first step towards a fix.  Thanks!
 Yeah, seems it's related to jsdom. Damn, what a stupid decision to support only `io.js`
 @nikolaymatrosov Hm, I was wrong: I've tried to replace `node` and `jsdom v3` by `iojs` and `jsdom v5` and the issue is still there. I'll make a simple test case as I promised
 Ping @Kureev for a simple testcase.
  @Ianfeather Thanks!
 React checksum attribute gets inserted in the wrong place when rendering a self closing tag at the root.

@Ianfeather I believe you can work around the issue by having your render function return `<div><img alt="foo" /></div>`.  I know it's hacky, but let me know if this does/doesn't work for you.
 @jimfb, going to file that separately since it seems tangential (0.13 didn't do self closing tags)
 React didn't generate self closing tags in 0.13 so I'm not sure how `markup` would ever contain that in 0.13. It also looks like you're using `ReactDOM` in your client code, which to me indicates you might be mixing versions (the require statement isn't there so I can't be sure). Could you double check the version numbers (rebuild client bundles, clear caches, etc just to be sure)
 No problem, we found a very legit bug as a result of the discussion and investigation!
 @nodu Sounds like you're not using ReactDOM 0.14 on the client...

**EDIT:** Oh wait, did you spot this yourself or was it reported in the error message? The difference reported by the error message is incorrect (not sure if it's fixed yet).
 @nodu What do you mean when you say the client does `<img blah blah >`?  Are you getting a checksum warning?  Can you provide a simple jsfiddle that demonstrates the problem?
 @nodu Your error message indicates an element with a different key on client/server, specifically `EXxkPxefTtywv7xFToFL...` vs `36luBceRSfSgZB7DSKsN...`. What you're seeing there is the `data-reactid="..."` attribute.
 @nodu I'm still not sure how you arrive at the conclusion of `/>` being the issue, are you not checking normalized DOM vs rendered DOM?

> I'm at a loss on how to go forward then.

Look for a place in your code where you provide keys that look like the ones above, and try to figure out why they may be different on the client and server. Are they randomly generated? Are they part of a non-sorted DB query that you execute once for server and once for client? (bad idea) Are they serialized and sent to the client as JSON and displayed without sorting? (some JSON implementations do not maintain key ordering)
  :thumbsup: thanks!
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 Seems reasonable to me, but @zpao and @spicyj know the packaging the best.
 :thumbsup:

Want to poke the Hello team too and get them to upgrade/use the same version? Looks like they're using the dev version in prod (http://mxr.mozilla.org/mozilla-central/source/browser/components/loop/content/shared/libs/react-0.12.2.js)
  Overall, diff looks good to me.
 Module scope should be fine, since this particular bug is easy to find/fix via grep (ie. you don't need to clutter up the console with each instance; knowing that there is at least one is sufficient and the person can use grep from there).  Diff looks good to me.  Thanks @koba04!
  TestUtils are primarily for internal testing purposes, and are not stable public APIs.  We usually don't implement a particular piece of functionality until we need it for one of our internal tests.  What is your use case?  Are you trying to create a PR for this repository?
  Hmm, #3355 landed after we shipped v0.13.0 and we never took that in the stable branch. At this point (going on 4 months later) we're not going to add it now so we should update the docs for react-codemod, then figure out the right thing for 0.14. cc @cpojer 
 This is unfortunate. We are thinking of adding a flag to React components that denotes whether they are pure (cc @sema). Once we have this I will update the codemod accordingly.

@pocketjoso I would suggest, in your main component (or any side-effectful component that sets up your environment), to manually add React.addons.shallowCompare. You'll be able to remove this once we ship a React version that exports this function or once we add the flag I mentioned before.
 Oh, I missed this! Yeah absolutely, this shouldn't be that big of a deal, except of course adding a require/import at the right location is still hard :)
 I'm quite swamped with work on jest at the moment. Is this something you'd be interested in sending a PR for, @jardakotesovec ?
 Moved to https://github.com/reactjs/react-codemod/issues/2
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thanks! (this should be small enough that the CLA shouldn't matter but if you sign it then any future PRs can go more quickly).
  Yes, that would be nice. Any chance you want to look into adding it?
  Fix event target for input change events.  Fixes #4288
 Will `beta2` be released after merging this?
 @chicoxyzzy Not sure, I'd really like to get the reconciler fix too before beta 2, but we'll see.

@zpao CR?  This should be ready to go.
 Ping @zpao 
 Threading that argument through is pretty annoying :(. Any other cases you missed?
 Note for blame hunters (eg me): this is a regression due to #4150.
 Hopefully not missing any others.  I did a skim of the uses of nativeEvent, all of them looked reasonable (already have nativeEventTarget or don't need it in that situation).
 Ship it at some point

Edit: sorry, didn't read who asked that (thought it was a teammate who I could be a smart-ass to üòú). I was thinking we'd push out a beta2 sometime soon, maybe this week or next - want to get a few more things in order first.
 @vslinko @richardaday It's not an officially supported/stable solution, but https://www.npmjs.com/package/react-dom-future stays up-to-date and has these fixes merged.  It's what I use for my own testing and stuff.  Obviously don't use this in production, but it'll let you play with the latest and greatest features and then you can let us know when we broke things in trunk :).
 @jimfb thank you!
 @jimfb We already have http://react.zpao.com/builds/master/latest/ which has the latest browser builds as well as the npm packages (.tgz). So you can run

```
npm install http://react.zpao.com/builds/master/latest/react-dom.tgz
```

or list that URL as the version spec in package.json. These are updated automatically by Travis.
 Ok, great, that works too!
 Should have been‚Ä¶
 Well, the change definitely made it out. But perhaps it wasn't a complete fix.
  This is probably a good idea. Jest has issues with require statements in strings or comments too.
 @mmoss Can you add amend the commit to include a comment (above the changed) line explaining the problem, since it's non-obvious what the motivation of the hack was for anyone reading the code.

Something like this: https://github.com/facebook/react/commit/357ed8ebd7d890d14193962ced6c2fbcf563cec2

Also noting mostly for tracking purposes, I think this will be fixed by @zpao's PR to use fbjs, since it will no longer use commoner?
 I suppose this is fine but just goes to show why AST parsing is so much better than simple regex detection (this isn't a problem with babel since it correctly parses the code and knows that's a string literal).

@jimfb - not a problem with our build process so commoner is exempt in this case but it does the same regex search.
 Ok, Thanks @mmoss !

@zpao Agree, people shouldn't be doing their own parsing; they should be using an AST.  I'm fine with this one to unblock people using jspm today.  I had thought this issue was related to commoner, which made me a little more sympathetic.  In the future, we should perhaps be a little stricter in saying that people should fix their tools rather than forcing ridiculous hacks into other projects.
 We'll do another beta soon. No specific date though.
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
  Do you have a simple example that demonstrates the issue?
 No response for over six months, closing.
  cc @spicyj There has already been a few people who have been confused by the old wording, as per https://github.com/facebook/react/issues/4305.
 Sure, thanks.
  Your child component is probably a composite component, not a dom component.  DOM components are like `span` and `div`.  If your component has a `play()` function, it is probably not a DOM component (technically, you could be referring to a web component, but then you will get the physical WebComponent so you should still be able to use the play function on that).  Most likely there is no issue, you will continue to get your composite component and everything will continue to just work.

Did you test to see if this breaks your app?
 To clarify:
- DOM Components wrap the nodes in the DOM.  They are things like `<div>` and `<span>` and `<img>`.  Refs to these components now return the underlying DOM node, so there is no longer a need to call `findDOMNode` on them.  Getting the DOM node was basically the only thing you could do with them anyway, so returning the component wrapper instance was pointless.
- Composite Components are the components that you wrote/implemented.  They are things like `<MyFancyMenu>` or `<MyContextProvider>`.  Refs to these components are unaffected.
 Looking at the blog post, it does say:

> References to custom component classes work exactly as before.

Since the blog post is technically correct and does explicitly state that custom component classes work exactly as before, I'm going to go ahead and close out this issue.  Feel free to continue the discussion here.  If enough people find this confusing, we can re-open this issue to work on the communication/messaging.
 @serle Do you have a simple jsfiddle that demonstrates the issue?
 @adjavaherian You're trying to access a method on a rendered child. You can't access that directly. You could attach a ref in render of ContextWrapper (on Stub) and then put a getter in ContextWrapper that access that ref and exposes the method.
  there is no method `getInitialState`. you should use constructor with ES6 classes
see [this blog post](https://facebook.github.io/react/blog/2015/01/27/react-v0.13.0-beta-1.html#es6-classes)
 Thanks @chicoxyzzy, that's the correct answer.

I'm going to close this issue, since it's not technically a bug in React (we use Github issues to track bugs in the React core), but feel free to continue the discussion in this thread or move the discussion to StackOverflow (preferred site for questions).
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 I'm treating this mostly as an RFC; is this something we'd want?  The ResponderEventPlugin predates me.

Events: @syranide 
Big PR: @spicyj @sebmarkbage 

@dieppe There is a lot to consider when making changes to the core (both history and future plans) and it's often helpful to start small in order to learn.  Before tackling a big PR like this, my intuition is that it's worth trying to tackle a few of these: https://github.com/facebook/react/issues?q=is%3Aopen+is%3Aissue+label%3A%22good+first+bug%22
 This is a great start. I would like to move the source of truth of these files from react-native into this repo. After that we can rebase and reevaluate.

cc @jordwalke for thoughts on unification.
 This is repo the source of truth for all but these files which I didn't copy properly:

https://github.com/facebook/react-native/blob/62e8ddc20561a39c3c839ab9f83c95493df117c0/packager/blacklist.js#L17-L19
 I‚Äôm closing in favor of #6352 which is the new issue I created. Incidentally, #6338 should bring in the relevant missing dependencies, so we can look at this again.

We are learning towards using issues (perhaps in a separate RFCs repo) rather than stale PRs for discussions, so I‚Äôm closing this PR. However your work is very much appreciated, and you are welcome to contributing to discussing this in #6352, and if there is a consensus, to continue this exciting work.
  I feel like you really should solve this through unit test isolation.  Each unit test should run in a new javascript context, such that nothing one test does could possible influence the other test.  For this reason, I'd say a fix for this is a low-priority use case at best.

We don't want to have any global React configuration states, so supporting opt-in erroring/warnings is probably not something we're going to do.

Also related: https://github.com/facebook/react/issues/3252, because having multiple instances of React (presumably each with their own warning memoization/deduplication) would mean that each would fire the warnings (it's a poor-man's version of test isolation).
 @glenjamin The existence of low quality test frameworks is not a reason for us to compromise our designs.  There are plenty of good options for test isolation, like jsc, that don't require spinning up browsers.

Long running applications are exactly the reason we warn only once per javascript context.  Once we've informed the developer they have a bug, we don't need to keep warning them.  Warning once per render wouldn't make sense either; we want to get to the point where we can do 60 renders per second.  Moving forward, we expect renders to happen more (not less) frequently.

The argument for things like hotloading is a little harder to refute.  While I personally don't use hotloading, I can see why it's useful and why allowing the hotloader to reset React would be desirable.  But I think the solution for hotloading is a combination of https://github.com/facebook/react/issues/3252 and https://github.com/facebook/react/issues/3932#issuecomment-104480582
 Yep, it's a tough problem.  We've talked about the idea of adding a `clearAllInternalState()` function, which might be a possible solution.  I still think the best solution to your particular use case is test isolation, but I understand that's not possible in all setups/environments/situations.

I'm leaving this thread open for tracking purposes.  We don't really have a good solution at the moment.  Feel free to let us know if you have ideas / proposals for solving this.
 Yep, I actually created a diff for that exact idea a few months ago (not sure if it ever hit github, but I do know we ultimately decided to abandon it).  The problem was that the deduplication logic was often times specific to the use case (Do you warn once globally?  Once per component?  Once per property name?  Back off logarithmically based on time?) - it was too difficult to generalize without it being too awkward to add warnings.  That doesn't mean it isn't possible though, just harder than it sounds at first glance.

So far, I most like the idea of providing some kind of reset functionality to addons.
 Yeah, you'd need some way of coordinating the intent to dump the state.

Incidentally, I just realized a possible solution might be to pass an extra argument to the warning module (specifically, a boolean, to indicate if React thinks the error message should be shown based on our deduplication rules).  The warning module we provide can honor the boolean and only print if the value is true, but power users could override the module to implement their own preferred deduplication logic or ignore the deduplication flag altogether.  I don't really see any meaningful downsides to this approach.
 I don't mind inserting the boolean between condition and format as you indicated, but @zpao is usually the one with the strongest opinions on modifying function signatures, so just run it by him before investing time in a PR.
 I'll defer to @zpao here, I have no objections.
 Ping @zpao 
 @joeybaker We have worked very hard to avoid all global configuration, and probably aren't going to add it here, so I don't think we're ever going to expose `React.onWarning`.

Another unrelated update: I was talking with Sebastian the other day, and we were discussing design ideas around a good devtools API.  Specifically, we want to expose an API that could power tools like https://facebook.github.io/react/blog/2015/08/03/new-react-devtools-beta.html .  Anyway, the related chunk of that discussion is that it might be possible to move all the warning-related logic out of the core and into an external module (to be packaged with React in the dev distribution) that uses the same devtools API to figure out and emit warnings.  With that refactoring, you could easily fork that module and do whatever you wanted with regards to warnings, since none of the warning logic would live in the core.
  @slorber Nothing jumps to mind.  Your code appears to be pretty complex.  If you believe it's an issue with React, it would be helpful if you can provide a minimal jsfiddle that demonstrates the issue.  This example imports a bunch of libraries, and has a bunch of things going on in there.

Also, if you'er debugging, it may be worth looking at what nodes are at id '.0.0'; the value of those nodes may provide you with some context/info that makes it more obvious what's going on there.
 @slorber Yeah, a simple jsfiddle would still be helpful so we can fix this issue :P.
 Realistically, this bug isn't too actionable in it's current state.  A minimal jsfiddle would help us identify the issue.

Might be related to https://github.com/facebook/react/issues/3790, since that's the only place I'm aware of that results in this error being incorrectly thrown, but it's just hard to tell from this.
 Yeah, it's hard for me to imagine how `renderSubtreeIntoContainer` could be the cause of the issue, since (in theory) the only thing it does differently from `React.render` is to propagate context.  My guess is that it is either user error (ie. one of your libraries is manually modifying dom nodes) or is related to a race condition in React ala https://github.com/facebook/react/issues/3790.
 FWIW, I shipped beta2 last night so you might be able to get a repro case going.
 Closing unless we hear more.
  Thanks @brigand, great answer!

@mrgreen7 You may find this document helpful: https://facebook.github.io/react/docs/forms.html

I'm going to close this issue, since we use Github issues to track bugs in the React core and this is not a bug in the core.  Feel free to continue the discussion on this thread, or as @brigand suggested StackOverflow is a better place for usage questions.
  @spicyj and @sebmarkbage are the correct people to figure this out, so we'll let them have the final word.

Question: If someone does want to replace the ref (for whatever reason, they don't want to preserve the original ref in any way and want to completely override it), how would they do this with the new API?  I'm worried that this new version of cloneElement is strictly less flexible.

Personally, I feel like this might take us in the wrong direction for the core (I'd like to see refs get less special/magical over time, not more special/magical).  I think it's great to have an easy way to wrap refs via a utility (you should consider publishing your version!), but I don't think it's good to have that be part of the core.
 My concern with chaining refs implicitly is that you may introduce subtle bugs by having two sources touching an imperative API. You can't reason about how they interact. It can also lead to subtle race conditions. There's no single source of truth of the state - which is what React is all about.

I do agree that it is common for people to forget about the ref and that others might want access to it. However, I think that it is very important to make the choice explicitly. If they didn't, you can just ask them to do that explicitly or do it yourself. This is also one of the primary reasons we discourage `React.findDOMNode` for the benefit of direct refs since it allow you to by-pass the contract of a child and get access to a deeper ref.

Regarding replacing refs with data binding, I think that every possible use case in React could be replaced by data binding. We know because there are so many FRP libraries that have done it and we know how to do it. We also know that can lead to massive complexity. It is very difficult for us to make the call when we should move towards that direction since we know how it usually turns out. That's why I think that we should be very hesitant with data binding, but pragmatic when we need to be (e.g. Animated) - i.e. not as a general direction of the project.

refs is an espace hatch. It allows us access to solutions we haven't thought about. If we think about them, even just briefly, I think we can come up with great alternatives. For example, there are some ideas around focus and selection using parent-based context.

For higher order components specifically, it is usually the case that you want a pass-through ref. The current alternative is to have pass-through proxy methods on the higher order component. See #4213 

It seems weird to use cloneElement with higher-order components. @ide can you elaborate on how you use it?

Finally, `cloneElement` is mostly used as a way to pass extra props from a parent to child. However, that doesn't work through wrappers. This is one of the primary features of parent-based context so we expect a lot of uses of `cloneElement` to be replaced by parent-based context anyway. The exception is when you need a ref ofc.
  @adelevie Good first attempt!  I'm not entirely sure what a fix to the language thing is going to look like, but I know that index.html is generated from index.md, so modifying the generated output is not going to work.  Also, pull requests should be against `master`, not `gh-pages`;  changes from `master` will get copied over to `gh-pages` after they are in the master branch.

The source file of index.html is index.md, but the md file is translated into html and inserted into the generic page template, so you're probably going to need to find the template file and modify that.  Furthermore, we probably can't just set the `lang='en'` in the template file if we use the same template file for all the translations (not sure if we do), so there may need to be some kind of logic to select the correct language for the template.  Regardless, the diff as-is won't work.  I'd recommend looking in /docs/README.md to get an introduction to how the documentation/website is generated.
 Going to close out since this is against the wrong branch as mentioned (and you can't change the target branch once a PR is created). @jimfb is right - we do use the same templates for all the translations so we'd want a way to make sure that it's possible to override (eg, by specifying a `lang` field in the front matter). It's doable but will be more work than just what you have here.
  Great job!  Your fix was right on!

I'm going to run with https://github.com/facebook/react/pull/4311 since it has a unit test and passes Travis.  But you should know that you fix was exactly correct.
  @d4goxn If the user is editing the form, the markup (attributes) remain unchanged while the javascript value (property) changes.  This is why markup validation does not fail.  Keep in mind that markup validation was intended as a sanity check for SSR, and was not intended to protect against this use case.

With regards to the race condition, yes, it does exist, but it's a little unclear what we could/should do about it.  One option is to enqueue the events until such time as the required javascript has loaded, and then play the events - but this requires that the event listeners have been setup which requires that at least some minimal javascript has been loaded.  We generally think of it in terms of a user clicking a menu which is a no-op until the javascript loads (interactions lost), but the form field modifications is an interesting case.

An option specific to form fields is that we could check in componentDidMount if the value property is equal to the value attribute, and if they are not equal, emit a set of events (is a single change event always sufficient?) such that they are made equal.  Perhaps this is worth doing.
  Seems good, thanks!
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Seems reasonable to me.

Also, @rwoodnz can you sign the CLA so we can merge?  You know, lawyers :/
 RE CLA: Well, that's annoying.  I found your record in the CLA database, but there is no github account attached to the record.  I'll try to figure out the CLA situation on our end and ping you when I've figured out next steps.
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 Ok, CLA situation has been solved.  @rwoodnz, if you can amend your commit to put the public/comments.json in backticks (the key just above the escape key, `, so it becomes `public/comments.json`), I think we'll be ready to merge.
 :thumbsup:
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 As per github bot, CLA required.  You know, Lawyers :/.

I'm also not entirely sure this sentence is necessary/helpful.  Is this something that confuses people?  It seems fairly obvious to me; I'm not sure how someone would be able to figure out the rest of this tutorial if they can't figure out to test in their browser.
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 Ok, I suppose it's fine to provide an extra nudge for people to actually follow along rather than just passively read the document.
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 üëçüèº thanks!
  Same issue. The workaround is using `e.currentTarget.value` instead of `e.target.value`. But that's kinda wrong :(
  Looks legit, thanks!  How did you find all these?  Is there a lint rule we can enable?
 Not for TypeScript (at least not the tooling we have, but probably with some basic TS tooling). And I think we're still excluding a few of the files in test/ from linting. We need to move a few things from there to a better place and then we can lint that properly too.
 IMO, I think it's a bit excessive to start including linters for TypeScript, CoffeeScript, etc. It's a tiny proportion of our code.
 @bgw agreed :)
  My intuition is that this is a bit out of scope.  Also, to be honest, we're still figuring out where everything should live, so all of this is subject to change.  It's all internal API, so don't rely on any of it.

I think the answer is that you need to implement whichever functions you want to provide.  The most obvious are `MyReactRenderer.render()` and `MyReactRenderer.unmount()`, but depending on your target environment and use cases, you may want more (or even fewer) things.  For instance, the server side renderer doesn't need to provide unmount (because you will never mount/unmount on the server), and the web renderer provides `findDOMNode` because that is sometimes helpful when working with the web but which is impossible/meaningless to implement with server-side rendering.

The React core provides `React.createElement`, `React.createClass` and `React.Component`, `React.PropTypes`, `React.Children`, and the other helpers related to elements and component classes.  Everything else is the domain of the Renderer.  We've put some shared renderer stuff in `src/renderers/shared/` because we think it's useful when implementing your renderer, but not all renderers can/should re-use that code.

Ultimately, I think you're supposed to think of the core as a shared library that is shared with your Renderer implementation.  Your Renderer is permitted to call into and re-use as much code as is practical, which largely depends on how similar your environment is to what already exists.  It would be much easier to target a xml-like output language than one built on top of opengl for instance (because the React renderers are currently optimized for (x)html markup), but it's just a matter of how much code you can re-use instead of re-implement.  A good way to get started would be to fork an existing renderer (ideally, fork whichever is closest to whatever you're trying to implement).

My intuition is that we close this issue, since it's not a bug in React, and is probably not something we want to add to the formal documentation, but it might make for a reasonably interesting blog post so it's worth keeping in mind.
 While we might not end up with a formal spec, we should probably figure out our messaging here before launch. I think @jimfb is mostly right but too much ambiguity here is probably not advantageous to us. cc @sebmarkbage 
  I do like the change that gets rid of the child variable and moves the other line into the `if` block.  If that's ultimately the only change in this diff, I'd accept.  Also, @simek let's flatten the multiple commits into a single commit.
 @Simek Just FYI future reference, on your PR branch, you can squash the commits (http://gitready.com/advanced/2009/02/10/squashing-commits-with-rebase.html) and then do a `push -f` to do a force push to the upstream branch, which will override the PR with the single commit.  The nice thing about git is that you can fix virtually anything :).  Still happy to accept the removal of the child variable.
  That's fine. Thanks!
  The God of css doesn't forgive mistakes like this. Thanks!
  I'm not sure how I feel about this one.  The purpose of this code is to be a simple example, and the additional markup just adds more noise for the reader.  The goal of this document is to teach React while keeping the complexity to a minimum, and I don't feel like this change furthers that goal.

We've left off a bunch of WCAG stuff in the examples, and making everything fully WCAG compliant would result in a bunch of additional code that is orthogonal to React.  React does support the WCAG attributes, and anyone who is making their site WCAG compliant will surely be able to figure out how to add these attributes.  This is further complicated by the fact that these documents are being translated into different languages, and it means that the translation may no longer be purely of text nodes (code changes now involve changing browser code).

Anyway, we've also left off things like character encoding tags (though those are arguably even less optional).
 We also don't specify the lang attribute on http://facebook.github.io/react/  We should probably fix that, @adelevie, if you're interested in this stuff and looking for something to do :).
 Yea, I'm with @jimfb on this. It's not necessarily bad but the focus, especially on the getting started page, is not on the HTML details (and might actually be the wrong thing to copy paste for somebody in a different locale, whereas the doctype is actually important in some browsers).

I do think accessibility is important though so let's add it to the actual tutorial code (https://github.com/reactjs/react-tutorial/blob/master/public/index.html and https://github.com/facebook/react/blob/master/docs/docs/tutorial.md)
  Based on your code, I'm assuming you're playing with the 0.14.0-beta?

Your code looks fine to me, and it runs fine in my environment.  How are you running this code?  Can you provide a jsfiddle?
 We have seen this error if you have multiple instances of React loaded; so that might be an idea of something to take a look at if you are using a pre-packaged component.  Sometimes a second instance of React can get pulled in as a dependency to one of your components/whatever.
 You probably have two copies of react in your repo. `npm ls` or `npm ls | grep react` might help illuminate.
 That alone shouldn't cause problems.
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
  Things moved fast and I don't think those made it. We'll make sure they get done soon (next beta)
  This PR makes it so the name is 'updates' but the module is 'update'.  Seems inconsistent, I'd imagine we want to update the npm module to be called 'updates' instead.  But @spicyj and @zpao are the ones who understand all the packaging stuff.
 Oops, we should probably call the package react-addons-update. It gives you a function called update so‚Ä¶
 Thanks!
 (Published to npm.)
  It's a build artifact allowing us to create multiple development and production builds.
  Very well written. LGTM.
 @koba04 it's not done yet #3995 (not reviewed and doesn't pass ESLint)
  The only bug number that I have memorized at this point is #140. It keeps coming up, and maintaining the ever-growing whitelist is infuriating.

As a baby step toward fixing that bug, I think it would be nice to know if the spread operator is used during element creation, since this is the primary way that attributes could be accidentally passed to an element. We could then only enforce the whitelist on elements that are using the spread operator, as a baby step toward eliminating the whitelist altogether. In order to do this though, I think we need to modify the transform (Babel?), right? Do we want to file a bug against them?

This issue is mostly exploratory, to get an idea of what would need to be involved to do this effectively. RFC: @spicyj, @sebmarkbage 
 Also negative feelings on this. The whole point of object spread is that it works the same as not spreading.
 There are other ways to get prop typos in. Explicit typos, intentional, Object.assign, object spread.

What's the progression and end goal here? Are you going to warn for explicit typos first? And then tackle the spread or are spread always going to remain unwarned? What's the point of warning for non-spread before warning for spread?
 @sebmarkbage Object.assign and object-spread will ultimately manifest themselves as a jsx-spread, since that's how you go from an object-full-of-props to an element with properties, so those use cases are covered (assuming the person is using jsx).

My working assumption is that if a person does `<div {...myProps} />`, the person might be relying on the whitelist to filter props, but if they are explicitly setting props (eg. `<div align='left' />`) then they aren't just forwarding props and so the whitelist filtering is providing very little value.

This is a good first step because it unblocks anyone using custom attributes (They now have options: can create the element without using the spread, or they can invoke React.createElement directly), while sidestepping the main blocker of #140 (namely, people using spread to forward props that they don't intend to be inserted into the DOM because they are relying on the whitelist).

It solves the immediate issue at hand (no way to pass custom attributes to a DOM element) without being blocked by use of the spread operator, and it allows us to break the migration into two steps (fix everything except spreads, and someday in the future fix the spreads too allowing us to remove the whitelist completely).

@syranide Correct, it isn't htmldom specific and not everyone uses it.  People who don't use it would need to migrate their code to not rely on the whitelist (we provide warnings to help them with this).  As for it not being htmldom specific - that's true, but we're making the situation strictly better than it was before (for both htmldom and non-htmldom), so I'm ok with this.
 I don't think it's a big issue that we'll pass down props too much in some cases. I'd expect at most one or two things to break in FB code and maybe another one or two for external users. More importantly, it doesn't seem like we'd have any other good path to weed those out before a switch (unless we can figure out which attributes have meaning but are currently not passed so that they can be logged), so I think we may as well switch all at once.
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 This file is generated as a part of our build process and will actually be discontinued soon so even if you updated the right place in the source it wouldn't matter. I appreciate the PR but we won't be taking it.
  Thanks!
  Do your files have a `.jsx` suffix or a `.js` suffix?  The command in the docs (getting-started.md) correctly states that it will translate the `.js` file.  It says nothing about `.jsx` files.  Am I correct in assuming that's the problem?
 @amitmtrn Yeah, Sebastian wrote a long rant about this somewhere.  Basically, it's a side effect of the fact that using transforms is now a fairly standard thing to do in javascript.  For instance, if you're using es6 classes, you have to use a transform, but that's technically part of the javascript language now.  What if you're using es7 features?  What if you are using speculative features that haven't reached consensus at TC39?  What if you are using multiple language extensions?  `mycomponent.es6.jsx.flow.sweetjs.whatever`?  How do you decide on the order of the suffixes?  It starts to become a mess.  Since transformations are a part of the javascript build/deploy process nowadays, and are here to stay, the decision was made to just call everything javascript.
 Update: I found Sebastian's original post I was talking about: https://github.com/facebook/react/issues/3582#issuecomment-90964457 (it wasn't as long as I remembered it being)

On another note, I think the jsx command is provided by react-tools, which is being sunsetted in favor of transforms like Babel which have jsx support built in.  See: https://github.com/facebook/jstransform/pull/81

For these reasons, I'm going to go ahead and close this issue.
  I think failing to support international characters is not by design :P.

I just tested on jsfiddle and in one of the files in the examples directory, it seemed to work fine.  This seems to imply to me that it's not a React issue.  Are you sure you have the page encoding set correctly for your test?  Try something like `<meta charset="UTF-8">`.  Can you provide a complete testcase / steps to repro?
 Yeah, that seems reasonable to me.  Any example containing non-ascii characters should probably have the meta tag.

On a related note: Might also want the meta tag on the english versions (for consistency, if nothing else).  Encourage the best-practice of always specifying your encoding.  But I'll let @spicyj and @zpao be the gatekeepers of that decision.
 I guess I'm okay with that, though in reality what charset you use for your HTML files is your own business and React doesn't really care. 99% of people probably do want utf-8 though so we can add it.
 cc @tako-black 
 `<meta charset="UTF-8" />` works, although it's a far worse solution than using the correct HTTP headers. Without the HTTP header, browsers have to examine the first few kilobytes of the page, guess the charset from the character frequency, then start parsing with that guess. If it encounters a `<meta charset="blah" />` tag, and realizes it got the charset wrong, it has to stop and reparse the entire page.

If we're going to make a suggestion about defining a charset, we should suggest the appropriate HTTP headers. The meta tag is buggy and has horrible perf characteristics.
 @bgw Users run into this when opening local html files, which don't have server headers.  But yes, I agree.  That said, anyone who knows how to set a server header will know to remove the meta tag from their markup :P.  The point is to solve the problem where someone opens a local translated example and it blows up.
 @tako-black Yep, if you want, any inline example in the translated documents that renders a full HTML markup (like the first code block example on http://facebook.github.io/react/docs/getting-started.html) should probably contain `<meta charset="UTF-8" />` in the header.

Was cc'ing you mostly so you had context and were aware of the issue, since it primarily affects translations.
  As always, thanks!
  The documentation is not contradictory.  If you call render twice with the same element, the second invocation will effectively be a no-op (because there is nothing to update).  If you pass in a similar element (same type, but maybe with a different property for instance, resulting in a slightly different render result), the DOM will be updated.  The documentation is correct in description of this behavior.

The note is saying that if your container already has some random DOM nodes in it before you invoke an initial render, those nodes will be blown away.

Since the documentation is not self-contradicting and is merely describing a behavior (and edge cases) that requires the reader to be semantically careful in their reading of the API, I'm inclined to close this issue.  Having said that, I'm curious if you have a proposed wording that would have been more clear to you.
 That new wording isn't technically true either (though I suppose not worse than the existing wording), because if you mutate the nodes in the container after initial render, those changes may or may not be blown away.

I think another point the note is trying to indicate is that the update has the effect of rendering the specified element INTO the container (children), rather than AS the container (updating the element in place).  Lots of people mistakenly think that React.render() will update the node passed in (for instance, if they pass in a component that ultimately renders to a body node, and mount that to the body, they think it will replace the body instead of attempting to insert the rendered body node INTO the the existing body node).
 Perhaps if we said:

> React.render() replaces the contents/children of the container node you pass in, rather than updating the container node itself.  In the future, it may be possible to insert a component to an existing DOM node without overwriting the existing children.

Unclear if that actually solves your initial complaint though.
 > React.render() controls the contents of the container node you pass in*. Any existing DOM elements inside are replaced when first called. Later calls use React‚Äôs DOM diffing algorithm for efficient updates.
> 
> \* React.render() does not modify the container node (only modifies the children of the container).  In the future, it may be possible to insert a component to an existing DOM node without overwriting the existing children.
  Dupe of #1297. mouseEnter/mouseLeave should work in the 0.14 beta already and in 0.14 when it comes out.
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 Thanks!
  React adds one top level listener for each event but doesn't stop listening if the components are unmounted. We've never seen this to be a performance problem.
 It could be that removing listeners is better in some cases, but in other cases you'll soon mount a new component which needs the same events in which case we'd be wasting effort by removing and readding them.
  This is a perfectly valid question, but since it's not a "bug" in the React core, I'm going to close the issue to take it off our radar, but feel free to continue the discussion here or on StackOverflow.

Animations are super hard.  The best animation library I'm aware of is Ryan Florence's library ( see this great video: https://www.youtube.com/watch?v=z5e7kWSHWTg ).  If I were digging into this, that's where I'd start, because his stuff is awesome.  MagicMove might be exactly what you're looking for.

I know that @vjeux has also been working on animation stuff.

It's probably also worth asking on StackOverflow, because other people might have other great ideas.
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 Thanks @janraasch!
  Thanks!
  Dupe of #3548. :)
  The plan is to move away from propTypes in favor of flow.  In the future we are expecting people to only define getDefaultProps and not to define propTypes.
 Would it seem less weird if required was the default, like it is in Flow?

My hope is that another dynamic type system (maybe using Flow syntax) eventually takes over the responsibility of React's propTypes. It really has nothing to do with React. However, until there is a dynamic alternative we'll still keep it. However, there is so much work making a really good type system that I think that it is a wasted effort trying to do it specifically for just React which is why we're not putting a lot of effort into this atm.

There isn't really a neat syntax to collocate the default value and type definition in Flow right now, but if you can think of a neat syntax you should propose it.
 Proptypes is mostly in maintenance mode, and we probably aren't making big API changes at this point.
  Great question for the discussion group (discuss.reactjs.com) but it's not an issue with React itself, so I'm going to close out.
  You are rendering a `<tbody>` into a `<tbody>` in your jsfiddle. It's invalid nesting according to browsers and they proceed to normalize it and break React's understanding DOM.

PS. There is no trivial fix here (can't return a list of `<tr>` in your component), you probably need to render the entire table with React for now.
 Right now you can't, the _only_ possibility is to render the tbody into a `table = document.createElement('table')` and then transplant the tbody from it into your table. But I really don't recommend that unless you absolutely have to.

Another possibility could be to render the entire table in React but use `<thead dangerouslySetInnerHTML={...} />` to leap back out into HTML.
 PS. I should add that you could render each `<tr>` separately too and insert manually, that wouldn't be a hack. But it would probably not be a good idea either and you would have to do the house-keeping yourself, but it wouldn't be a hack.
 Ok, looks like @rickhub has the info he needs!  Thanks @syranide.  And welcome @rickhub to the React community!  Since this isn't a bug in React, I'm going to close the issue, but feel free to continue the discussion on this thread or at StackOverflow.
  I don't fully understand the ramifications of using attribute vs. property flags.  I think that if it can be either one (need to test them on browsers?), we're supposed to use `null` instead of `MUST_USE_ATTRIBUTE`.  I think we're supposed to test on various browsers (or find in the docs where it specifies) if `element.propertyname = 'foo'` works and/or if we need to use setAttribute.  @spicyj?  Is there a reason one would be preferable over the other?  Any objections to this diff?
 #4237 is already in progress for the same thing, let's just follow through on that PR
 Sorry to close this but definitely appreciated! Hopefully we'll see you in some more PRs :)
  Thanks!
  @syranide @sebmarkbage 
 adding @spicyj.

@syranide and @spicyj: either of you know of a good example where we normalize in this way?  Can either of you provide some tips here?
 No, I'm not sure. I would be inclined to think that both mouseenter and mouseleave should fire. It's a little weird to me that click doesn't but I can kind of justify that one in my mind.
 @attilaaronnagy I believe this is expected and matches the HTML/DOM spec. @gaearon Did we miss this in the changelog?
  There is not. Why would you want such a thing?
 @nwwells It sounds to me like you're building a framework, rather than an app.  Our goal with React is to support the 99% use case for app developers, and ensure we have sufficient escape hatches for the remaining 1%.  I don't see a huge need for app developers to listen for all events, since app developers generally want to associate specific behaviors with specific events, and therefore know which events they care about.  Since you want to build a framework to manage your events, it sounds like the escape hatch is to use the DOM API, which will give you access to the underlying event system and let you respond in any way you want.  At least, that's my two cents.  I'll defer to @spicyj if he sees this issue differently.
 Most frameworks try to bow out of all high-level abstractions, for various reasons.  React, for instance, wants to bypass the DOM entirely and render pixels directly, bowing out of the browser APIs.  Because bowing out is such a common desire for frameworks, trying to support all frameworks with a single high level API is a hopeless objective, so it's better for us to just allow the framework developers to escape out to a lower level API.

With regards to being able to disable the React event system: what is it about the React event system that is interfering with your code?  What stops you from just ignoring (ie. not using) all React events?
 Hmm, interesting.  cc @spicyj @syranide 

What would an ideal fix look like for this?  Disabling the React handling of this event would lead to the data in the text box becoming out of sync with the value provided (this effectively turning the component into an uncontrolled component, which is wrong behavior from a React perspective).  

Obviously you could use uncontrolled inputs, but we should support controlled components in order to preserve idiomatic React.  For controlled components, it seems like having your framework specify an onChange event handler (using the React event system) is the correct behavior, since any other solution would introduce race conditions or data consistency issues.  I don't really see any other way around it :/.

Ideas?
 > There is not. Why would you want such a thing?

I agree. IMHO the power of React comes from the isolation of components and the readability it offers. I'm personally not at all a fan of being able to listen for most events on unrelated ancestors (onSubmit, onChange, etc), I see no technical reason why you want that other than being "less code". This is more of the same, it looks sensible because people have previous experience with HTML, I don't think many would suggest such a feature for any other frontend.

Don't get me wrong I don't necessarily mind there being shortcuts, but when you're not significantly experienced it's hard to know good from bad and these shortcuts look like actual solutions (especially to those familiar with jQuery) rather than the messy problems they tend to devolve into. It pushes you outside the "pit of success".

> I've worked around the issue by specifying an onChange on every input (technically I'm using valueLink), but I'd rather not do that, since it breaks my architecture.

In my opinion, that's absolutely the right approach (onChange on every input).

**But...** you're free to move onChange to context and provide custom components to go with it if you have a special use-case in-mind (which seems largely equivalent to what you want). There's nothing wrong with that, if you're OK with the complexity and find the trade-offs acceptable. But I think React does just fine being as simple as it is (and could easily shed a few of the HTML quirks). React already provides the tools needed to build such (frontend-independent) abstractions, it only introduces unnecessary complexity (for everyone) to have it in core.
 > so, are you rejecting my use cases I outlined about out of hand?

Not at all, but just because there is another way of doing something doesn't mean that it's an acceptable trade-off. You're talking about extending core in ways that seem objectionable to me, when context already largely solve your problem.

You expect React to formalize an API that's somewhat unique to HTML DOM. Not all frontends even have a concept of bubbling, you listen to controls individually.

> And using the context mechanism you refer to would essentially bar me from using anyone else's components unless I customized each one to use my custom version of the elements. Unless I could somehow do it in such a way that all components would be forced to you my implementation of the "input" component, for example?

Just provide a wrapper factory (or w/e). Components can always introduce inconsistencies or implement entirely different input methods (canvas, etc) that you would not be able to support as you intended. Wrapping allows you to interop with _any_ component that has a compatible API.

To be clear, I don't necessarily mind an event system exposing this functionality with you knowingly accepting the consequences (you're free to circumvent all the React stuff and hook the DOM directly). But the "React DOM event system" is an internal implementation detail, it should not be confused with the React API which should be generic and independent of the underlying frontends.
 > Well, FWIW, I would be doing this on any front-end, not just HTML DOM. To me, this is part of what got me excited about React, with the uni-directional flow of data. In fact, I'm not really asking for bubbling at all, but rather a single place to listen for all events generated by React. Every front-end generates events.

There are frontends implementing just per-control callbacks, having no central event system to subscribe to or simply having an incompatible API. I mean many basic game frontends only provide a global mouse/keyboard API, there is no bubbling or inherent concept of controls and focus. But, context and wrappers could handle all this just fine.

> Can you point me to an example of what you mean?

Something along the lines of the code below (just an example), could probably be turned into a helper/factory too.

``` js
class MyMagicInputWrapper {
  ...context stuff...
  render() {
    return (
      <MagicInput
        value={this.context.myForm.values[this.props.name]}
        onChange={(value) => this.context.myForm.onChange(this.props.name, value)}
      />
    );
  }
}
```

> Do you consider passing values into an input element part of "all the React [event] stuff"?

Not sure what you mean.

> I would happily bypass React's event system entirely, but I have been unable to do that without working around the ways in which React's components are tied to it's event system.

Why do you want that? It sounds like you're going against the intentions of React just to go your own way, what benefits do you see versus just using React as it was designed/intended?

I'm wondering what your intentions are, it kind of sounds like your building your own UI framework on-top of the React UI framework, rather than using React as it was intended.
 > I would happily bypass React's event system entirely, but I have been unable to do that without working around the ways in which React's components are tied to it's event system.

The only way (that I can think of right now) that DOM components are tied to the event system is in value/checked handling. If you use defaultValue/defaultChecked then React won't do anything special.
  @tako-black You've been on a roll lately :).  Nice work!
  We're moving all the requires around for 0.14. I don't recall what we landed on for this. (@zpao if you're there?)
 React.addons is currently correct (typically `React = require(react/addons)` when using addons, this should be in the addons docs already)

See #4185 for the new packages for npm (though those aren't set in stone yet)
  Unless I'm miss-understanding something, this is a javascript question not a React one.  Also, general usage questions are better located on StackOverflow, as we use github issues to track bugs in React.

Have you tried something like:

``` js
class Test {
   handleChange(type, event) {
      console.log(event);
   }
   render() {
      return (
         <div>
             <input onChange={this.handleChange.bind(this, 'title')}/>
         </div>
      )
   }
} 
```

I'm going to close this issue, since it's not a bug in React.  Feel free to continue the discussion here or on StackOverflow.
  This behavior is correct. If you want to find one of your children's DOM nodes, you have to add a ref first (using React.cloneElement) and then use that ref. (An element is little more than the `type` and `props` of what you want to render; it doesn't have identity and doesn't correspond to a DOM node directly.)
 (The next commend in the thread you linked contradicts that. We do guarantee that children have their componentDidMount/DidUpdate called before the parent gets it.)
 @miguel-guedes @VinSpee @miguel-guedes: Look at the solution @MadLittleMods provided, his solution is correct.

> SomethingThatWillFindStuff cannot simply clone `<div ref="iShouldBeFine">find me</div>` as `<div ref="parentDiv">`'s props are obviously immutable.

Immutable props does not prevent cloning.

> It may not be possible or feasible to add refs to children nodes, in which case how does one query a DOM node downstream from a .props.children reference?

If you use callback refs, it's always feasible, because you can have the new callback ref also call the previous callback ref, making it completely transparent.  Or you can have whomever does have the ref pass down a reference to the actual dom node.  Or you can call `ReactDOM.findDOMNode(this)` and walk the DOM.  The recommended solution is to attach a ref.

Having said all that... Usage questions are better answered on sites like StackOverflow, as we try to use github issues for tracking bugs in the React core. We generally do not answer usage questions on github.
  Yes, just put a new key on the container and React will render that subtree from scratch.
  Thanks!
  Unfortunately, this just works around the problem. For #4019 at least, we definitely do want the component to rerender, we (probably) just want to skip the selection preservation behavior. The fix for these will probably be nontrivial, but I'm going to close this PR out as it isn't the right fix.
  Thanks @tako-black!
  Thanks!
  @zpao is out of town.  I suspect that @mathieumg is correct and this does not do what we want, but @spicyj understands our build/packaging so we'll let him weigh in.
 Yea this is fine. `coverify` is the only one that looks like it has any risk (but not sure if we actually even run the coverage builds right now), the rest are close enough.
 @zpao I noticed you accepted but didn't merge.  Is this blocking on anything?
 Nope! Merged now
  lgtm, cc @spicyj 
 This should be added to htmlpropertyconfig, not here. @jimfb can you follow up with the details and confirm the testing is done right (look at other PRs for my comments about testing property vs attribute)
 Thanks @zpao, I hadn't gotten a chance to look.
 No, it's fine to just add it to the list of supported properties and not add a unit test, but you should test manually:

Are you able to make a local build and test that this property works correctly? It's important that both the initial render and updating the property work as those exercise different codepaths.
 It looks like this field can be either a property or an attribute (eg. https://msdn.microsoft.com/en-us/library/ms535152(v=vs.85).aspx), so should we be using `MUST_USE_ATTRIBUTE` or `null` here or does it not matter @spicyj ?
 If both work for updates, `null` is best.
 @jas14 Let's use `null` unless there is a browser that requires it to be an attribute.  Also, we need to rebase due to merge conflict.  Otherwise, looks good to go.
 Cool. Can you squash these to a single commit? Then we can merge.
 Thanks!
  Can't they use Object.assign to pull in the other mixin into their mixin, and subsequently do anything they want?  Specifically, you can override `_setStateFromFlux` and have the new function call the old one (you could even make a helper function to do this automatically).

We're drifting away from mixins anyway, so I'm going to close this issue, because I don't think we're making further changes to mixins.
  I can't repro at http://react.jsbin.com/sinehasako/edit?js,output on iOS 8.3. Can you repro on that page?
 Not sure. This case doesn't need any polyfill though. Plain JS:

http://react.jsbin.com/fasohojiwo/1/edit?js,output
 You should be requiring babel/polyfill I think? https://babeljs.io/docs/usage/polyfill/ Are you requiring it before both immutable and react? That might be necessary.
 babel/register is used in Node applications:

https://babeljs.io/docs/setup/#babel_register

Those docs mean that you don't need to also require the polyfill in that case. babel/register is not the correct thing to require in a browser environment though.
 Immutable and React both fall back to the `@@iterator` property if Symbol.iterator doesn't exist in the environment.
 (Closing since this doesn't sound like a React issue.)
  @liondancer Did @nopantsmonkey's comment resolve your issue?

As a side point: In the future, questions like this are better asked on StackOverflow, since Github issues are intended to track bugs in the React core, rather than usage questions.
  As per https://github.com/facebook/react/issues/2410#issuecomment-115659185: findDOMNode(this) throws for unmounted components, but the error message is too cryptic:

`Uncaught Error: Invariant Violation: Component (with keys: getDOMNode,_handleChange,props,context,state,refs,_reactInternalInstance) contains render method but is not mounted in the DOM`

Some expert React users honestly thought they had duplicate React or something, so didn't even bother to check whether the component was mounted. (It wasn't.)
 @percyhanna Are you saying that you‚Äôve had this error in 0.14.x despite a wording change in #4727? Can you provide a failing test? Thanks.
 > This was on an app that hasn't gotten around to upgrading past 0.13.x yet.

Got it, thanks. I was just worried we missed some case when adding a warning.
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Seems reasonable to me.  I think it does make sense to add an example that demonstrates a click/event handler, since it's a very reasonable thing for someone to want to know how to do.  Rather than creating elements manually, we should probably use jsx, since it's more idiomatic.  And we should squash the commits into a single commit.  cc @spicyj.

On a side note: Can you sign the CLA so we're allowed to merge?  You know, lawyers :/
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 Looks good, thanks @DarkScorpion!
  Just sharing. Can look at incorporating this into our build pipeline if we want to. Produces files that look like https://gist.github.com/spicyj/19df83d04eaad215b92b.

```
$ node pack-flat.js >react-flat.js
$ cat react-flat.js | ./node_modules/.bin/uglifyjs -c -m >react-flat.min.js
```

Curiously, it's bigger after gzipping than the other way:

```
$ wc -c react-flat.js react-flat.min.js build/react.js build/react.min.js
  662769 react-flat.js
  121416 react-flat.min.js
  601727 build/react.js
  124097 build/react.min.js
 1510009 total
$ gzip <react-flat.min.js | wc -c
   38355
$ gzip <build/react.min.js | wc -c
   36602
```

Initial startup execution cost looks to be about 14% less though.
 cc @sebmarkbage 

cc @sebmck ‚Äì In case you're interested. I have a transformer here to prefix all top-level variables and extract/rewrite requires. Maybe you have a better suggestion for how to provide arguments to a transformer (`currentModule`) and how to get some sort of result out (`required`)?
 Maybe it is because the minifier has to use longer identifiers to make them globally unique?
 Updated it to eliminate variables from requires completely, so

```
// foo.js
var invariant = require('invariant');
invariant(bar);
```

becomes

```
invariant(foo$$bar);
```

instead of

```
var foo$$invariant = invariant;
foo$$invariant(foo$$bar);
```

Now gzip is better:

```
$ gzip <react-flat2.min.js | wc -c
   36090
$ gzip <build/react.min.js | wc -c
   36602
```

I also remeasured the perf and it takes now 22% less time overall to execute the minified bundle (previously 14%)! Guess those variables aren't free.
 Well this is a giant function so I would expect V8 to completely ignore optimizing it which is fine since it is executed once. It's probably just interpreted as part of interpretation they probably keep the variables around in case they get accessed later, since they probably don't know if they will be.

Uglify should've stripped them though. Have your tried Closure's simple mode?
 My last test was actually jsc but just tested in node and got 33% improvement (30% before my last change).

Uglify doesn't, unless I'm just missing a switch:

```
$ echo '(function() { var foo = 2; var bar = foo; alert(bar); })()' | ./node_modules/.bin/uglifyjs -m -c
!function(){var a=2,n=a;alert(n)}();
```

but Closure simple does give

```
(function(){alert(2)})();
```

on the same input. Let me see if that changes things‚Ä¶
 Running through Closure simple mode (where I manually readded a `"use strict"` since it doesn't want to keep it) brings us to 31% better in jsc, 40% better in node.

```
$ gzip <react-flat2.cc.js | wc -c
   32299
```
 Neat. The real power comes from the more powerful dead code elimination, we've yet to taken advantage of, and advanced mode.

Now all we have to figure out is where we'll draw the line of which modules to include (e.g. fbjs etc.) and how we're going to use this internally were we override some modules.
 @bloodyowl A long, long time ago: https://github.com/facebook/react/pull/1937. We made other improvements to the browserify build since though to make them more comparable. This change here is still significant. 
 cc @amasad -- you may be interested in the gains we saw here. To summarize, we ended up with 31% better in jsc, 40% better in node for initial startup and 12% smaller bundle after min+gzip. I imagine the runtime gains might be higher for a bundle with more modules than React has.
 Closing in favor of #6351. Let‚Äôs discuss this further in there!
  Thanks!
  I think @zpao or @spicyj are the ultimate authority here.  That said, I personally don't see a problem with adding some sort of namespacing, though I'm not sure I really see the need (for reason below) and also I don't think the stuff in vendor is React public API, is it?  Isn't it questionable to be using it for application code?

More importantly, your solution is not a general one.  What if you have two video players loaded on the same page?  You need a way to differentiate not only between the TYPE of the event, but also which instance of the player.  Therefore, it's probably better for your video player to have a unique internal key to identify the player, and include that key in your events, such that the event is always uniquely tied to the player that is being controlled.  We still need to figure out a viable solution for SSR (https://github.com/facebook/react/issues/4000) but if you're just using React client side, a UUID is on the component instance probably what you're looking for.
 Yeah, we don't support any modules except the main React module and the addons.

Feel free to make a fork (or rewrite) of keyMirror and publish it independently, like https://github.com/JedWatson/classnames was relative to `cx`.
  @blainekasten is correct, remodal is likely modifying the dom.  The problem is that React uses change tracking to optimize writes to the DOM, and if you change things from under React's feet, things break :/.

Our recommendation is that you avoid touching anything rendered by React; there shouldn't be a need to do so anyway (the whole point of React is that your render function is declarative and thus easier to reason about - if you start mutating things, you are back in the imperative world, so why use React at all?).

@ciaoben: Registering it as a callback as you suggested may have hidden/delayed the error, but you still would probably have received the same error later in your app development cycle (ie. next time React needed to reconcile changes to that component).  Therefore, an app that does the dom manipulation as a callback is equally 'broken'.

Since this is not a bug in React, I'm going to close this issue.  Feel free to continue to have the discussion here.  For future reference: Questions about how to properly use React are probably better located on StackOverflow, since we use github issues to track bugs in React.
 @ciaoben The point of using React is that you should not be modifying the DOM, so the 'correct' solution is to not use `remodal`.  Instead, you should define your UI declaratively such that no DOM manipulations are needed.

If you're trying to popup a modal, I would recommend watching Ryan Florence's talk (http://conf.reactjs.com/schedule.html#hype) and playing with the portals demo located in `demos/03-portals` of https://github.com/ryanflorence/reactconf-2015-HYPE
  Yep, looks legit to me, https://developer.mozilla.org/en-US/docs/Web/HTML/Element/textarea

I look forward to the day when #140 is resolved and we don't have to deal with this wackamole anymore :P.
 Yes, thanks for the reminder
  @spicyj I don't have any strong objections, but I wonder if mentioning jspm adds value for our users.  I hear about browserify and webpack all the time, but I don't really hear much about jspm.  There is no wikipedia page for jspm, and while that's not an required metric, it's a pretty low bar to meet and an indication that they don't have critical mass.  Lots of research (both at Facebook and elsewhere) has shown that people who are trying to connect with a new site/person/tool/whatever (like React) are attracted when they see familiarity and are turned away by things/terms that they don't recognize.  You're far more familiar with the js community at large, so I'll let it be your call, but my inclination is that mentioning the top two frameworks (browserify and webpack) is sufficient.
 Agree. @capaj Happy to revisit if JSPM becomes more popular. 
  It's been a few months and none of us were here to tell you that this seems like something best suited for Stack Overflow. Hopefully you got it all worked out. Sorry!
  This fixes a bug where children of a component won't get context updates.
 Ok, I think this diff is ready to merge, pending @sebmarkbage.

It solves @ryanflorence's demo, so this should unblock him.

I ended up taking out the check in ReactReconciler and adding a todo item because that code is behaving in a very unexpected way, and I think there may be another bug in the reconciler (which is out of scope of this diff).  Since this diff accomplishes what it intended to do (fix https://github.com/facebook/react/issues/4218), it can be merged independently.  We should investigate the reconciler soon though.
 Merging this for the 0.14 beta, because Ryan will want/need it to be merged for his stuff at the conference and @spicyj needs to cut a beta in a couple hours.  We still want to figure out the reconciler bug and add the unit test provided by @andreypopp , but as I mentioned before, that can be a separate diff since it will requires further investigation.  Sorry for making this a post-commit review, but I think everyone has seen it already.  Would be great if someone (@spicyj?) can do a final pass on this diff (hopefully formally accept it) and let me know if they'd like any additional changes made/merged to this diff, I'm happy to post an update.
  See https://twitter.com/ryanflorence/status/613905590176186368

And the following thread.

Quick fix?
 Dupe of #4218. ;)
  I think #4344 fixes that (happened after beta3) but it would be good to double-check.
  I think the server doesn't actually need to be changed. Can we move this script into the main script section (either still as the current `TEST_TYPE=test` or maybe with a new `TEST_TYPE=build`) with `set -e` like build_website has so that we fail the build next time this happens?
 Looks pretty good. What do you think about combining it into the existing if statement?

```
elif [ "$TEST_TYPE" = build ]; then
  if ["$SERVER"]; then
    ...
  fi
else
```

Right now it runs grunt build twice (which isn't the end of the world, just a little clowny).
 Looks good, will merge if Travis passes. Thanks!
 curl: (26) couldn't open file "build/packages/react-codemod.tgz"
 I'll just drop that one.
  Hmm... console.trace is non-standard.  We use console.error for warnings, so you can just expand the message to see the trace (in chrome and firefox at least).

Are you using an environment that doesn't let you expand error traces?
 Chrome allows you to break on caught errors. That's why that try/catch is there. So that you can optionally toggle the breakpoint on and off.

@jimfb In 0.13 we used console.warn which doesn't have a stack associated with it anymore.

@abritinthebay In master (and the upcoming 0.14) release we've switched to using console.error that has a stack associated it with. https://github.com/facebook/react/blob/master/src/shared/vendor/core/warning.js#L42
 Follow the checkboxes: https://github.com/facebook/react/issues/3220 :)
  That code looks fine. Can you post a simple jsbin that reproduces the problem?
  For 0.14 we'd like a feature that allows us to forward refs or define what the public instance of a component should be. That way we can make higher order components that are completely transparent.
 @sebmarkbage I told @cpojer this probably wouldn't be hard to implement if we can agree on the semantics. Does findDOMNode (etc) work on the ref you get if you implement getPublicInstance? If not, this might be really easy.
 Rant: Yea I've been thinking about this. This feature smells really wrong to me, since the whole point of moving refs off props was to make them an outside-concept that the framework controlled. It seems like if you want to control it, we should just make them props. That way you have the ability to fully control them and the timing. However, you don't always want to have to resolve them yourself. Also, you don't want to accidentally transfer a ref by using the property spread. Although if refs finally become less common, they should probably become manually invoked functions. So I'm torn.

Non-rant: I'm not sure the `getPublicInstance` API is going to be sufficient for other use cases. It doesn't provide the capability to refire.

``` js
class Container {
  state = { toggle: false };
  tick = () => {
    this.setState({ toggle: !this.state.toggle });
  }
  componentDidMount() {
    setInterval(this.tick, 100);
  }
  render() {
    return <div>{this.state.toggle ? this.props.children : <Pause />}</div>;
  }
}

class Wrapper {
  getPublicInstance() {
    return this.refs.myComponent;
  }
  render() {
    return <Container><Component ref="myComponent" /></Container>;
  }
}
```

In this example, there is nothing that binds the unmount/remount scenario to the Wrapper. We can't recall getPublicInstance to get the fresh component. We will keep having a stale version.

Something like this might be better:

``` js
class Wrapper {
  render() {
    return <Container><Component ref={this.ref} /></Container>;
  }
}
```

However, how do we know that a ref was transferred? Maybe if the function fires before this component's didMount, but that is very subtle and breaks down for the case above where it doesn't fire until later.

Maybe we add something like `getControlledRef` but that's an extra API and would be an side-effectful which is not ideal.

Suggestions?
 Personally, I'm a fan of refs becoming manually invoked functions, and so that probably influences my thinking/solution...

Make component manually invoke the ref, wrappers can forward the ref.  For now, call it `myref` to avoid the autoinvoking that React does.  Then the wrapper becomes:

``` js
class Wrapper {
  render() {
    return <Container><Component myref={this.props.myref} /></Container>;
  }
}
```

It's not "completely transparent", since the base component must expose a manually invoked ref instead of relying on the one provided automatically by React, but assuming you're in control of the base component, this works, right?  Or maybe I'm totally miss-understanding the request :P.
 The request is to provide a seamless API that is natural to use with React so that HoC can be unobservable.
 If we care about it being unobservable: Could we have a flag on the class that says "I'm a high level component, don't resolve my ref, I'll manually invoke it and/or pass it to someone else"?  That would make the high level components completely transparent and also enable a clean migration path for making all refs manually invoked (if we decide to do that someday; migration path is that every component that takes in a ref must have that flag set).

So the new code looks like:

``` js
class Wrapper {
  render() {
    return <Container><Component ref={this.props.ref} /></Container>;
  }
}
Wrapper.manualRefs = true;
```
 We already use static flags for things like context types etc. We might want to use flag to indicate that a component's state is pure too. That seems natural. Could potentially work for stateless functions too.

However, that brings up an interesting point. Should stateless functions automatically transfer the ref since they don't have instances?
 My vote would be to have refs be illegal on stateless functions, since there is no component for them to reference.  That allows us to punt on the decision until a future date.  It also gives us a reasonable opportunity to warn if someone tries to attach a ref to a stateless function (since, in all likelihood, the implementor of the stateless function will have forgotten to properly forward/handle the ref, which will lead to user confusion unless we can reject at the time the ref is attached thereby sidestepping the issue).

Making refs illegal on stateless functions won't result in lost functionality, since a user can always regain any potentially lost functionality by wrapping the stateless function in a HOC, thereby regaining the functionality including the ability to attach a ref and use findDOMNode.
 > My vote would be to have refs be illegal on stateless functions, since there is no component for them to reference.

Seems like a rather arbitrary restriction to me. findDOMNode is as useful on a stateless function as it is on any other component. (I'm fine with introducing a way to restrict use of findDOMNode but this seems unrelated.)
 The use case for stateless functions is basically to A) provide syntax sugar for another component and/or  B) lock down the API by excluding configuration of some props.

For A it would be a nice convenience to forward the ref, but for B it would be detrimental to locking down the API. So I don't know. In cases like that I tend to error on the side of the easiest to change from, which is the more restrictive form - i.e. making refs not work and possibly warn on these.
 :+1:  Sounds like we've got a game plan here.
 ...or just use a class for your HoC.
 Ah, yes. That's the same problem that @yungsters has.

What methods are you expecting to forward on that ref? If you use a heuristic such as scanning the `prototype`, then if there is nothing on the prototype then you don't need to attach a ref because you don't have any methods to wrap.
 Oh I see, I didn't read properly. You use `getWrappedInstance()` instead of seamlessly exposing the methods like Relay does. In that case, it's not a seamless HoC anyway.
 Relay doesn't forward instance methods in open source. We did this internally so the mixin -> container codemod would be safe. We didn't want to support this pattern externally however and we are hoping for a resolution to this issue inside of React.
  It's recommended against _in most cases_. Here the tutorial explicitly shows that marked is used in a way that sanitizes the input, so react's own sanitation isn't needed.

This is a case where `dangerouslySetInnerHTML` is actually  the correct choice, and the tutorial tries to explain that. If it didn't use it, there's be no way to preserve the formatting generated in marked.
 The code is "recommended against" mainly because it explicitly bypasses security features (xss protection) provided by React.  The tutorial also explicitly calls out these security ramifications.  It's an escape hatch of sorts.  The point isn't that you should never use it (if the feature were inherently bad, we would remove it), the point is that you should be very careful and the decision to use `dangerouslySetInnerHTML` should be a conscious one.  Mentioning this feature in the tutorial isn't a bad thing, especially since people upgrading their legacy codebases (ie. people new to React) are the most likely to need this feature in order to interoperate with their existing codebase.

I'm going to go ahead and close this issue, because I think this was a conscious decision and not a bug.  Feel free to continue the discussion here, and if the community decides that hiding this feature is a good idea, we can re-open the issue to burry the feature deeper in the documentation :).
 Ah, so you're saying the "safe taint" should be moved up out of the jsx tag.  Yeah, I could get behind that :).
 While we're fixing it, might as well do it correctly on the homepage too.
  Your approach seems reasonable to me, but I defer to @spicyj and others for a more authoritative answer.

In general, when perf starts becoming an issue, we recommend switching to immutable datastructures and using `shouldComponentUpdate` to avoid unnecessary rerenders.  If that isn't enough and you're trying to super-optimize a particular component, and you're able to track "changes" to your data, you can cache the ReactElements and perform imperative mutations to keep your ReactElements synchronized with your data (obviously this defeats the main advantages of using React, so it's not the recommended solution except in cases where you need to squeeze every last ounce of performance out of a component).

In the future, this type of question is probably better suited for a place like StackOverflow, as we use github issues for tracking bugs in React.  Since this is not a bug in React, I'm going to close this issue for tracking purposes, but feel free to continue the discussion here.
  This is browser behavior and it seems entirely correct to me. The button receives the mouse down event but since the element moves immediately after then mouse up happens outside and no click is registered. Do the same thing but move your cursor back over the button first and then release, now you get the click as expected.
 Confirmed, it looks like the issue is that you're not getting a click as a result of the button moving.  If you put the error output under the button (such that it won't affect the positioning of the button), everything behaves as expected (so it's not an issue related to mutating state, it's an issue related to you moving things in the dom).  Also, all the things @syranide pointed out.  I'm going to close this as "not a react issue".
  lgtm, cc @spicyj 
 ping @spicyj 
 Looks good to me, @spicyj's comments have been addressed, no complaints from anyone in almost two weeks, so let's ship it.
  Looks good, thanks @battaile!
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 Sure, thanks!
  Looks good, thanks @yiminghe!
  Pretty sure this is a bug that's been fixed on master. Works fine if I pull in the latest:

http://jsbin.com/rokazegofe/1/edit?html,js,output
 @davidreher The 0.14 beta (already released, but in beta) should have this fix.  We're working on getting 0.14 ready for a final release; follow the checkmarks: https://github.com/facebook/react/issues/3220
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Great, thanks @dpercy, looks good to me!
 Can you accept the CLA so we can merge this in?  You know - lawyers :/.
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 Thanks!
  What is `other` in your code?
 cloneElement's params beyond the props arg specifies children, much like createElement (unlike Object.assign/_.extend). Sounds like you probably want

```
React.cloneElement(child, { style:style, ...other })
```

instead.
 Er, make that something like

```
_.extend({ style:style }, other)
```

since you probably don't have that ES7 experimental transform.
 The former.
 Or maybe something like

```
child = React.cloneElement(child, {style: style});
child = React.cloneElement(child, other);
```

if you'd prefer. Up to you.
 Seems I'm not understanding you properly, sorry. Can you make a small example in react.jsbin.com that shows the problem?
 Here, `other` contained all of the props of the parent component (except `layout` and `style`), so it looked something like

```
var other = {
  children: <Tabs />, // <-- this is the exact component that you're cloning!
};
```

so you ended up making a copy of `<Tabs />` that set its children to `other.children`, which happened in this case to be the `<Tabs />` element itself, giving you `<Tabs><Tabs /></Tabs>`. This is working as intended. If you don't want to transfer a specific prop, then take it out like you did.

(cloneWithProps wouldn't transfer children as a special case, which was surprising in many cases and one of the reasons we're deprecating it ‚Äì cloneElement treats all props identically.)
  Great, Thanks @tako-black!  I will cherry-pick this over to the stable branch shortly, after which it should appear online.
  Why would we remove this? The dev tools aren't deprecated.
 Devtools are struggling but not deprecated.  Maybe you were thinking of buildtools or reacttools?  Also, a replacement for devtools is on the way, so we'll probably just update the fburl or update the plugin on the chrome store, so no change to the React code should be necessary for this.

@battaile If you're looking to get involved: https://github.com/facebook/react/issues?q=is%3Aopen+is%3Aissue+label%3A%22good+first+bug%22
 @iamdustan Just a brief mention in our meeting notes for now: https://discuss.reactjs.org/t/meeting-notes-2015-06-19/697?u=spicyj. Probably @jaredly will put up a pull request to the devtools repo in the next few weeks and then you can try it out.
  See #2912. Happy to reopen if a simple case shows React is doing something wrong.
  Hi @gyzerok,

Thanks for the pull request, and welcome to the community!

Unfortunately, we probably don't want to merge in this pull request, primarily because we are trying to keep the top-level API clean/simple, and the function that this PR adds is simple enough for users to just implement themselves as needed (as per the gist you linked).

If you are looking for ways to get involved, I would suggest checking out one of the issues on this list:
https://github.com/facebook/react/issues?q=is%3Aopen+is%3Aissue+label%3A%22good+first+bug%22

I'm going to close this PR, for the reason above.  But we look forward to having you get involved in React development!
  `context` can also be important for getting the initial state (for instance with side-loading architectures like Flux), which leads right back to the constructor's signature. I don't see much of a difference whether you do `this.state = { ... }` vs. having the base component call `this.state = MyComponent.getInitialState(props, context)`. You can always implement the static method yourself though.
 I'm going to have to quote Allen Wirfs-Brock here:

> `this` is an OO concept. FP people, `this` is not for you; don't use it, don't try to "fix it".
> https://esdiscuss.org/topic/named-this-and-this-destructuring#content-3

OO is already broken. Don't try to fix it to be more functional. The current design is there to be natural for someone familiar with building an object-oriented class, using their own JS class system, or something like TypeScript. There are also type inference benefits to doing that since the type of `this.state` can be immediately inferred.

However, React is at its core a FP library so we will definitely add a more functional alternative API that doesn't use instances nor `this` at all.

See this draft for example:

https://github.com/reactjs/react-future/blob/master/07%20-%20Returning%20State/03%20-%20Default%20Props%20and%20Initial%20State.js#L30

I'm not sure it makes sense to combine the two worlds into one. IMO its clearer if you use one style or the other rather than trying to combine them.
 No discussion for six months, and I don't see anything actionable here, so I'm going to close this out.
  Looks good to me.

Just musing here: I wonder if we want to warn when the user instantiates the instance, instead of (or in addition to) when they unmount.  The reason being that users may not test unmounting behavior while writing the component (though, if they wrote that function, they really should test it and not rely on 'correct-by-careful-inspection').  If we print the error on mount, they will see it sooner and are therefore less likely to miss it.  The counterargument is that this displays the error at a more timely location.  I could go either way on this one, so I'm mostly commenting in case @spicyj or @zpao feel strongly and want to jump in.
 This is an never ending battle. IMO we shouldn't have accepted #4045 and the like. We decided against `PropTypes` and `mixin` are a few more. We can't just keep adding these ad-hoc. What's the proper solution here? A better type system? An automatic spellchecker?

We need to at the very least break this code out of composite component.
 It would be better if this kind of validation was done statically outside of React instead of at runtime. For instance, with Flow.
 @sebmarkbage 

> This is an never ending battle.

True.  But we can catch the ones that meet some minimum threshold of frequency.  For instance, 100 or 1000 results in Google.  The threshold is arguably debatable, but doing what we can to help engineers avoid sufficiently common mistakes is something we should do.

I actually think I'm in favor of this particular one primarily because otherwise it fails silently (which seems like our fault, since we provide a default implementation instead of throwing if we don't find theirs).  For proptypes, the debug path is to open the component and print the props to see how they differ from what the component is expecting.  For a lifecycle hook not firing, it's much harder to understand _why_ it isn't firing (short of opening up the React framework source code), and for this reason a warning seems justifiable.  It's even worse for the lifecycle hook, because if you're assuming `componentDidUnmount` exists, you're not going to disabuse yourself of that notion just by looking at your code (at least with a typo, you've got a snowball's chance of noticing the missing character).

Anyway, that's my two cents.  I don't feel particularly strongly either way.
 Yea, this is probably the most reasonable one to add. I'm just frustrated that we don't have a more permanent solution for catching typos. We're close to being able to that for propTypes but our current class API doesn't allow for that in a systematic way.

Maybe we can add something like a componentX namespace where everything that starts with "component" is assumed to be a React life-cycle, but what about all those cool extensions that reuse that namespace?
  If it's not a standard we're not going to polyfill it for you.
  why? there is no such method in documentation. 
  Instead of checking `el.type === Foo.type`, check `el.type === Foo`. For isElementOfType, pass `Foo` not `Foo.type`. Let me know if that doesn't make sense.
 Just 'thead' not React.DOM.thead.
 Glad you figured it out.
  Just throwing this out there, since I'm not sure where everyone stands on this issue:  Do we want to be maintaining Object.create and Object.freeze ourselves (increasing codebase size, introducing the possibility of errors); I assume that was the reason we didn't implement it ourselves initially (as we did for Object.assign).  Also, I think we're probably getting close to the point of sunsetting support for any browser that doesn't support this functionality natively, right?  So why add it this late in the lifecycle?

Having said that, if the sham is causing problems for people and the fix is easy, might as well include it, right?

I don't have a strong preference either way, just curious what @spicyj @zpao think.
 > Also, I think we're probably getting close to the point of sunsetting support for any browser that doesn't support this functionality natively, right?

To confirm, `Object.create` and `Object.freeze` [seem to be pretty much everywhere, except IE8](http://kangax.github.io/compat-table/es5/).
 Freeze here seems reasonable-ish but if we want to avoid the create sham I'd just inline the minimal logic like in https://github.com/facebook/react/pull/139.

Not my fight though. :) @sebmarkbage or @zpao can care.
 +1 for @spicyj's solution.  Could lnline both `create` and `freeze` if we want to avoid the sham; it sounds like there aren't many of them.  Seems like a good way to minimize the surface we're maintaining, which was the intent of my prior comment/question.

Also, as mentioned before:

> I don't have a strong preference either way
 Hey I wanted to make Object.assign a required sham. :)

If every library does this then we end up shipping an accumulation of unnecessary polyfills. Very few users of React even need these polyfills because they're not supporting old environments.

Even if they do, they use polyfills anyway for other purposes.

Sure, some libraries respond poorly to polyfills but that doesn't make polyfills inherently bad. 

If we go down this route we should use the transpiler model. That way it becomes an optional build process problem. Out of sight - out of mind. That can also be applied to the code base as a whole and integrated into build systems that target different browsers with different packages.

Btw, it is likely that within a year or so, React might stop actively supporting some of these environments like IE8. Not sure but if we have significant need for newer features it might be necessary. That's not on the plans yet but it makes these changes less valuable. The question around ES6 features like Object.assign still stands though.
 If you're supporting IE8, you can use a sham that overrides the native `Object.create` and warns or throws if you use unsupported arguments. That prevents developers from relying on behavior that doesn't work cross-browser. This is the job of the transpilers and polyfills to ensure that you have a uniform environment to work from.

> Currently a developer can carelessly write Object.create(proto, {foo: {get: function() { return 'bar'; }}); in React code. This will run fine on their machine.

This will run fine on their machine even with your proposed solution, since they will have access to the native `Object.create`. Fixing it in React Core doesn't solve the problem for consumers of React. I would argue that if you want to protect against such mistakes, you need to look towards a better polyfilling environment that can provide a consistent debugging experience. (E.g. by forbidding non-polyfillable APIs in all environments.)

> Alternatively, in place of Object.create we could use lodash's .create which implements the behaviour that React requires.

This is exactly the problem. If we never adopt better polyfilling strategies, we'll end up having to fallback to community library code like lodash. If we can't use Object.create today, six years after standardization, then we will never be able to have nice things.

I explained why that's a problem in my JSConf.eu talk about this subject:

http://2014.jsconf.eu/speakers/sebastian-markbage-minimal-api-surface-area-learning-patterns-instead-of-frameworks.html

The transpiler strategy is great because it can be used by you as a consumer instead of as part of React's build-process. It maximizes the configurability of optional localized polyfills.
 Wow, I never thought this would spark such a debate :/  I think everyone has made some great points.

> If we can't use Object.create today, six years after standardization, then we will never be able to have nice things.

#GreatestQuotes.  I really need to start a collection of @sebmarkbage's best quotes :).  I agree, btw, fwiw.

> So, browserify transform that modifies Object.create and Object.freeze invocations? Or is babel the proper place... tricky to say for this instance.

Probably Babel.  It is my understanding that Browserify is more about interaction with NPM whereas Babel is more about language compatibility.  This seems like a language compatibility feature.

> In react's repo or as a new npm module?

New npm module.

> What do we do when Object.create(proto, {...}) is used (ie: property definitions that can't be simply be pollyfilled)? Silently skip? Error out? Make the transform user pick?

Probably warn, but ultimately up to the implementor of the transform.

## 

But we digress.  I think the question at hand is: What, if anything, do we want to do about removing the dependency on es5-sham?  It sounds like @sebmarkbage is in favor of not re-implementing the polyfill, I find myself leaning in the same direction, so I'm going to mark this PR as needing revision.  Implementing this as a transform seems ideal to me, but I'd be perfectly happy if we just manually inlined all the calls to `freeze`/`create`.
 I thought @sebmarkbage says you should use a transform in your app code, that it shouldn't be in the React repo at all.
 Ok so I'm mostly fighting a battle of principals here. However, I have a pragmatic side as well. If we can get a way from using the shams without compromising these principals too much that's a win-win.

If we apply the same logic to ES6 classes, we should be writing using them and then have the transpiler runtime deal with it for us. So, we should just use ES6 classes instead of Object.create, no?

As for Object.freeze, that's a DEV only feature that we use to enforce a set of warnings in one place, and that we're expecting to move/copy into the Babel runtime anyway. I wouldn't be opposed to just conditionally check it in that one callsite. `if (Object.freeze) { ... }`
 Haha, I think we've reached a consensus here.  :)
 We've been talking about best practices for transpiled code and npm. I think we're starting to land at that npm packages should include both the lowest common denominator and the original source. That way it can "just work" for all tools, and then you can get an enhanced experience when tools are aware of additional information. For example, we could leave Object.assign and ES6 classes as original source for build-systems that can handle them, and transpile them in the lowest common denominator bundle.

I guess that means that our current bundle is considered lowest common denominator, and Object.assign should be transpiled/auto-polyfilled.
 @dantman For Object.freeze I'm fine with just having it be conditional `if (Object.freeze) { Object.freeze(this); Object.freeze(this.props); }` in the code base. No need to transpile it. Although for other projects it might be useful.

Likewise, we're already using Babel to transpile our source so we should just use the `class` syntax since that is what we're trying to do there. We don't need a `Object.create` polyfill. If the resulting code ends up bloated, we can fix it in Babel and everyone benefits. 

For example, Babel can track rudimentary type information so if it can easily prove that a value is non-null, it can avoid the check in the transpiled code. @sebmck is very responsive to that kind of challenges.
 > If you're supporting IE8, you can use a sham that overrides the native  Object.create  and warns or throws if you use unsupported arguments. That prevents developers from relying on behavior that doesn't work cross-browser. This is the job of the transpilers and polyfills to ensure that you have a uniform environment to work from.

I know the discussion is already past this, but isn't that exactly the problem? To illustrate, by that argument it would kind of make sense to implement `Object.freeze` and have it throw because it's not supported. But no library in existence feature detects `Object.freeze` by try/catch because that behavior is not defined by the standard, they test `if (Object.freeze) {`, crash.

So it's more that shams is a flawed concept, you deviate from the standard and polyfill the environment with non-standard/partial implementations. For you as a developer it works out really rather well, but as a consumer of various libraries that rely on standard behavior it's a nightmare.
 @syranide If you're calling into a sham that can't be polyfilled, you can wrap the invocation in a try-catch, so the exception will be non-fatal.  You are effectively handling the case where the operation is not supported by that browser.  It's a pretty reasonable case for developers to handle, since they know they are invoking features that are not well supported by their target browsers.
 > If you're calling into a sham that can't be polyfilled, you can wrap the invocation in a try-catch, so the exception will be non-fatal. You are effectively handling the case where the operation is not supported by that browser. It's a pretty reasonable case for developers to handle, since they know they are invoking features that are not well supported by their target browsers.

@jimfb Not arguing that it can't be tested for by try/catch, the reality is that it often isn't (for whatever reason).
 The only way that will change is if people use shims more often :).

But yeah, I think we're all in agreement that shims/shams suck and the best solution is to use a compiler/transpiler that generates code for your target browsers.
 @jimfb I don't mind shims. As far as I've been able to understand it "transpiling shims" doesn't really work super well. It works great for your own code, but you end up polyfilling the environment too because there are other libraries out there aren't transpiled along with the rest of your code.

So to me shims seem just fine, but not all shams, people have different expectations when it comes to shams and that's where it breaks down.
 If your library relies on defineProperty behavior then it won't work in IE8 anyway.

The issue is that libraries might have the ability to work around the sham if it is not available and therefore they want to feature detect if it does work, then conditionally fallback.

That notion is flawed because now your code will still behave differently, just using one indirection. So effectively to get a safe environment you need to ensure that all your libraries conform to a subset of the language. In which case the sham model works fine.
 > That notion is flawed because now your code will still behave differently, just using one indirection.

No, it will explicitly do what's written in the code, it will not perform some arbitrary fallback behavior that I may or may find acceptable and have to guard against too. To take a silly example, why is it that `Object.freeze` should silently return? Why can't it throw an error if XYZ? Why does React not feature test that and return silently if the provided behavior unacceptable?

> So effectively to get a safe environment you need to ensure that all your libraries conform to a subset of the language. In which case the sham model works fine.

"ensure that all your libraries conform", why it's so obviously fine for React to make non-standard demands on my environment? Why can't React conform to the standard instead?

To me it's really simple; follow the standard then everyone gets the same experience and everyone gets to choose their preferred fallback, it's simple and it works. Don't follow the standard and you're making vague demands on everyone else to elaborately feature test for what is a minor benefit. It would have been fantastic if ECMA provided specs for acceptable partial implementations, but they didn't.
 I guess that we actually agree. Shams should throw if they can't follow the implemented behavior rather than silently failing. E.g. if the sham can't implement the second argument of Object.create, it should throw. Libraries that doesn't depend on that behavior should just avoid passing the second argument.

I agree that silently failing is generally a bad strategy for a sham, however, for perf reasons it might be prohibitively expensive to throw. In those cases, you have a tough choice. You could take the extreme route and say that we should never use those APIs at all and implement it in user space, but you could be talking about an edge case that almost never occurs. We hold up progress in adoption because of it.

My preference is to use a DEV time warning to ensure that this behavior isn't being relied on, but that does not allow the try/catch pattern to be used in production code.

One example is ES6 classes. They require methods to be non-enumerable. Making them non-enumerable is prohibitively slow. Should we not use ES6 classes because of it? No, we definitely should be using them anyway with the loose mode because iterating over them is an edge case. It is up to the polyfilling environment to ensure that you have a good DEV mode experience that warns you if you try to iterate over the properties of a class prototype.

It is not as simple as just follow the standard or don't use it at all.
 As for `Object.freeze`, this doesn't have to throw. You can just avoid adding it. That way it can be ignored. However, I think that this particular case is fine to polyfill as a noop.

You shouldn't be relying on try/catch for code flow. In fact, the spec relies on throwing in places that are expected to NOT throw in the future. So you will break future specs by doing that.

You also shouldn't be using non-strict mode. That's just breaks everything.

So given those assumptions, your `Object.freeze` dependent code will behave the same in your modern environment as a sham:ed environment. This is a special case that mostly only applies to `freeze` but every rule has its exceptions.

Besides, try/catch as a feature detection is a terrible user experience. Map polyfills rely on it to test the constructor, but we've had to disable those polyfills since they cause the "Break on caught exceptions" mode to trigger in Chrome. A few polyfills and that important debug tool is busted.
 @dantman @sebmarkbage To summarize: it sounds like the ideal solution is a transform but we would happily accept inlining the ifexists check for `freeze` and es6 classes instead of `create`, right?
 Closing out in favor of #4189
  Can you post a simple jsbin (or similar) repro?
 Looks like Firefox re-initializes the input completely when you change the type, which makes intuitive sense to me. If you want to maintain the cursor position it's probably best to manage selectionStart/selectionEnd yourself. Maybe one day we'll have a better API to manage this from React (https://github.com/reactjs/react-future/issues/4) but not right now, sorry.

(As a side note, your component isn't actually controlled like you might believe it is ‚Äì starting value as an empty string and handling the change is maybe what you meant to do: http://jsbin.com/bedadoxada/1/edit?js,output. Doesn't affect this issue though.)
 Yes, if you feel that changing type should not move the cursor then opening a Firefox issue sounds reasonable. I'm fairly sure you'll find that the same problem exists without React.

(Personally, I'm not convinced that "preserving cursor position" can even make sense. Sure, text and password look mostly similar, but for other types of inputs there's no cursor to preserve. Or for a date picker you might have multiple cursors for each part of the date.)
  Haha, well, that's unfortunate.  Since a reader of this code might be confused as to what's going on there (why the string is built up that way) and might try to "clean it up" by manually undoing the changes in this commit, can you add a source code comment that describes why it's written this way.  You can just take the description of this PR and put it into a comment:

`// React's build tools are reading the require("react") and react("%s") inside the warning string and thinking they are actual requires.`

Also, cc @spicyj @zpao I feel like the correct fix for this (at least long term) is to fix the parsing in the buildtools, rather than to hack around it.  Do we want to open an issue for that?
 > You can just take the description of this PR and put it into a comment:
> 
> `// React's build tools are reading the require("react") and react("%s") inside the warning string and thinking they are actual requires.`

You probably don't want to do exactly that, as what's to keep the build tools from then parsing that comment?

> Also, cc @spicyj @zpao I feel like the correct fix for this (at least long term) is to fix the parsing in the buildtools, rather than to hack around it. Do we want to open an issue for that?

@jimfb It's probably not easy to fix, since that'd probably require a real parser.
 Ah, you're right, the comment would also have to be well-crafted to avoid the erroneous parsing.  I still feel like a comment might be useful because it's very non-obvious what's going on there.

With regards to it not being easy to fix the buildtools, I agree, that's why I think that we accept this commit  (with a comment) and open an issue for buildtools, instead of outright rejecting this commit.  But it is still a bug in buildtools; we should switch to using Babel at some point; it's just a matter of if/when we want to pay off that particular piece of technical debt.
 Looks good to me!  Thanks @dantman!
 üëçüèº

My pr to using fbjs will make this moot as it won't use commoner (which is
what's naively looking for requires in text, not AST)

On Tuesday, June 23, 2015, Jim notifications@github.com wrote:

> Merged #4190 https://github.com/facebook/react/pull/4190.
> 
> ‚Äî
> Reply to this email directly or view it on GitHub
> https://github.com/facebook/react/pull/4190#event-337195855.
 @zpao Most excellent!  Glad to hear it!

I assume this is a reference to https://github.com/facebook/react/pull/4167 (though, as of today, it looks like commoner is still being used in the PR (eg. line 12/13 of bin/jsx-internal), but I don't have context so maybe I'm just missing something or a fix is still coming).  Regardless, sounds like a fix to buildtools is in the works ;).
  :+1: I'd love this too, es5-sham doesn't interop very neatly with all libraries so I've ended up in weird situations where I (luckily) could include certain libraries before es5-sham and others after and have it sorted out that way. But I would really like not to have to use es5-sham at all.
 To summarize the discussions in https://github.com/facebook/react/pull/4192 : it sounds like the ideal solution is a transform but we would happily accept inlining the ifexists check for `freeze` and es6 classes instead of `create`.  See https://github.com/facebook/react/pull/4192 for relevant discussions.
  1. This should use the `warning` module, not a call to `console.error`.
2. This shouldn't warn more than once per tag. Probably easiest to combine with validateDangerousTag (rename to just validateTagName) and take advantage of validatedTagCache.
3. SVG tags like `fontFace` start with a lowercase letter and are valid. Let's only warn when the first letter is uppercase. Let's use the message: `"DOM tag names should be lowercase but got: %s."`. 

When you're done, can you squash your commits?
 I'm not sure this is the right solution. The HTML DOM allows case insensitive definitions and it might even be encouraged to use capitalization for certain custom elements.

Shouldn't we just make our `omittedCloseTags` check case-insensitive?
 I didn't mean that we should enforce a strict casing on a subset. We should not enforce it on anything.

I.e. downcase here https://github.com/facebook/react/blob/master/src/renderers/dom/shared/ReactDOMComponent.js#L533
 @sebmarkbage is the ultimate authority; a go-ahead from him is generally enough to do anything :).

I'm fairly certain that @spicyj won't object to this proposed solution.

Go ahead and make the change :).
 No objections here.
 @sebmarkbage doesn't always win!
 Haha, true, but he has a pretty good track record :P.
 $40 says I don't always win.
 That's true too.  // Note to self: never bet against @spicyj.
 I'm always right because I change my mind. Doesn't mean you should listen to my initial inclination. Unlike American politics I think we should value new input. :)
 ok, ok, enough fun.  New diff is up, back on topic.

@jisaacks
I think you missed this one:
https://github.com/facebook/react/blob/master/src/renderers/dom/shared/ReactDOMComponent.js#L224

And also lint requires a trailing comma on line 459.
 All the switch statements too for custom form components (incl. `this._tag === 'select'`).
 @jisaacks: What @spicyj was trying to say is that there are other places in the codebase where we check the value of the tag.  Since now we're supporting arbitrary case, we need to fix those also.

Eg: https://github.com/facebook/react/blob/c5fb3ff9870cc09a6ec82672e854ab54a412cef1/src/renderers/dom/shared/ReactDOMComponent.js#L715
 And a bunch that look like this: https://github.com/facebook/react/blob/c5fb3ff9870cc09a6ec82672e854ab54a412cef1/src/renderers/dom/shared/ReactDOMComponent.js#L677
 How about making it simple for yourself and just do it once `this._tag = tag.toLowerCase();`?

This is already going to have perf implications so we should minimize this work by just doing it once.

Optionally we could use the original tag here to make sure case is preserved in the DOM: https://github.com/facebook/react/blob/c5fb3ff9870cc09a6ec82672e854ab54a412cef1/src/renderers/dom/shared/ReactDOMComponent.js#L553
 We at least need to preserve case for SVG tags.
 @spicyj Which browser requires that? They should be insensitive according to spec.

Or are you referring to #4077 for XHTML in which case we need it to be sensitive for XHTML as well?
 Yea, that works. It is just a bit unnecessary to store that piece of state for every node but we can refactor that later. You could also use `this._currentElement.type` to get the original I guess.
 > They should be insensitive according to spec.

TIL. I guess we might want to support XHTML though. Sigh. Browsers.
 Is XHTML really a thing yet? Are browsers even supporting it? Maybe we should have a special build for that. If we support XHTML then they aren't insensitive anymore.
 To keep things maximally general, it seems intuitively better to avoid mangling the input whenever possible.  The more transparent we can be (ie. the closer we can be to passing inputs straight through) the better.  I could see people wanting case sensitivity, as we see with things like SVG and XHTML and WebComponents.

That said, I'm not strongly attached to preserving case sensitivity.  This one doesn't bother me quite as much as the unitless numbers bug does.

In this latest diff, it looks like we're using upper case for the open tag and lower case for the closing tag?  That can't be right :P, unless I'm miss-reading something?
 Yea, we should probably use the same for the closing tag too. I figured it didn't matter because of case-insensitive parsing and we only really want to preserve the case for purposes of debugging since it shouldn't matter for anything else.

However, for safety, and our own well being we should probably use the same case in the closing case too.
 Ok, thanks @jisaacks!  Sorry about all the back and forth, but this is a good change!  Much appreciated!
  `#examples` contains not only the rendered examples, but also the code editors and preceding descriptions. Thanks for your attempt to contribute, but we're not willing to take such a broad change, and the actual problem you're trying to fix is so minor that it's not causing any problems.
  Thanks
 Oops ‚Äì in the future, please change the source markdown files in docs/ on the master branch.
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 I think this rule (`#examples p`) ends up affecting more elements than you intended. I'm not actually sure what issue you're trying to fix. #4177? In any event, this also doesn't match the style of the surrounding code and that would also need to be fixed. I'm going to close this but if you feel strongly let me know and we can reopen.
  What does Sidebar look like? Does it understand what to do with children?
 ```
class Sidebar extends React.Component
  render: ->
    <div className="sidebar">{this.props.children}</div>
```

`this.props.children` is a special prop created from the children. Read more: http://facebook.github.io/react/docs/multiple-components.html#children
  It's an example, not a full-blown online markdown converter so we don't need to make it work for every use case.
  #4482 happened so closing this out.
  tl;dr

```
<div a={(2)} b={3} />
```

compiles to

```
React.createElement("div", {a: (2, )b: 3})
```

in jstransform, which is wrong. 

@Huxpro You can work around this by removing the parentheses around the function. Please note that react-tools is now deprecated per http://facebook.github.io/react/blog/2015/06/12/deprecating-jstransform-and-react-tools.html (and Babel already works correctly for this case), but maybe we can fix this anyway.
 FWIW, this was fixed in newer versions of JSTransform but there were other changes which resulted in us not shipping an updated react-tools. Both of these projects are deprecated but you can switch to using Babel or the latest jstransform (which now does JSX itself - https://github.com/facebook/jstransform#migration-guide)
  Can you paste _exactly_ what code you have or make a jsfiddle/jsbin? There are a number of red flags in your code sample (`oneOfType` takes an array, you're missing commas)
  It's not super obvious what should happen with events if a component switches away from null during the would-be transition time or if it switches to null while transitioning, but I guess this is an improvement either way.

Can you squash your commits together?
 No worries. On your `patch-1` branch, you'll want to run an interactive rebase by doing

```
git rebase -i master
```

meaning you want to edit the changes you've made since the top of the `master` branch. You'll get a text editor, hopefully with two lines corresponding to your two commits. If you change the second "pick" to a "f" or "fixup" then save the file, git will amend the second commit to the first (and throw away its message). You'll then want to do a `git push -f` to overwrite the branch you currently have on GitHub with the new, altered commit.
 Thanks @johanneslumpe!
  I guess so, but I'm curious how you ended up in a situation where this wasn't obvious. In most cases I'd imagine that you would have just written the code seconds earlier so it would be pretty obvious? 
 The message in master has more context and will be a part of the 0.14 release. We won't be backporting.
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
  Dupe of #3814 (fixed in master already).
  Seems to be working for me: http://react.jsbin.com/tegupeyaxa/edit?html,js,output Can you try to reduce to a test case?
  Yes, this works.
  I don't think you can reliably get charCode for non-keypress events. For keyboard shortcuts, you probably have to use keyCode. @salier might be able to say more, but I'm going to close this out because unfortunately, I don't think React can help you.
 You can always do

```
var node = React.findDOMNode(this);
node.addEventListener(...);
```

in a componentDidMount (and remove it in componentWillUnmount). I am fairly sure that charCode won't work across browsers though, so be sure to test.
 key is roughly equivalent to keyCode; it doesn't depend on keyboard layout like charCode does. If key would work for you, keyCode will too.
 I'd listen to keydown and do

```
e.keyCode === 'C'.charCodeAt(0) && e.ctrlKey
```

which should also work in React.
  I got tired of dealing with PRs trying to add image. Then I decided to cleanup while I was there since we've had to do a few followup changes when changes in getMarkupWrap weren't made in both places.
 Sure.
 @abhilashsajeev This is slated for the 0.14 beta release, which is coming very soon.  If you're anxious to try it out, you can always check out the source code and do a grunt build.
 @abhilashsajeev If you need it urgently, you can always patch your local copy of React to include this change. 0.14 final will probably be released sometime in July.
 No, not July first week. Sometime in July.
  Thanks!
 @tako-black My understanding is that @zpao cherry-picks the documentation changes over to the public website before releases.  This was merged into master only a few days ago, and @zpao is currently out of town, so I imagine this will get merged when he gets back, unless @spicyj does it earlier :P.  Just hold tight for a week or two, and if it's still not merged onto the website, let us know :).
 Wow, somehow I didn't know we had the translation actually available online. Will cherry-pick now.

@jimfb It's easy if you ever want to do it.
 @spicyj I'm happy to learn.  I just wasn't sure what the exact rules were for when we do the update (when do we ever intentionally let stable lag behind?  presumably we don't cherry-pick 0.14 docs over, so we only label/pick things that apply to the last public stable release?), nor the exact steps for the process (we just cherry-pick into stable and remove the tag?).  Didn't want to step on anyone's toes.  Modulo the clarification questions, I'm happy to do it myself next time! :)
 This time I just picked all of the ones that had the label. We don't put on that label for 0.14-related changes but otherwise we generally take everything. I do `git cherry-pick -x` so it links back to the original commit.
 Great!  Thanks @spicyj.  Now I'm excited for another 0.13 docs change so I can test out my new workflow :).
  Make events propagate through shadow DOMs.  This is necessary for WebComponents, which often render into shadow DOMs, through which events may need to propagate.
 cc @sebmarkbage 
 @sebmarkbage new diff is up.
 Ran the perf test, event handling took between one tenth and two tenths of a millisecond.  The new implementation looked ~2 hundredths of a millisecond slower, but I could totally believe that's within the noise of the measurement.  I think that's within a reasonable range (certainly for a beta release, we can try to optimize later if we feel it's necessary).  As per conversation with @sebmarkbage the perf test was the only thing blocking this, so I'm going to mark this as accepted as per that conversation.
  Use lowercase strings when calling createElement (we use the type to set up some special event handlers for forms, including submit).
  Value-less attributes are a shortcut for boolean attributes. It's not my favorite part of the JSX transform but it exists. You should be able to specify an empty string `<table data-tablesaw-minimap="">...</table>`, which will ensure the value React gets is an empty string. That should end up in the DOM correctly without a value.
 Oh, good point @zpao. Somehow I forgot that.
  Curious: does acorn support all the latest ES6 syntax or are there many constructs that only acorn-babel supports?
 Sweet, thank you.
 If we're going to call out Acorn, it would feel remiss to not mention Espree, which also parses JSX.
 Oh nice, I didn't realize that was under consideration. I think we're probably fine as is then.
  Thanks!
  You need to enable the other es6 transforms by adding some params to the `type`. `type="text/jsx?harmony=true`

I don't know how to trigger that on jsbin but I would suggest using Babel there anyway.
 @josdejong It is, but it is not enabled by default.
Also https://facebook.github.io/react/blog/2015/06/12/deprecating-jstransform-and-react-tools.html
  Sure, would you be interested in writing something up?
 A code example might be useful (and would hopefully help prevent followup questions where people will surely have a problem with using `this`)
 Related reactjs/react-future/issues/35
  Fixes #3223.
 Looks like you have some test failures. Probably need to fix that. Other than that it looks good. Hopefully we figure out something cleaner for the top level node.
 Test failures are just due to missing warnings/getDOMNode. Been working on today, almost done.
 Edit: nvm. I see you already posted the updated code.
 @sebmarkbage Yeah, just pushed the last commit. Want to look? Maybe there's a better way to do setProps (cf. `_topLevelWrapper`) but this works.

(One failing test, investigating now.)
 nbd if the setProps stuff gets messy. We'll make a quick follow up release that kills setProps/getDOMNode.
 yolo
 It is a wrapper around the root so, inclusively, it include everything else. So it should be the most expensive (inclusive).
  We generate `<input disabled="">` currently which works in both HTML5 and XHTML. Does that work or does the value need to be `'true'`?

Right now React probably won't be usable without forking the property stuff (sorry!) but hopefully there's not too much else. I want to support SVG better soon and maybe improved XUL support can come with that too.
 Hm, I thought it should work: https://github.com/facebook/react/blob/d67f23fb0e1813aae26ff09d36eea9e32d8e3dae/src/renderers/dom/shared/DOMPropertyOperations.js#L123-L126
 Oh, I guess that's not in a release yet. http://react.zpao.com/builds/master/latest/ has builds from master if you're feeling adventurous, or you can wait for 0.14 in about a month.
 I'm definitely sneaking exploits in there to get access to the machines with Firefox code.
 Neat technique.
  I don't think this is really a React issue. The discuss thread is a good place to keep talking about this.
 My bad about this, I've talked to @threepointone and suggested to create an issue for it. The initial goal is to turn this into something more actionable because it might require react-level support (assuming this pattern makes sense, I think it does). But I guess we can solve the problem fine without it. The same pattern @gaearon suggests can also work with scu with normal children passed to the wrapper.
  We're still a little ways away from this but starting the list before we lose track. This is less big picture like #3220 and more about the longer tail of work.
## Misc
- [x] Remove react-tools, JSXTransformer mentions from docs
- [x] Update react-tutorial repo to use babel/browser
- [ ] Polish readme for react, react-dom
- [x] Update fb.me scripts to exclude JSXTransformer
- [x] Update to node v4 for development (will be better moving forward with stable branch maintenance)
- [x] Update cdnjs, jsdelivr autoupdaters to account for #4901
## Documentation Changes
- [x] Updates for refs, stateless function components (#4964)
- [x] Update for desired API usage (eg `React.render()` ‚Üí `ReactDOM.render()`) (https://github.com/facebook/react/pull/5055)
## Final Steps
- [x] create `0.14-stable` branch
- [x] shrinkwrap
- [x] actually publish to all the places
- [x] update jsfiddles
  - [x] base
  - [x] thinking in react
- [x] Update changelog.md
- [x] make sure master branch has all documentation changes made in 0.14-stable
- [x] update react-tutorial repo with final changes
 @activatedgeek See this blog post from last week: http://facebook.github.io/react/blog/2015/06/12/deprecating-jstransform-and-react-tools.html.
 https://github.com/facebook/react/milestones/0.14 is what I've been looking at. We don't have issues for updating docs.
 From the description:

> This is less big picture like #3220 and more about the longer tail of work.
 I think at this point we just have some docs and the final release steps. Thanks for the offer though! Feel free to jump into anything else you find.
 `react-addons-specific-package`. It's not mentioned super loudly in http://facebook.github.io/react/blog/2015/09/10/react-v0.14-rc1.html, but it's there.
  It is intentional and we know it's inconsistent with HTML (which is honestly pretty odd). The reason removing the spans works is because then the whole child is read as a single string (with spaces).

There is some more detail in the blog post when we made this change (>1 year ago): http://facebook.github.io/react/blog/2014/02/20/react-v0.9.html#jsx-whitespace

The short version is that it's what we believe to be the lesser of 2 (whitespace handling) evils.
  Thanks!
 @tako-black updated the pull request.
  Thanks! I think this should be good - going to try to land this and the other deprecation pieces close together in case we need to back out.
 _finally_ got this in. Thanks again!
    Thanks!
  This doesn't work because after one shallow render, the rendered output is

```
<Double value={50}>{doubled => <div>{doubled}</div>}</Double>
```

and if that were rendered, you'd get

```
<div>{100}</div>
```

(At no point would you have `<Double value={50}><div>{100}</div></Double>`.)

You could try

```
var double =TestUtils.createRenderer().render(<App input={50}/>).getRenderOutput();
```

and verify that `double.type` is `Double` and that `double.props.children(50)` is `<div>{100}</div>` or something along those lines.

Let me know if that doesn't make sense.
  We've suggested in the past binding to onBlur if that's the semantics you want. Does that work for you?
  actually you should do `npm outdated`
 You can't do this blindly. There's actually a reason we're stuck at some of our dependencies (eg, by updating sauce-tunnel you actually broke some of our testing,  npm-jsx_orphaned_brackets_transformer actually needs the specific version of jstransform that it specified).

For many of the other things, the `^` range will install the latest version and I don't feel the need to bump everything. Here's what `npm outdated --depth=0` tells me after a fresh install:

```
Package                Current  Wanted      Latest  Location
coverify                 1.0.7   1.0.7       1.3.3  coverify
browserify               9.0.8   9.0.8      10.2.4  browserify
eslint                  0.22.1  0.22.1      0.23.0  eslint
eslint-tester            0.7.0   0.7.0       0.8.0  eslint-tester
grunt-contrib-connect    0.6.0   0.6.0      0.10.1  grunt-contrib-connect
sauce-tunnel             1.1.2   1.1.2       2.2.3  sauce-tunnel
typescript               1.4.1   1.4.1  1.5.0-beta  typescript
wd                      0.2.27  0.2.27      0.3.12  wd
```

If you really want to go update everything, that's a great goal. But I won't accept it blind like this. Doing it in pieces is ok. Eg, update the server-side rendering example _and test it_. We need to know you tested it and it worked before we ship it to a bunch of people. I'm going to close this PR out as is as a result. But if you do want to do this, I'd expect to see at least 4 separate PRs (or 1 big PR with multiple commits), each with an complete test plan.
  Not super easily right now since that's baked into the markdown processing (https://github.com/facebook/react/blob/master/docs/_plugins/header_links.rb)
 @bryanbraun Seems reasonable, though let's just inline the logic instead of pulling in a third-party library (and let's make sure the regex is equivalent in order to preserve existing links). Should only be a few lines of JS.
  Thanks!
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 @ericelliott & @cody are right that it is correct as written but if it's confusingly worded, let's change it. Maybe this is clearer:

> ‚Ä¶ because props may change as a component is re-rendered.
 No response from author so closing out and will just change myself.
  Great. 1 more request - could you flatten these to a single commit?
 Ah, nope. Github doesn't send notifications for commit changes. Looks great, thanks!
  Looking at the HTML view, the data-reactid in question is used on 2 `<a>` tags. Usually this is the result of the browser reorganizing nodes, specifically nested `<a>`s.

``` html
<a id="1">
  <a id="2">foo</a>
</a>
```

Will always get moved in the DOM to be 

``` html
<a id="1"></a>
<a id="2">foo</a>
```

That's the likely culprit for your case. Chances are you have nested anchors across components. `DropdownItem` definitely has one. If anything rendered inside there has an anchor (I guess `PluginsList` or one of its children), then this will happen. When it does happen, React's idea of the DOM and the real DOM get out of sync, and then you hit this problem.

Though your problem might actually be manifesting slightly differently (could be the DOM structure playing different tricks) but you definitely have nested anchors.
 React will warn for invalid nesting like this in the next release.
 @mdcsfk That kind of nesting will not trigger this error.
 @jimfb Yes it will; you can't have two nested anchor tags in HTML.

@mdcsfk You will need to restructure your markup. You can't have that kind of nesting in HTML, whether or not you're using React. Usually you'll want to change one of the links to not be an actual link and you can add a click handler to it.
 Oh, right, because the dom will rewrite the anchors.  You're right.
  Thanks!
  Not quite right, but you can use an ES2015 template string, which can contain newlines:

``` js
render: function () {
  return (
     <Markdown>
       {`# Hi whitespace is important in this tag

       Please add an option to keep all my spaces!`}
     </Markdown>
  )
}
```

We're unlikely to do anything beyond this.
 Whitespace also matters with `white-space: pre;`.
 @matthewmueller No, you need the backticks. (@mathieumg was saying that whitespace is collapsed (by the browser) in most HTML tags with the notable exception of `textarea` so I just pointed out that changing the `white-space` CSS on other tags will also preserve space.)
  These aren't broken but are relative to work on the website. See the final rendered page: http://facebook.github.io/react/docs/thinking-in-react.html
  They're not public outside the component. We should figure out a solution here though. https://github.com/facebook/react-native/issues/1521 is also related.
  Dupe of #1587.
  Thanks!
  Does your own package.json have "learn react" as its name? We don't use that anywhere.
 So the only way I can repro this is if a package.json contains `"learn react"` where it's expecting a valid npm package name (which can't contain spaces). This could be in the `name` field or `dependencies`. The error stack you pasted is pointing at something in your directories, not React itself. Perhaps it's something you're not expecting to be read? The best I can suggest is deleting some directories and starting over.

```
4 verbose install initial load of /Users/ajfarkas/Sites/Learning/react/package.json
5 verbose stack Error: Invalid name: "learn react"
```

I'm 100% certain this is not a problem with React itself so I'm going to close out, but I'm happy to keep helping here.
  ```
import React, {Component} from 'react'
```

> it seems to me that the JSX transpiler should be responsible for setting up variables that are only internally referenced, but i wanted to ask the question...

JSX doesn't know how React is made available in your environment, even if it did it would not be a good idea for various reasons.

Also this is probably best brought up in the babel repository (but I would expect a similar answer until there's a good plan for how to make elements work independently from React).
  cc @sebmarkbage 
  Added in https://github.com/facebook/react/commit/fd682b5cac157b08c12403e4e6e87c3384385202
  Yup, the browser field will get used by browserify automatically, so envify will work. AFAIK there is no equivalent for webpack.

FWIW, envify + uglify is exactly how we build our minified builds.

Any suggestions (or PRs :wink:) on clarifying the documentation would be appreciated!
 ``` js
new webpack.DefinePlugin({'process.env.NODE_ENV': JSON.stringify('production')});
```

Is all you need for webpack.
 Going to close this out. I haven't seen this come up recently but we'll definitely plan to do a clearer job explaining usage like this when we do a revamp of docs.
  As per https://github.com/facebook/react/issues/2302 we're probably dropping valueLink in controlled components.  The LinkedState mixin really isn't used much, and even less so now that people are moving towards ES6 classes.  Also there have been no replies on this thread, which indicates a lack of interest in this topic.  Since LinkedState appears to be on its way out, my guess is that we won't invest a lot of effort in enhancing the mixin and it is mostly legacy at this point.  If you find it useful, feel free to create your own LinkedState mixin for your apps and/or publish it for others to use.
  @reactkr review please. :)
 Thanks!
  Seeing as this isn't actually a legal document, lgtm.
  The answer you got on Stack Overflow is correct. `defaultValue` only specifies the value when the input is initially created; if you want it to remain updated you need to use `value` and handle `onChange` events correctly.

We don't update when `defaultValue` changes because otherwise you have two sources (the user's input and your component props) trying to control the value, and it wouldn't be clear what should happen when they conflict. Instead, we force you to think about and write out the actual behavior you want.
 > The whole point is that state is not stored in the DOM...

With defaultValue, the state _is_ stored in the DOM. That's why we don't recommend it. We recommend using controlled components instead. The docs say:

> If you wanted to update the value in response to user input, you could use the `onChange` event.
> 
> (http://facebook.github.io/react/docs/forms.html#controlled-components)

Let me know if that's still confusing.
  Try `accessKey`: http://react.jsbin.com/bucuxiguli/1/edit. You should have seen a warning in your console for this.
 You'll also want to fix the other warning in the console about using `htmlFor`
  Trying this again‚Ä¶
 Still no luck. We can see it starting and we see the original output from jest but then it immediately exits cleanly :(
 Would that help? The jest script is exiting cleanly so I think it's more of an issue with jest + something about travis. I'll try upgrading jest & node in the coming weeks and see if that helps.
  Unfortunately setting `process.env.NODE_ENV` at runtime isn't going to work. We do some initialization work based on the environment when you require React. I would guess you could set the env before requiring React and it would work but otherwise, we're not going to support dynamically changing environment.
  How are you using `cloneWithProps`? Looks like you might be passing it a Component Class, not an element.
 Closing since this isn't actionable for us as-is without a code sample, but @zpao's suggestion sounds the most likely.
  Sorry for the delay, it's been a busy couple weeks as we work out how the build process is changing.

Let's do this (thanks by the way!). Can you rebase first though so it will merge cleanly? We made some changes to the Gruntfile which will conflict.
 Thanks!
  If you really want to control the children of UIPane imperatively in that way, you can add a `setChildren` method to the instance that can be called from outside which updates its state. (Or you could do the same on a wrapper component.) Something like:

```
class UIPane extends React.Component {
  setChildren(children) {
    this.setState({children: children});
  }
  render() {
    return <div>{this.state.children}</div>;
  }
}
```

(setProps in particular can be confusing because now you have multiple places in your app disagreeing about what they think the current props are.)

@jimfb also has a ReactComponentRenderer wrapper class that might be helpful. Like #1711.
 This should work:

``` js
var uiPane = React.render(<UIPane ... />, node)
uiPane.setChildren(stuff)
```

You'll have a component instance, not an element. You can't do anything with just an element (`<UIPane/>`) except render it.
 You can also do

```
<UIPane ref="pane" />
```

and then `this.refs.pane.setChildren()`.
  Intended. null/undefined aren't the same as the empty string so if you want to select the value with `value=""`, that's what you should pass.

We interpret `<select value={null}>` to mean an uncontrolled component (similar to #2533).
 @blainekasten Interesting idea. Unfortunately it's fairly common to have an uncontrolled component but also listen to onChange so I don't know if that can work.
 We don't want to add DOM-specific logic into the JSX transform. It's more likely that we'd split out `ControlledInput` and `UncontrolledInput` into separate components which would also solve the problem, but honestly this probably isn't tripping up enough people for it to be worth making that change for us now.
  @mathieumg Not sure what you're doing, but you probably just want `return <MyComponent />;`.
 `<MyComponent />` and `React.cloneElement(<MyComponent />)` are basically equivalent. You can't access instance methods on a component without mounting it, after which you can use instance methods via a `ref`.
 It would still work without the cloneElement call. cloneElement takes an existing element and creates a copy (useful for modifying elements passed to your component). `React.cloneElement(<MyComponent extraProp={/* ... */} />)` creates a new element (that's what the JSX does) and then immediately creates a copy.
 You could try

```
var MyWrapperComponent = React.createClass({
  getWrapped: function() {
    return this.refs.inner;
  },
  render: function() {
    return <MyComponent ref="inner" extraProp={/* ... */} />;
  }
});
```

then `this.refs.myref.getWrapped().foo()`. Not sure if that works for your case.
  Yeah, let's track there. cc @jimfb though.
 I think this is solved by using ReactWithAddons.renderSubtreeIntoContainer.  It currently handles context forwarding but not event bubbling, but it sounds like that would work for @slorber's use case.
 @slorber https://github.com/facebook/react/pull/3741 was never merged; the PR was closed because we figured out how to do the sync internally.  The switch to parent context has happened.
 Yes, 0.14 will be parent-based-context, and renderSubtreeIntoContainer will be made available publicly.  You can start playing with it in React 0.14-alpha3, which is up on NPM.
  Your specific issue with unmounting‚Ä¶ that doesn't seem right. Purging cached nodes is a big part of the point of unmounting. Perhaps we have a bug there.
  I think this should be fine. Thanks!
 Note: we'll need to make sure this gets manually synced internally.
 Thanks for the reminder.
  Please try to reproduce in a jsfiddle or similar that makes it easier to reproduce. It seems like you got some help switching to `defaultValue` but you didn't explain what the problem was after you applied that fix. We can follow up on StackOverflow.
 defaultValue doesn't update after initial render. That makes a component "uncontrolled" so that the user interactions are not feeding back into state and the changes the user makes are visible. Controlled components use `value` and `onChange` to explicitly handle user data on each change.

In your example, adding `value={this.state.defaut}` will make the text area update.
 This is not a workaround; it is the suggested way to build forms for most use cases.
  Virtually all of the component code runs in that `.mountComponent` call, so it's not surprising that you found it took most of the runtime. We're been continually trying to make performance improvements to React and will continue to do so.
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 Like @zpao said in https://github.com/facebook/react/issues/3982#issuecomment-107678957, we avoid exposing global configuration options like this as it makes it harder to share components between projects. If you would like to add a property to the list, you can send a PR for that, as he suggested.
  cc @spicyj This wouldn't work with the context scenario. Maybe separate renderers are need at the top level? Or at least a flag.
 Sorry that was directed to @spicyj based on a conversation I had with him yesterday
 @sebmarkbage It works if ReactMount supplies the context.

@neojski Are you using XHTML? I was under the impression that in HTML, just an `<svg>` tag with no explicit namespace should work fine.
 @spicyj What about ambiguous elements like? `React.render(<title />, container);` This doesn't have a context to be picked up.
 @sebmarkbage I assumed we'd look at the namespace of the container. Sorry for not being more precise.
  Thank you!
  I'm not sure how much value there really is in this. react-rails already stopped using it and just builds the files in itself.

cc @rmosolgo
 (I'm currently running https://github.com/grosser/gem-dependent to find out how many there might be - looks like this script may take a day to hit the end point for every gem in the registry)
  This is a really specific question that is better suited for stack overflow or the discussion forums: https://discuss.reactjs.org/. We try to keep the issue tracker focused on bugs and features for React itself.
  > I'm running into the situation that since I'm not creating the <Route> in the parent and passing it through from the owner, the children do not re-render when the parent's state changes.

Perhaps I'm missing something... they don't? When each component re-renders the children it renders re-render too (unless prevented by `shouldComponentUpdate`). However, them being created externally in `home.js` they won't receive any new props as it doesn't re-render too.

On a personal note, I think doing routing that way is poor practice, I don't see any benefit to specifying routes as JSX elements instead of using regular JS structures. I just see downsides.
 > So in this example you're right that  home.js  isn't being re-rendered. What's being re-rendered is the  <Router>  when  pushstate  or  popstate  triggers. Intuitively, I would think that would cause the  <Route>  components to re-render since they're children of the  <Router>  but that doesn't seem to be the case.

Yeah that's what surprises me, if `Router` re-renders then any elements it render will re-render too (you're not using a `PureRenderMixin` right?). Do you have a working jsfiddle I could look at?

> Thanks for your feedback, can you elaborate a little bit more on this? I'm not sure what you mean by regular JS structures and what the downsides might be.

I should rephrase that as defining routes as children to a React element (using JSX is not _necessarily_ a bad idea).

``` js
addRoute('/', function(...) { return <span>Hi from Index</span>; });
addRoute('/user/martin', function(...) { return <span>Hi Martin</span>; });

render() {
  return (
    <div className="home">
      {routeObject[route](...)}
    </div>
  );
}
```

Technically, lookups can now be constant (or log) time and preprocessed/cached instead, doesn't involve React overhead nor does re-rendering `Home` cause all route elements to be recreated, additionally routes no longer have to be centralized in a single file (may or may not be a good idea). I don't have a neat bullet-proof argument on hand... but you should always strive to use the simplest data structures (not easiest/most flexible) to solve your problem, using UI elements to define routes does not fit that. Just like using a Map to define a pre-defined structure is a bad idea too.
 > No it's not using PureRenderMixin. so here's the simplest example I can think of to illustrate this point: http://jsbin.com/cuxexulajo/1/edit?js,output

That's interesting... cc @sebmarkbage @spicyj It seems React skips re-rendering for elements that pass `prev === next`. Is this an optimization gone bad or now intentional?

http://jsbin.com/wuzinaqari/1/edit?html,js,output
 This is intentional. It is an optimization we've had for a long time and extremely rarely does it ever show up as an issue (as evident by the fact that @syranide didn't even know about it).

Here is an example of one kind of optimization you can do (manually or automatically): https://github.com/facebook/react/issues/3226

It is also useful for container components that only updates their own state but their parents doesn't rerender. E.g. a scrolling surface.

We do support mutation of your own state as a convenience but we do make certain assumptions about your code style.

This optimization relies heavily on the hard requirement that `render` must be pure, which is the only hard FP requirement of React:

1) `render` should be idempotent. I.e. it should render the same thing regardless when it is called. Neither of these examples uses idempotent render functions since they're reading from (globally) mutated state. (`match` and `Date` are not immutable) We've been thinking about ways of trying to enforce that. The ideal solution is to put time into your own state, but as a convenience you can call `forceUpdate` on something that you know is reading from global state whenever it changes. I.e. the thing calling `match` or `getTime` needs to call `forceUpdate`.

2) `render` should not cause side-effects. Even if you use mutable state in your objects, you shouldn't mutate them within the render.

ReactElements and their props are immutable. That is already enforced through `Object.freeze` and warnings. However, it is ok for state within them to be mutable. E.g. `<Foo bar={this.state.mutableObject} />`

We do have one heuristic. We assume that you won't combine mutable state with reusable elements. E.g:

``` js
var mutableObject = { value: 1 };
var reusableElement = <Foo bar={mutableObject} />;

class App extends React.Component {
  componentDidMount() {
    mutableObject.value = 2;
    this.forceUpdate();
  }
  render() {
    return reusableElement;
  }
}
```

This last part is a heuristic assumption which has a theoretical case that doesn't violate any of the other rules but still breaks. This case has never showed up yet AFAIK, because it is so awkward and unnatural way to structure your app in React.

However, the OP isn't related to that, this is simply breaking rule number 1.

`render` should be idempotent.
 One possible solution is to use subscriptions in your Route components that listens to the global broadcasting of a new route change (then calls `this.forceUpdate()`). In `componentDidMount` you can subscribe and in `componentWillUnmount` you unsubscribe.

We have various future options pending, like #3398 or #3973, that could both make this easier.
 @matthewmueller 

> More generally, I'm failing to understand how this isn't problematic anytime you want to encapsulate the complexity of a global, window-related event (browser history, resize events, geolocation, etc.) into a component.

The recommended approach is to listen to whatever info you need and store it in `state`, reading from state in your render method ‚Äì each time you update state, the component will be rerendered.
 Yeah, that could cause multiple renders in some cases. With https://github.com/facebook/react/issues/3398, React could be intelligent about scheduling updates and batching them together though. Also you'll only get unnecessary renders in the case that you have a new element from the parent _and_ new data that's sideloaded, so that may be relatively uncommon.
  I actually think we made a mistake ever allowing mixins to be be able to specify other mixins but that's beside the point since this could happen without that.

We've never allowed method redefinition as a blanket statement, with the exception of some lifecycle methods as they can stack. With userspace methods, the intent isn't clear so we don't allow it and I don't know that we'll change our minds there.

cc @spicyj @sebmarkbage 
 The point of the 0.13 release is that you no longer have to rely on the `React.createClass` abstraction. You can use whatever class system you want.

We probably won't add new features to it, instead we'll defer to the standard class system or third-party class systems that has mixin abstractions.
  This was called out in all of our documentation about ES6 classes and there are a number of issue on it. Closing this out but feel free to follow along in one of the other places.
  Thanks! I just pushed the change to the stable branch so this should be updated on the site and in the gh-pages branch as soon as it builds.
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 Are there any other `<video>` related markup DOM properties/attributes that can also be added? #2094 attempted to add some (and some non-markup related ones which is why it didn't get off the ground).
 http://www.w3.org/TR/html-markup/video.html#video-attributes
http://www.w3.org/TR/html-markup/track.html#track-attributes

I'm pretty sure all of these have to be `MUST_USE_ATTRIBUTE` too.
 By default React does `node.property = newValue`. However that doesn't work for everything and for some you must actually do `node.setAttribute('name', newValue)`. `MUST_USE_ATTRIBUTE` tells React to do the latter here. The inverse is also true where some must be set with the property and will never work with the attribute so we specify `MUST_USE_PROPERTY`. https://github.com/facebook/react/blob/master/src/renderers/dom/shared/DOMProperty.js#L22-L61 has some comments about this.
  Apparently my brain autocorrected these :)
  Thanks!
  Can you preventDefault in an async callback? I would imagine not.

BUT if you do want to persist outside of the event handler then you can just call `event.persist()` and it will get pulled out of the pooled class list.
 If you can't get clipboard data synchronously, then I don't know. You could try persisting as I mentioned and see if calling preventDefault later does anything.
  Yea, I agree that it is probably useful as a convenience similar to refs. Since a ref could expose a public API which can be tested. It is probably bad practice to call handlers or inspect state directly though. It is better to test the public API by invoking the callbacks of the render output.
 @jsdf Yea, that seems reasonable so that they can be addressed separately. Both seems reasonably simple though so a pull request would be welcome.
  `props.children` is not the rendered child instances, it is the child elements provided to your component's associated element (which is not a guarantee they end up being rendered). PS. It may be more obvious if you consider that `props.children` is treated exactly like `props.foobar`, the only difference is the dedicated JSX syntax for children.

> I am currently writing code to traverse through a form with all its inputs

React does not provide a way to do this and (AFAIK) never will for non-testing purposes, it goes against current best practices for React. You should be explicit for the purpose of readability and keeping components isolated.
  Thanks!
  Sorry, not sure if I missed this or just forgot. Instead of using browser detection, I'd like to listen to both events and deduplicate them. This will require some refactoring.
 Thanks for the effort. I realize this is painful but I'd rather fix this in a way that's more likely to work across browsers and is more likely to be future-proof. I think listening to all the events is probably the best way to do that.

In any event, I don't think we want to take this as-is so I'm going to close it.
 I know. But when we have hacky solutions committed we have to maintain them and it's more likely that people will run into weird edge-case bugs that I won't find in my testing, leading me to believe that everything works but then other people run into bugs. There's no good solution here. 
 @jquense This is one of the few long-standing issues that people do run into, and we would be interested in a complete/correct solution.  The problem is that for many of these issues, a partial fix is worse than no fix, for the reasons @spicyj mentioned.

If you'd like to try to create a fix that listens to both events and deduplicates, let me know and we can try to get your PR fast-tracked.  React does occasionally do user-agent sniffing, but in this case modern browsers don't even agree on behavior with regards to range inputs, and sniffing might make it harder for browsers to converge/change on behavior (because they need to continue supporting our sniffing), so we'd like to avoid sniffing to the extent possible.  Basically, what we would need to do is subscribe to both events, and fire a change event when we see an event that gives us a new value which differs from an old value that we've seen.  Does that make sense?  Let me know if you have any questions and we can help try to come up with a design that makes sense!

You've been a very active contributor, and we appriciate it!  Feel free to ping us on any PR that you think we haven't been responsive enough on, and we'll try to jump in.  If you don't get a response, just keep pinging! ;).  We do want to be more responsive to pull requests, especially from regular contributors like yourself.
  This solution feels simple and clean to me, it avoids having a whole additional browser-dependent code path to follow (ie. better than #3826).

I'll leave it unmerged for a day so people can raise any objections.  If there are none, let's ship it.
 @jquense updated the pull request.
 Thanks @jquense!
 cc @salier as a heads up since you've been dealing with this sort of stuff.
  Thanks for filing ‚Äì going to close this though and leave the discussion on the other issue.
  Thanks!
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 :thumbsup: Now last request: could you squash to a single commit?
 thanks!
  @gilbox Can you try to make a minimal repro case? If this is a React bug I'd like to fix it.
 @gilbox I fail to see the problem in your fiddle, it outputs null for as long as `Foo` is returning null (it has no associated DOM node), but when `Foo` starts returning a div then associated DOM node is output in the console... ?
 @gilbox Do you mean that `findDOMNode` returns null for a component even though it has rendered an element, so if you replace null with `<noscript />` then it actually works and returns the correct node (**not** noscript)? I.e. something like #2353 (that was supposedely fixed)?
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 Thanks for the idea. We just talked about this in our meeting and decided that we'll leave the name as-is in our repo, but we don't plan to use either term in the public APIs or our documentation so hopefully this doesn't make much difference.
 I'll repeat myself:

**We don't plan to use either term in the public APIs or our documentation.**
  Sure, we have another for `componentShouldUpdate` (which is the common "typo" of `shouldComponentUpdate`). Would it be cool if we just said "I BEFORE E EXCEPT AFTER C, and also other times because English is silly and inconsistent."?
 I think it probably belongs alongside the warning for componentShouldUpdate, which should already be dev only.
 @raybooysen, Ideally, but I don't think many linters can check for undefined variables across imports, and some of the react userbase isn't using one. Whether we should _support_ that use-case or not is a valid question though.
 Closed via #4045.

Yes, ideally this is a part of lint. I think it could be cool if https://github.com/yannickcr/eslint-plugin-react has a rule for it - feel free to suggest it to @yannickcr (and/or write it :wink:)
 @yannickcr Your call. We try to keep it pretty minimal in core, this 1 added here after 2 years, componentShouldUpdate added a lot earlier, incorrectly-cased DOM props a while ago. There's another for mistyped event handlers. We'll adjust with more or less later I'm sure. I'm currently on a "machines should fix all my problems" kick so I like more linting. If you don't add it that's totally your call - I'm appreciative of the rules you do have :) If somebody wants to add their own rules, eslint makes this super easy so they can write their own.
  Are you talking about the xmlns field? I don't think React is adding that but you could confirm by using `React.renderToString` and logging the output. That will be what React renders.
 @Swaagie sounds like you have a couple of different dependencies going on there.  Do you not see the issue in other browsers?  What version of firefox are you using?  It would be great if you could provide a jsfiddle that demonstrates the issue.
 Closing due to inactivity.  I'm assuming that @Swaagie has solved his issue.

@Swaagie If you have a fiddle that demonstrates the issue, feel free to re-open the issue and we'll happily investigate further.
  In response to #4028. I don't think we use these anywhere, and we recommend using grunt for everything anyways.
 Let's keep `test`
 It sounds like this is causing a lot of backlash. I'll drop it.
  Some invariant violations leaves React in an unstable state at the moment so this is to be expected. AFAIK this is partly because catching and re-throwing errors is a crapshoot in many browsers and may also have significant performance impact on hot code-paths.
 @korakon It doesn't matter if you rethrow errors, my intended point was that React can internally catch and rethrow errors to avoid the internal state breaking (completely at least) but doesn't because there are undesirable side-effects in many browsers currently.

AFAIK there is no clean way out of an invariation violation once it has happened. If you have a particularily vulnerable piece of code then wrap that in a try-catch, not the calls to React.
 @jordancardwell You should have gotten a warning for that in dev mode with React 0.13.  We try to warn in the previous version whenever making breaking changes, such that if you fix all your warnings then the migration to the next version will go smoothly.
 @jordancardwell We did exactly that in 0.13.

Example text of error message:

> Warning: Don't set `.props.myFooProp` of the React component `<FooComponent />`. Instead, specify the correct value when initially creating the element or use React.cloneElement to make a new element with updated props.
 @jordancardwell Don't we freeze the props in dev now?  In most browsers, you should get an error (with stack trace) like:

```
Uncaught TypeError: Cannot assign to read only property 'foo' of #<Object>
Uncaught TypeError: Can't add property noise, object is not extensible
```
 This error message usually just mean that `render()` of some component threw during the initial mount. If you look _above_ this error message and ignore it, you will see the real error message.
  If you clear your require cache does this start working? I wouldn't be surprised if some of our node memoization causes issues (namely in this case, the bit we use to generate HTML with the right namespace creates a node once). Since these are all run in the same process, the requires are cached. Looks like the feature was rejected from mocha so you may have to make it happen yourself or just run each on in its own process. https://github.com/mochajs/mocha/issues/536
 Yes, creating a new node each time would be expensive. Potentially we could check if the cached node's ownerDocument matches window.document. Even just doing that check will come at a cost though and I'm not sure it's worth it to support a use case we don't currently intend to support.

React isn't really configurable like that and it would be more of undertaking than we plan on making to do so. Maybe one day.
 It only happens on re-renders (initial render just does an innerHTML), which is why setState triggers it.

As for the why, when we create new nodes to insert, we have a string of html, add it to a node, then extract the DOM node. Then we put it in the right place. We do this because some nodes need to be wrapped to insert correctly. Things probably work fine up until the point where we move the nodes from the dummy wrapper and put them into the right place. This is where we cross document elements (I think that's the "Wrong document" error).

I don't know what's happening in your image case specifically, could be related to an update. Creating nodes is the problem, updating existing nodes should be ok.
  This is correct as is - you use the `key` prop to specify a key.
  `createClass` is pretty much depreciated (but supported) in favor of ES6 classes. So going forward React no longer has an opinion on how components classes should be constructed and it's up to you to use whatever class mechanism you prefer.

Personally I agree with you on mixins, they may offer some benefit for certain purposes but largely seem to be a very poor solution to the problems developers usually apply them to.
 @ysmood React isn't dropping mixins, going forward React has no opinion and `React.createClass` is effectively being made into a separate module. `React.createClass` _could_ warn that mixins is a bad idea, but effectively everyone would see the warning and those who really prefer mixins (right or wrong) would just find it annoying. If you're at all subscribing to where React is heading then you'll know mixins is something you should avoid. So while I think a warning seems like a great idea on the surface, I cannot see it being anything but a disaster in practice. cc @zpao 

> Why close this issue so fast.

"Deprecate Mixins" doesn't seem actionable to me.
 @ysmood We're not ready to deprecate mixins because we don't have good replacements for all of their use cases. When we do, we'll probably move towards deprecating mixins and React.createClass, but that is at least months away.
  cc @graue 
 https://github.com/facebook/react/commit/40b7c19a890b04e5d7bd1273e4f90bb78769ae5b may have fixed this. Not sure it actually rerenders though?
 @spicyj Should we have a custom transaction for shallow rendering? (Eventually we should get rid of transactions completely.)
 Yeah maybe. 
 Good call, @robertknight. Looks like this was fixed in 0.14.0 (not RCs), broken in 0.14.4 (the fix was accidentally reverted upstream in fbjs), and fixed again in 0.14.6. I just tried @glenjamin's example with 0.14.6 and it's working (prints baz).
 Yeah, let's at least have a test.
  Yes, deep updates in state like this can be tricky. But this is the nature of JS - if you pass an object by reference then it will remain that way. In your case that's exactly what's happening with `var2`. Generally state will not be great for things like this and you may want to consider alternatives like deep cloning or immutable data structures. We have no intention of doing the state clones ourselves as that can be an expensive operation with lots of nuance. If you need it, then it's on you to do it.
 Those words meant, "do not mutate this.state", not that React will make a copy.
  Can you provide a bit more information? Are you using Babel to transform? What version of React exactly? (we have a couple alphas published, or maybe building from master/specific revision)
 `npm install github:facebook/react` won't give you react. Currently it'll give you react-tools.

Nothing is jumping out at me though. It would be good if you could create a complete repro on jsbin (react.jsbin.com - change the JSX option to Babel). You can point at the build for 0.14.0-alpha3 http://react.zpao.com/builds/master/1432770455-8471cc5f47bac0dbfd6b3123775fc28757db0ed3/react.js
 @blainekasten are you still seeing this?
 üëç thanks for the update!
  This is the same as #1232. The workaround in your case will be to put keys on the divs inside your ternary. (https://jsfiddle.net/up8j9aqz/)
  The responsibility of sanitizing user data falls on you (or 3rd-party helpers). It's usually advisable to reject any non-absolute non-HTTP(S) URLs really. This applies to all properties that are interpreted in any way, so beware of styles (colors, sizes, etc) too.
 #3473
  The comment you included explains the reasoning "as a convenience for simpler class abstractions, we set them up after the fact". Not all component classes will be created with `createClass`. Already you can use ES6 classes. If you extend our base class then props and context will be set up before hand. But you don't have to extend our base class.
  In researching a separate server implementation, I have found that being able to inject different component types in to `instantiateReactComponent` allows me to bypass much of the reconciliation logic that is not needed on the server. Via `ReactNativeComponent`, `instantiateReactComponent` most of the types are injectable with the exception of `ReactCompositeComponent`. 

I've also noticed that a lot of the component injection is spread in different two files: `ReactEmptyComponent` and `ReactNativeComponent`. Neither of these seem like a good place to add CompositeComponent injection.

These injection containers also contain a default implementation for many of their methods which could bloat package sizes if the defaults are overridden as they would likely be for the server.

I would propose to have a `ReactComponentFactory` that contains the `instantiateReactComponent` method and provides the injection for each type of component. Defaults implementations would be provided only by `ReactDefaultInjection`, which would likely also have a derivative `ReactServerDefaultInject`.

This would also allow removal of this circular dependency wrapper: https://github.com/facebook/react/blob/master/src/renderers/shared/reconciler/instantiateReactComponent.js#L24
 My intuition is: now that 0.14 is splitting renderers out from core, it should be easier/better to just have a separate renderer for server side.  A substantial portion of the logic can be simplified/removed, streaming can be implemented, skipping component instantiation becomes a possibility (ok, maybe that one is hard/questionable), etc.  Things that are common to client and server can be moved into shared, and things that are different can be forked.  I tend to like that strategy better than injection/factories, because I find it more difficult to reason about the flow of control with the latter patterns.  That said, I'm curious what @sebmarkbage thinks.
 @jimfb The problem is when you want to fork something in the middle and don't want to fork everything above it.

We do want a system for injections but I would like it to become statically resolved. E.g. through overrides of requires. Then the shared code would be copied into each renderer build (i.e. not shared on npm), then minified and dead-code eliminated as a unit.
 @mridgway The current set up is really ad hoc and messy as part of incremental refactoring. :)

So here's the plan that I'm shooting for...

I would for renderers to be a two layer system:
- The generic React reconciler part (which in turn could be split into a server side and a client side).
- The environment specific part (e.g. the DOM specific pieces, react-native specific pieces, react-art, etc. etc.)

This should make it trivial to target a new imperative API by just plugging in the environment specific parts into the generic reconciler part.

There is currently a necessary cycle between ReactCompositeComponent and ReactDOMComponent because ReactDOMComponent causes a recursion which may lead back to ReactCompositeComponent.

We solve this using a dynamic hacky injection workaround, which is unfortunate for static analysis and VM optimization reasons.

However, that recursion is an implementation detail that we would like to get out of the environment specific logic. I.e. the DOM specific code shouldn't do any recursion. That should be part of the generic React reconciler.

That way the entire cycle can move into ReactReconciler as a unit. No more module cycles.
  ReactTools is deprecated so lets remove it.
 Updated with the complete removal of react-tools. I left a couple of the other changes in-tact and then re-added jstransform and commoner to our devdeps (I hadn't done a fresh npm install to test last time‚Ä¶). We'll get rid of jstransform once we do #4130.
 cc @amasad. If react-native isn't ready to consume react from npm, we could build a new package that is just `src/` (maybe call it react-provides-module or something similarly obtuse). I know there are some other pieces that we'll need for react-native before it's ready - @sebmarkbage is working on that.
 Yea, pretty much. But decoupling the overrides is not completely straightforward.
  I'm not sure if it was intentional, but either way, we aren't going to change this behavior in a point release because it would break things for more people than it would fix.  Sounds like the workaround is to use cloneWIthProps instead, which apparently does preserve context.

Starting with React 0.14, context is parent based anyway, so context will no longer be attached to the element and therefore not impacted by cloneElement / cloneWithProps.
  ![facepalm_227785](https://cloud.githubusercontent.com/assets/8445/7943674/d3d743de-091a-11e5-886e-7da8a028f287.jpg)
  @pwmckenna any more information? Seems to be working in 0.13 and master.

> But what I find surprising is that the validator function gets called twice. I wonder why?

We still validate at both createElement time and render time (since you can modify props after creating the element).
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 Thanks for the PR! Sorry for the long wait‚Äîthe whole approach to this was changing. Now that #5714 is merged, all attributes on SVG elements will be passed through as is, with no need for the whitelist. I'm closing but please let me know if you still have problems with master.
  Thanks for this!

What do you think about prepending "For inputs and textareas, ..." to the sentence, since oninput only applies to those types of controls? Also, this is a super small nit, but can you use an em dash? ‚Äî

@zpao, does this wording seem accurate to you?
 Looks good, please squash commits and then we can merge this. Thanks again!
  This is a really great question for our discussion forum: https://discuss.reactjs.org/, we're trying to keep questions about use there or on stack overflow and keep GitHub for bugs and issue tracking.
  Injecting global event plugins is not a sustainable approach, you're free to reach in and do if you absolutely must but beware of the long-term consequences. There are some brief discussions on this topic in various issues throughout but there has been little movement on this so far.

In the future, please use the community forum for questions.
  Good question. I don't know the answer.
 Mostly brainstorming here, so I'd be curious to hear what the rest of the team thinks (and nothing I say here constitutes an official recommendation).  Personally, I would go with option number 2.

What you're really looking for is a UUID, but you don't want to use random because then the markup wouldn't match :/.

Ultimately, this is the server-side-clock problem (ie. suppose you had a component that rendered the current time displaying microsecond accuracy; the two machines are going to have clock skew, making it impossible to generate matching markup).  Incidentally, since `rand()` reads the clock, it's literally the same problem :P.

When framing the problem as the server-side-clock problem, I think it's pretty clear that you want to have some way of controlling the current time (perhaps you want the clock to be red&green on christmas, and have eggs&bunnies on easter) because you need a way to test this functionality more than once per year.  To write unit tests to verify the functionality, you would need to control the time.

The difference is that, for your component, your need for a unique identifier is an implementation detail not visible to the user, so the dependency on sideways data kinda sucks.  Eeh, not sure what to do about that.

In the near future, you will be able to get around the cumbersome passing-down-props problem by using `context` (actually, you could use it today, but it's officially undocumented and unsupported and subject to change).

In the more distant future, you will be able to use sideways data loading, perhaps in combination with context, to subscribe to external data like the clock.

@jmar777 does that help a little?
@sebmarkbage thoughts?
 @jimfb Technically I think it really just comes down to the need for a facility for centralizing per-root data (and optionally automatically transmitting server to client), i.e. conceptually just a per-root object that everyone can access. Everything else related to this issue (like time, random numbers, etc) can then be implemented in-terms of that functionality, it's really rather unopinionated and flexible.

It wouldn't even have to be strictly exposed by React, you can do this right now, but for a reusable component ecosystem to thrive I think it has to be. One could imagine React providing only per-root UIDs, UIDs, seeds, etc through it's API, but it's _possibly_ too opinionated (but possibly sufficient) and I can imagine many benefits to having a preferred facility for centralizing and transmitting necessary data.
 @syranide I think that's the point/goal of `context`, right?

I suppose context needs to be initialized by the user, so you can't have "first user is responsible for initializing" style code (you need to have a root `ContextProvider` that 'enables' the sharing), but the idea of shared data among subtrees is the intended goal of `context`, afik.
 @jimfb I wouldn't say so, `context` is only concerned with propagation of data, it's not concerned with the source of the data which I think is the real issue here.

To put it differently, this issue seems "trivially" solvable to me (in theory):
1. Write store that provides a static UID per React root
2. Write store that provides a counter per React root
3. Combine UID + counter and you've got a deterministic GUID
4. Initialize server stores with default data
5. Render server-side
6. Transfer markup AND initial store data (only UID, counter is always 0) to client
7. Initialize client stores with transferred store data
8. Render client-side
9. Remember to uninitialize stores when unmounting (per React root) (context probably solves this).

You can do all of this today, but it's cumbersome especially if you isolate it per component and _especially_ if you don't have any kind of framework to help you, each component has to reinvent all the wheels (and also send more data). I'm not saying this exact solution is it or where to draw the line of what React should provide and not. But I think this illustrates the issue, it's already doable, but it's not really realistic.
 @syranide Right, but isn't propagation of data the only thing we are able to handle?  I mean, without dictating the server side architecture (or at least transport protocol), we aren't able to help with the "source" of the data.  The data needs to come from the server (and management of that is the domain of some other framework, like Relay or other).

It seems like we can only reliably solve 5 and 7.  We could maybe solve 9 (and potentially help with 4+7) with sideways data loading.  But I think 1,2,3,4,6 are all far outside the domain of React (maybe in the domain of related projects like Relay).  I'm not sure if React can/should help with anything beyond the propagation of data.

Or am I wrong and/or miss-interpreting your point?  I'm curious which of the above steps you think we should be responsible for handling?
 @jimfb 

> Right, but isn't propagation of data all we are able to handle?

That is the question I think :)

> Or am I wrong and/or miss-interpreting your point? I'm curious which of the above steps you think we should be responsible for handling?

It seems like we're somewhat on the same page. To me it seems there are 4 options:
1. React should not concern itself with this problem.
2. React should expose a per-root UID.
3. React should provide a write-once "initial data" store, anyone can claim a key and store whatever in it (it's up to the consumer of React to serialize and initialize the client-side with the data).
4. React should automatically serialize the data store server-side and initialize the client-side data store.

Looking at that it seems obvious that option 4 is overreaching. It _seems_ to me that this could be considered a basic necessity like `context` in some ways and that option 1 would be detrimental for legitimate use-cases. It's imagineable that option 2 is enough to satisfy the majority of use-cases...

To be clear, you can replace "React" with "Library X" if you want (this is not rocket science), it would be democratic but it seems it would be hurtful to the ecosystem for reusable components. No one wants to deal with "Library X & Y & Z" just because the various components chose a different library even though they all have largely the same basic purpose.

Option 3. Just so that I'm abundantly clear (hopefully), what I'm suggesting is **just the idea** of the somewhat pseudo-code below which is the solution to this issue (and in the context of this discussion, `InitialDataWrapper` shouldn't actually be a wrapper but some kind of React API):

``` js
function getPerRootUID(context) {
  if (context.dataStore.rootUID === undefined) {
    context.dataStore.rootUID = Math.random();
  }
  return context.dataStore.rootUID;
}


var rootUIDCounters = {};

function incrementPerRootCounter(context) {
  var rootUID = getPerRootUID(context);
  if (rootUIDCounters[rootUID] === undefined) {
    rootUIDCounters[rootUID] = 0;
  }
  return rootUIDCounters[rootUID]++;
}


class InitialDataStoreWrapper {
  constructor(props, state, context) {
    this.context.dataStore = this.props.data;
  }
}

class AppWithGUID {
  constructor(props, state, context) {
    this.state = {
      guid: incrementPerRootCounter(context);
    };
  }
}


// Server
var dataStoreObject = {};

var markup = React.renderToString(
  <InitialDataStoreWrapper data={dataStoreObject}>
    <AppWithGUID />
  </InitialDataStoreWrapper>
);

/* transfer markup and dataStoreObject to client */


// Client
var dataStoreObject = /*dataStoreObject from server*/;

var dataStoreWrapper = React.render(
  <InitialDataStoreWrapper data={dataStoreObject}>
    <AppWithGUID />
  </InitialDataStoreWrapper>
);
```

I hope it gets my point across at least (it's total crap code and not correct at all). So again, I'm not at all saying this is the solution (it isn't), I'm just trying to illustrate the utility in there being _something_ like this.

Also, I'm not advocating that this should extend to per-component data (usually associated with model data, Relay, Flux, etc). I'm only suggesting this as a basic utility for allowing components to execute deterministically for the purpose of GUID generation, random numbers, etc.

Just shout if this made no sense at all...
 @syranide Makes sense to me.

There have actually been some talks internally about requiring all IO go through React.  And that things like getTime (and therefore, transitively, getRandomNumber) would count as IO.  I think the idea was proposed mostly for academic purposes (a thought exercise, not a proposal for implementation), but this might add fuel to that discussion.

Suppose we provide a UUID generator, and we provide a time api, and we provide... [we can create a huge list of possible APIs to provide, but how do we know we've covered everyone else's use cases?].  My preference is to provide basic building blocks, from which people can build whatever they want/need.  So the question is: what is the common theme / underlying API that would make it easier to implement these things in user land?  Where does context/sideways-data fall short of what is needed?

More brainstorming: What if we (somehow, magically) allowed a context variable to have a default value.  A component could require a dependency on a `UUID Generator` context variable, which could be provided through context (to allow alternative/overwritten/mocked implementations) or if the variable wasn't on the context stack, defaulted to some shared implementation.  Similarly, the default `clock` context variable reads from the current system time, unless it is overwritten (to manually solve the server-side-clock problem).  Similarly for any other custom datastore that a component could require/desire, a default implementation is available, but can be overwritten to solve unit testing and/or SSR.

Would that be sufficient, if we could somehow make it work?  Or would that not solve the problem?
 > There have actually been some talks internally about requiring all IO go through React. And that things like getTime (and therefore, transitively, getRandomNumber) would count as IO. I think the idea was proposed mostly for academic purposes (a thought exercise, not a proposal for implementation), but this might add fuel to that discussion.

Those are interesting discussions, but I'm curious exactly what you mean by "requiring all IO go through React", what kinds of IO is it referring to? (Or is it in the sense that no data should exist outside of components, like Flux stores does? So all data can be serialized and is guaranteed to represent the entire state?)

...

My replies below are purely gut feeling, intuition and brainstorming :)

> Suppose we provide a UUID generator, and we provide a time api, and we provide... [we can create a huge list of possible APIs to provide, but how do we know we've covered everyone else's use cases?]. My preference is to provide basic building blocks, from which people can build whatever they want/need. So the question is: what is the common theme / underlying API that would make it easier to implement these things in user land? Where does context/sideways-data fall short of what is needed?

The way I see it, if you give me (per-root) **Time**, a **Seed**, a **UUID**  and a way to store per-root local data. With that a component should be able to accomplish any useful deterministic process without requiring any additional data be sent from client to server.

UUID is only necessary for producing markup with GUIDs, which seems like a necessity only because of HTML deficiencies and should not otherwise be useful I think... but it might have other uses.

I think the key point of these features is there is no benefit in having more that one definition/source of each, it's probably only detrimental even. But these are values that have to be transferred from server to client, if React does not provide these then components has to make these demands on other libraries or on the consumer of the component, neither of which seems at all beneficial (because it's redundant, leads to duplication of data and code, inconsistencies, etc).

But **Time**, **Seed** and **UUID** have fairly limited usefulness to reusable components and when those are needed they _could_ be provided on an as-needed basis by the consumer if we want to be hands-off (but UUID is intrinsically useful to some reusable ReactDOM components). So I think the primary issue is that **per-root local data** simply doesn't exist currently, because even if you have **Seed** you're unable to use it for anything stateful because you have nowhere appropriate to store the data without putting explicit requirements on the consumer for making specific per-root data storage available through context (which is a slippery slope from a maintenance perspective).

> What if we (somehow, magically) allowed a context variable to have a default value. 

So yeah it seems to me that (technically) it is indeed a solution to the above lack of "root local data", which is the primary problem. :+1: 

What to do about **Time**, **Seed** and **UUID** is a secondary problem. We may decide not to provide some/all in core, but I think it would be a mistake not to at least make them available as separate "preferred" modules (possibly even just as interfaces). So that reusable components can specify them as dependencies. But again, less of an immediate concern.

PS. I think `clock` must be a function, it has to be on-demand.
 Like I said, mostly academic exercises (we were only half-serious about the idea).  That said, there were a couple of variants of the idea.  What if we didn't allow a component's data to enter/exit the jsvm without passing through React.  Or maybe you manage the layer between the component and the flux store.  The point is: if we manage the IO, React gains a lot of power to do super interesting things.  For instance, if you replay all io since the beginning of time, you can restore (rewind) the React tree to any point in time.  No idea if that would be useful, but it leads to interesting conclusions.

UUIDs have many other use cases.  For instance, suppose (as a result of a click event) you want to create a new data object or a new transaction to be sent to the server.  You want an identifier for lookup or to prevent accidental replays when doing retries.  But if we only allow the supplied `UUID Provider` to be used in render, maybe those use cases vanish.

With regards to making it deterministic... this is potentially the hard part, as component render order is not guaranteed by the React API.  We may (in the not-so-distant-future) start rendering in parallel via workers.

Yeah, clock/seed/uuid all need to be functions/datastores/something-more-complex-than-a-constant.  Especially since they will need to be able to handle things like out-of-order renders, making the naive implementations of things like seed/uuid non-deterministic.

My intuition is that the solution somehow involves a default value for a context variable, but we honestly haven't given it enough thought yet, so I don't know how such a thing would work.
 @jimfb 

> No idea if that would be useful, but it leads to interesting conclusions.

I think it seems like an interesting exercise in determining if there are better ways developers should structure their apps. Perhaps not so much as a future direction for the React API in particular. As I mentioned in the other gist, IMHO the strength of React is how close feature-wise it is to manually wiring UIs without the associated burdens. It even does so without being opinionated. (I know academic, just saying :))

> UUIDs have many other use cases.

I thought about that but I feel like it's an overreach, these UUIDs would be for the purpose of separating React roots (for the benefit of reusable components). So it seems to me that UUIDs for any other purpose than that is outside the scope of React and provides no benefit (communication is not something reusable components is concerned with, they only communicate through callbacks).

> With regards to making it deterministic... this is potentially the hard part, as component render order is not guaranteed by the React API. We may (in the not-so-distant-future) start rendering in parallel via workers.

As far as I've understood it, only `render` can realistically be parallelized. All of the above discussion relates only to life cycle events (where side-effects are allowed) and would be unaffected.

> Yeah, clock/seed/uuid all need to be functions/datastores/something-more-complex-than-a-constant. Especially since they will need to be able to handle things like out-of-order renders, making the naive implementations of things like seed/uuid non-deterministic.

Only clock would be a dynamic value, seed and UUID would be static values per root... although the seed provided to the consumer probably should be mutated per use (so also dynamic) to avoid separate implementations of the same random number generator algorithm producing the same sequences separately.

> My intuition is that the solution somehow involves a default value for a context variable, but we honestly haven't given it enough thought yet, so I don't know how such a thing would work.

Yeah, default value === inject context variable, so it seems like a solution, but exactly how it should be implemented to make sense is an interesting problem for sure (you don't want every component specifying/providing their own default...).
 I've experimented with a solution for making this available through a common interface.

``` js
var ReactRootStore = require('ReactRootStore');

var testProperty = ReactRootStore.createProperty(0);

var HelloWorld = React.createClass({
  contextTypes: ReactRootStore.contextTypes,

  render: function() {
    var initialValue = testProperty.get(this);
    testProperty.set(this, 3);
    return <div>Hello {initialValue} {testProperty.get(this)}</div>;
  }
});

// The root element must be wrapped so the context variable is exposed
React.render(ReactRootStore.wrapElement(function() {
  return <HelloWorld />;
}), document.getElementById('container'));
```

https://github.com/syranide/react-root-store - It works. It's possible the code in the repo has some minor error/bug, I only committed it to get it out there for now. https://jsfiddle.net/tfttkyfm/ JSFiddle with slightly older code, but it works and shows the concept.

This should provide a store that behaves deterministically when going from server to client as it is per-root and not global.
  Thanks!
 Maybe we should add a warning for this too. :)
  @Daniel15 do we still maintain that here or is it all part of https://github.com/reactjs/react-magic?
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 We should ideally try to avoid caching things on these function objects if possible.

One neat feature of these functions is that they don't need a backing instance which could help performance. We also know that they won't have a `shouldComponentUpdate` so we could skip the memoization part.

What if instead of wrapping, you just kept executing it until you get a result that can be instantiated?
 One plausible incremental route could be to fork ReactCompositeComponent and see how far we can optimize that branch.
 This is good progress. You chose a good strategy to unblock yourself. Let me take another look....
 Ping @sebmarkbage 
 @sebmarkbage Do we want this in the 0.14 beta?

@spicyj for situational awareness, since he is cutting the 0.14 beta now-ish.
 @syranide It would be possible to add an attribute later that specifies the stateless function is pure, thus enabling you to make it fast.  We've already discussed using attributes to indicate special properties on stateless functions, so this isn't an unreasonable solution.
 @syranide I think the key difference is that we don't have to instantiate a component instance and don't have to preserve state, which allows for a whole bunch of performance+memory optimizations.  Most importantly, it allows you to use a lambda function as a React component, which is a syntax that allows a whole bunch of patterns that were previously clunky to become practical.
 @syranide Yeah, I'm not saying your alternate syntaxes aren't valid, was just explaining the benefits.  The function syntax is fairly natural, and using attributes to specify special behaviors is also fairly natural/flexible.  If you prefer the fourth suggestion, you can always implement it yourself to append the attribute.  The function syntax doesn't hurt you if you prefer to use a wrapper function instead of setting an attribute.
 Lambdas with attributes are conceptually no different from ES6 classes with attributes.  Both are standard javascript constructs with attributes that are understandable by React.
 @syranide `propTypes` and `defaultProps` are currently used on classes when defining your ES6 components.
 @syranide Maybe I'm miss-understanding something, but what's the difference?

``` javascript
class MyComponent
{
  ...
}
MyComponent.defaultProps = {};
module.exports = MyComponent;
```

``` javascript
function MyComponent()
{
  ...
}
MyComponent.defaultProps = {};
module.exports = MyComponent;
```

They look the same to me.  Define something on your standard-javascript construct, which React understands, for more advanced functionality.
 Right... but it's the same...

``` javascript
function MyComponent()
{
  ...
}
MyComponent.pureRender = true;
module.exports = MyComponent;
```

One could easily imagine the `pureRender` flag which does intelligent optimizations if you specify that your parameters conform to tripple-equals equality.  The details of which options are allowed (and what the defaults are) are still being determined, but the use of attributes doesn't seem like something that would/should be objectionable, since the exact same style is used for classes without objection.
 Ok, cool, glad we agree :).  Thanks for the good discussion!
 @gaearon It's worth noting that the wrapper function can return an element instead of manually invoking the delegate, thereby preserving the original behaviors because the nested component renders independently.  The wrapper can also copy the values from the delegate, thereby exposing those behaviors while avoiding a second component render.  Or the wrapper can expose different behaviors if so desired.  This behavior is the same as HOCs using class based components, and is fully flexible without making assumptions about the propagation of behaviors.  I'd argue that these are the ideal semantics.
 For anyone following along on this issue, an alternate variant of this was merged in #4587 but we might take this implementation or a similar one in a future release.
 We would need to refactor out the part of the initialization that makes it necessary to create a "ReactStatelessOrCompositeComponentWrapper" and avoid the allocation there. If you can avoid the extra allocation we can take it. See `ReactReconciler` for the direction we're going. No internal classes, just function calls.
 We took https://github.com/facebook/react/pull/4587.  At the very least, this would require a ton of work.  Merge conflicts, six months old, this PR is dead.
  I think you want to file this in the fixed-data-table repo: https://github.com/facebook/fixed-data-table
  Thanks!
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 Thanks!
  See #2517.
  More discussion in #1035
  Please post support questions somewhere else, such as Stack Overflow, in the future.
  Seems ok without a helper let's just fix up what I mentioned.
 Aesthetically I prefer `.toLowerCase()`‚Ä¶ :) Fine either way I guess.
 @neojski Let's do lower case. I was always bothered by the fact that it was uppercase in these tests. (Yes, `.nodeName` is uppercase, but conventional HTML markup (including XHTML) writes the tags in lowercase.)
 @spicyj 

> In XML (and XML-based languages such as XHTML), tagName preserves case. On HTML elements in DOM trees flagged as HTML documents, tagName returns the element name in the uppercase form.

Since it's the standard and considering `nodeName` being an enum value of sorts (irrespective of input syntax), then uppercase seems like the correct case if we want to get technical. Also since we really only care about the tag names then perhaps `tagName` is the correct property, not that it really matters.
 Looks great. In src/renderers/dom/client/ReactMount.js we have a `.tagName` check ‚Äì can you change that one too?
 Thank you!
  You listed basically all the options. In the future we might support a syntax like

```
{this.props.condition && <frag>
    <p>Foo</p>
    <p>Bar</p>
</frag>}
```

which wouldn't result in an added HTML element, but there's nothing else to do here now.
  If this is a change that should be made for everybody, please submit a pull request.

If not, then you could modify your version of React or you could specify the value as a string and React won't add `px`.

There is not currently a public method to inject your own properties, and I'm not sure that we'll ever expose one.
  > It is a speciel field that can not be serialized

I'm confused, can you elaborate?
 Yes, but why is that relevant?  What does serializability have to do with anything?
 We generally only document the differences between React's behavior and the web standards.  In this case, as far as I can tell, we are simply conforming to the web standards, so it's not clear to me what remains to be documented.

So in particular: is there a way we are deviating from the web standards that is unclear?
 What does it mean for an input file to be simulated in the virtual dom?

Do you mean: "is it possible to render `<input type="file" />`?"
 We don't call out the `type` prop in particular, because it isn't any different from the web.  We don't call out `type="password"`, for instance.  That block you quoted only call out the ones that are exceptional (`checkbox`/`radio`), the previous bullet point applies to all others.  I think we're being consistent here, and I think it's reasonable to only mention when we deviate from the expectation, so I'm going to close this out.
 I think it might be worth mentioning something. Eg, you can't actually programmatically set the value of a file input which is a pretty big deal - it means you're more susceptible to issues with reconciliation.

You can only read. You also have to read from `node.files` which is just how those work even outside React, but still might be worth mentioning.
  I feel like the more 'correct'/'ideal' solution is to have the fiddle authors update their fiddles. That said, I don't feel too strongly, and will let @zpao make the decision on this.
 Ideal maybe but the correct thing to do is not to bother other people to update their fiddles so links from our blog work.

Thanks @cody!
  Closing in favor of #2127.
  I feel like the more 'correct'/'ideal' solution is to have the fiddle authors update their fiddles.  That said, I don't feel too strongly, and will let @zpao make the decision on this.
  cc @sebmarkbage
 cc @avikchaudhuri Does this make sense to add as a propType, and therefore to Flow's React bindings? Does this implementation map to the Flow semantics for intersection types? Especially for shapes.
 cc @gabelevi same question
 https://github.com/Microsoft/TypeScript/pull/3622
 I‚Äôm closing because we have been treating PropTypes as being in maintenance mode for the past year. We don‚Äôt plan to add any new features to them, and we encourage you to try using Flow or distribute third-party prop types as custom npm packages.

Thank you for sending a PR! We hope to see you contributing again. I suggest you to raise an issue to discuss any significant changes or changes to the public API before spending time to implement them because API and code review are two separate activities and it‚Äôs best to agree on API (or even intent) first.

Cheers!
  See #2517
 Well currently the broadcast pattern can be implemented as wormholes as well. It's just more boilerplate, which might be ok if it is rare.

`shouldComponentUpdate` currently takes all your inputs (props, state, context). It is used to determine if any of your inputs changed in a unified way. This includes `state`. Then `getChildContext` get called IF one of the inputs changed. This means that a parent component already has the ability to stop child context from updating.

Any parent component that doesn't provide this context cannot intercept it with neither `shouldComponentUpdate` nor `shouldUpdateChildContext` so they're irrelevant.

The only benefit `shouldUpdateChildContext` provides is a way to update your props without updating your context. However, shouldn't you then be able to update your context without updating your props?

We don't allow you to make fine grained `shouldComponentUpdate` on a per prop level. It seems like this kind of fine grained optimization is better suited for generic subscriptions like Stores, Observables, etc. We generally avoid that strategy and optimize towards very coarse grained update strategies rather than fine grained subscriptions by default.
 @sebmarkbage Since children is a prop, this would mean that the ContextProvider (which is presumably a parent (but not an owner) of a very large subtree) would return true any time anything on the page changed.  If context is assumed to have changed on every rerender, this means the ContextProvider effectively has no way of opting out of the context change, since it needs to update because the children have changed (ie. we don't want to notify all the context recipients deep in the tree, but we must).  I think the common case is that the context does not change but the children prop does change and thus a render needs to happen but we don't want all the recipients of the context variable to start rerendering themselves.
 I‚Äôm closing in favor of discussion in #2517. We are cleaning up stale PRs. Also, there are plans to significantly change the core (#6170) so this will probably get less relevant in a few months. Definitely the issue is still there, but how we approach or implement the context internally may change.
  Look like the result of not creating the element in the right place, we even have a comment explaining that this might happen. https://github.com/facebook/react/blob/master/src/shared/vendor/core/getMarkupWrap.js#L29-L30. I think we just need to add `tspan` in there.
 We should be doing the right thing now (shipping in 0.14). `tspan` is on the list - https://github.com/facebook/fbjs/blob/master/src/core/getMarkupWrap.js#L82
 It's the same. Your example works with 0.14 rc.
  After #3968, the next thing we should do is start linting our tests. Historically we've ignored them due to lack of parser compatibility. But that shouldn't be a problem anymore. We may want to integrate https://www.npmjs.com/package/eslint-plugin-react to more aggressively lint our JSX in tests.

cc @PiPeep 
 Indeed. We have the benefit that we don't have to worry about anything internal yet so we can be more flexible :)
  Fixes #3958.
-   Removes esprima-fb dependency
-   Tightens up eslintrc with some minor rules we were pretty-much following anyways.
-   Adds pretty colors to the `grunt lint` output
-   Breaks `block-scoped-var` :cry:

@hzoo, insight into/thoughts on the ~~`no-empty`~~ and `blocked-scoped-var` rules would be helpful.
 It would be nice if we didn't need to put comments in our empty `catch` blocks.
 @spicyj, @zpao seemed iffy on it too. I'll go ahead and revert that bit.
 @hzoo, But does "cannot be used before it is defined" include

``` js
function foo() {
  console.log(a);
}
var a = 3;
foo();
```

I think it's breaking on that type of pattern when it shouldn't, as `a` isn't actually used until `foo` is called (I believe this is a case of late binding, not hoisting).

Regardless, it seems like `block-scoped-var` is duplicating functionality of `no-use-before-define`.

If there's no easy fix, we can leave it disabled for now, and maybe add a custom rule later, or fix all the ~100 places in our code it finds.
 Let's disable the rule for now. It is interesting that the same code that's failing here with babel-eslint does not fail when using esprima-fb (nor espree IIRC).
 :thumbsup: merge when ready
 Rebased and squashed onto master.
 Note: pushed with 58fb322e211614ffb4fc6a8228e96e93c5ea65dc
  Looks good. Thanks!
  @gaearon Yeah, guessing is even trickier than that, because render could create multiple copies of elements (either in a loop or via a helper function), resulting in distinct elements, even though they were created in the same "location" in code.

@dantman I think your best bet (at least medium term) is going to be to hoist the component state up above the tree (rather than relying on component state).  See https://github.com/facebook/react/issues/3653#issuecomment-92526513.  That will, in general, solve the re-parenting problem from a correctness point of view.  Then, the only remaining 'issue' is performance (re-creating DOM instead of re-using the 'moved' markup), but React is pretty fast and I'm guessing that isn't too much of a concern.

@dantman The change is the addition of the divs in the else block of the render function.  @vkurchatkin is correct that this should preserve the DOM shape/structure, thus allowing React to better figure out what's going on during reconciliation and re-use the structure.  His change is subtle, but correct.
 I'd just like to point out that you can do reparenting manually today, if you render the component you want to reparent into a separate non-React node, this node can then be reparented manually anywhere you like (but remember that you may only put it in empty React nodes).
  It would be nice for the [Forms doc](https://facebook.github.io/react/docs/forms.html) to be more explicit about the fact that React's `onChange` supersedes, and should generally be used in place of, the DOM's built-in `onInput` event. People might be used to using `onInput` instead for text inputs and textareas, since, with the raw DOM, the change event for these controls doesn't fire until the control loses focus.
  I see it's already removed from the sidebar:

https://github.com/facebook/react/blob/master/docs/_data/nav_docs.yml

Maybe we should just leave this page as just the NOTE linking to classnames so we don't break old links?
 Yea, let's do what Ben said (this is also what I suggested in the other PR). We do have an fb.me link pointing there so we should try not to 404 it.
 Note added already in another commit.
  @murashki There's more planned to alleviate the issues around unknown elements and properties, but we're not there yet. We have no plans on to use different syntax.

Adding the additional attributes here seems totally reasonable.
 It's even easier than that since we don't really have tests for the attributes. But do actually test in a couple browsers that changing values across renders is reflected appropriately (usually the issues is property vs attribute).
 Yea. I usually just make a simple component with a button that toggles state so I can test with multiple values easily.
 Those are used to determine if we do `node.challenge = newValue` or if we do `node.setAttribute('challenge', newValue)` when updating. `null` means it doesn't matter and browsers should work with either. Currently we use properties in that case but we may switch that in the future. `MUST_USE_*` indicate that they must be set & removed as a property or an attribute.
  Are you sure this is how it works natively? I wouldn't expect this to have changed in React. PS. Also, why would you do it like that, React component should never need to query the DOM like that.
  We're a few versions back, it would be good to get all upgraded. There have been a few changes to rules which are a bit annoying so we'll probably have to tweak the configs / make a few changes to code.

cc @pipeep
  Unfortunately, we don't have a good way to fix this. See discussion at #1782.
  looks fine to me, but @zpao or @spicyj should be the POC for this one.
 I actually think we should ultimately just delete this page, not update it to be documentation for another module (which will and has changed).

I think the right move for 0.14 is to delete any links to this page and remove most of the content, leaving pretty much just the note with a link to the other module.
 +1.

We can also remove it from the sidebar.
  Yea, this is what happens with UMD, which is what our browser build uses. If you're using require.js then you need to do that across the board and `require('react')` instead.
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Closed with #4157
  Back in the day, we had a bunch of D&D fans on the team.

For reference:
http://www.dandwiki.com/wiki/SRD:Scrying
http://www.dandwiki.com/wiki/SRD3e:Scry_Skill
https://en.wikipedia.org/wiki/Scrying

Historically, we've used scry to indicate a helper that finds a set of results.  As the framework matures, we should start choosing function names based on what the functions actually do instead of fantasy words that have very little meaning to the typical developer.
  :+1: http://www.w3.org/TR/html-media-capture/#the-capture-attribute
 @syranide can you explain what is the difference between `MUST_USE_ATTRIBUTE` and `MUST_USE_PROPERTY` and why for example `checked` and `multiple` are `MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE` and `capture` should be `MUST_USE_ATTRIBUTE | HAS_BOOLEAN_VALUE`?
I don't see any difference between [`input type=text`](http://www.w3.org/TR/html-markup/input.text.html#input.text-interface)'s, [`input type=checkbox`](http://www.w3.org/TR/html-markup/input.checkbox.html#input.checkbox-interface)'s and others' attributes which are `MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE` and [input's capture](http://www.w3.org/TR/html-media-capture/#the-capture-attribute) attribute
that's why I made [PR](https://github.com/facebook/react/issues/3949) where capture is `MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE`
 @chicoxyzzy Some only exist as HTML-attributes whereas some also exist as JS-properties. I assume `capture` is a JS-property too, but since React is rather naive in this area right now it does not recognize that older browsers have no concept `capture` and thus have no JS-property for it. So it's only setting the attribute that works consistently cross-browser (it has no effect, but keeps the DOM correctly synchronized).
 that makes sense. should I close #3849 ?
 @cody have you tested this in a React component that changes from true -> false & vice versa to ensure the DOM gets updated appropriately?
 :thumbsup: Thanks for testing! Should be good to go then.
  Looks like you answered your own question. Closing out.
  Going to close and just point at #1657 where we're tracking discussion about SVG
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 It's correct as it is, props can change over time and that's why you may want to store some of them in state, so you still have a reference to the initial/previous value.
  This should guarantee that the hidden class is the same after inlining.

(blocked on killing prop mutations)
 @yaycmyk Yes, sorry ‚Äì I meant that we needed to clean up some stuff internally that was still giving mutation warnings since the last release. I think that's all cleaned up now so this can go in.
 My primary motivation for pushing for this change was #3226, which isn't possible if you allow mutation. But this also fits into a longer-term vision where JS has custom immutable value types that don't have real object identity and are compared by value. The language already has immutable numbers, booleans, and strings; the ReactElement type can be thought of as similar to those.
 @syranide The problem is that we can't reliably freeze them "later", since they're passed as children, props, nested inside of other objects, captured in closures etc.

There are languages that guarantee that an objects is frozen once it leaves the scope. JS is unfortunately not one of them. It makes subtyping difficult to reason about in type systems too. It's just more complex to reason about. It's simpler to just let things be born frozen, and we haven't really had a lot of complaints about this warning in 0.13.
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 Can you clarify a bit what you're expecting to work that isn't?
 Makes sense! Flagging it for merge but looks like there are some Travis problem.
 Looks like Travis was just the webworker test. Thanks @troutowicz!
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 lgtm
  We try to keep our API changes to a minimum and provide deprecation notices when we can. We don't have a hard timeline on releases, instead waiting until we have something more meaningful to provide. Typically we've gone a few months between 0.x and 0.y.
  #2533 has an in-depth hard-to-follow (partial) discussion on the subject.

The truly proper way to reset values is to set to an empty string, not null. The reason inputs reset is because they reset internally due to becoming uncontrolled, whereas textareas keep the last value (both should have the same behavior, but it's not behavior you should rely on like this).
  :thumbsup: thanks!
  jQuery loads the data values and then caches them. Try `.attr('data-page')` instead.

Also, please post support questions like this on Stack Overflow in the future; this tracker is for bugs in React.
  See, this is why we break private stuff ‚Äì to get you all to come and write about the APIs you're missing. :)

@sebmarkbage 
 Technically it is still there, just moved a level deeper. Feel free to update the hack. Checkout ReactInstanceHandles. In fact, Relay is even using this hack for this very purpose. It is not perfect though because this ID doesn't contain the full key path. Only the path between rootNodeIDs. We also want to move away from using composite IDs which is expensive. Instead, we'd use a key tree + potentially a counter for event listeners but those are implementation details that we don't want to expose.

However, this use case is definitely in scope. We are thinking of a few public APIs to solve similar things:

1) We want to provide a way to externalize the state tree. We're moving towards this model for the internals. Not sure about the representation. This is probably more long term in terms of public APIs.

2) Short term we want built-in support for "rehydrating" an state tree. This use case is a way to save memory by cleaning up the component tree but keeping its state in memory. E.g. while a view is offscreen, between page transitions (forward and backwards) and master/detail view where you switch between different detail views.

3) Longer term we might add a serializable form of 2.

4) These three options only exposes state, not the component tree. This is because we want the component tree to be transient or non-existent in memory. E.g. a plain stateless render function shouldn't need a backing store. It's just a transformation. However, for things like tooling we want to expose the whole render tree for introspection, as a public API. E.g. for building react-devtools. For that use case we would attach an external tool to a running React instance and maintain an external component tree. This is not for production purposes but would be able to connect to a production instance of React.

That's the plan right now in terms of public APIs. Is that plan satisfactory?
 Closing this out for a broader discussion in #4595
   Thank you!
  It should be `MUST_USE_ATTRIBUTE` as it's not supported by every browser.
 cc @jimfb - not sure what the state of web components support is, but let's make sure this fits into the general plan.
 @zpao I think this is fixed automatically by https://github.com/facebook/react/pull/3067, right?  Are we ready/willing to accept that one, I can rebase, just let me know.
 @jimfb This attribute is for regular elements, not (only?) web components (#3067).

```
<button is="taco-button">Eat Me!</button>
```
 @Wildhoney The code I pasted is from the W3 TR above.
 Ok, I think you're right, looks like this can be applied to standard DOM elements.  I'm fine with moving forward with this diff, pending approval from @zpao et al.
 @Wildhoney  I think there is a merge conflict.  Can you rebase?

@zpao @spicyj This looks good to me.  Any objections to merging?  Let me know!
 Good with me.
 Can you squash your commits together?
 Try doing a git rebase -i origin/master and then delete all lines but the one commit where you actually added it, then you can force-push to the same branch to update this PR.
 When you're done, the Commits tab here will have only one commit.
 Thank you!
  This looks handy and the failing test is an unrelated web worker test, probably being flaky. Thanks for this PR @laskos and sorry for the lack of response here. If you're still interested in getting this merged, do you think you could produce a version that's rebased on current master?

Also, `array.some` should be safe to use.
 Eventually we'll move away from string refs so this PR is a nonstarter. I would recommend using a data-testid prop or similar, but this is easy to implement in userspace so I don't think we'll add this to the test utils for now.
 > Eventually we'll move away from string refs

Eventually we'll all be dead. In October 2014, I didn't implement ref support for shallow rendering because of murmurings that a new API for refs was coming. A year passed and there's no sign of that new API. Can't we accept test util PRs that are useful now?
 What do you mean "there's no sign of it"? We implemented callback ref support. We haven't deprecated string refs yet but we will.

> Can't we accept test util PRs that are useful now?

No, we won't merge things in that only make easier patterns we don't recommend, can easily be implemented in user space, and will cause more pain for anyone using them in the next release or two.
 @graue https://facebook.github.io/react/docs/more-about-refs.html#the-ref-callback-attribute
 Ah, sorry, don't know how I missed that.
  This is because `setInterval` now refers to the function itself, instead of the global setInterval. Filed https://github.com/babel/babel/issues/1598 upstream.
 (Autobinding still works, but then this.setInterval calls setInterval (itself) again without context and you get the error.)
  Props in state is not anti-pattern _if_ they're intended serve as the initial state of a stateful component (say, you may not want the content of a textfield to update while it's focused). Another exception is if you need to perform expensive computations on the data which you may not want to repeat, then storing the result of those computations make sense.

But from what I can tell from your example all you're doing is mirroring props in state and I have no idea why that would be anything but a bad idea.
  cc @salier :) ‚Äì What should we do here?
 I think we should not fire `onChange` until the IME string is committed.

One way to handle this in `ChangeEventPlugin` would be to ignore all `input` events between `compositionstart` and `compositionend`, then use the `input` event immediately following `compositionend`.

I did some quick testing on OSX Chrome and Firefox with Simplified Pinyin and 2-Set Korean, and the event order and data seem correct enough. (I predict that we'll have problems with IE Korean, but we may get lucky.)

I think we may continue to see issues with alternative input methods like the Google Input Tools extension, but there may be workarounds for that.
 None currently ‚Äì this is not a high priority for us right now. I'd be happy to look at a pull request if anyone dives into fixing this.
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 Thanks @jamischarles!
 @lili21 Sorry this slipped through the cracks. Do you mind rebasing over the latest changes (`git pull --rebase upstream master` probably)? #4208 will conflict, not sure if anything else will. After you've done that, let me know and I'll merge this. (I don't get a notification when you push updates.)
 Squashed and merged in 63d0471 ‚Äì thank you!
  Thanks for the reminder! I had this and other updates in the 0.13-stable branch, which I just cherry-picked over. https://github.com/facebook/react/compare/f1cfd29e7ea0...924328b436ee
  Internally, there has been serious discussion about exposing an API that allows data reads and writes to be tracked, as an alternative to the Observe API proposed a couple months back.  This new API allows React to automatically track a component's dependencies, thereby allowing React to efficiently re-render a component when one of the dependencies changes.  Usage is a little more intuitive (and a little more flexible) than the Observable API (also more intuitive if you are using Observables, see https://github.com/facebook/react/issues/3858, so it's a win-win), but since the data bindings are tracked automatically, it's a little less explicit.  For anyone following along at home, take a look at the unit test in this commit for example usage.

Posting this commit/PR mostly to continue/inform the discussion.  We aren't ready to merge this quite yet, as the final disposition of this API proposal is still undecided.

Fixes: https://github.com/facebook/react/issues/3858
 why not to move `observeRead` and `observeWrite` to `ReactDataTracker` module? This way we'll be able to import only `ReactDataTracker` without the whole `ReactWithAddons`

``` javascript
    import { observeWrite, observeRead} from 'ReactDataTracker';    

    class Person {
      constructor(name) {
        this.setName(name);
      }

      setName(name) {
        this.name = name;
        observeWrite(this);
      }

      getName() {
        observeRead(this);
        return this.name;
      }
    }
```
 also possibly it'll be better to [take](https://github.com/zloirock/core-js#custom-build) [`map`](https://github.com/zloirock/core-js#map) polyfill [from `core-js`](https://github.com/zloirock/core-js/tree/master/es6)
 @chicoxyzzy Good question.  The answer is, you can import only the ReactDataTracker without the whole ReactWithAddons!  The methods you will want to look at are `startRead`, `endRead`, `startWrite`, and `endWrite`, all of which are provided by the ReactDataTracker (to be called before&after reads&writes respectively).  The start and end methods are actually a little more powerful/flexible (though a tiny bit more complicated to use).  If you call multiple startWrites before the final endWrite, then all your writes can be batched together, so by using the `ReactDataTracker` directly, you actually get a little more flexibility/control/power to optimize performance!

The implementation of `observeRead` just calls `startRead` and `endRead` immediately after one another, similarly for `observeWrite`.  The reason for adding only two observe functions (a read and a write) to the addons was purely to make the usage a little simpler (less error-prone).  They are absolutely trivial to implement in your own code, if you decide to use the ReactDataTracker directly.  Keep in mind, however, that ReactDataTracker is currently internal API.  We may end up exposing these APIs for a final release (tbd, primary use case would be to support data binding transforms that users might want to apply to their datastores).

Re: core-js polyfill, good advice.  I'll look into it and may update the diff.  We may end up scrapping the polyfill altogether in favor of expando props, so I'll sync with Sebastian about this before churning the diff too much.
 @cody Great question!  The answer is that it does the expected/desired thing.  Multiple invocations of `observeRead` are deduplicated appropriately.  Functions can be called recursively, can have intermediaries, etc.  It all just works.  Also invoking `observeRead` outside of a render/reconciliation is effectively a no-op, exactly as you would expect.

So you can have your component render function call a helper function like this:

```
function calculateChecksumOfName(person) {
  return MyMd5Library.calculateChecksum(person.getName());
}
```

React will still detect the dependency on `person.getName()` and re-calculate the MD5 checksum when the person's name changes.  And you can also use this function outside of React (in your other code) with no problems.

This means that in your getGreeting() function, you don't need to call `observeRead`, because the read will be observed when `getGreeting()` calls `getName()`.  But of course, it's not a problem that you did put an `observeRead` there!
 Yes, `person` is just a native example.  In practice, you would likely be firing reads and writes on data that was loaded over a network and managed by a flux store.  You should still use props and immutable data whenever possible/practical, but in real world apps, sideways data loading is sometimes necessary (see the motivation for the observable api, which this new api could supersede).

Yes, the `start` and `end` variants of observe read/write do intend to optimize performance by allowing the system to do batching.  Since these low-level functions are difficult to use by hand, we currently only expose the higher-level `observe` variants.

The ability to transparently/seamlessly change the granularity is one of the advantages of this API.  Flux store implementors can observe reads/writes at any granularity.  As long as they are consistent with regards to where they fire reads and writes, the implementor can choose to fire them at the store level, at the 'root lookup node' of some immutable data, or at an individual element level.  They can change their decision at any time without affecting the implementation of components that depend on those stores.  This plays nicely with immutable data and allows you to observe anything that is mutable.  Datastore implementors can change the mutable/immutable boundaries without changing their public/component API.

This API is intended to be easy enough that a user _could_ use it by hand, but the long-term hope is that they would use a data library (analogous to an immutable data library like immurablejs), or that they would use a javascript transform to enhance their datastore code.  Internally, we have a transform demo that finds all classes which extend a particular flag class, and automatically adds the calls to startRead, endRead, startWrite, and endWrite.  Using the transform makes your code ultra-simple, but is also a little magical, so we are unopinionated and users should do what makes sense for them.  It is similar to JSX, in that you get some fancy magic if you use a transform, but you shouldn't feel obligated to use a transform.
 Some extra context: this is analagous to how Relay works.

GraphQL and Relay represent application data as a cyclical graph, because objects in a system are typically interconnected (ex: a user can be the author, liker, and commentator of the same story). But you can't _directly_ represent a graph as a persistent data structure: a single change invalidates the whole graph and little memory can be shared. If _nothing_ is shared between the old and new version of data, there is no way to know what actually changed and what didn't. By extension, there's no way to write an efficient `shouldComponentUpdate`. Ex:

```
// Previous data:
user: {
  name: 'Joe',
  posts: [...],
  friends: [
    {name: 'Jim'}
  ]
}

// New data (friend's name changed):
user: {
  name: 'Joe',
  posts: [...],
  friends: [
    {name: 'James'},
  ]
}
```

At first glance it might appear that `posts` would be unchanged, since only the friend's name changed. But it's a graph, so _all_ the objects are new. There is no way to know whether the name change affects those `posts` are not; we would have to re-render everything and find out.

The alternative is to record the list of record IDs that were read during the course of rendering each component, set up a listener at each component for any changes to its set of read IDs, and update the component when the data for those IDs changes (eg via `setState`). Components whose listener did not fire can return `false` in `shouldComponentUpdate`, and the render time becomes proportional to the changes.

That's (in part) what this proposal is about.
- Note that the alternate, indirect graph representation is a self-referential Map of IDs to Records, where records can link to one/many other records. While this approach allows for immutability & structural sharing, it does not solve the above problem, because we still don't know what part of the graph did and did not change.
 cc @gaearon ^^
 @cody No, if you don't use this feature, there is no overhead.  Certainly nothing that could show up in any measurement.
 @kevinrobinson Relay can flatten the graph because React components will ultimately form a DAG, but then the problem becomes: "how do you know which DAG nodes to update when the source data changes?".  It turns out to be the exact same problem as knowing which components to update.  Also, in the more general case, you can't flatten the data ahead of time unless you know how deep the component hierarchy is going to look (something that is impossible to know for a general React app).

Regarding serialization of cyclic graphs: Json does not directly support cyclic graphs, but it is possible to implement your serialization on top of json, or using your own protocol/format.  Either way, cyclic data is actually pretty common in large applications.

Performance is always a consideration.  For instance, internally, we are working on an animation API that allows React to render super smooth animations.  This is not possible without super high-performance bindings.  But having said that, performance is not the primary motivation for introducing this API; please take a look at the related issues (https://github.com/facebook/react/issues/3858 and https://github.com/facebook/react/issues/3398) for background/motivation information.
 @kevinrobinson Wow, you've really been following along and keeping up with all the technologies!  This is a great discussion!

You are correct that each component does give (via GraphQL) this exact information to Relay, but incorrect in your assertion that this happens at render; it actually happens statically before the first render, thus allowing Relay to pre-fetch all the information that the component could ever need.  As a result, some perfectly legitimate apps can't be described using Relay (eg. a recursive TreeView, where each node is a person and the nodes can be expanded to see the person's friends).  Our goal with this API is to solve the Relay use case, but also to provide a more general solution (eg. allow for apps like a recursive TreeView).  This is what I was implying when I said that you would need to know "how deep the component hierarchy is going to look".

One could argue that this limitation could be overcome by doing as you originally suggested, computing the query at render time.  And this is true, but... suppose you did generate an immutable DAG representing your data as needed by a component.  Now suppose your underlying data changes, and you need to provide a new DAG; how do you update the DAG?  You want to re-use as many DAG nodes as possible, in order to preserve triple equals equality and thus a fast re-render, so you can't just re-generate the DAG.  What you really need to do is track which parts of the DAG need to be "fixed" as a result of the data change... but... that's just as hard as figuring out which components need to be updated.  In fact, it's actually the same problem, wrapped in a different box.  Rather than have each user of React re-implement the same diffing logic, we can use this new API proposal to allow React to figure it out for you!  (As an added bonus, by having React do the diffing at the component level, you can automatically avoid re-rendering all the parents of the modified nodes).

@cody Yes, the final implementation will change substantially before this is ready to be merged.  The source code of this PR is mostly for API demo purposes.  The comment in ReactDataTracker (right above the first usage of the Map polyfill) explicitly calls out the perf ramifications of using Map (see the first bullet point in that comment).  A final implementation will not have a Map polyfill in the hot codepath of render for components not using this API.  I can assure you that the performance impact of this API for components not using the API will be asymptotically close to zero before this code ever ships/merges.
 @jimfb - I couldn't have explained it better myself!

@kevinrobinson thanks for the great questions! @jimfb covered just about everything, but a couple extra notes: My comment above was just to illustrate the problem - ultimately, in a cyclical graph when _one_ thing changes, _everything_ changes - and it isn't meant to describe how Relay actually stores data or provides it to components.

One of the design goals with Relay is to make it so that applications do not have to worry about the data representation or efficient updates; we push this complex work into the framework. The internal data representation is abstracted away (so that we're free to store data however is most efficient) and the data provided to components is opaque: we guarantee that it will match the shape of the query fragment. Whether we provide a circular data structure or a DAG or something else doesn't matter to the application because the contract is the query format. 
 @kevinrobinson In Relay, a component's data needs are specified as a query, and the query may specify deep dependencies based on data (example query: "for each news feed item, get all comments, for each comment, get the author, for each author, get the name and profile image").  Obviously you need to know who commented in order to know which profile images to fetch, but that's why the GraphQL queries are so expressive.  And yes, a component needs to fetch all the data for any branch that it will take in render; the programmer needs to figure that out in advance (it is not automatic).  That was one of the design decisions made in Relay.  But let's move this tangential discussion to another thread; the details of Relay aren't required for an understanding of this API.  The key insight is that when underlying data changes, determining the ramifications of those changes on the component tree is non-trivial (and that's what this API aims to fix).

@leebyron Absolutely, great points!  Regarding API: In general, I totally agree, it's great to be able to push code into user/library space whenever possible.  In this case, however, we thought it through, and there are several reasons we would want this in the core instead of user/library land.  One of which is that by managing subscriptions internally, the "side effects" are an internal implementation detail (we keep our options open to refactor later and make the entire core immutable and render pure).  Another is that there are optimizations we can build into the core, which are not possible if this is implemented in user-land.  Jordan made an internal fb-only post a few hours ago (about timer propagation), which is worth reading.  Another is that we might want to use this functionality internally (for things like context? pruning) which would require that this functionality be in the core anyway.  In summary, we want to push things into user/library land whenever possible, but it was a conscious design decision to expose this higher level API instead.  Feel free to grab me and Sebastian if you'd like to discuss more.

@swannodette points out that he has written this same logic multiple times.  Internally to Facebook, we've also seen this exact logic implemented several times (Animations, Relay, etc).  That's exactly the motivation behind this API (it is a pattern we see people implementing over and over again, and it's difficult to get it right/optimized).
 @leebyron Yeah, I agree, that's ideal, just don't know how to do it without disrupting our other/future plans.  With regards to the dependency on long-lived object references... this is easily solved by emitting reads/writes on whomever manages the data (eg. datastore) instead of the actual immutable data objects themselves.  This shouldn't be incompatible with immutable in any way.  But yeah, let's chat more when you get back!

@swannodette True, any system which tracks dependencies outside of React wouldn't benefit from having React track dependencies (sorta self-evident).  In that sense, this API is no better or worse than the alternative `Observe API` (for your use case; both proposals are semantically equivalent in this way; they both allow components to respond to a new-data event).  But as I mentioned above, there are reasons we don't want to expose this as a lower-level hook.
 @kevinrobinson Yep, absolutely.  That's a completely valid alternative API (semantic derivative of what Lee was proposing).  The issue is that `externalTracker` and/or `wrapperFunction` require external mutations and are therefore impure (ie. render performs mutations external to React-core, so we can't refactor React to use immutable/workers without breaking those APIs).

By having React control the subscriptions, all side effects are internal to React (therefore, React can undo them or choose not to apply them, or whatever).  `render` remains, conceptually, pure.  This is important because many of our experiments and planned future work will revolve around making the core immutable, rendering in workers with immutable data, aborting renders part way through, etc.  This is not possible unless `render` remains pure and side-effect-free, at least from an external perspective.  Those alternatives were rejected for this reason, and other related reasons that prevent core level optimizations.
 @mweststrate Yep, saw it, and read through the docs.  Although I haven't played with MOBservable, I agree it looks pretty similar to this proposal for React.  I would even go so far as to suggest that the implementation is likely be better than this proof-of-concept implementation, which I wrote up in a few hours (we would fix our implementation before a final release).  Conceptually, I agree with you 100%.  However, there are reasons such an API really needs to be supported by the React core in order to work efficiently/correctly.

The problem is: either you need to do subscriptions in advance or lazily.  Let's explore both options...

If you do subscriptions in advance: you necessarily must oversubscribe to your data, since you need to subscribe to anything you could ever need to read in render.  You often get into situations where virtually every component on the page is subscribing to almost everything, and now you're back to where you started (slow performance).

If you do subscriptions lazily: you can solve the oversubscription problem, but now you need to change your subscriptions on the fly based on which mobservables your component is reading during render.  This works (it's the solution used in this RFC/PR) but it means one of two things:
  * You are mutating state during render (which is against the rules of React `render` because React requires that `render` remains pure).
  * You are the React core, and managing subscriptions transactionally within the core.  This allows all 'side effects' to be within the core.  Having the subscriptions within the core is mathematically equivalent to having render return the set of subscriptions.  Therefore, render remains pure as per the API rules, and everything works.
This is why such an API, if supported, MUST be supported directly by the core.

MOBservables is a super cool proof of concept, but it is necessarily insufficient because it is only possible/legal to do dynamic read subscriptions if you are the React core.  I encourage you to continue iterating and exploring the area, because we pull a lot of our inspiration from the community's work.  Having said that, if this is a style you'd like to see us support, let us know so we can prioritize it!
 @jimfb We've talk about an issue internally about how could you use this API to stop listening to a data source based on its value? What's the alternative solution when you can be sure you're not going to need the value anymore? E.g. the timer / alarm scenario. I guess you can never be sure since you should be able to do time travel etc. unless something in state changes.
 @sebmarkbage Yeah, I think that you solve that the same way you would solve this if it were standard javascript and you wanted to stop reading from a stream.  You need to have some state variable to indicate when you're done.

For a timer/alarm/server-subscription, which requires an imperative unsubscribe, I think we'd just use a wrapper like in https://github.com/facebook/react/issues/3858 to be notified of the unsubscription and imperatively dispose of the subscription.
 It appears that there was no consensus on this. I‚Äôm closing as we are trying to avoid stale pull requests and be more decisive, and discuss in the issues instead. Please feel free to continue the discussion in #3858.
  We've gone back and forth on this; there are benefits to both. This would solve the case where you're setting your state based on your current `this.state` value, but not if you also read from props. See this comment:

https://github.com/facebook/react/issues/122#issuecomment-81856416

Instead, our recommendation is to use the function form of setState so instead of

```
this.setState({
  alarmSet: this.state.alarmTime > 0 && this.props.elapsedTime < this.state.alarmTime
});
```

you write

```
this.setState((state, props) => ({
  alarmSet: state.alarmTime > 0 && props.elapsedTime < state.alarmTime
}));
```

We're not planning to change this anytime soon; any improvements will probably be along the lines of making the APIs more functional to support this better.
  If you're using the NPM-version (unbundled version) of React then you can use the following workaround for now https://github.com/facebook/react/issues/2713#issuecomment-67462102. Else you'll need to dig into the React bundle and replace `data-reactid` with something else, say `data-reactid2`.
 React 15 RC2 no longer uses `data-reactid` on the client (unless you are server rendering) so it is probably no longer an issue. If it still is, please provide a reproducible example on JSBin. Thank you!
  Yea, events are pooled. Probably some changes in batching resulted in the difference you're seeing, but either way, we reset the `e` object you're using so it's not really safe to just pass it around.

Changing your setState to copy properties off of `e` will make this work. `this.setState({deltaX: e.deltaX, deltaY: e.deltaY})`
  Where is this linked from?
 Found it :), thanks for the heads up. Will sync that to the site shortly.
  I think just the one comment and then could you rebase (we had a bunch of files move and lint changes in the last 2 weeks)
 :thumbsup: looks good.
  The WebWorker test seems to have gone flaky again, nothing to do with you :)

@graue, you're most familiar with shallow testing, can you take a quick look?
 Thanks, looks great! Just two minor issues.
 Could you squash the commits and then we can merge this.
 Thanks!
  `this.props.children` will contain ReactElements, not DOM nodes. If you would like the actual DOM node you will need to assign a ref and use React.findDOMNode so that you can access it after the DOM has been mounted. See http://facebook.github.io/react/docs/more-about-refs.html
  buttons are `type="submit"` by default in HTML, and pressing enter simulates a click on the button. This is standard HTML behavior, not specific to React.
  Looks like it's probably the phantomjs version not being compatible. We're using 1.9.x.
 Not sure. We use https://www.npmjs.com/package/phantomjs, which will install a local phantomjs or fallback to the system one. I'm surprised that it doesn't complain about versions. I just tried with v2 installed and it seemed to still install a local copy. Forcing it did show that it detected the global version didn't match what we expect.

```
% node ./node_modules/phantomjs/install.js
PhantomJS detected, but wrong version 2.0.0 @ /usr/local/bin/phantomjs.
...
```

Running `grunt test` after that didn't have any issues (but it didn't before either)
  :thumbsup: thanks!
  React has a custom module system which needs a build system. This is why none of the `require`s inside `src/` use relative paths. The module system right now is one used internally at FB such that the name of the module is defined inside with `@providesModule Foo` and then resolved with `require('Foo')`. All the modules are globally unique. In order to work with CommonJS we move files and rewrite the require statements such that they are relative. The result of this build step is what is used when we ship to NPM.
  Yea, this works since we'll just pass whatever is there along to createElement. You can even have a variable that is a string and a DOM component will be created. The point about capitalizing is important.

``` js
var D = 'div';
return <D {...props}/>
```
  We support uncontrolled components (although we do not necessarily encourage them) and it seems to me that this is a utility that is of relevance to a handful of such use-cases, especially in more complex situations. I.e. where you have a stateful component which you need to reset, say a rich-text editor or in my case of [ReactSWF](https://github.com/syranide/react-swf) a running SWF, in response to some user action. **EDIT:** Think of it as a complement to `React.findDOMNode(inputRef).value = 'foobar'`.

This can currently be worked around by providing a monotonic `key`, but that's really just a hack and not a neat solution.

This is very much in the more obscure end of the spectrum but seems like a missing feature in-terms of being "feature complete" for uncontrolled components. So I'm not really going to push hard for this (especially as it could be _really_ obscure and the above hack might really be the best trade-off, also considering batching).
 Not sure what your proposed API is? Can you unmount and then remount?
 @spicyj Think `thisOrRef.forceUpdate()` but instead `thisOrRef.forceRemount()` I guess. So effectively `forceUpdate()` but rather than ignoring `shouldComponentUpdate` it will ignore and fail the internal `shouldUpdateReactComponent` instead, i.e. it will be unmounted _and_ mounted just as if its `key` had changed.
 @cody Just like `forceUpdate` (which is like `setState` + internal variable). So it's a regular, possibly batched, update like everything else but with an internal flag specifying that it must not pass the internal `shouldUpdateReactComponent`. (**EDIT:** So if the component ends up being unmounted by the parent then the flag will simply have no effect, so everything works out naturally)

`React.addons.batchedUpdates` is probably an important part in this for some of the use-cases and it's something I'd really like to see move out of addons, but that's another topic :)
 @cody Ah, yes I see what you mean now, that's a good point. I'm getting an uneasy feel thinking about all this now... hmm...
 I don't think we'll do this since providing a new key is easy and we're trying to reduce API surface area, not increase it. Thanks for the idea.
  Elements are light-weight objects with no knowledge of HTML elements. I'm not sure exactly what you're asking or why you would need it but if you're looking to get "div" from <div/> you can access .type.

``` js
var el = <div />;
console.log(el.type); // "div"
```
 A ReactElement doesn't correspond to a DOM node until you mount it in the DOM using `React.render`.

```
var element = <ScrollView><Text>hello</Text></ScrollView>;
var component = React.render(element, container);
var node = React.findDOMNode(component);
```
  PropType validation does not throw, it uses console.error.

`React.render` will throw in the above because you didn't pass a DOM node.
`TestUtils.renderIntoDocument` creates a node to render into, which is why it won't throw.
 Let me know if I misunderstood what's happening and we can reopen, otherwise, this doesn't sounds like a bug.
 No, I'm talking about an actual DOM node: `React.render(<Component/>, node)`. Without `node`, `React.render` will throw.

`TestUtils.renderIntoDocument` creates that node then calls `React.render`, which is why that signature is different. This is what it looks like:

``` js
  renderIntoDocument: function(instance) {
    var div = document.createElement('div');
    return React.render(instance, div);
  },
```

If you did the same thing before calling `React.render` in your test, I don't think that would throw either.

In general, I strongly suggest expecting a specific error, not any error. By expecting any error, you are masking what's actually wrong. In your case, expecting an error at all is the wrong thing. The error you're catching is about calling render without a DOM node, not anything about proptypes.

This is what you're test should look like:

``` js
it ('should require record with id', function() {
  spyOn(console, 'warn') // Note: will be console.error in 0.14
  TestUtils.renderIntoDocument(<RecordListItem />);
  expect(console.warn.calls.length).toBe(1);
  expect(console.warn.argsForCall[0][0]).toBe('some specific warning about record being required');
  // or something similar, I forget the exact syntax for all this.
})
```
  lgtm, thanks!
  What's the issue? You're getting a warning that says child keys must be unique. You have multiple siblings with the same key since you're using `category` (your data isn't sorted by category so you end up with multiple `ProductCategoryRow`s for the same category. Also, you're `ProductRow` is using name for its key, but there are multiple items with the same name, so you'll get the same warning for that.

And last but not least, perf - you're adding / removing thousands of nodes per keystroke. There are a bunch of optimizations you could do, the easiest is to simply toggle a CSS property on rows that shouldn't be shown. By doing that you'll have the exact same DOM nodes no matter what the filter is, you'll just be toggling a single property which is much cheaper than adding/removing nodes. And then using the prod build will be much faster, since there is a lot of code in there for debugging purposes.
  Ah sorry, I didn't see this before I committed a fix this morning.
  We have some unhandled warnings in our tests, which isn't great. We should clean those up and then we can make it so that any unhandled warnings are test failures.
 When you run the tests (`npm test` may be best for seeing the colored output), it should be fairly obvious what I'm talking about. The warnings are logged to the console between passing test lines.
  Thanks!
   Thanks again! You're all awesome :)
  This is sort of a hard problem to solve all the way. Our best answer so far has been to add some runtime checks so you can actually get the right value (eg, check if you're in a browser that needs "-webkit-flex"). Alternatively don't use use inlines styles for this.

I don't think there's anything else to do. Something like autoprefixer may exist for JS style objects, but I don't think we'll ever integrate that into core. So I'm going to close out.
  We'll need to rebase and fix a couple things but overall it seems fine to me. Any thoughts @spicyj?
 topLevelTypes is the wrong thing to look at here. It doesn't include custom React events like onMouseEnter and onMouseLeave. Instead, you want to look at the "registration names" gathered at the top of each event "plugin":

https://github.com/facebook/react/blob/8f9643485d767e44af8a9c388601414a4dadf67e/src/renderers/dom/client/eventPlugins/SimpleEventPlugin.js#L37-L43

These are collected in EventPluginRegistry:

https://github.com/facebook/react/blob/8f9643485d767e44af8a9c388601414a4dadf67e/src/renderers/shared/event/EventPluginRegistry.js

Hopefully that gives you some clues to go on. I also don't love that the warning logic for DOM properties

https://github.com/facebook/react/blob/71afd5a465880d87e7acbcf4f91ee23b716a87d5/src/renderers/dom/shared/DOMPropertyOperations.js#L84

is in a totally different place. We should at least make the error messages a little more similar.
 I think we're going to go with #5361.
  Let's also add `required` as @camsong says. Instead of listing the JS output, what do you think of just writing that `disabled` and `disabled={true}` are equivalent with an example?
 @spicyj happy with this now?
 Yup, this is fine now. Thank you @glenjamin!
  Can you move it down so the list is in alphabetical order and squash your commits? After that I'll merge this ‚Äì thanks!
 Sorry ‚Äì to be clear, it should be between `min` and `multiple`.
 Thanks!
 It's in 0.14 RC, will be in 0.14. You can generally tell this by looking at the tags on the commit page (35e67a793e0899328696bb8a776f101503fb7612).
  lgtm, thanks! If you wanted to leave the original post alone, I wouldn't have complained. We should add a header to the top of it so people know that the other doc exists and is more updated.
  Bah, this is because @jimfb changed his username and I guess GitHub doesn't set up redirects for everything.

Last time I looked we couldn't update fb.me links but I'll look again. It wasn't too much of a problem before but I'll force the issue this time.
 Another option is that I can change my username back to jsfb (at least temporarily until fbme is fixed).  That way, existing users don't get a 404.  Just let me know.
 @zpao What action do we want to take here?
 Fixed.
 Maybe your browser cached the redirect? This is working for me.

```
~% curl -I http://fb.me/react-context-by-parent
HTTP/1.1 301 Moved Permanently
Location: https://gist.github.com/jimfb/0eb6e61f300a8c1b2ce7
Vary: Accept-Encoding
Content-Type: text/html
X-FB-Debug: Y4MZfizL4TEgxAHIZW/5Ggh2/D4jn7rTB3COZu37DYRkvy6+ZE0pD2IkIMOWFCS2hbYNWByE5UWWnjff9a661g==
Date: Mon, 01 Jun 2015 18:11:08 GMT
Connection: keep-alive
Content-Length: 0
```
  There's a bunch of discussion about this in #3152. Let's continue there, might be a good time to revisit and make it actually happen. I'm not an expert about this so definitely value more expert opinions!
 As part of the effort to move discussion of intent to issues and close stale PRs, I closed #3152 which did not get merged, and reopened this issue. If this is something we want to fix, let‚Äôs discuss it here, and reach consensus first.
  This sounds like a great idea.
 Please stop +1ing, it adds zero value. We have already identified that this is a good idea.
 Thanks for taking this on!
 #3913 was not shipped to 0.13.x
 The fix was landed, any additional +1 is pure noise. Please stop.
  If you browserify with `NODE_ENV=production`, then you'll get the prod version, which doesn't have that message. You probably want to do that for your extension users anyway.

As to actually debugging, I'm not sure the best way about this. The DevTools are expecting to be inspecting the browser window, which is why they aren't playing nicely together (devtools set a global on the browser window, but React is looking for it in the context of it's execution environment, which isn't the browser window).

We might have to just close this but a quick cc of @sebmarkbage to see if he has any other comments.
 What do you mean? You can't use the React Developer Tools to debug the extension? What kind of extension is it? Did you use the `chrome://inspect` tools to open the extension?

It may not be possible to use React DevTools to debug extensions because of how we insert a global flag into pages to find the React instance.
 I think it _should_ work if you have global `React` or a global `require` that is able to `require('react')` from global scope.
 Btw, any reason you're stuck at React 0.12.2 and not upgraded to 0.13 yet?
 (Please note that you should not use NODE_ENV=production during development as it silences many helpful warnings.)
 @silvenon If you were using node, wouldn't the user-agent check prevent the message? We can add a check for console.debug if that would be helpful.
  Can you get rid of that merge commit?
  I started work on a more formal guide some time ago and haven't had the time to finish. We haven't updated that part of the contributing doc in a while but we've since introduced a bit more tooling to help enforce a lot of our style. Linting now catches many issues and the remaining are hard to define anyway (like what to do when the test of an if statement is too long). For the most part, following https://github.com/airbnb/javascript will get you 90% of the way there.

I think all we need to do at this point is update CONTRIBUTING with some version of what I just said. If somebody is interested in doing that then great.
  Looks good. Thanks!
  The code you posted sounds fine ‚Äì if you can reduce this to a simple test case I'd be happy to reopen and take a look.
  ``` js
<Card title={<div>Mes informations d'identification</div>}>
    Content
</Card>
```

Note the brackets instead of the quotes. Quotes will always be strings. The brackets will get evaluated, which in this case will give you a new ReactElement. You can then render that exactly like you already have in `Card` (though beware of putting divs in spans!).

You could also assign to a variable first:

``` js
var title = <div>Mes informations d'identification</div>;
<Card title={title}>
    Content
</Card>
```

No need to apologize fore your English. In the future though, this is a question best asked on the mailing list or stack overflow (since it's much more about doing a very specific thing in React vs a problem with React).
  cc @jimfb - I remember us talking about this but wasn't sure what the result of that was.
 One issue was with regard to subtrees. It is not enough for subtree rendering so we introduced the subtree rendering for implicit context pass through.

Another issue is just that this method already has a third argument. Wrappers is basically our poor man's named arguments. Allows us to put arbitrary things there. :)

A third issue is that I don't even think object maps will be how we define context in the future so it would make less sense.

Finally, if this is about unit testing then our recommended strategy for unit testing is to use the shallow rendering, so we should add context support to shallow rendering instead.
 One thing you can do which might be helpful for your test utilities: you can define a wrapper function that takes in a context object, and which generates a new wrapper component that defines childContext and renders the provided component using renderSubtreeIntoContainer.  Then you get almost exactly what you're looking for, and the solution is entirely in userspace.
 Let's close this out and we can revisit if we need later. We're not going to do anything in the near term.
  The new folder structure is organized around major packages that are expected to ship separately in some form.

`/isomorphic`

I moved classic/modern and children utils into a directory called "isomorphic" with the main export being ReactIsomorphic. This will eventually become the "react" package.

This includes all the dependencies that you might need to create a component without dependencies on the renderer/reconciler.

The rest moves into decoupled renderers.

`/renderers/dom/client` - This is the main renderer for DOM.

`/renderers/dom/server` - This is the server-side renderer for HTML strings.

`/addons` and `/test` - Same as before for now.

You're not supposed to take on a dependency inside another package.

Shared code is organized into a "shared" directory which is intended to support all the packages in that subdirectory. Meaning that once we swap to CommonJS modules, the only time you should use `..` is to target `../shared/` or `../../shared`.

E.g. `/shared/` is common utils that are used by everything.

`/renderers/shared/` is code that is shared by all renderers, such as the main reconciliation algorithm.

Shared code will likely be copied into each package rather than referenced. This allow us to have separate state and allow inlining and deadcode elimination.
 cc @zpao
 For my own notes. There are some unfortunate dependencies from /isomorphic right now that we should resolve.

ReactCurrentOwner.js - Needed for refs. We'll need to require this from each renderer so that they can update it.

flattenChildren.js and traverseAllChildren.js - Used both in reconcilers and children helpers. Not sure how to best share this code.

PooledClass.js - We can probably just simplify this code and drop the dependency.

ReactErrorUtils.js - This call is in the wrong place anyway which leads to bad production bugs at FB. Should move it into the event system.

ReactFragment.js - Should ideally be deprecated ASAP.

ReactUpdateQueue.js, ReactInstanceMap.js and ReactLifeCycle.js - Current the classes have a direct connection into this code. Effectively we need a pointer from the instance to the "active" renderer to get to these. Makes it not possible to make ReactInstanceMap just a Map.

ReactNativeComponent.js - Don't remember why we needed this but if we want isomorphic components we can't know ahead of time what a string element will render into. We can make heuristics at best.
 The new folder structure is best reviewed at: https://github.com/sebmarkbage/react/tree/coreapi/src
 Fixed lint. Now passing travis.
 lgtm. Still not wild about "isomorphic" but it doesn't matter (yet)
 yes. Also lets server rendering use a different implementation.
  cc @spicyj - designer of error messages.
 Am I? We can make this say "expected a single ReactElement".
  Ah nice, I saw the other PR first and was going to ask if you would do this. Thanks for being ahead of the game!
  https://github.com/facebook/react/blob/master/src/vendor/core/ExecutionEnvironment.js#L39
https://github.com/facebook/react/blob/master/src/vendor/core/ExecutionEnvironment.js#L16-L20

Your window is most likely not properly set up, `document.parentWindow` does not seem standard so I would expect it's your `window` which is not correct.
 @MoonTahoe It's possible the environment needs to be set up before React is required then. **EDIT:** Which it seems you're doing, but perhaps React is required elsewhere?
 :thumbsup: Glad you worked it out! The environment checks are a little bit fragile :(
  This is a better question for the mailing list or stack overflow as there is no direct issue with React you are bringing up.
  That's a bug with checkboxes, but it applies to text inputs too due to browser bugs which have not yet been normalized (and might not be strictly possible). So if you need to explicitly detect only when a change is made then simply test it yourself for now.
 @jedwards1211 Correct.
 I'm not sure what these bugs are‚Ä¶ (unless it's about us having to use other events to simulate `change`).

Everything with checkboxes appears to be working as expected to me and checkboxes are behaving the same way (eg, logging `e.target.checked` in an `onChange` callback tells me the right value, even if I don't call `setState`).
 @zpao Yeah, my initial answer seems a bit wrong, textinputs are affected by noop change events (that I know). But not checkboxes to my knowledge. It also seems to me that this issue is not about that issue and is actually not a bug at all, onChange should always fire when a change is initiated, it can't be any other way, discarding the new value happens _after_ onChange.
  That's only mentioned in ideas for the future, best practices and various community tools. React (at current) largely only exposes the underlying DOM as it is.
 The W3 docs you link are outdated; the latest version makes no mention of the syntax: http://www.w3.org/TR/css-style-attr/.

Right now we're not planning to add more support for complicated "inline" styles like this into React core.
  For reference. We're exploring an alternative to the `observe` function proposed in #3398.

Instead of having a separate function that defines a list of dependencies on Observables, we could allow the render function itself trigger a bunch of side-effects that registers the currently executing component with some Observables.

``` javascript
render() {
  var data = request(this.props.url);
  if (data === null) return <div>Loading...</div>;
  return <div>{data}</div>;
}
```

Side-effects! :astonished: 

The implementation of request wouldn't return an Observable. Instead it would tell React that the currently executing component has a dependency on this Observable and needs to rerender anytime the subscription fires. It returns the last value received by this particular Observable... somehow.

``` javascript
function request(url) {
  return React.readAndSubscribe(Observable.fetch(url));
}
```

If an Observable is no longer subscribed to in the next render pass, it is automatically unsubscribed. Perhaps the Observable API is not ideal for this model.
 I've posted a PR (https://github.com/facebook/react/pull/3920) that implements the underlying API that would power these new semantics, mostly to continue/inform the discussion.
 @glenjamin It doesn't make server-side rendering any harder, because you can just re-run render on the client to discover the dependencies.  In fact, we do re-run render on the client anyway (to setup refs and callbacks and other component data structures), so we aren't making things any worse.
 @gaearon Correct, there would be no benefit to using observables, unless your system already uses observables, in which case, by all means, do so!  Observables propagate state on write, whereas a react render utilizes data on read.  While observables are perfectly compatible with React, the model is actually the reverse of what React does internally, so, yeah, that's why the observable API doesn't add any additional value when talking with the react core.

@gaearon With regards to your point about immutable/plain javascript, this is super important and one we've give lots of thought!  This system actually plays super nicely with both immutable and plain javascript, and you are encouraged to use immutable/plain javascript as much as possible!  If you don't use the data tracker, everything behaves exactly the same as it behaves today.  Sometimes, however (eg. large cyclic graphs), immutable data starts to run into troubles and the recommended solution is to break up the cycle by having keys that you lookup in a map (effectively introducing mutability into your immutable graph).  This API allows the data store implementor to do that, without exposing where the mutable break-points are located.  If you are able to effectively implement your app with immutable data, you are encouraged to do that, and you won't ever learn about this api!  But when that isn't practical, you would be able to call into this API for better performance and sideways data loading.  However, please don't feel obligated to ditch plain/immutable javascript just because we add a new API!  We still love immutable and plain js!
 @glenjamin  Ah, I see what you're asking.  Either API (observables or this) will require some minor nonisomorphism (is that a word?).  With this API, you SSR datastores would need to return the data eagerly (eagerly fetching isn't usually a problem on SSR because your database (source of truth) lives near by), and with Observables your SSR datastore would need to close all observable streams after loading but not close them on the client in order to receive updates from the server.  So we aren't really making the situation any worse than the other proposals.
 @gaearon Yes, exactly, it's like shouldComponentUpdate in reverse!  It allows datastores to provide "hints" to a component that "data they depend on has changed, and they might want to rerender".  It does the rerenders in an optimal way to be maximally efficient (in some cases, even more efficient than you can be with immutablejs).  See @josephsavona's https://github.com/facebook/react/pull/3920#issuecomment-104711512 for details.

This API would probably be used by people writing datastores, but potentially also by people writing flux libraries.  If this is the API we choose, this pattern would be recommended for sideways data loading (ie. you shouldn't setup subscriptions to flux stores manually).  All sideways data loading is still "discouraged" (ie. people SHOULD TRY to find a way to use just immutable props), but if you're sideways loading data anyway, it would be recommended that you let React track that data.  Of course, you could still always do the tracking manually, just like today, if you felt the need to do your own thing.

One of the motivations is that: There is an oft quoted statistic that something like 80% of mixins are trying to implement sideways data loading.  I'm not sure where that statistic came from, but it is certainly true that sideways data loading is one of the main thing mixins are used for, and it's also one of the more error prone things that people do in React, and we want to simplify that.  See the motivation for Observe (https://github.com/facebook/react/issues/3398).
 Interesting update:

If we can work around the need for push-updates for dirty marking, we can use the `Iterable` protocol for pulling data. E.g. polling of data.
 @oztune It's worth noting that the "side effects" are internal to the React core.  It is semantically equivalent to returning a tuple (containing the jsx elements, and objects-read).  For this reason, doing the tracking within `render` isn't an antipattern **IFF** React is responsible for tracking the reads.

Moving the logic out to a separate function does work, and was discussed (it is semantically equivalent to an `observe` function), but it leads to a duplication of logic.  You are specifying (in the first method) what you are going to read, and you are actually doing the read in the second method.  It's totally unnecessary, and error prone.  If the two methods ever get out of sync, this can lead to some pretty subtle bugs.  For simple components, it's relatively easy to keep them in sync (so long as you don't forget) but as your component starts getting more complex, it becomes exponentially more difficult to keep them in sync.  The whole point of combining them is to avoid this unnecessary duplication of logic and to make sure that what-you-read-is-what-you-use.
 @oztune Neither of the above (Both options `A` and `B` are bad).  For applications written in React, you're probably going to want some sort of data management architecture (like Flux or Relay) that is responsible for managing your application's data - you probably wouldn't want to store your application's data in the internal state of an `App` component at the root of your application.

Under this proposal, all your data remains in the data layer (flux/redux/relay/whatever), and components "subscribe" to that data by reading the data.  When the data changes, the appropriate components will re-render.

If you do like you suggested, and copy/store the data prior to rendering, you have a few issues:
- Duplication of state - your source of truth is now confusing, since you have two "copies" of the data.  For more details on a similar anti-pattern, see: https://facebook.github.io/react/tips/props-in-getInitialState-as-anti-pattern.html
- Under fetching - If your first function fails to copy/return one of the data elements needed by render, then your render function will crash (or at least return the wrong result).  This was totally avoidable, because the data you need is in your datastore, you just didn't copy it out.
- Over fetching - Rather than reasoning about what data will be needed when, it's easy to just "fetch everything" instead of trying to figure out the minimal set of what you'll need.  This is wasteful from a performance perspective, and results in death-by-a-thousand-papercuts ,where each component is slightly wasteful and the result is a whole application that is slow.  React apps are often fast because we intentionally make it difficult to fall into these anti-patterns.

All three issues just evaporate if your definition of "in use" is based on what "is actually used by render".

Additionally, if you copy the data manually, it means you're managing your subscriptions manually (because you need to know when your data changes), which is error prone.  It's super easy to forget to unsubscribe from one of your data sources when your component unmounts (oh, and manual subscriptions are super side-effect-full).
 Yeah, my thinking is that the flux example creates a shadow copy of state, and shadow copies are bad, so I tend to think that reflects negatively on the example.  However, the example does have some redeeming qualities (namely that it's a commonly used pattern, especially in the context of data transformation/memoization, and also has a render function that is clearly pure).  For the record, the same example shows a component manually subscribing/unsubscribing from the datastore, which is exactly the opposite of what we would want in a perfect world and is the whole reason for these issues discussing sideways data loading.  To say the example is 100% good or 100% bad is too simplistic.  We are still learning about "best practices" and will continue to improve the libraries and documentation over time.

Yes, components should be a pure function of props and state.  However, once you implement flux, your state may be in a datastore rather than in your components.  The primary point of that sentence is to communicate the fact that components should never imperatively mutate the data/ui.  To see this, allow me to paste in the remainder of that sentence from the first search result you linked...

> The `render()` function should be _pure_, meaning that it does not modify component state, it returns the same result each time it's invoked, and it does not read from or write to the DOM or otherwise interact with the browser (e.g., by using `setTimeout`).
 See also https://mobxjs.github.io/mobx/getting-started.html for a related approach based on tracking reads and writes. I think it was mentioned in this thread before, but it's gotten more mature since then, and I've only heard good things about it from the people who used it.

cc @mweststrate
 > Also the term "observable" in the case of MobX, while accurate by Merriam-Webster's definition, might be a misnomer. When I think "observable", I think Bacon, Most, Kefir or Rx, etc.

Yeah. I posted it because I think this is the sense the original issue post was implying (see also #3920 for something similar to MobX in spirit).
  Thanks @chaseadamsio!
  Hmm, I can't repro this in a simple case (http://jsfiddle.net/jqznqwg4/), can you give a bit more detail, perhaps a test case on jsfiddle or elsewhere.
  I'm going to close this out in favor of https://github.com/facebook/react/issues/4302, since that has been where most of the discussion has been taking place and I like the solution we arrived at in that thread.
  We don't have an exposed way to extend the built-in event system. Essentially the problem is that these extensions wouldn't be scoped to a component. It is a global set up and different components with different event systems.

This makes it difficult to share your components with the community. Different event systems may conflict in the same namespace. It will only work in your own controlled environment. We want to make it easy to share and reuse components without conflicts.

So to support this we would need to build it in a way that supports isolation.

This is the major benefit of a wrapper like `<Tap />` since it does support component isolation by default.
  Thanks!
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 We'll stick with the original unless it's causing problems.
  @dantman Thanks for bringing this up, we've been bad about this. Our intention was to publish the same revs that we sync internally @ FB but then we didn't do that. We just synced recently so I published what's in master as `0.14.0-alpha1`

@andreypopp They're being published on each commit (at least the ones that we didn't decide are docs only). @spicyj and I were just talking Friday about moving the builds off my website & into a more official home.

@cody not sure we ever shared it but nice detective work :)
  No, #1398 didn't make the release; we decided it was a little too risky. (The "Did it." comment there refers to the release itself, not that PR.)
  babel-eslint lints the original source, not the transformed code. See this post for info about how to set it up:

https://medium.com/@dan_abramov/lint-like-it-s-2015-6987d44c5b48
  Just a few inlines ‚Äì otherwise looks great. If you could make those updates and squash your commits I'll merge.
 Thanks!
  > However it's not enough to set a value of href, which means we still should not use a in svg in v0.15.0-alpha.1.

Sorry, I'm not super familiar with SVG, can you elaborate?  What are we doing wrong in v15?  What should we be doing?
 @piglovesyou I'm not sure it's true that the current architecture can not distinguish.  We already do things in 0.15 like enable all tags/attributes when within an `svg` tag.  So I would speculate that handling this would be technically possible.  cc @spicyj 

I think the bigger question is: How many of the SVG tags/attributes use getters like this?  is this a singular special case, or are we going to see this type of thing cropping up in dozens of situations with SVG?
 It is surprising to me that setting the attribute doesn't work. So writing `<a href="...">` in the HTML works but calling `.setAttribute` does not?
 Okay, thanks for the followup. xlinkHref in React does that.
  I guess it's arguable, but I would think this should only apply to `document.body`. Whether or not a different target document has finished rendering is a different problem. We can warn for that too but the error messages should be distinct as to not confuse the two.

**EDIT:** :+1: for the test, but it instinctively seems rather fragile and, in that context, kind of unnecessary for a simple warning perhaps, cc @zpao
 I think we were all really busy around May 11th, this PR appears to have slipped through the cracks.

@bloodyowl Can you rebase.  I think @syranide is right, I can't think of a reason we'd want to warn except for document.body, and the ramifications of warning for the target document are unclear to me, so might as well clean that up to avoid any issues.  If we run into a case where we want to warn for something other than document.body, we can always add that back later.  I'm also going to cc @sebmarkbage and @spicyj to see if they have any merge-blockers/feedback.
 hm. I could see the use case for rendering before body to do early work while waiting for CSS and avoiding flash of unstyled content. However, the rendering pass may also require the CSS to be available  to do layout. That is part of the componentDidMount which could be deferred.

I could see us reverting this recommendation in the future to allow for work to be scheduled earlier in the pipeline. Not sure if that should block adding the warning now or not. Don't really care either way.
 @sebmarkbage What element would you be rendering into before the `<body>` open tag?
 An out-of-document node. It can be inserted later.
 @sebmarkbage Can't we just warn if `target == null` instead and hint that this might be the problem? **EDIT:** Oh wait, the original issue is rendering to `document`, so we should just make that special-case smarter (too).
 @syranide Sorry, you lost me - can you elaborate on the special case / what the diff should look like?
 @jimfb https://github.com/facebook/react/issues/3800#issuecomment-98220446 but perhaps spicyj's follow-up applies too. Anyway! My point is simply, instead of always checking whether or not document.body has loaded, why not only do it if the target doesn't exist. Then everyone is happy right?
 Let's just warn if it's DOC_NODE_TYPE without a body then and not warn if you pass an element or doc fragment.

@bloodyowl When you're done, can you squash your commits together?
 @bloodyowl What case are you trying to warn against with such a check?
 @vicapow (and @askmatey probably) I assume you're talking about #3207. It's true that it is more work to create and render into a div but you will tend to get unreproducible issues if you don't from browser extensions and the like that manipulate the body directly. This issue is unrelated.
 Hey @bloodyowl ‚Äî sorry you spent time on this, rebased later, and it still didn‚Äôt get through.

It appears that #3800 is not that bad anymore‚Äîthe [current error message](https://github.com/facebook/react/issues/3800#issuecomment-201935164) looks relevant and doesn‚Äôt require more specific checks such as these. This, and concerns by @sebmarkbage above, is why I‚Äôm inclined not to take this after all. We should have articulated this earlier.

Thank you for the PR, and I hope that we can make your next contribution experience more positive!
  This means that when React was loaded, it thought it was not in a DOM environment, so it didn't create the wrapper node it needs to test when rendering certain nodes.

Here's the check we use:

```
var canUseDOM = !!(
  typeof window !== 'undefined' &&
  window.document &&
  window.document.createElement
);
```

As you can tell we're detecting globals so just ensure you have those defined.
 No, getMarkupWrap creates the wrapper node when it is required (https://github.com/facebook/react/blob/master/src/vendor/core/getMarkupWrap.js#L16-L20). That could perhaps change to create once on demand and cache but as of right now it doesn't.
 In general we've made the assumption that the execution environment doesn't change so you may run into other issues.
  No, there are also React ART Components, React Native Components etc.

This is also not verifying that it is indeed a component at all, any random object or string or null would pass.

The problem right now is that React DOM components are wrapped in composites. We're planning on changing that and just returning the straight up DOM node.
 I actually ended up fixing this in #5016 so we don't need to take this. Thanks for looking into it.
  When you modify `this.state` directly and use `forceUpdate()`, no new object is created for next state. It is, by reference, the same object that was in the previous state.

The workaround is to use `setState()` (but that will also have the same problem if you modify `this.state` directly before calling it).
 > workaround

(To be clear, using setState is the recommended pattern whenever you want to update state. Mutating the state object directly works in some cases as you saw but does not work consistently with all of the lifecycle methods so is not recommended.)
  Thanks for taking this on! If you could fix up a few grammar nits and then squash to a single commit, we can get this merged.
 Awesome, thanks!
  As you can see from the implementation, renderIntoDocument simply calls React.render:

https://github.com/facebook/react/blob/v0.13.3/src/test/ReactTestUtils.js#L45-L53

If you're having trouble passing functions, it's an artifact of your test environment and not something specific to React.
  Thanks!
  Thanks!
  Good catch. Luckily it doesn't matter for the error we're expecting :)
 In this case it's ok and we throw the same error either way. [The code that throws](https://github.com/facebook/react/blob/master/src/browser/ui/ReactDOMComponent.js#L108-L112) only looks to see if `dangerouslySetInnerHTML` is non-null and children were also specified.

Definitely true that this typo could have masked an error if we change some code though. That's generally why I think it's a good a idea to specify the error message we expect to be thrown :)
 We've explained it a few times. It's to make sure it's nice and awkward and
intentional so when you use it, it's annoying you clear that you're
breaking out of the nice box React provides. There are a couple open
discussions about changing it.
  Yea, it's not the best example. It actually doesn't have anything to do with hotloading, just wasn't well informed (plus is ~2 years old and at that point generating multiple bundles with browserify wasn't super easy).

The point of this bit is just to show that a generic solution where you don't have an entry point to your app in a main.js or something that has the things it needs bundled, then you need _some way_ of accessing React and Component.

I'm going to close out since this was just a question but feel free to continue discussing.
  cc @syranide & @salier
 On a general note, I don't think we need to special-case IE here, any browser that fires an event without the value having changed should receive the same treatment I would think?
 (@zpao) It's also worth noting that the reason why this _really should_ be fixed in the event system is because `change` bubbles, you can put `onChange` anywhere among the ancestors (and some do). I personally wouldn't mind deprecating that behavior entirely, but that's not how it is right now.
 I would change `event.target.value === '' && lastValue === ''` to `event.target.value === lastValue` because we really don't want any of those to emit a change event.

I'm not a fan of this as it does not take care of foreign nodes (but it is beneficial...), it being a fix in the input wrapper rather than the event system. It's treating the symptom, not the cause, so it does not apply equally. I still think it's in the best interest of React to not use bubbled events, but it's an entirely separate discussion and a huge breaking change which is unlikely to happen I would think.

@zpao How do you feel about this?
  It's been requested :) #1587 has more discussion so I'm going to point you there.
  This is fixed in master and will be in the next release.
  Sounds like a good idea. Are you interested in creating a PR to add it?
 We autogenerate the vender-prefixed styles there (which you might have seen below where you changed code) so that's all you need to do! Thanks again.
  Checking for HTMLUnknownElement is preferable because we might not have all the HTML tags in that list and definitely don't have all the SVG tags.

You can probably mock out document.createElement in the test (or temporarily set HTMLUnknownElement to HTMLParagraphElement, and verify you get the warning when creating a `p`), but if that doesn't work we can take it without a test.
 How will this work in partial Web Components environment? E.g. some partial polyfill where web components might extend HTMLUnknownElement? Does one exist?

Another case is if you want to do a polyfill. E.g. `<video>Fallback content</video>` this would warn even though it is a valid tag, this browser just happened to need a fallback.
  cc @fkling
  cc @spicyj for a sanity check
 I don't think this works if the element has a data-reactid attribute, which it would in the case you're trying to catch?
  You don't really need `mockComponent`. It is really a legacy API and will be deprecated.
  @yiminghe Overall looks good.  I'm excited to see this fix!  A couple of comments.  Also, the linter is unhappy (you can execute `npm run lint` and fix anything of `error` severity).  
 Tracking issue in https://github.com/facebook/react/issues/2620
 This logic would actually be better in ReactDOMOption especially since we already have that wrapper, not in ReactDOMComponent.
 I would be far less concerned if we simply threw on multiple children, or no longer made `<option />` accept children like we did with `<textarea />` (but that's probably too late now?). As for this specific implementation, if we ever support components returning a string then `<option>Hi <Name /></option>` wouldn't work as expected, my point being that this fix is basically a hack. It's current idea of what is printable is not identical to Reacts either. **EDIT:** Also fragments/arrays isn't accepted right now I think?
 @yiminghe I understand. I'd prefer to have the logic in ReactDOMOption because I don't anticipate us adding it for other tags. If we choose to do that in the future, we can look at abstracting it out ‚Äì but ReactDOMComponent is already very complicated and so we'd like to avoid complicating it unnecessarily. Can you move the code to ReactDOMOption's render function?
 Actually, #3847 looks closer so I'll follow up with that one instead. Thanks for sending this in.
  This is a valid bug, but I'm going to close this gh issue in favor of tracking this as  https://github.com/facebook/react/issues/2620
  Looks good to me!  Thanks @neojski!
    Built files look the same up to parenthesization and quoting. This only saves 1.5 seconds out of ~20 on a clean build but it's a little simpler.
 (This conflicts with #3788‚Ä¶)

cc @sebmck ‚Äì if you could take a look and let me know if this looks sane, I'd appreciate it.
 (it gets the @sebmck seal of approval!)

![image](https://cloud.githubusercontent.com/assets/6820/7465186/07adcdbe-f281-11e4-9b03-8c1b94b14ea4.png)
 :thumbsup: I was actually going to look into this so thanks! :) I'll redo #3788 with babel (you did the hard part so it should be pretty easy)
 > NOTE: It's not recommended to use this API unless you're dealing with dynamic source strings

;)
  @iceNuts you should create React Native issues in this repo: https://github.com/facebook/react-native
  Can you try with the master version of React? You can do this by changing your package.json to have

```
"react": "http://react.zpao.com/builds/master/latest/react.tgz"
```

and running npm install again. You may see a more informative warning.
 Sorry, it's a current limitation that you can't return more than one component from a React render method. Something we want to fix (#2127).

You'll have to refactor your components to make this work right now. If it helps, you can have a plain function (not a React component) return an array of elements but that doesn't necessarily help if you need component-local state like you have in GeneExonRow.
  Thanks for finding that @cody. I'm going to close this out and we can continue discussion over there.
  If you're going for unsupported workarounds, you can also call `DOMProperty.injection.injectDOMPropertyConfig` anytime before or after React is required.
  Thanks for the bump. I'll try to make some more progress on SVG in the next couple of weeks and figure out if we want to take this.
 SVG tags work correctly in master.
  Thanks!
  Yes, @levibuzolic's approach sounds great.
  Fix of the week candidate right here.

Display names should all be ok (since they are identical), but links might not be. I defaulted to Twitter because that's what we do. I could also link back to github instead and do that across the board. I don't really care where the link goes (FB profile, personal blog) so let me know if you'd like something else. I decided to just use github username for the key in the authors hash.

I'll give this a couple days in case people want to change anything, let me know if you do. I'll check you off as I go.
- [x] @Daniel15 
- [ ] @LoukaN
- [ ] @chenglou 
- [ ] @fisherwebdev 
- [ ] @jgebhardt 
- [ ] @josephsavona 
- [ ] @kmeht 
- [ ] @matthewjohnston4 
- [x] @petehunt 
- [ ] @schrockn 
- [ ] @sebmarkbage 
- [x] @spicyj 
- [ ] @vjeux 
- [x] @wincent 
- [x] @zpao
 > I defaulted to Twitter because that's what we do

Would it make sense to use Github links by default instead? A Facebook project with a lot of Twitter links in blog posts looks a bit odd :D 
 I thought about defaulting to GH but realistically there's a large & active dev community on Twitter and when people tweet links, it's sometimes nice to mention the author.
 I'm going to merge this. If anybody would like to update their links later, feel free to create a PR.
  Size comparison:

```
   raw     gz Compared to master @ 6ed98ec0c83918d91b16517544e658e2ec068070
     =      = build/JSXTransformer.js
-15736  -3247 build/react-with-addons.js
  +287     +7 build/react-with-addons.min.js
-14412  -2887 build/react.js
  +274    +15 build/react.min.js
```

Differences mostly look to be various bits of whitespace that Babel ends up removing during its transforms. In minified files, mostly additions of `"use strict";`.
 (cc @sebmck)
 This will (potentially) break with closure compiler. It might not (they might already be in the DOM externs) but we should confirm

```
-  'Esc': 'Escape',
-  'Spacebar': ' ',
-  'Left': 'ArrowLeft',
-  'Up': 'ArrowUp',
-  'Right': 'ArrowRight',
-  'Down': 'ArrowDown',
-  'Del': 'Delete',
-  'Win': 'OS',
-  'Menu': 'ContextMenu',
-  'Apps': 'ContextMenu',
-  'Scroll': 'ScrollLock',
-  'MozPrintableKey': 'Unidentified'
+  Esc: 'Escape',
+  Spacebar: ' ',
+  Left: 'ArrowLeft',
+  Up: 'ArrowUp',
+  Right: 'ArrowRight',
+  Down: 'ArrowDown',
+  Del: 'Delete',
+  Win: 'OS',
+  Menu: 'ContextMenu',
+  Apps: 'ContextMenu',
+  Scroll: 'ScrollLock',
+  MozPrintableKey: 'Unidentified'

```
 I guess so. Filed https://github.com/babel/babel/issues/1415 upstream.
 oh yeah! make it please!
 @zpao r? Updated babel to avoid property key minifiers.
 r=zpao
 Just remembered that we can probably get rid of our es3ify dependency now (which means a bit of cleanup in the browserify config)
  Calling React.render() from a script tag in the document head implies that React.render() is being called before the document body has been parsed by the browser.  This can lead to a confusing error, especially if the user is utilizing server-side rendering.

> Error: Invariant Violation: findComponentRoot(..., .1ba6uva93i8.1.0.1): Unable to find element. This probably means the DOM was unexpectedly mutated (e.g., by the browser), usually due to forgetting a <tbody> when using tables, nesting tags like <form>, <p>, or <a>, or using non-SVG elements in an <svg> parent. Try inspecting the child nodes of the element with React ID ``.

We should probably warn if the user calls React.render() before the body exists.
 Worth noting that this only happens when using server side rendering and rendering into `document` (`React.render(..., document)`). Otherwise you'll be trying to get a node and we'll hit an invariant that the target container is not a DOM element.
 Yes, though I also recall we had an issue where someone was rendering into document.body which was null and they were confused why.
 See the README.
 The demonstration I've seen was written back when 0.13.2 was the latest release, and it utilizes SSR so it will require a bit of tinkering to make it run on 0.14, because SSR requires the checksum to match so you can't just edit it manually (you will need to generate the markup using `renderToString`).

If you can verify that this is no longer an issue on 0.14, I think we can close the bug.  I know there have been some changes with regards to how react ids and event handling work, so it's possible this is fixed, but I think there is also a pretty good chance that it's still an issue, so we should verify.

Original repro:

> https://grepular.com/react/broken/
> https://grepular.com/react/working/
> 
> The HTML at both URLs is identical. The only difference is that in the "browser.js" which is referenced inside /working/, I use "setTimeout(this.updateNow, 1)" instead of "this.updateNow()"
 @m0nstrSq4d You should use the `master` branch, as any changes would need to go into master anyway, and that will give you the most up-to-date changes.
 Today in master I get

```
Uncaught Error: Invariant Violation: _registerComponent(...): Target container is not a DOM element.
```

both with and without server rendering.

I think this is descriptive enough, and we can close this issue.
  @cody can you explain why you think React is innocent in this case?  It looks to me like setProperty and setAttribute both update the value.

```
var div = document.createElement('div');
<div>‚Äã</div>‚Äã
div.setAttribute('placeholder', 'noise');
<div placeholder=‚Äã"noise">‚Äã</div>‚Äã
div.setAttribute('placeholder', 'nois2');
<div placeholder=‚Äã"nois2">‚Äã</div>‚Äã
div.setProperty('placeholder', 'noi32');
<div placeholder=‚Äã"noi32">‚Äã</div>‚Äã
```

Since initial render and updated-render are different, I would consider this a React bug.
 Update: Looks like setProperty is added by mootools (it doesn't normally exist on a dom node).  I tested it in a fiddle that had mootools loaded, thus my testcase above which called setProperty.

But the point about initial-render and update-render still holds, so I'm going to leave this as a valid bug.
 React is doing node.placeholder = value, which doesn't work for divs (because divs don't have that property). We'll eventually support arbitrary properties & attributes so perhaps then this will just work (assuming we can use setAttribute blindly for this)

FWIW, using an arbitrary property for data is exactly what data-\* is for, so using data-placeholder is the best thing to do anyway :)
 Fixed: http://jsfiddle.net/utp5br4g/
  Looks good to me, cc @zpao.
 We should do inputMode to keep with our camel-casing.
 @levibuzolic Mind squashing your commits? After that I'll merge this.
 Looks good to me, thanks @levibuzolic!
  original diff is here: https://gist.github.com/marocchino/7f04fe5e4460f8036555
 Thanks!
  We ended up shipping the addons differently so closing this out.
  Analogous change to #2935.
  This is something we want to do, but it requires more thought around how components are rendered because the currently solution always renders something synchronously. In your example, what does it wait for before returning the result? Anyway, we're tracking this in #1739.
 React.renderToString doesn't do any I/O so you wouldn't gain anything from it being async in its current form.
 Where you might benefit is not so much async but streaming markup generation. Follow along in #3009 for more there.
  I would say this is clearly a bug, because anything that passes initial render should pass update render.  Thanks for flagging it for us!
 Closing in favor of #2620. You should also get an explicit warning for this now in master.
  It's not currently supported or available without doing a custom React build, sorry.
  This looks bad.

We don't do a great job interacting with native events.  Sebastian wrote a post about this once-upon-a-time, how native and synthetic event systems are, by and large, not interoperable.  Even so, I can't see a reason we should fatal like this.

@syranide @spicyj Do you understand what's going wrong here?  What a fix might look like?
 This happens when we handle a click event from a node that's been removed in between when the event is triggered and when React receives it.

@sebmarkbage How should we deal with the case that events fire on detached elements? Should we ignore events for nodes that aren't in the document? I don't think the bug is easily fixable otherwise because we don't have the old event handler after the reconcile that removes that node.
 @rigdern Thanks for an excellent bug report and good repro case!

@spicyj I think this happens because we use the "root id" to determine which element was clicked. In the repro case there is no "key" as part of the root ID for two reasons:

1) It is not a child of a container (multichild) so it doesn't get a key added to the root ID.
2) It doesn't have a unique key and doesn't need one because it the button is of a different type.

If I make sure that a key is used as part of the root ID the problem is solved:

http://jsfiddle.net/xzucgepn/1/

So the problem in the repro isn't that we're firing on a removed node, it is that we're firing the event on the new node. This would be solved if we used a unique ID per instance to identify event handlers instead of a generate root that is non-unique. Which I think we wanted to do anyway.

Is there another repro that shows a different issue?
  @spicyj @zpao does this change our thoughts on renderIntoDocument?  Maybe we should attach to the dom to avoid cases like this?  What cleanup were we trying to avoid when we removed that logic?  Might the better solution be to improve test isolation?
 > This will help avoid some cleanup effort between tests in the open-source version of React (see calls to removeNextSiblings in react/src/test/index.html).

I don't feel strongly.
  Thanks!
  I actually think we should match up with the fields on `React.addons` now. I don't think we'll be able to fully automate this. eg, `react/addons/createFragment` needs to look like `module.exports = require('../lib/ReactFragment').create;`
 I liked @spicyj's idea of just adding the files directly into the repo. Though I guess he said "build/npm-react" which isn't right and I think he miswrote. We can do it before the build process starts.

If we create an addons folder in https://github.com/facebook/react/tree/master/npm-react with the right files and the right content, we don't have to do anything fancy. It's more prone to falling out of date but perhaps we can do some simple testing.
 Yeah, my bad ‚Äì I meant just npm-react/.
 I think these all need to be `../lib` not `./lib`. Were you able to test these at all? If you run grunt npm-react:pack then you should be able to install from build/react.tgz.
 That's it (except for the paths as Ben mentioned) :)

A couple things I'm not sure about:
1. The deprecation notice. It might end up being that we really do want to deprecate this but I'm not entirely sure yet (no need to change the code just yet - we should get confident and not churn you).
2. What to do about `__DEV__`. Right now `React.addons.TestUtils` doesn't exist at all in prod. Same with `Perf`. Now maybe it doesn't matter so much since people would be requiring explicitly but it is a slight difference.
 I'm personally up for deprecating react/addons now (though I'd probably do a console.warn) and I don't think the `__DEV__` difference is that important here.
 Thank you!
 Thanks Dustan!
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 Looks good, thanks!
  Let's just use React.renderToString here.
 renderToString just takes one argument; no need to pass container. Other than that, this looks good. Mind fixing and squashing your commits into one?
 If you do an interactive rebase (git rebase -i) then you can delete all the lines that don't correspond to your commits and then you can force-push to the same branch to update this PR ‚Äì no need to delete your repo. A new PR is also okay though.
  Can you provide a more detailed example / use case?

Normally, in a Flux-like framework, all the events get sent to the dipatcher, which results in updated datastores and a rerender.  I don't see why you would need/want a before/after notification, nor what that would actually mean (How is this different from doing something at the beginning/end of your event handler).
  The current system of packaging react/addons isn't great because you need to pull in all the addons even if you just want to use one of them. Instead, let's make it so you can do `require('react/addons/TransitionGroup')` and similar.

This should be as simple as adding a few files to build/npm-react that require the (private) internal modules.

``` js
// npm-react/addons/TransitionGroup.js
module.exports = require('../lib/ReactTransitionGroup.js');
```
 cc @gaearon @iamdustan. This came out of the Twitter discussion as a possible way to start migrating to requiring of a single addon in a condoned way (without reaching directly into `lib/`) that shouldn't screw up other packaging.
 Please do!
  :thumbsup: thanks!
  Ok, there's a bunch of feedback. It would good if you could also rebase since this won't merge cleanly as is.
 :thumbsup: We'll agree to disagree on that 1 sentence but I don't care too much :)

I'm going to squash and merge so we don't have 11 commits for this. Thanks!
 Squashed commit: f34c2eab405f8548e7920b0415dcdcec56768770
Merge: aee3614d802802c76fc6ee494a98146bd58d9cd0
  :+1: 
 cc @petehunt who also wants it gone
 I know it's entirely anecdotal, but here is my story:

> Long before I ever considered joining the React team, I had a friend recommend React as a framework to check out.  This particular friend recommends that I "check out" half a dozen different libraries/languages each week, so it wasn't a particularly strong endorsement, but it was enough to get me to open the web page.
> My level of due-diligence on one of his recommendations is generally to read the homepage of the tool/library/language, maybe poke around for some example code so I can see what it would look like, and insert it into my mental index so I know it exists if/when I need to call upon it.
> All the terminology was foreign to me.  "Virtual DOM" and "JSX" and "reactive data flow" and "Elements" vs. "Components".  I was about to file it away as "I don't really understand what they're trying to accomplish" (a category for things that try to solve problems I'm not experiencing).
> When I saw the sentence "Lots of people use React as the V in MVC.", it suddenly all clicked.  I knew MVC, and I now understood what React meant by "Just the UI".  They meant that I could define my own models and controllers using my own tools, and I could use React to render the view in my application.  This was the critical point where I decided to click the download button.
> Now, needless to say, I'm a huge fan of React.

Anyway, now that I fully understand React, I can understand why that sentence is arguably a bit misleading, but I also see how it succinctly communicates what React actually does in terms that were very familiar to me.
 Something has to replace the MC though. Whether it's Flux, Relay or another system entirely. The default option of callbacks passed down 4+ levels deep as props (as you get if you extrapolate from [Thinking in React](https://facebook.github.io/react/blog/2013/11/05/thinking-in-react.html)) becomes quickly unmanageable.

Maybe take @ryanflorence's suggestion, and _also_ add to the "Data Flow" bullet point:

> React implements one-way reactive data flow which reduces boilerplate and is easier to reason about than traditional data binding. Combine it with [Flux](https://facebook.github.io/flux/) for a full replacement for MVC architecture that helps you build great apps faster.

This way, we still explain how it relates to MVC and present a recommended architecture.
 No comments for over six months.  It isn't clear that we want to change this, so the bug isn't actionable.  This might get changed/fixed as part of a bigger docs rework, but let's close for now.
  Thanks for the report.

This keeps coming up. I know @sebmarkbage was reluctant but we should probably just add a hard error for this in createElement.
 @danschumann You should have seen a console warning for this though. Did you?
 @agnosticdev Thanks ‚Äì it looks like Babel [gives a better error here](http://babeljs.io/repl/#?experimental=false&evaluate=false&loose=false&spec=false&playground=false&code=React.createClass%28%7B%0A%20%20render%3A%20function%28%29%20%7B%0A%20%20%20%20return%20%3Cdiv%3E%0A%20%20%20%20%3Cdiv%3E%3B%0A%20%20%7D%0A%7D%29%3B) which is reassuring. We're probably not going to end up improving react-tools's parser here but we'll start to recommend Babel more and hopefully that will help for transform-related errors.
 @spicyj Since babel errors are better and will be the recommendation moving forward, are we free to close this out?
 @jsfb No, we haven't added the error for non-string/function types that I said I wanted to add.
 I am closing as this appears resolved.

> No, we haven't added the error for non-string/function types that I said I wanted to add.

I think we do have a good warning now. With 0.14.6:

``` js
var Lol = undefined
ReactDOM.render(
  <Lol />,
  document.getElementById('container')
);
```

gives me

```
Warning: React.createElement: type should not be null, undefined, boolean, or number. It should be a string (for DOM elements) or a ReactClass (for composite components).

Uncaught Invariant Violation: Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: undefined.
```

The error stack is also meaningful because the warning fires early in `createElement`.

The lowercase `<lol />` would render to an unknown custom element but we are tracking adding a warning to it in #3596.

I‚Äôm closing but let me know if I missed something.
  Thanks for the bug report!

I think you're probably looking for the react native repository, which is located here: https://github.com/facebook/react-native

If you post the issue in that repository, I think they'll be better able to handle the bug report.  This repository is actually for tracking react-core and the web-version of react.

Since this issue probably isn't related to react-core, I think it makes sense to close this issue in this repository.  But I encourage you to post in react-native.

cc @zpao and @spicyj in case something jumps out at them related to react-tools or npm bundling.
  We made a change to JSX parsing in 0.13 to fix some somewhat ambiguous cases around `>`. [We documented this in the changelog](https://github.com/facebook/react/blob/master/CHANGELOG.md#breaking-changes-3) (which also has a link to an npm package we distributed to find and update places that would be an issue). In your case you can probably just use `&rarr;` for a full arrow or `&gt;` if you really want to keep ascii arrows :)
  :thumbsup:
  Inputs have somewhat complicated logic to handle user interactions and making sure state changes are handled correctly. This unfortunately means there is probably more code running for each of these than there is using jsblocks. Now we probably could do a bit of optimization for `type="hidden"` inputs so we don't have to do as much setup for user handling. That would be interesting, though not sure how valuable it would actually be in typical cases with a handful of inputs (7000 hidden inputs is a pretty contrived use case).
  This is expected; see #3610.
  You can do

```
<i data-icon={String.fromCharCode(0xf00f)} />
```

or if you have it as a string for some reason,

```
<i data-icon={String.fromCharCode(parseInt('f00f', 16))} />
```

Only the JSX compiler parses HTML entities; React doesn't so you should use the Unicode character instead.
  > This implies to me that it should be perfectly safe to update the state here to diverge from the state encoded in the initial server side HTML representation... If I replace the "this.setNow()" with "setTimeout(this.setNow, 1)" that fixes things, but it seems like a nasty hack to me.

Yeah your code seems fine to me. If React is able to reuse the markup it should just work and if not React will emit a warning but it should still just work (suboptimally). As it works when you defer the update seem to indicate that React is doing something wrong I would say.

#1839 _might_ be related, not sure which PR/commit is relevant though. cc @spicyj
 This example works fine for me:

http://jsbin.com/vupagekuvi/2/edit?html,js

@mikecardwell Any chance you can get a repro in jsbin?
 Thanks for the example. Looks like this happens with full-page rendering when you try to re-run the React.render in the `head` tag because the body hasn't been parsed yet and so React can't find it when it goes to do an update. I think it's best for us to not support this pattern (and recommend you call React.render in a script tag at the end of your body or on DOM ready) but maybe we can give a warning for this.
 Looks like this is resolved on your end, so I'm going to close this bug and track warning-for-render-in-head as a separate issue for clarity: https://github.com/facebook/react/issues/3800
  Looks good to me.  Tested the new URL, it does resolve.  The only thing the tutorial appears to be using jquery for is $.ajax, and that api hasn't changed, so this change should be safe.
 Thanks for the fix @kubosho!
 There's only browser compatibility differences, but jQuery 2 is probably fine for this.
  I just ran this example with React 0.13.2 and my data-reactid looks like: .0.2.0.0.

What browser and what version of React are you using?  Can you create a jsfiddle that demonstrates the issue?
 `$[object Object]` means you have `<comp key={anObject} />` somewhere in your code, everything that goes in `key` is stringified so you can only have primitives there (**EDIT:** for now at least).

PS. Also it's definitely not the right code snippet by looking at the id.
  I'd rather we not do this here. Can we set up a redirect somewhere else like we have for reactjs.org and reactjs.com?
 Sorry I wasn't clear in my comment in the issue. I meant that I want react.js.org to redirect to facebook.github.io. I don't want react.js.org to ever work on its own. We could set up a new project with a cname and index.html that just does a meta refresh. Or we could point it somewhere else with actual 301 headers.
  As @gaearon said, React never reads from the DOM and mutating React-rendered DOM from outside of React isn't supported.
  getMarkupWrap is already meant to handle these cases:

https://github.com/facebook/react/blob/master/src/vendor/core/getMarkupWrap.js

Unfortunately it looks like `image` isn't in the list. Since we don't want to add these all one at a time we'll need some alternative way to deal with this.
  Yeah, unfortunately there's no way for you to manage only the tbody in React for the reasons already mentioned.
 @StoneCypher That's true but it doesn't help here.
 @scarletsky If you can post a simple jsbin that shows the problem (in a new GitHub issue, ideally), I'll be happy to take a look.
 Thanks for the solid test case.

I have not confirmed, but I believe this is also a manifestation of #2410. I believe it would be fixed if you instead added and removed rows in the stores in response to CHANGE_TABLE_ROWS directly (and drop ADD_ROW and REMOVE_ROW completely) instead of chaining actions together in componentWillReceiveProps. What you're doing here is generally considered a Flux antipattern and also ties your code to your views more, which makes it harder to refactor your code later. I'll leave this open until I can confirm that this is in fact a dupe of #2410.
 Yeah, I'm 95% sure this is #2410.
 @scarletsky I am not a flux expert, sorry ‚Äì but my understanding is that chaining actions is always discouraged.
 > Should my store.table, store.rows, store.cells listen to CHANGE_TABLE_ROWS action to change themselves ?

That's how Redux apps should work, yes.
  @alexpien - would love to see this finished if you have the time!
 Sorry for the delay. I merged locally & pushed to avoid another roundtrip where we drop the ball again while you rebase. Thanks for your patience!
  cc @graue 
 @gaearon: When I said this was already supposed to be supported, I was thinking of the behavior in this test:

https://github.com/facebook/react/blob/master/src/test/__tests__/ReactTestUtils-test.js#L92

We should maybe support your suggested way as well, but does that approach to testing updates help you?
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 @meatballhat I see that this now finds grunt successfully, but the tests still don't pass. They haven't passed on master for a few commits now due to this grunt problem, but they should pass if grunt is found, so something else is wrong here.
 @meatballhat I've never seen them before. With a fresh clone of this repo, running npm install then `./node_modules/grunt-cli/bin/grunt test` works for me with no problems locally. This Travis build from a couple of days ago passed with no errors and we haven't changed the dependencies since then:

https://travis-ci.org/facebook/react/builds/60015425
 My theory is something with npm versions. I went with my #3722.
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Can you explain in more detail why the old code didn't work and why the new code does?
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 We're not planning to add more utils like this to TestUtils. You can always implement this locally in your project as a helper if you want to, but we're planning to move towards shallow testing (i.e., TestUtils. createRenderer) in the future.
 Yes, thank you.
  I don't want that to be the canonical link. I still have plans to eventually make reactjs.com a thing (with content that doesn't work on gh-pages). A redirect would be fine so we could update when we get there (I guess we'd need a different gh-page project for that).
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 ![spam](https://cloud.githubusercontent.com/assets/8445/7353226/edb57b88-ecc6-11e4-8de0-9a6b098cb880.jpg)
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 This has a ton of overlap with #3067, we should probably focus our efforts. cc @jsfb to figure out the best path forward.
 Yeah, let's check the status of #3067 and once we figure out what to do there, we can take another look at this PR.
 Cool, this looks good to me.  :+1: 

cc @zpao @spicyj Any objections or is this one good to go?  (modulo travis build failure)
 Should be `props.is != null`. Can we extract the logic to a helper function? (Side note: when is `this._tag` null?)

Ideally we would do something intelligent when the value of the `is` attribute changes since I assume we need to remount the element to have things work properly. (That sounds harder though and certainly doesn't need to be done in this PR.)
 @spicyj Just to confirm, you're looking for a helper function that takes in tag&props to decide if the element is a webcomponent?
 Yeah. It was more convincing when I thought it could just take `this` as an argument, but tag and props seems good.
 Thanks @jhicken!  Looks great to me.
  cc @syranide, our resident event expert these days.
 @jsfb Haha, I'm not _that_ familiar with the events actually ;)

Anyway, #2011 is kind of related. If the value that's meant to go in `relatedTarget` is available elsewhere in the event then it would obviously be easy to normalize, but I doubt it is, which makes it unlikely that we can/want (fragile, etc, etc). Generally speaking though, you should never need to access `relatedTarget` in React so I'm curious what you need it for?
  Nice find. We should use the same version. Are you interested in creating a PR to update it?
  I'll take this for consistency with the other functions here, but I'd really discourage you from mutating Object.prototype. Most libraries break if you do. For example, jQuery doesn't support it.
 Yea, we'll definitely break in other places too (eg, #3665 was entirely about getting rid of hasOwnProperty for objects we created and know can't have certain keys that would be an issue). This looks like a case where we're already using our generated ids as keys so we should be able to consider it safe.
  Are you suggesting we make syntax highlighting in the output of our Markdown example?
 We're not going to do that. It's a simple markdown example and the mechanism for highlighting in our docs is vastly different.
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 Thanks!
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 Is there more? Would be nice to bundle these together.
 Meh, merging. Thanks!
  I don't think this is quite right ‚Äì since you're storing the timeout ID as a global now, you're mixing timers from different components together. You'll probably want to store it as `this.noEventTimout` or similar.

How did you test this?
 It doesn't necessarily need to be a programmatic test, though that would be great. Would be good to know that it worked in manual testing at least.
 @sejoker Are you interested in finishing this?
  That's kind of annoying but yea, we might need to do something like that. Compilers are a dependency for any binary npm module (which one of our dependencies depends on). Even contextify itself doesn't call out the need for g**. When you install node / npm via `apt` does it not install `build-essential` as well? It seems like it should since that's a requirement for many modules.
  I shipped jstransform 0.11, which now has the CLI and API from react-tools. The intention was to deprecate react-tools entirely so we have 1 less thing to support (and it lets us ship transform updates outside the React release cycle). I'm not sure if we just won't ship react-tools 0.14 at all or if it'll basically re-ship jstransform.

If you're a hawk and watching this repo, and wondering what that means for you, here are your options:
- Switch to jstranform. I wrote [a migration guide](https://github.com/facebook/jstransform#migration-guide) for you.
- Switch to babel. It supports many of the same things jstransform does and more.
- Do nothing. We don't really suggest this but it's an option. We won't un-ship react-tools from npm so as long as you used versions correctly, you should be able to keep chugging along.
- [x] remove transforms from here
- [x] make sure our build still works
- [x] make a react-tools that still works like the one we have
- [x] make sure JSXTransformer still works (did not make a new one of these for jstranform).
 It probably won't fix it since we have a build process. The better fix for that (which we'll get back on track with) is to have us publish alphas to npm.
 Ok, we'll still need to add a proper deprecation notice on npm and probably write a blog post, but otherwise we're all done here.
 Deprecation notice applied to npm, blog post posted, I think we're done here.
 Heh, thanks for coming back and closing. We're long done.
  Thanks! Sorry for letting this fall through the cracks :(
  return `null` instead and that will work.
 I thought we talked about it more, but I guess not, maybe just release notes and briefly in the docs. http://facebook.github.io/react/docs/component-specs.html#render

`null` and `false` both work (to support the `return condition && <Component/>` pattern).
  cc @chenglou who never merged #3566. Like this one better?
 Hummm well #3566 was done so that it doesnt break existing custom validators. If we are to break it, might as well pass arguments in an object like you said?
 An extra arg won't break custom validators right? Or did I not look closely enough at this?
 Ah right. That's fine then. Still, might be better to pass an obj in the future I guess
 @Morhaus Sorry, this got a bit buried. Can you rebase and squash the commits? Travis should be all ok now.
 Merged, thanks! https://github.com/facebook/react/commit/490d8835fc6fde5066260c4ff2f40fef7973cdb9
  We don't plan to maintain TS definitions, but you can use the ones @vsiao linked. If there's other things we can do to be more TypeScript-compatible, let us know. You should already be able to use TypeScript classes as React components like any other ES6-esque class.
  @reactkr review please.
 Thanks as always!
  Not super easily, unfortunately ‚Äì but if you break on that warning in the debugger you should be able to see what objects are involved (and perhaps even the problematic render function) by looking down the stack.
 We do our best to include context when we can but it's not always easy to do.
 Can we look at owner for this one?
 We'd have to thread the owner through flattenChildren, which isn't the easiest. These should already warn on element creation time though in most cases and then you have the stack‚Ä¶
 @TrySpace Can you be more specific, preferably with a code example?
 We're going to stop supporting objects as children so we aren't going to make it configurable. As you can see it causes confusing issues and also stops us from making other advancements.

Going to close out as it seems like we can't make this part of the warning better. See #4840 for a related discussion about making the warning better in a different way.
  I think this is a feature of Android browsers unrelated to React. See http://stackoverflow.com/questions/7771687/disable-automatic-linking-of-mailing-address-in-webview.
  @wwayne I don't see any bug in React; it appears to be rendering exactly as expected.

You never set the showModal button, so it is always undefined, so it always goes into "modal hide" and you never see the checkboxes.  The checkboxes, if you force them to be visible (I did this by changing the style to red/green instead of invisible/visible), all check and uncheck as expected.

My fiddle, with a few fixes since your code didn't run in jsfiddle as-is: https://jsfiddle.net/edn4evb2/

Can you provide a fiddle that demonstrates the issue you're having?
  Glad you figured it out ‚Äì this isn't React-specific; any error you throw in your component bubbles up to renderToStaticMarkup so however you handle errors in your app, you have to do here too.
  If you use `onClickCapture` does that work? You'd be handling the event in the capture phase so things may be slightly different.

As to why we don't add event listeners directly to each element, [this article](http://www.nczonline.net/blog/2009/06/30/event-delegation-in-javascript/) is a good read. Browsers have improved in 5 years but it's still generally a good idea (especially in a library used to build very large applications).
  @jsfb, can you take a look at this once we're past context changes
 I'm pretty sure we fixed this in https://github.com/facebook/react/pull/3923 or earlier, closing.  Re-open if not fixed.
  This usually means that the user mixed up our lowercase/uppercase naming convention; see https://github.com/facebook/react/pull/3429#issuecomment-85166440.

We could add a message like

> Warning: The tag <commentBox> is unrecognized in this browser. If you meant to render a React component, start its name with an uppercase letter.

We'd check this only once per tag and only in development mode.
 I'd probably add it to the logic in validateDangerousTag inside ReactDOMComponent.js, as that already runs only once per tag. Note that that runs in dev and prod mode for safety, but this new check should probably be wrapped in an `if (__DEV__)`.
 Hmm, SVG makes this a little trickier. Ideally we'd know whether we're in an SVG container or not (which we need for a handful of other stuff) ‚Äì but we don't right now so this may have to wait on that. Thanks for looking into this @kastermester.
  The default props should be already merged in when componentWillReceiveProps is called.
 That's correct. Instead, you write this:

``` js
class Control extends React.Component {

  // ...

  componentWillReceiveProps(props) {
    // Do something with props...
  }

}
Control.defaultProps = {value: ''};
```

Does that work for you?
 @Gopikrishna19 you would need to enable another babel plugin that implements the class properties proprosal: http://babeljs.io/docs/plugins/transform-class-properties/
 @fxhereng The second argument is reserved for `context` so I‚Äôd avoid overriding it with some custom meaning because this might break in future releases.
 If you use the experimental transform http://babeljs.io/docs/plugins/transform-class-properties/, then you can just use `static defaultProps = {...};`. No need for changes to the constructor. Otherwise, you need to assign outside:

```
class X extends React.Component {
}
X.defaultProps = {...};
```
 @efernandesng This is not a supported pattern. It won‚Äôt behave like `defaultProps` and it mutates `this.props` which you should not do.
  cc @reedloden ‚Äì there are probably more of these that don't work in their current state‚Ä¶
 Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 (It's not jsfiddle's doing ‚Äì the link is included in each fiddle by the fiddle's author.)
 For any jsfiddles owned by us, we can fix those. For ones like this which are unowned we can't. But we can recreate them under our reactjs user.
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 Yea, let's close this. I filed #3735 so we don't forget. Thanks for the find btw.
  The shallow renderer's render method currently accepts a second (undocumented) argument, `context`, but values you pass don't actually make it through. If you pass `{foo: 'bar'}` the component receives the context object `{foo: undefined}`.

Related: #2393, #3696
  It's intentional.
 @zpao Why?  I could see reasons to want to make the behavior as similar to real-world as possible.
 It simulates an event in our synthetic event system so you don't need the DOM.
  Did you test this in a browser to make sure that both the initial render and updates work properly? This PR is a lot closer than anything else I've seen so it would be great to iterate on this and get it to a point where it can be merged.

What do you think of the attribute names? Is it reasonable to have people write `xlinkActuate={...}` or is it worth changing the JSX transform to support `xlink:actuate={...}` or similar?
 Okay, cool. Can we combine HAS_NAMESPACE and NamespaceProperties then? (And nit: maybe call it PropertyNamespaces to reflect the meaning of the values?) After that I'll try to test this some but I think it should be good to merge.
 Thanks, merged in 1db70dbef1d6e15936bb2c93a5ca2400167ec9f2 with a few minor changes!
  You now no longer have to pass an undocumented extra argument to the shallow renderer for rendering components with contextTypes to work.

Fixes #3696
 Thanks for the quick fix! My inline comment is just an observation, not something we need to do here.
 You're welcome :) Yeah, actually passing context is broken right now ‚Äî filed #3721 for that. But this will fix the case where the component under test supports optional context.
 @anyong: Sounds like a different problem. If you can create a new issue (ideally with a minimal example that shows the bug, like #3696), we'd appreciate it :)
  You probably want to make sure the environment variable `NODE_ENV` is set to `"production"`. This disables a lot of debugging that can slow down React, including the ReactPerf stuff: with this setting, `ReactPerf.measure` is a no-op and will just return the function passed in.
 If you're intent on using React in development mode, my recommendation would be to fork the version of React you're using, modify the `measure` and `measureMethods` functions in ReactPerf.js to always be no-ops, and use that fork for your performance testing. Just be aware that there are many other checks in React that slow down performance in development mode and may skew your results.

I'm going to close out this issue because it doesn't look like there's anything concrete for React itself to do differently here, but feel free to continue discussing.
 @tjwebb Depending on the build of React you're using, the `__DEV__` gets compiled out (global replace), so setting `window.__DEV__` would have no effect.  You will need to enable/disable dev as part of your build process while compiling React.
 Also ‚Äì it's very unlikely that ReactPerf is causing you perf problems if it's disabled. When measurement is disabled, it just calls the wrapped function directly so there should be barely any overhead. If you're seeing it as a hot spot, it may be an artifact of your profiling tools.
  The decision to not call componentWillUnmount on the server side is intentional.  We can't call componentWillUnmount on the server side because that indicates that it's time for a component to cleanup and shutdown (calling it would mean that components get cleanedup before they ever get sent to the client, which is obviously wrong).

At the moment, some components will attempt to "detect" their runtime environment through the presence (or lack thereof) of particular features, thereby differentiating their server/browser environments.  This can work, but feature detection is fragile and prone to breaking.

Eventually, we may provide a way for users to build isomorphic components against a sever-side or client-side environment, allowing for components to be more aware of their local environment and the features available in that environment (this is still in the early discussion/idea phase).  There are other issues tracking the ideas in this area, including https://github.com/facebook/react/issues/3398 https://github.com/facebook/react/issues/2928 and https://github.com/facebook/react/issues/1979.

Ideally your components get their renderable data directly from their parent (instead of side-loading the data), which eliminates the vast majority of cases where you would otherwise be inclined to open resources on the server side.  Following the simple-data-from-parent model also makes your code much easier to reason about.

Since the current solutions are (1) runtime detection or (2) reorganize app to get renderable data from the parent, and since there are other issues tracking this request, I'm going to close out this issue.  Feel free to continue the conversation here.
  I think the only thing this affects is performance.
 Nice find! @chenglou added support for `null`, perhaps he wants to look into it ;)
 Dupe of #2770, I think.
  Ah, we added notes in the Component API section ([eg a note that replaceState doesn't work](https://facebook.github.io/react/docs/component-api.html#replacestate)), but not for lifecycle methods.
 > I can volunteer for converting to ES6 but not sure of facebook's commitment towards documentation.

Great! As you can see from our [recent meeting notes](https://github.com/reactjs/core-notes/blob/master/2016-05/may-19.md#next-steps), we‚Äôre not very happy about the situation either.

I think we want to convert the docs to use functional stateless components where state or lifecycle hooks aren‚Äôt needed, and ES6 classes wherever state or lifecycle hooks are necessary. We would only leave `createClass` in examples that specifically discuss its usage (e.g. mixins).

@zpao @spicyj Does this sound like what you folks have in mind?

---

> **Note to contributors:**
> If you‚Äôd like to work on this, **please leave a comment in this issue** to avoid duplicated work. Also don‚Äôt want to add _more_ ES6 class examples, we want to **change _existing_ examples** to use ES6 classes.
 @gaearon Sounds right to me.
 Yeah. For now, let's also link to the createClass docs in the tutorial and intro docs after showing React.Component as an alternative for people who don't want to use ES6 classes.
 @gillchristian @jakegavin 

Feel free to organize the work between yourselves in this thread! e.g. you can write ‚ÄúI‚Äôd like to take pages A, B, and C‚Äù so others can see which pages you‚Äôll be working on, and can join to say ‚Äúcool, I‚Äôll take D and E‚Äù. This way we can split the effort and track the individual progress.

> the core team notes say "We could just always bind in constructor in the documentation." I just want to verify that's the final decision since the wording make it sound a little uncertain?

Yes, we won‚Äôt use class properties in the docs. We only want to use stable ES2015 syntax. So if we need to bind an event handler, we will do this in the constructor.
 @gillchristian Yes, master branch. Thanks!
 > Why not skip ES6 and migrate into function stateless components?

Because many examples in the docs are concerned with state and/or lifecycle hooks. I did suggest that we use functional components where possible though.
 @gaearon since you're leading this effort, can we track progress somewhere? Maybe hijack the original description with tracking. It's hard to know what the state of this is at a glance.

Also, ideally we land all updates at the same time (or within a couple days) and we get each update to a place that we're happy with before merging. Or if we need to change language we do it immediately as a followup. Otherwise our docs are going to get worse. In particular the tutorial being the main place that people learn React is going to need a lot of attention as topics need to be introduced and discussions intentionally and in the right order.
 Hey folks, thank you so much for contributing ‚ù§Ô∏è 

I didn‚Äôt expect people to react this actively, this is awesome üòÑ . It is a large change though, and we need to make it cohesive for it to work well. I‚Äôm currently preparing for my talk at ReactEurope next week and can‚Äôt dedicate time to this yet, but in a week and a half I will be ready to review all of these changes, address them, and merge them together.

Cheers!
 I think we should do the following:
1. Of ES6 features, use only classes, arrows, and destructuring.
2. Don‚Äôt use `let` and `const` because it is distracting while we still have _some_ ES5 examples.
3. For functional components, use functional declarations because they work the same everywhere.

These are just guidelines that I have in mind so if they make no sense, let me know.
 Yes, but I propose to declare functional components as

``` js
function CheckLink(props) {
  ...
}
```

which is the most familiar form. Arrows are find to use elsewhere though, when helpful.
  @spargonaut Can you provide two fiddles.  One that demonstrates that it works without React, and a second that demonstrates it does not work with React?
 Ping @spargonaut
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 I'm quite certain that this isn't going to work (for updates, initial render will be ok). `xlink:href` actually needs to use `setAttributeNS`, which we don't currently do.

See some of our other discussions about better SVG support (namely #1657). Adding them piecemeal like this isn't really tenable. I'm going to leave this open for a bit but we may close it out and do things a bit differently.
 Closing this out as we need something more sophisticated for this to work. #3718 may solve this problem ‚Äì haven't looked at it in detail yet.
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 Thanks!
  I'm pretty sure `_renderdChildren` should never be undefined at that point. But I haven't really touched that code. Perhaps @spicyj or @sebmarkbage can say with more certainty.
 It could be that something else is throwing and therefore causing `_renderedChildren` to be undefined at that point. We don't do very good error recovery so if you have one error, you'll likely have more subsequent ones like this one. The work on error boundaries should help with this.

It could also be a strange VM bug. We've sometimes found similar errors in our logs from Android phones using Chrome. Is there anything more you can say about the source of these errors?
  Idea (that I'm pretty sure I saw elsewhere, react-native maybe?)‚Ä¶

We should transform our `invariant` calls to a conditional wrapping the call. We have to check the condition _anyway_ and this would reduce the no-op function calls.

In otherwords

``` js
function doSomething(someArg) {
  invariant(someArg !== undefined, 'hey doofus, don't pass undefined');
}
```

becomes

``` js
function doSomething(someArg) {
  if (!(someArg !== undefined)) {
    invariant(false);
  }
}
```

Hell, we could replace the `invariant(false)` with `throw new Error('whatevs')` and get rid of the function call entirely, though it really doesn't matter much since we're going to throw (plus we'd duplicate the default string).

This might end up be a meaningless optimization‚Ä¶
 > This might end up be a meaningless optimization‚Ä¶

I believe this is done intentionally (by hand) in some hotspots, so it would seem not.

I guess one could argue if it might not make more sense to simply always use the inline style and drop the argument rather than adding another transform?
 > I guess one could argue if it might not make more sense to simply always use the inline style and drop the argument rather than adding another transform?

That's a tough sentence to parse. Are you saying we should always write the "optimized" form? If so I would say "no", the first is way easier to read as a human being.
 We have complex invariants that aren't strictly about arguments so while that might be an option for some cases, it doesn't cover us.
  Yeah, this is that issue. Works correctly on master as long as you keep the tab focused ‚Äì if you background the tab you run into #1326 though.
  Not a bad idea, however we're probably not going to add features to react-tools at this point. I would suggest giving babel a look.
 Now we've officially changed our code+recommendations to Babel.
  cc @bolinfest - have you guys done anything to work around this? Sounds like something that should be possible to force Atom to do.

@francoislaberge I'm not really sure how this would work, especially since our prod build actually strips out the friendly messages entirely. Our npm package (which is basically what Atom is using) is already after a build step which makes it possible to get that dev OR prod build (that's the switching you did, but now that I think about it‚Ä¶).

But actually I may have misunderstood and there might be a way to make this work‚Ä¶ are you installing your own React or using the one that ships with Atom (if it still does)?
 `require('react/dist/react')` will give you the precompiled dev build (the same one we ship to CDNs). The other pre-built files are in `dist` as well.

There are downsides‚Ä¶ if you're using anything from `React.addons`, make sure you _always_ use `require('react/dist/react-with-addons')` (otherwise you'll hit problems with multiple Reacts). If you're using any 3rd party components they won't interact well (same reason of multiple Reacts).
  Thanks!
  :+1: Yes, @basecode, Thanks!  Unit tests are always much appreciated! 
  I think this is a known issue with shallow rendering. cc @jsfb @graue 
 @matthewgertner, thanks for the report. Context isn't meant to be supported with shallow rendering (i.e., we haven't tested it), but it looks like you may be able to work around this problem by passing an object as the second argument to `render`:

``` .js
var renderer = TestUtils.createRenderer();
renderer.render(<Foo/>, {});
```

@jsfb, it looks like an additional `context` argument was added to the shallow rendering API in 081feeb2dd97ae0854a7d2448232e651c7330344. What was the thinking here? Can we default this to an empty object?
  Yea, I stand by my response there :) The crux the argument there is that the language already supports these constructs so use the language. JSX is supposed to be a simple. We really don't want people to learn a new language to use React+JSX. The answer to "how do I do a loop in JSX?" should be "the same way you do a loop in JS".
  Thanks!
  Alright, let's do it. Dear translators (@marocchino and the KO team especially), I'm sorry! You may be able to get a bit fancy and do some processing on the patch to automate this but otherwise it might be a bit rough.
  I think you want `PropTypes.oneOfType`. `oneOf` is basically an enum.
 No problem. You're not the first one to do that (and I'm willing to bet you won't be the last :) )
  Someone running this on a simple http server would also fail shortly after when trying to POST to a JSON file :)

I'm fine with adding it. I think last time somebody started to, they never addressed review comments, which is why this is still like this.
 :thumbsup: thanks! We'll pick this up on the website in the next few days.
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 Merged in e3cf48cd7fd4fa543134a289d12783cce828b048 -- thanks!
   I don't want it Blub, I want it Blob
 Let's call it React‚Ä¶
 _for anybody who is super confused‚Ä¶_

This was a test of the bot to automatically label PRs as it goes through the review process.
 I forgot that so many people were listening to pull requests, sorry about that :x
 This was my inspiration!
 testing
 testing 2
 testing 3 (sorry folks, testing emails)
 @bloodyowl Put https://gist.github.com/vjeux/68fc9285791eef56e2c3 anywhere on the internet that can execute PHP and add a webhook to that file. You also need to generate a token with the account you want to update and put it after `$token =`
  The gh-pages branch is autogenerated. Please make changes to files in https://github.com/facebook/react/tree/master/docs, which is what we use to generate the html.

GitHub will force you to make a new PR since you're targeting a difference branch, so closing this out.
 (also, hi Reed!)
 Also, @reedloden : There have been some discussions (and some fixes) of this stuff before, and while I haven't looked into all of these specifically (there are a lot of them) there were some reasons that we haven't switched everything over to https yet.

For instance, the download links point to a CDN, and while the FBME url is httpsable, it immediately redirects to a HTTP CDN, so making the FBME url https doesn't actually protect anyone (and might give people a false sense of security).

Also, for the embedded jsfiddles, switching to https will sometimes break the rendering of results, so we need to be careful with those (I don't remember the details, but I'm sure there are some PR/issues about it in the history).

Anyway, we'll need to look at the ramifications of switching individual URLs, it's not as easy as doing a global search-and-replace and expecting/hoping that everything will work.  It's probably worth taking a look at that history so you can pre-empt some of the issues you're likely to hit when doing this migration.
 @reedloden For example you changed https://fb.me/react-with-addons-0.9.0-rc1.js

But yeah, anywhere we are do support HTTPS CDN, we should absolutely update those links to be HTTPS.  I tend to agree that even if it redirects to an HTTP CDN, maybe we should update the urls in anticipation of that switch.  I'm just saying that there has been some discussion about this in the past and there is a valid argument to be made that it could be confusing/misleading because https is redirecting to http.  Just wanted to bring such discussions to your attention.
 0.13.0 and under didn't use https on the redirect

```
~% curl -I https://fb.me/react-0.13.0.js
HTTP/1.1 301 Moved Permanently
Location: http://dragon.ak.fbcdn.net/hphotos-ak-xpa1/t39.3284-6/10734320_1571131556471061_497798403_n.js
```
  The proptypes are just functions that you can call to manually verify the props.  You could always iterate over your props and manually call the proptype function to verify their type.
 As much as that's true, it's not really super useful.

@joshfrench I believe you should get warning when receiving new props (or actually before) - we're running the validations when creating a new element (which we then use to update an instance). As for prior to rendering, props should be immutable and we warn on mutations so you should get those too :)

We talked about these a bit before we launched 0.13 (http://facebook.github.io/react/blog/2015/02/24/streamlining-react-elements.html#immutable-props) precisely because validation is important and there are lots of places it can happen. If you haven't updated to 0.13.x yet I would encourage you to.

Otherwise I don't think we're going to expose anything to check proptypes at any given point.
  There's some discussion about this already in #3399
  Ah I understand the confusion `initial____` or `initial<whatever>` might be slightly clearer if you wanted to do something like that. I'm fine either way.
  Hmm, we try/catch this with the expectation of it throwing in a sham environment. https://github.com/facebook/react/blob/0.13-stable/src/classic/element/ReactElement.js#L69-L81. So when we catch we just simply don't have "frozen" props.

And we don't do this at all in production. Not sure what exactly you're hitting here.
 @codeuniquely It sounds like you're saying that development in IE8 sucks but that there isn't much we can do about it, is that correct?  Is there an action item on our end, or should we close this one out?  Or do we think there is still a React bug here?
  This is just how JS works with objects, they're effectively always passed by reference. You would see the same thing if you use typical JS protoypes. http://jsbin.com/rujutijaku/1/edit?js,console

We explicitly don't clone everything from the object you pass us (that becomes a pretty unscalable solution). Because we autobind functions, we do create new functions for each instance due to the binding. As Felix said, you should probably use state. Since you're returning a new object from the `getInitialState` function, you don't have the reference issue.
  Make sure you're not unintentionally running in debug mode, there is a performance regression in the debug version of React 0.13.
  In 0.14 we'll have a warning for this. :)
  original [diff](https://gist.github.com/marocchino/b7ba36cec6be343b0f4a) is here.
@reactkr review please.
 Thanks!
  They're supposed to be, but we're checking for setState here:

https://github.com/facebook/react/blob/v0.13.1/src/test/ReactTestUtils.js#L77-L80

Not sure what the best fix is ‚Äì @sebmarkbage? Seems like we could look to see if the internal instance is an instance of ReactCompositeComponent.
  Setting `key` like in your example is **wrong**, it should be put on the `<li>`, the children of the array. The paragraph is correct, but perhaps confusingly worded.

The effective key for a component is the concatenation of all keys and indices up to that point, so by putting the key on the inner child as in your example (always index 0) it has no impact on the outcome.
 I think the old example (where we're adding the key directly to the `<li>` elements is a better example of what we're trying to indicate.  The old example is teaching the "right way".  If something is unclear though, we should consider updating the surrounding text to do a better job of explaining the intent, but the old example seems better, and it's not entirely clear to me how the text should be updated.

The fact that React reads the key attribute and generates a unique attribute and attaches it to the DOM is true, but it's an implementation detail (@syranide, correct me if I'm wrong, but I'm pretty sure that's an implementation detail) and stating it explicitly there might add as much confusion as clarity.  The only important api point is that you can uniquely identify each child by assigning it a `key`.
 @jsfb The inclusion of the final concatenated key in the markup is definitely an implementation detail (but the concatenated key itself isn't).
 @syranide Ok, good.  Is the concatenated key ever exposed to the developer (except through the DOM?).  If it is only exposed through an implementation detail, then I think I'd argue that the concatenated key its self is also an implementation detail.

Either way, we just want to be careful about exposing implementation details in the documentation.
 @jsfb No it's not. The concatenated key itself is also an implementation detail (and an inefficient one). All child instances should ideally be stored by key (or index) in the parent instance and it would have the same result, but the concatenated key might be a good visual explanation of how it all works though.

PS. If we're going to visit reparenting of instances in the future then it likely require a separate key-scheme (co-existing with the current parent-based one)... but the parent-based one is here to stay I'm sure.
 Let's bring it back to documentation and discuss implementions elsewhere (like IRC in realtime)...

I don't think we need to make this change to docs. We want it to be `<li>` and I don't think we should say that 2nd half of that new paragraph. We can clarify the use of key but differently.
  Thanks!
  They've been updated but nobody put the right labels on that PR to make sure it got cherry-picked :(. Done now though. Might take a few minutes for caches to clear and the page to work properly.
  That does not make sense, I suspect your copy of React has been modified (probably by search and replace by mistake?).

https://github.com/facebook/react/blob/master/src/classic/element/ReactElement.js#L156
 Yeah, this isn't React ‚Äì not sure where you got "code". If you search https://fb.me/react-0.13.1.js for "key = config" you'll see that our built copy has `key` as well.
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 Thanks!
  If you have a repro it would be great.

Is "materialize" perhaps modifying the DOM? It kind of sounds like it, that's a big no-no, you _may_ update styles and props of React managed nodes without errors, but if they're cloned/replaced/moved then it's an invariant error waiting to happen.
 Not an actual React bug so closing out. The fact that materialize is modifying the DOM means you're probably going to have a tricky time of things and you'll probably want to build some wrapper components to make things work better. Good luck!
  What @yaycmyk said should work.
  `hasOwnProperty` within `flattenSingleChildIntoContext` is showing up in the top of [profiling](https://github.com/mridgway/react-perf/blob/singleChild/profile.txt#L12) so I ran an [experiment](https://github.com/mridgway/react-perf/tree/singleChild) with replacing it with a simple typeof === undefined check. Performance difference shown in Travis: https://travis-ci.org/mridgway/react-perf/builds/58356726
 Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 I found many more places that we can replace `hasOwnProperty` calls that may improve this as well, for instance a lot for...in loops.
 Will this fail if I have a key named `toString` etc?

E.g. `<div><span key="toString" /></div>` will cause `{}['toString'] !== undefined` which will make it seem like this was a duplicate key.
 @sebmarkbage I'm not sure if we care enough, but we could create the object with `Object.create(null)` and fall back to `hasOwnProperty` only if that isn't supported (to be replaced with a proper `Map` in the future).
 @sebmarkbage - that was my first instinct too. It looks like by that point we're working with objects where key is `.$hasOwnProperty` and `.$toString` and `.2` for implicit keys.
 Ah. Ofc. I think we even have a unit test for this so they should've caught it. This seems safe "enough" then. Just fix the lint?
 Btw, I doubt you would get noticeable results in a macro test. The reason this shows up in profiling tools is because tiny method calls gets exaggerated. When profile React I'd recommend measuring a larger operation yourself without a profiler and then compare it before/after this change.

Normally we don't trust Profiler + JSPerf tests as trusted sources for optimizations. I don't think this change should hurt though so why not.
 @bloodyowl Creation of the object yes.
 @sebmarkbage Do you have any specific suggestions as far as benchmarking React rendering? I'm having a lot of trouble finding a consistent way to measure performance. Timing at the macro level is highly variable: some renders take 8ms some take 20ms which is why I chose to use benchmark.js around full renders to normalize it across many executions.

Also, there are a lot of for...in + hasOwnProperty loops throughout the codebase that could be updated to use Object.keys and for loops. Should I submit these updates as a separate PR or include it here?
 We haven't used Object.keys in part due to worries about GC overhead. ReactDOMComponent.js has the other places that are likely to matter for perf.
 (I guess there are a few in ReactMultiChild.js too.)
 Thanks!
  Put `<tbody>` in your `<table>` and it will work (i.e. `<table><tbody>`).

@zpao Yet another reason to drop the optimistic traversal if you ask me (perhaps something like #2262)
 @syranide In master we now have a warning, at least.
 @spicyj Fantastic :)
 @RudmanMario That's what I meant by my comment, sorry for being unclear ‚Äì in the next release we'll warn you explicitly and suggest adding a tbody tag.
  Looks like this is a permissions error. `react-tools` doesn't run anything on install so I don't think there's anything we can do. Can you `npm install -g` anything else?

This sounds like an issue to take up with npm.
  cc @syranide @salier - do we need to special case this & listen to a different event there?
 cc @spicyj I think?
 ^ Also broken on Chrome per #4733.
 @AdamBoxall You're welcomed to submit a pull request.
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 Thanks1
  I think the motivation was performance (it is expensive to create lots of short lived objects, puts lots of pressure on the javascript garbage collector).  onClick wouldn't be a big deal, but a mouse-move event could fire very often.

Having said that, this issue keeps coming up as a surprising/confusing part of the framework (lots of people spend lots of time debugging an issue before they realize the problem), so it might make sense to consider changing this.  cc @zpao @spicyj 

But yes, we should document it if we are going to keep this behavior.
 @jsfb https://github.com/facebook/react/pull/1612#issuecomment-44561241
 Closed with #4634
  Drag and drop events are not normalized by React (at the moment).
 https://github.com/facebook/react/blob/master/src/browser/syntheticEvents/SyntheticDragEvent.js is the entire implementation (extends SyntheticMouseEvent which is normalized though), so `event.dataTransfer` is not currently normalized.
 I‚Äôm closing this as a duplicate of #2676.
  http://facebook.github.io/react/docs/reusable-components.html#es6-classes does reference this. It might be good to also put some documentation in http://facebook.github.io/react/docs/component-specs.html#getdefaultprops to make it a bit easier to find. I'm going to close this out since it's invalid but I'd love to see a PR with more docs :)
 I think you should have also seen a runtime warning for this?
 @tjwudi Thanks, looks like an oversight. Fix incoming‚Ä¶
  @jsfb You made this change in 6f44f6049edfd7a66448ac50cd4415f6c26fd4b5. What page did you mean to link?
 The same bad link is on http://facebook.github.io/react/tips/dangerously-set-inner-html.html and should be updated/removed.
 Oh, just realized this was a PR instead of an open issue.  All I saw was that @spicyj assigned it to me :).  Oh well.  I guess there are now two PRs for this.

Yeah, I think the line about the sophisticated example was supposed to move from docs/docs/ref-07-special-non-dom-attributes.md to 19--dangerouslySetInnerHTML.md, but somehow (erroneously) replaced the last line of children-undefined.

@koba04 Thanks for identifying this and proposing the fix!
 We'll go with #3723 ‚Äì @koba04 thanks for bringing this up!
  Seems like bad practice to me (you're exposing internals), the general advance AFAIK is to create stateless components and provide a stateful wrapper components for them. This may be preferable even if you're only interested in stateful components as it separates logic from presentation.
 Not an actual issue so closing out. Feel free to discuss further here or (ideally) the mailing list.
 @andrerpena Yeah, I agree with @syranide; sounds like a bad practice.

The design I use in my React code is to have a mutable AutoCompleteState object that is created&held by your controller-component, and pass that down to your autocomplete component.  Your autocomplete component is free to manipulate that state object, and the API of that state object can expose any state that the autocomplete desires to expose.  That way, the state is still all held by the controller-component, but the internal state is also opaque to the controller and is a single variable instead of a whole mess of internal variables that the controller doesn't know/care about.

Personally (and note that this isn't the opinion of the React team/community at large, just my extremist view), I think that all components should be either: 1.  purely state+logic (no user interface, behave like a controller) or 2.  purely render functions (a stateless view of the data).  I always pull a component's internal state into a mutable object and keep it in the controller component, but I do it as a single "internalState" variable for each subcomponent to avoid long chains of callbacks and variables-I-dont-care-about.

My model (same that @syranide mentioned) turns out to be particularly good for examples like the one you highlighted, because it means the controller can easily "read" the "value" of the text component (from the public API of the component's state variable) rather than responding to callbacks (to set a variable in the controller that remembers the value).  The parent never needs a reference to the child component and never needs to respond to the nightmarish hell of callback chains.  It also gives the parent an easy way of "resetting" the child component (throw away the internalState object and create a new one); something that is not easily achievable when the children have state.

Of course, there are still plenty of use cases that warrant callbacks and individual props, so use your good-engineering-discretion; don't go crazy with the single-variable idea.  Generally, anything that a parent will likely control/edit should be separate from anything that is "internal component state"
 @jsfb :+1: Just a quick side-question, do you guys have a good component naming convention for that pattern?
 Usually we just try to pick a name that makes sense for the component we're building.  The biggest recommendation I can give is that for a given component (eg. `UserAutoSuggest`), give the class that defines that components state a name that combines the component name and the word `State` or `Data` (eg. `UserAutoSuggestState` or `UserAutoSuggestData`).

We generally use the word "container" to describe a controller that holds the UI components, but that's not common in the community (that's mostly our word internally at Facebook).
 Does this help? https://github.com/matthewwithanm/react-controllables
 Posting here, mostly so I don't loose the link when people inevitably ask me about this again.  A good article about state hosting: https://www.safaribooksonline.com/blog/2015/10/29/react-local-component-state/
  This doesn't seem intentional. I also can't repro in master. If we can track down what fixed this, it might be worth backporting into 0.13. cc @sebmarkbage, @spicyj 
 This might have something to do with the binding itself. We used to effectively call `new this.template.type()` which is not a bound function. However, we now switched to calling `new this.template()` which is a bound function. However, calling native `.bind()` should not bind `this` for the Construct operation which is invoked when you call `new` on a function.

If that is the problem, then this should still work in the production build, if no polyfill overrides `.bind()`.
 Actually, this particular issue is probably more related to #3638 but there might be secondary issues with this pattern after that.
 For posterity, never ever do:

``` js
    render: function() {
        var tmpl = React.createClass({
            render: function() {
                return <p>{this.props.data}</p>;
            }
        });

        return (
            <MyComponent 
                template={tmpl}
            />
        );
    }
```

You're creating a new class every render which is slow and doesn't reconcile.
 To be clear, you can do this instead:

``` js
var Template = React.createClass({
    render: function() {
        return <p>{this.props.data}</p>;
    }
});

var App = React.createClass({
    render: function() {
        return <MyComponent template={Template} />;
    }
});
```
 This is fixed by #3638
 If `Template` is `'div'`, then `<Template />` will render a div. You can also pass `<MyComponent element={<div>some content</div>} />` and return `this.props.element` inside `MyComponent`.
  There's been some interest in this recently (#2956, mailing list). Unlike the other helpers, this strips nulls per https://github.com/facebook/react/issues/2393#issuecomment-100573767.
 I like this too!
 Updated, now skipping nulls per https://github.com/facebook/react/issues/2393#issuecomment-100573767.

@sebmarkbage?
 > Unlike the other helpers, this strips nulls per #2393 (comment).

But that means it's (kind of) unsuitable for rendering right? Stripping nulls messes up implicit indicies which is not obvious.
 This doesn't have implicit indices since they are preresolved into explicit keys.

We're looking at ways we can encode the explicit keys in the same ways as if the toArray function wasn't used or as if they were nested.
 If it's a single child, this.props.children already works. If it's an array containing one element and you want to extract it, your best bet is probably to use forEach and store away the first child that comes out, something like:

```
var child;
React.Children.forEach(this.props.children, function(c) {
  child = c;
});
```
 @iammerrick: Both @spicyj and @sebmarkbage are out of the country at the moment, and have limited network connectivity.  I think everyone involved would still like to see this get merged, but we're trying to prep a 0.14 release and this is not a high priority item at the moment.  I imagine we will revisit this after 0.14 ships.  Feel free to ping this issue again after 0.14 ships, as that's probably the best time to restart these discussions.
 (Hi from Venice!)

I think we want this for 0.14. We wanted to make it so switching from this.props.children to React.Children.toArray(this.props.children) when rerendering does not change the keys of all children, which is currently hard.
  Can you be more specific? What did you expect to happen? What happened instead?
 You probably want this. But even so, your script probably won't execute (most browsers won't execute scripts when innerHTMLed.

``` js
<script dangerouslySetInnerHTML={{__html: `
  alert();
`}} />
```
  I don't have any objection to bumping the limit to some number in the millions ‚Äì or we could probably get rid of the check too.
 @greeze It was bumped from 100 to 10000, which should be more than sufficient for most use cases.  Can you elaborate a bit on your use case?
 @greeze The official recommendation is to update; we recommend that you always stay on the latest version of React!  If it's a one-off hack until you get a chance to upgrade, you could always open up the `react.js` file in your project and tweak that number manually, but that's arguably worse than forking the source :P.  
 Curious: what's preventing you from upgrading?
  I think ES6 is the "new" way of doing things, so probably just update the existing examples.  Feel free to submit a pull request.  cc @sebmarkbage @zpao
 No, we're not ready to recommend ES6 classes to all newcomers. See #3375 for more details.
 @spicyj is right but we should clarify the blockers before we do want to switch. IMO they are:

1) Property initializers reaches a stable polyfill that we can recommend.
2) The observe() pattern is released and is the primary recommendation for Flux stores (no mixins).
3) We publish an article describing alternatives to mixins.
4) Most popular libraries you might want to use, moves away from mixins.
 Going to close this out as it's likely we'll forget to ever update this even after we update docs. We won't forget to come back to actually making the change when we're ready though.
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 @gregorym, thanks!
 @gregorym Just noticed that there is a related issue (https://github.com/facebook/react/issues/3468) which specifies two additional properties.  Can we get a PR for `mozdirectory` and `directory` merged too?
 I actually think we should revert this and take a closer look.
1. Those properties don't conform to our pattern (camelCase, even if the property itself isn't)
2. This isn't a standard (yet?). It's _ok_ for us to add support for esoteric things but we should not do it blindly.

I'm going to revert and we can discuss some more.
  This seems very unlikely to me. Can you post a repro case?
 Oops, never mind ‚Äì this is because `this` inside the iterator function isn't your component. Passing `this` as the third argument to `_.map` or using an arrow function instead will solve your problem.
 Yeah, we've talked some about this: #1255. This is unfortunate but I don't think we're going to change anything here. This is the sort of the thing that a static type system like Flow should be able to catch though. 
  @reactkr Review please. Here is [diff](https://gist.github.com/marocchino/31452e9481e9c0c075d9)
 Thanks!
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
  Provide top level method for rendering subtree (passes context).  I almost wonder if we want to put an underscore in front of this new top level API, since it's maybe not something we actually support yet?
 @browniefed To be determined.  We're still trying to figure out a good story around layers/portals.  Right now, this is our solution stop-gap solution to allow context to propagate to layers/portals, at least until we figure out the whole story.  This will probably be undocumented (like the rest of context) and subject to change until we've figured it all out.
 This went up yesterday; any comments or ready to go?
 Are we going to expose this in `React.addons`?
 Yes, my guess is that @sebmarkbage wants this exposed.  Done.
 @zpao's comment about throwing when no parent is provided.
 FWIW, I still think this name and order of arguments is pretty bad. We've never called anything a "subtree" let alone use that in a method name. Ditto with "intoContainer", `render` also renders into a container but we don't include that in the method name. So I sort of want to bikeshed a bit more before this gets checked in.

`renderWithParentContext(element, node, parent, callback)` or `renderWithParent`, `renderAsChild` ‚Ä¶ or something. Pretty much just anything without "subtree" and "container". And I want parent to be the 3rd argument, not the first.

Or even `renderWithContext(element, node, context, callback)` and skip the part where we actually pull the context off an component and require that to happen by the user (`React.addons.renderWithContext(<Layer/>, document.body, this.context)`)

(apparently this last idea isn't a good one - I talked with @jsfb and he said we might need to pull more than the context, also the thing about context being masked).
 Note that we know that this API is broken going in. It is just a workaround/hack until we can figure out the real one. This is why I wanted this to be a hack on the stack of life-cycles and just use `React.render` to avoid bikeshedding and confusion.

IMO, if we have to introduce another API it makes sense to call it subtree because it is a new concept that we're introducing.

This concept is not limited to context. There are many other things that affect subtrees that we might want to bring into this:

1) Debugging structure. E.g. tooltips shouldn't show up in the top level of React DevTools but rather in their respective subtrees.
2) Automatic clean up if the parent tree is unmounted.
3) Event bubbling.
4) Reconciliation order (`_mountOrder`).
5) Maybe refs unless we fully kill old-style refs? Maybe more?
 `renderSubtree(element, node, parent, callback)`?
 That signature looks more "unexpected" to me, because it looks so similar but is actually subtly different.  I would glance at the function and think I knew the signature, only to be surprised by the parameter in the middle.

Also, it splits the parent from the child in an awkward way.  `function(parent, child)` or `function(parent, child, container)` feels more natural than function(child, container, parent).

But I don't have a strong preference one way or the other.  If Paul likes this version better and there are no objections, I'll make the change.

Last call for objections @sebmarkbage or @spicyj.
 Meh. I thought @jsfb's original signature was intuitive. Seems arbitrary. Pick either one. This API probably can't easily support all the things we want to do with subtrees anyway so we'll likely update it later anyway, as we've discussed.
 Fixed to throw if the user passes in null or a non-component as the subtree parent.  (Also fixed jsdoc per @zpao).  I actually like the old behavior where if the first argument is null then it behaves exactly like React.render() - that feels very natural to me.  Let me know if the null behavior would be preferable (we'd still keep the check for a valid component though, to prevent mistakes - it would accept null or a valid component).

I opted to keep the function signature as-is.  Mainly because as I was changing it, I realized it would mean that most calls become renderSubtree(myElement, myContainer, this, callback) - and having this as the third parameter just felt so wrong.  @zpao Let me know if you'd like to overrule and I'll change the signature.
 My feelings still hold but I'm done fighting it. Let's get this done.

I want the null behavior to throw because we have an API for that and it's called `React.render`. `React.renderSubtreeIntoContainer` shouldn't be used there.

> most calls become renderSubtree(myElement, myContainer, this, callback)

Sounds like you want an instance method :P
 Re null behavior: Ok, I can agree with that.

Haha, yeah, maybe I do want it to be an instance method, idk.  Whatever, we can figure out if it should be a top-level api or a component api if/when we ever move it out of addons.  Personally, my hope is that we'll replace the API with a proper layers solution and just delete this function altogether.
 New diff added a couple unit tests, and added some functionality that @sebmarkbage wanted to prevent invocations from outside a lifecycle.
 Returning value, updated error message to be more specific about when it's allowed.

Nested renders shouldn't be a problem since renders are not allowed to call this function (atm).  Although now that I think about it, @sebmarkbage is there a reason that render shouldn't be allowed?  Seems like it should be legal there, though it seems to me it should be legal everywhere.
 Let's drop the lifecycle stuff like we talked about.
 Lifecycle stuff gone.
 There's a console.log that you missed. https://github.com/facebook/react/pull/3640/files#diff-c818825b9093d7a157d104790f972ff2R467
 alright, lets do it.
 We're not sold on this API and we're working to see if we can make it go away entirely before we ship it. See Sebastian's comment - https://github.com/facebook/react/pull/3640#issuecomment-92533429.

The whole point of addons was that we could experiment more freely without the same levels of guarantees you get on the React object proper.
  Looks good.  I suggest changing it to check for undefined instead of checking for object, since that's what you're really trying to protect against.  Also, let's add a unit test that simulates the failure case you were experiencing and asserts that we now return false.
 Looks good to me.  Clearly Sebastian agrees.

@teosz I'd still like to see a unit test that verifies this functionality (ie. simulates the case you were running into, so we don't ever accidentally break that for you).  But I suppose that can be a separate PR.
  Based on other threads around the internet, that seems to be the thing to do (presumably you found the same things I did) along with `sudo sysctl -p` (to reload sysctl.conf). I don't know that there's much else to do (except maybe gracefully handle that error). It's really a problem with [commoner](https://github.com/reactjs/commoner) since the jsx command is really just a wrapper for that & applying the transform - would you mind filing there for posterity.
  Thanks!

And don't worry about the `--use-provides-module` option. It really shouldn't be exposed but I don't really feel like making that happen with commoner, so meh.
  Thanks!
  Looks like the first time Travis ran, it crashed (stupid travis).  I re-ran it and we now have a more useful lint error messages.

vendor/browser-transforms.js
  306:16  error  Missing semicolon                         semi
  312:44  error  Don't make functions within a loop        no-loop-func
  329:13  error  i is already declared in the upper scope  no-shadow

In theory, we should be able to do a "npm run lint" locally and get the same result, but for some reason, your code passes my local linter.  cc @zpao is the travis configuration different?
 `npm run lint` only checks `src/`. `grunt lint` checks everything 
 Nah, no tests. Just make sure it works locally.

I agree on using `j`. The other option would have been to actually use `Array.prototype.slice` on this NodeList and then `forEach`. IE8 doesn't support imports so it doesn't need to work (as long as it doesn't throw).

We can change package.json in another PR. It's just out of date, more got added to the grunt task recently.
 Can you help me understand what this change does? Sorry if I'm being dense but I don't know how `<link rel="import">` is related to JSX.
 Yea, it seems like a pretty special case but I don't think it's a big deal to support.

That said, once you get to using html imports, there's a good chance you shouldn't be using JSXTransformer. It is really intended to be a simple thing for prototyping. But I can see the argument for getting up and running quickly using imports.
 JSXTransformer is going to be deprecated so not going to add more features. Thanks for the effort though. Closing out.
  Just `var View = 'div';` is all you need, assuming you then use it with JSX or createElement.
  `<checkbox>` and `<radio>` aren't HTML tags. If you wanted to be more precise you could write `<input type="checkbox" />` and `<input type="radio" />`.
  [We have a handful of things we should ship in a patch release.](https://github.com/facebook/react/issues?utf8=%E2%9C%93&q=milestone%3A0.13.2) Are we missing anything?
 Did it.
  Perhaps you mixed up `id="container"` with `className="container"`? This works for me: http://jsfiddle.net/xzqwjhhL/
 I see. The (subtle!) difference here is that your HTML has whitespace in between each of the adjacent elements, but in JSX whitespace is removed between two tags on different lines because that's usually what you want. You can add it back explicitly by writing `{' '}` in between them: http://jsfiddle.net/fu1fs8ez/
  I think `transferPropsTo` or `cloneWithProps` (the only things actually using ReactPropTransferer IIRC) should be avoided if possible. We've already noted that they're deprecated in favor of spread props and cloneElement respectively.

Is there something you're trying to do that you can't use use those?
 cc @vjeux who has hopefully thought about this / encountered it.
 cloneElement takes out the magic so it might require a little bit more work. We're trying to get away from the magic :) See http://facebook.github.io/react/blog/2015/03/03/react-v0.13-rc2.html#react.cloneelement for a bit more
  The [`noEventTimeout` timer](https://github.com/facebook/react/blob/2aeb8a2a6beb00617a4217f7f8284924fa2ad819/src/addons/transitions/ReactCSSTransitionGroupChild.js#L80) is not cleared when a child is unmounted while a transition is in progress. This causes a false positive warning.
  Parents and children can still communicate in the normal way (callbacks, but you need to do it in the right places, because some lifecycle methods (including `componentDidMount`) won't be called on the server side), but the fact that you're relying on a child for information seems to imply you need to know something about the child's layout/size/etc.  The blocking issue for you is going to be that... if you're relying on the browser to figure out the component's layout/size, that information won't be available to you on the server side (because you don't have the browser).

Or is the exception being thrown from within React?  If it's thrown from within React, that sounds like it might be a bug.  Can you provide a piece of example code that crashes?
 You only have a single render pass on the server so abstractly this pattern doesn't really make sense on the server. You're parent has already rendered so effectively you're trying to kick off a 2nd render when you call a function that sets state in the parent. It does seem like we shouldn't throw in such a bad way here though. I bet we can blame @sebmarkbage for the changes he made to the state queue...
 @bishtawi I'm not convinced it's a bug in React.  For SSR, I can think of a bunch of reasons to want to enforce single-pass rendering (if nothing else, it keeps open the possibility of streaming the output to the client).  I can't think of any (good) reason to have a child pass that kind of information back up to the parent (your use case sounds like an antipattern to me).  So maybe the bug is that the error message isn't the best, but the behavior is probably correct.

Going to close the issue, feel free to continue the discussion here.
 We've determined that callbacks up to parents from all life cycle methods is typically an anti-pattern. It actually opens up a lot of strange timing issues. (For example ref resolution order changed in 0.13 so refs of a parent is not resolved when a child's componentDidMount is called.)

@jsfb, we can't proclaim that it's an anti-pattern without providing an alternative solution. We should also fix the error message if we don't want to support this.
 @sebmarkbage I thought @tmbtech did provide an alternate solution, no?

Until we start handling layout internally (instead of deferring to the browser), my intuition is that we don't want to support this.  Fixing the error message makes sense, but should maybe be a new/different issue?
 The alternative solution presented makes use of something specific to react-router.
 Well, the general solution is to have the parent do whatever calculation the child is doing (possibly by calling into a shared library).  Outside of layout, the parent should have all the information that the child has (since the child presumably got it from the parent).  The react-router, in this case, is the shared code/data, but that same solution is a general solution.
 One neat way to do this is to have a static method on the child so you can call. `ChildComponent.getBreadcrumb(this.props)` before rendering it. The `ChildComponent` can forward the call deeper if it needs to.

Neither of these solutions solve the case when the parent and child are vastly detached from each other and passing info through the intermediate abstractions is prohibitive. It is the exact same problem as layout. That's what prerender was suppose to solve. https://github.com/reactjs/react-future/blob/master/04%20-%20Layout/02%20-%20Layout%20Components.js#L15
 @wied03 Is there a reason you are using `componentWillMount` instead of the `constructor` or `getInitialState`?  Also, can you provide a jsfiddle that demonstrates the issue?
 I noticed similar issues in workers. We should fix these for 0.14.
 @sebmarkbage Can you be more specific?
 @spicyj I found it! https://github.com/facebook/react/blob/52752446760dee0bc7232b4146f5a309ac57f065/src/shared/vendor/core/dom/getActiveElement.js#L23
 The stack is:

getActiveElement
ReactInputSelection.getSelectionInformation
Mixin.initializeAll
Mixin.perform
batchedMountComponentIntoNode

This should not happen on the server though 
 @ericclemmons Yes, this is still a React issue.
 Hm, it's possible 40b7c19a890b04e5d7bd1273e4f90bb78769ae5b fixed it.
  In this case, I think "Factory" is already the component class name? But if you add a breakpoint on the warning line and look at the stack, you should see the exact code path that caused it.
 If you look up through the stack trace, one of the frames should be your application code which is accessing `.type`.
  Looks good, thanks! Sorry that you lost some time :(
  Related #3554
 @jokeyrhyme (I'm not part of the team) so all I have to offer is https://github.com/facebook/react/pull/3554#issuecomment-88264870
 Let's keep all discussion in the other issue. Somebody with authority will comment when able.
 http://fb.me/patents2
  @henricavalcante Neither is absolutely fastest, it doesn't work like that and it's not a meaningful metric. You can construct cases where React will win hands down and cases where Angular wins hands down. React, by and large, tend to be much more manageable as applications scale up, performance is usually predictable and hotspots can mostly be very easily addressed. Anecdotally this is not the case for Angular and friends, which tend to degrade as applications scale up and it becomes very hard to do something about it.

Regardless, first of all it's running the debug version of React which is significantly slower and this specific example is the worst-case for React, I don't see why you would ever want to update 1000+ items per keypress like you do here.
  Switch to parent-based context.  Fixes #2112.
 Can we add a new test that would have failed with owner-based context?
 Yep, good idea, done.
 Seems like `ReactElement._context` and `ReactContext` should be removed since they are no longer used with parent contexts.
 @mridgway That's a super easy change, but I'd like to separate functional changes from cleanup changes (which don't affect functionality) to make code reviews easier.  That way, someone has a chance of actually understanding what's going on in any given commit (removing _context will touch a bunch of lines, making it harder to read the PR).  If @spicyj would like it to be part of the same commit, I'll go ahead and amend.
 Having all the cleanup in one commit is preferable to me.
 Ok, easy money, done.
 If you do the cleanup in a separate commit and revert this change then the reverted changes won't function correctly unless you revert the cleanup as well. Seems like it creates unnecessary dependencies between commits.
 Cherry-picking reverts can be exceedingly difficult anyway, because people inevitably touch the same code (especially when you have huge commits, you're likely to overlap/conflict somewhere, and merging commits exacerbates the problem).  So it's a loose-loose situation.

Regardless, it's a style difference, I don't have a strong preference either way, already fixed it as per @spicyj.
 I kind of prefer functional changes in a separate commit too, although since PRs allow multiple commits they could be merged.

Accepted, but DON'T land until we've solved the layers issue since that will get this reverted.
 Nope, it is an internal FB issue.
 Basically, there is no way to pass a context to a new subtree - which was also true before but some people hacked around it so we have to undo those hacks.
 Layer issue is solved, pending a final review and sync with www.
 Well ideally we should land that (and prepare the callers) first since we won't be able to sync React internally now.

> On Apr 9, 2015, at 1:21 PM, Jim notifications@github.com wrote:
> 
> Layer issue is solved, pending a final review and sync with www.
> 
> ‚Äî
> Reply to this email directly or view it on GitHub.
 0.13.3 only includes 0.13 plus individually cherry-picked commits; 0.14 will include everything that's currently in master.
 After the things in #3220 get done.
  This sounds like perhaps we should be explicitly calling `onChange` with `undefined` in our controlled component implementations.
 Yup, agreed.
 Yeah, ReactDOMInput, ReactDOMSelect, ReactDOMTextarea, and maybe LinkedValueUtils too (just off the top of my head).
 It looks like I accidentally fixed this in 52a229f168ea10c342d0e69e1ddc63d425579656. Want to send a pull request with your test to make sure we don't regress? (You don't need the findDOMNode call at all.)
 The bug here was that inputs weren't firing with `this` as `undefined`. ES6 classes do not autobind, nor will they. Your options are to bind manually in render, add `this.foo = this.foo.bind(this);` to the constructor, or use the experimental ES7 property initializer syntax which you need to enable manually in Babel:

``` js
class Foo extends React.Component {
  handleClick = (event) => {
  }

  render() {}
}
```
  lgtm, thanks!
  cc @spicyj @sebmarkbage.
 Updates happen asynchronously when calling React.render with a new React element on the same container. We might start batching initial renders too.
 The result of React.createElement or any JSX expression.
 For the second and third renders there, I believe it's async.
  Receiving a call to `componentWillReceiveProps` every time render is called is perfectly within the guarantees of the API.  There is no promise that the props will be different from the previous time the function was called (nor is it guaranteed that there will be any props); the only guarantee is that the function will be called if the props change.

There shouldn't be a need for you to "control" when `componentWillReceiveProps` is called.  If your component doesn't have any work to do for the new props, it can just return.
 When you call setState on a component, its componentWillReceiveProps is not called (e.g., Application in your example does not have componentWillReceiveProps re-called). React doesn't make an attempt to diff props for user-defined components so it doesn't know whether you've changed them. In your case where the props object is empty it's pretty clear but oftentimes a prop is a complex object or function that's hard or impossible to diff, so we call it always (and rerender always) when a parent component rerenders.

Note also that the behavior here may change slightly after #3226 ‚Äì if you have a JSX object that doesn't depend on the parent's props at all, it'll be hoisted outside the React.createClass definition by a smart compiler. If you were to write `React.createElement(Button, {test: this.props.test})` then it would always rerender though, even if `this.props.test` is always the same (because it's hard to determine that statically).
 @cody Please do not rely on `componentWillReceiveProps()` always being called.  The API does not promise to always call the function, though in practice it is currently getting called.  We may optimize the calls to this function and call it more intelligently (less often) without notice.  The only guarantee is that it will be called if props change.
 @cody I think the weird thing is that you are using componentWillReceiveProps to copy the data from your stores into your component local state.  If you want something that will be called on each render cycle, that thing is called "render".  Why wouldn't the component's render function just get the data from the store as-needed to render?

IMPO, the vast majority of components shouldn't need a componentWillReceiveProps().  That function is more of an escape hatch for exceptional situations (in particular, detecting and responding to a props change).  For instance, suppose you were implementing a video player component, that took a status prop with value "playing" or "stopped".  When you transition from playing to stopped, or vice versa, you need to do some setup/cleanup or call an imperative API.  This use case aligns perfectly with the documented API (if props change, function will be called, else, no guarantees).
  Could be an outdated JavaScript environment (like Phantomjs 1 is), have you tried with the recommended polyfills?
 http://facebook.github.io/react/docs/working-with-the-browser.html#polyfills-needed-to-support-older-browsers
 Yea, sounds like a polyfill issue (which would explain why React is undefined laster). Reopen if that's not the case.
  We're not planning to add more to the existing helpers in test utils right now but you can always make your own helpers in your own util library and use those.
  Thanks @firlaj, I was able to reproduce this.
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 cc @syranide. Seems pretty reasonable (and vaguely familiar to something you might have done in the past).
 @zpao React officially supports rendering into iframes so separating by document seems like a no-go (and this would exclude shadow documents too I think?). Ultimately I think the solution is to drop `data-reactid` but it may take a while (but may be possible soonish). For now I've recommended people to use https://github.com/facebook/react/issues/2713#issuecomment-67462102. It could probably be built into the `data-reactid` itself (or at least publicly exposed for now), but at the cost of more overhead, so I'm not sure how keen you guys are on that.
  lgtm, thanks!
  Wrong repo? :)
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 As you can see in the ReactElement source:

https://github.com/vgpena/react/blob/v0.13.1/src/classic/element/ReactElement.js#L111

`_store` is always initialized with `originalProps`, so if you're seeing otherwise it's probably due to mixing different copies of React together, which we don't currently support.

(As a side note, your fix would be a little off in any case because you need to check `element._store.originalProps`, not just `originalProps`.)
  Sounds like it. Happy to take PRs to fix this ‚Äì though I'm surprised that 678/817 fail; I thought they all passed at one point in the past.
 That's pretty strange - the checksum gets added to the HTML string manually and I wouldn't imagine that differs between browsers. (https://github.com/facebook/react/blob/master/src/browser/server/ReactMarkupChecksum.js#L23-L29)
 I don't think we support running tests in the browser anymore, right?  Rendering this bug no longer applicable?

We should have an in-browser test suite like https://github.com/facebook/react/pull/4393, but it sounds like we want to do that as a separate thing.
  We generally treat warnings as "non-fatal errors", meaning that we try to only warn for things "should be fixed".  Once upon a time, we enumerated all the "known html attributes", and have been backpedaling that mistake ever since.  We allow any lower-case tag, because we can't distinguish it from a valid html tag, and using a new tag that we've never heard of shouldn't be an "error".

With regards to warning if there is a variable in scope: It's very common to say `var div = <div style=...>My great content</div>`.  Now you would have a variable in scope with the same lower-case name as a tag, and this clearly shouldn't generate warnings [or maybe it should :)].

Anyway, If you can think of a way to handle the problem of separating "tags" from "components", I'd be interested in hearing your thoughts.
 Yeah, I could get behind that idea.  I'm curious what @spicyj says.
 It could be a bit expensive though.  We would probably want to do the check only for unrecognized html tags (ie. have a whitelist).  And we'd probably want to avoid the check in production.  The logic for when we would warn starts to get a little messy.
 There's nothing to do in production, this is all part of the JSX transform step. Even if we did do something and it ended up in JSXTransformer, that's fine, it's not for production anyway.

This is definitely interesting but might really be quite difficult, we would need to track every variable that might be in scope. I don't think that's possible with most transformers and you really need something like Flow to understand how everything is used (imagine passing function `foo` around which renders `<centered>`, `centered` isn't in scope in the module but it is when you call `foo` in another module). Even if you just want to capture local scope, that's not perfect and will be slow. You would never be defining a class is actual "local" scope of the `render` function. You could capture a couple cases (passing a component class via props) but not much else.

Or imagine you have a custom-element called `centered` which you actually wanted to render, not some local variable. Some other developer came along and did a precalculation and assigned something called `centered` because it made sense, not realizing it would affect the render. We don't actually know what was intended.

Since there is so much state and intention outside of the transform that we can't capture, I don't think this is realistic to actually do.
 I was thinking we could warn if the rendered element is an HTMLUnknownElement:

http://ryanmorr.com/determine-html5-element-support-in-javascript/
 > I was thinking we could warn if the rendered element is an HTMLUnknownElement:
> http://ryanmorr.com/determine-html5-element-support-in-javascript/

If this works, I think it‚Äôs a better solution than transforms especially considering that most people are using Babel today anyway. :+1: 
  Fixes #1398.
 No, the same markup is still rendered on client and server.
 @spicyj - is this safe enough to take back in 0.13?
 Probably safer not to, but there's nothing in particular that ties this to 0.14.
 It will be in 0.14.
  This is a known problem right now, though we haven't looked back into it lately. See #1398 for more discussion.
  I don't know why this would be related to addons, but it sounds like you're using an old JSX transformer. Can you check if that's the case?
 Can you look at the built file? Does it have `React.createElement('div',` or `React.DOM.div(`? Similarly, `Test(null),` or `React.createElement(Test, null)`?
 You can look at the script tag in the generated HTML to see what's loaded.
 @ivanflorentin Your `CommentBox()` should be `React.createElement(CommentBox)` or `<CommentBox />`.

@shaimo Closing because it sounds like you found your issue.
 @ivanflorentin You should have seen a warning in the console too pointing this out.
 @ivanflorentin Your code works fine for me here:

http://jsbin.com/venaqozebi/1/edit

If you can make a repro case in jsbin for me to look at, I'm happy to investigate.
 Yes, you need to pass an element (either `React.createElement(CommentBox)` or `<CommentBox />`) to React.render.
 Yes, this was a deprecation introduced in 0.12 and completely removed in 0.13. See http://facebook.github.io/react/blog/2014/10/14/introducing-react-elements.html for more details. You should have received console warnings for these when running under 0.12.
  Possibly you're trying to make an element like `Foo()` instead of `<Foo />` or using an old JSX transformer ‚Äì are either of those possible?
 @shaimo What about looking for the `react-tools` line(s)?
 Can either of you post an example project that shows this issue?
 @01bit Oh! Yes, createFactory is required in this case since you're not using JSX. If you were to do `<View />` instead (custom components should start with a capital letter), that would work too.
  #2302, ReactLink is probably going to be deprecated so possibly never, but that's not my call. You can easily provide your own enhanced `input`-component wrapper which provides this behavior rather than having it be supported by React core, that's my recommendation.

PS. It really should be called `checkedLink` (the property is called `checked`), not `radioLink`.
 Yea, sorry. ReactLink is getting deprecated. I recommend that you implement a wrapper component and publish it to npm.
  Thanks!
  Thanks!
  @reactkr/translators review please.
You can see original diff in [here](https://gist.github.com/marocchino/369691a5e804ae2fb36a).
 Thanks for keeping this current!
  I had an idea: what if our stack traces looked more like this so you don't just have 30 frames inside React and then a top-level render call, which is the typical situation nowadays?

![image](https://cloud.githubusercontent.com/assets/6820/6995020/aacf7f9e-dae2-11e4-9959-d4914cae5123.png)

Turns out we can do this with a small hack. Each time we create an element, we store away a function that just calls its argument:

``` js
var foo = React.createElementDebug(function element_Foo(x) { x(); }, Foo, ...);
```

then when we go to mount the component, we call this function with the mount code as argument so that it appears on the stack.

This is a little crazy and probably slow, but could make development nicer. You can't inspect the props (e.g., `a`, `b`, `c` here) but if we had the function capture those vars I think you could.
 This is actually a really neat insight! `__DEV__` mode is already super slow anyway (which is also a problem but a separate issue). I don't think this is necessarily making it much worse.

Another thing we were considering was using Promises so that the async debugging tools in Chrome would work.

Lets keep iterating on something like this.
 @spicyj Here's a kind of related thought:

If you have a properly inferred name on the render function. E.g. ES6 classes would have a name like "MyComponent.render".

What if we in `createElement` did something like: `new Error().stack` and stored away the stack where it was created. That way you get not just where it was created, but also the indirect stack that got you there, including file/line which can be used by the devtools.

You could even use this to infer the "owner" name for use by debug outputs. That could allow us to avoid tracking owner even in debug mode.
 Yes, we could. I assumed that would be much slower than this and not much more useful.
 The benefits are that A) it works with unchanged syntax and any caller, not just JSX. B) it shows indirections. The downside is that you don't get the breakpoint debugger which is really neat.
 cc @jaredly
 This is interesting but I‚Äôm not sure how feasible this would be perf-wise, or whether it would actually improve the situation rather than introduce more confusion.

Deep and seemingly unrelated stack traces are a real problem so let‚Äôs continue tracking it in #5460. I will close this PR, but we can revisit it later.
  It's really hard to say for sure without more info but one thing that jumps out at me is that you're doing some AJAX and calling `forceUpdate` with the result. It's possible that the component unmounted before you did that though. In 0.12, doing that would throw an error. In 0.13 I think we should just be warning and then just returning. Clearing the requests in `componentDidMount` is the suggested way of handling this.

Your error is suggesting you're using 0.13 though. If you could reduce this to something reproducible and sharable, that would be helpful.
 I haven't seen people running into this old issue, and we don't have a repro, so I'm going to close.  We can re-investigate if we can get a repro.
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thanks!
  This is a proposal for tightening React's XSS security model as referenced by #3473.

React Elements are simply JS objects of a particular shape. Because React applications are frequently assembling large trees of these elements and including user data, it's possible for a malicious user to insert data that appears like a React Element and therefore render arbitrary and potentially dangerous markup.

Previous versions of React used instanceof, but that limited the ability to use multiple Reacts and tightly coupled JSX to React which we wanted to avoid.

This proposal augments `{_isReactElement: true}` with `{_source: "randomstring"}`. Using React.createElement() automatically adds this _source, but JSX could generate regular object bodies with `{_source: React.getSourceID()}`.

In order to use multiple Reacts, a new API `React.trustSource(sourceID)` is added. You can imagine using a different React instance in a webworker and using `React.trustSource(sourceIDFromCallingWorkersReactGetSourceID)`.

To preserve back-compat, the default behavior proposed is to dangerously trust all sources, but to warn! If this proposal lands, then I imagine a future version of React will make the default behavior to not trust unknown sources, removing warnings.
 cc @sebmarkbage @graue @yukinying
 There's also an argument to be made for the default behavior being not trusting unknown sources from day 1 of this landing. That's technically a breaking change from v0.13, but actually matches the behavior of using instanceof with v0.12. It would remove all the warnings and just go straight for safety. I'm curious what you all think of that.
 Maybe warn in 0.13.2 with opt-in errors, then always error in 0.14? I don't want to keep dangerouslyTrustAllSources long-term.
 To be clear - there are no errors at present (maybe there will be in v0.14 for other reasons). Simply isValidElement returns false, so foreign elements are seen as arbitrary object literals.

dangerouslyTrustAllSources has it's place beyond whether or not we do warnings. It provides a quick fix if you're doing hyjinx and this change screws you over. I agree that long term, it makes far less sense.
 The more I think about it, the more I agree with you @spicyj that this makes sense as a 0.13.2 as a partial security fix (introduces the warnings and gives you new tools) and by 0.14 the default is explicit trusting and no more warnings.
 It's obviously a question of how far you want to take it, but this only prevents exploitation of React elements. It does not prevent other future sources, say if a users writes a component that takes HTML as children rather than a prop `<MyComp>blabla{{__html}}</MyComp>`, I would even argue that if it weren't for HTML DOM complexities we too would/should support that syntax rather than `dangerouslySetInnerHTML` which really seems like a temporary hack to me.

I get that explicitly separating values from elements is rather invasive (it's implicit), but it really only applies to inheriting/markup frontends and mostly codebases that do not follow the React recommendation of "isolating components" so that they can be reused in any context. Explicitly separating renderable elements (values of otherwise) from non-renderable primitives also has a number of additional benefits and most non-HTML frontends would be minimally affected.

I get that it's invasive and a hard sell when HTML is our current frontend, but the problem is introduced by our current implicit behavior and can be definitively solved if we made explicit.
 @leebyron I think that it is important that compilers can generate ReactElements without coupling to the React instance. It removes the annoying need for JSX to have React in scope and these optimizations can work: https://github.com/facebook/react/issues/3228

To do this, the transpiler would need to have access to a source ID in its runtime instead of the React instance.

``` js
<div className="foo" />
```

could turn into:

``` js
{ type: 'div', props: { className: 'foo' }, sourceID: $runtime.jsxSourceID  }
```

However, to do this I would have to wire up my transpiler and my React instance somehow. `React.trustSource($runtime.jsxSourceID)` It wouldn't be seamless out-of-the-box.

It might also require multiple different sourceIDs to be active at any time which would be slower than the ideal by-ref always-true comparison.

Therefore I was thinking about maybe storing some source ID on the global that can be shared by transpilers and React, or if it is available, then React picks it up or something. What do you think?
 @syranide Your comment is a bit unclear in the context of this PR. I think you're referring to your comment in #3473 that you would prefer primitives to be wrapped. I'll comment there to keep this thread about the merits of the sourceID approach on its own. We can use #3473 to discuss alternative approaches.
 @sebmarkbage My bad, after more consideration I don't think my line of thinking is right approach for this immediate XSS issue, it's about going back and re-evaluating and that's an entirely separate discussion. This PR seems like the way to go :+1: (even if we could `instanceof` it wouldn't be a universal fix, while JS is currently lacking native serialization of classes it's not an intrinsic guarantee).
 @sebmarkbage #3228 optimization can still work in this case - the inlined object body just needs to include a `_source: $somethingGoesHere.sourceID`.

I'm not sure I understand why having `React` in scope vs `$runtime` in scope is better or worse. They seem isomorphic to me - you need _something_ in scope, so why not React?
 @brigand - we _do_ want JSON serialization. This would be much easier to solve otherwise. JSON serialization gives us the ability to move React components across web workers and between server and client.
 @leebyron JSX is a language feature so it should be able to execute without any other context. For example, array literals doesn't require the `Array` constructor to be in scope.

``` js
var Array = null;
var arr = []; // still works
```

Likewise, I shouldn't need to do:

``` js
import React from "react";
var element = <div />;
```

It even looks like it is unused. Even if I did want to use React for something else I should be able to call it what I want without JSX dictating the variable name:

``` js
import $R from "react";
import { Component, PropTypes } from "react";
```

Another neat feature is that React components doesn't even depend on React's base class necessarily.

``` js
function Bar(props) {
  return <div />;
}
class Foo {
  render() {
    return <Bar />;
  }
}
```

This should be perfectly valid. You can even load the modules without loading the dependency on the rest of React. You can run these in isolated unit tests without React and without any mocking. They're also agnostic to multiple instances of React. If you end up with both `React v4.2.1` and `React v4.2.0` because of some clowny npm versioning.

It also decouples it from React itself so that other VDOM libraries can use these elements and the same JSX transpiler.

Now if a transpiler decides to require React automatically and bring it into scope to use `React.createElement`, that's fine but that should be an implementation detail of the transpiler's runtime rather than a hard requirement on the developer.
 We still have some work to make that a reality. In <0.14 a lot of things depend on "owner" which is global state inside React at the time the element is created.

In 0.14 that is still true for refs.

> On Apr 12, 2015, at 8:53 AM, Jari Pennanen notifications@github.com wrote:
> 
> @sebmarkbage  should someone open a new issue to change transpiler to work like that? It would make so much more sense.
> 
> ‚Äî
> Reply to this email directly or view it on GitHub.
 > JSX is a language feature so it should be able to execute without any other context.

Yes, however the `_source` key being proposed here is unique to a React-specific transpilation. 

I think we might beyond describing semantics of JSX as I imagine whatever we do here would be a transpiler detail and not a user-facing API change for those who use JSX.

What I'm actually unsure about is how the order of operations will work. Putting this "source token" in a global somewhere like `$runtime.jsxSourceID` means that something else needs to be responsible for initializing that value before the JSX block runs. As currently written, a source ID is set as a side-effect when `require('react')` is first run, such that `React.getSourceID()` is guaranteed to return a correct value, because you need to acquire the `React` reference first. The reason for it being a function rather than an accessor is to protect against malicious or blind mutations of that value, but we can probably find other ways to protect against that.

Perhaps we can propose something like `$runtime.jsxSourceID()` as a function call, so the first call to this function ensures a value has been set and every other call returns the same, and it's the role of a transpiler to ensure this function exists and is in scope before a JSX expression.
 @leebyron While JSON serialization is useful, I think @brigand's suggestion is interesting and potentially worth further thought/discussion.  His solution doesn't prohibit moving components across a serialization boundary (@brigand's suggestion merely requires that an additional explicit action must be taken to say "Yes, I mean for this to be deserialized as a component", namely that the developer set the unserializable field on the component after deserialization).  It also meets Sebastian's desired language-feature rule/syntax without resorting to smelly globals.  It has the advantage that even if the attacker has full knowledge of the user's browser state (including the `_source` variable or random-number-seed) AND the attacker has full control over the serialized json, they still can't mount an attack.  It's super simple/elegant, which scores it bonus points, and I don't think it actually prohibits anything that anyone would reasonably want to do.
 I'm not sure if I understand the full proposal from @brigand. I was under the impression that JSON serialization isn't just potentially useful - it's our goal. It unlocks the ability for React to operate across Realms, server, webworker, etc. In my opinion `safe: Math.max` seems fairly arbitrary in comparison to `__proto__: React.Element`
 His suggestion, as I understand it, is to use a value which is impossible to describe using JSON (eg. a cyclic reference).  Component (de)serialization is still possible, because the deserializer can explicitly declare their intent to receive a component by re-setting the value which was "lost" during the json serialization.  So you don't loose the ability to pass components across the serialization boundary (to webworkers or whatever) but you make it impossible to "accidentally" deserialize a component because components require that special value.  It means you have to know when you are expecting a `component` vs. `data` because you need to set that field if you're expecting a component, but I can't think of a case where you wouldn't/couldn't easily know/determine that.

The only downside is that deserialization of components requires "an extra step", but I don't see that as a bad thing.  If you're really expecting to deserialize a component, you pass it into a function that rehydrates the component.
 My problem with that solution is that is limited to the current JSON limitations. It says nothing about other serialization mechanisms such as postMessage, etc. Most serialization boundaries don't support functions atm but there's nothing permanent about that. If you add a new feature to the serialization boundary, you change the security implications of the whole app.

One way you can illustrate this is using the second (`reviver`) argument to `JSON.parse` which lets you return an arbitrary rich object which may contain a function for example, for whatever reason.

One reason we care about serializability, in general, is because we don't want to traverse and copy an entire object hierarchy to make it React-compatible. One of the most powerful features of React is that you can put ReactElements in arbitrary data structures. Not just a single "children" array.

``` javascript
var data = [
  {
    first: [
      new Immutable.Vector([ element1, element2 ]),
      new Immutable.Map().set('foo', element3)
    ],
    second: element4
  },
  element5
];

return <Component data={data} />; // Component does something fancy with this deep data structure
```

Even if your serializer knew how to properly transfer these data structures, it would also have to know how to properly deserialize a React element for this realm. A lot of serialization is, in practice, not pluggable because of layers of indirection. E.g. a data fetching library.

The alternative is that you have a secondary step that recursively goes through this data structure, after data fetching, and creates local React elements in place of these elements. That requires marshalling of every single node in this potentially large tree. So the ideal scenario would go directly from deserialization into the React component.

> Yes, however the _source key being proposed here is unique to a React-specific transpilation.

@leebyron Well we could drop the underscore and make it possible for anyone to use this. Then it is not React specific.

> What I'm actually unsure about is how the order of operations will work. Putting this "source token" in a global somewhere like $runtime.jsxSourceID means that something else needs to be responsible for initializing

Well, to properly decouple the transpiler and React, I think they would probably need to communicate through a third-party. Otherwise, you couple React to the transpiler instead. One possible third-party is a global like `$JSX_SOURCE_ID`. However, to avoid a direct third-party dependency on runtime code, we can introduce the notion that anyone who plays in this ecosystem sets this global variable if it is not already set. That way it doesn't matter which player runs first. Whoever is first gets to set the value and any subsequent player reads that value.

## Standard Value DOM

My hope was that we would find a way to "standardize" (at some level, not necessarily ECMAScript) both JSX and the data structure together as a generic "Virtual DOM" (Value Type DOM). We would couple the `VElement` data structure with `<... />` just like the `Array` data structure is coupled to `[...]`, or the `String` data structure is coupled to `"..."` etc.

If we implemented this on top of something like the [Value Type Proposal](https://github.com/nikomatsakis/typed-objects-explainer/blob/master/valuetypes.md#the-typeof-operator). Then we could potentially do something like `typeof element === 'velement'` or `typeof element === VElement.symbol`.

Custom value types can be passed between realms with their identity preserved by sharing a Symbol between realms. That way this at least works between non-serialized multiple realms (like iframes). Presumably, anyone that wants to share custom value types between realms would be in a similar situation where they need to find a way to share some kind of ID.

This is primarily why I like the ID solution because it is essentially a polyfill of the shared symbol solution for realms.

Of course, this "Value DOM" type is not really JSON serializable, unless it becomes defacto standard and therefore part of common JSON protocols or common revivers above JSON. Which sort of brings us back to the situation that we can be shared between realms but not serializable boundaries.
 The current thinking around Value Types in the spec is that they will use a single Symbol that is passed between realms. This is a coordination issue that is problematic for many systems like module systems and npm versioning. You also have to coordinate it with build systems like Babel. It is currently an unsolved problem.

Therefore I would like to punt on this and make "dangerouslyTrustAllSources" the default for now, just like in 0.13. We can still have the opt-in solution IF you have the ability to coordinate this in your system.

Another consequence of the Value Types system is that you're expected to only have ONE symbol to describe these types. I think that therefore we can get rid of the multi-source system which should simplify things a bit.

We have also separated ReactDOMClient/ReactDOMServer/ReactIsomorphic so we already have a need to coordinate between these packages.

How about we only expose `setTrustedSourceID` on each of these packages? This causes that package to turn on "secure mode" and only allow that trusted ID. The type of the ID can be of any type for now, but will expected to become a Symbol in the future.
 (Can we call it a sourceToken? I think that sounds a little better.)
 Eventually went with #4832 instead. Pushes the burden of managing this to the Symbol system.
  I think at this point we're not likely to do this. The current plan is to sunset react-tools and make jstransform the standalone way to transform your code (or babel or whatever tool you want that supports JSX). See https://github.com/facebook/jstransform/pull/81

Given that jstransform does more than the JSX transform, it doesn't really make sense to default to `.jsx` files there.

FWIW, we've never really advocated using `.jsx` files. We use `.js` and most (all?) of our open source projects follow this convention. What people are actually doing‚Ä¶ that's may not match. But I think as transpiling JS becomes more and more common-place, it makes sense to just use `.js`.
 Basically we think of these as potential or experimental extensions to JavaScript, not a new language. FlowType is another one. Each experimental syntax extension doesn't need a whole new language to support it. You could argue that it should be annotated as an extension but it doesn't make sense that I combine a long list of file extensions for every new experimental version of the language.

`.jsx.flow.es6.es7experimental.sweetjs.js`

They're all designed to coexist as extensions to the existing language in a compatible way. In fact they might maybe one day be part of what we call JavaScript. In fact E4X once was. This is what differentiates it from Java or CoffeeScript. None of these features are a new language (unlike TypeScript which is a subset+superset of JavaScript and really a new language).
 > making sure people understand that a file is not going to be runnable in a JS engine without a conversion step

The same argument currently applies to many ES6 features. Early adopter code might not even work in future engines. Flow types is another example of a syntax extension that doesn't have an active proposal but is in talks to be potentially standardized in some form. JSX is not actively pursued right now but I can definitely see some form JSX being standardized in the future since it solves a real use case that template literals doesn't. Perhaps not in its current form, but in some form. Also, E4X code used the `.js` extension for years.

More over, JS is becoming a source and target language where they're not necessarily the same. The future of JS is that it is always expected that a majority of code will in the future be compiled/transpiled before executed in the engine. It is a moving target.
  It has been long enough, I think everyone has had a chance to see this.  Looks good to me, merging.
 I don't think this PR is the best solution here. It's legitimate to load two copies of React if you keep them separate ‚Äì for example, you might want to embed a third-party script which bundles its own copy of React and only renders into its own subtree. As long as you create and render elements with the same copy of React, you won't run into problems (as far as I know of).

I'd prefer something more like #3332 where we warn in problematic cases and leave people alone if they're not mixing things in a problematic way. This PR also doesn't catch cases where you use multiple copies of React on the server in a bad way (since it guards its global assignment in a `canUseDOM`), which is another reason I don't like tacking on a global.

In any event, this adds a _lot_ of log spew to the tests and that needs to be fixed.
 @spicyj should we revert this while we sort it out?
 @zpao Off-topic, but fixing the tests would be awesome, many currently use multiple (partial?) React instances simultaneously and just happens to work at current. It is a blocker for a PR I had to keep the concatenated IDs stored internally, leaving only minimal sequential IDs in the DOM, say what you want about that PR but it is something we'll want to fix eventually at least :)
 @zpao Yeah, let's for now. #3646.
  No, that'll trigger a diff (so it should be fast) and is the recommended way to rerender a top-level component.
 Yes, it does. You should call React.unmountComponentAtNode before removing the container from the DOM in order to prevent leaks.
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 `renderComponent` is a deprecated API. The new one is `render` actually =).
  :thumbsup: Thanks!
  As @syranide noted, the current plan is to pull linking out of the core and probably throw it into an addon package.  Assuming `radioLink` is something you find useful, I encourage you to publish a npm module or git repository that provides this functionality as a wrapper component so other people can use it.  Since this is not something we plan on supporting in the core, I'm going to go ahead and close out the issue.
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 Thanks!
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
  rAF batching isn't supported and won't go in the docs, but batchedUpdates should.
 We don't use it at Facebook and it's not clear that it solves real problems, so we don't want to maintain it or have to fix bugs related to it. React.addons.batchedUpdates should give enough control over batching.
 There are also known issues with rAF batching (mostly around controlled components).
 Should we deprecate and eventually remove the RAF batching?
 It's never been supported in any fashion.
 (i.e., it's already deprecated?)
 That's not exposed as a public API in any of our builds, but sure, we can delete it ‚Äì PR incoming.
 Killed in https://github.com/facebook/react/pull/6016
 We should document ReactDOM.unstable_batchedUpdates.
 @spicyj Since when did we start documenting `unstable_` features?  Haven't we always left them intentionally undocumented?  We also have unstable_renderSubtree and unstable_handleError and others, but I thought the decision was to not document them until they become stable.  We document them as part of the release process.

It was a different situation when it was an addon, the issue made sense at that time.
 Sure.
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 I'm going to close this out because we definitely won't expose it like this. Let's chat more in #3568 and figure out a good plan then we can revisit.
  Correct, React dev tools reaches into the internal private API.  We don't expose that hook as public API because it is subject to change without notice and we don't want people relying on it (to the extent possible).  That said, @timbur, exposing ReactMount the way you did is a pretty reasonable solution if you really need access to the internals; just be aware that it is "unsupported" territory.  As per @gaearon's comment, yes, as we grow it might make sense to have better resources for dev tooling.  It would be interesting to start understanding the tooling needs/usecases to see what could be better addressed by our devtools, and what/why people need whatever isn't yet available.  @timbur I'm a little curious about the details of your use case.
 We really want to keep the public API minimal, so I don't think we're going to expose `ReactMount` directly. We may do it in a way that is very obviously unsupported (we did that before with `React.__internals`, also with devtools in mind), but the way you have it is not how we'll do it.

If all you actually need is `_instanceByReactRootID` (which note, is even "private" within that module), then we should figure that out.
  Every type checker follows the signature (props, propName, ...), through
which the value `props[propName]` is retrieved. This works badly with
`arrayOf` since it'd pass the index of the item as the prop name; the
warning message will therefore show "Invalid prop `1` of bla" instead of
the more helpful "Invalid prop `myProp` of bla". This fixes that.
Ideally we'd pass the prop value as an argument, but it's too many
changes.
 Fixes #1833
 @zpao @gaearon
 Clever solution :) Thanks!
 Superseded by #3737 
  https://github.com/facebook/react-native/issues/600#issuecomment-88673022
 Pretty sure this has been fixed in master. Also improved the error message at mount time: 642323e5a8ad814e372b67bd76ded2d6d5bd383d.
  :thumbsup: Thanks! (perhaps I can convince you to take a look at the pile of `update` issues / PRs if you use it?)
  Thanks!
  Did you get a console warning for this?
  Not sure if I'm doing something wrong, but your example works fine for me in Safari 8.0.4.

![image](https://cloud.githubusercontent.com/assets/6820/6951946/95708ace-d873-11e4-8ddb-668238705fe7.png)
 I think if Safari is breaking accessing a `NodeList` by index, then much of the internet will break. I also can't reproduce the issue in 8.0.4 (nor in latest webkit nightly).
 I was also unable to reproduce the issue in Safari versions 7.14, 8.02, 8.03, or 8.04.  And I also tried installing all the latest updates from apple and it did not upgrade me to 8.05.  I'm a bit curious where you got the 8.05 build.

If Safari ends up breaking on this, I think the code in this PR is ready to merge (looks good to me), but let's figure out how to reproduce it first.  Until then, I'm going to close this PR.  We can re-open if we are able to reproduce and want to reconsider.
 Ok, confirmed.  This bug repros in Safari 7.1 also.  Browsers suck.

Code looks good, shipping it.
 Well, I'll be damned. AFAIK no other browser uses DOM node ids as keys in NodeLists. Safari isn't even doing it consistently (eg, the NodeList returned by `querySelectorAll` doesn't do this). I would be interested to know if this is intentional and if we can get them to not do this.
 I assume unintentional. Chrome had it: https://code.google.com/p/chromium/issues/detail?id=254995
 If we want to stay entirely on the safe side then we shouldn't access `parentNode.childNodes.item` either, but use the item-method from a prototype.
 @syranide Yea, we should probably do that. Otherwise we'll just get bitten when `id="item"`.
 @zpao Thankfully it seems it doesn't overwrite length :)
  Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 Thanks!
  This is a legal matter and won't be resolved without lawyers.
 @colinmegill We understand your concern/pain.  We are in dialog with legal about the potential to change this language.  Unfortunately, for legal reasons, we can't comment further.
 Any comment on legal matters must come from the lawyers.  I can't predict what commentary would be available at the end of the discussions.
 That is certainly not the intention. We will be clarifying this shortly; thanks for your patience in the meantime.
 We updated the grant: https://github.com/facebook/react/commit/b8ba8c83f318b84e42933f6928f231dc0918f864
 @jamesgpearce https://github.com/facebook/react/issues/3617#issuecomment-91669738 probably goes best in here :) also :+1: 
 [osquery's BSD License](https://github.com/facebook/osquery/blob/master/LICENSE)
[osquery's Additional Grant of Patent Rights Version 2](https://github.com/facebook/osquery/blob/master/PATENTS)

@ab34 I don't work for Facebook and I'm not a lawyer, but a project licensed under the BSD license is not a guarantee that you're safe from patent infringement, if you need an example of that then you need to look no further than the [BSD-like licensed VP8 codec](http://en.wikipedia.org/wiki/VP8#History). If you can substantiate your claims then please do, but rash action is only counter-productive to the discussion.
 @ab34 Google's VP8/webm seemingly has the same legal approach, so it doesn't seem like something fishy Facebook's legal team made up, [webm's New BSD license](http://code.google.com/p/webm/source/browse/LICENSE.TXT?repo=libwebm) and [webm's Additional IP Rights Grant (Patents)](http://code.google.com/p/webm/source/browse/PATENTS.TXT?repo=libwebm).

http://www.softwarefreedom.org/blog/2013/may/29/vp8-cross-license-draft-foss-compatible/ says:

> Because the patent license does not restrict those freedoms, but rather affords some new, limited protections to users and developers within the field of use, it improves on the current situation. Without this license, the patent holders would be in a position to threaten those users and developers as well as others.

This may be a misrepresentation of facts on my part, this is not my expertise after-all, but that sounds only logical to me. Again, I'm no lawyer, I'm as interested in this as everyone else as an outsider, but substantiated facts is the only way forward in this discussion.
 @ab34
[[LICENSE] Facebook osquery's New BSD License](https://github.com/facebook/osquery/blob/master/LICENSE)
[[LICENSE] Google webm's New BSD license](http://code.google.com/p/webm/source/browse/LICENSE.TXT?repo=libwebm)

[[PATENTS] Facebook osquery's Additional Grant of Patent Rights Version 2](https://github.com/facebook/osquery/blob/master/PATENTS)

> Additional Grant of Patent Rights Version 2
> The **license granted hereunder** will terminate, automatically and without notice, if...

[[PATENTS] Google webm's Additional IP Rights Grant (Patents)](http://code.google.com/p/webm/source/browse/PATENTS.TXT?repo=libwebm)

> Additional IP Rights Grant (Patents)
> ...then any patent rights granted to you **under this License** for these implementations of WebM shall terminate...

It seems to me like the same legal framework (and everyone seems fine with Google's) and I interpret them both to have the outcome, the termination of the additional patent rights license (again, I'm just a layman), not termination of the main New BSD license. It seems you don't and that is the issue you take with it? Or am I misunderstanding?

Anyway, you don't need to explain it to me, I'm an "outsider" just like you on this matter.
 @dqdinh On the contrary... we did update our patents grant: https://code.facebook.com/posts/1639473982937255/updating-our-open-source-patent-grant/
 The diff is here: https://github.com/facebook/react/commit/b8ba8c83f318b84e42933f6928f231dc0918f864
  You should be running your linters on source code (not generated code).  Generated code generally should not be checked into a repository, should not be linted, etc.  For this reason, this is probably pretty low priority.  That said, if you'd like to submit a pull request, it would likely be considered.
 @jsfb We've tended to recommend linting after running through JSX as that's what FB does and it preserves line numbers, etc.
 Eeeh, That would mean that if someone's lint rules state that there must be a space between a function name and the open pren, that the linter would fail.  Or any number of potential lint rules that happen to conflict with whatever the transpiler produces.  You can't win, because people's linting rules can be mutually exclusive and thus there is no possible transpiler output that will pass all linters.  Better to lint what the human is actually reading/editing.
 It's true, but then your linter needs to understand JSX. Now there are some (particularly eslint) but there weren't a year ago.
 Yep, I agree :).
 Yeah, having the transpiler produce trailing whitespace probably wasn't intentional, but it's not a high-priority bug (primarily since it's generated code and thus not intended for human consumption).  Like I said, we'd likely accept a pull request if you'd like to fix it :).
 #970, it's non-trivial to fix in the generator and was left as-is for now.
 JSX compilation is now handled by babel, which I think renders this issue no longer applicable.
  Thanks!
  We're going to deprecate react-tools so closing this out.
 Yea, I haven't blogged yet. react-tools was always mostly just a pretty command line interface to jstransform, so we moved the wrapping bits into jstransform and shipped that. That lets us decouple releases. But then we also decided to stop using jstransform externally so we'll be recommending people start using babel. However, jstransform does exist with mostly the same API as a less churny alternative. https://github.com/facebook/jstransform#migration-guide
  Ah, seems like it's mostly to do with `.swp` files and not the combo of options.
 Filed https://github.com/reactjs/commoner/issues/78 in our dependency to fix this.
 This has been replaced by babel.
  Good idea, thanks.
 I think we only need this for DOM components (at least for now) - we attach the listeners here: https://github.com/facebook/react/blob/master/src/browser/ui/ReactDOMComponent.js#L272-L274 (we also do it later in `_updateDOMProperties`) so we can do some extra work to build up a list of incorrectly cased strings.
  Do you have some data to back up the perf boost claim?

I tend to not actually like this pattern. And it might not generally be needed (http://mrale.ph/blog/2014/12/24/array-length-caching.html is a good read). It might be worth changing the cases where we do cache.
 I tend to agree with @zpao regarding the readability of the two loop styles.  I like the readability of the version without the cached loop size.

That said, I just ran a microbenchmark (for what it's worth, see @zpao's article), and the new loop style proposed by @James-Dunn does outperform the uncached version by a few percentage points.  (Tested on chrome, results were 35 mm-ops/sec and 38 mm-ops/sec for uncached and cached respectively).  So that would be in favor of merging this change.

In my opinion, source code should be for human consumption and bytecode should be for machine consumption.  I would much rather work with human-readable code.  There are countless stories of people optimizing for runtimes, the runtimes improve, and the "optimized" code becomes worse than the "unoptimized" code when running in the improved runtime.  The moral of the story being: source code is for humans.  If caching the array length improves performance, I tend to think it should be part of a transform we run (or better, submitted as a pull request to V8), and not a style that engineers need to manually conform to.
 #3552 landed so closing this out.
  #2842, XML-compatible markup in next release.
 @cody If the _closing tag_ is there then yes I believe so, but `<meta />` is valid.
  Thanks!
  Going to count this as part of #3059 as we'll likely support either both or neither.
 It's true that there's no technical reason they need to be consistent, but it's hard for me to imagine us doing one and not the other.
  https://github.com/facebook/react-native/pull/275
  Thanks!
  +1 I've run into this a few times myself.
 This fits in well with the idea of frags. For example, I think we want to make this possible:

``` js
label =
  <frag>
    Label
    <Tag text="important" />
  </frag>;
```

I'm not sure if we want to do it with another call like this, but the idea is definitely in line with what we're interested in.
 @zpao  :+1: I currently have that by overloading `React.createElement` for now :)
 #2127 is the place we've been tracking frags.
  We renamed it to React.render several releases ago. Please consider keeping up to date with new versions.
  Hey @tonyspiro - if you can sign the CLA I'll merge this. I agree these changes make sense.
 :thumbsup: thanks! Yea the bot gets a bit finicky - it usually responds to the PR, though perhaps only when the email it has matches the github email. Either way, this is good.
  Looks like this was fixed in https://github.com/facebook/react/pull/3589, closing.
  Running multiple instances of React is not currently supported. It's possible to work around that with some tweaks, but they still have to be isolated from each other, so you cannot use the instances interchangeably.
 Yeah, unfortunately we don't support this right now. We'd like to but don't know how to do a good job of it. #3252 is our issue tracking that.
  This seems fine. We can merge once the CLA is signed.
 @hatched ping - can you sign the CLA?
 No response, closing.
  In other places where you see this it's generally to keep under the 80-column limit. Since these are all short, we're happy to keep them on one line.
  Thanks!
  Any chance you can get a full stack trace for the error? We use pooling to reuse objects instead of creating new ones every time.
 Sorry to hear that. Sounds like Nashorn may be buggy as I haven't heard about anyone having this problem in other engines.
  It's not the best way to ask for support. Mailing list, stack overflow, IRC are all better.

To answer your question though, use props. Then in the child handle the props update to setState (though in that case you may actually want to be using props and not state).
 No worries :)

On Mar 26, 2015, at 1:47 PM, oscar men√©ndez <notifications@github.com<mailto:notifications@github.com>> wrote:

Thanks for the answer :)
And Sorry for ask here :(

‚Äî
Reply to this email directly or view it on GitHubhttps://github.com/facebook/react/issues/3524#issuecomment-86708673.
  Can you post title and description of this in English please? You'll also want to rebase because there is a ton of noise here. Also also, don't try to merge into gh-pages. You should target master.
 Alright, reopen if this was intended and we can discuss further.
  objects too. Really the message should probably just say that only strings are functions are allowed, not %s. (typeof type)
  Ideally squashed but I don't care much. If you update and push -f before I merge, I'll take that.
  Thanks!
  We've had this requested before, so I'll point you to #1587. We won't be able to really do this as long as the pattern of passing along extra props is a thing. Eg `<FancyButton>` which renders a regular `<button>` with a specific class but otherwise lets users specify any other props that would get passed down to the DOM node.

``` js
FancyButton = React.createClass {
  propTypes: {
    color: React.PropTypes.string
  },
  render: function() {
    return <button {...this.props} style={color: this.props.color} />;
  }
}
React.render(<FancyButton color="blue" value="foo" />, ...)
```

Anyway, follow along in the other issue for updates.
  Yea, this seems fine. Can you actually remove the last 2 commits? We'll update docs manually with other attributes and the merge is extraneous since we'll just merge this back.
 ``` sh
# move back 2 commits
git reset --hard HEAD~2
# force push since you're changing history in the remote
git push -f
```

I won't lie and say those aren't risky operations, especially with a merge in ther :) There's a chance you'll screw it all up (I certainly have). Luckily it's a smaller change so easily reproducible. In the future you'll probably want to do PRs in a branch anyway (and not on master).

If you don't feel comfortable, then no worries at all. I can grab the code commit and push that with you as the author.
 Awesome, thanks!. Don't worry about the failing test, that's not you.
  :thumbsup: thanks!
  PropTypes is largely getting replaced by Flow, so we aren't actively developing the proptypes feature.  Even if we were developing proptypes, we most likely wouldn't add this new functionality.  Recommendation is to just use comments/docs.
 @plasticine Having each framework define it's own notion of proptypes is not a scalable approach.  We switched to ES6 classes for a similar reason (having each framework define their own notion of classes, mixins, etc - is not scalable for the community).  As generalized tools become available, our framework-specific hacks should fade away.

We've been pretty consistent about our messaging on this point:
- https://github.com/facebook/react/issues/5215#issuecomment-149318908
- https://github.com/facebook/react/issues/5080#issuecomment-146373158
- https://github.com/facebook/react/issues/5314#issuecomment-152049117
  ES7 will likely include [class property initializers](https://gist.github.com/jeffmo/054df782c05639da2adb) and you'll then be able to specify your method with an arrow function to autobind it:

``` js
class Foo extends React.Component {
  render() {
    // ...
  }
  handleChange = (e) => {
    // ...
  }
}
```
 We're unlikely to add any magic specifically to React for this though ‚Äì the new syntax should be enough.
 FYI, you are not forced into using ES6 classes. `React.createClass` still exists with autobinding and will continue to exist for the foreseeable future.

ES6 classes intentionally don't have support for things the language doesn't support.
  As per discussion in https://github.com/facebook/react/issues/3501, we may want to consider other alternatives rather than merging this.
 Thanks for sending this in ‚Äì going to go with #3663 instead.
  lgtm, thanks!
  #3589 got merged with the same change, so we can close this out.
  lgtm! Thanks!
  Yea, that's fine. Thanks! The `sudo` bit was probably copied from the react-tools readme.
  Since copy+pasting our code makes it too easy for people to XSS themselves, lets just add a comment in there about it.
 @zpao My intuition is that it makes more sense to fix the example (call a sanitization library) or to change the example completely (demonstrate something else that is safer).  It looks really bad to have a security warning on the homepage of the react site.  Makes it seem like our framework encourages unsafe operations, rather than a safe-by-default way of doing things.
 Uh yea, that sounds fine to me. This behavior is definitely non-standard markdown but it's an example so not a big deal. We should probably do the same for the tutorial while we're here. And it's on cdnjs so that's all pretty easy: https://cdnjs.com/libraries/markdown.js
 Just going to use _marked_ instead, which I'm already familiar with and has an option to sanitize input.
  I agree.  This doesn't sound like a bug in React.  I'm going to close this off to take it off our bug-tracking radar.  Feel free to continue the discussion on this thread or move it over to StackOverflow.
  :thumbsup: thanks!
  We should perhaps even update this further and match what we do in the html we ship in the tutorial repo: https://github.com/reactjs/react-tutorial/blob/master/public/index.html

Let me know if you want to do that or we can always to that later. It hasn't been an issue either way.
 I don't think it's super important to make the tutorial compatible with IE8. IE8 is usually an afterthought and if you do need to support it, you probably have some experience and know what you would need to do differently (including using an appropriate version of jQuery and not just copy and pasting code from tutorials).
 I like the idea but I'm a bit torn that it might be _too_ new. While `$.ajax` has it's downsides, it's relatively familiar. Even if you've never used it, it's pretty simple to understand. `fetch` on the other hand uses Promises which have another step to actually understand.

We don't do it in the tutorial but elsewhere we talk about aborting xhr during `componentWillUnmount`. This is trivial with native xhr & `$.ajax` but is actually currently impossible with `window.fetch`.

So for now, let's just stick with what we have. We may want to revamp the tutorial entirely in the future and we can consider it then.
 True, I forgot about jQuery's deferreds. And that's a good point. I'm not opposed longer term, but let's keep this change simple. I love the enthusiasm though - let's chat more about what else we can do to make some broader changes to the tutorial.
 :thumbsup: thanks!
  Unless I'm mistaken you _must_ use `dangerouslySetInnerHTML` with `style` elements, updating `style` element that uses children will break IIRC (this should be documented/warned for).
 JSX is very much a simple transform and we have no intention of making it special case specific tags. We also don't want to introduce complicated semantics. In this case you should use `dangerouslySetInnerHTML`. We may be able to make React warn if it gets a `style` element with children, but that should probably be tracked separately.
  I _think_ react is doing the right thing with specifying its browserify transform in our package.json. If you could minimize this to something anybody could reproduce (maybe a new repo) then we can try to help but as is, I'm not sure how much we can really do.
 Sounds like a plausible case and no activity from original reporter, so closing.
  Thanks! I'm going to let @jsfb and @spicyj review from here.
 Looks correct to me.  Good catch.
  Sorry, I'm not entirely sure what this issue is requesting, but `Transaction` is an internal API and it seems to meet our internal use cases, so I'm going to close this out.
  Yeah, the docs are just wrong here. Care to send a PR to fix?
 Oops, my mistake!
 I think this was fixed.  We don't have any notes about 0.12 anymore, and I don't see "factory" mentioned anywhere on the page.
 #5065 fixed this
  lgtm, thanks!
  Thanks! Sorry rebase caused pain!
  Your first request is a dupe of #1302 which is embarrassingly still open with an umnerged PR. Your second suggestion isn't really possible without advanced static analysis but is something that http://flowtype.org/ could warn about if it doesn't already.
 When referencing an existing component, it'll actually just be `React.createElement(Link)` and you can't tell statically what that Link refers to. createElement can warn when called, of course, which is what I think we do already. 
  Thanks!
  :thumbsup: Thanks for this!
  Seems fine to me.

Can you remove the merge commit and rebase instead?
  I guess we never did start using that label. Thanks!
  `Component` is the class, `<Component />` is an element.
 @dmatteo It's the equivalent of `Class` vs `new Class`. Factories are helpers for non-JSX users only, React consumes classes as-is. I'm not sure if there's a way to definitively check whether a given "function" is a valid component class or not. cc @spicyj 
 To clear up some of the terminology:

Elements are lightweight objects. They can be reused. An element is what is returned from `render`.

A component class is pretty much any "class" that has a render function the returns an element. These may have constructors but they should not be called directly. React will do the instantiation. Here's the simplest ES6 example:

``` js
class Foo {
  render() { return <div/>; }
}
```

A class can also be created with `React.createClass`.

A factory is a actually a function that wraps up the creation of an element of the specified type. These can be called directly (but if you're writing JSX you should never have to think about factories). Honestly factories are really unexciting but they get confusing. Basically it's just this:

``` js
React.createFactory = function(type) {
  return function() {
    return React.createElement.apply(React, [type].concat(arguments));
  }
}
```

Rendered components have state associated with them. They are the return value of `React.render`. Also, `refs`. There are very few methods and properties on these objects. Anything with an underscore is "private" and you really shouldn't be accessing it because we will break it (as you noticed). This will never be an element. And it shouldn't be.

I'm not sure what idea you're proposing. Can you clarify?
 Rendered components simply aren't elements. They are very different. If you took a rendered component and used it like an element (eg pass it to React.render) you would not get what the same thing.
 Can I turn it around. Why do you need to know? There may be another way to achieve what you're working toward.

I don't think we have any `instanceof` checks for component instances. cc @sebmarkbage 
 A rendered element is an instance of your component class, so you can always check if there is a `render`-method (I believe that's the only guarantee there is) and if there is one then it's _valid_, but not necessarily instantiated by React.
 A valid render() function is literally the only requirement, as demonstrated in @zpao's really simple ES6 example.  So your checks can't really rely on anything more than that.

We use open github issues to track bugs in React.  Since this isn't technically a bug, I'm going to close out the issue, which basically takes it off our development radar.  Feel free to continue the discussion here, or continue the discussion on a mailing list or StackOverflow.
  Yea, we can do better than that. On the plus side, looks like this error will actually log as `TypeError: type.toUpperCase is not a function` in the near future (does for me in my browsers: Firefox Nightly, Chrome beta).

We should be able to catch this in `createElement`. Strings are ok. Functions are ok (I think, or will be). Objects with certain characteristics are ok (has a render function?)
 No objects, just functions that return objects with a render function. I thought we had a warning for this already though.
 We just look for `!= null`. https://github.com/facebook/react/blob/master/src/classic/element/ReactElementValidator.js#L399-L407
 @cosmith @johntyree Did you see a warning in the console logged before the exception was thrown? There should be one.

> React.createElement: type should not be null or undefined. It should be a string (for DOM elements) or a ReactClass (for composite components).
 For this case specifically, it's because we want to be able to inline calls to React.createElement (https://github.com/facebook/react/issues/3228) without changing runtime behavior which we can do only if createElement never throws.
 Hopefully we can make the toUpperCase error a little less cryptic. Just posted #4154.
 In 0.14, you'll get something like this message:

> Invariant Violation: Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: null.
 This isn't possible without changing the transform, no. You can look at the stack trace to see where the error was.
 ## Folks, I already made the error message better in 0.14. Please stop commenting.
  We've intentionally moved towards https. We should update the fiddles so they are all using https. Cc @spicyj
 Ok, I just updated all of our fiddles and tested them inline in the docs from http - everything is working again.

Thanks for reporting!
  React relies on engines using object key insertion order for iteration, which practically all engines do. Guessing yours doesn't. You could try using Rhino, perhaps?

Closing as it's unlikely we'll change anything in React to support this use case.
  Thank you!
  I agree with @andreypopp, this is likely an issue of multiple instances of React.  Often a second copy of React gets pulled in by one of the dependencies you've loaded, so I'd recommend examining our dependencies.

Since React 0.12 has been out for quite a while and it doesn't sound like you're doing anything particularly fancy, I think it is unlikely that this is a bug in React; it is more likely an issue with your setup.  Github issues are used to track bugs in React, so I'm going to go ahead and close this issue since I don't think it's a bug in the React core.  Feel free to continue the discussion on this thread, or on StackOverflow.
  There was a security hack that mentions React here: http://danlec.com/blog/xss-via-a-spoofed-react-element

Ultimately this is a server-side bug and NOT a bug in React itself. This issue is about figuring out if there is something we can do to mitigate issues when you have a JSON parsing bug or some server-side issue.
## isValidElement

React is designed to work with plain objects as input, and in fact, we're even getting rid of the `_isReactElement` as a way to verify this. We'll allow any JSON object. IMO, there is no problem with the verification here.

All string values are sanitized before inserted into the DOM (except for CSS styles which is a known wontfix issue for IE8).

In earlier versions we used `instanceof` checks but that didn't work well with multiple Reacts, it makes it difficult to optimize (inline objects are much faster) and couples JSX permanently to React, which we would like to avoid.
## dangerouslySetInnerHTML

One possible solution is to disable this feature and require it to be used imperatively (`React.findDOMNode(ref).innerHTML = ''`) which makes for worse performance at insertion time.

However, I don't believe this is the only bad thing once you can insert arbitrary HTML tags. It is certainly the easiest way to gain access to XSS though. You can also insert arbitrary Web Components which could expose data. You can render form elements that can potentially pass data.
## What else can we do?

Ultimately this is an issue where `<div>{userData}</div>` seems like a valid use case, but if your userData is compromised, it becomes dangerous.

Should React be responsible for protecting itself against arbitrary JSON as children?
 I don't think "script" tags will execute because we use innerHTML to create them. Do the "style" tag and "style" attributes allow you to execute (in context) scripts in modern browsers? I think it is only older versions of IE.

Regardless, the UI redressing attack is still an equally valid concern.
 Note that JSON rendering of a virtual DOM tree is a perfectly valid use case. E.g. you can prerender a high level component into a smaller level virtual DOM tree on the server and then render the result on the client. This is also one of the ideas we had for web worker rendering where it would construct a virtual DOM that can be postMessaged and rendered on the other side.

Therefore, we also have to consider what options we have if we chose not to protect ourselves against JSON data. How much can we mitigate that scenario?
 Possible solution, use different syntax for inserting strings as children:
- `<span>{=this.props.username}</span>`: Coerces username to a string.
- `<a href={this.props.url}> .. </a>`: Coerces url to a string (as now).
- `<div>{this.renderFooter()}</div>`: If `this.renderFooter()` returns a string or number, warns in 0.14, error in 0.15. Explicitly wrap in a span or use `{=str}`.

Feels ugly but would solve the problem, wouldn't it?
 Coercion doesn't catch mistakes where you miss it. We would need to make that a requirement, e.g. by wrapping strings in some placeholder that is distinct from elements: `{ __thisIsSupposeToBeAString: str }`
 That's why I suggested making it an error to pass a string to the non-coercing syntax (plain `{}`).
 I see. That would be difficult to enforce since they can come nested arrays or non-JSX sources.
 @sebmarkbage As schemaless storages are becoming somewhat popular, this is going to become more prevalent. At some level it is a repeat of inserting foreign HTML markup as a result of lack of escaping (React made it a goal to make it a thing of the past), but instead the vulnerability moved to React components where wrongly typed values can lead to insertion of foreign hierarchies.

I'd argue that even if we could somehow guarantee that insertion of foreign hierarchies wouldn't be _dangerous_, it would always be _very bad_. Malicious data will always wreak havoc on a system and React is just one part of it. The danger I see with React being targeted (apart from being easily exploited due to being debuggable client-side) is malicious data being rendered for other users of the same system, it's hard to guarantee that the malcious data won't be able to act freely under the assumed identity of those users.

---

I think the way forward is to drop implicit wrapping of primitive values. Printable values should be elements like everything else from React's perspective, they should not be implicitly wrapped like they are today. A printable value should look something like `React.createValue('foobar') => {type: 'value', props: 'foobar'}`, it's still serializable but it's not exploitable. JSX could have some simple syntax sugar for it too, say `{=foobar}`, and inline text would be automatically wrapped.

While it may seem rather draconian in a sense, I think this is the sensible way forward, HTML introduced a lot of conviences that turned out to be really inconvenient (for user interfaces), this is another one. I think the practical implication of this is not as bad as it seems; any sensible user interface backend would expose labels as `<label value={...} />`, buttons as `<button label={...} />`, etc. `React.createValue` would be largely exclusive to rich-text components where it actually makes sense.
 Having discussed this with several people now, I'm leaning towards the "mark as trusted" solution. It doesn't have to be a reference identity. It can be a unique enough token string or number. This token has to be shared between environments in a similar way as CSRF. By default we may share it with the realm through the global. 

It could also be completely disabled if you chose to.

> On Mar 24, 2015, at 10:59 PM, Glen Mailer notifications@github.com wrote:
> 
> I think the way forward is to drop implicit wrapping of primitive values.
> 
> I think to provide safety it would actually have to be the reverse - it should be easier to render a primitive value than to render a component. This is the approach that other front-end frameworks have converged on over time.
> 
> For instance <p>{user.name}</p> should always be a primitive render, which is known to be safe. The potentially unsafe version should look different, which causes the reader/author to look more closely, eg. <p>{!:user.name:!}</p> or something similarly wacky. This is possibly too much of a departure from the current way of doing things to be viable?
> 
> Note that JSON rendering of a virtual DOM tree is a perfectly valid use case.
> In a nutshell, we really need a way to distinguish if a JSON object has executable context (i.e. _isReactElement). Thanks!
> React is designed to work with plain objects as input, and in fact, we're even getting rid of the _isReactElement as a way to verify this.
> 
> These are conflicting goals, so I think React would have to make a clear choice here, the options I can think of are:
> 
> 1) Decide that all data is renderable, and increase documentation warning about this
> 2) Decide that all data is primitive by default, and introduce new JSX syntax to render data intended to be non-primitive
> 3) Find a way to mark data as "safe".
> 
> For point 3, to support the JSON cases, as well as createElement, there might need to be some sort of hydrateElement which can take a plain object and mark it as safe to render eg. <p>{React.hydrateElement(someJSONobj)}</p>.
> 
> As proved by the bug which prompted the discussion, a boolean property is not enough to mark some data as executable, as I understand it, the only "safe" option would be an object reference, perhaps something like {type: "div", React: React}, which can be checked using React === React at render-time. This re-introduces the multiple-react problem discussed above, and while that could be alleviated slightly by sharing some arbitrary flag object via global (window || global).___reactMarker = {}, this doesn't really help for iframes, web workers, or multiple windows.
> 
> A bit of a brain dump, (1) seems simplest but unsafe. (2) is safest but a large change, (3) seems fiddly and error prone.
> 
> Hopefully someone else has a better idea!
> 
> ‚Äî
> Reply to this email directly or view it on GitHub.
 @glenjamin 

> I think to provide safety it would actually have to be the reverse - it should be easier to render a primitive value than to render a component. This is the approach that other front-end frameworks have converged on over time.

By explicitly having to put all primitive values in a value element it becomes inherently safe, primitive values cannot render outside of it and non-primitive values are stringified inside of it (or w/e).

Personally this makes a lot of sense to me, we already implicitly wrap primitive values internally, this is also how any non-markup/style-inheriting backend would work. There's no such thing as rendering inline text in iOS and most other user interface libraries, it only really makes sense for rendering rich-text content.

This is also how you'd do it if it was implemented in say C/C++ where you would want a single type for all children.
 @glenjamin 

> Which is subtly different from HTML escaping of strings, where most strings work correctly when escaping is forgotten.

Yeah, but then again, `React.createValue()` would be the equivalent of `document.createTextNode()` so it's already there today, it's just that HTML markup implicitly creates text nodes, just like React currently does. But that's also a source of XSS in HTML and now in React too, but React hierarchies are object-based rather string, so React is vulnerable to malicous objects instead.

@sebmarkbage So it seems weird to me to add another "feature" to work around this when it isn't an inherent issue, it's introduced by implicit wrapping of primitive values (which we borrow from HTML, it still doesn't make sense for me for the purpose of user interfaces). I'm quite sure that performance implications of this should be minimal, but it obviously does significantly affect the code in one way or another. That is no doubt a very important consideration, but React has challenged many of the wrong-doings and inconvenient conveniences of HTML so far, I think this is another one that should be.
 > I might be missing something, but why does React need to complicate inserting stuff like conditional JSX elements by forcing users to wrap them, when it's not issue of React nor of 99% of use-cases when server is written properly.

@RReverser That applies to HTML as well and look at how that turned out :) React is obviously less susceptible as it relies on objects, but one missing/insufficient check somewhere (and a susceptible backend, say JSON schema) and an attacker can potentially act on behalf of all users visiting the site, that's the only reason I see why React should make an effort to prevent it (like it did with HTML markup).
 @syranide I see your point. You might be right. The usability and performance issues might be deal breakers - especially when other solutions are less invasive.

I'm still trying to wrap my head around where the line can be drawn between various data types. What is is that makes a string safe when its wrapped and when it is not. What makes an object not safe and when is it safe?

I am concerned that it is still too easy to do the wrong thing even with an explicit syntax:

The difference between something like this is very subtle:

``` js
<div>{=this.props.user}</div>
```

``` js
<div>{this.props.user}</div>
```

And both are legit use cases. You would have to actively test these code branches to notice that you did something wrong when you expected a string. Everyone has these kind of edge case code branches that go into production without ever being properly tested. Would this be a false sense of security as well?

Ultimately, I don't think that validating data structures is something that React needs to necessarily concern itself with. (We have type systems for that.)

The reason I think we need to address this particular issue is because the cost (XSS) is too high. I think it is fine if this mistake causes your site to break. I even think it would be ok if we had something that allows for UI redressing in this scenario. There are plenty of other ways to get to that point.

However, it is not ok that a simple mistake like this causes full cross-site script execution. This is too high of a cost/probability ratio. The risk is too high even when the probability is low.

I think the argument for the sourceID solution is that it specifically addresses the tag creation scenario which is causes these high risk scenarios.

There are still other issues that are not solved by simple data types alone:

``` js
<a href={this.props.userProvidedURL} />
<div style={{ border: this.props.userProvidedBorder }} />
```
 > I'm still trying to wrap my head around where the line can be drawn between various data types. What is is that makes a string safe when its wrapped and when it is not. What makes an object not safe and when is it safe?

@sebmarkbage I think to me it kind of comes down to `"Foobar"`, it's currently both an element and a primitive. If you instead imagine something like `<MyButton label={createValue('Foobar')} />`, whatever you put inside `createValue` becomes opaque, toString-ed and safe to render. Supplying a primitive value `label` would throw.

In this example, I would argue that `MyButton.label` should sensibly only accept primitive values, `<MyButton label="Foobar" />`. `MyButton` would internally call `createValue(this.props.label)`. So whatever you value you pass `label` will be safe to render. If `MyButton` would instead accept elements only, then passing a non-element would throw.

> I am concerned that it is still too easy to do the wrong thing even with an explicit syntax:
> The difference between something like this is very subtle:
> ...

Yeah (regardless of syntax really). But `createElement('div', {}, 'Foobar')` will throw, and `createValue(createElement('div'))` will helpfully throw, warn or toString it to something harmless. So yes, you _can_ still mess it up, but if you run it and it looks correct then it is correct, a rendered value can no longer turn into arbitrary elements if given malicious data which it previously could.

> Ultimately, I don't think that validating data structures is something that React needs to necessarily concern itself with. (We have type systems for that.)

With static type checking you would catch the above mistake without running the code, implicit wrapping prevents that as far as I see.

> The usability and performance issues might be deal breakers - especially when other solutions are less invasive.

I suspect that performance won't be an issue in the end, static values can be trivially reused and pooling should make dynamic values virtually free. But, yes there are some obstacles.

Usability is a very valid point. Any frontend that doesn't have style inheritance wouldn't understand `createValue` and would be unaffected, a string wouldn't be renderable by itself, to render text you explicitly render `<label value="Foobar" ... />` (or `<label ...>Foobar</label>`). So it's only frontends with style inheritance (like HTML) or rich-text components that would be affected by the introduction of `createValue`.

I don't have it all laid out in my head yet, but implicit behavior can be fragile/dangerous and we've seen that implicit wrapping is, workarounds will only reduce the problem, not fix it. So I think it's a matter of realizing that the implicit model is flawed in some way, can we take the explicit model and somehow make it almost as friendly as the implicit for such frontends? I suspect the answer is yes.

PS. I realize this really should be a separate discussion, it's not really about solving this XSS issue in any immediate sense. It's about whether or not the implicit model is too flawed. Less invasive solutions are far more realistic at this point.
 @brigand We've already evaluated and decided against protecting against invalid styles. It is not a simple fix. When we last evaluated it, we found that:

1) It was prohibitively expensive to do this automatically for you for any given value.
2) A whitelist of safe patterns would be massively huge and we actively want to move away from whitelists in React and fallback to the underlying DOM.
3) Any blacklist we could come up with would likely be incomplete anyway.

IE's CSS expressions is another one. Various url and paint expressions. Semicolons was not the only concern, but also various complex parsing rules.

I agree that this is bad because it relies on an implementation detail of React (HTML serialization instead of `element.style.foo =`). Hopefully one day, the slowest browsers will be fast enough to use that technique instead.

As for `javascript:` in href. Perhaps that should be protected against but it is also arguable that would be React overreaching. I do agree that the cost of accidentally doing this is very high which is why we've added additional protection against `innerHTML`.

At the end of the day, we can't protect against everything crazy in the DOM. We target it to interop with the environment that is there. We can put higher demands on new abstractions such as React Native.

It is also highly recommended that you build your own set of high level components instead of targeting HTML directly. This is what we do at Facebook because "semantic HTML" is not enough.
 @syranide I think this is a valuable conversation to have in this thread since this is a generic catch-all issue and not necessarily only related to one issue alone (see the title).

I don't really think that there is anything special about primitive values. A string is only one kind of data structure and we'd want to support many different ones. For higher level components you might have objects that represent the same kind of values. Even strings could be reimplemented with a different data structure in something like immutable.js. That may also be JSON serializable.

The key issue here is the union type. You have a set that accepts one of multiple types and you want to make sure that the user explicitly decides which one they put there. I think that ultimately that become prohibitively verbose. That is why we have union types (or overloads for that matter).

FWIW, we have a lot of components at FB that accept both strings or rich text. We need a convenient way to pass rich text through out the system too. It should also be possible to build it up in one place, componentize and use it in another. Since these rich text elements could include animation etc. it might make sense to allow them to be stateful too.

In that scenario, you would want the underlying component rendering of a label to accept a subset of components for its rendering. That's what we have a type system for (except propTypes is a dev-only system which doesn't protect against this kind of attack).
 @sebmarkbage Perhaps I wasn't entirely clear (I think). It seems to me that "everything is rich-text" model of HTML is flawed; it's great for documents but it's immensely fragile for user interfaces. Documents can be rendered within a user interface, but you don't render a user interface within a document, so it doesn't make sense to me why we should be using the document model of HTML as the fundamental design language if it weren't for it being the current render target. I would argue that any mature React user interface should do its best to avoid the HTML style inheritance/document model. I.e.

```
<div>
  <span style={...}>Click that</span>
  <button style={...}>Click me</button>
</div>
```

...and not...

```
<div style={...}>
  Click that
  <button style={...}>Click me</button>
</div>
```

In a more simpler more traditional setup I would write that as:

```
<panel>
  <label value="Click that" style={...} />
  <button label="Click me" style={...} />
</panel>
```

...or if you want a more generic button implementation (whatever is in children is the label)...

```
<panel>
  <label value="Click that" style={...} />
  <button>
    <label value="Click me" style={...} />
  </button>
</panel>
```

There is no longer a universal understanding of how to render a string. Components are inherently isolated and reusable from a style perspective, primitives cannot be rendered so the this XSS issue goes out the window and even white-space rules become irrelevant. There's an inherent technical beauty in that if you will that's as unambigious as it gets (for whatever it's worth), it could be a very formal no nonsense syntax that would be hard to argue with... it could even be marketed as a new general purpose primitive type that's not limited to user interfaces (ahem, we're basically talking about an XML subset now...).

That should be our **starting point** in my opinion. The only thing that's stands out is rich-text components which usually finds themselves useful in most user interfaces, so they should definitely not be forgotten. But it doesn't **necessarily** mean that rich-text should have a dedicated syntax or perhaps not the current syntax.

React is currently targeting HTML which makes this a daunting aspect, but that's only because HTML provides all these conveniences, if we would have targeted anything else I'm quite sure React/JSX wouldn't have walked down this path without significant consideration. I'm not sure what the solution is, but HTML sets itself squarely apart from all other user interface targets and doesn't really prove itself exceptionally competent so I think it's only sane to question whether HTML is really an ideal role model for React/JSX user interfaces.
 React Native's `<Text>` almost works like that, though you can have both strings and other Text elements as children of a Text. Other components don't accept text children like that.
 @syranide Mid/Long term I think you're right that this is the kind of architecture that React and its users should be moving towards. However it is not an easy shift to do immediately.

I don't see that the trusted source solution needs to block any important features that we would've gotten, by shifting to the newer architecture. So it seems like a safe short term solution that also doesn't block anything we were planning to do anyway.
 @sebmarkbage Agree and agree.
 I've been thinking about the priorities here. As I see it there are three threats:

A) XSS through dangerouslySetInnerHTML, `href="javascript:..."` or script tags etc.
B) Clickjacking by `<a href="..." />`, `<form />` or similar.
C) Other types of UI redressing scenarios that doesn't involve interactivity.

If we agree that React is the secondary layer to an already broken issue, and the real solution **always** is to fix the JSON pass-through hole. Then it follows that React is not responsible for providing the permanent solution. React is only responsible for mitigating the impact, IF this hole occurs.

Full XSS (Threat A) is clearly a too high of a cost of this bug and even if you fix it quickly the harm is already done.

Getting an embarrassing redressing message or phishing attempt through a static message (Threat C) might not be as bad. Even if they do happen, there's no guarantee that there is any significant harm done. They can then be fixed by addressing the pass-through hole, before any real harm is done.

If we agree that we only need to protect against A and possibly B, then we have a lot more possibilities to limit the scope of the problem to a few sensitive attributes.

Another thing that I would like to start thinking about is.... What if we ran React in a worker? What if we allowed a cross-origin script to communicate through the worker and render arbitrary `ReactElement`s (which could be targeting higher level abstractions or real DOM nodes)? What kind of things would we need to protect against then?

The point of that scenario is explicitly to allow arbitrary UI elements in a subtree of the page (probably with `overflow: hidden`) which means explicitly allowing for Threat C and probably even B.
 @sebmarkbage As far as I'm concerned those are all related to HTML and not React (except for this particular issue). So while they should be addressed, doing so without implementing a much safer abstraction of HTML (which it seems we won't) doesn't seem worthwhile and I'm sure there would still be many tricks that ReactDOM might simply not be able to guard against. I think publicly documenting and explaining all the known pitfalls would go a long long way. It seems to me that the _biggest_ issue right now is the general lack of awareness, not mistakes.

E.g. **what are all the dangers of a user supplied href?** `javascript:` is one, but it applies to 3rd-party protocols too, including urls without a protocol/domain part, so you should always block everything but say `http://` and `https://`. You should also beware of links that point to the current domain which could possibly perform operations on behalf of that user. React simply cannot guard against this, it needs to be documented and possibly be made available as ready-made helpers.

It's also important to document that `style={{backgroundColor: userColor}}` is also exploitable and allows injection of arbitrary CSS. It won't stop the problem, but just having it publicly documented is a big step (seeing as it's unlikely that we can ever out-right prevent it when targeting HTML).
  Nice, thank you!
  Thanks!
  I'm going to close this and point you to #2127 (feel free to subscribe, discuss more there). This is definitely a known limitation of how React currently works.
  The problem I think is that Immutable is using the return value of the map to create a new Set. That's legit. However in order to do that when objects are the values, it needs to shim weak maps. And in order to do that it actually needs to set a property on the object (in this case a ReactElement). In `__DEV__` in React we freeze the element when creating it, thus making it non-extensible.

Your best bet is probably to turn your Set into an array and map over that.

``` js
    var nodes = Immutable.Set([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]).toArray().map(function(item) {
      return (<span>{item}</span>);
    });
```

As to why this works with array of size 8, that's an implementation detail of the Trie library (`MAX_ARRAY_MAP_SIZE = 1 << 5 / 4 // => 32 / 4 = 8`).

I'm not sure there's much we can really do on React's end at the moment. We want to freeze elements in dev to prevent user error and establish best practices. Perhaps we can add some fancy interop so Immutable knows it's dealing with a React element.
 The recommended way is to turn it into a sequence (Iterable) first using toSeq() and then mapping over that.

> On Mar 25, 2015, at 3:01 AM, Michael Narciso notifications@github.com wrote:
> 
> Thanks for the explanation @zpao, I was trying to avoid having to convert Immutable objects. However, for my use case I switched to using Immutable.List() and it's been fine. I was originally exploring usage for List() Set() OrderedSet() Map() etc and how they might interact with my React components.
> 
> Is it not recommended to pass Immutable objects to react components?
> 
> ‚Äî
> Reply to this email directly or view it on GitHub.
 Going to close out since the immediate issue is solved. We can figure out interop later.
  We currently have a whitelist of supported attributes.  We want to remove the whitelist and allow all attributes at some point (https://github.com/facebook/react/issues/140) but it's tricky because some components pass all attributes to their children.

Edit: Actually, changed my mind, we'll leave this one open to track the addition of `webkitdirectory`, `mozdirectory`, and `directory` until such time as https://github.com/facebook/react/issues/140 is fixed or these are added.

A #goodfirstbug might be to add these to the whitelist.
 webkitdirectory was added by https://github.com/facebook/react/pull/3644.
 Still need `mozdirectory` and `directory`.
 I think we're pretty unlikely to take it for the next release (very soon) and we'll hopefully get to a point before the next release after that where all attrs will work without the whitelist. So I'm not super inclined to spend any effort here at the moment.
  Sorry about no reply.

I think at this point most React users have gone through 0.12 -> 0.13 migration. We are now releasing v15, and I don‚Äôt think spending time on adding warnings about migrating off 0.12 patterns is something we plan to do at this point. This is why I‚Äôm closing this issue.

If you see others ways to improve the onboarding experience for new users and warn about potential problems please feel free to send a pull request! Thanks.
  Dupe of #3399.
  Thanks!
  Thanks for noticing this! I actually can't repro the autoplay (but for me nothing shows up so still an issue). I decided to just fixup the videos page in general in #3487 so I'm going to close this out.
  Someone else mentioned this being surprising to me too.
 As far as I understand it, the idea is that `{__html: ...}` is basically the equivalent of a HTML-type. You're not meant to use it as `<div dangerouslySetInnerHTML={{__html: this.props.description}} />`, but as `<div dangerouslySetInnerHTML={this.props.description} />` so that you cannot accidentally pass unsafe data. So `description` should be `null` or `{__html: ...}`, in this model it does not make sense to have `{__html: null}`.
 @syranide That doesn't mean that people won't write it as `dangerouslySetInnerHTML={{__html: this.props.description}}` ‚Äì doing so is even pretty reasonable if you're careful about naming your vars/props and do `dangerouslySetInnerHTML={{__html: this.props.descriptionHTML}}`.
  This is not React but whatever editor you are using, specifically:

```
    console.log content # yes, I found it to be HTML every time
    @setState text: content
```

You're even saying it's HTML yet you put it in text, so that's where your escaped text is coming from.
 React doesn't do anything special to your state properties. If you put HTML in, you'll get HTML out. If you can make a minimal repro case that shows this isn't the case I'd be happy to take a look‚Ä¶ but React doesn't do anything to your state properties so I'm fairly confident that's not the case.
  This is good as-is ‚Äì thanks!
 Thanks - I'm curious as to why this only broke recently though? Is the React site loading via HTTPS now but it never used to?
 Looks like we never merged this to stable.
 This was landed before the stable branch was cut and you can see this code in the branch.
  @Daniel15 I though we were going to remove this page and let this live entirely in the react-magic repo?
 @zapo The scripts live in the react-magic repo, but I think we'll keep the page on the React site as it's still really useful there.
  This is actually correct as is. `markup` is generated on the client. `rootMarkup` is what was already in the node. The failing test shows this correctly (yay tests!).
 I would definitely be interested in a test case that shows the discrepancy. Let us know if you can repro & find the time to share.
  This issue is old and hasn't been active for a while.  It also appears to be a usage question rather than a bug in the React core.  We use github issues to track bugs in the React core, so I'm going to close it out to take it off our radar.  Feel free to continue the discussion on this thread.
  cc @jsfb - I'm not following the plans for context, can you confirm.
 Sorry about this ‚Äì we'll make sure to get that in 0.13.2 if we do another minor release.
 @xizhao No. In 0.14 this will work how you want it to.
 Next time, maybe don't use unstable, undocumented features if you don't want to run into trouble.
 @shaurya947: 1 and 2 are correct.  3 is usually but not always true (it is possible for an owner to do odd things with the elements it creates, like render them somewhere other than as a child).  Also, the order of elements/context-assignments may be different in the owner-ownee vs parent-child relationship (which is important if components override the context variable's value).  To a first order approximation, it's correct to say that owner-ownee is a subset of parent-child, but it's not strictly true and there are corner cases.  Also, context is not a supported feature.
  Now documented here: http://facebook.github.io/react/docs/reusable-components.html#es6-classes

We use fat arrow internally and in many docs.  Ultimately it's just syntax, and you need to decide what makes the most sense for you given your infrastructure and codebase.
  @grav Because `shouldComponentUpdate`; by reading props/state from arguments you're unable to access updated props/state if `shouldComponentUpdate` ever returns false when a prop/state actually changed. This is a problem if you have inline closures in your render as they will be reading outdated props/state.
 ```
function(props) {
  return <div onClick={function() { console.log(props) }} />
}
```

Will always output the props it was last rendered with, not necessarily the up-to-date props. Whereas if you put `this.props` in there it will always output the up-to-date props.
 There's a bunch of discussion in #1387, which is about the same thing.

It's not the default of React because we're in a somewhat functional, somewhat OO world. What we're enabling moving forward is something like this where any function with the right signature can be a component.

I'm going to close this out because of the overloap, but feel free to read some more of the thoughts over there.
  `shouldComponentUpdate: function() { return false; }` ... ?
 @Youmoo Right, as far as I see it React components are classes, not a bunch of values, so magic values and "shape-shifting" properties should be avoided at all costs. `shouldComponentUpdate` is a method so it should be a function.

cc @sebmarkbage 
 Yeah, since you can just write `function() { return false; }` to get the same effect we'd rather keep API consistency instead of making this pattern a few characters shorter. You can even write `() => false` with ES6 arrow functions if you're looking to save a few more.
 I think we might want to build a different system where a parent promises that its properties are pure, and if so, the children are able to do shallow comparison by default.
 @sebmarkbage :+1: 
  Thanks!
  This is unfortunate but the way it is for now. If you don't have a good reason for using preventDefault(), don't.
  The current behavior is how JavaScript generally implies display names though IIRC? You're always free to provide your own displayName if you feel the one generated by JSX is insufficient.
 What do you think about doing something like this?

``` js
/**
 * If `expr` is an Identifier or MemberExpression node made of identifiers and
 * dot accesses, return a list of the identifier parts. Other nodes return null.
 *
 * Examples:
 *
 * MyComponent -> ['MyComponent']
 * namespace.MyComponent -> ['namespace', 'MyComponent']
 * namespace['foo'] -> null
 * namespace['foo'].bar -> ['bar']
 */
function flattenIdentifierOrMemberExpression(expr) {
  if (expr.type === Syntax.Identifier) {
    return [expr.name];
  } else if (expr.type === Syntax.MemberExpression) {
    if (!expr.computed && expr.property.type === Syntax.Identifier) {
      var flattenedObject = flattenIdentifierOrMemberExpression(expr.object);
      if (flattenedObject) {
        flattenedObject.push(expr.property.name);
        return flattenedObject;
      } else {
        return [expr.property.name];
      }
    }
  }
  return null;
}

...

var displayNamePath = flattenIdentifierOrMemberExpression(left);
if (displayNamePath) {
  if (displayNamePath.length > 1 && displayNamePath[0] === 'exports') {
    displayNamePath.shift();
  }
  addDisplayName(displayNamePath.join('.'), right, state);
}
```

Not tested, but it feels little cleaner to me.

Also, can you add a test for the `exports` behavior too? 
 Thank you!
  You can probably open the framed content in a new window and debug normally, right?
  I don't think anyone has been using this in a long time. Let's kill it?

@jsfb just double checking: are you using parts of this?
 Yeah I guess it is safe to just kill it.
 It's version control, we can undelete it.
  If react-router were compiled also with closure compiler, then minifying the prop names would be the correct thing to do. Since it's not, my understanding is that you're supposed to create an externs file that lists all the property names that it uses, so that the key `handler` remains unchanged:

https://developers.google.com/closure/compiler/docs/api-tutorial3#externs

Let me know if that doesn't sound right to you.
 Wouldn't it still get minified on the other end? Wouldn't `this.props.handler` become something like `this.p.a` there but would be `this.p['handler']` if we quoted in the transform? Or everybody accessing props would have to write `this.props['handler']`, which seems pretty fragile.
  This doesn't come up very often, so it's probably not worth cluttering up the documentation with something that no one will ever remember reading.

However, we probably could warn if `config.__proto__ != null && config.__proto__ !== Object.prototype`

We should warn on both `createElement` and `cloneElement`.
 Yes, you're correct, thanks!
 @neilgalarneau Can you provide a brief sample of the code you were using? In particular, I'm curious whether you were using JSX or React.createElement directly.
  Can you also make sure this works with the servers we tell people to use in https://github.com/reactjs/react-tutorial/?
 No response, closing. Don't think it's a huge deal for the tutorial anyway.
  Looks great ‚Äì thanks!
 (If you have a repro case, you should also be able to turn on break-on-exception in the debugger and inspect the stack trace to show you the culprit.)
 That's true, but you can put a breakpoint where the console.warn call is. If you turn on "Pause on Uncaught Exceptions" then this line should also put you in the debugger:

https://github.com/facebook/react/blob/5d9b228e03d08bc50fa0c0b4d8e48fefeb342e31/src/vendor/core/warning.js#L55

We should add a page on the React site somewhere explaining this.
  Good idea, thanks. Want to send a pull request?
  Thanks! :)
  Curious: Were you using JSX? Either way, I'd expect at least _some_ sort of error‚Ä¶
 @spicyj I guess there wouldn't be an error if you write `<mycomponent>` because we just assume that's DOM now and innerHTML it. No more whitelist means we can't really warn about this :/.
 Wonder if there's a way to test if a browser understands a tag name.
 In any event, we can take this. Thanks for sending this in!
  (#2052 broke somehow, resubmitting)

Previously it was only given to a subset of the functions on the spec.
Fixes #3173.
@zpao 
 @zpao received spam here. Maybe this is a sign that it should be merged soon, lol
 if you rebased and it still works then do it up.
 @zpao rebased, tested but also tweaked the thing to distinguish a function from an anonymous component vs a mixin. It passes a boolean to `mixSpecIntoComponent`, and passing boolean params is still discouraged iirc? Is it important here?

@spicyj 
 We didn‚Äôt do a very good job reviewing this one but if you‚Äôre still up for some rebasing.. :stuck_out_tongue: 

I‚Äôll close this out as part of the effort to clean up stale PRs. #3173 still has a ‚Äúgood first bug‚Äù¬†label so if you don‚Äôt feel like submitting this again, hopefully somebody else will pick it up. In any case I don‚Äôt think there is a sense of urgency here as more people are moving to either ES classes or functional components.
  I think this is just a bug, not an intentional breaking change. Thanks for reporting.
  dupe of #3972 which is fixed in 0.14
  lgtm, thanks!
  @WishCow `this.state` should be a plain object, you're not allowed to put classes in there.
 @WishCow Seems so... cc @leebyron @sebmarkbage 
 @jeffutter AFAIK this is not going to change. Personally I still don't understand why people want to put third-party objects as state, I don't see what benefit there is. What's wrong with just using `setState`?
 There is movement on #3303 which would get rid of replaceState and add better immutable-js support (and perhaps other libraries) in the core.

However, it was not our intention to break the old behavior of replaceState in 0.13 so this seems like a bug to me.

@zpao @spicyj Do we maybe want to patch release this if there is an easy fix?
 @jeffbski 
1) I can't speak for this, but using a store's data for the singular state object seems rather limiting, you're now unable to include any other stores or introduce any other locally relevant state for the component right?

2) Is straight-forward with objects as well, immutability is not a concept that is unique to _immutable-js_. Depending on the underlying behaviors you can use just `===` or a simple reusable shallow equality test with plain objects too.

@sebmarkbage But does #3303 actually intend to allow replacing the "state object" vs just simply understanding how to iterate over generic maps/sets?
 @sebmarkbage not sure that it will be the cleanest thing. This is a result of your `ReactUpdateQueue` changes #2930. Right now we just have a `pendingStateQueue` but we don't know what each thing in the queue is (did it come from a `setState` or `replaceState`). We could wrap each item in the queue so we know what it came from, so instead of `[state, state]` we have `[{state: state, is: 'set'}, {state: state, is: 'replace'}]`. That would allow us to stack `setState` and `replaceState` calls (which I don't think we actually handle correctly now).

But the simplest case where you're only using `replaceState`, we can probably just change this line: https://github.com/facebook/react/blob/master/src/core/ReactCompositeComponent.js#L626.

``` js
// BEFORE
var nextState = assign({}, replace ? queue[0] : inst.state);
// AFTER (maintain identity of queue[0])
var nextState = replace ? queue[0] : assign({}, inst.state);
```
 We could take something in 0.13.4 (not 0.13.3, shipping that today). But it needs to bake first. Both changes I mentioned would change behavior so there's some risk. The first is more complete, the latter trades 1 bug for a slightly less bad bug (setState(), replaceState() in the same update queue will result in the object passed to setState being used as the replacement since we only have a single pendingReplace flag)
 Actually, this came from #2991. There is a simple fix:

``` js
if (replace && queue.length === 1) {
  return queue[0];
}
```

https://github.com/facebook/react/blob/master/src/core/ReactCompositeComponent.js#L625

Because the queue is emptied for every replaceState, since nothing earlier in the queue could've affected the result:

https://github.com/facebook/react/blob/master/src/core/ReactUpdateQueue.js#L177
 Ah, truth. @spicyj is fixing and it's small and let's just take it in 0.13.3 so we don't have to do another patch release so soon after.
 setState merges. Using a non-plain object with it isn't supported. You can put whatever object you want on an inner state key (this.state.data, this.state.map, etc.).
  I think the recommended way is to make sure you're properly cleaning up resources and canceling timers, etc. in componentWillUnmount, so that you don't need to worry later about whether the component is still mounted. @sebmarkbage can probably say more.
 The common case where this is difficult is for Promises (terrible design to not make them cancelable) but we'll probably add some custom workaround for Promises, for everything else, we recommend that you clean up and timers during `componentWillUnmount`.
  @koba04 We've got full eslint coverage now, so I disabled jshint for react at FB internally. Do you still have time/interest to work on this? Can you rebase it?
 > I didn't remove it from `vendor/browser-transforms.js`

You can change that one. My previous comment was about `vendor` in `src`. This one isn't synced with anything else.

> Should I convert to use JSX?

No, leave those alone.
 This lgtm. Any comments from you @PiPeep?
 The commit lgtm, pending `vendor/browser-transforms.js`. I checked it against `ag jshint -p .eslintignore`, and it seems to cover everything.

@zpao, are we simply avoiding jsx altogether in the react source, excluding `__tests__` and `src/addons`?
 Currently that is correct (except we also don't use it in src/addons).
 Oh, sorry. I think I was accidentally looking at code within comments.
 Thanks!
  It looks like `pubdate` isn't part of any html standard.

Neither of these specify it: https://html.spec.whatwg.org/multipage/semantics.html#the-time-element, http://www.w3.org/TR/html5/text-level-semantics.html#the-time-element
 @t128 It seems it was dropped from the spec, I saw it mentioned somewhere that `itemprop="datePublished"` replaced it.
  Thank you!
  We're not going to do this. The concept of elements is not specific to the DOM and so we're not planning on adding shortcuts like this.
 className doesn't have any significance in other environments, like React Native. You're free to create a wrapper in your own code for this if you prefer but we won't support it as part of the core. Thanks for sending in the idea though ‚Äì always good to have people thinking about how we can make the API better.
  Yes, we knew there was a perf regression in dev. That's the cost of doing business here to add more warnings and do things like "freeze" props, setting up getters and all that.

As we remove some deprecated patterns we'll see some speedups since we'll have less code for warnings.

I'll leave this open for now but I'm not sure how much we can really do at this point, if we even want to.
 I just did some profiling here and there aren't big, obvious, easy wins to be had so we're probably going to leave it like this for now. Hopefully next release will be faster‚Ä¶
 Closing as this has been inactive for a while, and it doesn‚Äôt appear that we have any specific plan to improve perf in dev. If the problem keeps getting worse (I‚Äôm not sure what the situation in 15 is?) we might want to revisit.
  Ok, I sort of wish you had gotten in touch first. There are things I don't care about and strictly listening to lint often leads to uglier code. This is why it's only a warning, not an error.

Many of these are fine but I'm going to ask you to revert some of the changes.
 We're all caught up on linting, these probably got fixed by @bgw or somebody. Thanks though!
 @zpao I don't think they got fixed. I think we just disabled the `max-len` rule.
 Either way, lint doesn't complain :)
  cc @jsfb - sounds like we'll definitely want to address this before we cut over.
  We actually made this change intentionally but then I forgot to update the fiddles with https sources. I'll do that shortly
 Done.
  lgtm, thanks!

CC @syranide who broke (üòâ) this in #2241.
 @zpao It seems your prayer wasn't heard ;) But yeah, my bad, I apparently forgot to consider the empty case.
  Sorry, meant to comment the other day. You did figure out the right option (`es6module`). Sorry about the confusion and lack of docs here.
  You're free to use whichever you like, what is the question?
 @mirkodrummer  `React.createClass` is still there and with these new changes you're free to tweak it however you like. This change is effectively making React un-opinionated about how you construct your classes, just as it should be, it has not taken anything away it has simply stepped back from enforcing from `React.createClass`.
 @mirkodrummer It will always be. It might not be actively maintained by the React team for all forseeable future, but the idea is in no way deprecated and you're free to use/write your own (better) replacement.
 > Anyway I think there we didn't get the point: Javascript Classes, something that sounds as continuing doing the errors of the past.

@mirkodrummer That makes no sense to me. React has stepped back from being unnecessarily opinionated, how is that bad? It's an incredible improvement from the current state of every JS framework in existance having invented their own consistently flawed concept of classes which are never compatible with any other classes.
 @mirkodrummer If you want to use `class` or not that's your choice, it's just syntax sugar anyway so I don't see a point in setting up the prototype manually, it's just more mork. I'm using traditional prototypes for my [react-swf](https://github.com/syranide/react-swf/blob/master/npm-react-swf/react-swf.js) for simplicity as widespread native `class` syntax is far far away, but I'm using ES6 class syntax in all my professional work.
 > i hope the react team dont deprecate `React.createClass`

@bjrmatos They "can't", they might stop supporting it at some point, but it's not tied to core so there's no reason the community can't take over long before that happens and most likely will. It's nothing more than a utility.
 @bjrmatos Any classes that can be instantiated with `new MyObject` and have a `render`-method are compatible, regardless of how it was built, that's all React knows and cares about. Even if React wanted to discriminate it couldn't. There's nothing to worry about. :)
 We're not trying to encourage inheritance; we prefer composition in general and continue to try to make it more feasible. Encouraging composition is one reason we've been promoting building higher-level components instead of using mixins when doing so is possible. You may also be interested in Sebastian's comment here: https://github.com/facebook/react/issues/613#issuecomment-76621639.
  https://github.com/facebook/react/blob/75a8bc96b10ef364c751bbc7a0594dbdb7e8663c/src/browser/ui/ReactMount.js#L819

It's comparing it against `outerHTML` which isn't guaranteed to be identical to the initial markup (and never is on IE8 too).

cc @arnihermann 
 @arnihermann innerHTML vs outerHTML makes no difference, the issue is that neither of them gives any guarantee to return the same markup you put in. The only reasonable solution I see is to render the new markup as well and read outerHTML from it and compare that.
 @jordansexton The message here is a red herring ‚Äì it's not those attributes themselves that are the problem, but something else in your markup.
 @jordansexton My best suggestion is to call React.renderToString on the server and on the client and compare them. They'll have different root node IDs so the strings won't match up directly but maybe you can do a find and replace to make them match up.
 @jordansexton As far as I can tell, these are all the same problem: the warning message not being useful when browsers slightly change the format of HTML that gets passed through.
  This is a first-class API for sideways data loading of stateless (although potentially memoized) data from a global store/network/resource, potentially using props/state as input.

``` js
type RecordOfObservables = { [key:string]: Observable<mixed> };

class Foo {

  observe(): RecordOfObservables {
    return {
      myContent: xhr(this.props.url)
    };
  }

  render() {
    var myContent : ?string = this.data.myContent;
    return <div>{myContent}</div>;
  }

}
```

observe() executes after componentWillMount/componentWillUpdate but before render.

For each key/value in the record. Subscribe to the Observable in the value.

``` js
subscription = observable.subscribe({ onNext: handleNext });
```

We allow onNext to be synchronously invoked from subscribe. If it is, we set:

``` js
this.data[key] = nextValue;
```

Otherwise we leave it as undefined for the initial render. (Maybe we set it to null?)

Then render proceeds as usual.

Every time onNext gets invoked, we schedule a new "this.data[key]" which effectively triggers a forcedUpdate on this component. If this is the only change, then observe is not reexecuted (componentWillUpdate -> render -> componentDidUpdate).

If props / state changed (i.e. an update from recieveProps or setState), then observe() is reexecuted (during reconciliation).

At this point we loop over the new record, and subscribe to all the new Observables.

After that, unsubscribe to the previous Observables.

``` js
subscription.dispose();
```

This ordering is important since it allows the provider of data to do reference counting of their cache. I.e. I can cache data for as long as nobody listens to it. If I unsubscribed immediately, then the reference count would go down to zero before I subscribe to the same data again.

When a component is unmounted, we automatically unsubscribe from all the active subscriptions.

If the new subscription didn't immediately call onNext, then we will keep using the previous value.

So if my `this.props.url` from my example changes, and I'm subscribing to a new URL, myContent will keep showing the content of the previous url until the next url has fully loaded.

This has the same semantics as the `<img />` tag. We've seen that, while this can be confusing and lead to inconsistencies it is a fairly sane default, and it is easier to make it show a spinner than it would be to have the opposite default.

Best practice might be to immediately send a "null" value if you don't have the data cached. Another alternative is for an Observable to provide both the URL (or ID) and the content in the result.

``` js
class Foo {

  observe() {
    return {
      user: loadUser(this.props.userID)
    };
  }

  render() {
    if (this.data.user.id !== this.props.userID) {
      // Ensure that we never show inconsistent userID / user.name combinations.
      return <Spinner />;
    }
    return <div>Hello, {this.data.user.name} [{this.props.userID}]!</div>;
  }

}
```

We should use the RxJS contract of Observable since that is more in common use and allows synchronous execution, but once @jhusain's proposal is in more common use, we'll switch to that contract instead.

``` js
var subscription = observable.subscribe({ onNext, onError, onCompleted });
subscription.dispose();
```

We can add more life-cycle hooks that respond to these events if necessary.

Note: This concept allows sideways data to behave like "behaviors" - just like props. This means that we don't have to overload the notion state for these things. It allows for optimizations such as throwing away the data only to resubscribe later. It is restorable.
 `undefined` is probably the safest value to assign to `data` until the observable provides its first value via `onNext`. For example in Relay we assign different meanings to `null` (data does not exist) and `undefined` (not yet fetched), so our ideal default data value would be `undefined`. The alternative is to provide a new method, eg `getInitialData`, but I suspect this is unnecessary/overkill.
 The reason is because we don't want to require the use of combinators and understanding RxJS to be able to subscribe to (multiple) Observables. Combining two Observables in this way is quite confusing. In fact, at least for our data sources, we'll probably implement the subscription API but not even include the combinators on the Observables' prototype. That's not a requirement, but you're free to use combinators if you need to.

However, to subscribe to a simple Flux store, you shouldn't need to.

I think that Flow will probably be able to handle this static type using constraints, but I will check with those guys to make sure. I think that it'll be enough to type the data property and then the observe type can be implied.

``` js
class Foo extends React.Component {
  data : { user : User, content : string };
  observe() /* implied as { user : Observable<User>, content : Observable<string> } */ {
  }
}
```

This change is not about going all in on Observables as a way to describe application state. That can be implemented on top of this, like you've done before. This is explicitly not about application state since this method is idempotent. The framework is free to unsubscribe and resubscribe as needed.
 cc @ericvicenti
 @aaronshaf @gaearon The benefit of making it first class is:

1) It doesn't eat away at the props namespace. E.g. the higher-order component doesn't need to claim a name like `data` from your props object that can't use for anything else. Chaining multiple higher order components keeps eating up more names and now you have to find a way to keep those names unique. What if you're composing something that might already be composed and now you have a name conflict?

Besides, I think that best-practice for higher-order components should be to avoid changing the contract of the wrapped component. I.e. conceptually it should be the same props in as out. Otherwise it is confusing to use and debug when the consumer supplies a completely different set of props than is received.

2) We don't have to use `state` to store the last value. The `data` concept is similar to `props` in the sense that it is purely a memoization. We're free to throw it out at any point if we need to reclaim the memory. For example, in an infinite scroll we might automatically clean up invisible subtrees.
 @RickWong Yes, it would be fairly trivial to support Promises since they're a subset of Observables. We should probably do that to be unopinionated. However, I would still probably recommend against using them. I find that they're inferior to Observables for the following reasons:

A) They can't be canceled automatically by the framework. The best we can do is ignore a late resolution. In the meantime, the Promise holds on to potentially expensive resources. It is easy to get into a thrashy situation of subscribe/cancel/subscribe/cancel... of long running timers/network requests and if you use Promises, they won't cancel at the root and therefore you have to just wait for the resources to complete or timeout. This can be detrimental to performance in large desktop pages (like facebook.com) or latency critical apps in memory constrained environments (like react-native).

B) You're locking yourself into only getting a single value. If that data changes over time, you can't invalidate your views and you end up in an inconsistent state. It is not reactive. For a single server-side render that might be fine, however, on the client you should ideally be designing it in a way that you can stream new data to the UI and automatically update to avoid stale data.

Therefore I find that Observable is the superior API to build from since it doesn't lock you in to fix these issues if you need to.
 @elierotenberg Thanks for chiming in! It does seem very similar indeed. Same kind of benefits. Do you see any limitations with my proposal? I.e. there something missing, that React Nexus has, which you couldn't build on top of this? Would be nice if we didn't lock ourselves out of important use cases. :)
 @jquense There is active work on a proposal for adding Observable to ECMAScript 7(+) so ideally this would become plain JS. https://github.com/jhusain/asyncgenerator (Currently out-of-date.)

We would not take on a dependency on RxJS. The API is trivial to implement yourself without using RxJS. RxJS is the closest to the active ECMAScript proposal.

most.js seems doable too.

Bacon.js' API seems difficult to consume without taking on a dependency on Bacon because of the use of the `Bacon.Event` types for separating values.

The Stream APIs are too high-level and far removed from this use case.
 They might become more complicated (and slower) if the committee insists that calling `next` schedules a micro-task like Promises.
 I think a common Flux store pattern might be to keep a Map of Observables on a per-key basis so that they can be reused. Then clean them up when everyone is unsubscribed.

That way you can do things like: `MyStore.get(this.props.someID)` and always get back the same Observable.
 Async rendering is something we would like to support but is not part of this issue. L

Probably won't make it in 0.14 unfortunately. Many different designs to consider and refactor needed.

Feel free to create and issue describing the architectural changes to the internals needed to make that happen.
 @andrewimm The idea is to feed that into a generic error propagation system that bubbles error up the hierarchy until it is handled by an error boundary. https://github.com/facebook/react/issues/2928

This should also handle errors in methods throwing and recover gracefully. Like if the `render()` method throws. This is significantly more work and will take some time to implement properly but the idea was to unify error handling in this way.
 I would argue that this is the smallest integration point to get the new semantics of stateless data subscriptions. What other integration points would you suggest? Not including async rendering which is a much more complex issue and deserves its own thread, and this hook could be used with async rendering regardless.

Everything else is already possible to implement on top of React on a per-component basis. Note that we're not going to do global injections of plugins since that breaks component reuse across environment so frameworks built on top of React should be contextual to individual components.

What hooks are we missing?
 I don't understand the comments that it shouldn't depend on `this.state`. Encapsulated state surely makes React a lot more complicated but that is also all it is. If there wasn't encapsulated state, we would only need a memoized immediate mode library. If you go all in on "Stores", then yes, you don't need state but that is not what React prescribes that you do.

We have several patterns that requires you to create extra wrappers but for normal usage you shouldn't need to. Other than stores, your observed data always depends on state even if indirectly. I don't think it is bad practice at all to depend on it in observe. E.g.

``` js
observe() {
  return { items: Items.getPagedItems({ pageIndex: this.state.currentPage }) };
}
```

Even if `observe` didn't depend on `state` it would still depend on `props` and `context`. Even if it didn't depend on `context` you would still have an indirection that uses `context` to render a component's props that uses it in `observe`.

`observe` would need to get reevaluated every time a render pass comes down because the props could've changed. However, we would definitely diff the resulting observables and not unsubscribe/resubscribe if the same observable is returned. However, we can't do diffing on individual properties (other than with shouldComponentUpdate) so ideal you should implement your own cache using a `Map` as a power feature. That way you can return the same observable to multiple components in the tree. E.g. multiple components loading the same user. Even if you don't, you just recreate the Observable and eventually hit the bottom cache. This is just how React reconciliation works anyway. It's not that slow.

This `observe` hook isn't designed to make React completely reactive in the sense that state is captured in Observables. It is currently a key design goal is to avoid trapping state in closures and combinators and instead have a nice clean separate state-tree that can be frozen and revived, and potentially shared across workers.

Which brings me to my final point...

We certainly don't _need_ to add this to the core library. The original "public" interface was mountComponent/receiveComponent and you could build your whole composite component system on top of it. However, not many people used that it is much more powerful to raise the abstraction bar since we can now build other things that are enabled by a higher abstraction bar. Such as component-wide optimizations.

React's primary purpose is to create a contract between components so that different abstractions in the ecosystem can co-exist. An important part of that role is to raise the level of abstraction for common concepts so that we can enable new cross-component features. E.g. saving all the state of a subtree, then revive the subtree. Or possibly including automatic unmounting on the server or changing the timing aspects of reconciliation on the server.

It is also important to provide some batteries included to make all this palatable and uniform.

It is important to realize that micro-modularization (like adding a new life-cycle hook) isn't strictly a pure win over building it into the framework. It also means that it is no longer possible to reason about system wide abstractions.
 @jquense I completely agree. I wanted to add this hook a long time ago. (Original experiment: https://github.com/reactjs/react-page/commit/082a049d2a13b14199a13394dfb1cb8362c0768a )

The hesitation two years ago was that it was still too far away from standardization. I wanted a standard protocol before we added it too the core.

I think we're getting to a point where a lot of frameworks agree on the need for something like Observables and standardization is reaching a point where a palatable API has been proposed. I'm sure we'll need to end up tweaking it a bit but as long as the high level architecture works it should be swappable and eventually converge.

I think what happened with Promises is that the API and debugging story was severely lacking in certain areas that Observables doesn't suffer from. It is a more complete story out-of-the-box where as Promises had to standardize a minimal incomplete solution.
 @threepointone Sounds exactly like one of the implementation proposals to power https://github.com/reactjs/react-future/pull/28
 @Mitranim I agree, that's a really good read, thanks for finding that!  It's effectively what https://github.com/facebook/react/pull/3920 is suggesting.

We are undecided on which proposal is better.  Having played with both, I'm mostly convinced that reactive programming (as you linked; https://github.com/meteor/meteor/wiki/Tracker-Manual) is the way to go, but we haven't reached consensus and we're still trying to figure out what makes the most sense, so feedback is welcomed.
 @ccorcos Yes, in https://github.com/facebook/react/pull/3920 all the side-effects would be completely internal to React.  In fact, React core could implement them in a completely immutable/functional way that would not perform any mutations.  But that's an implementation detail, since the side effects wouldn't be externally visible anyway.
 @ccorcos The main problem is that when a component instance gets destroyed, all the "subscriptions" need to be cleaned up.  Component authors often forget about this cleanup, thus creating a memory leak.  We want it to be automatic, which makes it easier to write (less boilerplate) and less error-prone (cleanup is automatic).
 @Mitranim is correct, the semantics of #3920 are more "automatic" than Meteor (unsubscription really is automatic), and far simpler since there is literally zero API surface area in the common use case.
 @oztune No updates; we've been focused on other priorities.  We will post to one of the threads when there is an update on this topic.
  Nope, just never excluded it. Thanks!
  Do you have a repro case for this?
 My gut says this is multiple versions of React mixing.
 Closing ‚Äì @leiserfg if you're still having trouble let me know.
  :thumbsup: Thanks!
  :thumbsup: thanks!
  Unfortunately you're right that there simply is no way to actually use the parent context yet. You're probably best off using the deprecated features until then. Context is a trickier migration because we want it to be `this.context` and that's taken until we cut over. The warnings we have now are mostly unactionable.

I really don't think we should mix the two and conditionally use parent or owner. It's fraught with peril, any dependency change could break everything.

#2112 is the issue we're using to track the switch over.

@jsfb @sebmarkbage - anything to add?
 There are two tricks you can use in your ChildContextProvider.

The simplest one is to just accept a function instead of passing the child in directly:

``` js
    render: function() {
        return this.props.createChild();
    }
```

So instead of:

``` js
renderWithContext(<MyComponent />, ...);
```

You would do:

``` js
renderWithContext(() => <MyComponent />, ...);
```

OR

You can use the legacy `cloneWithProps` method since that tool gives it a new owner and context. If you have nested elements, you would have to loop over them using ReactChildren, recursively.

``` js
    render: function() {
        return React.addons.cloneWithProps(this.props.child);
    }
```

This will make the context provider the owner of those children. That way it will work with both parent/owner based context.

The complexity comes from the fact that you're passing them in from outside the root. Usually they're created in the root itself. Again, this complexity is why we're changing things.
  Chances are we'll tweak the tutorial a little bit so you're obviously interacting withe an API and not a file. See https://github.com/reactjs/react-tutorial/issues/39 if you're interested in helping out :)
  @Tvaroh: @miracle2k is correct, the official signature is `componentWillReceiveProps(nextProps)`.  Context is not officially supported, but is currently the second parameter.  I think your previous props are still available on the component instance.

It's also worth noting that the documented API guarantees that componentWillReceiveProps will get called when your props change.  An invocation of `componentWillReceiveProps` is not guaranteed to imply that your props have changed, nor is it guaranteed that componentWillReceiveProps will not get called if your props do not change.  Do not assume that componentWillReceiveProps will only be called when props change.
  Taking a look through it, I think you need to call start outside of a render. Many of the measurements are based around update batches so a batch is already started by the time you call this. The internal state of Perf gets messed up (which is why something is `undefined`).

The original goal of perf is that it would be used to measure the whole app and then you could drill down. It is not the same as something like `console.time/End`.
 Yeah, that seems reasonable @also, I'm going to re-open this for the purpose of providing a more useful error message.
 Removing ‚Äúgood first bug‚Äù because this code is being rewritten anyway.
Keeping this open to make sure we fix it in the new code.
  if `type` is a string we would never look at `type.prototype`, so something else must be going on. Can you make a repro case.
 @deminoth You shouldn't use `React.createFactory` with JSX, it should just be the plain class.
 Let's check to see if we can have a better warning for this.
 @spicyj, @deminoth's problem is not the one in the issue though (just making sure :))
 @Tvaroh Really? It's still not making any sense to me how a string would pass the function check though...
  See #3329. It's not calling getDOMNode, but it's using the property as a heuristic. Our warnings on ES6 classes are done via getters so just accessing the property (even without calling) results in the warning.
  @binarykitchen You can construct React elements dynamically and that's what you need to do here, you just can't do it with only string replacement.
 You can use the `split` function with a regex and then replace the captured parts, like so:

``` js
var parts = "I am a cow; cows say moo. MOOOOO.".split(/(\bmoo+\b)/gi);
for (var i = 1; i < parts.length; i += 2) {
  parts[i] = <span className="match" key={i}>{parts[i]}</span>;
}
return <div>{parts}</div>;
```

Let me know if that's unclear.
 Parsing JSX at runtime is error-prone and slow, and can easily have security implications ‚Äì it wouldn't inherently be any safer than dangerouslySetInnerHTML is.
  Sure ‚Äì thanks.
  lgtm otherwise, thank you!
 Thank you!
  @akshayp Sorry about that, #3384, you can apply it by hand if you're in a hurry :)
 1.0.1 of jsx_orphaned_brackets_transformer is published. Update and you should be good to go. Thanks for filing!
  I specifically noted this in the docs:

> Note also that we're relying on the JavaScript engine preserving object enumeration order here, which is not guaranteed by the spec but is implemented by all major browsers and VMs for objects with non-numeric keys.

For now we're planning to keep it as-is (and the React internals currently rely on this property as it allows faster performance than other options) but we'll keep your suggestion in mind for the future.
  cc @jeffmo ‚Äì know what's up?
 babel gives some helpful information when transforming the same code. It looks like you can't actually have the `var` there and if it worked before it was a bug.

```
SyntaxError: code.js: Unexpected token (1:15)
> 1 | export default var HelloMessage = React.createClass({
    |                ^
```

And actually testing this with react-tools@0.12 also gives a parse error (and mentions var being illegal there). `Error: Parse Error: Line 1: Unexpected token var`
 Ah, this is because previously esprima would parse all import/exports. But the spec has since been updated such that incorrect use of import/export is a parse error, so there was an option added to esprima, which we exposed on `jsx` as either `--es6module` or `--non-strict-es6module`. Either of these should actually work here.

See #3143 for some discussion. @jeffmo and I also talked outside of github and decided to make the default be that no options would be passed, meaning es6 modules wouldn't get parsed (why did we say that @jeffmo?). Now this _should_ work with the `--non-strict-es6module` option but I screwed that up, but that's tangential.
 For this particular issue, the answer is probably just to give the `--es6module` flag; Although beware that the old version of esprima was not spec compliant in that it did not enforce that modules are "use strict" by default. The new parser does (and this is one of two things the `--es6module` flag toggles).

@zpao: I think the two candidate options that make sense to be the default are either non-module or regular, spec-compliant module (they are the only two spec-compliant modes of the parser).

There is a 3rd mode of the parser called "non-strict-module" which is meant as a temporary mode for people who are transitioning existing commonjs modules to ES6 modules, but haven't had the chance to verify that their old CJS modules are strict-compatible yet. It would be a bad thing to turn this on by default because it would be too easy to build not-implicit-strict es6 modules with the expectation that they would work in a spec-compliant ES6 browser and forget that this is not the case (and things would break in a spec-compliant VM in very subtle ways).

I don't remember how we decided on which option to default to -- but I suppose it makes sense to choose whichever one aligns with "most people". I'd speculate that most people aren't using ES6 modules yet, but OTOH I wouldn't be opposed to encouraging a change in that momentum. Also the plan is for React and Flow to switch to ES6 modules in the near future anyway...so maybe it's time to rip off that band-aid? 

(No matter what though, it should always be the case that people can choose script vs module via a flag toggle)
 Yea, right now JSXTransformer has a limited set of options. We could perhaps parse everything out of there but not sure how much it's worth it (also, it's not a production code thing so supporting es6 modules there isn't a huge priority).

But going to close this out as we shipped 0.13.1 with a fix for the command line parsing.
  Which version are you seeing this with? I can't repro with 0.13 (using http://facebook.github.io/react/jsx-compiler.html to test, as well as `jsx` on the command line)
  @spicyj Sounds like a browser quark that we should normalize against, right?  Is there anything other than value that we would need to check?
 Yeah, this seems odd. Probably on the challenging side for a first bug, but it would be good to figure out why this is happening and how we can prevent it, while still making it possible to type the placeholder text in directly as @captray says.
 #2185, not really related but I imagine both could be solved by a similar fix.
  @vsiao is correct, your version of React is out of date.
 While we encourage you to upgrade, if you'd like to continue using 0.12, the docs for that version are available on github - https://github.com/facebook/react/blob/0.12-stable/docs/docs/tutorial.md
  We don't want these to be ES6 yet
 `createClass` is still more powerful. es6 classes are enabled but have limitations (as you know).

I think what I might actually want is to redo our presentation of all of these examples so we can show createClass and es6 classes side by side.
  Not all browsers or JS engines actually support ES6 class syntax yet. You will likely need to transform to ES5 for a while. React-tools does this, as does babel, and some other tools.
  Closing this as a duplicate of https://github.com/facebook/react/issues/654
  Putting all children-logic (`createContentMarkup`, `updateDOMChildren`, etc) behind the same check should make sense I think, no point in going through the children-logic if there cannot be children.

PS. Or do we not care in the name of simplicity? cc @zpao @spicyj 
 @syranide Well, maybe the proposed `if` check should be `if(props.children == null && props.dangerouslySetInnerHTML == null)`, since void elements don't have a monopoly on not having children.

@jonhester Thanks for fixing this one so quickly :).  Just note that, as per the conversation in https://github.com/facebook/react/issues/3367, we need to keep it a warning for the 0.14 release, so this probably won't be mergable until 0.15
 @jimfb That's tricky because you have to consider prev/next children as well and in a sense that's what the "children logic" is doing internally already, whereas void components will never have children so you can simply skip that part entirely with a single stateless check.

PS. What I'm proposing would be the equivalent of introducing a ReactDOMVoidComponent separate from ReactDOMComponent (except we don't because it's probably a little excessive and settle for a simple conditional instead).
 @syranide Ah, absolutely correct.  If such a check is added (to this commit or a future commit), @syranide's logic is correct, we can't just check for the current presence of children, but we could do a void-element check.  Probably wouldn't be blocking, but I'm a little curious what @zpao @spicyj would think about the performance vs. simplicity trade-off.

@jonhester Ok, awesome!  Glad to have you be a part of the community!  Let me know if there is anything we can do to help!
 @jonhester We're merging 0.15 stuff now.  As expected, there are a few merge conflicts.  Do you want to rebase and we can get this PR ready to be merged?
 @jonhester updated the pull request.
  I would recommend...

```
if (typeof objA !== 'object' || typeof objB !== 'object' || objA === null || objB === null) {
  return false;
}
```

...and remove `if (!objA || !objB) {`.
 Yeah, I could go either way on that one.  Having the null check logic in a separate `if` statement makes it easier to decide if you're taking a given branch (without jumping through mental hoops to decide what a more complicated expression is actually guaranteeing).  Also, with everything squished into a single if statement, it pushes it over 80 characters, so it would need to linewrap, so the number of lines is the same anyway.  Lastly, if we did push it all into one if statement, I think we'd want to use `== null` instead of `=== null` because we also want to catch undefined.

I can't actually decide which is better, they both have their advantages.  Either way, probably not severe enough to hold up this diff.
 @jsfb The reason I chose the above is because you only need to check for `null` is because `typeof null === 'object'`, there's no other reason to treat `null` as different from any other primitive value.
 @syranide Ah, true :).  Your solution would have worked :).  But the fact I didn't see that is further evidence that the exact semantics of the single expression are complicated.  If I were thinking about how undefined would propagate down, I would have gotten it wrong in the second version.

Both versions work.  I would have been perfectly happy with either version.
 @jsfb Yeah both work, I'm not arguing about one vs two `if`s, but rather that checking for falsy values seems flawed when we're only interested in separating `null` from `typeof null === 'object'`, nothing else.
  This seems kind of fragile. I think I'd be more inclined to hardcode a list of propType-generating functions and make sure that prop types aren't specified as any of those. That way, you also get it at class definition time instead of mount time (though of course that's impossible with ES6 classes and we do warnings on first mount anyway in that case).
 Yeah, hence my hesitancy.
  Simple fix: just use `Child` instead of `'Child'` ‚Äì you want to pass an actual reference to the JS variable:

http://jsfiddle.net/dhjxu5oL/1/
 @spicyj I don't think that's what he is asking.  I think he wants to be able to create a React element from a dynamically acquired name (string).

What he is looking for is:

```
React.createElement(ChildName, null)
```

instead of what he has (`<ChildName />`)
 `React.createElement(ChildName, null)` and `<ChildName />` are equivalent.
 @spicyj EDIT: You're correct.
 As you probably know, it's best practice not to use `eval` or look up globals on `window` by string name as it tends to make code hard to reason about, but you can use those patterns with React too:

```
var name = 'Component' + this.props.componentID;
var Component = window[name];  // or eval(name)
return <Component />;
```

The key is to use a capitalized variable name (`Component`) or else React will treat it as a built-in DOM element.
 Maybe you can do something like

```
var allMyComponents = {};

var Child = React.createClass(...);
allMyComponents['Child'] = Child;

// ...
var Component = allMyComponents[name];
```

which isn't a large overhead but is more reasonable than using globals. React tries to be simple and get out of your way instead of adding a lot of magic ‚Äì you can then build whatever you want on top, just as you can in JS without React.
 React doesn't have a global registry so that won't ever be built-in functionality.

You could have your own registry and just make sure each class registers in that, then you could access that inside `EmbeddableList`, then you can just use that. For example:

``` js
// DifferentListElement.js.jsx
var DifferentListElement = React.creaceClass({});
ReactComponentRegistry.set('DifferentListElement', DifferentListElement);

// EmbeddableList.js.jsx
var EmbeddableList = React.creaceClass({
  render() {
    var ListElement = ReactComponentRegistry.get(this.props.listElementClass)
    return <Whatever><ListElement>...
  }
});
```

This is essentially what Ben described above, but with a registry object. Either way it would require a different global object be available.

The other thing is that you may be setting `window.DifferentListElement` when creating the class because that's the default behavior of the asset pipeline. So when you're doing `eval(this.props.listElementClass)`, you could actually just write `window[this.props.listElementClass]` and would be a slightly less bad taste.

`React.createFactory` is only for when you aren't using JSX, and you still need the class object itself to pass in.
 What @syranide said. Then in render you can do:

``` js
// Needs to start with a capital letter
var Type = myComponentsList[this.props.componentId];
...
<Type />
```
  Thanks!
  > When people complain about this (#1484, #1663, #2764) it is usually suggested that they use value instead of defaultValue but this is often seen as unpractical in a form were there are many input fields since all fields now need an onChange listener to be editable.

They can all share the same onChange-listener so I don't see the issue, but yeah some people don't like to do that for some reason.

> Or is there an even better solution?

There are two approaches for updating uncontrolled inputs, neither is universally right:
1. Assign a ref and call `this.refs.myInput.getDOMNode().value = ...`. This "should" be used when the underlying value has changed and the input should be updated to reflect it.
2. Assign a key (mostly preferable to do it further up on a shared parent). This "should" be used when the input has changed "source", i.e. it's now referring to another unrelated value, like an input on a different tab. Assigning a key will completely destroy the previous input, along with focus, etc.

The second kind of applies to controlled components as well, but it's rarely something that really matters.

It may be more obvious if you think of it in-terms of traditional DOM interaction, either you update the value of an existing input. Or e.g. when switching tabs you destroy the DOM and render it again and thus the newly rendered inputs show the current value.
 `onChange={this.mySharedListener.bind('mykey')}`
 I think the official answer is to use controlled components.  There are other techniques, like using keys or the imperative DOM API, but these are escape hatches rather than officially endorsed solutions (documenting them beyond what's in the github issues would give them too much legitimacy).

The confusion about `defaultValue` was mostly solved in: https://github.com/facebook/react/pull/4379, which gives our official "reacty" answer.  There hasn't been much confusion/pressure since that PR merged, so I think we can close this issue.
  This adds `shallowCompare` and adds tests for PureRenderMixin.

This allows the following pattern:

``` js
class MyComponent extends React.Component {
  shouldComponentUpdate(nextProps, nextState) {
    if (!React.addons.shallowCompare(this, nextProps, nextState)) {
      return myCustomCheck(‚Ä¶);
    }
    return false;
 }
}
```

Not _super_ happy about this API. `Component.prototype.shouldComponentUpdate = React.addons.shallowCompare` seems like the better choice for the common case, but then using it would require calling `React.addons.shallowCompare.apply(this, arguments)`.
 @3den What happens when you want to be both a `PureComponent` and a `GraphqlComponent`?  You can't extend both.
 @3den Yes, that's called a "mixin".
 Also, sometimes copy-pasting a trivial three-line function can be a better solution than introducing abstraction and indirection. It makes it obvious where the method comes from, and easy to change its implementation if necessary later.
  - [x] make sure examples work (@zpao #3354)
- [x] docs
  - [x] `React.findDOMNode`
  - [x] `React.cloneElement` (@zpao #3363)
  - [x] `React.Component` (@sebmarkbage)
  - [x] ES6 class use
  - [x] Notes in component instance methods about what doesn't work in ES6 classes (@zpao)
  - [x] ~~Note in element.type~~ (no such documentation; mentioned change in blog; skipping)
  - [x] Update refs documentation for callback style (are we actually recommending this yet?) (@jsfb https://github.com/facebook/react/pull/3364)
  - [x] Update setState docs for function style(@jsfb)
  - [x] `React.addons.createFragment` (@spicyj #3353)
  - [x] `React.classSet` deprecation
  - [x] shallow testing (#2963)
- [ ] fb.me updates (@zpao)
  - [ ] http://fb.me/react-invariant-dangerously-set-inner-html ‚Üí http://facebook.github.io/react/tips/dangerously-set-inner-html.html
  - [x] ~~http://fb.me/react-legacyfactory~~
  - [x] ~~http://fb.me/react-context-by-parent~~
  - [x] ~~http://fb.me/react-warning-keys~~
  - [x] ~~http://fb.me/react-transferpropsto~~
  - [x] ~~http://fb.me/react-addons-classset~~
  - [x] ~~http://fb.me/react-jsx-lower-case~~
- [x] ship it (blog, npm, bower, etc) (@zpao)
- [ ] update react-tutorial (@zpao https://github.com/reactjs/react-tutorial/pull/40)
- [x] ship jsx upgrade tool (@zpao)
- [x] update react-source gem (@zpao)
- [x] update react-rails gem? (@zpao)
- [x] ship React ART 0.13 (@zpao https://github.com/reactjs/react-art/pull/43)
- [x] update readme, etc in master
- [x] update fiddles
 Nah, not going to block on that. We can fix it independently.
 RE: Update refs documentation for callback style

> are we actually recommending this yet?

Doesn't matter, we support it and talked about it in the changelog.

We can't have discussions inline in a text field, we don't get updates and I have no idea who asked. Ask them in comments.
 Sorry, me.
 @camspiers Ah, I'm assuming you mean the testing suite and not `React.addons.Perf` (there was a problem but we believe that's all in shape now). Correct me if I was wrong though!
 Apparently fb.me urls _can't_ be changed (well, not without bypassing some checks which I'm not sure are safe to bypass) so we'll skip that part for now. Not the end of the day, but my bad.
 Ok, calling this done. I'll followup on the tutorial
  Hmm, I'm ok with this in principal, but I'm not wild about putting DOM specific things into core like this. This definitely isn't the first thing but we're also trying to move in the direction where core is pure and reusable between web and react-native. @spicyj you've worked on both so you might have a better perspective on if this sort of change would set back that goal or if it's manageable. (also @sebmarkbage)
 We could use context for this:

``` diff
diff --git a/src/browser/ui/ReactDOMComponent.js b/src/browser/ui/ReactDOMComponent.js
index 4df78e8..7f4fd9e 100644
--- a/src/browser/ui/ReactDOMComponent.js
+++ b/src/browser/ui/ReactDOMComponent.js
@@ -301,7 +301,7 @@ ReactDOMComponent.Mixin = {
         var mountImages = this.mountChildren(
           childrenToUse,
           transaction,
-          context
+          assign({}, context, {svgTextChild: this._tag === 'text'})
         );
         ret = mountImages.join('');
       }
@@ -342,7 +342,11 @@ ReactDOMComponent.Mixin = {
   updateComponent: function(transaction, prevElement, nextElement, context) {
     assertValidProps(this, this._currentElement.props);
     this._updateDOMProperties(prevElement.props, transaction);
-    this._updateDOMChildren(prevElement.props, transaction, context);
+    this._updateDOMChildren(
+      prevElement.props,
+      transaction,
+      assign({}, context, {svgTextChild: this._tag === 'text'})
+    );
   },

   /**
diff --git a/src/browser/ui/ReactDOMTextComponent.js b/src/browser/ui/ReactDOMTextComponent.js
index d561646..46f8817 100644
--- a/src/browser/ui/ReactDOMTextComponent.js
+++ b/src/browser/ui/ReactDOMTextComponent.js
@@ -75,10 +75,12 @@ assign(ReactDOMTextComponent.prototype, {
       return escapedText;
     }

+    var tag = context.svgTextChild ? 'tspan' : 'span';
+
     return (
-      '<span ' + DOMPropertyOperations.createMarkupForID(rootID) + '>' +
+      '<' + tag + ' ' + DOMPropertyOperations.createMarkupForID(rootID) + '>' +
         escapedText +
-      '</span>'
+      '</' + tag + '>'
     );
   },
```

though we'd need to make the name not clash with user-defined context keys and change the code to be smarter about not copying. Works as a proof of concept though.
 Yeah, I ended up solving this a different way. Thanks for sending this in though ‚Äì though we didn't merge it, I appreciate the discussion and we may not have fixed this in 15.0 otherwise.
  cc @sebmarkbage - anything you want to do about this in the short-term?
 Basically, our thinking has been that this should be consistent with life cycle methods (which get `nextProps, nextState, nextContext` or `previousProps, previousState, previousContext` and also uses `this`) and how you do things in callbacks (which uses `this`).

We've been exploring ways of expressing callbacks in a way that they also receive `props, state, context` in the same way. We haven't landed on anything there yet though. Therefore the idea was to wait on something here until we know where we're heading with that API.

One design philosophy we have is that there generally shouldn't be two different ways to do the same thing in arbitrarily different ways. That creates bikeshedding and confusion.

I think the next thing we could do is allow constructors to return a `ReactElement`. This is the stateless function proposal in react-future. Perhaps this is a good start to encouraging pure functions.
 Closing for now.
  Can you make sure you sure fix all the lint errors (warnings are allowed but errors will cause travis to fail as you can see happening). You can test that locally with `grunt lint`
  It used to warn, right? Maybe not? `[[1, 2], [3, 4]].map((m) => m.map((n) => <div></div>))`
 ~~That does not become nested children, you're discarding the inner array...? :)~~
 Weird, looks like we never did this right.
  cc @sebmarkbage 
 @zpao, just in time for 0.13?
 Yea, fine. It's just Perf.
  I'm quite sure spread isn't the problem, but exactly what the error message says. It just so happens that it's this component that reveals the issue (it throws on update, not the initial broken render).
 What else is this component doing? As @syranide said, this doesn't seem like it's spread that's causing the problem.

Also FYI, you have `classnames` being a function and a string... check that.
  cc @zpao 
  cc @sebmarkbage 
 This doesn't have anything to do with `img` specifically, but does happen for our faked DOM components (reprod with input). It also has nothing to do with using the return value, just running `renderToStaticMarkup` makes it happen.

I'm guessing we're screwing up something with currentOwner somewhere along the line.
 Your render function is not returning a valid value.  You need to return a ReactElement or `null` for no value.  If you add `return null;` to render method of your new example, the error goes away.
 The new test case seems wrong (as @jsfb says, it doesn't repro the bug) but the original one is solid.
 Yea, the invariant you're seeing there is different. But let's not get hung up too much on the specific example... the `ref` part of this is the important thing. Returning something with a ref in conjunction with rendering specific things to a string breaks. Add the return of a div with a ref in that example and the error is still there.
 I agree with @zpao 

Simplified example slightly to avoid any confusion about any interaction between renderToStaticMarkup and the return value.

```
var Bug = React.createClass({
    render: function() {
        React.renderToStaticMarkup(React.DOM.img());
        return React.DOM.img({ ref: 'ref2' }, null);
    }
});
Bug = React.createFactory(Bug);

React.render(Bug(), document.body);
```

renderToStaticMarkup is clearly mutating something in the internals.
 `renderToStaticMarkup` can have side-effects other than just mutating the owner stack. Components that are instantiated also have life-cycle hooks (constructors, getInitialState and componentWillMount) which may cause side-effects.

The `render` method is pure and may not cause any side-effects. We should throw the same invariant we do for `setState` and a bunch of other methods, while you're in a render. This would be a much nicer error message.

The workaround is to `renderToStaticMarkup` in one of the life-cycles that are allowed to have side-effects. Such as `componentWillUpdate` and store the result so that it can be used inside `render`.
 The fix here is to disable this use case.
 My gut says that that's lazy. I think we should actually look into `renderToStaticMarkup` and `renderToString` and see if we can make those behave better. Short-term‚Ä¶ fine, a friendly error message is better than this. But why should generating a string of markup be considered a side effect? (instantiating anything or calling any function can have side effects, so I don't really buy that excuse)
 Another possible solution would be to disable componentWillMount for server-rendering and don't allow side-effects in constructors/getInitialState. Therefore making renderToStaticMarkup pure.
 The contract of a Component is that it is allowed to trigger side-effects or do mutations in life-cycle methods. We need to ensure which API boundaries are side-effectful and not. Just because your component happens to not have a side-effect now, doesn't mean it won't later.

``` javascript
var Component = React.createClass({
  componentWillMount: function() {
    triggerSideEffect();
  }
});
```

Regardless, I think that we'll probably go the opposite route and make `renderToStaticMarkup` asynchronous so that components can resolve dependencies before fully completing. In that case it'd definitely be a side-effect and it still wouldn't make sense to put it in render. (We most likely won't make render() itself async.)
 My instinct is that @zpao is correct; generating a string of markup shouldn't automatically be assumed to be side-effectful.  If your components are a pure function of props (which is the most ideal design), than calling this shouldn't be a problem.  If you're using janky components that side-load data, well, at use at your own peril.

Rendering another component is no different from calling into another library.  It's the caller's responsibility to ensure that the invocation is side-effect free.  We can warn if we know the invocation is has side effects, but we shouldn't block someone from rendering to string if they know their components are all well-behaved.
 I would be happy to take a PR that sets `ReactOwner.current` back to its old value in all the places we mutate it.
  Thanks!
  React will re-render a component when that component's setState method is called.  If you are manually mutating the data, there is no way for React to know the data has changed and thus no way to re-render.  Calling setState or forceUpdate are both appropriate ways of notifying a component of a data change.

For future reference, questions like this are better asked on StackOverflow.  Closing issue, since it's not a "bug in react".  Feel free to continue the conversation here or take the issue to StackOverflow.
  @jquense looks like a bug.  Your example can be cleaned up a bit (for example, your passing of `children` and `props` to `Modal` is superfluous and makes it more difficult to fully understand what's going on there).

@sebmarkbage The issue is more readily demonstrated using the deprecated `withContext` function.  See my demo: http://jsfiddle.net/Lbdwo477/ (should render "bar" instead of "foo").

@sebmarkbage Under the new parent-based context (to be enabled in 0.14), how do we expect `React.render` to behave?  Should it inherit the current context, or use the context that is effective at that position in the DOM (eg. someone renders into a leaf node of a React component after mounting).
 Yeah, my intuition is that it should inherit the context from the DOM.  If a user wants to explicitly pass a new context, they should create a wrapper component that provides the context variables (potentially received as props) and pass that wrapper component into `React.render`, thus maintaining the parent-based propagation of variables.

@jquense Owner is not necessarily a subset of Parent.  Parent and Owner can (in theory) be independent, though the owner is **usually** a parent.  We warn in cases where context variables are used and the owner's provided value does not match the parent's provided value.  That should be rare.
 We do want some way to pass the context down. See "#3210 Nested Render Trees".
 This was fixed in 0.13. https://github.com/facebook/react/commit/ed7332c74921874cdcb3cce629bb5bd8c95a7968#diff-c818825b9093d7a157d104790f972ff2R304
  cc @zpao 
  Change it to only add the element to body when the modal is going to be shown, also, why is `this._renderLayer()` called in `componentDidMount`? That seems really weird and slow.

**EDIT:** Perhaps I'm misremembering how these work... anyway, this seems like an issue with the Mixin, not React.
  Thanks!
  I was gonna just add a comment, but we may as well add a full-blown warning.
 Hm, my test passes in jest but fails in grunt test.
 Fix travis and then ship it?
 @sebmarkbage Fixed Travis.
 Couldn't rebase this to have it work at a first attempt. Maybe we work properly on this now? Not sure.
 0.14 also has a few other improvements that should make having multiple copies of React no longer a problem in some cases so hopefully people stop running into these problems.

@JedWatson Thank you.
  This should make debugging easier for people who missed callsites when fixing up their JSX/non-JSX usage.
 What does the error that gets thrown look like?
 ![image](https://cloud.githubusercontent.com/assets/6820/6517057/2453da4e-c34c-11e4-90ca-541bc4b3f6d6.png)

"undefined is not a function", or "inst.render is not a function" if you're lucky. Since we assign props/state/context on the next line and _reactInternalInstance later though, it's confusing because the array looks half like it's some React thing whereas really it's not.
  This is unfortunate. I don't quite know what the right heuristic should be for 0.13, but we're changing it for 0.14 anyway since refs on DOM component will just be regular DOM nodes so I think we'll just power through. :/
 Maybe we can do `typeof ReactInstanceMap.get(this)._currentElement.type === 'string'`?
 I was thinking that we can reuse string types for ART and React Native too. We wouldn't want a React Native node to hit this.
 `inst.hasOwnProperty('getDOMNode')` maybe then?
 It is not an own property. (And will be deprecated anyway so not a great heuristic.)
 Lets just move fast on the ref === real DOM node stuff instead of spending time figuring this out.
  @darcyadams updated the pull request.
 Thank you for the PR, and sorry about the long wait. Now that #5714 is merged, all attributes on SVG elements will be passed through as is, with no need for the whitelist. I'm closing this but please let me know if you have any troubles in master.
  I assume you've seen this document on how we do inline styles: http://facebook.github.io/react/tips/inline-styles.html

Our styles behave same as browser styles.  We do not yet have a solution as clean as the shadow DOM for style encapsulation, but the web has existed for many years without shadow DOM, so it is certainly possible to design websites using the browser's native style rules :).

One thing that you could do is define a style reset class, which resets the styles to their default, and then you can override the defaults with more specific selectors.

Alternatively, you could create a base inline-style object that has all your default styles, import that object everywhere, and when you want to apply a specific style, you copy that object and override the styles you want to set using `Object.assign`.  If you want to get really fancy, you could have your components do the style merging (with the style-reset-object you create) automatically, so your webdevs can just use the components without seeing the style-reset code.

That's my two cents.  cc @spicyj 

PS: Since this is more of a usage question rather than a bug in React, I'm going to go ahead and close the issue.  Feel free to continue the conversation in this thread (closing the issue mostly just takes it off our radar for dev purposes).  An ideal place for questions like this would be StackOverflow.
 I tend to recommend using BEM-esque class names that are globally unique, usually scoped by component name:

``` js
var MyComponent = React.createClass({
  render: function() {
    return (
      <div className="MyComponent">
        <button className="MyComponent__button">Hi!</button>
      </div>
    );
  }
});
```

and then in your CSS, try to avoid using descendant selectors, in favor of single class names. This tends to promote style isolation and separation of components ‚Äì it makes it easier to compose components without the styles falling apart.
  Looks good.  Two minor changes.
1.  We should use the warning module instead of console.debug.  For example usage, you can search our code base for 'warning' (https://github.com/facebook/react/search?utf8=%E2%9C%93&q=warning).  The warning module takes in two arguments (the invariant condition and the message to display).
2.  We should wrap the call to warning in a `if(__DEV__)` block, as we do elsewhere in the code base (see same link).
 Great, looks good to me!  @spicyj, any feedback?

We are in a code freeze for the next week-ish, so we'll prep this for merge once the code freeze ends.
  It's not super obvious but there is a repo for the devtools - https://github.com/facebook/react-devtools

Can you file this over there?
  lgtm, reducing cognitive load by eliminating useless variables.
  Seems odd‚Ä¶ cc @spicyj @sebmarkbage 
  @zpao This went to gh-pages instead of master, just wanted to confirm that this isn't going to be an issue / will be in latest master after the 0.13 release.  Let me know if there is anything I need to be doing here.
 I fixed it in the right place already. bda845cf4ce59efd1b2e5205bcd0aab3e5653f43
  I have no idea what swiper is doing but it seems like it's probably mutating the dom. When that happens things can go wrong with React. My best guess here is that for the asynchronous case you actually need to tell swiper you added more photos - there are lifecycle hooks for that.

There isn't much actionable for us here, this isn't a bug with React. I suggest talking with their developers or asking this question in another place, maybe stack overflow of the mailing list.
  I like this PR, especially since it is predominantly adding unit tests.  I'm going to mark it as accepted, but pinging @spicyj just in case I missed something (the semantics of javascript falsey expressions are subtle).  We are in a code-freeze for the 0.13 release, so ETA for a merge is a week-ish.
 This seems weird to me I think, why do we want this behavior?
 @syranide Why not?
 @syranide returning false (if one object is null and the other is not) seems more correct than throwing an unexpected exception.
 @jsfb Ok, after reading it a bit more I'm kind of OK with it, but it's not super obvious, I'd say it could make more sense to make it `objA == null || objB == null` for clarity? `shallowEqual(1, 2) === true`. `props` and `state` can indeed be non-objects too, although perhaps that is being restricted.
  Is this with PureRenderMixin?
 It is potentially worth noting that getInitialState is likely to become required for stateful components in the near future.  See https://github.com/facebook/react/issues/3236#issuecomment-76456970

It is already the case that any component calling `setState()` should ideally be specifying a `getInitialState()`.
  A style like this is already being considered.  See react-future's `observe` function (https://github.com/reactjs/react-future/blob/2534efc1e731fe46a87e5bdc71bb549e56360409/09%20-%20Reduce%20State/01%20-%20Declarative%20Component%20Module.js)

There are a couple of considerations:  This would increase the API surface (and thus learning curve) for React, so we need to be sure this pattern is common enough to justify the additional weight.  We also need to decide if this pattern is a legitimate/recommended design pattern (there are questions around this, since you are effectively side-loading data when data should probably be passed down as props from your parent).

Anyway, this is being tracked in React-future (still needs more baking), so I'm going to close it out here.
  Good catch.  An explosion within a component should not cause the React core to die.  cc @sebmarkbage 
 This is effectively a duplicate of #2461

Throwing during the render phase leaves React in a broken state and we're unable to recover. We need to do some major refactoring and introduce better regressions tests to support this. Will close this out and leave it to #2461
  Sorry!
  Looks good to me.

I don't have a strong preference, but if console doesn't exist, I'd almost be tempted to throw instead of swallow, since warnings are analogous to errors (I think we're switching to console.err at some point).  That said, frontend engineers seem to prefer sweeping errors under the rug.  @sebmarkbage: throw or swallow if console doesn't exist?
 Yeah, we require a console polyfill (only with the dev build) on browsers that don't support it, as @MattKunze says. Let me know if that can't work for you for some reason.
 Are we sure that we don't fire the warning module in the prod build?
 Presumably you primarily test things in another browser anyway so you get the warnings there. We'll probably add an in-document warning later. The argument that IE9 doesn't need any other polyfills seems reasonable to me. We also converted all the direct callers and use the warning module instead.
  If @radubrehar is using shouldComponentUpdate correctly, he shouldn't be constructing a substantial number of descriptors for vdom diffing, right?  cc @sebmarkbage 

cc @jordwalke sounds like a situation similar to your react-native situation where you wanted to tunnel updates, right?
 @jsfb you're still creating the elements before you go into the existing ones to run `shouldComponentUpdate` (we need to know if there's an update or if there's a replace/remove). So you need to create 1000 elements to know that you aren't updating any of them :/

One of the things we've been working hard towards is the elimination of the need for calling createElement if it can be optimized away. That and a couple other ideas for optimizations are being discussed in #3228, #3227, #3226

What @jeffchan said should work, though it can get a bit unwieldy. Anther option is to start windowing. You may not actually need 1000 elements to be rendered if 900 of them aren't actually visible. This is also a fair amount of work (you have to start tracking scrolling and sizes) but definitely doable. We did that with [fixed data table](http://facebook.github.io/fixed-data-table/).
  Duplicate of #1740 I think?
 (Closing in favor of #1740.)
  That is true in 0.12, however we're loosening that in 0.13 (it won't throw anymore but it'll be a no-op). So I'm going to say we should just leave it so we don't immediately delete it :) Thanks though!
   @matthewjohnston4 can you include babel-sublime and ping me when it's done so that I can merge it in?
 2 things.
1. Can we get a mention of [react-meteor](https://github.com/reactjs/react-meteor) in here? It was updated recently. [React.NET](https://github.com/reactjs/React.NET) also had a release yesterday.
2. Can we hold off on publishing this until tomorrow? I have an RC2 blog post I want to get up today.
 @zpao maybe you can mention React.net as part of the RC2 announcement
  Seems like this is a common use case for `replaceState` which we would like to deprecate. #3236 

Not quite sure how this would work with Records and mixins since they're fixed type.

cc @leebyron 
 Seems like the core incongruence is between using stateful mixins and having control of your component's state. Using stateful mixins means giving up some of this control to your mixins.

The practice of using replaceState() alongside Immutable.js came with the caveat that you couldn't use stateful mixins.

I see a few ways out of this:
1. mixins are barred access to setState, they cannot be stateful. This is possibly an unfortunate limitation.
2. mixins have their own state, distinct from the component they're mixed into. This makes them even more "special" than they already are (which is a bit more special than just a bunch of methods to be mixed into a class prototype). This would encourage data isolation between different mixins and between mixins and components, so each maintains control. This adds weight to the React abstraction, also unfortunate.
3. Add some duck-type interface for state to allow overriding the state "merge" strategy. Here's a very very rough example of what this could look like:

``` js
function merge<T>(prevState: T, stateDeltaObj: Object): T {
  var mergeStrategy = prevState['@@reactMergeStrategy'];
  if (mergeStrategy) {
    return mergeStrategy.call(prevState, stateDeltaObj);
  }
  return Object.assign({}, prevState, stateDeltaObj);
}
```

This would allow for initial state to be any kind of object that supports this interface, and we could keep using the existing setState API.

---

I'm actually leaning in favor of option 1 here, thinking that perhaps stateful mixins would be better off as wrapping components. Component composition could provide the functionality that stateful mixins can be used for today. I'm leaning in favor of this because it's the only option of the three that actually simplifies rather that adds complexity to React.

In the case that we go with option 1, I would propose also adding an API that's parallel to setState(), perhaps called updateState() which always takes a function and that function always returns an entirely new state object. This kind of API would put the most amount of control back in the hands of developers using React.

This would allow you to turn code that looks like this:

``` js
class ClickCounter extends React.Component {
  getInitialState() {
    return { 
      data: Immutable.Map({ count: 5 }) 
    };
  }

  updateCount() {
    this.setState(prev => ({ data: prev.data.update('count', d => d + 1) }));
  }

  render() {
    return <div onClick={this.updateCount}>{this.state.data.get('count')}</div>;
  }
}
```

Into code that looks like this, one layer of indirection removed from state access.

``` js
class ClickCounter extends React.Component {
  getInitialState() {
    return Immutable.Map({ count: 5 });
  }

  updateCount() {
    this.updateState(prev => prev.update('count', d => d + 1));
  }

  render() {
    return <div onClick={this.updateCount}>{this.state.get('count')}</div>;
  }
}
```
 The concern with having two different update functions was that we were hoping to go into the direction where state is always updated through returning values.

https://github.com/reactjs/react-future/blob/master/07%20-%20Returning%20State/02%20-%20Module%20Pattern.js#L17

I'm not sure that direction is still to be considered "the current thinking" though.

This proposal also seems half-way to me. If you're using Immutable.js in this way, it seems like what you really want is an Om-like cursor like:

``` js
this.state.update('count', d => d + 1);
// or
this.updateState('count', d => d + 1);
```

Why call an "update" twice? I feel like this is a case where pluggability leads to worse results for everyone and a more opinionated solution is preferable.
 There are a few differences going on here:

1) Immutability. Not really relevant.
2) The update helper is attached to the object itself.
3) Map vs. Record that contains a Map.

You could imagine a mutable Map instead of a Record so that concern exists for both.

``` js
this.state.data.set('key', value);
```

is longer than

``` js
this.state.set('key', value);
```

So it seems to me that the issue here is the convenience of using the updater. If the top level object was an Immutable.Record which was auto-merged, you could do:

``` js
this.setState(this.state.updateIn(['data', 'key'], value)));
```
  As if I needed another reason to dislike font-smoothing‚Ä¶
 Good work @petehunt, you forced us to file a bug and get this fixed "upstream". Firefox is going to change it to `MozOsxFontSmoothing` because there's actually a spec they didn't follow.
 So what is our thinking at this point?  Do we abandon the PR and say "meh, bug in firefox 25-(fixversion-1)), no one was using that css style anyway" or do we add more complicated logic and potentially some css property detection code?
 Closed as per https://github.com/facebook/react/pull/3306#issuecomment-78328600.  If anyone really cares and wants to submit a PR, I bet it would be considered.
 @lourd there's nothing to get fixed. Firefox now supports the correct property (`MozMacOsxFontSmoothing`) as of v39.
  @richfisher Unable to reproduce on our roadhouse environment.  See attached screenshot of your first example.  The environment isn't an exact match (didn't use browserify), but it is still Windows 7 64bit (SP1), IE8 32bit, so it should pretty damn close.

Anyway, without a repro, there isn't much we can do from our end.  I have pasted my source code below, so you can play with it and see if you get the same results.  If you can post your (prebuilt) failure case online somewhere, I'll fire up the test environment again and see if we can determine the root cause.  On your end, it would be good if you can try my example code to determine if this is a React+browser compatibility issue or an issue with browserify.

index.html:

```
<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Document</title>
  <script src="https://raw.githubusercontent.com/es-shims/es5-shim/master/es5-shim.min.js"></script>
  <script src="https://raw.githubusercontent.com/es-shims/es5-shim/master/es5-sham.min.js"></script>
  <script src="https://raw.githubusercontent.com/paulmillr/console-polyfill/master/index.js"></script>
  <script src="http://fb.me/react-0.12.2.js"></script>
</head>
<body>
  <div id="main">
    <!-- Flux goes here -->
  </div>
  <script src="js/index.js"></script>
</body>
</html>
```

js/index.js:

```
var CommentBox = React.createClass({displayName: "CommentBox",
  getInitialState: function() {
    return {tasks: []};
  },
  componentDidMount : function() {
    this.setState({tasks: [{'name': 'n1', 'val': 1}, {'name': 'n2', 'val': 2}, {'name': 'n3', 'val': 3}]});
  },
  render: function() {
    var taskNodes = this.state.tasks.map(function (task) {
      return (
        React.createElement("p", null, 
          React.createElement("b", null, task.name), 

          React.createElement("br", null), 

          React.createElement("b", null, task.val)
        )
      )
    })

    return (
      React.createElement("div", null, 
        "Test", 
        taskNodes
      )
    );
  }
});

React.render(
  React.createElement(CommentBox, null),
  document.body
);
```

![ie8](https://cloud.githubusercontent.com/assets/9595985/6473571/1cdfa71e-c1af-11e4-9ba3-336027c702cd.png)
 @richfisher I checked out your repository on my roadhouse machine, and was still unable to reproduce.  Based on your screenshot, it looks like your system language is non-english.  It is conceivable that the language preferences are causing the browser/html/dom to render differently; can you try testing with the language preferences set to english and see if you get the same error?

At this point, I'm at a loss to reproduce.  I'm running your repository with the exact same browser version.  The web world sucks.

Do you have any plugins/modules/extensions installed?  Can you try testing in the english language?  Are there any other environmental factors that might be different on your machine?

@zpao ideas?
 @richfisher I created a pull request for you.  Please merge pull request, test again, and take a screenshot of the alert message.  That might provide at least a little insight into the issue.
 Alright, I can repro when I set the Browser mode to "IE8 Compat View" mode, which also sets the Document Mode to IE7 standards. When this happens all bets are off. You're effectively using IE7 at that point, which we don't support.

Compat View shouldn't be the default but‚Ä¶ apparently IE8 will run in Compat View by default when testing locally, which is ‚Ä¶ crazy. [This thread on stack overflow](http://stackoverflow.com/questions/13858491/ie8-automatically-uses-the-ie8-compat-view-browser-mode-and-ie7-standards-do) talks about it and some ways around it.

If you open the F12 tools and confirm what mode you're running it, I _think_ you'll see the mode is incorrect. I'll hold off on closing this but that's my guess.
 No problem!
  What version of React are you using?  Your `data-reactid`s look a little janky to me, so my guess is you're using an out-of-date version?

When rendering to a string, React generates the full markup string (including a `data-reactid` to uniquely identify the render root), and calculates the adler32 checksum of that string, and then appends the checksum to the root element.  The client can do the same, and compare the two checksums - they should match.  This is arguably a bug (but maybe a low priority one) because the `data-reactid` doesn't technically need to match in order for the markup to be compatible.

You are rendering twice, thus two different render roots.  Your issue comes from the fact that each render roots have a unique `data-reactid`, and since the checksum is calculated across the markup string, this effectively means that each call to renderToString has a unique checksum.  As long as your render roots have matching `data-reactid`s, their checksums should match too.

I'm going to close this out as not-a-bug, since this is expected/known behavior.  At some point, it may make sense to have the checksum calculated without considering the root's `data-reactid` but this could have performance considerations (our current checksum implementation is super fast/simple), and so such a change is not on our roadmap.

cc @sebmarkbage for situational awareness.
 Interesting.  Ok, apparently our `data-reactid`s are now generated in a way other than incrementing from zero (we used to just increment an integer).  Good to know.  The rest of the answer still applies.
 [We _do_ increment from zero when rendering on the client.](https://github.com/facebook/react/blob/master/src/browser/ClientReactRootIndex.js)

[We generate a random number on the server.](https://github.com/facebook/react/blob/master/src/browser/server/ServerReactRootIndex.js)

The idea behind this is that on the client there is a single React and we know everything (though that has proven to be a source of problems when there are multiple Reacts). On the server we don't know about everything nor how it will be generated (you could imagine 2 parallel processes generating a page) so we can't start at 0 and increment, you'll get clashing keys very quickly. So we use random numbers. There's still a small chance of collision but it's probably fine for now.
 @zpao Why do the algorithms differ?  Why not always use random?
 More predictable behavior perhaps. Adding 1 is faster than Math.random() and you can be much more certain that you won't have collisions. In general autoinc a known unique int is fast and cheap and guaranteed unique (to 9007199254740991: 2^53 - 1). An algo with the same guarantees is expensive and takes up more space (GUIDs are nice but also have 31 chars, sticking that in each DOM node sucks). Another (bad) option would be to always use Date.now() but at microsecond precision you're pretty much guaranteed to collide.

I don't remember if there's much more to it honestly. cc @petehunt @syranide
 @zpao Yeah, the only two reasons I can think of for not always using random are overhead and collisions (however unlikely).

Ultimately I want to get rid of `data-reactid` on DOM nodes though, but it needs some more core refactoring before that can happen "neatly".
 I was going to say that I'd like to see us choose a single algorithm, but I like @syranide's idea even better.
 @jsfb For posterity; #1570. It's very much possible to do today, but there are some bugs/missing things in core which prevents doing it for "for real". It's also easy to just reconstruct reactid's for pre-rendered markup.
  Unmounting during a React event is not currently supported AFAIK.
 Unmounting as the result of a event sounds like a perfectly reasonable thing to want to do; I think we should try to support this.

@slorber can you create a simple jsfiddle that demonstrates the issue?
 Awesome, thanks!

Issue is related to mutating nodes synchronously within an event loop.  We may want to make unmount take effect at the end of the event loop.  I think this demonstrates the more general problem of how to handle these top-level functions from within an event loop.
 This now throws with v15 (http://jsfiddle.net/wevohwfp/1/):

> Invariant Violation: React DOM tree root should always have a node reference.

I'll note that this does work if you unmount a subtree but apparently not if you unmount the whole root ‚Äì because unmounting is batched differently from updates.
  How are you rendering this component?
 @gsklee Can you provide a jsfiddle that demonstrates the issue?
 Yes, references make this tricky. As for updating Flux docs, that's a good idea to bring up in that repo. I'm going to close this out here though.
  Yea, we know about this one. See #3066 for more info.
  üëçthanks!
  I've noticed that there's no way to access a class' statics through one of its instances.
When trying to find a `statics` method inside an instance method, `this` does not contain the method. `this.statics` exists, but is `null`.

This is something I think could be a bit useful. This is a behavior that exists in Java and other similar languages.

A description of my use-case: I am using [React DnD](https://github.com/gaearon/react-dnd), and trying to slightly generalize duplicate code.
By using this library/mixin, you need to define a static method, which calls a `register` method and passes a constant value. I would like that value to be defined on the class.

By adding the following bit of code:

``` js
statics: {
  getConst: function() {
    return 'const';
  },
  configureDragDrop: function(register) {
    register(this.getConst(), ...);
  }
}
```

However, in my `render` method, I need to access the same constant again:

``` jsx
return (
  <li className={classes} {...this.dragSourceFor('const')} />
);
```

At this point, `this` does not have `getConst` defined, and `this.statics` is a null object.
 That's true, but then I have to explicitly call it by `MyComponent.someMethod()`, rather than `this.someMethod()` or `this.statics.someMethod()`, which could potentially enable better code reuse.
 You should be able to do `this.constructor.someMethod()` to access statics.
  Thanks!
  Really? Please don't waste our time making PRs like this.
  (To be clear, this would be about changing checks like `if (element._store.validated || element.key != null)` in ReactElementValidator to not assume that `element._store` exists.)

@sebmarkbage This one's for you. :)
 #3228 sounds very much related (but again, lack of warnings is an issue)
 Note that `createElement` is responsible for both key AND propTypes warnings as of 0.13.

@ariabuckles The way I've been thinking about this problem is that this should definitely be possible to inline objects in your code. #3228 would only enable this as a production mode compiler feature. However, it should ONLY be ok in the case that you have some other way of providing valid warnings.

I don't think that simply opt-ing out of these warnings completely is a viable strategy. You might think that you won't mess up propTypes or keys as you're manually inlining these. Even if you don't, you might be accepting children or props from the outside that does need to be validated.

You might think that these warnings are coddling developers and that we should just allow you to opt out. However, this undermines the stability of shared components in a larger community - which ultimately will cause people to blame React.

One idea was to use a static type system like Flow. If you use a static type system, your files can be statically verified, and therefore you shouldn't need to validate them dynamically, even in development mode. I'm not sure how to accommodate this and transfer the verification flag. Perhaps using a special transform which adds the `_store`.

Can you explain a bit more about your use case (even if it is sketchy)? It might help us come up with ideas for how to solve your special case without losing warnings for the common case.
 It is definitely a goal to decouple the ReactElements from React itself. The idea is that a transpiler can have its own `React.createElement` implementation so that you don't need to have React in scope to generate these elements. Any such implementation would need to have both `DEV` and production mode I guess.

Another possibility is that we could start using WeakMap for `_store` as the element gets passed through.
 @STRML IIRC that is only seen when using the inline elements transform and the dev build of React. cc @spicyj 
 I had meant to fix that check but I guess I missed it. But yes, you should use the prod build of React when using the inlined elements.
  Lots of updates! Wooooo!

I had to do some mapping so I'd like to get confirmation from people about what they would like for their name/email.
- [x] @ianobermiller - you have 2 emails in there now, I changed to use the personal one.
- [x] @amykyta - You commit(s) didn't have your name, so I used the one on your GitHub profile
- [x] @jeffmo - you have a million email addresses now, still pointing at anafx one, but can change.
- [x] @graue - ditto
- [x] @steveluscher - ditto
- [ ] @kikyous - let me know if you would like a different name in there than "chen"
- [x] @chicoxyzzy - I pulled your name from your profile, let me know if you'd like something else
- [x] @Pouja - I pulled your name from your email address, let me know if that's ok
- [ ] @brafdlog - Let me know if you'd like a real name in there
 Steven Luscher <react@steveluscher.com>
 The oceanbase one is fine for me. What's .mailmap?
 The .mailmap gets automatically used by `git shortlog`, which is what we use to generate the AUTHORS file (https://github.com/facebook/react/blob/master/scripts/authors)
 Alright, calling it. We can do any other updates later.
  > Offcourse you can do all things with simple composition in Javascript.

I mean that React in particular provides a very good composition model. Instead of

``` js
class Button extends Component {
  getColor() {
    return this.props.color;
  }
  render() {
    return <div style={{ color: this.getColor() }}>{this.props.children}</div>;
  }
}

class LightButton extends Button {
  getColor() {
    return lighten(super.getColor(), 0.2);
  }
}
```

You can write

``` js
class Button extends Component {
  render() {
    return <div style={{ color: this.props.color }}>{this.props.children}</div>;
  }
}

class LightButton extends Component {
  render() {
    return <Button color={lighten(this.props.color, 0.2)}>{this.props.children}</Button>;
  }
}
```

This is why we don‚Äôt encourage inheritance in components.

I‚Äôm closing as we are unlikely to add special conveniences to make inheritance easier, as it is an anti-pattern with a good migration way I described above.

Please let me know if there is something that inheritance gives you but composition doesn‚Äôt. I‚Äôd love know more about why you chose to use inheritance for React components instead. Thanks!
  Why not `setup(props)`?
 The React team has been watching the issue, and we do discuss it internally.  In principal, I always lean toward eliminating API surface area, so I find myself leaning toward @me-andre's arguments.  However, our team sometimes affectionately refers to `componentDidReceiveProps` as "the missing lifecycle method", and there are serious discussions about potentially adding it.  The important thing is that we enable best practices without catalyzing bad practices.

What would be most useful for us (or at least me) is to have a solid understanding of WHY people want this lifecycle method.  What are you trying to do in this lifecycle that isn't sufficiently covered by the other lifecycle methods?  Why would someone want to do `UserActions.load(id);` within `componentDidReceiveProps` instead of within render as suggested in https://github.com/facebook/react/issues/3279#issuecomment-163875454 (I can think of a reason, but I'm curious what your reasons are)?  Are there any use cases other than initiating a data-load based on props?
 @shea256 Can you elaborate on why `componentWillReceiveProps` does not serve your needs?
 @shea256 Also, why does your component need to make an HTTP request?  What does that http request contain?  If data, why aren't you updating your component asynchronously when the data callback returns?
 @grassick wrote:

> The common case for me is when we have to load something asynchronously in response to a prop change, which involves setting some state to indicate that loading is happening and then when the data is loaded, setting that state.

@grassick wrote:

> render doesn't have info on whether it's a new prop, and anyway, setState from render is a no-no.

Just spitballing here:  If `componentDidUpdate` got invoked on initial render (in addition to subsequent renders), would that solve your use case?  You could check if props changed and do all your data loading in `componentDidUpdate`, right?   And in render, you would know you were loading data if `this.state.profileName != this.props.profileName`.  Would that alternative be sufficient for your use cases?

---

Are there any use cases that people have which do NOT involve components loading data based on props?
 @me-andre It's probably worth toning down your language a bit, as it can come across as a bit confrontational even though you're just trying to help.  We want to create a welcoming community for everyone; we were all newbies at one point.  Even though you are correct about some of your points on the API/design, the very fact that so many people are +1'ing the issue is an indication that something is amiss, so we should try to understand what/why people want this lifecycle.  Maybe the problem is that we're not sufficiently communicating how to properly write components (documentation), or maybe React's API needs a change - either way, it's worth understanding the complaints/questions/comments here.

@shea256 `this.state.profileName != this.props.profileName` is checking to see if the internal state (what the component is rendering) matches what the parent is asking the component to render.  This is almost the definition of "component is updating" or "component is up-to-date", so I don't see it as hacky.  At least, no more hacky than the idea of "fire a data-update request when the prop changes and do a setstate in the callback" is in the first place.

@shea256 To be clear: this proposed lifecycle wouldn't enable you to do anything that you couldn't already do today with the current lifecycles.  It would merely make it potentially more convenient.  As others have mentioned, what you are trying to do is possible with the current lifecycles (there are multiple combinations of lifecycles that would allow you to achieve your goal).  If you're trying to "make it work", then StackOverflow would be a better place to discuss.  This github issue is attempting to understand the need for `componentDidReceiveProps` as it relates to developer ergonomics.

## 

> And who told you componentDidReceiveProps would guarantee the props have been changed?

@me-andre is correct here.  Most of the lifecycle methods don't actually guarantee that something has changed; they only indicate that something _might_ have changed.  For this reason, you always need to check if `previous === next` if you are going to do something like make an http request.  A bunch of people in this thread seem to be making the assumption that their value has changed merely because the lifecycle method fired.

## 

@me-andre wrote:

> You're trying to solve the problem of applying classic imperative approach to a functional-oriented framework.

I think this might be the root cause of people wanting this new lifecycle method, but I'm still trying to figure out why/how people want to use this method.  It's entirely possible that the current lifecycle semantics are slightly miss-aligned with what people commonly want to do.
 All: Are there any use cases for `componentDidReceiveProps` other than "loading data asynchronously in response to a prop change"?

cc @grassick @iammerrick
 @akinnee-gl et al: If componentDidUpdate got fired after initial mount in addition to updates, would that solve your use case?
 @akinnee-gl `componentWillReceiveProps` may also be called for reasons other than props changing (see: https://github.com/facebook/react/issues/3279#issuecomment-164713518), so you MUST check to see if the prop actually changed anyway (regardless of which lifecycle you choose).  Also, if you're actually doing asynchronous data, you're going to be waiting for the next event loop before your callback will get fired anyway, so I don't think it would matter if your function got invoked immediately before/after your render function, right?
 @kmalakoff You will always need to check if the props changed, since we will never be able to tell you definitively that props did/didn't change (because Javascript does not have value-types and does have mutability).
 @kmalakoff I don't want to digress this thread, but here is a gist for you: https://gist.github.com/jimfb/9ef9b46741efbb949744

TLDR: @akinnee-gl is exactly correct in his explanation (Thanks!).  With the minor correction that we couldn't always do the recursive check anyway (even if we wanted to, and performance were a non-issue), because there is no way to recursively check a callback function passed in as a prop.

Let's keep this thread on-topic though :P.
 @kmalakoff As per the gist, let's not increase the scope of these issues.  The issue is already complex enough, and digressing the conversation into a full API-redesign is not going to be tractable.  You're welcomed to continue thinking about these issues, but please keep this thread on topic.

@kmalakoff Many of the points you're mentioning are topics of other issues.  For instance (D) is answered by https://github.com/reactjs/react-future/issues/40#issuecomment-142442124 and https://github.com/reactjs/react-future/issues/40#issuecomment-153440651.  Those are the appropriate threads to have that discussion.  If you're looking for more general/holistic design/API discussions, the correct medium is probably https://discuss.reactjs.org/
 @kmalakoff The topic of the thread is defined by the title and first post.  The title is `componentDidReceiveProps Please` not `lots of general ways to reduce boilerplate`.  This thread is about reducing boilerplate specifically through the introduction of a very specific lifecycle method.  That discussion alone is already nuanced enough, without introducing additional topics (like renaming all the functions) that are already being discussed in other issues.

Your points are valuable, and I encourage you to have the discussion, just please move it to a different thread, because we want to keep github threads focused on the topic at hand.  Otherwise the discussions are too difficult to track/manage.  Threads do exist for most of the topics you raised.
  That's a reference to an internal module at FB. It's basically `querySelectorAll` with fallback behavior for handling old browsers and special cases. It is pretty unremarkable and doesn't actually translate super well here (except maybe a `scryRenderedDOMComponentsWithQSA` or something, but meh). We're working on improving the testing in other ways so I don't think there's anything we really want to do with this right now.
  This certainly works but it is not a pattern we would like to encourage because:

1) It reexecutes every time so you get a new object every time which might change over time. We rely on it being the same every time. You would have to ensure that it is truly idempotent.
2) It is not as easily statically analyzable so we can't use a compiler to inline the result when they're constants (which is most of the time).
3) It is slower because you are reevaluating the expression very often. Getters are also slow in all engines and not well optimized. People will blame React for being slow.
4) Getters doesn't work in IE8 so we can't keep our backwards compatibility.
 Maybe if an advanced compiler had a way to optimize these into plain properties. Then it would be optimizable and verifiably idempotent while still just using plain ES6 syntax.
  This sounds like a bad polyfill. I verified that you do get that error with core-js when running `RegExp.prototype.test.bind(/a/)('a')` on IE8 but not when using es5-shim instead. Can you file this issue on the core-js repo? We're not looking to work around broken polyfills when working ones exist.
  It does differ but it shouldn't matter terribly. A bunch of changes went into #3123 and we should be linting it now. It's not a part of `npm run lint` (thought it probably should be) but `grunt lint` should be getting it.
  Thanks!
  Warnings are ok, errors are not. There are a lot of warnings about long lines (we need to clean them up) so it is admittedly hard to find what you did. I want to make only lint for your changes to show up but we don't yet.

As noted, the error is coming from your change, so I'm going to close this out.
  At a glance this seems ok, though it's not great that we're adding code that will ship to prod which is only useful for development warnings. So we might want to try something else. We're code frozen for 0.13 so it won't go in there (though perhaps patch release). We'll take a closer look at this and a few other issues after we cut the release branch.
  Sounds like this is an issue with the tutorial servers so I'll close this issue and leave the other one open until we fix it.
  Thanks! This file is actually generated automatically from this file on the master branch:

https://github.com/facebook/react/blob/master/docs/_js/examples/todo.js

Can you redo your changes there and send a new PR to master (instead of gh-pages)?
  This is the piece we need to bring into React. We need to do a couple things first before we can merge this (and this will need a small update too).
- [x] https://github.com/facebook/esprima/pull/85
- [x] ship updated esprima
- [x] ship updated jstransform using updated esprima
- [x] update our deps (we pull `Syntax` from the re-exported object in `jstransform`, so we only have to update that for this. We also depend on esprima-fb directly so we can use it in eslint... once we do that we can probably autolint our tests)

I tested this by using `npm link` and running our transform tests.
 Alright, new esprima and jstransform are published so this should be fine to do. We don't have to do it for final but might be good to not sit on it.
 I doubt this will make 0.13, since we're already building RC2 and we don't want to break things right before the final release.
 I kinda want to take it. It should be pretty transparent to anybody and is pretty low risk.
 Ok, sounds good to me.  @zpao can merge when he's ready.
  @wmertens Can you sign the CLA here?
 No worries, thank you!
  @yaycmyk `componentWillReceiveProps` is for update from owner, not from the component itself's state change.

You can do it in `componentDidUpdate`, but that'll easily create an infinite loop (since your filter update triggers `didUpdate` again) if you don't know what you're doing. Alternatively, you could pass a callback as the second argument to `setState` if that fits your use-case. Maybe there's a better way to achieve what you want to do. And yeah, don't mutate state in `shouldComponentUpdate`.

Closing for now unless you have more questions =) (btw, Stackoverflow helps).
  Note that prop mutation is deprecated; see also https://github.com/ericclemmons/react-resolver/issues/8. If there's something else that can't be done in componentWillMount, let me know and we can reopen to discuss.
  closing per last comment.
  =)
  The usual way to do this is to write something like

``` js
<Dot onSelect={this.select.bind(null, 'yellow')} />

select: function(color, e) {
  // ...
```

Here, the `.bind` does a partial application of the callback so that the arguments passed to bind are passed as the first argument to the callback.

However, looking at your code I see some more problems. Most importantly, you should never ever set another component's state by calling `setState` on anything except `this`. State should be thought of as a component's private variables. You could expose a `setSelected` method on the Dot component, but really this belongs in the parent component's state, then it can be passed down automatically through props to the dot components. Something like this should work:

``` js
var Whiteboard = React.createClass({
  getInitialState: function() {
    return {selectedDot: null};
  },
  handleSelect: function(color) {
    this.setState({selectedDot: color});
  },
  render: function() {
    return <svg width={window.innerWidth} height={window.innerHeight}>
        <Dot color="yellow"
             x={window.innerWidth/2 + 100} 
             y={window.innerHeight/2}
             selected={this.state.selectedDot === 'yellow'}
             onSelect={this.handleSelect.bind(null, 'yellow')} />
        <Dot color="blue"
             x={window.innerWidth/2}  
             y={window.innerHeight/2}
             selected={this.state.selectedDot === 'blue'}
             onSelect={this.handleSelect.bind(null, 'yellow')} />
      </svg>
  }
}); 
```

Note that now you don't need the refs, nor do you need to update each child individually. Idiomatic React code rarely uses refs. Let me know if this example makes sense.
  Thanks!
  Cool, I'm game to mention these. Can you actually update the markdown file in master (https://github.com/facebook/react/blob/master/docs/docs/tutorial.md)? The gh-pages branch is generated so this will get overwritten on the next update.

GitHub will make you do a new PR so I'm just going to close this out ahead of time.
  Yea, closing. This is the same as other issues mentioned.
 #2402 
  Thanks. About magic-templates... this is actually using jekyll which uses [liquid](https://github.com/Shopify/liquid/wiki) for templating.
  Merging into #1326.
  Why do you need this?
 Not sure what you mean. Can you give a code example of the problem you're trying to solve?
  renderToString doesn't fully mount a component, so we don't call the componentDidMount method in that case (e.g., `this.getDOMNode()` wouldn't work because there isn't a DOM node at that point).

I'm going to close this out because I believe there hasn't been any behavior change here in React, but if you can post a minimal repro case where a component is mounted but `componentDidMount` isn't called, please post it here and we'll take a look.
  Thanks for the issue ‚Äì you're right that we do assume that dangerouslySetInnerHTML markup is valid so we didn't ever expect this error message to fire; it's more of a sanity check. We can at least try to document better and improve the error message, but maybe we can also consider validating the markup in development mode.
 (We parse them together for performance reasons.)
 > We can at least try to document better and improve the error message

I believe it was mentioned some time ago, perhaps we should put out a one-time message first time `dangerouslySetInnerHTML` is used. But then most people probably use it somewhere and will nag to get rid of it... :)

> but maybe we can also consider validating the markup in development mode.

I'm not aware of a reasonably fast/easy/small way of validating the markup other than using a parser, but even that would not be 100%.

We could make `createNodesFromMarkup` more robust and helpful by interspersing all markup with a comment and then validate all comments being in order, but it can't give you the reason/source of the error.

We can't validate the markup out of context either as invalid nesting plays its part too. The only thing that seems realistic to me is wrapping `dangerouslySetInnerHTML` markup with a comment on each side, then we walk the tree and ensure that all such special comments are on the same level.

But you're always at the mercy of chance here, the root problem is that the user _must_ be made aware that markup must be well-formed, valid in context and safe/sanitized.
 > I believe it was mentioned some time ago, perhaps we should put out a one-time message first time `dangerouslySetInnerHTML` is used.

That doesn't work in codebases worked on by more than one person. :)
  Is this specific example not working for you? It appears to be doing as you expect (in firefox and chrome at least), the "add new row" is always the last item.

(ps. let's try not to assume "gents")
 Ah, looks like the main difference is the lack of `<tbody>` in the broken example. Browsers are "fun" and will change the DOM after you insert markup. So when you write a table without a tbody, the browser inserts one for you. Your original rows are in that tbody but the new rows are appended directly to the table. So that's why they show up after the original content. We have a warning that fires in some conditions as we try to detect this but we can't always, which leads to weird things like this.
 @zpao Related #2262, optimistically traversing unexpected nodes like we do now for `tbody` just seems like a bad idea to me, it hides invalid nesting issues like this and make them only surface _sometimes_ rather than consistently which seem far preferable to me.
  @zpao Korean translate team members all agree with cla. You can see full the members list here. ( reactkr/react#55 ) If you still have a reason that  you can not merge this pr. please tell us. We will fix it.
 Alright, let's do it. Sorry for the delay, it's been a bit crazy around here recently with react native :)
 Ok, now moving forwards (and this is something we need to figure out a bit more across translations but I'm here), I really like the update in batches approach. Some things we'll definitely encourage that we fix across locales (eg, my change in #3487 would have been done to the ko-KR page as well), but others just won't be possible. I think it would be awesome to keep an eye on changes to docs (perhaps on a weekly basis just looking at https://github.com/facebook/react/commits/master/docs) and submitting changes in batches.

Looking further ahead, I've had https://github.com/screeninteraction/jekyll-multiple-languages-plugin open in a tab for a long time now, it might be time to finally look at integrating that. We have 3 translations at the moment - zh-CN, ja-JP, ko-KR - and while they aren't all complete, it would be great to integrate them into the site more holistically. Ultimately I'd like to move away from Jekyll to something node-based (and preferably using React, as we're doing in most of our other docs sites). We might have to write out own i18n stuff to make that work though.

If anybody is interested in taking on the larger project here and I'll try to give some guidance and thoughts.
 We already doing weekly update in [here](https://github.com/reactkr/react/pulls?utf8=%E2%9C%93&q=is%3Apr++update). It need to rebase with master but, hopefully We can send PR tomorrow. so.. dont worry about update translation. :smile: 
 @marocchino awesome! We'll be better with actually merging the PRs moving forward :)
  Looks great, thank you!
  Wups early submit. It shouldn't be automatically propagated, whether you can pass a class or not (or even how) is for the component to decide. PS. Also no, `className` and `style` are not special in any way, DOM components do not receive special treatment by JSX.

http://facebook.github.io/react/docs/jsx-spread.html and https://github.com/sebmarkbage/ecmascript-rest-spread has some more information which could be useful depending on how your components are set up.
 In my words; components are not thin bundles of DOM, they are opaque. They decide what is rendered and how. If it should take class/style and forward it to _some_ rendered DOM component then that is the responsibility of that component, it's not a given, there's not even a single universally agreeable way of doing it anyway (hence why `transferPropsTo` was discarded).

Also consider something like ReactKit (for native apps), there is no concept of style/class in native apps.
 > JSX effectively acts as a mini render for html

No, JSX is frontend neutral, it is not made for HTML. Think of it as [E4X](http://en.wikipedia.org/wiki/ECMAScript_for_XML).

> it is defining a specific way of rendering and has clear understanding of class and style.

JSX has no knowledge of the meaning of individual props.

> I do agree that JSX is not present in ReactKit because we are not working with an html output

You can definitely use JSX with ReactKit, that's the point.
 For posterity, `className -> class` is done by **React** for DOM components (only).
  The use cases for replaceState seems to fit one of these patterns:

1) Let state temporarily be null until some data is fetched. Then reset it to null using replaceState at some later point.

2) Use an immutable-js Record to store your state. That way you can use it with cursors and convenience methods like "update" and batching.

3) Using immutable-js Map to store your data. 

4) Use state as a map. I.e. adding new keys dynamically. `setState({ [someID]: value })`

All these use cases break down when you need to add another state value which makes refactoring a pain when you thought that you wouldn't need to.

It also means that mixins can't add state. (I'm not particularly found of this pattern but it is a common one.)

We could potentially add native support for (2) but it would expand the record type to one that contains all the fields required by mixins.

We would like to add a warning if you expand the state with fields that are not in the original getInitialState. The reason is that VMs optimize around records that keep their type signature. By changing the type signature dynamically you introduce performance penalties. We can't add that warning if patterns 3-4 is used.
 It's fairly safe to say that (1) is equivalent to `if (this.state) { this.state = null; this.forceUpdate(); }` though, it's not very neat.

Idea; deprecate `setState()` as well in-favor of `this.enqueueUpdate(void)`, i.e. `forceUpdate` without `force`. You're now responsible for updating `this.state`, we make no assumptions, you can easily re-add `setState` to your base class.

Tangent; technically we could even move to something like `React.forceUpdate/enqueueUpdate(instance)` if we want to avoid publicly exposing methods on the base component class. Only `isMounted` would be left then right? It even seems imaginable to drop the base component class entirely if you wanted to?

> It also means that mixins can't add state. (I'm not particularly found of this pattern but it is a common one.)

\* shoulder shrug *, your class, your choice. If you don't use an object you also accept that it won't be compatible with "standard mixins" out there.

> We would like to add a warning if you expand the state with fields that are not in the original getInitialState. 

:+1::+1:
 I would like to move the authoritative state object to the internals. Ideally it should also be frozen. At render we would resurface whatever the internals thinks is the current state object. That way the internals could be implemented in terms of immutable trees/cursors. The component structure could also be quickly hydrated and restored if we need to reclaim some memory (e.g. infinite scrolling lists). Ideally `this.state = null` and even `this.state.foo = null` wouldn't work. Nested objects would still work.

By mutating state we also have the timing issues that comes with mutation.
 > By mutating state we also have the timing issues that comes with mutation.

Oh right, yeah.
 This effectively means that all stateful components must define getInitialState.  My knee-jerk reaction was that this is a bad thing, but now I'm starting to like it :).
 @jquense There are other advantages to requiring a complete `getInitialState()`.  Readability is the most obvious advantage, because you can always see (in one place) what state variables are being used.  Another minor advantage is that it forces component developers to explicitly think through their component state (and consider if state is really necessary, since ideally most components should be stateless and this nudges developers in that direction).  Much more importantly, forcing `getInitialState()` means we can identify stateful components, which allows for performance optimizations across your entire React app.  It's not just about the minor cost of a V8 optimization surrounding statically-keyed objects; it's potentially about a framework-level optimization.  So saving a little convenience for one person could mean a lot of performance loss for a lot of people.
 I agree with @jquense. React should not be prescribing style guides or subjective readability/documentation rules. That's one of the nice features of the new class support in React. We don't really care how you create your classes as long as they correspond to some interface.

The only time we would introduce something prescriptive is if the mere existence of a convenience means that is blocks features for everyone that doesn't use it.

I think that Flow already do and will continue to require you to define the full state signature at construction type. For static typing that makes sense that you want stable type signatures. That also unlocks optimizations in VMs.

I think that is enough for us. We probably don't need to add a runtime warning.

I don't think we have any React-specific optimizations that would require state to be consistent, however, I could see that becoming the case in the future. So I'd still strongly recommend using a consistent state.

Regardless, I think it safe to remove `replaceState`. @jquense are you arguing that your pattern also requires you to reset state by doing `this.replaceState({})`?
 :thumbsup:
 You can simulate replaceState in your component by using only a single state variable. Ie. always do: setState({mystate: {...}}); Then you effectively have replaceState again, except that now you're component can be updated in the future without a huge refactor (as per Sebsatian's original post).

In fact, you can even define a replaceState function on your component, and if you always use your replaceState function (as oppose to ever using setState), it behaves almost exactly the same as the original function did.

``` javascript
function replaceState(newState)
{
  setState({myState: newState});
}
```

Our philosophy is to maintain a minimal API surface. This is especially important for public facing open source projects (like React), since we need to keep the learning curve low. Having the documentation littered with functions that we "continue to support, but recommend you don't use" is very suboptimal and confusing to people who don't eat-sleep-and-breath React. We move fast, try new things, and deprecate anything that doesn't stand the test of time.
  cc @sebmarkbage 
 I think we will actually deprecate the `mockComponent` API completely. This was only needed in versions < 0.13 because of the extra factories around components.

This feature is no longer needed because you can just mock the class yourself. If you use something like jest, the component is already auto-mocked for you, including all the methods.

The only feature that `mockComponent` provides is the ability to swap out the rendered output (by default it is `null`). However, you can even do that yourself:

``` javascript
Child.prototype.render.mockImplementation(() => <div />);
```
  Spinoff discussion of #1373, #3128 and #3228.

We're pretty sure that we need to change the current way refs work (see above). However, the new ref callbacks are also not ideal because it relies on some imperative code and suffers from timing issues like all imperative life-cycles. It is also not very convenient without arrow functions. Even with arrow functions it might suffer from performance issues.

A few things refs tries to solve:
- Imperative access to APIs that doesn't have declarative counter-parts yet. E.g. DOM layout.
- Fast-path down the tree to update deeply to by-pass reconciliation. Perf-optimization.
- Get the current state of a child that you don't want to control without duplicating state (which might possibly diverge).
- Send signals/pulses downwards.
 Another one that I've been thinking about is "parent-based refs".

You could treat refs similar to context and assign it a unique key that bubbles upwards through the parent hierarchy and everyone in the hierarchy gets access to it. Effectively reversed context. Which is useful for other things too: https://github.com/reactjs/react-future/tree/master/04%20-%20Layout

``` javascript
var DIV = new Symbol();
class Container {
  componentDidMount() {
    var myDiv = this.refs[DIV];
    ...
  }
  render() {
     return <Something><div ref={DIV}>{this.props.children}</div></Something>;
  }
}
```

This should work for most cases but it has the possibility of screwing you up when they're nested:

``` javascript
class Something {
  render() {
     if (stopRecursion) return this.props.children;
     return <Container>{this.props.children}</Container>;
  }
}
```

It would provide a way to identify upwards signals such as this proposal:

https://github.com/reactjs/react-future/blob/master/09%20-%20Reduce%20State/01%20-%20Declarative%20Component%20Module.js#L19

Anyway... Just an idea to spin-off other ideas.
 As I kind-of-mentioned in #3228, I suspect part of the answer is:
1. Refs are well-suited for event-triggered interaction with uncontrolled components (clicking save and saving, etc).
2. Whereas refs aren't well-suited for life-cycle events; refs are based on your own life-cycle whereas you're really interested in the life-cycle of the target, you don't want a ref, you just want the instance momentarily and only when the target mounted/updated/unmounts.

PS. That's obviously not the complete story, but it seems to me that refs for life-cycle events might not be the right way to go.
 hm. I'm currently working on view recycling which allow us more efficient use of resources in long lists or tabs that share similar behaviors.

One of the interesting qualities of that problem is that instances are no longer necessarily tied to the state of a component. I'm not sure what that means for this particular problem yet but I suspect that relying on instance identity here might be problematic. Maybe not though.
  Yea, let's take this... just in time too :)
  Good catch! I remembered when I added it but then was switching between branches and forgot to come back to it. Thanks!
 Merged manually to get rid of the duplicate visitor changes. (fe16c8292c784eece30fdfaa5133bfef28eee47d)
  React specifies the use of contextify with browserify (it should happen automatically), which replaces `process.env.NODE_ENV`. I believe webpack has something similar built in. We're going to keep doing this for the time being so nothing more to do.
  Ignore @golenazfazli, that appears to be a terrible bot.
 Thanks, this looks good. Will merge this after we branch for 0.13 final.
  Deep merging is always tricky because you need to assume things about the shape of arbitrary objects. In this case, would you actually want a deep merge? The `.target` value is the actual DOM node that you passed in; it would be surprising to me if passing args to Simulate would end up mutating that node directly. In the React tests, we mutate the target's value directly before simulating the change event, like:

```
input_text_element.value = '0:01';
TestUtils.Simulate.change(input_text_element);
```

and that's the approach I'd recommend here.
  Starting with React 0.14 we will be able to inline ReactElements:

``` javascript
<div className="foo">{bar}<Baz key="baz" /></div>
```

as objects:

``` javascript
{ type: 'div', props: { className: 'foo', children:
  [ bar, { type: Baz, props: { }, key: 'baz', ref: null } ]
}, key: null, ref: null }
```

This improves performance over the existing `React.createElement` call by inlining the result of it.
## defaultProps

If a component might have default props they need to be resolved by the transpiler's runtime:

``` javascript
{ type: 'div', props: { className: 'foo', children:
  [ bar, { type: Baz, props: $resolveDefaults(Baz.defaultProps, { }), key: 'baz', ref: null } ]
}, key: null, ref: null }
```
## Exception: ref="string"

Unfortunately we still haven't figured out what the final semantics for refs. The current semantics relies on getting the current React owner. Therefore, we cannot apply this optimization if the ref attribute might be a string.

``` javascript
render() {
  // Neither of these...
  return <div ref="str" />;
  // ...are safe to inline...
  return <div ref={possibleStringValue} />;
  // ...because they might contain a ref.
  return <div {...objectThatMightContainARef} />;
}
```
## Non-JSX

This can work on React.createElement or functions created by React.createFactory if the first argument is an inline object literal. Otherwise it is not safe since the object might be reused and mutated.
## Only in Production Mode

This optimization should only be applied in production mode. Currently `React.createElement` fires various warnings for propTypes and key warnings if the `__DEV__` flag is set to true or `"production" !== process.env.NODE_ENV`. This optimization would skip the warnings which would be very very bad in development mode.

The difficult part of this is figuring out a way that this will work in everyone's environment because not everyone has the ability to use different transpilers for development and production mode.

One solution might be to use a ternary and rely on minifiers to strip out the extra code:

``` javascript
"production" === process.env.NODE_ENV ?
  { type: 'div', props: { ... }, key: null, ref: null } :
  React.createElement('div', ...)
```

This will a pain for source maps though.

Another solution would be to have different flags in the transpilers themselves but we'd have to make sure that people actually use them correctly. They will otherwise have problems due to not firing warnings, or think that React is slow because they screwed up their config.
 cc @sebmck
 > What do you mean by using different transpilers? You'd just be using the same transpiler flick a switch unless I'm misunderstanding something?

Yea, that's what I meant.

Developers already have minifiers that they only use in production mode. This is effectively the same thing.
 Nit: developer education is a technical issue. :) Look at how much technical trouble we go through to add warnings and locking down the API so that developers don't unknowingly shoot themselves in the foot.
 @sebmarkbage 

> Unfortunately we still haven't figured out what the final semantics for refs. The current semantics relies on getting the current React owner. Therefore, we cannot apply this optimization if the ref attribute might be a string.

There were mentions in the past of "inverting" refs, you instead provide a ref-object to `ref` which is updated. That sounded great to me, it gets rid of the implicit owner and possibly even the magic object... additionally you could set up a ref**s**-object which could take care of lists of components, this does not work well today with strings.

**But...** what if we implemented ref as a callback(s) instead which receives the instance as an argument and something to distinguish whether it was mounted or unmounted, kind of similar to how `onChange`/`valueLink` works in a sense. That way we leave exact implementations up to the user and there is no preference for either individual instances or lists of instances nor where you store them (_if_ you even store them). These could even be chained easily. But this is no longer a system for refs, it's basically externally chainable life-cycle method listeners which can be used to reimplement refs.

I imagine this could have other benefits in the future; expose all life-cycle callbacks and you could use it to say easily measure frontend objects without ever having to store the instance, nor provide complex logic to determine whether or not the frontend object actually updated. This exact use-case is just an idea, but this approach seems a lot more React:y, reusable and naturally efficient than `refs` which seems like something you should avoid unless explicitly dealing with uncontrolled components in which case you have no other option.

Perhaps I'm way off on the utility here, but it seems to me that it solves a lot of problems that refs as meant to solve but in better ways and actually storing refs should only necessary when dealing with uncontrolled components. All other uses should reasonable be capable of doing its thing directly on instance when the callback is called.

Re-implementing refs as-is could look something like the code below, it could easily be made into a reusable helper. It could take any number of shapes, perhaps a key isn't even interesting and just putting all instances in a Set is enough. You decide.

``` JS
function createRef(that, name, next) {
  return {
    next: next,
    componentDidMount: function(instance) {
      that.refs[name] = instance;
    },
    componentWillUnmount: function(instance) {
      delete that.refs[name];
    }
  };
}
```

To keep updated measurements of a component you would simply as below, if the editor didn't update then you automatically avoid re-measuring for free. If only the editor updates, but not your own component, you still remeasure and get the updated height.

```
<Editor lifeCycle={{
  componentDidMount: (instance) => {
    this.setState({editorHeight: instance.measureHeight()});
  },
  componentDidUpdate: (instance) => {
    this.setState({editorHeight: instance.measureHeight()});
  }
}} />
```
 @syranide We already implemented both first-class refs and then switched them to callbacks in #2917. You haven't been keeping up. :)

It is not very convenient and very imperative since you need to keep your own reference to it. The timing of life-cycles isn't ideal too. Therefore I'm not comfortable deprecating the current refs until we're sure which model is final, and make sure that we have a good upgrade path (codemodable).
 @sebmarkbage \* facepalm \* ;)
 This proposal now need to be revised to include a `$$typeof` field as per #4832
 @sebmarkbage shh I was working on a PR! now @sebmck will beat me for sure‚Ä¶
 (https://github.com/babel/babel/pull/2352)
 On the React team we've been operating under the assumption that it's better to include the nulls.

I'm going to close this since the babel plugin now exists.
  We can make more optimized reconciliation by tagging ReactElements with the "hidden class" of their props.

For example, this is guaranteed to always have three props: `className`, `width`, `children`.

``` javascript
<div className="foo" style={{ width: w, height: 100 }}>{c}</div>
```

If we could tag every element with these properties with a unique ID:

``` javascript
{ __t: 7, type: 'div', props: { className: 'foo', style: { width: w, height: 5 }, children: c } }
```

Then we could use the hidden class to generate an optimized diffing algorithm for these instead of iterating over the properties. Presumably, we would only need to do this for `type: <string>` since we only diff native components.

Bonus points if we can determine which properties are constant. Perhaps using a property descriptor object:

``` javascript
// Constant properties are annotated as 1, other properties are excluded and inferred by props.
var t = { className: 1, style: { height: 1 } };
{ __t: t, type: 'div', props: { className: 'foo', style: { width: w, height: 5 }, children: c } }
```

We would use a heuristic inside React to determine when to create an optimized differ. For example, after 10+ updates to the same component. Just like a JIT would do.

``` javascript
if (oldElement.__t === newElement.__t) {
  numberOfUpdates++;
} else {
  numberOfUpdates = 0;
}

if (numberOfUpdates === 10) {
  optimizedDiffer = generateOptimizedDiffer(newElement);
  optimizedDiffer(oldElement, newElement);
} else if (numberOfUpdates > 10) {
  optimizedDiffer(oldElement, newElement);
} else {
  manualDiffing(oldElement, newElement);
}
```
 > If we could tag every element with these properties with a unique ID:

This seems problematic with watcher builds and generally keeping bundle hashes static for production. Or is this intended to be a production build post-process of some sort? But even then there are problems when separate parts of apps are built/maintained individually.

> Then we could use the hidden class to generate an optimized diffing algorithm for these instead of iterating over the properties. Presumably, we would only need to do this for type: <string> since we only diff native components.

This would be very useful for non-DOM elements too I would think (but it would have to be opt-in).

> Bonus points if we can determine which properties are constant. Perhaps using a property descriptor object:

It seems to me that you would also want `__t`s to reference a shared unique ID which would identify the unique set of actual props to check or you'll end up with a potential of O(2^n) differs rather than O(n), n being unique sets of prop names to check.

> We would use a heuristic inside React to determine when to create an optimized differ. For example, after 10+ updates to the same component. Just like a JIT would do.

Shouldn't this be globally per `__t` rather than per instance?
 cc @jimfb 
 @trueadm I think @sebmarkbage mentioned that originally with "Bonus points if we can determine which properties are constant.".
 Oh, I totally misread. You're right, my apologies.
  Starting with 0.14 we will be able to start treating ReactElements and their props objects as value types. I.e. any instance is conceptually equivalent if all their values are the same. This allow us to reuse any ReactElement whose inputs are deeply immutable or effectively constant.

Take this function for example:

``` javascript
function render() {
   return <div className="foo" />;
}
```

This can be optimized by moving the JSX out of the function body so that each time it is called the same instance is returned:

``` javascript
var foo = <div className="foo" />;
function render() {
   return foo;
}
```

Not only does it allow us to reuse the same objects, React will automatically bail out any reconciliation of constant components - without a manual `shouldComponentUpdate`.
## Reference Equality

Objects in JavaScript have reference equality. Meaning that this optimization can actually change behavior of code. If any of your calls to render() uses object equality or uses the ReactElement as the key in a Map, this optimization will break that use case. So don't rely on that.

This is a change in the semantic contract of ReactElements. This is difficult to enforce, but hopefully a future version of JavaScript will have the notion of value equality for custom objects so this can be enforced.
## What is Constant?

The simplest assumption is if the entire expression, including all the props (and children), are all literal value types (strings, booleans, null, undefined or JSX), then the result is constant.

``` javascript
function render() {
  return <div className="foo"><input type="checkbox" checked={true} /></div>;
}
```

If a variable is used in the expression, then you must first ensure that it is not ever mutated since then the timing can affect the behavior.

``` javascript
var Foo = require('Foo');
function createComponent(text) {
  return function render() {
    return <Foo>{text}</Foo>;
  };
}
```

It is safe to move a constant to a higher closure if the variable is never mutated. You can only move it to a scope that is shared by all variables.

``` javascript
var Foo = require('Foo');
function createComponent(text) {
  var foo = <Foo>{text}</Foo>;
  return function render() {
    return foo;
  };
}
```
### Are Objects Constant?

Arbitrary objects are not considered constant. A transpiler should **NEVER** move a ReactElement scope if any of the parameters is a **mutable** object. React will silently ignore updates and it will change behavior.

``` javascript
function render() {
  return <div style={{ width: 100 }} />; // Not safe to reuse...
}
// ...because I might do:
render().props.style.width = 200;
expect(render().props.style.width).toBe(100);
```

If an object is provably deeply immutable (or effectively immutable by never being mutated), the transpiler may only move it to the scope where the object was created or received.

``` javascript
function render() {
  var style = Object.freeze({ __proto__: null, width: 100 });
  return <div style={style} />; // Not safe to reuse...
}
// ...because I might do:
expect(render().props.style).not.toBe(render().props.style);

// However this is...
function createComponent(width) {
  var style = Object.freeze({ __proto__: null, width: +width });
  return function render() {
    return <div style={style} />; // ...safe to move this one level up
  };
}
```

This is due to the fact that arbitrary objects have referential identity in JavaScript. However, if the semantics of an immutable object is expected to have value equality, it might be ok to treat them as value types. For example any data structure created by immutable-js may be treated as a value type if it is deeply immutable.
### Exception: ref="string"

There is unfortunately one exception. If the `ref` prop might potentially might have a string value. Then it is never safe to reuse the element. This is due to the fact that we capture the React owner at the time of creation. This is an unfortunate artifact and we're looking at various options of changing the refs semantics to fix it.

``` javascript
render() {
  // Neither of these...
  return <div ref="str" />;
  // ...are safe to reuse...
  return <div ref={possibleStringValue} />;
  // ...because they might contain a ref.
  return <div {...objectThatMightContainARef} />;
}
```
## Non-JSX

This can work on JSX, React.createElement or functions created by React.createFactory.

For example, it is safe to assume that this function call generates a constant ReactElement.

``` javascript
var Foo = React.createFactory(FooClass);

function render() {
  return Foo({ bar: 1 });
}
```

Therefore it is safe to reuse:

``` javascript
var Foo = React.createFactory(FooClass);
var foo = Foo({ bar: 1 }};
function render() {
  return foo;
}
```
## Advanced Optimizations

You can also imagine even more clever optimizations that optimize per-instance elements by memoizing it on the instance. This allows auto-bound methods to be treated as effectively constant.

If you can track pure-functions, you can even treat calculated values as constants if the input to the pure function is constant.

Static analysis tools like Flow makes it possible to detect that even more elements are constant.
 cc @sebmck
 If the optimization in #3228 is applied, then the children array and the props object itself might be reused independently from the element itself.

``` javascript
render() {
  return <div className={this.props.className}>hello <span>world</span></div>;
}
```

``` javascript
var children = ['hello', { type: 'span', props: { children: 'world' }, key: null, ref: null }];
render() {
  return { type: 'div', props: { className: this.props.className, children: children }, key: null, ref: null };
}
```

This can be useful for reusing empty props objects:

``` javascript
render(someKey) {
  return <Foo key={someKey} />;
}
```

``` javascript
var emptyProps = {};
render(someKey) {
  return { type: 'div', props: emptyProps, key: someKey, ref: null };
}
```
 nice!
 This is an optimization that affects run-time behavior though, right?
 That is only because we don't have the distinction between value equality and physical equality in JavaScript. That's what we're trying to change. https://github.com/sebmarkbage/ecmascript-immutable-data-structures

You're very unlikely to rely on different referential equality of two otherwise equivalent React Elements. I've never seen a case for it, unless you have a mutable nested object. In which case this optimization should not apply.
 This is an optimization that should ideally be a applied in development mode too, just to be safe.
 I realized that if you have the code:

``` js
var CurrentTime = React.createClass({
  render: function() {
    return <div>{"" + new Date()}</div>;
  }
})

var Clock = React.createClass({
  componentDidMount: function() {
    this.interval = setInterval(() => this.forceUpdate(), 1000);
  },
  componentWillUnmount: function() {
    clearInterval(this.interval);
  },
  render: function() {
    return (
      <div>Right now, its: <CurrentTime /></div>
    );
  }
});

React.render(<Clock />, document.body);
```

then currently this shows an autoupdating time, but would not with this optimization. :\

Wonder if we can come up with some way to catch this in development (i.e., look for DOM mutations that happen?) and warn or something.
 @spicyj : I think the definition of constant values has to be that the expression contains zero references to non-local bindings and zero side-effectful expressions (member expressions, function calls, etc).

So with that assumption, we're fine here because `<div>Right now, it's: <CurrentTime /></div>` always evaluates to a constant (it doesn't eagerly execute the CurrentTime render() function -- just a descriptor).
 No, @spicyj is right because of how the reconciliation bails out by default if the element is reused.

However, relying on global state without a forceUpdate is not a supported use case. The solution is to add a forceUpdate on a timer in the deeper component.

> On Mar 10, 2015, at 2:50 PM, Jeff Morrison notifications@github.com wrote:
> 
> @spicyj : I think the definition of constant values has to be that the expression contains zero references to non-local bindings and zero side-effectful expressions (member expressions, function calls, etc).
> 
> So with that assumption, we're fine here because <div>Right now, it's: <CurrentTime /></div> always evaluates to a constant (it doesn't eagerly execute the CurrentTime render() function -- just a descriptor).
> 
> ‚Äî
> Reply to this email directly or view it on GitHub.
 I guess the difference is that before, if you didn't do a forceUpdate() (i.e. you didn't comply) you'd just lose out on a re-render...whereas with this optimization, you could actually be breaking more than just UI rendering
 Well, it is still just UI rendering, but yea, this is an added risk. We make the following two assumptions:

1) `ReactElement` is a value type. (including the class itself)
2) `render()` is idempotent. We always called it a pure function of `props` and `state`.

We don't have have runtime or static type system support for validating those things yet. We have to rely on convention to enforce those constraints. If you violate those, you're SOL.

However, this optimization is not the only place you'll risk getting screwed. It is easy to shoot yourself in the foot in other places too if you violate these principals.

We'll just have to make harder to bring value types and pure functions to the runtime and Flow to make it easier to ensure that you're compliant. No need to punish compliant code while we wait.

We've had this idea of doing pseudo-random double rendering in `__DEV__` so that we can validate that renders are idempotent.
 I'd like to propose moving the initialization for static elements into either componentWillMount or the constructor, and caching them on the module level. Taking out all of the static elements of a huge React app would add a significant initialization time overhead and also initialize components that might not be rendered at all (imagine downloading the full JS for the App but only rendering one view at a time).

I propose doing this optimization for React.createClass and classes that extend `React.Component`:

``` js
// before
class MyComponent extends React.Component {
  render: function() {
    return <div className="foo" />;
  }
}

// after
var _ref;
class MyComponent extends React.Component {
  constructor(props, context) {
    super(props, context),

    _ref = _ref || React.createElement("div", { className: "foo" });
  },
  render: function() {
    return _ref;
  }
}
```

Similarly, for a `React.createClass` call it would inject this into `componentWillMount` or create `componentWillMount`.
 @cpojer Should probably make it `_ref = _ref || ...`.
 oh yes, of course! Edited my example.

It could also of course have a single check for all of the static components in one module, like `var _initialized = false;` and an if-statement.
 A simpler transform would be to do

``` js
var _ref;
class MyComponent extends React.Component {
  render: function() {
    return _ref || (_ref = <div className="foo" />);
  }
}
```

which might be a little slower than your proposal but much easier to transform.
 @cpojer That is a much more specific optimization that ties it specifically to assumptions about React classes. I don't think we're ready for that yet. See **Advanced Optimizations** for other use cases.

This optimization is really a generic one that is employed by functional engines to any value type all over. It is also generalizable to the value types proposal for ES7.

We should really hold off on the React specific ones. I'd also argue that you don't need your React class if you don't intend to call render on it yet. So the whole module and class can be deferred.

That's a much more generic optimization that can be used for a lot of things. But it separate from this issue.
 Is there a reason however not to include this in the transform? I don't think it would make the transform that much harder to build ‚Äì I'm not proposing only allowing the general optimization for React components, but have a separate optimization that makes this work better for React components.
 @cpojer  It ties it to subtle differences in React semantics that we can't prove are sound. For example, `MyComponent.prototype.render()` wouldn't work. A sub-class that doesn't call the super constructor wouldn't work. Etc. @spicyj's suggestion would be safer but comes with a performance penalty.

Besides, you have to allocate the binding slot for the variable regardless.

I think we're better off investing in more generic optimizations such as lazy initialization of the entire module body. If we need statics, then we can pull them apart from the main classes.

For example:

``` javascript
// foo.js
export class Foo {
  render() {
  }
}
Foo.myConst = 10;
```

``` js
// bar.js
import { Foo } from "foo";
now(Foo.myConst);
function later() {
  new Foo();
}
```

Could be transformed into (something equivalent to):

``` javascript
// foo-static-content.js
export myConst = 10;
```

``` javascript
// foo-deferred-content.js
export class Foo {
  render() {
  }
}
```

``` js
// bar.js
import { myConst } from "foo-static-content";
now(myConst);
function later() {
  new (require("foo-deferred-content"))();
}
```
 Babel supports this in conjunction with React 0.14. Enable the `optimisation.react.constantElements` transform (do so in production only, e.g., when minifying your code).
  Thanks!
  My mental model is that we have a polyfill layer (`ReactDOMInput`) to support what the browser would support, and will support in the future once these ideas propagate through the standards. The fact that it is currently implemented as a wrapper should be an unobservable implementation detail, and perhaps it shouldn't be implemented as a wrapper.

As an upgrade path we would need to monkey patch existing legacy methods (`props`, `setProps`, `getDOMNode`) onto it as an upgrade path. These would work but immediately warn when used.

`setProps` will be replaced by some other imperative layer, or simply multiple calls to `React.render`.

`component.getDOMNode` is being replaced by `React.findDOMNode(component)` which can take either an arbitrary component or a DOM node directly. So you can use it on something that you're unsure about. In most cases, you can simply get rid of the call all together and use the DOM ref directly.
 > My mental model is that we have a polyfill layer ( ReactDOMInput ) to support what the browser would support, and will support in the future once these ideas propagate through the standards. The fact that it is currently implemented as a wrapper should be an unobservable implementation detail, and perhaps it shouldn't be implemented as a wrapper.

I agree about "should be an unobservable implementation detail". But how would you accomplish "perhaps it shouldn't be implemented as a wrapper."?

Anyway, it seems to me that direct interaction with the underlying frontend objects is something we want users to avoid? Instead favoring a reduced API bridge (when necessary) which would just fulfill the needs of the users and one that could also be reimplemented/proxied by community wrappers intended to fix/improve/extend/emulate native components for compatibility. This reduced API bridge could also provide additional benefits such as caching, batching or alternative APIs suitable for the React environment. Accessing the underlying frontend object would then be the "last resort".

The idea of returning the actual DOM node instead of a component for a ref is really interesting... the more I think about the more directions/reasons for it appear to me so I can't really boil down my questions/concerns to something sensible so I'll just trust you ;)

> `setProps` will be replaced by some other imperative layer, or simply multiple calls to `React.render`.

That wouldn't work for `toElement` though?
 @sebmarkbage This wouldn't work with e.g. #2242 I think? There's no universal guarantee the underlying DOM node lives as long as the owning component, unless polyfilled DOM components are exposed as such, but that doesn't seem to be your plan? **EDIT:** But even then, we're forcing that guarantee to hold for all frontend implementations unless there's a way to force refresh refs?
 Refs gets attached/reattached all the time: E.g:

``` js
<div key={Math.random()}><div ref="myDiv" /></div>
```

We respond by firing the ref callbacks and updating `this.refs[key]`. The only difference is if you stash the ref away in your own state or closure somewhere.

Even then, it seems like this is only a problem if you have a `ref` on an `input` whose `type` changes and only in IE8 (which is quickly dying). That seems like a very uncommon edge case.
 @sebmarkbage 

> Even then, it seems like this is only a problem if you have a  ref  on an  input  whose  type  changes and only in IE8 (which is quickly dying). That seems like a very uncommon edge case.

But are we sure this holds for every frontend out there? I agree input is kind of special here, but could one not imagine something similar for other frontends too? But then again, being able to refresh refs would solve that if it ever came to that.
 ZOMG! So exciting.
 Those work the same; only low-level DOM components (e.g., `<div>`) are affected.
  We still shouldn't write "undefined", so this sounds like a bug.
  Why not just destructure other properties such as `createClass` as well?

``` javascript
var {createClass, PropTypes} = require('react');
```
 FYI, on react native, the convention we adopted is

``` javascript
var React = require('react-native');
var {
  Image,
  StyleSheet,
  Text,
  View,
  ix,
} = React;
```
 I talked with @sebmarkbage yesterday. Basically, we netted out that this is going to be a larger issue as we move into a world where more people are using destructuring and ES6 modules. It's slightly inconvenient to do this across 2 statements, but it's also weird to create circular references to save a line of code. It's unfortunate that our own transforms depend on React being in scope but that's where we are for now.

Let's leave it as is for now and if a widespread pattern (which might just be what you proposed) shakes out soon, we'll look at adopting it.
  New Cool Features
- [x] Pure Functions as Stateless Components https://github.com/reactjs/react-future/blob/master/01%20-%20Core/03%20-%20Stateless%20Functions.js #4587
- [x] Allow arbitrary attributes on dashed tags i.e. custom elements. (@jimfb) see https://github.com/facebook/react/pull/3067
- [x] Fix the error utils guard. See ReactCompositeComponentError-test (Mostly affects FB internals but ties into better error handling in general.) (@sebmarkbage)
- [x] Add trusted key for ReactElements? #3583 / #4832 (@leebyron / @sebmarkbage)

Package changes
- [x] Build ~~Separate~~ Packages for react isomorphic, dom and server rendering [Still need to handle https://github.com/facebook/react/issues/4279 ] (@zpao)
- [x] Deprecate the dom renderer in the react package. Replace with separate package. Warnings if used. (@zpao)
- [x] Ship all React addons as separate packages. ~~Remove from react repo. (Possibly kill already deprecated ones like classSet)~~ Build with warnings if existing package is used? (@zpao)
- [x] End-of-life of react-tools. Clean up legacy in react-native and in the react repo (@zpao)
  - [x] Figure out react-native needs for `@providesModule` React (@amasad, @sebmarkbage)
- [ ] Ship index.ios.js with react so that react-native components can immediately start using the react package. (@sebmarkbage)
- [ ] Decouple dependencies between React DOM and React Isomorphic, except for `currentOwner` which React DOM still needs to set on React Isomorphic. (@sebmarkbage) See comment in #3866
- [x] Browser build for ReactDOM (@zpao)

Kill Deprecations from 0.13
- [x] `Object.freeze` props in `createElement` in DEV, remove old props mutation warnings. (@jimfb) see https://github.com/facebook/react/pull/4172.
- [x] Make `React.addons.createFragment` return a toArray from objects (@spicyj)
- [x] Kill `_isReactElement` (@spicyj)
- [x] Kill `ComponentClass.type` (@jimfb) see https://github.com/facebook/react/pull/4009
- [x] Clean up the remaining owner/context stuff (@jimfb)

New Deprecations
- [X] Deprecate setProps/replaceProps and replace with external ReactRenderer package, don't forget to include replaceProps in the renderer API and ship the package. (@jimfb, see https://github.com/facebook/react/pull/4150)
- [x] Deprecate getDOMNode (replaced with React.findDOMNode) (@spicyj)
- [x] Expose DOM component refs as the actual DOM nodes. #3223 (@spicyj)
- [x] Warnings on using a DOM Component's ref's getDOMNode or props #3223 (@spicyj)
- [x] Clean up remainders of context (@jimfb)

Probably not
- [ ] Deprecate replaceState? #3236 Needs Immutable.js solution. (@sebmarkbage)
- [ ] Deprecate isMounted? #3417 Needs Promise solution. (@sebmarkbage)
- [ ] Detect event target through `event.path` if available. E.g. in shadow DOM. (@jimfb) see https://github.com/facebook/react/pull/4150. (Disabled in https://github.com/facebook/react/pull/4585)
 > Expose DOM component refs as the actual DOM nodes. (Monkey patch props, setProps, getDOMNode onto it as an upgrade path.)

Hmm, this seems kind of weird to me, especially in-light of  `ReactDOMInput`, etc unless we intend to discontinue them as (recommended) addons or w/e. I would think the preferable direction would be _away_ from direct DOM interaction. Going off on a tangent here; including in some sense basically discontinuing the use of DOM events in-favor of passing a ReactEvent or even just the new value to `onChange` callbacks (which perhaps only really makes sense as an addon perhaps).
 Breaking this out into a separate discussion in #3223. Not sure what you mean by "passing a ReactEvent"...? Anyway we 
 @kharin As that page mentions, it is safer to use a nested state property anyway.

We could build native support so that this would work:

``` javascript
  getInitialState() {
    return Immutable.Record({count:0})();
  },
  handleClick() {
    this.setState(this.state.update('count', v => v + 1));
  },
```

We would merge it in React. We would likely only support the Record type, and not Maps though. It would still have problems with mixins.
 That's right. I added a spin-off Issue for discussion. #3236
 1) Yeah, refs to components you define yourself will still work the same way ‚Äì #3223 talks just about what happens if you take a ref to a node directly, like `<img ref="photo" />`. We're looking at making `this.refs.photo` be the img node directly in that case.

2) Yeah, re-calling React.render at the top level is the preferred solution. No plans to change how the instance is returned, though you should treat state as private to a component and only call `setState` on yourself (i.e., `this.setState`) and never on another instance you have a handle to. You can expose a custom setter method, but in most cases it's better to just pass the new values via props.
 Well, React supports winged birds, wingless birds, and (soon) wingless dogs. I'll change the name in the checklist above though.
 Every science and community has contextual terminology where you drop redundant terms. All these terms are also contextual to our field. I'm sure they mean something completely different in the world of plumbing and they would prefer it if we add more context.

In the world of the React community, the word "component" is often redundant. For example, when we say "instance" we often drop the "component" part.

In the broader sense, a "stateless function" is NOT redundant since it clarify the difference from a "closure" with captured state. You could build one of these single function components by using the closure to capture state for callbacks. In fact, that has been suggested.
 > > "closure" with captured state
> 
> function closure is orthogonal to statefulness

That's why I clarified that it captured state. I don't need a condescending terminology lesson, thanks.

This is an internal React issue tracker, used for our communication and tracking of issues, and not a blog post broadcasting new creative concepts. It is expected that the reader is aware and understands the distinction.
 I should clarify why this matters.

Doing development in the open is a curtesy. Lots of teams do this kind of progression in private. We even do that way too much by virtue of face-to-face meetings. I would like us to be more transparent. To make that happen, we don't want to be in a situation where we have to tailor our communication in a clear and timely fashion. That's what blog posts are for.

I definitely don't want anyone to have to hesitate to post because they feel they'll need to have a clear chain of arguments, make it understandable to a broader audience without context or because of fear from the terminology police. This space should be as accessible to our core team as possible. Even if that means contextual terminology, missing information if you're not part of wider conversations or even exploratory concepts that may or may not end up at already commonly known concepts.

That's why I'm pushing back. Feel free to ask clarifying questions though.
 @jimfb Can I pass "`Object.freeze` props in `createElement` in DEV, remove old props mutation warnings." to you since you're handling the deprecation internally?
 Yes, I'll update the umbrella issue.
 > Deprecate getDOMNode (replaced with React.findDOMNode)

it's already deprecated, isn't it? or should this be in `Kill Deprecations from 0.13` group?
 @chicoxyzzy 0.13 didn't have a runtime warning for it.
 @nmn We generally don't add any new functionality/deprecations to point releases (only minor bug fixes).  Also, we're working hard to get 0.14 out the door, and increasing the scope of the release won't make it happen any faster :).
 @nbostrom No promises, but I think we're still going to try to squeeze that in for 0.14.  We were just a little too busy before ReactConf Europe, and it wasn't quite ready in time for beta1.
 #3995 hit a block because some unfortunate timing in the initialization code forcing an unfortunate branch. I think we can probably fix that and get a better implementation by restructuring some other code.

Priorities in terms of releases sometimes get prioritized based on what gets blocked on it. I.e. if we don't add/deprecate certain things in release A then we can't do something else in release B. So this kind of sequencing is important. New APIs like this one often doesn't block anything else so they're easy to bump. They can always go into an ad-hoc release later on though. So we should be able to get it in soon.
 Just re-call React.render (or `renderSubtreeIntoContainer`) with the same container and your component will update. This has always been our recommended way to update a top-level component.
 @spicyj No, that doesn't solve the setProps problem.  He wants the blog post on the ReactComponentRenderer, which includes a setProps and replaceProps helper.

@sebmarkbage Let's figure out the blog post today.  I have a couple drafts in the Google doc.  Just let me know what you want here and we can put it up.
 @jsfb Not what I read from

> as it's not immediately clear how to call React.render on a component that's already been mounted

but let's get the blog post out too. :)
 @rchanou It allows for performance optimizations in the core (since we don't need to keep/track instances) and it also means less boilerplate/typing for you (since you just need a function, instead of a fullblown class).

You would still be able to use the component using JSX, just like any other component, it would still be `<Checkbox checked={true} />`.  Of course, you could use the alternate syntax if you liked it better for whatever reason by creating a factory.
 Stateless component functions are as if you had no shouldComponentUpdate, or a shouldComponentUpdate that always returns true.
 We checked off this stuff so I'm closing this. @zpao created a separate #4135 and we're also looking at the 0.14 milestone on github.
  Merging into #2104.
  As discussed in https://github.com/facebook/react/issues/3207#issuecomment-75181038, a complementary improvement is to turn on a mutation observer in dev, and warn of someone other than React modifies the DOM and/or if dom nodes appear without a data-reactid, thus indicating an extension or some other script is doing fancy magic.
 +1. I was going to implement this but didn't have any time to do it. At work I've encountered some bugs where non-React JavaScript touched React nodes and broke everything.
 > This seems like it would create annoying noise in some instances. There are a few use cases where direct DOM mutation is desirable

IMO those cases should be explicitly marked as such (perhaps a `dangerouslyAllowExternalMutations` attribute or something) as it's quite rare.
 Mutation of DOM node attributes/properties is safe (but should be avoided). Mutation of the DOM node hierarchy for anything but insertion of nodes into empty leaves is disaster waiting to happen. There shouldn't be an issue discerning an unsafe mutation from a safe.
  Can you explain your reasoning?
  When react-native is released. There isn't a set date there, but we're working to get it out as soon as possible.
  This is actually correct as is (though it should perhaps say "build into `build/modules`"). The files from `src/core` can not be dropped into any CommonJS env. Honestly that whole paragraph is probably really dated, that might have been written before we published to npm with all of our modules (we initially just published the single file for the browser).
  üëç this was before we changed our use strict style, which happened recently. Thanks!
  Looks good, thanks ‚Äì will merge after we release 0.13.
  The way we implement portals is through a nested React.render in componentDidMount/Update. This is also how react-art can switch render mode in the middle of the tree.

This comes with a few problems.

1) We can't reason about the depth of a component. Which is why we had to implement mountOrder.
2) We can't reason about its position in the tree for debugging purposes (react-devtools).
3) We can't pass the context through to the next subtree.

We should have a first-class concept of nested render trees, that can optionally use a different render mode.
 Would be nice to figure out how event bubbling works as well (cf. #1696).
 for reference: see ReactWithAddons.renderSubtreeIntoContainer
 Probably sometime, but no new proposal at the moment.
  cc @zpao 
 Thanks!
  From @gaearon https://twitter.com/dan_abramov/status/568566795004723201

This has come up before. We should warn when rendering directly to document.body because that list of children is often manipulated by third party scripts and browser extensions. Leading to subtle reconciliation issues.
 Wow, #thewebworldsucks.

I didn't think about this before, but there are many plugins that go in and do crazy stuff.  For instance, I have a Google extension that rewrites anything that looks like a phone number to be a link that I can click to dial via voip.  That's not a direct child of the body, but it's likely to confuse React.

I'm not sure what we can do other than warn for render-to-body and hope plugins aren't modifying other parts of the DOM, but I think it's worth thinking about the possibility of having a more graceful solution that handles this in a more general way (even if that's just overwriting the plugin's dom changes) rather than just warning in dev and "hoping for the best".  Not sure if there is a solution, but food for thought.

At the very least, we could probably setup a dom watch and warn if anyone except react modifies an element that was rendered by react.
 Tracking the mutation observer solution as a separate issue.
  Can you give a bit more context, perhaps in a jsfiddle?

Are you calling `event.preventDefault()` in the event handler? That's one case where we've seen this before.
 You shouldn't call preventDefault unless you intend to prevent the default behavior of the browser (which because of how we make the change event work means we're actually handling the click event. preventDefault of that on checkboxes prevents them from being visually updated). If you don't know why you're calling preventDefault, don't do it.
 There isn't anything wrong with React here. You're using your event handler incorrectly.

MovieList#_onClick should look like this: `_onClick: function(index, e) {` (index needs to be first so that when you bind, the arguments come in the right order.

render in MovieList, when looping over the movies, should look like this: `return <Movie onClick={self._onClick.bind(null, i)} ...` - you need to create a new function bound to the index so when it's called `index` is not `undefined`
 @binarykitchen Event handlers receive an event object, not just the new value, so you want `event.target.checked` or similar. I've fixed it here:

http://jsbin.com/huranakovi/2/edit

I also added a `.slice()` which clones the array so you're creating a new copy instead of modifying the old one in place, which tends to be easier to reason about (though isn't strictly necessary).
 I would look into what Table and the other components are doing. As is your setState is getting called and bound to the right thing. Your render is getting called again with the right state. You're _renderCheckbox isn't getting called again though. Perhaps it's because your rowGetter is returning the same data so those components decided to treat that as a reason not to re-render. Perhaps moving selected state into the row data would resolve this (regardless it seems that it's outside of React's hands and the issue is with components we don't control).

(edit: I see there were updates since I last loaded the page. I think my comment still stands though)
 I'm guessing somebody is already trying to make performance optimizations for you, which is why your cellrenderer isn't getting called. That's my guess anyway. I would look there and not try to prematurely optimize - make it work before you try to make it faster.
 Which will be worthless if you don't make it work first. AFAICT there is nothing directly related to React here. Dig into those other components and find out why they aren't updating.
  I can't repro this on Safari 8.0.3, but if you can put together a smaller demo that repros reliably I'm happy to take a look.
  input elements are implemented under the hood with a wrapper that deals with the events and making it a "controlled component":

https://github.com/facebook/react/blob/1c697ab1413f0db7e79de8f1a685c071128807fe/src/browser/ui/dom/components/ReactDOMInput.js

Closing this out as we're already aware that this sort of problem can manifest with multiple copies of React and we already have #2402, etc. to track.
  Thank you for the PR, and sorry about the long wait. Now that #5714 is merged, all attributes on SVG elements will be passed through as is, with no need for the whitelist. I'm closing this but please let me know if you have any troubles in master.
  Thank you for the PR, and sorry about the long wait. Now that #5714 is merged, all attributes on SVG elements will be passed through as is, with no need for the whitelist. I'm closing this but please let me know if you have any troubles in master.
  Yeah, pretty sure HTML5 drag and drop events will not work with SVG.
Unfortunately there is nothing React can do here as far as I know so closing.
  lgtm.
  cc @sebmarkbage (and @syranide for IE8 expertise)

We have a try/catch there, so even if es5sham is throwing an error, we should be catching it there (thus the comment in the catch - we expect that behavior). You're sure it's coming from this block?
 Fixed by #3017 :)
  Thanks!
  I'm quite certain this is correct as-is (but not 100%), click stands for click, not single-click.
 > But what if I want to distinguish between single and double clicks?

Not trying to be snark :), but that's something you'll have to take up with browser vendors/W3, React is simply doing it's best to normalize according to the defined standards.

If you're able to achieve this distinction yourself with native events then you're free to bind them manually and wrap it up in a reusable component. It's not perfect but it's very close.
 @binarykitchen You can bind manually in `componentDidMount/Update`.
  Please use `https://` instead of `//` as per the conversation here: https://github.com/facebook/react/pull/3180#issuecomment-74939014

Also, we should be aware this PR is subject to the same merging discussion mentioned in cody's PR: https://github.com/facebook/react/pull/3180
 Probably going to just take #3180 instead. I actually think we should leave this page alone, add a link at the top of this blog post to the updated location, and then only update that page.
 Closing in favor of https://github.com/facebook/react/pull/3180, which is now merged.
  cc @sebmarkbage
 I'm not sure what you're trying to achieve here but if we replace ReactInstanceMap with a polyfill we would want to be sure that it works with object keys (because otherwise this won't work at all) AND that it is fast enough.

The technique that we're using isn't good enough to be generalizable to a full polyfill. We rely on knowledge about this particular use case to cheat.

Basically, I don't think we can replace this with an arbitrary polyfill since they're too slow. We would only use an ES6Map is we knew it was native, and even then it might be slower than this. That's why I think that we don't actually want complete this TODO until browsers with native Map is overwhelmingly prevalent.
 @sebmarkbage I did some basic test a long while back and IIRC the native Map implementations are measurably faster in practice for nodeCache. All edge-browsers also come with Map implementations, so it's an idea to use those behind a check that ensures they are native.
 @SanderSpies No worries. I have written a transparent (but rather invasive for older) complete cross-browser O(1) Map implementation which actually really performs surprisingly well, but it can obviously never compare to bare-bone implementations which seems to be quite important in these cases.

If there are lots of places where we should use maps then I think the solution is to implement tailored bare-bones Map polyfills for each special use; i.e. instance object map, string map, etc (even different ones depending on what type the object is, so we can have a suitable name for the key). When there is a native Map implementation present we simply return it instead. But providing or relying on a generic polyfill just isn't a good idea it seems... it may become acceptable once we drop IE8 and perhaps IE9.
  @cody Thanks for helping move this forward!  Looks good.

> the Result tab is empty, because the external resources for the fiddles work only with http. So I guess facebook needs to update the fiddles first and then the docs can get changed to https. (https://github.com/facebook/react/issues/3153)

As per above, **we may want to update the fiddles (and potentially the CDN) before merging this**.  But this moves us in the right direction.  One potential issue is that the fb.me url does support https, but redirects to FBCDN which does not support https (yet/ever?).  We really should move react to a secure CDN, but that's a longer / more-involved task and probably won't happen over night.  Until we're hosting React on a secure CDN, my guess is that the empty results will remain an issue on https.  Having said all that, if we're only using jsfiddle to embed code snippets (ie. we don't care about the renderable results on jsfiddle), than I see no reason this commit can't be merged immediately (even before the fiddle and CDN are updated).  @zpao, thoughts?  Would it make sense to switch the fb.me urls to point to a copy of react on facebook.github.io instead of the http-only fbcdn?  Or would it make more sense to get fbcdn fixed?  Regardless, we really shouldn't be serving javascript code over an insecure connection anyway.

The `//` prefix is intended for resources that need to be loaded using both protocols.  For instance, if we were developing a service that needed to run in an https production environment and an http development environment.  In this case, we are only hitting the production jsfiddle (even when the site is served from localhost/dev), and the production jsfiddle does now support https.  For this reason, the prefix should be `https://` instead of `//`.  I would request that we update the PR now (to use `https://` instead of `//`), except that we still have the issue of FBCDN serving over http and thus such a change might cause the results tab to fail rendering when it would have succeeded over http.

@vjeux, looks like you own the fiddles.  Can you update them to point to the HTTPS versions of the domains? (they should all already exist).
 Having said all that, and having thought about it for a couple more minutes, I think my vote would be to merge this pull request immediately (since it makes things strictly better), and file a new issue to have these urls updated to `https://` instead of `//` once the fiddles (and potential CDN issue) are resolved.

That said, I'll let @zpao or @spicyj sanity check this idea, in case I'm missing a subtlety here.
 We can update the fiddles owned by reactjs (which is us) and @vjeux's to use cdnjs over https, but not most of the others.

So now that I've thought about it a little bit more and seen the extent of the embeds, I think we should just focus on ours and leave the rest alone. We already left the "thinking in react" blog post with the old embeds and only updated the more permanent docs page.

Also, I guess I was wrong about the `//` vs just using `https`, so let's do that. And then let's also update the links on "getting started" (in Chinese too) so those go to `https` (might as well).
  Correct, we use jest, which is built on top of jasmine.  Our jest configuration calls jsdom for simple tests and phantomjs for more complex tests.  Obviously your best bet is to run inside a real browser, but that's also the most difficult to setup.  We are not strongly opinionated about which testing environment you should use; go with whatever best meets your needs.

Since this isn't a "bug in react", I'm going to close this issue, which basically takes it off our radar.  Feel free to continue the conversation on this thread, or move the discussion to StackOverflow.
 Jest always uses jsdom, never phantomjs. Our React testing runs the same set of tests in both environments though (as well as in a browser for local debugging and sauce labs). That's obviously more work than one would want. At FB we primarily rely on jest (with some webdriver and other tests) so that's our strongest suggestion.
  :thumbsup: I'll update the filename and get this in tonight, then we can rebuild the site in the morning (better timing for more of the internet than 9PM <abbr title="Yes, technically it's PDT">PST</abbr>)
  ...including the ones that are not auto-bound like life-cycles.

This would help debugging as stack traces are better.

Also, I thought we added this at some point...?
 Yeah:

https://github.com/facebook/react/blob/f6920ba377b5f93cc8f02571fa16856839752428/src/classic/class/ReactClass.js#L530
 I guess we need to do it here too https://github.com/facebook/react/blob/f6920ba377b5f93cc8f02571fa16856839752428/src/classic/class/ReactClass.js#L478
 If you do something like:

``` javascript
var Foo = React.createClass({
  componentDidMount: function() {
     throw new Error();
  },
  render: function() {
    return <div />;
  }
});
React.render(<Foo />, container);
```

Assuming you're using the JSX transformer the class will have a `.displayName` in it. That means it shows up in debuggers. We should do the same thing with method names.

The stack trace of the error should include `Foo_componentDidMount` instead of `React.createClass.componentDidMount` or whatever browser's default name is.
 @chenglou did this in #2052 and we let that languish. It shouldn't be too bad to rebase.
 I screwed up #2052 somehow. #3423 is the same thing but re-submitted.
 FYI I closed #3423 as it didn‚Äôt quite get through the review and is outdated now. If anyone still feels strongly about it (aren‚Äôt we moving away from `createClass`?), you are welcome to pick up what @chenglou started in #3423, rebase it, and resubmit. We‚Äôll try to get better at reviewing stuff!
 @Sumei1009 Sure!
  Actually we might be able to fix that here (though it wouldn't be the "proper" fix). The right thing would be to make the class transform look inside templates strings. But we can maybe just change the order we run transforms [here](https://github.com/facebook/react/blob/master/vendor/fbtransform/visitors.js#L64-L76). @jeffmo - any known issue with running the template transform before the class one? I see we have some constraints internally but not here.
 Not going to do anything here.
  Minor performance ramifications, but I agree, nominal.
 Note that although fb.me is available over HTTPS, the URLs it redirects to are not.
 Baby steps.  The fb.me urls can be updated at some point in the future, once the fbcdn supports https or if we post the files on a different cdn.  One reason that CDNs often don't support https is that TLS breaks ISP caches because the ISP can't cache data from an end-to-end TLS connection (obviously).  Regardless, it removes one step in the upgrade path if we decide to use a secure CDN, and it means that users will not need to update their URLs if/when we switch the CDN to TLS.
 I think we'll probably just swap these out and stop pointing at fb.me. I did that in the tutorial repo a while ago (it just pulls from cdnjs). The only downside there (and the main reason I haven't stopped using fb.me entirely) is around releases. We want to have something available when we push the releases out but there's usually a small lag time before cdnjs/jsdelivr are updated.
  Yea, this sounds simpler. It loses a little bit (which makes sense to me but I'm too involved to get the outside perspective) but I think that's ok.
  Thanks!
  Hmm, we could also leave this mostly as is and just also reassign each of these like so:

``` js
var JQueryMobilePage = React.createClass(...);
JQueryMobilePage = React.createFactory(JQueryMobilePage)
```

That would keep the spirit of this example, which is mostly to show a non-trivial React example without JSX. Otherwise it's a bit weird to mix `createElement` with uses of factories (`React.DOM.*`). While both are without JSX, using factories is more likely to be written (for now).
 Thanks!
  If you cut out the jquery example update then we can merge this in.
 Thanks!
  `null` is the equivalent of no value and is not an object (empty or otherwise). If you don't want it to warn for `null` then don't make it required, it has the same effect. Testing for the presence of a key is not something I would recommend.
 I agree.  I can't think of very many use cases where you would want to force a user to specify a value, but would be willing to accept null as a valid value.  For practical purposes, the isRequired warning for null is sensible and expected behavior.
  Thanks @vsiao! :)
  This looks good.  Before we merge, can you change it to use a lowercase `element` (instead of `ReactElement`) anywhere we were previously using a lowercase `component`.  The reason is that it reads better and makes it seem less foreign/intimidating to people who are not yet familiar with all the formal terminology.
 @koba04 Looks great, thanks!
  @RnbWd Sorry, there was some sort of github glitch that caused only 3/12 boxes to be checked.  We've fixed the umbrella issue to accurately reflect our progress to date.  You are correct that the majority of the changes are to the internals rather than public API (we try really hard to minimize public-api churn).  The biggest changes to public API refs (still figuring them out) and es6 classes documented here: http://facebook.github.io/react/blog/2015/01/27/react-v0.13.0-beta-1.html

@joshbedo Runtime error messages generally suck, but such is life when you're working with a dynamic language like javascript; we try to have them be as useful/detailed as possible!  With regards to createFactory... it's not that we "introduced" createFactory so much as we "exposed" createFactory, which was previously bundled into createClass.  This change has several advantages including a simpler API for ES6 classes (which are the future), better support for static methods, better support for auto-mocking, and better language interoperability.  We thought long-and-hard about this change, and documented the decision/ramifications here: https://gist.github.com/sebmarkbage/d7bce729f38730399d28  Hope that clears up any misgivings you may have had about the factory change :).
 We're not going to do a changelog for betas this time around but we'll consider it moving forward.

@RnbWd to answer the timeline question - we're approaching RC very soon (which is where we've gone very short time between RC and final, we haven't actually done betas in the past). The other part of this is that you don't need to start using ES6 classes so you could write something for 0.12 that is forward compatible very easily.
  If (like most people) they view the page served on `http`, will having `https` embeds break? Do we need to instead leave off the protocol and just use `//`?

If that all works, we can have the PR set up and ready to go, then update the fiddles independently.
 Not sure that every page has a green lock now, but at least most do so I'm closing this. Feel free to send PRs if you run into any that are straggling.
  cc @yungsters, @vjeux, @zpao 

After digging around and evaluating, i see the following possible rule changes:

A. `escapeTextContentForBrowser` ignore `"` and `'`, they have no special meaning in text content.
B. `quoteAttributeValueForBrowser` ignore `'`, can only be broken out of with `"` (OWASP).
C. `quoteAttributeValueForBrowser` ignore `<` and `>`, cannot break out of quoted attribute values.

---

_The following safety observations are only guaranteed to hold for React generated markup, it does not hold when markup is introduced via `dangerouslySetInnerHTML` using different escaping/quoting or post-process manipulated._

**Markup as a string in inline scripts**
Proper escaping: JSON stringify + replace `</script` with `<\/script`.

With current rules (if no encoding):
- Leads to XSS if inside a `'`-string if there are legitimate occurrences of `</script>` (breaks layout during load).
- Leads to XSS if inside a `"`-string (throws error on load if markup has a quoted attribute value).

With rules A+B:
- Leads to XSS if inside a `'`-string (throws error on load if markup has a `'`).

With rules A+B+C:
- Leads to XSS if `</script>` is used as an attribute value (only observed if actively tested for).

**Markup within a HTML comment**
Proper encoding: HTML encode

With current rules  (if no encoding):
- Leads to XSS if there are legitimate occurrences of `<!-- -->` (breaks layout during load).
- Leads to XSS if comment is evaluted by a library (likely to throw error or break layout during load).

With rules A+B:
- (nothing new)

With rules A+B+C:
- Leads to XSS if `-->` is used as an attribute value (only observed if actively tested for).

---

The ruleset A+B is ever slightly more exploitable in the case of markup as a string within an inline script without proper encoding, but the flip-side benefit is that the lack of proper escaping is much more likely to be observed during development. I find this to be an acceptable trade-off and it's a dangerous situation to be in with or without the new rules so having a chance to catch it earlier is for the better.

So while the ruleset A+B+C is safe for HTML rendering it consistently elevates likely (relatively) minor safety issues to full-blown XSS and without increasing the chances of the lack of proper escaping being observed at development, although these are errors on behalf of the user and technically not our concern. This seems like a dangerous step that is not worth taking lightly, considering knowledge of proper escaping is far less common than it should be. `<` and `>` are also rarely used in attribute values so it would also have little practical impact. It would be easy to fix `</script` and `-->` but there's always the question of _what else_.

**tl;dr** I'm confident ruleset reduction A+B is, all things considered, as safe and perhaps even preferable due to earlier detection. This PR implements A+B.

---

``` JS
document.body.innerHTML = '<div></div>';
document.body.firstChild.setAttribute('attr', '<>\'"&/'); // quoteAttributeValueForBrowser
document.body.firstChild.style.content = '\'<>\\\'"&/\''; // quoteAttributeValueForBrowser
document.body.firstChild.textContent = '<>\'"&/'; // escapeTextContentForBrowser
```

``` HTML
<div
  attr="<>'&quot;&amp;/"
  style="content: '<>\'&quot;&amp;/';">
  &lt;&gt;'"&amp;/
</div>
```
 ```
 <span className="Select-clear" ... dangerouslySetInnerHTML={{ __html: '&times;' }} />
```

You can write

```
<span>&times;</span>
```

It's even in the docs: http://facebook.github.io/react/docs/jsx-gotchas.html#html-entities

Demo: http://jsfiddle.net/z2rkqL6g/

Does it solve your issue? Or do you still want to do some modification to React escaping strategy?
 This has been stale for quite some time. While this is important to get right, PRs tend to age worse than issues. We‚Äôre going to try an RFC-based approach to improvements in the future so features don‚Äôt get implemented unless there is a consensus on the approach and that it is high enough priority to be shipped.

I reopened #3879 as we are trying to hold discussions about intent in the issues now. Let‚Äôs keep track of this work there, and revisit if this is important to get it.
  In all of our `change` related tests, we actually set the value of the DOM node first before simulating the event. This is because `TestUtils.Simulate` doesn't actually fire the native event. So if your component doesn't do anything with the event (in this case our input wrapper doesn't) then the actual DOM node won't be updated. You also can't use `TestUtils.SimulateNative` like this - we actually set `event.target` to the node you pass in explicitly, so merging like this doesn't work.

So for the time being I'm going to say just set the value directly and ensure that triggering change doesn't actually change the node value.
  This happened in #3761.
  Semi-related; this is interesting as it also affects `PureRenderMixin` (and derivatives) as well and `shouldComponentUpdate` in general. For this reason I imagine you actually want to stay far away from putting `NaN` at all in props/state (for now at the very least). **PS.** Not of interest for this PR, but http://jsperf.com/isnanfast

cc @sebmarkbage
 @hmarr I doubt performance is an issue, my main concern is that people overwhelmingly implement equality as `prev === next` everywhere and in `shouldComponentUpdate`.

It's fine to update a generic mixin to have that in mind, but having to manually rewrite `this.props.name === prevProps.name` to `this.props.value === prevProps.value || isNaN(this.props.value) && isNaN(prevProps.value)` does not seem realistic. `isIdentical(this.props.value, prevProps.value)` could imaginably be, but it will always be a concern whether or not _every single_ component does it... and if that's the case then perhaps `NaN` should simply be considered perpetually unsafe because it is and fixing it in one place just lends a false sense of safety to what could be a big issue for someones unfortunate edge-case.

I'll leave this to @sebmarkbage or someone else who certainly has a better perspective on this than me.
 Thanks for this. This is clearly better even though staying away from NaN is clearly good, when possible. Hopefully we can rely on `Object.is` polyfills in the future.
 Ah interesting, it seems that positive and negative zero are not treated as equal by `Object.is`.

https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
  I'll take them :)

We'll probably have a few more fixes needed in tests since we don't current lint those (soon, but our code isn't all understood by eslint rules)
  Apparently we support rendering into iframes (@petehunt), but we always render new markup into the global document and then move rendered elements into the iframe document afterwards. JSDOM throws `Wrong document` if you try to do this but browsers don't seem to mind.

However, apart from perhaps not being very nice for various reasons, it seems to affect performance _significantly_: http://jsperf.com/renderdoc2 IE11 drops down to 33% performance and FF drops to about 20% (!) when rendering into the global document and moving rather than rendering directly into the iframe document.

This is easily solved everywhere except for `processUpdates` as renders into different documents are batched as well?

cc @spicyj @zpao
  Why does adding a transaction prevent the blur event from firing?
 Not really familiar with this part of React, but it seems to me that it would make more sense to just use `ReactBrowserEventEmitter.setEnabled` directly, which is all we want really, rather than rely on transactions which could have other side-effects/overheads down the line.

cc @zpao ... ?
 I guess this is related to #3790. I'm not in love with this PR because it feels like a bit of a monkey patch to me instead of fixing the true issue that unmounted components can receive events.
 Is this fixed now? I know we tried to avoid firing events on unmounted components. Regardless we need the full fix.
 #4983 should fix the rest.
  - Updates the jstransform version to include new Flow syntactic features (like `import type` and type casts)
- Adds new `--es6module` and `--non-strict-es6module` flags to the `jsx` executable

Why a special flag for es6 modules, you ask?

ES6 modules are parsed in a different mode than regular scripts: (1) They are implictly strict-mode (2) Only modules can have `import`/`export` declarations (scripts cannot); So the parser needs to know which mode it should parse the file.

Whats up with `--non-strict-es6module` you ask?

There are a lot of non-ES6 modules out in the wild (i.e. CommonJS modules) that are just begging to be converted to ES6 modules. However, because es6 modules are implicit-strict, it's not immediately safe to just convert the `require()`s to `import`s and call it a day. So this new `--non-strict-es6module` is a compatibility mode that lets people switch to the new syntax and defer the strict-mode conversion until they have time to come around to it.

cc @sebmck w.r.t. the new Flow syntax features (see https://github.com/facebook/jstransform/commit/de1173c3ee91b916f5921881439863589fca4b1d and https://github.com/facebook/jstransform/commit/a4099d9e2209c4d43df2c009209d87c4c26d9dd0)
  This is actually just a disconnect between expectations and the reality of working in the browser :/.

Unfortunately simulating events is not quite the same as what a browser does when you click on a submit button.

Simulating click is essentially the same as this:

``` js
var view = React.render(<Hello/>, document.body);
var button = view.refs.submit.getDOMNode();
var evt = new Event('click', {bubbles:true, cancelable:false});
button.dispatchEvent(evt);
// "  ... onclick called"
```

This creates a native `click` event and dispatches it to the button. However, no `submit` event is fired.

If you wanted to test this _exactly_ like a browser would behave, with trusted events and everything, then you need to run your tests in a browser and probably use something like selenium or webdriver to more accurately get results. Otherwise you'll want to simulate click and submit separately.
  Thanks!
 @brianpchsu Looks good, for future reference; if you mess up a branch, you can always reset it to master and start from fresh in the same branch.
  You can also write `className={'my-component ' + (this.props.className || '')}`. See #1198 though ‚Äì we're unlikely to do this due to perf.
  `isNodeJS` and `process.nextTick` exists nowhere in the React codebase, this is seemingly not related to React.
 No worries :)

On 13 feb 2015, at 17:44, dominataa <notifications@github.com<mailto:notifications@github.com>> wrote:

Yes apologies, I should have looked closer into it, I made the assumption it was react. Sorry for the time wasting.

‚Äî
Reply to this email directly or view it on GitHubhttps://github.com/facebook/react/issues/3136#issuecomment-74283480.
  Two of the licenses are even the wrong/old ones (brought in by my pre-2015 PRs :S). Could you update those to use the BSD-license as well?
 Only the license should be updated, any `@`-directives must be left as-is.
 Can you rebase? This doesn't merge cleanly (I fixed the license on 1 of the files yesterday as part of #3133).
  Thanks!
  Yeah, we use a feature test for addEventListener. Are there common polyfills that set it in old IE?
 @blainekasten Your fiddle works for me with IE11 in IE8 mode. You can still repro the problem with that?
 Going to reopen this to track. The OP closed the issue, so we didn't look into it. Wasn't aware of it. Nobody on our team chose to ignore it. I'll need to dig into this. I want to understand why this goes wrong so that we can explain this better in documentation etc.

Normally we recommend loading polyfills BEFORE the library but it seems like to fix this we have to load it after. We've also used shams for things like `Object.create`.

It's fair that maybe React should do more specific checks, but this isn't how we normally does things. It's new to me, so maybe it is a more systemic problem than just this bug. I.e. maybe we need to recommend/do things differently in more places.
 We could fallback to using `attachEvent` like we normally do but actually most things just works with the IE8.js polyfill so it would be even nicer if we could use the polyfilled `addEventListener`.

If we used the polyfilled version we'd get consistent bubbling order with other things on the page since we'd go through the polyfill's event dispatching. That's a nice feature to have and why we normally recommend putting the polyfills first to guarantee such whole page consistency.

It turns out that this bug happens because we're expecting to be able to listen to `focus` (which is used to set up the `change` special case).

https://github.com/facebook/react/blob/5696ccfcd72189f4fea13d8b0f084a0e3c9b8147/src/renderers/dom/client/ReactBrowserEventEmitter.js#L292-L302

We use the capture version of `focus` because it allows us to implement event delegation (it propagates unlike the bubble phase).

Since `focus` doesn't bubble, IE8.js doesn't pick it up. One solution would be to fix this in IE8.js to listen for `focusin` instead of `focus` when capture is used - as a special case to simulate this strange but standard behavior of `focus`. This would fix this bug and it would also make this trick work for anyone else using IE8.js.

However, we're also going to fix it in React by prioritizing the `focusin` event if it is available. That works around this limitation in the polyfill but also seems like a good move since `focusin` is on the standards track and is just as good.
  Hmm, can you run `npm test` locally - it looks like that might not be working on Travis (the `grunt jest` task doesn't seem to be outputting anything and is passing but running locally it fails). This will run our transform tests (we should also add one for whatever changes we have here, looks like there was a test case in the linked issue).
 The reason for them being inlined into the sub visitors is to have control over where they end up. Moving it out like that works, but you then end up with commas after newlines/whitespace rather than before as you would write yourself.
 @jasom ~~I don't see how this is off-topic~~, the current output by JSX (except for whitespace before newline) was agreed on in #970 and follows common style-guides/lints and the way you would write it yourself, this PR seems to undo just that?

`, \n` is a deficiency in the current implementation due to the complexity of solving it (it seems).
 @jasom Ah :)
 @jasom Your commit is broken (it includes git comments).
 cc @jeffmo
 There are still a few stylistic things. I'm in the process of enabling eslint here so that these files get linted and can tell you what's going on (namely use single quotes, match other styles with indentation, else bracing). If you rebase on top of #3206 (or it will be in master shortly I think) then you can see this yourself with `grunt lint` (that grunt task doesn't take params and is actually a bit noisy about long lines in other code so you could also run `./node_modules/.bin/eslint vendor/fbtransform` directly)
 Please rebase and re-run. If you were running eslint from your branch point, it wasn't configured correctly. It has since been configured appropriately and I cleaned up everything else in the above PR. The remaining errors and warnings are a result of your changes (image below is with your branch rebased on master).
![screen shot 2015-02-19 at 6 44 29 pm](https://cloud.githubusercontent.com/assets/8445/6280731/7080d27c-b867-11e4-9a3f-86630213dded.png)
 Sorry, been focused on shipping 0.13. This won't make that cut but I'll come back to it after. In the mean time, this doesn't merge cleanly (probably mostly just because xjs.js is now jsx.js) so getting it back into a mergable state will help.
 Squashed and landed as ef796790ec80c200bfc99df69e23db2522479272. Thanks and I'm sorry it took as long as it did!
  Thanks!
  It's been updated. Thanks!
  I totally get where you're coming from but let's leave this for now. We (FB) still use jshint internally so these actually help keep things a bit quieter there. I'd be fine dropping the jshint things from everything not in `src/` and making sure we use eslint there (we don't currently), if you want to go down that route.
 Overall, herculean effort. Thanks! Just a few smaller things inline I think.

Also, it looks like something got weird with your branching (or GitHub broke). Can you rebase and whatever you need to get that sorted out.
 Alright, lets do it. Thanks for fixing the commit weirdness!

This will definitely be useful and I know it was painstaking work, so we really appreciate it.
  :thumbsup: thanks!
  `htmlFor` is used by React, not `for`.
 You can also use a transform like my [es3ify](https://www.npmjs.com/package/es3ify) if you want to automatically add quotes to property keys that are reserved in ES3.
  I actually kind of like the 80 char rule, just so we have something in place. Right now it is a warning, not an error, so while it's a bit annoying to see what's new and something you can fix in a specific PR, it's doable.

So let's leave it as is for now. We've talked about maybe upping the line length limit but no decisions there.
  Seems correct and consistent with the rest of the codebase to me :+1: 
 Thanks!
  I'm going to close this as a duplicate of https://github.com/facebook/react/issues/1587

TLDR:

> It's a bit tricky because of transferPropsTo (or whatever we do instead) where you might have props that need to be passed on even if you don't consume them.

That said, I think it's a good idea, and would prefer to optimize for the common case where the unrecognized prop is a mistake rather than the less common case where people are transferring props.  Just not as easy as it might seem at first glance.
  If `this.getDOMNode().parentNode` is set then I can't imagine this being anything but a bug in Safari. React just sets `.innerHTML` and then calls `componentDidMount`.

I could be wrong, but I can't see this being anything but that at the moment.
 Thanks for tracking it down!
  Fixed in #2549.
  I appreciate the effort, but we're not going to put this in our transform, but you're welcome to apply this step yourself in your own tooling (we do need to make it easier to actually do that, but it's possible).

Generally you shouldn't include the extension in `require` statements. Using node-jsx is one way you can get around this (I use it in a couple projects). The other is transpiling first so `require` just works, like you noticed.
  I'll take consistency any day of the week :) If you wouldn't mind squashing these to a single commit, that would be nice.
 Awesome. Thanks!
  Basically; this: 

![screenshot 2015-02-09 16 32 18](https://cloud.githubusercontent.com/assets/1755404/6119087/27db095c-b079-11e4-842b-2f8be00827e9.png)

Yields this:
![screenshot 2015-02-09 16 33 18](https://cloud.githubusercontent.com/assets/1755404/6119083/2580dc86-b079-11e4-8886-1d162d7322c4.png)

It looks like properties from the immutable wrapper are being emitted along with the actual values themselves.  

Going to look into this myself when I get some time later today, but figured it'd be good to get it tracked with an issue.

Thanks!
 I'm going to guess this is relevant: https://github.com/facebook/react/pull/3030/files#r24046572
 cc @sebmarkbage 
 cc @leebyron 
 @gurdasnijor Is this using React 0.12 or 0.13?
 From the HTML output, it looks like you're using React v0.12 (current production version).

You need to explicitly cast the Immutable collection to an array:

``` js
<ul>
  {Immutable.List([1,2,3]).map(i => <li>{i}</li>).toArray()}
</ul>
```

This won't be necessary in v0.13, as React children accepts any iterable, not only array, which will include Immutable collections (as well as ES6 collections).
 @leebyron @sebmarkbage  I was running v0.12.2;

Just checked, and I can verify that the issue isn't produced with 0.13.0-beta.1 (installed from npm)

Thanks for the quick responses; closing out.
  I'm not seeing anything obviously bad about this. But it surely has some impact on the way we think about Mixins moving forward (any change to how they work has that impact).

We won't take this without tests but we can make sure we have the discussion first. cc @sebmarkbage 
 This doesn't really affect any future plans other than that mixins in mixins seems like a bad practice just like long inheritance chains are bad practice. It quickly becomes unmanageable.

This should probably be after the reserved keys are checked so that the logic for those can proceed using the custom logic.

If two different mixins implement the same exact function or object, then this would allow them to pass silently. I'm not sure that it is a good thing since it can hide an accidental bug. However, if we make `React.createMixin` flatten mixins as they go, then this might be a good way around that problem.
 We'd need to test that DEFINE_MANY_MERGED works as expected since they order dependent. I think that it'll work since each chained method will be a new function instance, just make sure to put it in the unit test.
 Doesn't look like we're taking this.  Mixins are mostly in legacy/maintenance mode at this point.  Also, as Sebastian mentioned, long/complicated chains of mixins is probably bad style (or an antipattern).  Also, no updates in over six months.  Also, merge conflicts.  So I'm going to close this out.  If this is something people want, we can figure it out in a new PR.
  That sounds plausible. Interested in making a fix for this? If it requires a lot of code it's probably not worth it but if it's just a line or two extra I'm happy to take it.
  `value` is assigned to a variable on the previous line. This came up in #3028 so let's just get rid of the assignment line. Can you update with that?
 @cody yea :( Perhaps we could just make this mulitline?

It's not how we would typically format this but it easy to read at a glance:

``` js
    return <input
             type="text"
             value={this.state.value}
             onChange={this.handleChange}
           />;
```

(damn you ASI for not just letting us go to the next line)
  @syranide, any interest in taking this on? I think we probably might just need to handle a different event for ranges (like we use clicks for checkboxes)
 @zpao I haven't really done much _actual_ event normalization so this feels somewhat alien to me, I believe @spicyj made the amazing `onChange` implementation for `inputs`?
 @kud Can you try a native `input` event listener?
 @xymostech Here's the bug I mentioned to you yesterday, if you're interested ‚Äì it involves working on [ChangeEventPlugin](https://github.com/facebook/react/blob/a8d9bff3ca0e123f0dade1987ad6040e23397989/src/browser/eventPlugins/ChangeEventPlugin.js) so that we can listen to both the input and change events for `range` inputs. The current code structure isn't super amenable to this change, but it should be possible with a little refactoring.
 (Dupe of #554.)
  Do you have steps to repro? This is the first we're hearing of this being a problem. cc @syranide 
 ```
>>document.createElement('style').innerHTML = '';
  "Unknown runtime error"
```

I.e. you get that when you call `innerHTML` on a node which doesn't support it... or in the case of React when you try to update the contents. Check the tag name of the node and report back please :)
 @flq That works just fine in IE8 for me and I can't spot anything funky in the code I think. Anyway, all I need is the tag name of the node, if you can reproduce it on your end, simply enable debugging and check `node`.
 @flq `<section>` is OK in IE8, but you need to use [html5shiv](https://github.com/aFarkas/html5shiv) or \* _cough_ \* my minimal fork [shivie8](https://github.com/syranide/shivie8) which uses a simple hack to make them behave and style correctly in IE8.

> Sorry to bother you, and thanks for looking into this - I'll leave you the satisfaction of closing :bow: 

No worries :)
 @ThomasChan Can you provide a jsfiddle that demonstrates the problem?
  (If we do this, we should link to https://github.com/reactkr too.)
 The reactjs.cn site is out of date at this point, and we are maintaining our own translation, so it might make the most sense to point reactjs.cn to http://facebook.github.io/react/docs/getting-started-zh-CN.html
 Ping @yibuyisheng: This site is still showing React 0.13.0, despite the fact we're on 0.14.7.  if you are not going to keep in pace, it might make the most sense to point reactjs.cn to http://facebook.github.io/react/docs/getting-started-zh-CN.html
  See https://github.com/reactjs/react-future/tree/master/05%20-%20Workers.
 @cecilemuller The problem of just using the DOM is that you can no longer integrate with synchronous APIs. So you have to build high level wrapper APIs on the main thread. IMO, the best way of building high level APIs on the main thread is to build them as React components that expose asynchronous APIs. Which is why I think that the solution is react->react rendering.

@SanderSpies The top section requires invasive changes to the core but we're working on doing them anyway. What we need help with is all the basic stuff.
- How do you start the worker?
- How do you load modules in a worker?
- How do you determine the root to render into?
- How do we unit test the system?
 @bluejamesbond None explicitly for web workers, though we've done a lot of refactoring recently with the goal of making it possible to have multiple reconcilers and make things more serializable, which helps with this goal.
 No, same as my last message.
 @axemclion Thanks for the writeup, that's pretty cool!  Your writeup mentioned that the bottle neck appears to become the mutations on the UI thread.  Presumably this is because you are mutating the values in every row as frequently as possible, but this is obviously not representative of real-world use cases.  It is my belief that most rerenders result in very few changes (That is, the majority of a typical application remains unchanged from one frame to the next).  Under the assumption that a typical rerender would do a lot of "work" (calculating diffs) but affect a small number of dom nodes, I wonder if batching becomes less significant and the overall performance benefits of running in a worker become more evident.  Especially with respect to things like scroll performance while running a rerender in the background.
 My latest thinking on workers:

We definitely want to solve concurrency. It is a major issue to let some work get out of the way. Particularly scrolling and other high-priority interaction that requires immediate feedback.

One way to solve that is through cooperative scheduling. I.e. making React and everything around React more "yieldy". Another is by adding preemptive scheduling (OS threads / workers) which adds additional guarantees about hitting frame deadlines.

One initial step we could take is move everything into a Worker as proposed here. We can reimplement/replace the DOM. There is, however, one major limitation. Text measurement. Browser layout is currently only available from the main thread. Even if we implement our own layout algorithm ( https://github.com/facebook/css-layout ), we wouldn't have access to text measurement. Even if we implemented our own text measurement, we wouldn't have access to the browser font files for internationalization fallback. Unless browsers are willing to give us text measurement in a Worker, our only option is to do layout on the main thread.

React Native doesn't have that limitation because it can get text measurements in the Worker thread.

That means that as soon as any of your work in the Worker is dependent on layout, you're going to be sending blocking work to be executed on the main thread. You'll have to wait for the round trip and probably stall the animation/scrolling while doing so.

However, luckily for us Compositor Workers are moving along as a spec:

https://github.com/w3c/css-houdini-drafts/blob/master/composited-scrolling-and-animation/Explainer.md

This would allow us to keep executing on the main thread, but also put code on the Compositor thread. We could build a React for the Compositor to allow us to easily build components for that thread.

If we had that, then it is not clear if React in a Web Worker buys us much more than some potential parallelism at the cost of lost scheduling ability, module initialization overhead (shared code executed twice), serialization overhead and added complexity.

If Compositors weren't happening, or if we wanted to render an entire page in WebGL, then we would wait for text measurement in Workers before moving into that model.

We could potentially use them to some effect as an intermediate step but it is going to be less than ideal. It would also require a lot of work to port our own code and move the community over to that model completely. Seems safer to wait for compositor workers. I suspect that its implementation will go quick once one browser has it and popular websites are utilizing it. Spec might take a while and it might be fatally underpowered in its first version. So we'll see how long it takes. In the meantime, we have React Native.

(Relay in a worker on the other hand seems very plausible.)
 @slober It's not terrible expensive and there are ways around it. We should also be focusing on that, and I am, through TC39 but that's an orthogonal problem to this issue. (Edit: Also note that starting up modules and code in each worker isn't free neither. Increases start up time if you have a lot of overlap.)

@fdecampredon There are 120,000 unicode characters. When you turn them into glyphs a large number of them have ligature combinations which makes that number explode. Each CJK language have their own font/glyph design for the same character. That explodes that set but most of those are fixed size so maybe you could optimize/compress those. An embedded font, even if it only has all glyph sizes, would be quite large. For proper sizing and shaping you need more information than that. Even if you did that, you would still not have the same exact font combination that that particular browser has. I.e. that gets rasterized on the screen. So you would end up win cases of incorrect measurements.
  Closing this because it's really about JSX and not React (and you already created an issue over there).
  Yea, this is better. It still looks weird, but better :). Thanks!
  It's not currently supported by React it seems:
https://github.com/facebook/react/blob/master/src/browser/eventPlugins/SimpleEventPlugin.js#L250

You can always attach listeners manually in `componentDidMount/Update` for now, it's not neat, but it works.
  That's exactly what the perf tools in the addons do ‚Äì see printDOM in particular:

http://facebook.github.io/react/docs/perf.html

Let me know if you're looking for something else.
  Thanks, but unfortunately we can't take this. I actually tried to do pretty much exactly this when I first joined the React team but it turns out we have this strange pattern for a reason - Closure Compiler Advanced Mode.

In order for `React.DOM.article` to actually render an `<article>`, we need a mapping to the string value. Closure Compiler will crush key access when using dot notation. It will also crush keys when creating objects that don't have string keys. `{abc: 1}` vs `{'abc': 1}`. So when `React.DOM.article` gets crushed to `R.D.a` we need to make sure the object we exported also got crushed so `{a: 'article'}`

I made a quick example which shows (more or less) why we can't take this. https://gist.github.com/zpao/7340ab4225840f168a72
  I'm going to agree that this is pretty arbitrary and not take it. Thanks for sending in the idea though!
  Thanks!
  See also #2196. (We do want to get to a consistent story for all of these things, but we're obviously not there yet.)
  Proptypes are just functions that throw an error if the prop doesn't match the expected value.  You could actually define your own proptypes.  https://github.com/facebook/react/blob/master/src/classic/types/ReactPropTypes.js
 > Proptypes are just functions that return an error

FTFY

Yea, it's not super complicated and hey, this is open source so you can re-purpose our code as long as you license it right. As of now we have no plans to pull them out ourselves so I'm going to close this out.
  Looks legit.
  You can use ReactPropTypes.any, which basically disables typechecking and lets you pass in anything you want.

I'm not sure if it's public API (so take this with a grain of salt / it might be subject to change at any time without notice / be careful), but... there is nothing magical about the default proptype validators.  They are just functions that validate a property (throwing an error if the property is invalid), and so you can write your own validator.  To get started, you can look at the implementation of our default validators: https://github.com/facebook/react/blob/master/src/classic/types/ReactPropTypes.js

Closing this issue out, since it's not technically a bug.  For future reference, Stackoverflow is the best place for questions that are not bugs.
 @skiano No, I don't think there is any fundamental architectural reason, but it shouldn't be a super common pattern.  The more common pattern is to create the element on the outside and pass in the element, or to pass in a function that takes in a particular set of parameters and returns an element.  This allows the owner/parent to have a little more control over the props that are passed to the nested elements, since the parent/owner is deciding the class of the element that is being created.
 You can get more specific that `any`. The real reason is that this "type" is a bit hard to define and actually cover all the cases. See my comments in https://github.com/facebook/react/issues/5143#issuecomment-147472187
 No
  I can't repro this. At any rate, we're not doing anything fancy with touch events so if we're sending it twice it means that we're receiving it twice from the browser and I don't know what we could do to fix that.
 (Tested on iPad Air simulator with iOS 8.1.)
  cc @zpao 
  Looks good to me.
  I'm not sure if this is exactly the format we want. props vs. state is a little tricky and not something that can always be solved with a table or flowchart. :) Have you read http://facebook.github.io/react/docs/thinking-in-react.html? That's our doc intended to give people an idea of how data flow works in React.
  Take a look at https://github.com/facebook/react/issues/2787

The TLDR: Calling setState() or forceUpdate() on an not-mounted component is a code smell that strongly suggests you are leaking objects prematurely or are not cleaning up your references after they've been removed.  This throws an invariant violation in an attempt to force you to clean up your code.  In practice, this is probably too aggressive.  There is discussion of downgrading this invariant to a warning or maybe even a no-op.

While not technically identical, I think this issue is sufficiently related to https://github.com/facebook/react/issues/2787 to mark it as a duplicate.
  In your case, that makes sense.  But suppose someone attaches an onChange listener to the root of their document (for hotkey navigation, or whatever).  It would be easy for a developer to create a form under that top-level component and forget to attach an onChange handler.  If they're using other components, they may not even be aware that some ancestor attached a change handler.  Also, in your example, the form is an immediate parent, but if you have formatting code in there, it might be a lot less obvious where the event is being handled.  For these reasons, the warning makes sense.  (It is a dev warning, not a fatal).

There is an easy workaround.  Just attach a no-op change handler that documents what you're doing.  Example:  `onChange={function(){/* no-op, change handled by the parent component (Form) */}}`

Because the warning is still useful even when the change event is being handled by the parent, and there is an easy workaround that also helps give the developer a nice place to document what they're doing, I'm going to close this as desired/expected behavior.
  Hmm. I must be tired because I'm not fully understanding the issue, but maybe we should just fix this?
 Thanks @WickyNilliams and @benglass!
  We currently don't because we handle this specially during runtime, but for server-rendered content it would be good to make this actually work.

cc @syranide 
 @zpao I never really liked the way it turned out.

It does focus once mounted, so it's decent the way it is now at least... but it also does so if you've already manually focused elsewhere, **which is not very nice at all**. This is kind of tricky, should we just ignore browsers that doesn't support `autofocus`? We could make something smart that doesn't focus if focus has already been set, but that's not 100% either. So perhaps it just shouldn't do it when reusing?

As far as `autofocus` is supported, it behaves as you would expect at page load in all browsers, which is good. So yeah, it makes sense to add it to the markup when server-rendering. But we currently can't add it to the markup selectively, we must remove it from the markup when reusing and it must not be rendered to the markup when client-side.

So it seems to me that to solve this, we need something like #1979 I think? Make server- and client-rendering detectable and reusing should incur an additional render where it transitions from server- to client-state (allowing properties to be removed, etc). And this is something that seems to be creeping up more and more elsewhere, having to be able to tell server- and client-rendering apart and being able to generate different markup for the two.
 > it must not be rendered to the markup when client-side.

What is the issue with using `autofocus` when rendering client side?
 @jsfb "We" decided not to use it because every browser has their unique interpretation of how it should work, literally all browsers do it differently. Overloading it and rendering it to the markup at the same time seems like a bad idea.
 Ok, we're probably going to get rid of the tag whitelist eventually anyway, so we would be sending autofocus to the DOM.  If the behavior of autofocus is browser-dependent, user beware.  Maybe we can do something to clean up the behavior and make it more consistent, but it's not entirely clear we should (though if it can be done easily/well, it seems reasonable).  Either way, I think the assumption that autofocus can't be used client-side shouldn't be taken as a given/assumption going forward.  The correct behavior, as I see it, would be to make autofocus work as consistently as possible in both environments (ie. it should be isomorphic).
 > Maybe we can do something to clean up the behavior and make it more consistent, but it's not entirely clear we should (though if it can be done easily/well, it seems reasonable).

That's what we did? The problem is that IIRC FF autofocuses _only_ on pageload, Chrome autofocuses only on initial element creation, IE autofocuses every time the element becomes visible, iOS does not autofocus at all, etc, or something like that, my memory is fuzzy but it's a total mess. It's literally useless now for anything but pageload or targetting a specific browser. Overloading is how we normalized the behavior.

> Ok, we're probably going to get rid of the tag whitelist eventually anyway

I know it's been talked about, but I just can't see it happening practically, the translation between attribute and property is arbitrary, how would we handle boolean attributes and avoid garbage ending up in the markup? Should attributes really be forwarded as-is? React DOM to me needs to be a good and safe abstraction, removing the whitelist is going in the opposite direction regardless of how enticing it is. But you know more about this than me.
  Has this actually been verified? Using objects for props is exactly what objects are intended for it seems to me, the same set of known keys used over and over. Maps should have way higher mem/perf overhead than objects for props I would assume.

PS. Also how would I access a specific prop in a universal way? Not possible AFAIK.
 > As far as perf goes, having a way to make props immutable (along with state) would allow us to more effectively perform equality checks in shouldComponentUpdate

@dmhood Objects can be immutable too and immutability in itself is not enough to get away with a simple equality test. I don't know how you would even go about universally reusing non-mutated "props" between renders.

> there are many very well known old tricks to supporting the hash map interface while incurring very small overheads - a common approach is to encode small maps (which are very typical in many programs including React) as arrays.

@swannodette Certainly, but that's just making them faster, it doesn't make them "as fast". An object (with a hidden class) should be be cheaper to instantiate, use less allocated memory and be faster to access. An object seems like the obviously correct DS for props (and state too) if you ask me, maps haven't replaced objects, they replaced objects-as-maps.

Anyway, I assume CJS sees it differently and it might make sense for you, but AFAIK it doesn't make any sense for "regular" React and would even come at a big "cost".
 @skrat `this.props.foo` vs `this.props.get('foo')` (you can't have both), then there's also memory and perf which may be more or less measurable.
 @swannodette 

> A huge bottleneck this removes is the Object iteration cost that React eats everywhere during reconciliation.

Object iteration is not slow AFAIK, but `hasOwnProperty` is at current relatively very costly (but not in IE11), but if that's really a problem then as soon as we drop IE8 it's should be safe to proceed under the assumption that no environment worth supporting breaks the object prototype I would say. There's also #3227. Or you could also provide an abstraction that returns an object and a list of keys thus you avoid the `hasOwnProperty` check without having to resort to other overheads related to maps.

http://jsperf.com/objvsarrxyz (and this doesn't include the overhead of actually dynamically creating and accessing the underlying array structure)

APIs shouldn't be designed from the standpoint of current performance characteristics if you ask me.

> Couple this with the memoization story this provides I suspect Immutable.js Map props based programs will kick regular React ones in the ass.

How would you (realistically) perform universal fast memoization for "props"? Perhaps I'm missing something but I can't see how you would accomplish that.

Also, memoization should work equally well for objects as it does for maps, it doesn't favor one or the other.
 > Why can't we have both? It seems like we could change the createElement function to accept a constructor or a collection (like an immutable map) and then it could be smart about building the right type of props object. // cc @brigand had some suggestions

@dmhood #3228

> It's not that just making them immutable will give us equality test

@dmhood It won't for "props" (at least not more than object already does).

> but adding the map interface will allow us to more easily use libraries (again immutable.js/clojurescript/etc.) that bring along the features we need for it (https://github.com/facebook/react/blob/master/docs/docs/11-advanced-performance.md#immutable-js-to-the-rescue).

@dmhood But my point is that I don't understand why you want that, "props" should be considered a class of sorts (a fixed structure), not a dynamic map of keys. Just like you wouldn't expect an "options"-object to be a Map. I don't see what benefit you expect to get from using a library to construct "props". In 99% of the cases only the values are dynamic, not the keys so the library just adds overhead.

> the only readable way to do it requires compile time transforms for non-changing props.

@brigand Yes certainly, but that only works for truly static "props" and it works equally well for objects as it does for immutable Maps.
 @dmhood `Object.freeze(...)` works for that (and will be "forced" I believe).
 @cigitia My unofficial answer to 1 and 2 is no. I just can't see the benefit of using a library for constructing the props object, if you have an example where it makes sense please share it. But from my perspective you're just making it more complicated, adding overhead and breaking compatibility between components for no benefit.

PS. `key` and `ref` are already separate from `props`.
 @cigitia As for 4, `style` is inside `props` and is technically unrelated to this, this discussion is about the universal restriction on `props` having to be an object. The interpretation of `style` (and other properties) is the responsibility of the component (in this case `ReactDOMComponent`) and if there's no technical reason (say performance) then I'd imagine it will be supported through generic iterators in the future.
 @skrat

> @syranide You seems to the only one in this thread not seeing the benefits of using anything else than POJSOs for props objects. No offense but there are many that see it, the reasons were explained here. 

Could be because it's an issue about people wanting that feature no? :)

Anyway, my perspective is purely logical/technical, if someone can show me an actual example where it makes sense to do it then that's fine, but I can't think of one and so far there's just talk (I get that it might be natural for OM, but that's besides the point IMHO).

There's a clear distinction between what objects and maps are good for, objects are a perfect fit for `props`; should only have a fixed set of known keys, values can have any type, they're small in size, they're fast to create and they're fast to access. They can also be immutable. So why do you need immutable-js or w/e for `props`?
 I think we can support this when createElement is bypassed, which it is (or can easily be) in environments like Om. defaultProps and propTypes won't work but I think everything else can‚Ä¶
  This was fixed in https://github.com/facebook/react/pull/3271
  It is :+1: (and it's overloaded)
  Thanks! In the future, could you fill out a description here so its easier to understand _why_ you made the change.
  @Simek, are you interested in addressing the comments?
 No updates and don't feel like this is important enough to push through, closing
  Yes
 The syntax is the same; ES6 classes don't affect this at all.
  That doesn't actually work for `valueLink` I think?
 It should also reset to `defaultValue`.
 @martinstein The only way to clear uncontrolled inputs is to physically set `.value`, that's just how they work and this wouldn't change it. When going from uncontrolled to controlled it should either keep or reset the value, anything else is arbitrary if you ask me... and keeping the value is out of picture. cc @zpao 
 > ‚Ä¢Now the user changes to a different one, whose description is  null . So, of course, the textarea value should be cleared / set to empty. Because of this issue, the old user's description stays, which is a bug.

Yes, so `defaultValue` should be an empty string.

> Of course, after the user has changed, the textarea is still/should stay controlled even though the value is now  null . After all, it's still the same form, only the value has changed from "something" to  null .

Huh? If `value == null` then it is by definition uncontrolled?

PS. It seems like you're thinking about this from a use-case perspective, that's something you should implement as a custom component, wrapping an input. This has to make sense from a technical perspective in React, where all you know is that you're going from one state to another, but more than that, the previous state is irrelevant. Rendering with the same props, at any time, should present the same output except for uncontrolled inputs, but rendering an uncontrolled input should either set it to `defaultValue` (because there was no previous sate) or do nothing at all.
 @iam4x Just because it resets doesn't mean it's a good idea to rely on this behavior. `null` switches controls into becoming uncontrolled, which is not what you really want.
 Superseded by https://github.com/facebook/react/issues/5013
  How could React know what context to use? The event handler is attached to the `<button>` DOM component ‚Äì React could use that as the context when calling the callback but you probably wanted the `<Button>` composite instance, which isn't directly tied to the `<button>` element you're returning.
 We've explored other ways that doesn't require binding at all. That would require massive changes to the framework but we have not yet found one that works and is as idiomatic as binding a callback. The only way we would move away from callbacks completely into a fully declarative model with some kind of signal/channel/event. However, IMHO, this API design is still an unsolved problem.

Therefore, the data structure that we use for "events" are callbacks. To do this we need to combine it with a particular instance since you can have multiple instances of a component on the page at any point. We use binding for that. HOW you bind it is up to you.

The most important task of React is to provide an idiomatic component boundary so that different components can interop. This issue is purely about how you implement your own component. It doesn't matter how your component does it as long as it does somehow. You can do it however you want and they'll still work in the larger community.

Therefore, I don't think we'll put anything opinionated like this in the framework.

We'll just recommend using property initializers with an arrow function as one way to do it. @jeffmo is presenting this to the TC-39 committee next week so things are moving along. Babel will adjust to support them.
 @arackaf Imagine something like `<Foo><div onClick={this.onClick} /></Foo>`. It will be created in `this` component but it will pass through `Foo`. Foo can currently intercept it, clone it and do whatever to it. Technically we could track this through the magic "owner" property (which is how refs work) but that was deemed to magical and breaks a number of optimizations and use cases in subtle ways. We hoped to get away from such magic semantics.
  > Never mind, I realized this can be accomplished quite easily by just setting the key to a unique value wherever you wish to remount the entire tree.

This would destroy the existing DOM though.
 @wmertens `React.Children.forEach` returns elements (not components) so you can't call forceUpdate.  Regardless, the OP already linked the relevant issue (#2517).
 FWIW I maintain https://github.com/gaearon/react-deep-force-update for my hot reloading purposes but it relies on React internals.
  In the docs we do say that we require a console polyfill for browsers(/engines) that don't support it:

http://facebook.github.io/react/docs/working-with-the-browser.html#browser-support-and-polyfills

Doesn't sound like there's anything else we need to do here so I'm closing this.
  Thanks!
  ![facepalm_227785](https://cloud.githubusercontent.com/assets/8445/6048183/69dc80e8-ac63-11e4-837a-34d88e5dd14a.jpg)

Thanks!
  I think we should update https://github.com/facebook/react/blob/master/npm-react/react.js for consistency as well.
 Not sure what this actually solves when this change is within the React package. If we switch to CommonJS, these will all become relative paths instead of providesModule, which will presumably break Flow inside React Core anyway. The name of the top level is then determined by the package name (or magic dir internally), which means that the name of the React.js source file in this package doesn't matter.

Where will the `providesModule React` alias go internally?
 I guess this could be an incremental step, but to make this a magic dir CommonJS package, we shouldn't refer to our own package name internally. To avoid name conflicts with any internal aliases, we could renamed this providesModule to `ReactClassic` or something.

Then we expose this package "main" as `react`. Either through a magic dir or just an internal alias.
 @zpao @sebmarkbage Did we want this in 0.13? Milestoning so we don't forget.
 @nmn Why is this relevant to you?
 (Didn't mean that to sound combative ‚Äì just didn't think this was causing problems for anyone and would like to know what you're experiencing.)
 @spicyj Is this still on our todo list, or is this something that we don't care about / there is no reason to fix?  Can we close out the issue?
 it's on the todo list
 We‚Äôre trying to close stale PRs and get better at being decisive and reviewing them quickly. I am closing because we recently created #6336 to track this, and if we decide to proceed, this PR would need significant updates anyway. Cheers!
  Since this is an artifact of using jstransform / esprima, I filed an issue elsewhere - we'll pick up any changes from there. Tahnks for filing!
  We actually generate the gh-pages branch from source files. We actually need to edit https://github.com/facebook/react/blob/master/docs/404.md. Want to do that?
 This is low pri and you won't be able to use this PR anyway since you'll need to diff against another branch. So in the mean time I'll close this out. But feel free to followup whenever.
  Thanks! I understand the struggle with `itemId`. I actually prefer `itemID` and think it's more idiomatic (I like to pretend `document.getElementById` is capitalized differently). Let's do that and be internally consistent. You _might_ need to include a capitalization mapping lower down, but I don't think so (I can't quite remember, so if you could do a build and do a quick test to make sure changing a value across renders works, that would be awesome! We don't have a good system for automated property testing)
 Awesome, thanks!
  Hmm, since this is actually a parse error, can you file an issue in https://github.com/facebook/esprima? There's nothing we in React can do about this.
  Thanks!
  cc @sebmarkbage, I think this might just be a devtools issue (not new since this is with 0.12)
 It is because they're wrapped by React in a composite and devtools exposes both instances. Was sort of a weird artifact, but not bug. I think that in 0.13 they're deduped but I'll make sure since devtools is broken for 0.13 atm.
 I think we're content with this behavior for now so I'm closing this out.
 This should've been fixed in 0.13 yes

> On Feb 26, 2015, at 3:42 PM, Ben Alpert notifications@github.com wrote:
> 
> I think we're content with this behavior for now so I'm closing this out.
> 
> ‚Äî
> Reply to this email directly or view it on GitHub.
  :thumbsup:
  Nope, not intentional. Thanks!
  Yea, this would be a pain BUT I don't want to write it off completely. Streaming markup to a browser is definitely a thing that people do and our server-side rendering story isn't great.

It might turn out that it's not realistic with the way React is architected but if somebody wants to investigate, I'd be interested in hearing how it goes.
 @jussi-kalliokoski @zpao This should be quite simple for now, #1542... but it might not be in the future...?
 @syranide yea, I was thinking of that PR. But even that has the big assumption that it's all flushed at once. I haven't worked with streaming markup and don't know what might have to change. Though if we're only doing it for `renderToStaticMarkup` it might not actually matter too much.
 @zpao Well it's built like that, but replace `array.push()` with something internal and voila...?
 > a synchronous  .renderToString()  that takes > 50ms for trivial view hierarchies seems super-problematic.

@busticated I don't have any hard facts at the moment, but that makes no sense to me. Performance definitely is not that slow, they're probably running the DEV-version av React (which is far slower) and there's probably something else that is funky as well. I'm guessing he's not counting the DOM components either and generally have really large components.

Also, caching is and always has been the answer to this, it's not any different with React.
 @jussi-kalliokoski Ah, thanks for the update!
 @jakearchibald Can you help me understand how streams could help on the client for us? Would there be some way to set innerHTML to a stream or were you thinking of something else?
 Thanks for the references.
 @AbrahamAlcaina Yes, we hope to implement some optimizations like that.
 @mufumbo We don't have any easy wins to suggest right now, sorry. We're planning to spend time working on performance over the next six months or so and hope to improve this but it sounds like React might be too slow for server rendering for you right now.
 @mufumbo: As @spicyj said, we're not ready to give actionable advice on ways to make rendering faster, but it is something we're actively working on.  I've literally spent the last two weeks pouring through flame graphs (not my idea of a vacation).

The lowest hanging fruit:
- Don't keep any internal state when generating the initial mount images.  Currently `React*Component`.`mountComponent` side effects and is not idempotent.  All the state created is unnecessary when rendering to static markup, so tracking that state is a waste of cpu cycles.
- Don't generate a string.  Streaming the output is not only good for sending the partial renders; it's also good globally and is measurably cheaper than returning a string.
- Flatten the call tree.  You're paying approximately one thousandth of a millisecond for every function call.  Call them thousands of times, and the milliseconds start to add up.  All the injected plugins are hurting performance.
- Turn off sanity checks.  Our security/sanitization protection is there to keep you safe, but if you're 100% confident in your code, turning it off has very measurable performance benefits.
- Turn off checksumming (https://github.com/facebook/react/issues/4401).  Again, it's there for your protection, but if you're ready to take off the guards, you can save a few cpu cycles.

But realistically, none of that is actionable advice for you because the changes either require large code refactors that are extraordinarily complex (work in progress), or require disabling features that we believe are critical to the practicality of React.

We will continue to work on this, and we'll continue to post on github when we have useful information to disseminate.  In the mean time, just hold tight and know that we're doing everything we can to make React even faster!
 @mufumbo Are you using `require('react')` package directly from npm? If so, there is an unfortunate perf problem due to how `NODE_ENV` is checked (see #812). If you require `react/dist/react.min.js` instead (and `react/dist/react.js` in development for better warnings), you may have vastly improved perf. One way to do this is to make `node_modules/react.js` a file like this:

```
// node_modules/react.js
if (process.env.NODE_ENV === 'production') {
  module.exports = require('react/dist/react.min.js');
} else {
  module.exports = require('react/dist/react.js');
}
```

Let me know if that helps at all.
 That's probably the only easy win I have to suggest, sorry. :)
 While I think this is a great discussion, we've wandered way off the topic of "streaming markup". I encourage you to use an alternate venue for this discussion so that we can make sure people watching the repo can maintain a better signal to noise ratio. We set up https://discuss.reactjs.org precisely for discussions like this :)
 Please continue discussion at https://discuss.reactjs.org/t/whats-the-best-way-to-unblock-the-node-event-loop-due-to-slow-react-server-side-render/1817/1 instead.
 Might be worth moving discussion about your specific project out of here and into that project's issues or a discussion forum like the one @spicyj linked to above to avoid notifying a bunch of people here. The project is relevant to this issue but the ensuing discussion isn't quite. Definitely keep us in the loop when you feel it's stable though.
 We will update issues when we have updates. If you don't see anything from us, it's safe to assume there are no updates.
 > And three months is probably a reasonable amount of time to wait before checking to see whether it's still be worked on.

Nowhere in this thread did anybody from React team say they worked on this. [react-dom-stream](https://github.com/aickin/react-dom-stream) is a third party project by @aickin, so feel free to try it and assess its stability and performance.

It is great that people explore this space but I want to clarify that streaming `renderToStaticMarkup()` is not currently being worked on by anyone on the React team to the best of my knowledge. The core React team has limited resources, and other issues are currently a bigger priority to Facebook.

Subscribe to this issue if you are interested in the updates but please consider other people subscribed to this issue who don‚Äôt want to receive this kind of back-and-forth talk. We will definitely post updates when and if there are any. In the meantime please feel free to contribute to the [relevant discussion thread](https://discuss.reactjs.org/t/whats-the-best-way-to-unblock-the-node-event-loop-due-to-slow-react-server-side-render/1817/5). Thank you!
  Going to close this out and let discussions go in the other repo.
  Thanks!
  It may have had some reason in but it looks unnecessary. Feel free to get rid of it!
 Fix will go out with next docs push. Thanks again!
  This is because we actually use the `click` event for checkboxes in our attempt to normalize the change handling. `preventDefault` actually makes the browser not visually update, even if it is actually toggling `checked`. You may actually want to use `stopPropagation` instead, depending on what you're trying to achieve.

Here's the minimal example duplicating what's happening, in pure JS: http://jsbin.com/ludogufaqu/1/edit?js,console,output (fun fact, putting the `node.checked` toggle in a `setTimeout` will make this work).

Now about _why_ the browser acts like this, I don't know :/
 No, its an implementation detail that you shouldn't have to worry about, but sometimes it becomes slightly relevant.
  Yep, @vsiao is right. We haven't updated docs yet but we will as we approach 0.13 final.
  Done in the other PR, thanks though :)
  Hey @charlieschwabacher, thank you for the PR. 

We try to avoid adding new features to `TransitionGroup` these days. Addons are mostly in maintenance mode now, and it might be a better idea to fork it and create your own package if you feel strongly about this feature. Some ideas from such forks do actually make it back to the official repo, e.g. that happened to https://github.com/Khan/react-components/blob/master/js/timeout-transition-group.jsx.

We don‚Äôt use `TransitionGroup` that heavily at Facebook, and seeing that it already has a bunch of bugs and browser incompatibilities due to its heavy reliance on CSS animations and events, as well as unorthodox handling of React children and calling instance methods on them, we are reluctant to make it more complex than it already is.

For a more React-friendly API that doesn‚Äôt rely on CSS animations and events, I would suggest you to take a look at https://github.com/chenglou/react-motion.

Thank you for contributing, and I‚Äôm sorry we left you out in the cold with this PR. Cheers!
  Thanks!
  Thanks!
 This breaks the sizing of code in headers and anywhere else the normal text size isn't used, such as here:

https://facebook.github.io/react/blog/2014/07/13/react-v0.11-rc1.html#rendering-to-null
 CSS is the worst
  Thanks!
  :thumbsup: thanks!
  Oh man, I hate these headers and the silliness that comes every year because of them.

Thanks though! It makes my life easier when somebody else does it :)
  I think there's definitely a transition period until everything fits into place neatly and ESx catches up, but I think the vision behind the current direction is as sound as they come. Instead of using the vendor specific `React.createClass` with vendor specific behaviors and features which does not interop with other libraries, why not use native classes?

Sure there's a lack of mixin-support in ES6, but there are ways around that. Property initializers are not here yet so that uglies it up a bit too and ES6 classes are not auto-bound which kind of sucks I guess, but property initializers will be the rescue there as well it seems. So yeah, using ES6 classes is still early perhaps, and if you choose to use them you are an early adopter in some way I would say. `React.createClass` is still there.

But the great thing about using native classes? `React.createClass` is now just _one_ way of creating classes, if there's one you prefer more out there you're now free to use it and when native classes are ready in your eyes, you can slowly migrate away from whatever class helper you were using. React has no longer decided for you what is best for you, you're free to use whatever you want... that seems amazingly great if you ask me, I don't see the issue.

**EDIT:** In my words, React is moving in the direction _away_ from unnecessary forced opinions and library bloat. React is not a class library, it's a view framework, so why should it be forcing a certain class library on you and X, Y and Z. React should focus only on what is the best future implementation, everything else the community can provide (or official addons if absolutely necessary), everyone has a different opinion on what is the right way, now everyone has the freedom to choose.
 @srcspider I feel like there's a misunderstanding here, before all you had was `React.createClass` and now you can use that or any other library or native class implementation you like. I don't see the problem; if you don't like ES6 classes don't use them? They're just syntax sugar really anyway. Keep using `React.createClass` if you prefer it?
 Thanks for all the feedback!  It's good to know what the community is thinking.  Some people love ES6 classes, others don't like them as much.  Fortunately, React lets you choose which syntax you'd like to use.

As @syranide, @brigand, and @gaearon mentioned, the change makes React classes less react-specific and makes them more interoperable with other libraries (and even other languages/dialects).  It also reduces the learning curve, since all javascript programmers will soon be familiar with ES6 classes and won't need to learn the special semantics of our magical React.createClass method.

Having said all that, we do use mixins internally, and are abundantly aware of their usefulness (We may see mixins return in ES7 classes).  As others have mentioned, you're free to continue using React.createClass() if you prefer that style.

I'm going to close this issue, since it's not technically a bug.
  This diff enables setState to accept a function in addition to a state partial. If you provide a function, it will be called with the up-to-date `state, props, context` as arguments.

This enables some nicer syntax for complex setState patterns:

If setState is doing an increment and wants to guarantee atomicy, you need a function:

```
this.setState(state => ({ number: state.number + 1 }));
```

This atomicy is particularly important if setState is called multiple times in a single frame of execution as the result of complex user actions. It's a tricky bug to chase down and difficult to determine how to fix when you find it. The current pattern of reaching into _pendingState relies on an implementation detail.

In this example: props.doAction() may result in your ancestor re-rendering and providing you with new props or context. If setState is called directly with an object literal referencing `this.props` or `this.context`, it will use the _old_ version of those values, not the new value. Using a function solves for this case:

```
this.props.doAction();
this.setState((state, props) => ({ number: state.number * props.multiplier }));
```
 Note: `ReactCompositeComponentState-test` will fail now because it relies on `_pendingState` to make assertions.

I'm not entirely certain how to fix because I'm not entirely certain what that test is actually testing.
 @brigand not quite in this case. I'm proposing to keep the same semantics of setState(). I can enable that effect in a separate pull built on this same idea using replaceState().

The semantics of setState() are to return a partial state patch to merge in.
 @brigand - however:

``` js
updateFooBar(value){
  this.setState(state => ({ fooBar: update(state.fooBar, {foo: {bar: {$set: 5}}}) });
}
```
 lgtm. Just needs to fix the existing test and add tests of the new functionality.
 Suggestion on how to approach the broken test? What conditions do we need to test there?

‚Äî
Sent from Mailbox

On Fri, Jan 30, 2015 at 8:30 PM, Sebastian Markb√•ge
notifications@github.com wrote:

> ## lgtm. Just needs to fix the existing test and add tests of the new functionality.
> 
> Reply to this email directly or view it on GitHub:
> https://github.com/facebook/react/pull/2991#issuecomment-72297936
 I think that it is probably better to remove the piece from that test that introspects pending state. Then add another exhaustive test of this new setState-with-a-function. Then assert the sequencing of calling it in the various life cycles. As well as the sequencing of when the callbacks gets invoked. Including what this.state is at various life-cycles.
 Just updated this pull to fix up ReactCompositeComponentState-test. It no longer inspects internal information and in order to test the same lifecycle of pending state, I added more setState() calls and a replaceState() call to ensure they're called in the correct order.

I think this should also cover the usages of providing a function.
 :thumbsup: Feel free to merge when you're comfortable.
 I'm curious, in which cases can props/context differ from the ones in `this`? Or are they just there for completeness (i.e. avoid accessing this, using non-method callbacks, etc).
 Nice, glad my API suggestion was picked up :)
 @syranide If you receive props in the same batch as where you have a state update, then this gets executed before shouldComponentUpdate passing the new props and state, before the instance is update.

@leebyron Your unit test doesn't cover this scenario. ^ Might be worth adding.
 Yes, let me add a unit test to illustrate that case before I merge
 I don't have a strong opinion. There are pros and cons to each. Smaller API surface area vs explicit type definition per method. Both are unambiguous. @sebmarkbage?
 We originally explored something like `enqueueTransaction` which would allow the `setState` within the transaction to keep the pseudo-OO looking API. However, when we realized that we couldn't update `this.state` and `this.props` at the point in the life-cycle where this operation must occur, we decided to go with something more monadic (which is what we really wanted all along anyway).

We evaluated a bunch of options such as `transact`, `enqueueStateUpdate` and `updateState`. I thought `updateState` was too confusing. There is nothing in those names to indicate the difference between the two signatures, `updateState` and `setState`. The only way to tell them apart is by some memorized knowledge. I would definitely screw that up and put the wrong argument with the wrong name.

@vjeux suggested that we'd just overload `setState` and that solved the problem.

We're also planning on overloading the API to accept a Promise anyway so this seems like a good start.

That said, I never really liked `setState` since it is deceptive. It is really scheduling or enqueuing the next state merge. I think that whatever name it has, the overloaded API makes sense.
 I just added a new test which illustrates the values of props and state when dealing with the parent child relationship that led us to this, @sebmarkbage.
  Thanks!
  The contrapositive (which would be logically equivalent) requires flipping the implication relationship.  Logically negating an implication is not necessarily equivalent to the original statement, and in this case, there is a subtle change in the statement's meaning.  Knowing that something does not change over time is generally sufficient to conclude it is not state, but knowing that it does change over time does NOT imply that it is state.  I'm going to go ahead and close this pull request because the old wording is more precise/accurate.
  If you unmount a currently focused node, `nodeCache` is repopulated after being purged and unless that specific ID is revisited later, it will remain there forever. ~~This is mostly likely due to the focus/selection restoration phase after reconciliation.~~

Repro: http://dev.cetrez.com/jsx/nodecache.html (nodeCache is output into the console)
 I'll go ahead and put _good first bug_ on this one, it may be a bit tricky to find the root cause but it should be quite easy to narrow down and the fix should be rather simple too I think. So perhaps not the easiest bug if you're entirely new.
 @javpaw I can have it fixed in an hour or so, but really, just change `var nodeCache = {}` to `var nodeCache = window.nodeCache = {}` and run that code against your own React build and you'll see it.
 Fixed.
 @pletcher You're right that those aren't removed, but they're added only once per document at the top level so that shouldn't really be a problem.
 Yes; the fix is probably to change React's event handling to not fire events on removed nodes. (If another root is still mounted, we can't remove the top-level handler anyway.) cc #3298, #3790
 @spicyj I think we intentionally fire events on removed nodes.  I'm pretty sure there was a unit test for that, ensuring that we fire an event on nodes even if they are removed as part of an event handler as the event bubbles up.
 Yeah, https://github.com/facebook/react/blob/master/src/renderers/dom/client/__tests__/ReactEventListener-test.js#L93

Spec says `it should not get confused by disappearing elements`, which I suppose is sufficiently vague as to imply any non-fatal but still undefined behavior :).
 Yeah, goes back to https://github.com/facebook/react/issues/1105. 
 Nope, thank you.
  This is an implementation shortcoming for now, you cannot clone elements and keep the original ref, nor can you re-add it as "you" would then be the owner of it, not the original owner.
 > So, in the end, there is no way to have an element that will, at some point, be cloned and have a ref ?

Right now, no, not that I know. But this is an implementation issue, it's not intentional.

PS. Accessing children is generally considered an anti-pattern unless they're explicitly "uncontrolled" ("controlled" components are preferable), so it's possible that you may be thinking about this the wrong way and would find using "controlled" components preferable in many ways.
 @jsfb @sebmarkbage @spicyj - did we have a plan to fix this warning / expose something else?
 I think that the warning is still valid, even though the owner is the same. The idea of a ref is to put a unique handle on a component. Kind of a lasso to pull in the real instance once it gets mounted in the tree. If you're overriding it, you're breaking the assumptions of the caller.

The workaround is simply to remove the ref on the original specification:

``` javascript
var myComponentSpec = <MyComponent></MyComponent>;
var myComponent = React.addons.cloneWithProps(myComponentSpec, {ref: 'myref'});
var myClone = React.addons.cloneWithProps(myComponentSpec, {ref: 'mycloneref'});
```

That way it's clear where you intended to have the ref and where you cannot rely on it.

There is a missing feature in React that we should add in the new `React.cloneElement` API. There is no way to preserve a ref while adding more fields.

It should be ok to clone the element without destroying the ref. We could make that possible if you don't try to override the ref field.

``` javascript
var myComponent = <MyComponent ref="myref"></MyComponent>
var myClone = React.addons.cloneWithProps(myComponent, {extra: 'value'});
```
 @myagoo Yeah, that's one of the reasons we're looking at new types of refs so that you can get more than one handle. Some discussion at #3234. Also see #3266 which lets you change props while preserving a ref.

Closing this out.
  @flying-sheep Everyone has different opinions on what is useful/necessary/meaningful though, React.addons.\* is mostly useful for getting started. `classSet` was originally designed to be compatible with CSS class name mangling, meaning it has to be simple so that each class name is easily discoverable.
 We're going to get rid of our helper (see #2910). I've said it in a few issues - it's implementation is stuck because it's tied to how we at Facebook statically transform class names. So we can't change the implementation. And since this really is a common request, I'm going to get rid of ours and tell people to use another one. @jedwatson's https://github.com/JedWatson/classnames is what I plan to point at.
  That is simply not how React is intended to work, it should not work that way and it cannot work that way.

You create elements which you pass to React which basically becomes "I want the view hierarchy to look like this". React then takes that request and creates/reuses/destroys components according to its reconciliation algorithm. If you need access to instances before that you're approaching the problem in the wrong way. React components should _not_ be compared with OOP or more classical object-based view hierarchies. Components are in a sense thin and should not have complex logic, such logic should exist outside of React and be communicated and propagates through the view hierarchy via props.

A parent accessing a child is generally considered an anti-pattern I would say.
 Did you find an alternative that works for you? Can we close this out?
 Were there any docs that were unclear on this point? We can improve them.
  Cool. I think this should be fine. I want to do this one specially since it's internal infra that breaks, not public. So a bit more delay since it requires more work.
 Sorry. Yea, we can have another go at this.
 Awesome, if we can get those updates in & squash the commits, we can get this merged.
 Merged it manually to fix a couple new conflicts. Sorry for the delay!
  Unfortunately right now we can't actually use the latest eslint _quite_ yet :( It's actually in much better shape than it was, but we locked to the version we did because it (mostly) happened to support the same set of ES6/JSX features we use (still used esprima-fb at the time). Namely, all of our code parses, which was important. ESlint 0.11 final and 0.12 didn't support many things we needed. 0.13 is actually looking great, though it's still missing rest args (AFAICT looking at docs).

And you can actually see with Travis that not everything is parsing. Even with a couple more options enabled (https://gist.github.com/zpao/8cae06d2428b64f205c8), `ReactClass` still isn't parsing (this is the rest args case).

I think for now we should leave what we have so we can have Travis fail lint accurately. I'm depending on this to help make sure our internal linting mostly matches up and I don't waste too much time with followup commits here (our linting is mostly stricter on GitHub, though there are some rules turned off because of the same parsing reasons).

BUT I do want this as soon as possible (though I'll say we should just put the features in the config in `src/.eslintrc`) and I'll take the incremental lint fixes in the mean time :) (though I kind of want to lose the goo.gl link - the 80 chars rule is silly). Want to drop the eslint upgrade?
 Going to close this out in favor of #3097. Thanks though @brianleroux!
 :thumbsup: (no underscore)
![tmyk](https://cloud.githubusercontent.com/assets/8445/6117298/4a4f3f0a-b068-11e4-99b8-0f060a618a7e.gif)
  Yea, `instanceOf` is really intended (and implemented as) `x instanceof y`.
 I think something like `elementOfMyComponent: PropTypes.shape({type: PropTypes.oneOf([MyComponent])` would do it. There's some discussion of maybe having `PropTypes.elementOfType` in #4716 but not sure if we'll do it (there's a lot of room for confusion and it really doesn't pair well with specialized components.
  Looks like this is fixed in master already. I'll add a test so it doesn't regress.
  So Firefox is right and Chrome is wrong?

Feel free to fix (either way) with hacky CSS if you want!
 PR is in, this will be all fine the next time we generate the website. Thanks again!
  Feature detection is the go-to solution (at least for now) I believe.

**EDIT:** Supplying an array of rules is complicated because updating any of them would require reapplying all of them in order, which could be quite costly. But this is an area where nothing is really decided yet I believe, but feature detection is the solution for now (or use CSS which is probably preferable unless it's dynamic, which it seems it is).
 Yea, we've suggested feature detection for this case. It's not bullet-proof (eg, won't work for server-rendering).

Otherwise yes, this is an area where unfortunately using objects doesn't work out perfectly. But there isn't really anything we can do, we're not going to change `style` to a string.
  I believe the point of showing the ES3 module pattern is that methods are "auto-bound", so you would get that for free, like you get today with `React.createClass`. You don't get that with the class pattern.
 Not sure if it really matters terribly. There are a bunch of ways to skin this cat. cc @sebmarkbage 
 The point of this example, isn't to show best practices, it's to show that we're unopinionated. The module pattern is a valid pattern. It grew in popularity in the early 2000s.

It is indeed not necessary to inherit from `React.Component`. That is just a way to get some helpers like `setState`. You can also do `React.Component.prototype.setState.call(myObj, {})`. We might add sugar for sideways updating in the future, or you can use side-effect free models like channels/observables to wire up state.

I didn't feel the need to illustrate ES3 classes since ES6 classes are just sugar for ES3 classes.
  Your example correctly yields `false` for me (http://jsfiddle.net/xgdm73a3/).

However, I'm pretty sure the issue you're seeing has to do with mutating objects in state/props. React does not clone objects passed in to state/props, hence, both `this.state.foo` and `prevState.foo` will reference the same object. This is why React advocates sticking to "immutable data", i.e. always create a new object instead of mutating an existing.
 Line 8, you're mutating the state object you try to compare.
 As noted, you're modifying `this.state` directly, which is what's used for `prevState`.
  Duplicate of #1798
 Yup, let's chat in there.
  There is no official proposal yet, no. I assume it will look something like TypeScript, but the reflective aspects and scoping rules will probably differ a bit.
 Not really a React issue, so I'm going to close this out. Lots of discussion on the babel issue:

https://github.com/babel/babel/issues/619
  Oh oops, that's to gh-pages. I'll update the markdown in the right branch so we don't lose it next time we generate docs.

Thanks!
 @zapo: it looks like this got merged into -stable instead of master.  Was that intentional?  Are you planning on cherry-picking it over?

Also, the idiomatic phrase is "with the exception **of**...", not "with the exception **for**..."
 Yup, I did it on stable on purpose, I'll pull it back to master later.

On Jan 29, 2015, at 5:24 PM, Jim <notifications@github.com<mailto:notifications@github.com>> wrote:

@zapohttps://github.com/zapo: it looks like this got merged into -stable instead of master. Was that intentional? Are you planning on cherry-picking it over?

Also, the idiomatic phrase is "with the exception of...", not "with the exception for..."

‚Äî
Reply to this email directly or view it on GitHubhttps://github.com/facebook/react/pull/2971#issuecomment-72138177.
  @ejelome The result of the markdown is `<p><strong>Default</strong> <em>message</em></p>`, `<p><p></p></p>` is invalid markup and the browser mucks with the DOM in weird ways when you do that, so some elements end up outside of the `<p>` you're updating. Hence the behavior you're seeing and React would also start throwing errors if you mutate the elements around the `<p>`.
  Thanks!
  Thanks!

The code works out but the text reads weird now. I think we need to rework it a little bit - this part was repetitive before but it still flowed ok. Now it reads like it's out of order.

Want to take a pass at cleaning it up?
 :thumbsup: this reads much better. Thanks a lot!
  Wow, good call. Thanks!
 Awesome!
  See #2393 for the original issue, and #2497 for the implementation.
 Are we using this internally yet?  We might want to hold off on merging this documentation until we've started using this and validated that the API makes sense and is production-ready.
 I had similar concerns, especially since it doesn't support refs (or context?). @sebmarkbage points out it's a better testing story than anything we have currently, though.
 I think we should probably start talking about it and getting people to use it. We're a slower moving ship so it's harder to steer but getting feedback from people who can move a bit faster would be worthwhile and will perhaps get us to the best shape possible.

We should probably enumerate any limitations though (and perhaps label it as "beta" or something just so people have an idea of what they're getting into)
 @jareware: the motivation is to be able to test just one thing at a time (i.e., unit testing). Say Foo's render method returns `<div class="foo"><Bar /></div>`. It's useful to test in isolation without worrying about how Bar behaves. You couldn't do this before. If, however, you want to do more of an integration test, you've always been able to render all the way down and assert properties of the DOM.
 @jareware Correct.
 @graue let me know if you have any updates you want to make before this gets merged. Otherwise I'm happy with it.
 :shipit: 
 Thanks :)
 Aww, this doesn't seem to have made it into the [changelog](https://facebook.github.io/react/blog/2015/03/10/react-v0.13.html)...
 Oops, our mistake‚Ä¶
  Thanks!
  This discourages reaching into internals like
._reactInternalInstance._pendingState
 Is this going to cause any issues with multiple instances of React on the same page? I don't think so but wanted to confirm.
 oh. It might mess with our unit tests since we have multiple versions of React there. Will test internally.
 @sebmarkbage Did you want this in 0.13? (Milestoning so we don't forget.)
 It might break even more uses of multiple Reacts. Let's fix it later.
 @sebmarkbage Kind of related; this would also break the internal `deepForceUpdate` of [react-hot-loader](https://github.com/gaearon/react-hot-loader), it's imagineable that it could be temporarily worked around regardless of this (it should be easy to discover the random key). A blessed `React.forceDeepUpdate(instance, callback)` or w/e is probably the preferable some point anyway I assume, but outright breaking react-hot-loader would make me very sad :)

cc @gaearon
 That falls in the category of development tools like the React DevTools.

I would like to formalize a standard API that can be used to attach this API to an arbitrary React instance from the outside. Without needing to include the actual code for this in React itself.

> On Feb 26, 2015, at 2:33 AM, Andreas Svensson notifications@github.com wrote:
> 
> @sebmarkbage Kind of related; this would also break the internal deepForceUpdate of react-hot-loader, it's imagineable that it could be temporarily worked around regardless of this (it should be easy to discover they random key). A blessed React.forceDeepUpdate(instance, callback) or w/e is probably the preferable some point anyway I assume, but outright breaking react-hot-loader would make me very sad :)
> 
> cc @gaearon
> 
> ‚Äî
> Reply to this email directly or view it on GitHub.
 > React Native views are optimized, and calling forceUpdate() just on your own components doesn't cut it

I'm not sure what this means, sorry?
 Got it.
  I may be wrong, but I think this is generally problematic unless `React.Children.filter` would replace filtered children with `null` or `undefined` rather than compact the array (which you can/should do with `map`). If the filter is in any way dynamic and the children aren't keyed then the reconciliation will suffer badly.
 `flattenChildren` returns a keyed object, this is deprecated (keyed objects) and will not be supported soon AFAIK (`Map` will be, but then you'd have to polyfill or wait for ES6).
 @arendjr I'd call that bad practice, `Tab` and `TabButton` are unrelated and should be provided through separate props, not as a mixed soup of children.
 @syranide I'm not sure I agree that this is bad practice.  It seems perfectly reasonable to me that a parent component might want to have arbitrary behaviors based on their children.  In particular, if components want to preserve the absolute ordering of the child components, there isn't really any other way to do it (do the tabs come before/after the tab buttons? or do they alternate? or are they otherwise mixed?).  I agree that's not what he is doing here (he doesn't appear to be preserving order), but I think it's a completely valid use case.  You could imagine someone implementing a "smart div" that does fancy layout things, and treats some components differently from others (obviously it's natural to have a mixed bag of children).

Given the simplicity of @ofersadgat's implementation, I'm not convinced it makes sense to pollute the API space by providing a filter function.

@syranide I agree reconciliation would suffer.  Maybe a `React.Children.filter` would warn if children do not have keys?  That is almost a reason to provide this function, to add a warn hook.

It's probably a separate issue, but as @gaearon suggested, it seems like there should be a natural way to get children as a (potentially empty) array.  `Children.toArray` might be a nice solution to this issue.

cc @spicyj 
 > I'm not sure I agree that this is bad practice. It seems perfectly reasonable to me that a parent component might want to have arbitrary behaviors based on their children

@jsfb A very broad subject it seems to me, processing children is not inherently bad, I think it depends on what you're trying to accomplish. If children need to be separated out it's _likely_ that they should be separate props to begin with or the should be API redesigned somehow, 

> You could imagine someone implementing a "smart div" that does fancy layout things, and treats some components differently from others (obviously it's natural to have a mixed bag of children).

Sure I can imagine that, but I'm not quite sure when that actually makes practical sense and if there aren't better solutions to the problem. Inventing non-standard behaviors on a per-component basis seems like it should be a last resort, to be used only after you've concluded that established practices isn't a good fit. It shouldn't be all-or-nothing, just because children can be used and looks pretty, doesn't mean they should.

The solution could imaginably be `<Tabs tabs={[...]} />`, it's no longer an opaque structure and the special behavior likely apparent to the user as well (just saying). If you ask me, each tool should be used only for its intended purpose, children has a purpose too and I think it's a mistake to expand that definition unless we're sure it makes sense.
 I agree that it depends on what you're trying to accomplish and that it's likely they should be separated out if you're going to try to filter them anyway.  But if someone desires a heterogeneous list of components (usually due to ordering concerns), I think that's a perfectly valid use case, and 'children' may be a natural place for those to be defined.  We should be providing reasonable support for that use case.

At Facebook, it's common to branch based on the type of a child.  Popularity at Facebook doesn't necessarily imply that it's a best practice, but it is a common use case that we do support.  I don't know what percentage of those use cases are doing a `filter` operation (I imagine it's not a large percentage, because presumably the reason to use a heterogeneous list is to maintain order).

Having said that, I'm still not entirely convinced this feature (`React.Children.filter`) makes sense / justifies the API creep.  The only real advantage I see is that it gives us an opportunity to warn about unkey'd children.
 It's true that Facebook has existing components that branch based on the type (or position) of a child, but it's usually a better idea to pass separate components explicitly. Instead of

``` js
<LeftRight>
  {left}
  {right}
</LeftRight>
```

you can do

``` js
<LeftRight left={left} right={right} />
```

which is more explicit in addition to being easier to implement. Going back to the original issue, we were considering implementing some sort of `React.Children.toArray` which clones children and re-keys them appropriately. For example

``` js
React.Children.toArray([
  [<div key="monkey" />, <span key="gorilla" />],
  <input key="gorilla" />
])
```

would return something like

``` js
[
  <div key="0.$monkey" />,
  <span key="0.$gorilla" />,
  <input key="$gorilla" />,
]
```

which is more or less how React flattens children internally. At that point you could manipulate the array in whatever way is most convenient.
 We have React.Children.toArray now.

@kidwm Not sure I understand what you're trying to do there.
 I don't know what key problem you're trying to solve. If you explain it maybe I can help.
 Something like this would work:

```
const slides = React.Children.toArray(this.props.children);
const slidesA = slides.map((el) => <li key={'A-' + el.key}>{el}</li>);
const slidesB = slides.map((el) => <li key={'B-' + el.key}>{el}</li>);
const wrappedSlides = slidesA.slice(-1).concat(slidesB, slidesA.slice(0, 1));
```

though exactly which keys you should assign to which elements depends on how you want to preserve each child's state/identity.
 Yes, that also works. But you rarely want the index as key.
 I'd suggest copying the Children object instead of mutating it so it's clearer when you're using your util and when you're not.
  In our [http://facebook.github.io/react/docs/dom-differences.html](docs) we mention this:

> The `onChange` event behaves as you would expect it to: whenever a form field is changed this event is fired rather than inconsistently on blur. We intentionally break from existing browser behavior because `onChange` is a misnomer for its behavior and React relies on this event to react to user input in real time. See Forms for more details.

Browsers already implemented this event inconsistently and we decided long ago to make it do what most people actually expected the event to do, tell you when a value changed, not at some point after the input lost focus.

If you'd like, you can use a combination of `onFocus` and `onBlur` and compare values to recreate somethng like the native event. Alternatively I _think_ `change` is one of the events we actually make use of to build our `onChange` behavior, so you could potentially still just use `onChange` in React, then in your event handler only run code if `event.nativeEvent.type === 'change'`
  Awesome! A few comments incoming, but overall it looks good.
 Awesome, thanks! I think this will be helpful.
  What does your style property look like?
 The prefix should be `ms`, hence `msTransform`. I believe what's happening is simply that React is setting unknown styles as well in the initial markup, but when it goes to update `node.style.MsTransform` it's an unknown property and hence the property change isn't reflected in the DOM.

@zpao Considering we enforce the camelCasing for everything else, how 'bout we do the same for vendor-prefixes and change to `oFoo`, `msFoo`, `webkitFoo`, `mozFoo`, etc? (Or at the very least change `ms` to `Ms` to be consistent... **EDIT:** but then we'd have to check/transform all style names, bah! But perhaps it makes sense to keep a CSS whitelist too? For much needed warnings...)
 We follow the same rules here that you must follow when setting styles directly from JS. I don't know the history but Microsoft didn't follow the rules for vendor prefixes (to be fair the rules might not have been standardized when they started). So `msWhatever` is the exception to the rule. 

The reason this works on first render is that we have to transform the JS style name to the CSS one, which follows a simple pattern - take each uppercase letter and replace it with a hyphen and the lowercase version. So `MsTransform` becomes `-ms-transform`, which is actually the right thing. But then on updates we don't update the style (we do actually try) because `node.style.MsTransform` isn't a property IE knows to parse.

We actually have a warning for bad vendor prefixes (https://github.com/facebook/react/blob/master/src/browser/ui/dom/CSSPropertyOperations.js#L38), but we don't check for `Ms`. Perhaps we should.

@syranide we don't enforce camelCasing for style properties, the browser just does that for us, so I don't think we should deviate here and use `Ms`.
 @zpao But... `node.style.webkit*` is used by Webkit, but we enforce uppercase I think? I always thought that the camelCasing in React was largely from the perspective of the JavaScript implementation of the DOM, not the HTML. So it seems to me it makes more sense to use `webkit*` rather than `Webkit*`.

Also, if I would hazard a guess, I would say that the leading hyphen in `-webkit-*` only signifies it being unofficial. It doesn't make sense that it would be added because the CSS property really is intended to be read as `Webkit*`... which also matches the fact that `node.style.webkit*` is the vendor-prefix in JavaScript.

Or?
 Yea, I can't actually find anything talking about any official rules. I thought I had at some point. Ah well. Regardless, Webkit actually makes both work, `webkitFoo` and `WebkitFoo`. I'm not sure which is the primary but they can be used interchangably.

> I would say that the leading hyphen in -webkit-\* only signifies it being unofficial.

I'm not really sure what you mean here. All CSS vendor prefixes are "unofficial". Most are not intended to live forever as specs develop. Others are just totally off-spec and might never become a standard.
 > I'm not really sure what you mean here. All CSS vendor prefixes are "unofficial". Most are not intended to live forever as specs develop. Others are just totally off-spec and might never become a standard.

@zpao Ah, what I meant was that I'm pretty sure that `-webkit-whatever` is meant to be read as `webkitWhatever` (as it actually is in Webkit, not all browsers though) even though it _technically_ should be `WebkitWhatever` due to the leading hyphen... but... I guess there's something to be said in-favor of `WebkitWhatever` and that would be that there cannot be accidental conflicts (however unlikely) and again kind of speaks for its "unofficial" nature.

So regardless of which one is preferred, it makes sense to me that React should normalize and use the same casing for all vendor-prefixes. It's also really weird currently because the JavaScript-prefixes are `webkit, ms, Moz, O` but React has it set to `Webkit, ms, Moz, O` which makes no sense at all to me?

**EDIT.** `webkitWhatever` is the correct one I assume, as it's the only one that is shown in the auto-complete list (hence what my reaction to `Webkit` being used in React rather than `webkit`).
  cc @sebmarkbage 
 Our policy is that execution flows shouldn't differ between `__DEV__` and production modes. This will throw on an invalid prop type in `__DEV__` but not in production. This can have unforseen consequences. E.g. a component only shows up in production but is completely hidden in development.

If you switch to use the `warning` module instead of an `invariant`, like checkPropTypes does, you can avoid that problem. Also, make sure that nothing along the way to the warning throws.
 Looks good to me!
  I think that instead of adding more context to the message, we'll want to do the validation earlier. E.g. when the element is created.
  This looks good ‚Äì will merge after 0.13.
  I'm game. Eventually we might want to move docs elsewhere but until then, I think it's a great idea to have them all checked in here. I know they'll fall out of date and we don't do a good job of publicizing the translations, but we can solve that later. Send a PR whenever you're ready!
  Would probably be a good idea to add a info/notice/warning if the transpiler notices some .jsx files but isn't converting them, since a user probably intended to have the devtools convert their jsx files.  #goodfirstbug

PS: Hey DC!  Glad to see you're using React!  We should go do the dish run again some time, I'd be curious to hear how your web-based gpg client is going!
  Mostly looks good ‚Äì just a few inline comments. Let me know if you have any questions.
 Looks good to me.
  Nice! We'll need to figure out how to statically type spyOn but at least now it's consistent.
 Awesome, let's do it. Thanks!
 I think we may have added some more. :)
  Thanks!
  We're currently validating the propTypes in production mode. We should probably not do that. It's wasted effort since they're not used.

It also means that you can play around with propTypes without fear of breaking production code.
 Not this one. https://github.com/facebook/react/blob/4486a17c248e1927fcfa3c4266a195300b5bc491/src/classic/class/ReactClass.js#L365
 @kentcdodds It looks like @jergason is already working on this. You might want to coordinate with him or follow up on the PR #2948 
 @kentcdodds  https://github.com/facebook/react/issues?q=is%3Aopen+is%3Aissue+label%3A%22good+first+bug%22
 Closed by https://github.com/facebook/react/pull/2948
  I actually think we should just not update this and instead leave a note at the top saying that this has been made a part of the flux docs, linking to its final home http://facebook.github.io/flux/docs/testing-flux-applications.html. I'm pretty sure we've already updated that since so it's surely out of sync.

So I'm going to say no to this but feel free to make a new PR adding a note.
  DON'T GET TOO EXCITED, this probably won't work. This issue is more about documenting why we can't do it.

We could consider using [JsonML](http://www.jsonml.org/) as the notation for [ReactElement](http://facebook.github.io/react/docs/glossary.html#formal-type-definitions).

This would make this **JSX**...

``` javascript
render() {
  return <div className="container"><FancyButton disabled /><span /></div>;
}
```

...which **currently** looks like this...

``` javascript
render() {
  return { type: 'div', props: { className: 'container', children: [
           { type: FancyButton, props: { disabled: true } },
           { type: 'span' },
         ] } };
}
```

...into a **much nicer** non-JSX declaration.

``` javascript
render() {
  return ['div', { className: 'container' }, [FancyButton, { disabled: true }], ['span']]
}
```

It would also align us with a spec which is not ours. Almost like a standard.

**Children are Special**

JsonML is designed in a way that children can be distinguished from other attributes. We don't really care about this property because we've already merged them, but we could undo that. NBD.

One problem is that you constantly need to slice off the children from the outer array as you're passing it into a component. This can become a performance problem.

**`key` and `ref`**

The problem with JsonML is that we don't have a way to attach custom attributes to the element, that are not props. I.e. `key` and `ref`. It is important that these are treated differently than other props because they should not be available to the component itself. Conceptually the parent is responsible for keying the element and changing the key should not affect the behavior of a component. Same for refs. It is also important that props can be transferred to a child without that affecting its behavior.

One possible solution would be to wrap the elements in another object:

``` javascript
renderButton(data) {
  return { key: data.id, element: [FancyButton, { disabled: true }] };
}
render() {
  return { ref: c => this.container = c, element:
    ['div', { className: 'container' }, this.props.data.map(this.renderButton)]
  };
}
```

It's still ugly. It also means that you now have to reason about two types of element (with or without wrapper). These children are also ambiguous in the first position of an attribute-less element.

**Constant Destructuring**

Any time you need to clone or reason about an element you need to destructure the system.

``` javascript
var [tag, props, ...children] = element;
return <tag {...props} foo={10}>{...children}</tag>;
```

``` javascript
var [tag, props, ...children] = element;
return [tag, {...props, foo: 10}, ...children];
```

``` javascript
return <element.type {...element.props} foo={10} />;
```

```
return { ...element, props: {...element.props, foo: 10 } };
```

**Nested Arrays**

We can't distinguish between a nested array of elements and just an element. This would only work if we enforced that children are always provided as flat lists and explicitly flattened as needed.

E.g. `['div', ...this.props.children, ['div', { className: 'extra-child' }]]`

Flattening makes it very difficult to preserve keys though.

**What About Allowing Both?**

A component that receives a ReactElement from the outside should not need to reason about two different kinds of abstractions and use two different patterns for accessing the type or props. It is important that the React community doesn't diverge too far from each other.
 cc @chenglou 
 Oh boy! _Gets excited anyways_

Here are some counterarguments, plus some other arguments on the pros of this.
1. **Non-JSX declaration**: pretty much. Less React-specific tooling is good.
2. **Children are special**: slicing off children is expensive with mutable arrays, yeah. But since we're (maybe?) considering persistent collections (or even your lazy splat/destructuring) this should be fine. `key` and `ref`, I agree. What about `['div', {key: 1, ref: bla}, props, children]`? Probably not good for perf (can static analysis help here?), but the current `['div', {prop1: bla, key: 2, ref: bla2}, children]` is fine too. Plus, it's more explicit, in this format, that the component shouldn't expect to receive `key` and `ref` in the object (we'll strip them before passing on the props obj and properly document this). It was harder to justify under the old `div({key: 1, prop1: bla})` and still not that obvious with `createElement` I'd say.
3. **Constant destructuring**: beside perf concern (which I pointed out above... The fact that it's lazy/persistent should help right?), I don't see the problem with that. It's much clearer and I prefer this over the `cloneWithProps` API. Smaller API surface and all. But if we really want, we could just make `cloneWithProps` use this destructuring under the hood. I don't see a problem here.
4. **Nested arrays**: since the specs aren't set in stone (even if they are, we don't have to follow them closely) I propose the format `[tag, props, childrenArray]` instead. Also solves the problem of having to spread `children` in the previous destructuring point.
5. **What about allowing both?**: nah lol

I don't think we have to stick with JsonML's specs too closely, if ours make more sense. For example, why is its style value a string? Why not an object like in React? Maybe you can influence the specs?

Now for the pros:
1. **(Ideally) React-agnostic render functions**: if a library provides `export function render(obj) => ['div', obj.a, bla]`, this is a win for future React-like libraries since that function doesn't depend on React. It's much more nuanced than that, I know, but this is a good start.
2. Potentially dropping `ReactChildren`: we're not gonna implement every array-manipulating functions (like we did with `count`). We did say that, for perf reasons, we wanted to keep the underlying children data structure opaque (e.g. to ease the switch to linked list), but realistically I don't think this is happening, and the benefits of working with plain arrays optimized by engines are too big. A good example is the `Select` problem we've seen:

``` js
<Select><Option selected={true} /><Option /></Select>
```

This is weird because we're passing a prop to a child, then making the parent read into it to determine some stuff. The theoretically better way:

``` js
<Select selected={0}><Option /><Option /></Select>
```

But this is hard to manage and might get out of sync. Even better way (@jordan):

``` js
<Select items={[['Option', {selected: 0}], ['Option']]} />
```

In which case we have a good excuse of being able to read `selected`: it's nothing but an array, that we'll also happen to render. With the JsonML format, this come for free:

``` js
['Select', {}, ['Option', {selected: 0}], ['Option']]
```

Also easier for libraries like `TransitionGroup` to read into/manipulate children. I might slice off children for infinite scrolling or something.
1. **Killing the distinction between owner/parent tree**: I haven't given much thoughts to the implication of this, but it might be nice. If I pass around a persistent children array, I wouldn't really own it; for all I know that array is always cloned before being mounted (`myArray === myClonedArray`).
2. **This is what the ClojureScript people already do**: https://github.com/reagent-project/reagent#examples. Except they actually precompile that to React components to play nice with us. Won't have to anymore.
 Yep. Not saying it's not possible with `createElement` but it feels definitely more excusable to directly read into normal collections.

I think that we should work with vanilla JS collections as much as possible (including their generation), and keep React at the edge only. `createElement` would be too dangerously convenient, because it allows us to cram new concepts into the arrays and still keep things superficially clean.
 Oh and @sebmarkbage: children comparison becomes easier. You'll also get whatever optimization you want from Flow for free (e.g. pull immutable arrays outside to avoid allocations). There are probably a lot more [insert optimizations for normal arrays/tuples] that I haven't thought about.
 No. Not sure why I quoted those. 
 @sebmarkbage It seems to me that the current object-based representation should be preferable from a technical perspective... in addition to actually making sense if you try to operate on them i.e. `elem.props.name`, but `elem[1].name`???

Something to consider is supporting JsonML via run-time/static transformation just like JSX instead, except it would be JS-compatible so there _shouldn't_ be any tooling issues for static transformation. Wrap all React JsonML in `ReactJML(...)` or whatever and if it has not been statically transformed you incur the (somewhat significant?) run-time overhead, if it has been statically transformed it's equal to JSX. No overhead and we get to choose the most suitable technical representation without considering it having to be especially human readable.

``` JS
render() {
  return ReactJML(
    ['div', { className: 'container' },
      [FancyButton, { disabled: true }],
      ['span']
    ]
  );
}
```

JsonML seems like yet another DSL for something which should have it's own dedicated syntax. I don't think the solution to problems like this is inventing ways of making the code less ugly with magical arrays (just because arrays have minimal character overhead), it's understanding that view hierarchies require a syntax designed for it (that's why we have HTML to begin with) and it's time for languages to catch up.
 @syranide `var [tag, props, children] = yourJsonML` solves your first problem.
I'm not arguing whether JsonML looks nicer btw (I actually think it's fine. But like @Raynos said, unless you're a lisp guy using paredit the `]]]]` might be a bit noisy). You can always make JSX compile to that in the worst case.

@Raynos good to know these exist. What do you mean by the perf cost? Can immutable collections mitigate this?
 @chenglou Still not a nice way to do it, you wouldn't do it like that if it wasn't for JsonML. My point is that it seems weird to make JsonML the target, why not make JsonML compile to _the best_ target instead? Just like JSX does.
 > It would also align us with a spec which is not ours. Almost like a standard.

:heart:
 @syranide yeah that's what clojurescript people do: https://github.com/reagent-project/reagent#examples
  #1169 #1418

Just add `cursor: pointer` and iOS will emit click events as expected.
 It's supposed to be fixed by MobileSafariClickEventPlugin, but it broke some time ago and haven't been fixed yet IIRC. `cursor: pointer` is the workaround for now I think.
 Dupe of #1169, essentially. Should be fixed in 0.14 by my PR.
  This issue will be used to track some properties / features that are available in some experimental frameworks that build everything around Rx / Observable streams, but with liftable component boundaries.

I've identified a few that already overlap well with existing projects:
- [ ] Error Propagation / Boundaries (Errors propagate up the hierarchy.) https://github.com/facebook/react/issues/2461
- [ ] Completion Propagation (A signal to tell that a component will no longer change. Can be used for memory cleanup/collapsing, async server-side rendering, transition groups that clean up exit animations.)
- [ ] "Prerendering" or "Lifting" Components (That then become opaque to their containers.)
  https://github.com/reactjs/react-future/tree/master/04%20-%20Layout
- [ ] Async Reconciliation. (Any component can block the entire UI as waiting for data. Useful for server-side rendering or calling out to asynchronous, but fast APIs on the client, )

These features will probably be built in an optimized imperative style into the core but expose the same capabilities as if it was built as Observables.

It is a non-goal of this particular task to provide a similar API surface area to Observables but to track the capabilities exposed by such frameworks. It should be possible to experiment with alternative APIs that heavily rely on Observable semantics on top of these features.
  cc @jeffmo @DmitrySoshnikov ‚Äì `() => <this.foo />` doesn't bind `this` properly because the `this` is a XJSIdentifier instead of a ThisExpression.

cc @sebmck too ‚Äì 6to5 seems to have the same issue.
 It's not obvious to me that this is a JSX spec bug ‚Äì for example, you could imagine that `<this />` could compile into something that doesn't use a `this` in the result, and conversely, `<div />` could compile into something that does use `this`. Seems like the transforms need to cooperate somehow. I guess that's hard when the transforms output strings.
 @RReverser I mean that different transforms may want to do different things with the characters `this`. In some cases it might mean the JS concept but I could imagine others where it doesn't.
 cc @sebmarkbage 
 The JSX spec doesn't make any claims to scoping rules of variables including their semantic meaning. Including the scope of the expressions contained in attributes. This is obviously a limitation because you can't reason about things like unused variables etc. This is also a feature.

If we want to implement semantic meaning, then we should move forward with a full semantic spec but we're not ready to do that since different implementations have different requirements. We're also actively changing the semantics.

If there was a `"this"` tag in HTML (which there very well might be in the future) or if I have that concept in my XML, then I'd like to use `<this />` to create such elements. That's why we went with the lower-case convention for React.

We added `JSXMemberExpression` as a compromise to allow a subset of valid identifiers in that scope. However, we didn't make it extend `MemberExpression`. It extends `Expression` in the AST.

Therefore, just adding the `ThisExpression` within it isn't enough to make it seamlessly work. You have to still reason about the `JSXMemberExpression` around it. Once you do that, you might as well special case the `JSXIdentifier` too.

Also, remember that `this` isn't the only reserved keyword. `arguments` already have the same issues (even though it is only reserved in strict mode). Seems strange that `ThisExpression` is special cased.

There is already talk about using more reserved keywords to include reflective syntax sugar like `new.target`, `super.` and more.

Therefore, I don't think it makes sense to special case `ThisExpression` unless you also want to do that with every other possible reserved or partially reserved identifier/expression.
 If we instead used the wrapper braces we could make it a full `AssignmentExpression` and then you're free to put whatever in there.

`<{this.foo} />`

Ofc, this has the problem of closing tags looking weird.

`<{this.foo}>...</{this.foo}>`
 @sebmck This issue is still a bug, however, it is a bug in the transpilers, not the JSX spec nor the parsers.

Just like `var x = () => arguments;` is also a bug in JSTransform, or `var x = () => <arguments.length />` for that matter.
 Super delayed response:

Regardless of whether this is a bug in a spec or whatever, the decision to avoid doing a `.bind` in the arrow function desugaring is purely an optimization and could easily be considered heuristic given this use case.

As such, it should not be a problem to just look for XJSIdentifier('this') in the arrow function transform and "accidentally" do an unnecessary bind in the edge case where this occurs _and_ doesn't actually mean `this`
 (I'll hack together a bugfix for jstransform here, btw)
 Fixed in jstransform here: https://github.com/facebook/jstransform/commit/b370c99706f075c6dfea134db5049d0f5e1669a7
 Also JSX Transform has been replaced by https://babeljs.io/
  Warn when unitless values assigned to unit-requiring fields.  Fixes #1873.
 Failing lint but I also don't think we have consensus on whether or not we'll actually want to do this since it's not cross-platform. Let's talk with @vjeux first.
 Ok, fixed linted whitespace.  I'll sync up with @vjeux soon, probably after reactconf.
 @ianobermiller The cross-platform issue is that if you don't automatically add 'px' to the style, then you can't re-use the same style declaration for React components and React-native components, since the numbers in ios aren't intended to be pixels.  Personally, I think it's a questionable idea, because it doesn't seem like you should specify a value that is intended to be pixels on web interpreted differently on mobile.  At best, it feels wacky/hacky, at worst I'm surprised it works at all.  But that's the discussion, obviously there are other points of view.

Personally, I would really like to see https://github.com/facebook/react/issues/1873 fixed.  I feel like people who feels strongly about style sharing can pass their unitless style object through a function to apply the correct units for their platform (like Facebook does for css class minification on the web) before passing the object to React, but that's not something React should be doing automatically (and most certainly not in the core).

@sebmarkbage Let's reopen the dialog with @vjeux after Europe.
 Let‚Äôs keep tracking this in #1873. It does not appear that this particular PR is going to get merged really soon, so I‚Äôll close it as part of the effort to clean up stale PRs.

We can revisit it at any time.
  No, the React event system doesn't have a way to attach multiple listeners to a single node automatically. You can always chain a callback to your own event emitter if you want to.

I'm curious about your use case. I've never seen the need for this (and I've seen a lot of React components). Could you elaborate a bit? Maybe there's something we're missing that we should support.
  I think the current plan is that we're going to push a tag each week so you can `npm install react@latest`. Hopefully this will be more stable than master but still up-to-date enough to test the latest changes. @zpao can elaborate.

There's also automatic builds here triggered by Travis which should always be up to date:

http://react.zpao.com/builds/master/latest/

You can `npm install http://react.zpao.com/builds/master/latest/react.tgz` for that.
 Yea, I don't want to push to npm nightly. There are often points where we know something is broken so it would be irresponsible. But we have been pushing pre-release checkpoints to npm for 0.13. These are generally (but not always) the same checkpoints that we bring in and use at Facebook.

If you want to make use of that you can `npm install react@next` and that will always bring in the next pre-release build. That's currently `0.13.0-alpha.2`, published last Friday. Or you can install directly from the `tgz` on our builds server as @spicyj mentioned. One day we'll clean that up so it looks more official :)

@brigand - "latest" on the builds server is simply a symlink to the most recent build on a given branch. It's not a corollary to npm tags. On npm I do keep "latest" pointing at stable and use "next" as the pre-release channel. You can't actually publish tags that look like semver versions anymore (I used to for RCs), so that's why we use "next", to match what npm itself does.

I've only tagged our "officially announced / supported" builds in the git repo. In other words, RCs and final builds. I haven't tagged alphas. 

So to answer the overall request, we have nightlies. But we won't publish them to npm. So I'm going to close this out.
 (@brigand sorry, I did mean `next`.)
  Closing this out as this doesn't sound like a React issue. If you can post a full code sample then maybe someone can help you debug your problem, but Stack Overflow is probably a better place for code-level debugging questions.
  Presumably `this.state.tags` is an array and you have pushed into it, then called `setState` with it again.

Something like this:

``` js
update: function() {
  var tags = this.state.tags;
  tags.push('new tag');
  this.setState({tags: tags});
}
```

That will keep the reference to the same array instance, which is why prevState and state are the same.

However if you actually cloned the array you wouldn't run into this reference issue (unless you looked at further nested objects)

``` js
update: function() {
  var tags = this.state.tags.slice();
  tags.push('new tag');
  this.setState({tags: tags});
}
```

I don't think that we want to make this work properly. It would require deep cloning current state on every transition which can get expensive. Other libraries are better at this, things like Immutable.js and Mori are good examples.

cc @sebmarkbage do you're aware. Reopen if you think we should do anything about this ourselves.
  try/finally without a catch shouldn't suppress exceptions ‚Äì are you able to reproduce the error in a standalone jsfiddle?
 In my Chrome 40, I see this:

![image](https://cloud.githubusercontent.com/assets/6820/5870620/5da80072-a286-11e4-833d-11f80a432820.png)

The Promise created in your `fetch` module is swallowing the exception. You'll notice that if you put a breakpoint on the catch on the `GitHubAPI.fetchIssues` promise, that code is called with the error object corresponding to the `this.v()` call.
 As I understand it, the native implementation of promises turns exceptions into promise rejections automatically ‚Äì you can't see the code in the call stack since it's not written in JS.
 I'll repeat myself again:

**React does not eat your exceptions.** If some part of your code is throwing an exception but it's not bubbling to the top level, something (not React) is catching them. Promises do this by default and are a common cause if you don't terminate every promise chain with a `.done()` call, but other libraries could also catch exceptions.
 Here's a post about the promises issue:

http://blog.taylormcgann.com/2014/08/21/catch-errors-javascript-promise-chains/
  Ah, I forgot about this and merged #2939. Sorry!
  This has no dependencies so I think we should either publish it as a standalone module or direct people to something else from the community. I'm inclined to do the latter since it means we can wash our hands of it. Our internal usage of `cx` is tied to our transforms so we've said no to features that would be useful to others outside FB. I'm concerned we'd do that again.

Any suggestions for existing projects that we can point to?
 Can't we just link to a bunch of "useful scripts" in the docs and leave it at that? People are free to use/modify them, it's implied they're not being maintained and are there just for getting people started.

I feel like a lot of people don't understand the current state of `React.addons`, but expect them to be full-blown frameworks and updated with every feature conceivable. Publishing on NPM kind of continues that trend and I suspect no-one on Team React really cares about the addons enough. So I would say, make them available in the docs (as code/files) and let the community sort out publishing/improving/direction.
 ...Can I "steal" the code and post it somewhere else under my name? I do need it for another CSS repo of mine, and it's really not React-specific.
 After talking with Jed at the conference, I think I'll just point people at https://github.com/JedWatson/classnames.
 It is. They're pretty much the same except for some negligible differences so I deprecated the former (the latter has an active maintainer).
  This is the 2nd easiest addon to get rid of.

see also #680 

TODO:
- [ ] figure out where shared dependencies (`keyOf`, `invariant`, `Object.assign`) live
- [ ] new name
- [ ] new repo
- [ ] file existing issues in new repo
- [ ] update internal usage @ FB
 Sorry about the dupe. Maybe as the first subtask here, we can de-emphasize this addon in the documentation?

My thinking is to rewrite https://facebook.github.io/react/docs/update.html to first suggest using array spread/object spread syntax (`$push` is easily replaced with array spread, btw üôÇ). We now tell people to use Babel right in the getting started guide, so suggesting a feature that needs transpilation seems reasonable.

Second, mention [immutable-js](https://github.com/facebook/immutable-js) for more advanced scenarios where you need to make deeply-nested updates. In my experience well-written React code rarely needs to update state nested more than one level deep, so I disagree with the current doc's implication that such deep nesting is common or natural (what do you think?). 

Then, only lastly, document `react-addons-update` with a note explaining that it's a historic artifact from before `immutable-js` existed, and may be removed from a future version of React.
 Yup, I'm aware, and that's why I suggested array/object spread as the recommended replacement for most people. It too sticks to plain JavaScript data structures, but has a simpler API. See my remarks in #5780.
 This might be helpful if we decide to rewrite the doc to use the spread operator: http://redux.js.org/docs/recipes/UsingObjectSpreadOperator.html
 Also if @kolodny is interested we can just direct people to his repo: https://github.com/kolodny/immutability-helper
  Let's track this over in the devtools repo - https://github.com/facebook/react-devtools/issues/62
  Closing due to no response, though this might also be #1326.
  Would #2362 cover this?
 We are handing over `update()` to the community so I‚Äôm closing this.
Please see my note in https://github.com/facebook/react/pull/6353#issuecomment-204219214.
  If you select an element in the Elements tab (using the magnifying glass or with the right-click "Inspect Element") then switch to the React tab, the corresponding component should be selected. I don't think we can do any better than this with the API Chrome gives us.
  Thanks for sending this in!

gh-pages is actually generated automatically from the markdown files in the main branch ‚Äì and #2874 a few days ago actually made just this change; we just haven't had the chance to rebuild the docs yet.
  Thanks!
  Thanks Sophia!
  Thanks! This sounds great.

I was wondering about your perspective as somebody who (presumably) just went through the tutorial. Would it make sense to make it so the servers we have do re-read the file on every request? That was proposed (https://github.com/reactjs/react-tutorial/pull/15) as sort of the opposite of this PR to leave the tutorial as it was and just make it work. I think I might be too involved with all parts of this to make a good decision on my own so I would appreciate an additional viewpoint.
 Ok, thanks! I'll push on getting the tutorial servers updated and we can close this out. If we don't get them updated in a reasonable amount of time I'll reopen and merge this as shorter-term solution.
  Ahh, thanks!
 Oh hey, I started writing that comment in the PR and forgot to finish. Thanks :)
  Nah, this isn't very JS-y. If we ever write React in Python that might happen :)

You can make use of built in JS features, namely `Function.prototype.bind`.

``` js
  componentWillMount: function() {
    some_stuff(function() {
      // this is now bound to the same this as the componentDidMount,
      // in other words, the component instant
      this...
    }.bind(this));
  },
```

FYI, it would be a breaking change if we were to do this. Half of the lifecycle methods take arguments (eg, `shouldComponentUpdate`)
  Initial state can depend on context, so we need make sure context is set up. With recent changes it is now `undefined`. Let's make sure we add a test too :wink:.
 @Dyscrete, I believe @zpao is referring to the master branch where this was broken.
 Indeed, this was an issue filed for us to remember since we knew the details. I sometimes forget there are other people watching the repo :) I appreciate your thorough testing though @Dyscrete. I hope you stick around and help some other people.
  This is the sort of thing that parent-based context should work for in 0.14.
  cc @sebmarkbage. We were talking about changing the autobinding recently. He might have some insight here (especially in context of ES6 classes)
 The idea is to move to an explicit binding model using ES6 classes + maybe property initializers. This lets you choses whether to bind at construction time or as they're used in render according to your optimizations.

Maybe there is a way we could change the optimization for server side render but I doubt it since in theory you'd need to bind it at least once even on the server. It's possible to call a callback in componentWillMount.

I would also suggest that you try a different strategy for benchmarking. Profiling tools tend to exaggerate small methods that gets called a lot.

If you comment out the call to `_bindAutoBindMethods` in React, and then profile by manually timing the whole operation, without a profiler enabled... Do you see the same results?
 @mridgway Just to be safe, have you considered the cost of calling `hrtime`? (i.e. move `_bindAutoBindMethods` outside of it and leave it empty and measure) I don't know what you're rendering, but `hrtime` might be an expensive external call that prevents optimizations and it could contribute significantly to the cost. Probably isn't, but you never know... 23ms just seems too high...
 You could also maybe try calling _bindAutoBindMethods twice to see what that adds?
 No matter how I measure it, `_bindAutoBindMethods` is always the largest contributor to our latency/performance issues. By running applications side-by-side with benchmark.js on node, with stock React vs React with `_bindAutoBindMethods` commented out, I see 15% performance gains (ops/sec rendering app) with it commented out.

Migrating to ES6 components helps for our custom components, but not for the built-in components which use `React.createClass`.

It seems like there are two ways to mitigate this issue:

1) Migrate internal components to not use `React.createClass` or 
2) Remove `_bindAutoBindMethods` so that classes created with `React.createClass` behave similarly to ES6 classes as far as binding
 Migrating to ES6, where possible, seems better.  It's hard to justify optimizing a feature that is "not the future".  We should increase the priority of migrating the built-in components to ES6 if we're really going to get a 15% perf boost on SSR.
 @jsfb Not too hard to justify it when everyone uses it‚Ä¶ but I don't know how to make autobinding faster.
 With `NODE_ENV=production` I'm seeing 20-25% improvement. This is in node.js using `renderToStaticMarkup`. This is the script I'm running to test: https://github.com/mridgway/flux-example/blob/bench/bench-chat.js. I am using React 0.13.1 from NPM and applied the patch from #3615 to make contexts work with multiple React's in same process.
 Yea, not really hard to justify at all.

We're still talking about server-side here right? Perhaps there's something we can do so we don't actually create all the bound functions upfront? Maybe have placeholder functions which lookup the real function and use `call`?
 @mridgway Can you try requiring 'react/dist/react.min.js' instead of the main React module as you're currently doing and compare?
 (Wondering if this is #812.)
 I don't think it is related to #812, since both tests are hitting the `process.env`. I will see if I can get the test working with the min.js although patching it is kind of difficult for me since I have to add the context changes as well.
 Here's a build from #3615: https://s3.amazonaws.com/uploads.hipchat.com/6574/26709/Ojl4jYZgCmwTdo1/react.min.js

And one with the call to bindAutoBindMethods removed:
https://s3.amazonaws.com/uploads.hipchat.com/6574/26709/iVzAHdzNHgEGOMh/react-nobind.min.js
 Ran the test with the above files and still seeing about 25% difference. The changes that I made for the benchmark are here: https://github.com/mridgway/flux-example/commit/0d6a228f48c56fd4b1e34c8c22640158f3bae5a6

Ran it a few times to confirm, but here's the smallest margin of difference that I found:

``` shell
$ node bench-chat.js
React 558 ops/sec ¬±5.06%
ReactOpt 698 ops/sec ¬±1.87%
```
 Okay. I'm having trouble getting that running locally ‚Äì it complains it can't find fluxible-router and I haven't figured out the right incantation of install/link/etc to make it work.
 Sorry, let me pull this out and simplify.
 Ok, you should have better luck with this repo: https://github.com/mridgway/react-perf

Note: the minified builds seem to break if I don't use NODE_ENV=production for some reason.
 Still failing to require fluxible-router here: https://github.com/mridgway/react-perf/blob/e8e0048d5153b3c2acd834b44ff9fb88c17b0cfd/chat/components/ThreadSection.jsx#L23
 Ugh, so sorry. This is what happens when you globally link something. I pushed changes that removes that dependency.
 Got it. Not seeing 25%, but definitely some difference ‚Äì like 10% with NODE_ENV=production:

```
balpert@balpert-mbp:/t/react-perf master$ node bench-chat.js
React x 348 ops/sec ¬±3.63% (70 runs sampled)
ReactOpt x 379 ops/sec ¬±3.52% (70 runs sampled)
Fastest is ReactOpt
balpert@balpert-mbp:/t/react-perf master$ node bench-chat.js
React x 346 ops/sec ¬±4.07% (71 runs sampled)
ReactOpt x 356 ops/sec ¬±3.63% (73 runs sampled)
Fastest is ReactOpt,React
balpert@balpert-mbp:/t/react-perf master$ NODE_ENV=production node bench-chat.js
React x 996 ops/sec ¬±2.73% (83 runs sampled)
ReactOpt x 1,141 ops/sec ¬±2.62% (80 runs sampled)
Fastest is ReactOpt
balpert@balpert-mbp:/t/react-perf master$ NODE_ENV=production node bench-chat.js
React x 1,002 ops/sec ¬±3.05% (76 runs sampled)
ReactOpt x 1,096 ops/sec ¬±2.66% (78 runs sampled)
Fastest is ReactOpt
```
 I think it's important to note that even if you drop `_bindAutoBindMethods` you'll end up taking the hit through manually calling `.bind()` instead. It may end up being less, but I don't think you can ever reasonably get rid of the entire cost with the way JS currently is, other than not binding them server-side, but that's not 100% safe.
 The typical use case for needing the autobinding is for event handlers which usually only get fired on the client. It would be more optimal to bind the methods on `componentDidMount` in that case.
 Looks like 0.13 started autobinding getDOMNode where we didn't previously, which is almost certainly unintentional on our part. :(
 @jordwalke This isn't with a profiler; this is with normal React and with autobinding commented out.
 With https://github.com/facebook/react/pull/3801 merged in, would you be open to a PR to migrate internal components to ES6 classes instead of `React.createClass` to avoid autobind overhead?
 I think so. Let's do the plain ES3 "class" syntax for now until we figure out whether we want to use loose mode, etc. in babel.
 Closing as internals have removed usage of `createClass` and userland can avoid it.
  I wonder which parts of this are relevant after we started passing all SVG attributes through in #5714.
 This diff is over a year old, has merge conflicts, last comment was over a month ago, https://github.com/facebook/react/pull/5714 merged over a month ago.  If there is anything actionable, we can open a new issue/PR.
  Like @gaearon said, immutable collections alone won't remove the need of diffing. As a matter of fact I don't think it makes much sense, lol. You might be thinking along the line of [Om's techniques](http://swannodette.github.io/2013/12/17/the-future-of-javascript-mvcs/). Doesn't mean you don't need the diffing.

That being said, the diffing is mostly an optimization. It's popular because it's creative, I guess. But that's not the important part of the concept of React imo. Given a reasonably faster platform like OpenGL you probably don't need diffing since redrawing everything would be faster?
 Feel free to continue the discussion but there's nothing really actionable here so I'm going to close it out. If you get to a point where it can be broken down and implementable (not "replace virtual dom")
  Thanks!
  Yea, this is a good idea. I'm not entirely sure if we actually have access to the owner component at that point, we may have to pass some extra information around. In the mean time, grep is the best option. Usually people see this while iterating so there's a relatively small surface area of possible blame, so it hasn't been much of an issue. But it would make React friendlier. I would support adding this as long as it doesn't make the code much more complicated.
 The idea is to move propType validation to the element creation instead of during mount. If we treat these warnings as part of the same validation step, you would get the warning earlier. So the stack trace would be at the point where you created the element.

This is a bit problematic for natives because it is environment specific but since this is just validation we can probably special case this.
 @skevy I think that's still there because props aren't really immutable yet so it's possible to mutate after creating an element. We want validation to only happen once at element creation. But as long as we support modifying the element, we need to actually validate at mount time. cc @spicyj 
 I'm not familiar with the validation setup here.
  I'm going to send you over to https://github.com/facebook/esprima/issues/34 since that's where this error is actually coming from, it's part of the parse step. This specific message is different than the one mentioned in that issue but it's in the same class of problems. I think we're definitely up for making the messages as helpful as possible, just want to make sure we solve the problem in the right way.
  This is by design. React does not poll state, only `setState(...)`, `forceUpdate()` and `React.render` triggers re-renders..

You really should not bypass `setState` and mutate state directly. But if you are, then you'll need to `forceUpdate` or make dummy call to `setState`, but I don't really recommend either of those... but they do work.
  I'm confused. You _do_ want to allow using `FluxMixin` as a mixin or you just want your own error to fire instead of React's (admittedly somewhat-confusing one)?
  React requires camelCasing for DOM attributes, even though the DOM attributes are lower-cased or sometimes hyphenated. However, React always output the correct DOM attribute name in the markup, so unless you're seeing something else, everything is as it should.

https://github.com/facebook/react/blob/master/src/browser/ui/dom/HTMLDOMPropertyConfig.js#L47
https://github.com/facebook/react/blob/master/src/browser/ui/dom/DOMProperty.js#L93
  Thanks!
  We'll make sure all the examples are working before we release 0.13 final but until then there's a non-trivial change they'll be broken at any point in time. Check out the latest stable branch for the working examples.
  Master seems to work fine (well, with #2884 anyway). I think the bug might be on your side? It's definitely not `onclick/onClick`'s problem as that's only a prop name. If you pass `onClickBlaCustomName` to `BootstrapButton` and it does `onClick={this.props.onClickBlaCustomName}`, you're still fine.
 =)
  This doesn't merge, can you rebase and clean up any conflicts?
  Part of the contents of the document has been translated into Chinese, I also intend to continue the rest of the document translated into Chinese
 Can you pull out the config/generic parts of the site into a separate PR. I'm not 100% certain on how to make these pages public in the best way possible using jekyll. I'll look into it but if you have any insights, let me know!
 I think this PR is basically dead at this point, in favor of other commits which add the Chinese docs translations.  Probably inspired by this PR, thanks!
  Thanks!
  Haha nice catch. Thank you!
  Closed with #4157
  map now always returns an array in 0.14.
  `<b>{this.props.author + 'px'}</b>`

React sees this as a single text child whereas the one in the tutorial is treated as two.
  Ditto on invariant. But I think those are ok already.
 Thanks @kevinold!
  - [x] Make sure `warning` and `invariant` have a string literal for first argument
- [ ] Make sure JSDoc args match up
 The exiting jsdoc rule is too noisy. I tried it but since we don't use jsdoc consistently it warns for way too much. I really just want to catch the cases that will break other tooling. #2772 is an example of the sort of thing I want to catch.
 s/exiting/existing/

I considered adding the options to upstream but I didn't care enough in the short term and my priority is our code. We'll see if our requirements are too niche to go upstream, but I'll definitely consider it.
 Yes!
  This probably needs another pass since it is somewhat stale, but it should be using the warning module instead of calling console.error directly.
 lgtm. We'll pull in after we switch branches. It is too late for 0.13 so we'll pull it into the 0.14 branch.
  Our philosophy is that runtime behavior should not be meaningfully impacted by environment. By stripping out errors from production you have different runtime behavior. Problems that stop execution in dev will run with unpredictable behavior in prod. Thanks for the effort but we aren't going to do this.
 There should be no places where we throw errors (`invariant`) in dev that we don't throw in prod. If there are, then I think we made a mistake. Like that one in ReactMount, we should either make that a warning or make sure we do that check outside the dev block.

`warning`s we're a bit less consistent with. Some of the ones you changed in here are already behind **DEV** checks because the function is only called in dev.
 I haven't looked closely but a couple quick things...
1. invariant using **DEV** is fine, we do that so we can show a useful message when the error is thrown. In prod we strip out the message arg and depend on the generic message lower.
2. warning is fine too for mostly the same reasons. We require a message in dev but make the whole thing a noop in prod. There is no program logic difference
3. Object.freeze in emptyObject is a special case to catch potential developer error so nobody depends on emptyObject being mutable. This (and other vendor files) are actually shared across FB projects so those are a bit harder to enforce our philosophy
4. We're going to remove copyProperties so don't worry about that one.
5. I think you're right that the places in your top file group should get fixxed. Thanks for finding them. I haven't had a chance to look thoroughly or figure out which is the right route (warning vs invariant).
  My first instinct is to put a warning in DEV so we don't incur any costs in prod. This would be similar to our other style key warning ("you used background-color but probably meant backgroundColor" or whatever it is we say).

``` js
warning(
  !/;$/.test(value),
  'yo, no semicolons, it breaks the things'
);
```
 @zpao It's only a warning, but it's worth considering that `url(foo;bar)` is valid CSS IIRC.
 `/;$/.test('url(foo;bar)') === false` so that wouldn't warn :)
 @zpao Oh right `$` :), but I've seen plenty of invalid `background: '#000; background: #333'`, but perhaps that's an exercise for some other time. Anyway, you might want to ignore white-space after the `;` as well.
  I'm not entirely sure what your updated question/post is asking, but it doesn't look like a React bug, so I'm going to close it out.  Let me know if you still believe this is a bug and we can reopen.

The bind method is well-documented here:
https://msdn.microsoft.com/en-us/library/ie/ff841995%28v=vs.94%29.aspx

In React 0.4, we introduced a feature called autobinding, which saved some typing:
http://facebook.github.io/react/blog/2013/07/02/react-v0-4-autobind-by-default.html

Turns out, this has been the source of a lot of confusion, so autobinding will not be enabled for React 0.13 using ES6 classes:
http://facebook.github.io/react/blog/#autobinding
  Not a React bug, this is simply how JavaScript works, `/\s/` is written as `'\\s'` in strings (you need to escape once to avoid the "unescaping" performed by strings).
  Thanks! @zpao 
  See https://github.com/facebook/react/pull/1473#issuecomment-41952920. These helpers are easy to implement outside of React itself so you can always add them in your own code though.
  currentTarget changes as the event bubbles up ‚Äì if you had a event handler on the element receiving the event and others on its ancestors, they'd see different values for currentTarget. IIRC nulling it out is consistent with what happens on native events; if not, let me know and we'll reconsider our behavior here.
 http://jsbin.com/pirayosura/1/edit?html,js,output seems to disagree if you open the console and click the inner div.
 We won't always follow the DOM but we will unless there's a good reason to deviate ‚Äì in this case, it really is the same event that both handlers are getting notified of, and the naming of currentTarget indicates that it's the handler that's _currently_ being executed so I think it makes sense to leave it like this and have it change as the event bubbles. (Making multiple event objects would also be worse for performance.)
  It's true that the spec doesn't guarantee this, but virtually all browsers and engines do, so we're planning to leave it as-is for now. Alternate solutions with manual bookkeeping tend to be significantly slower.
  Duplicate of #1673
  This looks good. Thanks for taking it on.

I think if the test isn't actually testing anything we should probably just not have it :) Can you get rid of that and rebase to trigger linting on TravisCI (and/or run `npm run lint` or `grunt lint`). Then I think we can get this in.
 I would actually find this useful myself :+1:
 ping ping @zpao
 Thanks!
  Events are pooled so we wipe out their values. If you want to use the event outside the current event loop then you need to call `ev.persist()` which will pull that event out of the pooling.

You'll note the same thing if you `console.log(ev)` in `onClick`. The properties are all nulled out.

We've talked about this before (I don't have the other issues handy) but we don't talk about it on the website. We probably should.
  For the purposes of providing dev-tools support and providing back traces in error messages/warnings, it might be useful to keep back references to a component's parent.  This trace information will cut down the amount of time required to find the component(s) responsible for throwing warnings.
 My current thinking is that this should be rolled into the devtools (via a new devtools api) instead of in the core.  Closing.
  ^ What he said, neat component =)
  This passes through the es5 flag to jstransform, which is used to support getters and setters in ES6 classes.

Fixes #2820

cc @fkling who added this in jstransform (https://github.com/facebook/jstransform/pull/19)
and @jeffmo who might know if we plan to support this particular option if we transition away from jstransform

It might actually make more sense to introduce a `target` option, like reactify has done (https://github.com/andreypopp/reactify/pull/27). Possible values would be "es3" (default) and "es5". Under "es3" we could also do the reserved words quoting (not happening currently). "es5" would not do the reserved word quoting but would do the getters.
 cc @sebmck - does 6to5 have this sort of target behavior? If so, it's be cool to align here (though I know it's not called 6to3 so perhaps not :wink:)
 I made `es3` the default, ~~but that's different than our current behavior‚Ä¶~~

~~https://github.com/facebook/jstransform/issues/71 is annoying me. By making the options mutually exclusive here we actually result in different code than we would today (assuming you pass no options). if you leave out `opts.es3` and `opts.es5` (in otherwords they're both false) then you get code that uses `defineProperty` for everything except getters and setters (because it's assuming the not-quite-polyfilled IE).~~

~~So for now I guess the best course is to only set either of these options _iff_ `--target` is specified. OR we add a 3rd possible value which is `es5polyfill` (would be default and functionally equivalent to my previous sentence).~~

~~The alternative would be to stop trying to ship this in 0.13 and waiting to figure this out better in jstransform.~~

Turns out I had screwed up my test of what we're currently shipping. I was just testing master without this change **which did change default behavior, because jstransform changed default behavior**. So we actually have to specify `es3` as the default to maintain what we were doing (though with this we actually change the default a little bit because of the reserved words change).
 cc @spicyj @sebmarkbage, making this block 0.13 per the edit to my last comment.
 Yes, because of the IE requirement, but only under the `--harmony` flag. Mostly because it is what we'll keep doing at Facebook to support IE. At least for the time being.
 FWIW, the plan is to get away from having react-tools be the primary way people make use of `jstransform`. I want to deprecate it and make `jstransform` the real vehicle for our transforms. We'll be able to move a bit more freely there and not get stuck in the React cycle.

We also are going to add a page somewhere (either on the site or in the wiki) with links and descriptions about transform tools (including Babel) so that people don't feel obligated to use our tooling.
 Hm... It's a difficult tradeoff. Either we have browser interoperability nightmares or we have transpiler interoperability nightmares. The presumption is that very little code will rely on non-enumerability because of the prevalent use of hasOwnProperty checks.

Mixins solutions might exaggerate the problem but we highly discourage the use of custom mixin solutions.
 The problem is exactly that they don't test it. They expect React to support it implicitly and for most things it just works. It complicates the story if you have to consider which parts of the React toolchain supports which browsers and which combination you want to use.

We could try to make a splash about it in the release notes... Like IF you support older browsers, use the `--es3` flag.
 Talked with @jeffmo, he's on board with biting the bullet and changing the default behavior here. I'm leaning towards it as well.

@andreypopp, heads up that this discussion is even taking place! Whatever we do surely impacts reactify.
 Yea, i think internally we have to target ES3/IE8 (for at least a while longer), but it wouldn't surprise me if we weren't the majority case in that respect. We can (and already do) set the `es3` option internally, the only thing we have to consider is that we run the risk internally of building code that suffers from the same future-compat issues as everyone else who sets `es3` will have.

I think the RightThingToDo‚Ñ¢ here is to follow the spec by default and just give an escape hatch for when there are important reasons for not doing so.
 @sebmck Not sure what you mean, but React itself already requires some ES5 polyfills itself:

http://facebook.github.io/react/docs/working-with-the-browser.html#browser-support-and-polyfills
 Yeah, we could ‚Äì generally we try to keep things as consistent as possible across environments so that you don't get bitten by a bug that surfaces only in IE8 due to nonenumerability.
  I'd call this a duplicate of #285, re-open if you disagree.
  Can you propose this in https://github.com/facebook/jsx/? The backtick is not a part of the spec we wrote there so we can't even implement it until it's there. Let's revisit this then.
  Thanks!
  This is continuing the conversation started in #2805

We're considering dropping replaceState because ideally state should always keep a consistent signature, defined by getInitialState.
 A bit out of loop but, if state is `{a: 1, b: 2}`, is setting it (merging it) `{b: 3}` still gonna work? I can see it being convenient for a long time to come, but if we go immutable, I'd rather return the whole state object: `setState(state.updateIn(path, val))`. Avoids a merge and uses structural sharing as much as possible.

I'm against whatever custom `merge` mechanism mentioned in the other issue though. Don't think it's needed with the above solution.

Edit: if you wanna type check `setState` well, you do want it to accept the full obj/record, right?
 > We're considering dropping replaceState because ideally state should always keep a consistent signature, defined by getInitialState.

I've always loved that idea, but I don't think it negates the value of `replaceState`. However, requiring calls to `replaceState` to provide the full state would surely not make it very practical... so it's not entirely obvious how you would keep useful without ruining a part of its appeal...

@brigand I feel quite confident that "inefficient" in this case is not really measurable in any real life scenario. But I could be wrong.
 Presumably an engine with hidden classes can do an optimization for `Object.assign(a, b, c);`

```
if a is fresh empty object
  and hiddenClassOf(b) === hiddenClassOf(c)
    then memcpy(a, c)
```

`this.replaceState` with a mutable object may be dangerous so I think we'd ideally clone and freeze any such objects anyway. We already do this with props in createElement.
 Closing in favor of #2843, I guess. 
 Er, #3236. 
  Hmm, not sure what to do about the `<!---->` comment ‚Äì I'm worried that that will confuse reconciliation later.
 I like this commit, awesomeness!  If we're going to do the `<!---->` comment trick, we should have a unit test that renders a simple example, and then re-renders in place to verify reconciliation.  That will be a useful unit test and demonstrate it doesn't break anything.

Alternatively, take that out the `<!---->` and merge that as part of another pull request with a unit test.
 Also, it doesn't look like `<!---->` works to force the newline? In my tests in Chrome it makes that literal text show up in the textarea.
 I think the best option for now may be to double an initial newline if it's present (so that it continues to work properly on HTML5) and otherwise leave it alone. This means that you will get two newlines instead of one when parsing pre/textarea/listing markup as XML, but I don't know if there's anything better to do.

Does that sound sensible? (If we then figure out later how to make it work consistently I'm happy to take an update.)
 Shouldn't this be behind a flag? It seems really weird to force it upon everyone, it's not HTML5, it's just HTML5-compatible.
 If the markup generated is compliant with the HTML5 spec and passes a HTML5 validator, it's a perfectly reasonable thing for React to produce.  Unless there is a good reason for someone to want to turn it off (I can't think of any such reason), no flag is necessary.

If we are targeting arbitrary xml (instead of html5) as an output target, we may want a flag that says "don't do anything fancy", since we already do a bunch of magic assumptions based on our knowledge of how browsers work.
 @jsfb I would consider HTML and XML to be different targets, treating them as equal just because it's compliant seems weird to me, especially as XML should technically support namespaces (and a bunch of other things) which HTML does not. The vast majority of users are targeting HTML and this produces suboptimal output, does it reeeeeally matter right now... no... but it seems really weird to me considering the low demand for XML to do it at the expense over everyone else (regardless of how small).

It's conjecture, but I'm quite sure we'll see issues about suboptimal output and it wouldn't surpise me if forks will appear which explicitly removes this to get "perfect HTML5 output".
 Internally, we've actually been seeing the opposite trend.  React is being used more and more frequently outside of web to generate XML-compliant output (see ReactNative, React@Netflix, ReactArt, and some not-yet-public facebook projects, etc).  At our team sync yesterday, we spent a large chunk of the meeting discussing how to properly support XML Namespaces and other XML features, because there is demand there.  Even on the web-side of the world, we need to start supporting more XML functionality if we're going to support web components.  So more generic XML support is certainly on the roadmap, and this brings us closer to that goal.  I could totally see us putting HTML vs. XML behind a flag at some point in the future, but probably not necessary at this time and probably shouldn't be blocking this pull request.  That's my two cents anyway.  We can always add flags later.
 @jsfb 

> Internally, we've actually been seeing the opposite trend. React is being used more and more frequently outside of web to generate XML-compliant output (see ReactNative, React@Netflix, ReactArt, and some not-yet-public facebook projects, etc).

Right, but those are interesting projects and developments, but that's what not the majority of users are doing, they're using React instead of jQuery or Angular.

> So more generic XML support is certainly on the roadmap, and this brings us closer to that goal. I could totally see us putting HTML vs. XML behind a flag at some point in the future, but probably not necessary at this time and probably shouldn't be blocking this pull request.

That's great (but the flag is probably many many months away), but I'm "worried" this change can and will be used against us. While harmless, it is _intentionally taking one step back_ (however small) for HTML-support in the eyes of our users (and competition); "New feature: React thinks HTML is XML", whaaa? I'm sure someone somewhere would love to use it against React.

Again, I don't reeeeeally care and it doesn't reeeeeally matter, the output once was kind of like this and that was fine. But, this is now _intentionally going back_ and unless you're the XML proponents you would wonder why on earth this is a good thing.

**PS.** When the flag arrives... `{__html: ...}` should be replaced by `{__xml: ...}` right?
 Other than the concern that some people might not like that their html looks like xml... are there any other objections to merging, or what's the status on this PR?  Who's court is the ball in right now?

@spicyj, is a change still required on @Acubed's end for the `<!----->` trick, or is this PR otherwise good-to-go?
 @Acubed In my tests, `<!---->` shows up verbatim in a textarea:

![image](https://cloud.githubusercontent.com/assets/6820/6281067/3bd24104-b86d-11e4-8838-0e6801633946.png)

http://jsbin.com/tizolesasu/1/edit

Let me know if I'm missing something. Also, this PR needs to be rebased for a clean merge regardless.
 Ok, so if I understand correctly, the ball is in @Acubed's court to remove the `<!--->` hack from this PR.
 Ok, awesome, thanks!  Sounds like the ball is now in our court.  We just pushed out a release candidate, so we can't merge anything except critical hotfixes at the moment (code-freeze until the RC graduates to 0.13, probably about a week-ish).  Once that happens, I think this should be one of the changes that is strongly considered for merging.
 Added GH-accepted tag to indicate that Ben and I have both looked at this code and are happy.  We should confirm with Sebastian+Paul before merging, but it looks good to me and I'm in favor of the change.
 @Acubed We've shipped 0.13, so we're out of the code freeze.  Can you rebase and fix as per zpao's comments?
  We have no explicit support but as @kahwee mentioned, there are integrations with maven in the JS ecosystem that can integrate with react transforms.
  Expected. The former is equivalent to

```
var handler = localStorage.removeItem("localData");
<button onClick={handler}>Clear Local Storage</button>
```

Note that the `removeItem` call runs immediately upon render, _not_ when you click the button. You want to pass a function that gets called instead. You can do this with an arrow function (as you saw), a regular function like `onClick={function() { localStorage.removeItem("localData"); }}`, or a method like `onClick={this._removeData}`.
  #101 and https://github.com/facebook/react/issues/101#issuecomment-69317573

As I mention, I think it's quite easily and realistically solvable (for DEV at least).

cc @zpao
 This happened.
  Going to close this out and just refer to that other issue. Let me know if there isn't enough there to answer your questions and give you an idea of the direction we're heading.
  People are doing this in a couple different ways. Stringifying the initial props and making sure those are part of the initial call to `React.render` in some way is the typical route. Some are just injecting a global variable with that data in a script tag. Using meta tags is an interesting way to go, I could see that working pretty well too.

Requesting that data again is a way to go but obviously has drawbacks. That might end up being the least complicated way for your application so if it works for you then great but it does have its drawbacks.

I'm going to close this out just because it's not really an issue with React. The mailing list and stack overflow are probably better places to continue this discussion but feel free to keep going here.
  Thanks!
  Are there any other microdata props we should know about?

We already support `itemProp` `itemScope` `itemType` as they are specified on http://schema.org/docs/gs.html. `itemref` doesn't appear anywhere on schema.org, so if there's some other spec with other `item*` props, please let us know.
 Fixed by #3022. 
  Removed unknown tag warning/whitelist.
 This will need an internal refactoring diff since this will break stuff upon syncing.
  Yea, we know. The fb.me "CDN" is not really set up to be a real CDN. We suggest you host the files yourself in a production environment or use one of the real CDNs we link to - http://cdnjs.com/libraries/react or http://www.jsdelivr.com/#!react

We should probably change the wording around the fb.me links to make it clear about the limitations.

We do plan on eventually have a better supported official CDN but in the mean time I'm going to close this out because the fb.me limitation isn't something we can fix. fb.me is a redirect service that doesn't support https.
  #2726 also got backported into 0.12.2 so you should be able to just update and see a warning.
  We can probably switch our warning module to use console.error instead, which gives a stack trace in most browsers I think.
 Duplicate of https://github.com/facebook/react/issues/4216.  Fixed in 0.14.
  Yeah, enter/leave have special bubbling and don't have the capture phase. I'll update the docs.
  That's because the mixin functions are just like those you attach on the component:

``` js
var Comp = React.createClass({
  handleClick: function() {...}
});
```

You don't access them either from the parent with `Comp.handleClick` (what would that mean even? It'd be a static function and that's not what you want).

Here's how you can do it: http://facebook.github.io/react/tips/expose-component-functions.html
Note that this isn't specific to mixins. Your mixin's fine.

Closing! =)
  We've talked about this a few times and even half done it. This is for real.

I also changed the name of the html file to be `index.html` (that's what's in the tutorial repo)

See also #2004, #2739, #800 (eh, not totally but I want to close it), https://github.com/reactjs/react-tutorial/issues/1 and surely some others.
 Anybody have objections? @spicyj?
 Seems reasonable. Did you test that loading the first parts from a file: URL works properly in Firefox and Chrome and Safari? I imagine it would since we're not doing anything fancy but it can't hurt to check.
 Yea, I guess moving it to `/api/comments` would be ok. I don't feel strongly, as long as its understandable and works (we needed `comments.json` before because of the simple server assumption).

Per the $.ajax bit, meh. I think it's ok and reduces the number of things that needed to be learned right away. It might be good to have an "advanced" tutorial which goes back through and talks about more topics like mixins, data stores. Overall we probably need a best practices section and should talk about architecture a bit but I don't know the right place.
  There is an error in the console explaining :)

> Error: Invariant Violation: enqueueUpdate(...): You called `setProps`, `replaceProps`, `setState`, `replaceState`, or `forceUpdate` with a callback that isn't callable.

I'm not sure what else we can really do. As @gaearon mentioned you've passed a function that gets called with the event as the "callback" which isn't callable. You hit this invariant https://github.com/facebook/react/blob/master/src/core/ReactUpdates.js#L194-L199. Because we're doing truthy check, that's why the invariant isn't hit for 0, null, undefined. And then we don't add the callback to the queue if its falsey. (though a couple lines lower we do send it off to `batchingStrategy.batchedUpdates` without a falsey check so _that_ should be throwing as well later. cc @spicyj - should we handle that?)
 Looking at the code I can't figure out why it doesn't _always_ throw in batchedUpdates when a callback isn't specified. I'm probably just too tired right now.
  Yea, there are some limitations of the service and it's not really a CDN. Use another CDN service. See my comment in https://github.com/facebook/react/issues/2829#issuecomment-69249065
  I _think_ these will be gone in 0.13 as we're hiding the internal instance from the public one. There are likely still a couple, though maybe we could consider double underscoring the React private things. cc @sebmarkbage
 Yeah, these are all gone now except `_reactInternalInstance` which will be gone if #2958 merges and isn't a likely name to conflict with anyway.
  @mlmorg While it's off-topic, `createElement` is primarily intended for JSX AFAIK, using `React.DOM.*` and `React.createFactory` exists for the non-JSX crowd.

However, I'm curious if you may be doing it "wrong" in a sense if you're seeing this issue a lot. Dynamically constructing a non-keyed array of items shouldn't really be done, the implicit key system used by React work best when all elements have fixed indices. I.e. it's better to construct `React.createElement('div', null, X ? A : null, X ? null : B)` than `React.createElement('div', null, A)` or `React.createElement('div', null, B)`, maintaing the holes like that helps the reconciliation without having to be overzealous with keying.

Again, off-topic and probably doesn't apply to you... but now you know if you didn't. :)

What might interest you though is using `React.createElement('div', {children: [...]})` instead in places where this is an issue... I believe doing that is still "officially OK", and would give you the result you want.
 It's a heuristic. People gets the keys wrong all the time, even with the warning in place. You're very likely to forget a key on a dynamic array.

Don't think about the implicit key as the default and we ask you to opt-in to keys. You should really **always** provide an explicit key because even with a static set you might switch between two different static sets. (We should really be warning on children and any other property too.)

The extra children arguments is really a special cased way to _avoid_ providing implicit keys by indicating that it's a static set of items.

You can certainly trick the system by using `.apply(...)` or `children: [...]`. However, it's more idiomatic to use a static notation for var args `(a, b, c)` which would clearly indicate that this is not a dynamic set. The spread operator makes it a lot easier to use arrays as rest arguments which is kind of unfortunate.

At the end of the day it's not there to prevent you from shooting yourself in the foot. It's just a heuristic that we can use to avoid a common source of errors. If we can come up with a foolproof system or different heuristic, by all means. Let's add that instead.

I'm closing this out since there is currently a way to avoid this as @syranide pointed out. I would not recommend making it a common practice though, since lack of keys can cause severe bugs.
  The API would be `React.createComment(data)` if we added this. I took the liberty to update the description of this issue. I don't see why not, other than that it seems a bit unnecessary.
 `React.DOM.tagName()` is just a set of built-in helpers for calling `React.createElement(tagName)`.

`React.createComment(data)` is to `document.createComment(data)`
as
`React.createElement(tagName)` is to `document.createElement(tagName)`

Edit: Also note that technically "comment" is not a DOM element. It's a DOM node. (Unless you're talking about `document.createElement('comment')` which is different.) So if anything `React.DOM.comment()` would translate into `React.createElement('comment')`.
 @sebmarkbage Hmm, perhaps a comment can be considered a special case and that's why it makes sense, but I'm not sure it does, a comment node is not universally useful and only really useful for the DOM frontend?

Other than that it should behave like regular ReactElement ... so does it really make sense that it would have its own `createComment`? Considering _all_ all other elements share the single `createElement` (DOM, SVG, composite, etc)? `createComment` makes sense to me if it was universally useful like say "fragment", but it doesn't seem to me like it is and it would be better off just special-cased as `createElement('<!-->')` or something?

**EDIT:** I guess it could make sense if we consider that comments could be a helpful debugging tool for any front-end and that it would map to no-op for those that can't make use of it. Hmm...
 The browser XML/HTML DOM has 9 interesting kind of nodes in the document:

| DOM Class | nodeType | nodeName |
| --- | --- | --- |
| Attr | ATTRIBUTE_NODE | this.name |
| Element | ELEMENT_NODE | this.tagName |
| Text | TEXT_NODE | "#text" |
| CDATASection | CDATA_SECTION_NODE | "#cdata-section" |
| DocumentFragment | DOCUMENT_FRAGMENT_NODE | "#document-fragment" |
| Comment | COMMENT_NODE | "#comment" |
| Document | DOCUMENT_NODE | "#document" |
| DocumentType | DOCUMENT_TYPE_NODE | this.name |
| ProcessingInstruction | PROCESSING_INSTRUCTION_NODE | this.target |

It's useful to be able to render all of these if you use React to server-side render arbitrary XML documents.

Of these, we already have support for five of them:

| DOM Constructor | React Constructor | React Signature |
| --- | --- | --- |
| document.createAttribute() | _key : value_ | _key : value_ |
| document.createElement(type) | React.createElement(type, props) | { type, props } |
| document.createTextNode(txt) | " " | string or number |
| document.createCDATASection(txt) | " " | string or number |
| document.createDocumentFragment() | [ ] | array |

We could add support for the final four as well to get complete support:

| DOM Constructor | React Constructor | React Signature |
| --- | --- | --- |
| document.createComment(data) | React.createComment(data) | {type:'#comment',data} |
| implementation.createDocument() | React.createDocument(props) | {type:'#document',props} |
| implementation.createDocumentType (name, publicId, systemId) | React.createDocumentType (name, publicId, systemId) | {type: '#document-type', name,publicId,systemId} |
| document. createProcessingInstruction (target, content) | React. createProcessingInstruction (target, content) | { target, content } |

The `nodeName` of a comment is `#comment` but it not valid to create it using `document.createElement('#comment')`. You have to use `document.createComment()`. That's why I think it should use `React.createComment()` as the API. It also is a different signature. It accepts only a string "data" field rather than a complete props object.

`React.createDocument` is useful in combination with `React.createDocumentType` to create a document type as well as the rest.

``` javascript
React.renderToString(
  React.createDocument({
    children: [
      React.createDocumentType('html', '', ''),
      React.createProcessingInstruction('access-control', 'allow="*.example.com"'),
      React.createComment('Hello this is a secret message for view-source'),
      React.createElement('html', ...)
    ]
  })
)
```
 @sebmarkbage Hmm, I'm a bit confused, I thought the idea was for `React.createElement` to be the "universal interface" for creating elements which are understood and interpreted by the active frontend (right now, only the DOM). I'm not saying this separation doesn't make sense, but doesn't it mean that DOM frontend implementation details leak into the React API?

Just to illustrate my thoughts, it would make sense to me if it was exposed as `ReactDOM.createComment` (or w/e), it would then be isolated from the React API and from the other frontends. `createDocumentType`, `createProcessingInstruction`, etc doesn't seem like they apply universally to React frontends as they map straight to DOM implementation ... or do we think they apply equally well to other frontends? (i.e. the DOM API is well designed and we're just adopting it)

PS. The React signature for fragment shouldn't be `[]` should it? I thought being able to key it was important?
 @syranide You're right. However, currently the `React` module is already overloaded with DOM specific APIs such as `React.render(ReactElement, DOMNode)` and `React.findDOMNode(ReactComponent)`. We'd have to move them all at once to a separate namespace.

It's an interesting exercise though. Would it make sense to have the ability to define a "comment" in other environments too? The others are probably very unique to DOM.

PS. We might need an additional representation for a keyed fragment but there is some discussion going on in that space. Currently it's just `[]`.
 @sebmarkbage For the future I guess... :)

If we expand the context a bit, it seems to me it's a matrix of:
1. Has debugging/logging for human consumption
2. Has informational data for computer consumption
3. Has semantic/control meaning for computer consumption

A. Exists in React only (avoids instancing overhead)
B. Exists in React and the front-end renderer
C. Exists in React, the front-end renderer and it's rendered representation (if any)

1A, 1B, 1C makes sense to me at some level, a good developer tool at A/B/C should make it largely pointless, but it seems there's _some_ legitimacy to it still I think.

2A makes no sense to me I think, that's what props are for?
2B, 2C could make sense in some hypothetical scenario where the front-end might be able to gather and present something interesting from the additional data?

3A, 3B is currently used quite a bit I believe (no-op composite components)
3C is abused by quite a few frameworks, it's a good way around the static-ness of HTML DOM, but not something you would ever strive to replicate elsewhere

That's what I could make sense of right now, if it makes any sense... it seems to me there could be some value in comments as a "universal API", however slim it might be.
 Not currently.
  - [x] refs - make them callbacks instead of first class (@spicyj / @sebmarkbage)
- [x] Move propType validation to element instead of class (@jsfb)
- [x] Warning if class.type is accessed (@sebmarkbage)
  - [ ] Clean up internal (@jsfb)
- [x] Expose React.Component base class (@sebmarkbage)
  - [x] Fix context (#2898)
- [x] Deprecate keyed objects as children with warning. (@jsfb / @sebmarkbage)
  - [x] Add ReactFragment API, expose as React.addons.fragment?
- [x] Fix ReactPerf
- [x] Change unmounted setState checks from invariant to warning (@zpao)
- [x] Add enqueueStateUpdate (name?) to enqueue updates that depend on this.state being consistent (since this._pendingState is gone). (@sebmarkbage)
- [x] fix devtools (@sebmarkbage)
- [x] do something about refs timing(#3128) (@sebmarkbage)
- [x] warn for `getDOMNode`, `isMounted` uses within `render` (#3171)
- [x] warn for Maps as children (#3171)
- [ ] `@providesModule react` (@zpao) (needs syncup with flow, internal)
- [ ] `--target` option for `jsx` (@zpao)

Won't fix:
- [ ] Expose DOM component refs as the actual DOM nodes. (Monkey patch props, setProps, getDOMNode onto it as an upgrade path.)
- [ ] Warnings on using a DOM Component's ref's getDOMNode or props
- [ ] Fix the error utils guard. See ReactCompositeComponentError-test
- [ ] Deprecate setProps? What's the alternative?
- [ ] expose cloneWithProps on React proper (not actual cloneWithProps but the other one)
- [ ] Deprecate replaceState?
 Deprecate keyed objects as children sometime?
 ah yes.
 @sebmarkbage `getDOMNode()` is not defined for `React.Component`, shouldn't it fall under "warn for one release and drop the next"? PS. Well... it is defined with a warning, but it doesn't actually return a function.
 @syranide No, because `React.Component` didn't exist in previously releases. Not exposing it explicitly to prevent new code from relying on it.
 @sebmarkbage Makes sense, the problem I see with it is `this.refs.foobar.getDOMNode()` will now fail "arbitrarily", depending on whether the component moved away from `React.createClass` or not. I realize these are fairly rare circumstances, but it did bite me. I.e, it is not only the component itself that is affected, but the consumer of the component as well.
 @syranide That's why we also have `React.findDOMNode(this.refs.foobar)` which moves the responsibility out of the instance itself into a global escape hatch.
 @sebmarkbage Yeah definitely, what I'm saying is just this breaks the "first warn then break" approach React seems to generally take. Now, doing `npm update` and also getting an updated component could mean your app instantly breaks telling you to use `React.findDOMNode` rather than warning and also working as it should for now. But I personally don't mind, I've already fixed all call-sites... just saying :)
 This scenario doesn't break because of `npm update` but because you're also adding a new component which is why I think it is fine. :)
  Thanks
  This is the base class that will be used by ES6 classes.

I'm only moving setState and forceUpdate to this base class and the other
functions are disabled for modern classes as we're intending to deprecate
them. The base classes only have getters that warn if accessed. It's as if
they didn't exist.

ReactClass now extends ReactComponentBase but also adds the deprecated
methods. They are not yet fully deprecated on the ReactClass API.

I added some extra tests to composite component which we weren't testing
to avoid regressions.

I also added some test for ES6 classes. These are not testing the new
state initialization process. That's coming in a follow up.
 The idea is to make state a record-like object with fixed keys. E.g. you should specify all keys in the initial state and never add extra keys. It ensures type stability both for type systems and VMs. It also ensures that you explicitly define an initial and descriptive value.

We could potentially support arbitrary state objects, but props is also always an object (could also become a record). The idea is that these objects act as named arguments. That way it's always easy to add and remove new arguments. I think it's valuable to keep that consistency through out components.

You can always put anything else one level below it. `Immutable.Map` isn't ideal as the primary state object since it's dynamic. Something like `Immutable.Record` is closer to what I had in mind. We could potentially support `Immutable.Record` natively.

These changes are not set in stone. The reason I'm not supporting them **yet** is to make this new API more restrictive to ensure some kind of insurance of future compatibility. Please, feel free to describe your use case with some real world examples.

We're playing around with updaters returning state in which case it would probably auto-merge: https://github.com/reactjs/react-future/blob/master/07%20-%20Returning%20State/01%20-%20Stateful%20Functions.js#L17
 Let's move the replaceState discussion to #2843 since it's not directly related to this pull request.
  I'm going to :+1: @gaearon on this, explicitly setting the allowed state properties to `null` is good documentation and also an optimization (or two actually, reduce allocations and shadow classes). There has also been some mention (just mention) of only allowing to set state properties that exist, else throwing, which I think sounds like a really great idea and another reason why you would want it to be explicit.
 @gaearon Speaking of the devil... https://github.com/facebook/react/pull/2805#issuecomment-68723101

> The idea is to make state a record-like object with fixed keys. E.g. you should specify all keys in the initial state and never add extra keys. It ensures type stability both for type systems and VMs. It also ensures that you explicitly define an initial and descriptive value.
 Yeah ‚Äì if anything, we're going to warn when you add new properties to state that getInitialState didn't return.
  Updated docs examples/recommendations to use findDOMNode instead of getDOMNode
 Code change was already merged here: https://github.com/facebook/react/pull/2646

This new pull request is for the docs update.
 Yea, let's add the toplevel doc.
 Alright, lets address the notes and add this to the top level API docs, then we can merge this.
 @zpao good to go?
 @spicyj better?
 @jsfb shipit
  Seems fine to me apart from the style nits.
 Thanks!
 I don't have access to W8, but could it make sense to wrap the entire transaction in `execUnsafeLocalFunction` rather than each invocation of `setInnerHTML`? I.e. is there are measurable performance overhead? I sincerely doubt it though, but you never know... especially when it's MS.
 There's also [`WinJS.Utilities.setInnerHTMLUnsafe`](http://msdn.microsoft.com/en-us/library/windows/apps/br211696.aspx) which seems like a better method to use for each invocation... unless we intend to wrap the entire transaction in [`MSApp.execUnsafeLocalFunction`](http://msdn.microsoft.com/en-us/library/windows/apps/hh767331.aspx)?
 @stkb Aha, good detective work on `setInnerHTMLUnsafe`! As for wrapping transactions higher up, I doubt it's worth it but you never know, I don't ever think you'd be able to "feel it", but it could show up in benchmarks... even though I doubt that too. It's something to consider for the future at least. :)

On another note, I think [createNodesFromMarkup](https://github.com/facebook/react/blob/master/src/vendor/core/createNodesFromMarkup.js) needs to be wrapped as well (but it shouldn't reuse `setInnerHTML`) for this to _really_ work? (related #2340) I.e. if you perform an "unsafe update" it will still throw I think...
  Yeah, I think that error is too aggressive in catching things.  I loosened the restriction a bit in https://github.com/facebook/react/pull/2774 but it's probably still too tight, and that commit isn't going to be merged for a while anyway.  The workaround I've been using is to directly invoke React.createElement(), which bypasses the JSX transformations (since it's standard javascript, just put it between the squiggly brackets in jsx), but it's admittedly not ideal.  That error is going to be removed soon anyway, it was a temporary migration hack.

cc @sebmarkbage 
 This needed to be an error for one version, since it used to work but have a different semantic meaning. We don't want to silently swap semantics between versions. So we break it for one, and then reenable it with different semantics in 0.13.
 Let's leave it open until @jsfb lands his PR in master to fix it.
 This happened.
  One of the reasons we added it was because React may not load immediately and many tools wants to be notified once React is loaded an available. There might also be multiple Reacts on a single page or at least in multiple iframes.

The idea is that other tools can override and chain the `__REACT_DEVTOOLS_GLOBAL_HOOK__ .inject` hook by running after the devtools but before React is loaded.
 Monkey patching internals will break as soon as we start precompiling React using Closure Compiler so you'll need officially supported hooks. Just like the devtools and ReactPerf etc. will also need. 

> On Apr 29, 2015, at 12:41 AM, Dan Abramov notifications@github.com wrote:
> 
> Never mind!
> I started working on the next version of React Hot Loader, and monkeypatching is more convenient :-).
> 
> ‚Äî
> Reply to this email directly or view it on GitHub.
  componentDidUpdate (and componentDidMount) is always called after the DOM has been updated ‚Äì we can update the docs. Want to send a pull request?
  Not sure what formset is. Perhaps you meant fieldset? If I'm being stupid let me know and I'll reopen.
  Awesome! I started looking at this months ago but there were some bugs at the time. I'll take a closer look at this after the holidays just to spot check, but I think it can probably go right in.
 Nope, just never had the time to make it work right. Incrementally improving browserify pipeline was easier (since I knew it better) and it already worked.
 cc @RReverser who submitted a similar fix a year ago
 :thumbsup: Let's actually just do this for _all_ of the configs. That'll keep the differences between dev and min builds as minimal as possible.
 Thanks!
  Done.
  Thanks!
  cc @zpao 
 cc @spicyj 
 Updated.
  It's mentioned briefly in #1853 if I understand you correctly (just mentioning for posterity).
 Hmm, we opted for deterministic ordering of calls instead of special casing any specific lifecycle methods (see #1601). I totally get where you're coming from - we should consider this. cc @yungsters who originally proposed what we did in #1601.
 I think I'm in favor of this, though it's not obvious what order all the update methods should be called in when the mixins are interdependent.
 Sorry, did not see this until now. I am in favor of @rickbeerendonk's proposal. We should effectively reverse the order of `componentWillUnmount()`, so:

```
var MixinA = {mixins: [MixinA1, MixinA2], ...};
var MixinB = {mixins: [MixinB1, MixinB2], ...};
var Component = React.createClass({
  mixins: [MixinA, MixinB],
  ...
});

// Depth-First Traversal of Mixins
// MixinA1.componentDidMount
// MixinA2.componentDidMount
// MixinA.componentDidMount
// MixinB1.componentDidMount
// MixinB2.componentDidMount
// MixinB.componentDidMount
// Component.componentDidMount

// Reverse of Above Traversal
// Component.componentDidMount
// MixinB.componentWillUnmount
// MixinB2.componentWillUnmount
// MixinB1.componentWillUnmount
// MixinA.componentWillUnmount
// MixinA2.componentWillUnmount
// MixinA1.componentWillUnmount
```

The intent of the lifecycle methods is for `componentDidMount` and `componentWillUnmount` to mirror one another. Resources allocated or state mutated in the former should be reversed in the latter. As such, mixins that assume a particular state when mounted should be able to assume that same state when unmounting.

We're conceptually matching curly braces / HTML tags / etc. here.
 See discussion on #3290 ‚Äì mixins are effectively a legacy feature now and so I'm not going to merge my (breaking) change to their behavior even though I agree that it makes more sense that way. Closing as wontfix -- in most cases you can use higher-order components to get the behavior you want.
 We're not planning to change their semantics, instead preferring to recommend an official ES7 mixin solution if any appears.
 And no, we still discourage mixins for most use cases.
  Thanks!
  We explicitly say in the documentation that the goal of `isMounted` is to guard against setState:
http://facebook.github.io/react/docs/component-api.html#ismounted

So it's not right that it doesn't work in all cases
 @sbrandwoo My understanding is that you're supposed to use componentWillUnmount to clean up any timers, cancel async requests, etc.  Failure to cleanup is often a code smell that indicates a memory leak or other even more severe bug.  That said, in the case of an asynchronous callback, it's easy to imagine why it would be easier to just ignore the update rather than attempt to cancel the callback, and this is where isMounted could come in as a handy guard.

Once a component is unmounted, I think it is effectively dead.  I don't think it can be re-mounted (at least until opaque prerendered components are supported).  There really shouldn't be a reason to update it anymore, so doing so would strongly imply a bug.

Having said that, I don't see why you **couldn't** set the state on an unmounted component, and the expected behavior is that it would effectively be a noop.  My intuition would be to remove this error check and make setState and forceUpdate be valid at any time, maybe be a warning if you have findbugs turned on.

I suspect @sebmarkbage has strong opinions on this topic.
 Yea, there's no reason for this error to exist other than enforcing that you properly clean up your components. We could just as well ignore the value. I think that we'll likely make this a warning or at least make sure that it doesn't break reconciliation if it throws.

I would like to deprecate `isMounted()`. It's only really used as an escape to by-pass this error. The error is there to help you. If the easiest way to avoid the error is to add this `isMounted()` check, then it circumvents the whole purpose of having the error in the first place. You're not fixing the root problem. And as we all know, we tend to take shortcuts whenever we can. In practice, these go unfixed.

There are three separate scenarios in play here:

1) **Sometimes asynchronously and some times synchronously calling some method that might set state.**

This is generally a really bad idea. This is a race condition that will act differently depending on the timing of your system, so testing won't reveal scenarios that an end user will hit. If you write in a completely immutable style, it's not as bad, but still considered bad practice.

If you have cached values, that you would like to use instead of causing two renders, you can at least build a separate synchronous API for that. E.g. in getInitialState: `if (promise.hasCachedValue) return { value: promise.cachedValue };` It's better than violating the expectations of a Promise or async callback.

Additionally, in the current server rendering model, it's best practice to trigger async side-effects in `componentDidMount` since that will only fire on the client.

However, this is mostly a non-issue if (3) is solved since `setState` is currently still allowed in componentWillMount.

2) **setState in componentWillUnmount as a way to unify resetting values and clearing asynchronous callbacks.**

This pattern seems a bit unnecessary to me. Unmounting and and reaching completion is two different concepts and are usually different code paths. Even if they do the same thing, it might be worth separating them to make refactoring easier when one changes.

I don't see this as a major issue that we even need to error in production, we could warn in dev. It doesn't suffer from the same consequences as (3). So we could even drop the warning.

However, the question is: Is it more commonly an mistake or a legit pattern? If it's a legit pattern, then we should not warn since warnings are meant to be cleaned up. Excessive warnings creates apathy. However, even if it is legit, should we warn anyway because the majority case is a mistake? I'm not sure. I could go either way. I don't think that this is a common mistake but not sure.

3) **Calling setState when a component is completely unmounted.**

This is a strong indication that an asynchronous callback isn't being properly cleaned up. Unfortunately, mainstream JS APIs makes it very easy to avoid cleaning up hanging asynchronous callbacks.

One callback isn't a big deal. However, that callback hangs on to objects and intermediate callbacks, promises and subscriptions. If alot of your components do this, you will quickly run into memory issues.

This is a case of death by a thousand cuts. There is always a reason to avoid the complexity of cleanup logic, so you end up convincing yourself that it's ok for your special case. Then you run into GC and memory issues, and blame React for being slow. This is especially critical on mobile devices where memory issues can cause a browser to crash.

There are two types of callbacks. Infinite (or very long living) callbacks, such as event handlers that fire multiple times. There are also single fire callbacks such as Promises.

Promises are not as bad since they only resolve once before they can be cleaned up. However, they also live a long time. E.g. data requests can sometimes have very long timeouts to handle low-latency/bandwidth environments. The example above of a 30 second timeout is also an example of a long living promise. If your components frequently unmount and remount, you'll accumulate a lot of hanging promises and finally crash.

Therefore, it really bothers me that the JS community has adopted Promises at scale since it doesn't come with a cleanup mechanism. However, from a pragmatic point of view, we should probably allow this pattern to work since Promises are so common and make it very difficult to do clean up. You've been warned.

The big issue is that we can't really tell if the callback is coming from a Promise or a long living event. Failure to cleanup a long living event is a very common and dangerous mistake. So, how do we prevent that mistake from happening?

Even if the current callstack is coming from a Promise, that's no guarantee. That Promise could've fired a persistent event subscription that called setState. E.g. a Flux store.

Ultimately, I think that the solution is to build support for Promises in state. That way we can easily make an exception and ignore the warning if the Promise resolves late.

We should also build in support for Observables that make it easy to get cleanup for free.

We could easily ignore these setState calls but we'd need another way to ensure that you're not making common dangerous mistakes.
 @shubik React already fails pretty softly in a bunch of places that I believe should be fatal.  It's a complicated balance of making it abundantly clear to a developer exactly when/where things go wrong, vs. failing quietly.  I agree with @sebmarkbage that we need a way to ensure developers are not making common dangerous mistakes, and provide escape hatches (like isMounted) when developers know what they're doing.  That said, my intuition would be that setting state on an unmounted component would be analogous to a noop, so I tend to favor removing this error.
 We'll probably make this a warning. However, note that we treat React warnings as if they're errors, except with a different code path in the error case. I.e. you should strive to never have any warnings in your code base. Even with a warning, it's not a fully supported use case and risk breaking.

I would like to be able to fully support the use case, but what's the API? I don't know. How do we distinguish between the clearly bad case (hanging callback) and a valid (in your opinion) pattern?
 @gaearon that sounds like a bug either in your code or in React? Do you have a case that you're able to reproduce that we can take a look at?
 I have a case where we are using side-loading (Flux stores) at multiple levels within the component tree. There is a callback for the `change` event at the root level as well as at a child level. The root node callback gets called first and causes a re-render where the child node will no longer be rendered and thus gets unmounted, but the callback for the child's `change` handler still gets called and proceeds to `setState`. The child `setState` call now warns because it will be unmounted, but there wasn't a chance to stop the callback from being called.

I feel like side-loading being a first class citizen in React will cause this kind of case to be more common.
 @mridgway Does the child component unsubscribe from the store on unmount? If so, it shouldn't get event callbacks after unmount unless I'm missing something.
 It does unsubscribe in unmount, but the `change` event handlers are already executing in order that they were registered. By the time `removeListener` is called it is too late unless `EventEmitter` was smart enough to know whether a handler was removed from its list in the middle of handling an event.
 > Just ran into this today within a redux project - we're triggering actions in componentWillUnmount to unload some things, which triggers a state change and rerender. The state is bound in a HOC so we don't really have the opportunity to unsubscribe first, and as mentioned above a isMounted() check doesn't help.

File an issue in React Redux and maybe we can find a way to fix it.
  @mteichtahl - Just wanted to checkin regarding this issue.  Haven't heard anything in a few days; does that mean you got it working?  If you believe it's a bug in React, can you provide a simple example demonstrating the issue?
 Enabling harmony in the transpiler fixed the issue for @mteichtahl .  Closing out bug.

Thanks!  Good luck building your app!
  Thanks!
  Since we're using innerHTML and building up a string as we go, that's not currently possible. If we switched to using createElement it would be, but I think we'd like to keep that an implementation detail so we could conditionally switch (eg, it might be better to use createElement in modern Firefox but innerHTML in IE8).

I think the better solution will be to make sure our attribute support is more versatile.
 Which attributes need to be set before element injection in order to take effect?

Also, is the underlying issue that React doesn't let you set unknown/unrecognized attributes?  If so, perhaps this is a duplicate of https://github.com/facebook/react/issues/2746
 Closing due to inactivity, but we can discuss more if you still have an issue.
  Thanks!
  I can assure you this is not an oversight. We talked about this ad nauseum. As for giving it 5 minutes‚Ä¶ we've given it 2 years. This is a design decision and not a bug.

> class in jsx can be transformed className in js

We actually did that initially but it takes away from real uses cases where you want `class` to be the prop. Remember, Composite Components are a vital part of React, not just DOM components. For example `<Teacher class="Physics" />`. Transforming that to `React.createElement(Teacher, {className: "Physics"})` is a terrible idea. It's super surprising and entirely outside of the programmer's control. Inside the `Teacher` component, you should access `props` as they are specified.

The same goes for the hyphenated -> camelcase idea. You're specifying values one way and reading them another.

Keeping the JSX transform as simple as possible is a real goal.

We're not going to support something just because a couple people :+1: it. We're opinionated here. We're happy to be unpopular with a few people if we ultimately think what we're doing is right. On the other hand we're not so confident that we won't listen to people saying we've made mistakes. But in this case we've spent a lot of time thinking about it and we're not going to change.
 Calling somebody a liar really doesn't get you far. FWIW, we've talked about _exactly_ this topic many times over the last 2 years, and that's the truth.

> Yeah, good thing nobody was suggesting that.

That was suggested: https://github.com/facebook/react/issues/2782#issuecomment-68263926

> as demonstrated by your complete and total misunderstanding of the example I gave (as though you didn't even read it):

Below is the only example I've seen from you, from #2781:

```
var root = React.createElement('ul', { className: 'my-list' }, child);
```

As far as examples go, it really doesn't give me much to go from. You said you want to use `class` there instead of `className` and I explained why we don't do that. The reason provided there applies more broadly across other properties.

If you're going to continue being hostile and insulting me, my team, and the other helpful people we work with, I'm going to ask you to remove yourself from any involvement with the project.
 üîí
  `class` is not prohibited. You can use it. But you're right that we don't support it for DOM components.

We are already deviating from pure HTML (it's XML, we camelCase attributes, have other enforcements). Overall we're using the JS API for attributes so `className` fits in (`node.className = 'whatever'`).

We're already years deep on this commitment so we're not backing out, sorry.
 > Why?

To make it all easier to understand and parse. An HTML parser is hard and has lots of edge cases. XML-ish is much easier to parse because it has stricter rules. The other part of this is that we are trying to make it clear that this still becomes pure JS with minimal processing.

> - Search: `.className =`
> - Replace: `['class'] =`

`node['class'] =` doesn't work in any browser AFAIK. It's not part of the DOM API.
 (Wow we're still on this! lol)

IIRC the thing that killed this is `let {class} = obj`. Restructuring and pulling out the `class` key. Doesn't work because it conflicts with the upcoming `class` keyword. That should end the discussion right?
  Like this? http://jsfiddle.net/vq1texr5/
 Looks like this works :)
  This is totally unrelated to react/JSX. Please use other resources for such questions (stack overflow for example)
  I feel like we've said no to this with good reason before but I can't find the link. Regardless, the discussion for extending semantics of JSX belongs in the issue @bloodyowl linked to. @sebmarkbage, perhaps you remember where we've talked about this before / can weigh in.
 We're deprecating our own JSX transform so going to close this out.
  I would love to but as long as Facebook supports ie8, so will we.
  Added info (example+doc) about react with webcomponents
 I don't think we'll want to add this to the main docs until it's properly **supported** and tested (e.g. used in production by someone). We still have some things to fixed before we're there. E.g. the attributes whitelist and figure out the event bubbling situation. We can keep this PR open while we work on it though.
 @sebmarkbage We now have attribute whitelist.  We punted on event bubbling, but I think/suspect that we're now in a state where people can reasonably play with them.  If I were to rebase, would we merge?
 We would need to make it very clear that event handling is broken.
 Rebased, added a note about imperative APIs and events as per @sebmarkbage.
 @sebmarkbage Added note a month ago, just rebased again to resolve merge conflict.  Any objections to merging this?
 @jimfb updated the pull request.
 @jimfb updated the pull request.
 @jimfb updated the pull request.
  :thumbsup: thanks!
  tl;dr: If you have a component that returns `null` and it rerenders, the noscript tag is unmounted and a new one is created because shouldUpdateReactComponent gets `<ReactEmptyComponentType />` and `null` and returns false.

---

This came out of some internal components that were breaking after the most recent update.

I haven't gone to see if this is more widely broken - it might have been before any of the recent updates, just that the empty component is triggering it reliably. I've been some reports of `<img>` having similar weird problems that we couldn't track down. It's use of `LocalEventTrapMixin` is very similar to what's happening in `ReactEmptyComponentType`.

The trigger here is that we're triggering an update during the mount phase. When we do this `<Child key="0">` works correctly because it's before `<Child key="1">` which is triggering `Parent` to rerender. `<Child key="2">` is the broken one because its `componentDidMount` hasn't been called yet. So we actually call its `componentWillUnmount` first. Then we still call its `componentDidMount`.

There's also the whole question of _why_ we're trying to unmount anything at all here. It seems like we shouldn't be doing that.

cc @sebmarkbage @spicyj

Drop this into examples/basic-jsx-harmony and debug with pausing on caught exceptions. I added some breakpoints in ReactEmptyComponent to make it super obvious.

``` js
'use strict';

var Child = React.createClass({
  componentDidMount() {
    this.props.onMount && this.props.onMount();
  },
  render() {
    if (!this.props.visible) {
      return null;
    }

    return <div>hello world</div>;
  }
})


var Parent = React.createClass({
  update() {
    this.forceUpdate();
  },
  render() {
    return (
      <div>
        <Child key="0" visible={false} />
        <Child key="1" visible={true} onMount={this.update} />
        <Child key="2" visible={false} />
      </div>
    );
  }
})

React.render(
  <Parent/>,
  document.getElementById('container')
);
```
 Why it's unmounting: When comparing the old `null` to the new `null` in `_updateRenderedComponent`, `prevComponentInstance._currentElement` is actually `<ReactEmptyComponentType />` whereas `nextRenderedElement` is `null`, so `shouldUpdateReactComponent` returns false.
 Why it's throwing: the three componentDidMount calls get queued in the order they were rendered (Child 0's null, Child 1, Child 2's null), but because batching doesn't happen on an initial render (something I've been meaning to make happen‚Ä¶), the forceUpdate happens synchronously and causes the unmount/remount of both child components, after which the old enqueued Child 2 null did-mount callback runs and throws, because that component isn't mounted any more.
 (Two issues; we should fix both.)
 The first one is a new regression, right?
 Not sure, but I think so. I added a test recently to ensure that text components don't get remounted on update; we should add one for empty components too.
 Initial render isn't asynchronous but to change it, I think we'd need to change the API to pass the instance to a callback instead of synchronously returning it.

We should be able to queue up new updates during initial render though. So that they're guaranteed to happen after the queue as processed.
 Right -- that's what we do already for new mounts of child components within a larger update.
 The second issue should be fixed now because we batch on initial render. Not sure about the first; it's probably still a problem.
 @sebmarkbage Maybe you can fix this.
  This throws an error that is immediately caught. This allows you to use the
debugger's "break on caught exception" feature to break on warnings.

This should help with tracking down these warnings using the stack.

However, it could also add more noise to other debugging pattern.
 Remind me the next time I sync to pick this up - `vendor` is a slightly different process.
  Just to clarify, `onChange` OR `setTimeout`, both are not necessary. Anyway, as I mentioned in the tweet, unless I'm mistaken this should be correctable and corrected in React so that it works with onClick as well... it shouldn't be very hard. I'd love to take a look at it but I'm still way behind on the rest of my PRs right now :(

PS. Thanks for opening the issue.
 Might be the same as #3005? (I realize this was filed first.)
  Your code there doesn't run so it's a bit tricky to actually see the problem.

My gut is that you're expecting `defaultValue` to work across multiple renders. It does not. It is only used on the initial render. Rerendering with different props or state will not update the actual DOM node. Take a look at our docs on controlled components.
 It sounds like the props are empty on first render? Since we only look at `defaultValue` on initial render if `this.props.dados.titulo` is empty on that first render, we'll never populate the form.

I really think you want to make use of controlled inputs here. I meant to paste the link last time - http://facebook.github.io/react/docs/forms.html#controlled-components
 You're right that the big problem is not props BUT it's important to understand that the fact that props change is the reason you are having a problem.

Yes, the first code you wrote will update the value when props are updated. This is because `value` makes the input controlled (see docs). The second line of code will not update. _`defaultValue` is only looked at on first render_. So the first render will see that `this.props.whatever.title` is empty and set the value to that. The 2nd render (when the props are updated) will not even look at `this.props.whatever.title`.

There's a misunderstanding happening here but no bug with React so I'm going to close this out.
  It's not a bug but maybe confusing docs. It's the creation order of the DOM elements. It has nothing to do with being in the document or not, since we cannot guarantee that anyway (since the root may be out of the document).

@thheller, what's your particular use case for the top-down order?

Technically the life-cycle methods only guarantee that your particular component is mounted. It doesn't make any promises with regard to it's children. Relying on this order is usually indication that you're breaking the encapsulation boundaries of components.

For example, if your component renders another component, that component may choose to delay rendering it's children while loading data (even if they're passed from above).
 @thheller Yea, that use case seems very mutative in nature. You might be able to use `componentWillMount` instead.

> I was thinking more about relying on DOM ‚Äúcomponents‚Äù (i.e. if you have a ref, its node should be there by the time componentDidMount happens).

Technically, this is breaking the encapsulation of what a "DOM" parent does. It should be allowed to defer rendering it's children too. The direction we're going with first class refs, allow you to respond to a child's mount event, regardless if that happens later.

> You can actually figure out whether you are in the document or not quite simply. Just walk el.parentElement till you either end at null (false) or document.body (true).

Yes, but you can't reliably and fast wait for it to become true (e.g. MutationObservers) cross-browser. We could throw if it's unmounted but that would hurt some use cases.
  #1570 it's easy to reconstruct the IDs during client render, but until React can go all the way (like in the PR), the entire rendered tree would have to be updated with reconstructed `data-reactid` during first client render which may or may not a bit of a perf issue.
  :thumbsup:
  Thanks!
  I'm just going to point at #2746 since I wrote a long reply there. I'm sure we have this tracked elsewhere as well.
  Can you make a minimal repro case, like in a jsfiddle? It's not obvious to me what the issue here is but it's hard for me to set up and run your example so I can't test.
  Thanks for reporting -- we should either work seamlessly with uppercase tags or warn when you use them.
 @spicyj Sticking to case-sensitive makes most sense to me, especially as some SVG-tags actually have casing.
 Probably the same place where we check for dangerous tag names (https://github.com/facebook/react/blob/master/src/renderers/dom/shared/ReactDOMComponent.js#L287) would be a reasonable place ‚Äì you can rename that function and add a `__DEV__`-only warning for this there. ReactDOMComponent-test is probably a reasonable place for a test but if you find somewhere else, that's probably fine too.
  The preferred way is to use onChange, which is polyfilled to behave like onInput in all browsers, including ones that don't support it natively. Is there a reason that doesn't work for you?
 @ryanzec `onChange` as provided by React is not the standard implementation by the DOM, it's basically a lesser but polyfilled `onInput`.
 @ryanzec Lesser because onInput will fire immediately after a change, but onChange may only fire when focus changes.

I'm actually a little curious why we didn't take this.  It seems perfectly reasonable to me.
 @jimfb No, our onChange is special, as @syranide said, and fires on every keystroke. You usually should not use onInput because browsers have a plethora of different bugs with it and onChange (for the most part) normalizes them away.
 @spicyj So should we warn if users attempt to use `onInput`?
  :thumbsup: thanks!
  Odd ‚Äì I was under the impression that fastclick works properly with React.
 Most mobile browsers have already fixed this.  https://developers.google.com/web/updates/2013/12/300ms-tap-delay-gone-away?hl=en

Also, as per https://github.com/facebook/react/issues/436#issuecomment-178268985, we are probably going in the opposite direction and pulling the tap event plugin out of the core.
  Good catch :) Thanks!
  We do both, sometimes within the same test file. There's probably 3rd pattern too. This is annoying and ugly. We should do better.

I think we should probably make use of `spyOn` - it feels a bit easier to work with.
 Awesome! :) Sorry for the delay in getting back to you though.

What brought this on was actually related to `console.warn` and our testing for warning messages. There are a bunch of places where we set `console.warn = some mock fn`, use it and assert on calls, wrap everything in a try/finally, and then reset console.warn to the original.

Jasmine has all of this built in with `spyOn`, which we use in a bunch of other places to do the same thing but in a less crazy way.

There may be some other patterns like this but the console.warn one was what I was thinking of when I filed it.
 Yea, let's call this fixed. There were a couple passes done to clean this up.
  My bad. :( It' because the public setState uses `.bind()` internally. It should ideally just pass through it's `this` context all the way to the enqueue updates.
  Before `createElement` we had a hard coded list. We still have that list in the transform for deprecation purposes but as you noted you can pass anything to `createElement` and it'll work. There may be some special cases for custom elements that we haven't accounted for.

As for attributes, there is some work but the plan is to let anything through eventually. We need to make the transfer and consumption of `props` better, otherwise it will be super easy to put way too many props on DOM elements. We still need a whitelist of attributes that have special requirements so we can make sure we mutate nodes correctly. We can probably just use `setAttibute` for many though.

And lastly for namespaced attributes, there's a bit that needs to be done. The first is just adding support so we know when to use `setAttributeNS`. The 2nd is deciding how we write them in JSX. JSX doesn't support `namespace:attribute={value}`. Even if it did, what does that transform to? It can't be `{namespace: { attribute: value }}`. Our best path here will probably be to make `namespaceAttribute={value}` the way to do this, but unless we expose a way to register properties we'd have to whitelist everything possible (xul, svg). We have the mechanism to register properties (it's how React works internally) but it's not publicly exposed as it's not clear how we should handle collisions.

We did talk a long time ago about exposing a way to register elements but as we get rid of the whitelist it doesn't make sense moving forward. Registering attributes may be a thing though. We need to figure out the details of all of this to support web components so it's definitely all in progress.
  This is where tests of static prop types should go when we have the
infrastructure set up to handle it.
 @pspeter3 I don't know yet. TypeScript doesn't make it as easy as Flow. Not sure if we want to support it yet or not but if we do. This is were they would end up. :)

I'm mostly interested in getting the testing infrastructure set up so that we can experiment with it.
  Hopefully @gaearon's answer helped, he explained this probably better than I would have :)

Explicit unmounting is only done on the roots and that's just how React works. If it's not clear why I'm closing this out, let use know! Good luck!
  We should make the link in the tutorial more prominent. We already have implementations for node, python, and ruby in the companion repo - https://github.com/reactjs/react-tutorial/
 On the other hand, getting `http-server` requires installing another tool over the internet whereas if you have Python 2 installed, `SimpleHTTPServer` is built-in and just works.
 The tutorial doesn't really assume you went through getting started (you don't need npm to do the tutorial, that's why we have a starter kit).

Let's not get too pedantic here. Let's not argue about node vs Python. We know this needs to be better and I think having a place that offers different servers to run in whatever language you want is ultimately the best thing.
 #2824 landed, so I'm closing this.
  JSX is not HTML and has a distinct set of parsing rules that are very close to to XML. It makes rules explicit and avoids special cases link some tags not being closed. We won't be changing that.
  ```
Error: Minified exception occurred; use the non-minified dev environment for the full error
message and additional helpful warnings. in /build.js on line (of invariant implementation)
```

Perhaps there are larger issues preventing this, but considering production errors encountered by a user rarely has access to stack traces, so you only get the single top-level error location... if an error is thrown by React today that's all you know, an error was thrown.

It would be nice if `invariant(...)` was replaced with `if (...) throw new Error(...)` instead. I could then report vaguely meaningful error locations which could at least hint at what the error is, React would also avoid the invariant invocation overhead then.

cc @zpao @sebmarkbage @spicyj 
 I think something like #2686 is a better solution. E.g. surfacing an error code or something in production. Maybe a hash of the original message.

The reason I don't think `invariant(...)` matters is that these checks often end up in common validation helpers. This is particularly common for warnings but also for invariants. We shouldn't have to take the levels of the stack trace into account when structuring our internal code. So even if we moved it one level, the next level will still be problematic.

Besides, you can catch complete stack traces in production in most browsers. That should be part of your error message / logging solution. That will give you much better error messages anyway since you can track the source in your own code easier.

*) We have experimented with converting `invariant(...)` to `if (...) throw` using a transpiler. That has shown to be a performance boost. We can also safely strip the error message for production builds. Especially in non-JIT environments and since a lot of our code currently deopts. That's unrelated to the problem of stack traces though.
  We got rid of this integration for the time being so closing out.
  Thanks!
  Yea, this seems like a fine way to address the problem. Thanks!
  @1st1 If you haven't "figured it out" yet, just defer the unmount and it should all be fine (until this is resolved one way or another).
 Yeah, this should be fixed now. Thank you!
  That's kinda crazy :open_mouth: 

Anything we can do here or can we just close this out?
 React's Context (if that's what you meant) hasn't changed but many other things did.

Could you make a minimal sample app or something? I'm not familiar with node-webkit and how that works so it's pretty hard to actually understand the problem and what might be going on.
 Ok, I see now - it sounds like there were some more uses of `window.document` instead of just `document` so it wasn't failing hard before. However I think it's pretty reasonable for us to make that assumption (all uses of `document` should be protect by our `canUseDOM` check). If you're mimicking a browser environment with something like node-webkit and using a library that is made to run in the browser, then having to add globals that I would expect you to have to do. I'm actually a little bit surprised node-webkit doesn't do that for you.

You can see our check here: https://github.com/facebook/react/blob/master/src/vendor/core/ExecutionEnvironment.js

We could perhaps be a bit more restrictive (maybe add a `window.document === document` check), but I don't think it's really worth protecting against every potentially different environment.
  This sounds like a dupe of #1326; merging.
  I'm not sure what you're seeing. If you write

```
<MainComponent>
    <h1>Hello <b>World</b></h1>

    <p>Hello world!</p>
</MainComponent>
```

then `this.props.children[0]` will be the h1 element from within MainComponent. If you're seeing otherwise, please post a simple repro case and I'll take a look.
  No, the plan is for React.withContext to go away.
  Probably another consequence of #1326. 
  cc @salier 
 cc @joshduck 

Interesting. In IE11, `selectionchange` fires before `input`, and doesn't fire at all while typing. I'd call this incorrect on both counts. http://jsfiddle.net/salier/3ngv6nf0/

The path of least resistance might be to stop using the native `selectionchange` event in IE and instead use the fallback we're using for Firefox. We're already ignoring the native IE `textinput` event for similar inconsistencies, perhaps we need to do the same here.

I'll investigate a bit further.
 The lack of event on keypress sounds familiar. The w3 look to be currently standardizing the API (http://www.w3.org/TR/selection-api/). Hopefully they can resolve the ambiguity and IE will update their implementation. In the short term ignoring the event sounds OK.
 Sorry for the long wait. I'm working on this now.
 Fixed by #4559.
  Good catch. I actually needed to sync a couple other bits from the 0.12-stable branch so I just did that instead. Thanks for the reminder though! https://github.com/facebook/react/compare/f13b4641bbb1...558afae61a89
  Access is being removed. It's already gone in master.
  lgtm, thanks!
  Curious ‚Äì can you give a real-world example of when this would make sense?
 We actually have something similar for controlled inputs.  If an input specifies a value property and does not specify the readOnly property as true, than we require that it specify a onChange listener.  I don't think dependsOn is sufficient to describe this use case (because of the conditional on readOnly), but it is an interesting data point.

I tend to agree with @pletcher, in most cases that sounds like an antipattern.  Cases in which such a thing is justified are rare enough and smelly enough that I don't mind making a developer jump through a hoop to implement it.
  :thumbsup:
  This is indeed intentional. The first syntax isn't really supported yet, and as it isn't related to React, we chose to avoid the React runtime dependency for it. If/when we want to promote that syntax more broadly, we'll be sure to note the need for a polyfill in the docs.
  At this point no there is no better way. I don't think we'd really considered this case. It's a known issue that using multiple copies of React on a page will cause problems but our typical answer of "don't do that" doesn't really apply here.

I think there are a couple longer-term possibilities. The first is to remove the use of that attribute entirely and not stick ids in the page. The other is to generate a random prefix for the attribute (or the values) at startup. That's essentially what you did. That way each runtime would be mostly isolated.

cc @sebmarkbage @syranide who have talked about some of these things before
 @gaearon I have a PR up for exactly that, but it's somewhat thrasing and the devs prefer to know the full story (there are many different ways it can be done and some may be faster than others), also React has a few currently irrelevant bugs which my PR trips on bad. But I definitely see that it is very much possible and seemingly even preferable from a performance perspective.

#1570
 I should also mention that a simple workaround that does not involve building your own version is to just exec `require('react/DOMProperty').ID_ATTRIBUTE_NAME = 'data-reactid-x'` unless you're using a prebuilt package.
  I totally agree that this feature is neat but also unexpected. This is a side effect of picking up our ES6 transforms from [jstransform](https://github.com/facebook/jstransform) and those transforms coming out of our internal codebase where we wanted to enforce "underscore means private so don't even try" convention.

As it stands we can't easily turn this off so I'm going to close out. It would be interested to bring this up in the jstransform repo though. The people actually maintaining that might have other thoughts.
  Please post this question in [another venue](http://facebook.github.io/react/support.html) (mailing list or stack overflow). We try to keep GitHub for bugs and issues with React itself.
  This is close enough to #2680 that I'll close this one and track there.
  Thanks!
  There's a lot more discussion in #2112.
  :thumbsup: Thanks!
  Thanks for following up.
  It seems to work just fine for character keys for me... any specific version/environment?
 Also can't repro this in Chrome.
  Unless they've added https support recently this isn't going to work. Trying to load one of those links you updated doesn't seem to work.
 @impinball updated the pull request.
  I think this is effectively a duplicate of https://github.com/facebook/react/issues/2746, so I'm going to close as duplicate.  Please reopen if this is the incorrect action.
  Thanks for the heads up. #2679 took care of it and will go out in the next website update.
  Thank you for the PR, and sorry about the long wait. Now that #5714 is merged, all attributes on SVG elements will be passed through as is, with no need for the whitelist. I'm closing this but please let me know if you have any troubles in master.
  Seems sane to me on the surface, though I'm not sure how it'll play with mixins in the future and what the migration path might be. So cc @sebmarkbage 
 This is reasonable but this is also an area where different polyfills will screw up. For example, our own Object.assign polyfill doesn't copy real symbols. Likewise, not all Symbol polyfills add the getOwnPropertySymbols feature. The overlap of polyfills might cause issues so I'm tempted to wait that out a bit to see how that space shakes out.

It's also not clear that Symbols will be the primary way of using private state since it's observable through this method. WeakMaps are a safer way to keep completely isolated private state.

I'm curious out your use case though. It seems to me that if they're completely private, they don't have to be on the instance itself. They can just be module level functions. Are you somehow using the virtual nature of them to combine multiple mixins that share a Symbol for certain methods?

It might also be useful to put Symbols in state. We will at some point start using the native Object.assign if one exists, which will copy Symbols too.
  What does https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/rest_parameters use for "rest parameters"?
 Awesome, thanks!
  Yuck. This is due to autobinding, I guess. In 0.13 RC it gives an error:

![image](https://cloud.githubusercontent.com/assets/6820/6405383/b1fe57ea-bdd7-11e4-8017-58c45d878ebd.png)
  Yup, closing this in favor of that issue.
  I don't know Chinese but I will believe you :)
  This seems like something you should take up with react-bootstrap. It is possible to maintain state - each tab content would need to maintain a hidden prop and just always render all tabs (even if some are `display:none` or whatever).

But to answer your root question, yes unmounting means the references are gone and data will get GCed.
  See #1302 and #1305 ‚Äì we'd like to do this but last time it wasn't possible due to some mocking problems.
  I would sooner have a REACT_ENV or something that takes precedence over NODE_ENV, but changing how this works will cause a lot of pain since everyone would need to update their build processes so I don't want to do it lightly.
 @spicyj On another note, could it not make sense to have IDs associated with errors and keep those in the minified builds along with outputting the additional arguments provided, that way you can always match up the message and values later without significantly impacting bundle size.
 @syranide Yeah, I do want to do this. It's probably the best solution here.
 > I also use GetSentry and once React starts to throw an error in a render method is generates a lot of errors afterward and make a lot of error reportings in GetSentry.
> 
> I guess it is related to catching errors in render() too, and some existing issues like #5528

Yes, this is #2461 which is a large project but obviously important.
 As a summary we should try to solve something for this while also optimizing for constraints:

1) React is big to download/parse!
2) The React ecosystem has too many options/configurations to learn!
3) React is too slow!
4) Error messages are too short and cryptic!
5) Different tools doesn't work with different combinations of global configurations/compliers.

Solving one issue at a time doesn't work for constraint solving. „ÄÄ

Anyway. This came up recently again. I think it was in a React Native issue. The solution I suggested there was that we'd compile to error codes and put them in a lookup somehow. Like @syranide and @spicyj suggested above.

This is what we do for stack traces. Minified and compiled code often doesn't have legible stack traces or even the stack frames at all for the debugging. Source maps reinsert them so that's what we should do as well.

This seems like a much more general problem though. This is something the ecosystem needs to address, just like what to do about `console.error` calls from our warnings. I don't think the React repo itself should be on the hook for solving general JS problems. Maybe React should just spit out `throw new Error('...')` and stripping the error message + generating a source map + error code lookup file is left up to your minifier/compiler. Someone should build this solution for Babel and then we'll adopt it.
 Note that preserving error messages is not a very standard feature of programming languages in general. Many native application just provide very small and coarse grained symbols.

Systems like C# or Java that preserve them don't have to deal with the problem of download size and memory usage.

Error messages at scale add a lot of bytes to an application and stripping them out is a significant win. You could imagine a compromise with shorter messages, but if you need to look up what it means, you might as well just go all the way and add an error code.

Right now the relative size is pretty small but we have plans on focusing on minimizing the byte size of the React package because it has been of some concern to people. At that point, these messages will represent a significantly larger relative size that it will start making an impact. When you expand the problem to Relay and React Native it becomes more noticable.

Of course, we could put this burden on the end user of our library. E.g. if you don't have a compiler for your website, then you don't get it and your users suffer for it. That doesn't help for CDN usage and we're also not being very good citizens of the community. Many sites don't have very advanced polyfill and compiler solutions. To some degree, we cater to a lower common denominator so we want to provide a decent solution for existing tooling.

Similarly, we do include an Object.assign polyfill by default even though we could just require you to have a polyfill. There isn't really good standard solution for global polyfills in Node for example. So we just do it ourselves so that most people get a decent production set up by default.

I'd be happy to have our transform spit out some unique error code for each message that goes into a json file for reference though. That way you could restore the error messages.

Note that our thrown errors are not super helpful anyway. Less useful than the warnings. I'd be curious to see what kind of errors you get and if it is much more helpful.
 I think the bigger issue is that we intentionally remove a lot of our thrown errors all together because the test adds execution time to hot paths.

Since we have so few errors left, maybe it doesn't matter anymore, but it also doesn't solve the issue.

What you really want is the ability to add fine grained error tracking for a subset of users that include some of the warnings. Our new devtools plugin system will hopefully let you do that at least for "profiling" builds of React.
 That's generally just for dynamically linked, right? For statically linked libraries like is common on iOS, you optimize those symbols unless you have the debug symbols locally which is similar to a source map.

Source maps does include references to source code and the ability to expand a stack trace to more frames, e.g. when a function was inlined. So you can reproduce the stack trace. React Native's error messages does this by default for example.

Btw, we don't do anything to change execution flow between modes. We've had a lot of production bugs due to such strategies in the past (both JS and native). An example is that you do a network request or mutation right after an assertion. If it gets aborted in development mode it might look like a small bug. You'll never know how bad that crash will be when it goes into production when the network request or mutation continues along. We've had pretty bad bugs due to this so we've made it very intentional to never change execution flow.

This means that we don't strip out assertions that would crash or throw in development. Similarly, because we want to be able to strip out the more expensive assertions, we turn them into logs instead of throws.
 @jedwards1211 do you have an example of an error (non-contrived) that only occurred in production?  While it is conceivable that such a thing could happen, it should be extraordinary uncommon in practice.  If it does happen, we'd like to know asap.
 @jedwards1211 The tricky thing about race conditions is that, in a build with better error messages (and potentially some warnings), you're still going to have a performance impact.  The main differences in performance are a result of us eliminating all the debugging information and logic.  If you add that info back into the production build, the performance characteristics will likely resemble those of the dev build.

> to throw errors that would get caught and minified by React

React won't catch/minify userland code/traces.  If your userland code is minified, that's some other tool in your tool chain.  If you just want an unminified production build of React, you can build dev with `NODE_ENV=production`, which would get you what you want (an unminified production build).
 @jedwards1211 I think the example you mention requires a middle ground build. Something that have most of the expensive checks removed so that the race condition gets hit in time. But still with nice debug messages.

The problem with this is that these different options create an explosion of different options. You could conceive of a configuration which would catch this scenario but not another so which configuration do you use? Then we have an explosion of best practices that all depend on whether someone hit a particular scenario involved. I think it configuration like this needs to have a very high bar.

Luckily there has been talk of a PROFILE configuration. A build that is set up to run at near full speed while retaining a lot more debug information for profiling purposes. It is designed to be used on development machines. Perhaps your scenario would've been satisfied by that option as well.
 > I just want to point out that, without this change, we will be forced to build our React app in development mode anyways ‚Äì thereby stripping all the benefits you're discussing above.

I would not recommend this as dev builds can be 5x slower. This is hardly a small performance improvement.

> fundamental successful bug-free operation of my application

Can you please help me understand how React invariant error messages relate to bug-free operation of the apps? The errors _thrown_ by React are rare and are generally not very helpful anyway because they usually indicate bugs in React itself. These get reported to us regularly from dev builds, and we try our best to fix them. Are there many scenarios where getting an exact internal error message would be helpful to you?

(For the record, all errors thrown [in my app](https://github.com/facebook/react/issues/2686#issuecomment-67057286) were due to rendering directly to `document.body`. React now warns about this in development. So these things do tend to shake out naturally.)
 > But that's not awesome either ‚Äì the purpose of our staging server is to mimic our production environment as much as possible ‚Äì and not everybody has access to additional servers to do this kind of verification.

This would get solved by providing a separate profiling build that‚Äôs running the production codepath but without minification and with a little bit of instrumentation. You can track this work in #6627.

You may then choose to run this build in staging, or even run it in production, as the perf impact would be much less than in DEV builds.
 > will **PROFILE** additionally keep error messages intact?

AFAIK there are no plans to minify it so I would expect so. We can discuss this in #6627.

> And can we realistically recommend to React + Sentry users that they can safely/confidently use **PROFILE** in production?

If anyone is using _dev_ builds for this purpose today, they will certainly be better served by a profile build. The profile build would still be slower than a production build but if this is an acceptable tradeoff to them, sure. In any case a necessary pre-requisite is for us to actually implement that build. I‚Äôll be looking at that in the coming weeks.
 @keyanzhang started working on an error code system in #6874.
Check it out and let us know what you think about the plan!
  See https://github.com/facebook/react/pull/2169#issuecomment-56889182
 Sorry, we don't support quirks mode and don't have plans to as it's sort of like supporting IE 5.5.

(Note that jQuery also doesn't support quirks mode: http://contribute.jquery.org/wont-fix/#quirks-mode) 
  6379342b717feed7ebf1e5abcbe512b92e25b3d8 landed in master already and we'll be sure to cherry-pick it when we do 0.12.2. The official builds should already have trailing commas stripped, and you shouldn't have a problem if you minify your code or run something like https://github.com/spicyj/es3ify over it.
 I understand. The official unminified build has trailing commas stripped using es3ify; you can do the same if you're getting React from npm.
  Hmm, I think this is actually a result of us blowing the stack. `setState` isn't supposed to be callable inside `componentWillUpdate`. It looks like we may have inadvertently removed a check.

We should fix this in master and backport for 0.12.
 @jsfb - can you take this? We explicitly blocked this in 0.11 and threw `Error: Invariant Violation: replaceState(...): Cannot update during an existing state transition (such as within`render`). This could potentially cause an infinite loop so it is forbidden.`. We lost this check in 0.12 and that carried over to 0.13.
  This was fixed in #2482 and will go out with the next release. It's on the list of things to be backported for a 0.12.2 release.
  Can you please provide a JSFiddle reproducing the issue?
  Thanks!
  I think this seems like a pretty reasonable thing to do in React. We fixup other properties. cc @syranide 
 I'm not overly familiar with all the intricasies fo dragdrop/dataTransfer, but IIRC there's quite a lot that can be normalized/polyfilled and that seems like a worthwhile endeavour to me at least! :+1: 
  :thumbsup: thanks!
  It's true the "lifecycle" is not really a cycle on the server. `componentWillMount` is called but the rest aren't. We've documented this for a long time as the exception. The reasoning is that `componentWillMount` can actually affect state before initial `render` so we do need to make sure it's called on the server. If we only called it on the client then the initial render could be different and the whole checksum would fail. We have considered forbidding the call to `setState` in `componentWillMount`, which would eliminate the need to call it on the server but until then (if it happens) it is necessary.

For your case with listeners and whatnot, it's probably better to set those up in `componentDidMount`.
  Hi @hallgren,

These tasks are primarily for tracking changes needed to the react code base.  Since this is more of a general question related to React and other diffing libraries, you'll probably have more success asking on StackOverflow.  I'm going to close out this issue, since it's more of a general question for the community rather than a bug.  Closing the issue doesn't prevent others from jumping in and responding (I encourage anyone with a good answer to do exactly that), but it does take the issue off our todo list.

Is there a reason you're using a controlled component rather than an uncontrolled one?  It sounds like uncontrolled components mostly do what you want.  If you need to do something fancy to your component, you can always break out of react and use the DOM imperative API (though, obviously this isn't the react way, and isn't our official recommendation for building react apps).

Good luck with your project!
 My understanding is that an input type="submit" results in a button, which is inherently not editable by a user, so I don't think the concept of controlled/uncontrolled exists.  cc @spicyj 
  Thanks!
  Thanks! @zpao 
  What's the problem?
  Wouldn't this require walking the entire component tree to collect all the shouldComponentUpdate return values?  One of the main benefits of shouldComponentUpdate is that if you have a node with a large number of children, you can tell React that it doesn't need to talk with the hundreds/thousands of children nodes.

Most components don't implement shouldComponentUpdate (it's really an emergency escape hatch for extreme cases where you need to do manual perf optimizations), and the default implementation is to return true.  Also, it's very difficult to generalize this function, so it is usually used then the developer has a firm understanding of the implementation details of his/her page, and knows the behavior of all the child components.  
 For what it‚Äôs worth I retract my +1 on this before. I‚Äôve written some pretty terrible code with smart mixins and I no longer use them. Any kind of merging behavior here encourages components keeping implicit state in mixins, and this turned out to be a trouble to maintain in the app I worked on.
  I believe this should already work in master after #2376 (not in a release yet).
  Unconfirmed for nearly a year, closing this out.  Please open a new issue with a reproducible testcase if you believe this bug still exists.
  I agree, hiding exceptions is a bad thing, but are we really hiding exceptions there?  The code you linked appears to have a try-finally block, which (if I understand it correctly) has no affect on the flow of exceptions.

Example:
function foo() { throw new Error("MyError"); }
function bar() { try{foo()}finally{console.log('bar');} }

Calling bar will cause an exception in foo, which will not be caught.

Perhaps I'm miss-understanding the issue.  If so, I'd really like to see an example test case where an exception is being caught/swallowed in the react codebase, and/or a pull request with your suggested change so we can see what you think needs to be done here.

I'm going to close out this bug as invalid.  If you feel that this is still incorrect, please re-open and/or provide a test case and/or pull request.
 The intention here is to let all errors bubble up without explicitly rethrowing them, as that tends to cut off the stack trace and make it harder to find the original bug. As far as I know, the current code should work correctly in all browsers except old IE, which still throws the exception but doesn't provide a good stack trace .
  Closing because it sounds like @sebmarkbage said no (but I don't have that message - something got weird with GitHub)
 Actually I'm not sure about this. I think returnValue isn't a spec:ed standard so I guess these jQuery-inspired methods are about as standard as it gets...
 It's been a few months but let's do it. They exist. We should document them.
  I appreciate the effort but I don't think we're ready to make this sort of commitment to our API. I'm inclined to say we close this for the time being until we figure out a consistent async story here.
  If you believe this error is due to a bug in react, please post a simple example (fragment of code) that demonstrates the issue so we can reproduce/verify.
 That still shouldn't happen. @jsfb Do you have a repro case now? It might be worth fixing and doing a point release sometime.
 This was apparently with edge (presumably not 0.12). I also can't reproduce so I don't think there's anything to do here. Let us know if you see it again @dotfelixb!
  cc: @sebmarkbage 
 This is indeed intentional. React reconciliation life-cycle occurs within a single event loop. Because there's no clear scheduling API within an event loop, we rely on explicit batching which ensures that only one reconciliation happens within a batch. In those cases, React.render is not synchronous. Ideally it would always be asynchronous.

The use case for `componentDidUpdate` is to do work after React has reconciled all it's properties but you may want to do some extra work before the next frame is painted. Otherwise you would always see a flash.

Normally, all the writes you do on a DOM component has no effect until then next event loop anyway. Unless you read in between, but you have no reads in your example.

You can explicitly schedule some work to happen after the next frame is painted, using `requestAnimationFrame`.

Can you elaborate more on your particular use case?
  I wonder if these haven't been superseded by any other property/style? They seem quite exotic (and not present in HTML5) so I can't really find any good informaton. Anyway... it seems they're available as properties even in IE8 and probably shouldn't have `MUST_USE_ATTRIBUTE`.
 I was trying to find some styles that would supercede them but couldn't. We also already have `frameBorder` so meh. I'm losing my will to say no to things that aren't (supposedly) supported in HTML5 and we'll support arbitrary properties at some point anyway.
 :thumbsup:
  Currently, unknown attributes don't get passed down to DOM nodes.  This is because things like transferring props (https://gist.github.com/sebmarkbage/a6e220b7097eb3c79ab7) would result in too many unknown/noisy properties being passed to the DOM elements.

We're aware of the issue, and a solution to the unknown-attribute issue is on the todo list.

Duplicate of: https://github.com/facebook/react/issues/140
  I agree with @chrislaughlin, supporting the use of those two props as valid user-defined props would be detrimental to anyone using JSX (since there is currently no way of specifying them).  For this reason, we probably aren't going to support it in the near future.  Feel free to continue the discussion on this thread, and we can re-open if our thinking on this matter changes substantially.
  Yea, it seems we do prefer to use `charAt`, though apparently we could get away with just using property access since IE8 supports it.
  `removeState` seems rather superflous, `replaceState(null)` should be enough no?
 I think we're leaning towards dropping support for replaceState.  https://github.com/facebook/react/issues/3236

Dropping replacestate has been an ongoing discussion since January (https://github.com/facebook/react/issues/2843)

Thanks for the PR though!  If we were going to keep replaceState, I would say we should fix this behavior, because I agree with you, it's current implementation is inconsistent/wrong.  That said, I'm going to close this PR, since I think it's likely we'll be removing replacestate, and it's better to do that in one hop, rather than changing behavior and then removing it anyway.
  :+1: thanks!
  Closed by #2649 
  ES7 was actually not a typo here ‚Äì but we removed other references to this syntax in #2636 so maybe we want to change how this page is written.
 As written this is correct so I'm going to close out. If we want to revisit the text of the page as a whole we can but in a separate diff.
  To the extent possible, we want to be framework agnostic, and let developers use React as they see fit.  Some components should clearly provide their own styles (generally the more complex components need some sort of styling) while others should probably inherit styles from the page - and without knowing the details of the component, it's hard to make a recommendation one way or the other.

Some design principals should be self-evident (like building components that can be re-used in as many different contexts/environments as possible).  Others are less obvious, and the existing docs do talk about the patterns and anti-patterns that we've discovered at Facebook while using React internally, and try to provide some guidance on how to build components.  Is there a particular best-practice that you feel we haven't sufficiently communicated?

Feel free to submit a pull request, and we'd be happy to take a look at whatever you come up with.
 It's a tricky problem and it's come up before. We've thought _a lot_ about it but there isn't really a solution yet. It's really a problem on the web as a whole and not specific to React. You've hit on a lot of the problems. There are questions about what package manager get used (npm? bower?), what to do about CSS (so many questions there... how do you prevent clashing class names? how do you package it?). Style is going to be intrinsic to the way you build a component. Take react-bootstrap for example - it would be pretty silly for it to exist without styles. And then there's dependency management which is a whole can of worms.

http://blog.npmjs.org/post/101775448305/npm-and-front-end-packaging has some good discussions on this and some hints at how we might be able to start solving it. But I think we're a long way from 1 final solution and the best we could do is start to write some minimal best practices (like "use `peerDependencies`"). If you're interested in doing that, I think a section on the site for this would be good. I'd be happy to do reviews and chat more about what might belong in this section.
 I agree, a core component library would be awesome, but it's a lot of work to maintain such a library, and our focus up to this point has been on making the react core be the best it can be.  It's worth taking a look at react-bootstrap (http://react-bootstrap.github.io/components.html) if you haven't already - it's a pretty awesome set of components.  Since you mentioned Polymer's website, you might like http://material-ui.com/#/components/buttons  There are also a few other react component libraries out there.
  http://jsfiddle.net/kb3gN/8339/

In this case, I cannot input dot.

http://jsfiddle.net/e2nc8z4n/2/
In this case, it is also strange.

At last, I use string type for var price to solve problem.
 As mentioned, this handling floats is not quite as simple as you have here. You'll need to do more specialized handling. There's nothing wrong with React here, it's doing exactly what its told. So I'm going to close this out.
  Do you have any ideas about what to do with `React.render` which also accepts a callback but also returns a value?

There are a few other techniques that can be used. You can have the row's `componentDidMount` call focus so that it's auto-focused when it is created.

The new style refs are callbacks that get fired when the child is mounted. That can be used to trigger a focus without the need of wrapping it.

You can also use the `componentDidUpdate` life-cycle hook as a component gets updated to ensure that the focused thing (according to your business logic) always retains focus (e.g. the newest one).

I think that these are probably better alternatives that don't rely on the imperative nature of the source of your state change. E.g. you're tying it to the action that triggered the event. What if you add another state transition to the same state? Isn't it confusing that you can end up in the same state with different side-effects? That's part of the beauty of React, that you can avoid that.

Do you think that one of those patterns could replace your callback?

Even if it isn't... Honestly, the current batching strategy comes with a set of problems right now. I'm hesitant to expand on it's API before we're sure that we're going to keep the current model. I think of it as a temporary escape until we figure out something better.

Does that seem fair?
 Why would you use that pattern over this?

``` js
this.setState({
  selected: input
});
this.props.didSelect(input);
```

It is in fact probably an anti-pattern to fire an event after updates in that case because it may triggers multiple rendering passes and multiple layout passes which has significantly worse performance implications.
  Thanks! I'll take a look at what you changed but I'm actually not going to take this. I want us to own our fiddles (easier to update, much less chance of foul play). So I'll incorporate the changes into the fiddles in #2639 (but I'll leave this open until I merge that so I don't forget).
 Change made in http://jsfiddle.net/reactjs/n47gckhr/. Thanks again!
  Please make sure you are in the right repo before filing issues. If you meant to file it here then I can only say "huh?"
  Hi, thanks for the PR! I‚Äôm sorry it didn‚Äôt get a proper review. React team is small and some changes get under the radar due to the relevant React code being low priority, already complicated or buggy, or if the PR lacks the use case explained in a sufficient detail (i.e. why many apps need this feature).

It is not immediately obvious why this feature would be useful to most `TransitionGroup` consumers. Additionally, we try to avoid adding new features to `TransitionGroup` because it is already pretty complicated. It might be a good idea to fork `TransitionGroup` as a separate project and add this feature. If enough people start using your fork we‚Äôll consider adding this functionality into the official addon (this has happened before with https://github.com/Khan/react-components/blob/master/js/timeout-transition-group.jsx).

Personally I would advise you to look into https://github.com/chenglou/react-motion which has a more React-friendly API. We try to get away from APIs relying on calling instance methods, and eventually `TransitionGroup` is probably going to live as a separate package outside React.

Sorry again about no review, and we hope to see more of your contributions in the future. I suggest you to raise an issue first to get some feedback about the idea you‚Äôre proposing so everyone has better context on why a particular PR was submitted and what problem it solves.

Thanks for taking time to contribute!
  This works fine for me (using the full running example in https://github.com/reactjs/react-tutorial). `loadCommentsFromServer` is bound to the instance already thanks to our autobinding so there shouldn't be anything else needed (and indeed if we didn't autobind, we wouldn't have set up the bind warning you saw).

I'll close out and we can reopen if you can if you can repro with the code in that repro. If you can, we'll need more environment information (browser, os, etc)
  There is no bug here, just a bit of misunderstanding of the component lifecycle (which can definitely be confusing).

You have 3 renders of PaginationDemo happening.
1. Initial render
2. Update from setState via componentDidMount (in PageinationDemo)
3. Update from App rerendering (with async promise)

And your data for each render:
1. `this.state.total === 0` (initial state)
   `this.props.dataset.last_page === undefined` (initial state of app)
2. `this.state.total === undefined` (you are reading from `this.props.dataset.last_page` which we just established is `undefined`)
   `this.props.dataset.last_page === undefined` (initial state of app)
3. `this.state.total === undefined` (the last update to this was in `componentDidMount`, which is only called once)
   `this.props.dataset.last_page === 3` (what was in your async request response)

Instead of using `componentDidMount` you probably want to use `componentWillReceiveProps` ([docs](http://facebook.github.io/react/docs/component-specs.html#updating-componentwillreceiveprops)). You may also want to reconsider using `state` for something that is only ever read from `prop`. It looks like you also had that idea based on your comment in render.
  Good catch. Thanks!
  Yes, this is a great idea. I have a branch that starts to add this, I'll try to finish it up this weekend.
 Replaced by https://babeljs.io/
  We're working towards making it possible to purely use object literals but there are currently still a couple things related to internals that prevent us from doing so entirely. Simple DOM component trees should be doable but many other things with composite components aren't quite. There isn't anything actionable here at the moment so closing this out.
  Thanks!
  Spread implies copying I'm pretty sure, so it's still needed, but supporting `<Comp {obj} />` could make sense.
 It's not necessary in your specific case, but it is necessary in the general case. I personally think there's still room for supporting `<Comp {obj} />` but that's tangential to the spread case and something that we've talked about before.
 FWIW, the discussion of extending JSX with the bare object should happen in https://github.com/facebook/jsx/
  What @cody said. You should use a `<span>` instead. We'll probably drop the whitelist in the future but not yet.
  I don't think that ReactMultiChild.updateChildren() is catching any exceptions.  In fact, I think it's specifically jumping through hoops to ensure exceptions are not caught there.

Note that try-finally blocks do not result in exceptions being caught, as demonstrated below:
function foo() { null.doSomething(); }
function bar() { try{foo();}finally{console.log('bar');} }

invoking bar() will not catch the null pointer exception thrown by foo.

Having a simple example/fiddle that demonstrates your issue would allow us to investigate further.
 Closing, but if you have a repro case please post it.
  Dupe of #1855 =)

> It's not supposed to be used in production. You should precompile your jsx for that purpose.
 The only reason is because it's fast to get started this way. Just like how you can use the inline coffeescript compiler but don't do that in production.

From what I'm seeing, that library isn't generating dynamic (in your sense of the word) .jsx at all? This is how they create forms: https://github.com/gcanti/tcomb-form/blob/master/src/index.jsx#L801

(Could it be that you misunderstood what it means to generate js from jsx?)
 The JSX is nothing but sugar for some function calls. In [this example](https://github.com/gcanti/tcomb-form#example), `t.form.create` returns "something" (a [factory](http://facebook.github.io/react/docs/glossary.html) really) that you store in `Form`. Things like `Form` are nothing but functions and plain js objects. They don't contain a special string markup of the format, say, "<bla>...</bla>" that needs additional compilation like perhaps you thought (`console.log` it).
  I reported this over in https://github.com/facebook/esprima/issues/75 since it sounds like a parsing issue, not a problem with the strip types transform. It may turn out we need to update the transform too though, we ca reopen this if that's the case.
  I haven't watched the video but it might be fine to add to the page. That said, it shouldn't be the first one on the page, please put it at the bottom.
 Thanks!
  Thanks!
  Yea, we should probably do some checks in our ReactDOMOption wrapper and not allow anything but text as children.
 This can be fixed by using ReactChildren.forEach in ReactDOMOption to flatten the children before passing it to the raw HTML component. Strings and numbers get concatted together; other elements should be skipped and log a warning for invalid children.
  This was probably fixed by #2503.
 Yes, the fix is in 0.14.
 Sorry ‚Äì not released yet, but hopefully in the next few weeks. 0.14-beta is on npm (see the React blog).
  The problem is that whitespace actually has meaning in HTML so while pretty printed JSON is identical, pretty printed HTML is not. Also, pretty printing is not a light task so we'll leave it to others. I've used js-beautify in the past and I've been happy with it.
  Hmm, this is going to mean we walk up the whole DOM for every event listener we add, which is suboptimal (especially since we add listeners progressively as they get used). A couple things‚Ä¶
1. At the very least we should keep the fast path fast. Was there a reason you stopped using `container.ownerDocument` when there is no shadow root?
2. We should probably just use a while loop instead of recursion.
3. I'm slightly concerned that this isn't going to play nicely when mixing a page with shadow roots and regular React usage (there may be some caching at play that will screw things up, not totally sure though)
4. cc @sebmarkbage 
 We probably won't hit the stack limit. My concern is that I'm not sure if engines would do tail call optimizations and eliminate the need for creating all the things functions need. There is definitely overhead in that unless engines are smart (I _think_ most are but I'm not certain).
 We want to do document wide delegation and use `event.path` to dispatch the correct handler. https://github.com/facebook/react/blob/a05691f0ad9d20fc9ffb1fc04d531e257e37d55b/src/renderers/dom/client/ReactEventListener.js#L65

However, this spec has been changing so we temporarily disabled it.
  Looks good. Thanks!
  Good catch. Thanks! We should probably also document `createFactory`‚Ä¶
  @sebmarkbage what do you want to do here?

https://github.com/facebook/react/blob/bb9748272966ca41d6e44c5d964eeb9c5f81fb96/src/utils/traverseAllChildren.js#L112
 Nice catch. I think that we might actually have more of these flaws. We should be more careful as this prevents browsers to add `.key` to the string prototype.

@spicyj that if branch can be separated and we just use the implicit key for string/number.
  Why?
 Not escaping the `a` tag leaves you vulnerable to someone creating a link of the form: `<a href="javascript:alert('I can execute arbitrary javascript');">Click me!</a>`.  The `img` tag is even more vulnerable.  Trying to create a blacklist sanitizer is inherently a flawed approach to security, and should be discouraged.

Also, you can have your custom escape function create the __html field, as shown here:

`function myEscapeFunc() { return {__html: customEscapeFunc()}; }`

Allowing you to do:
`<div dangerouslySetInnerHTML={myEscapeFunc(this.props.foo) } />`

Which mostly gets you what you want.

It doesn't make sense to add a feature in order to support a broken security policy.  I'm going to close out this bug, unless someone has a stronger motivating reason for such a feature.
  In general, reaching in and finding the DOM component and asserting on it will be fragile. We actually wrap some DOM components with regular React components so that we can add additional logic and event handling (that's how controlled inputs work for example). So when you go and do `input = TestUtils.findRenderedDOMComponentWithTag @comp, "input"` you actually find the thing our wrapped input renders. That won't have the onChange that you're expecting. Same goes for forms (we need to handle the submit event specially since it doesn't bubble but we do pass your handler on to the actual DOM component).

So my advice is to refocus your testing. Your making assertions on the way React is implemented, not about your application. Don't assert that assignment of handlers is correct. That's not actually a useful test. You have a way to assert that your form handler is called and that way is more correct than your fail case. You should do the same for your input.

I'm inclined to say this is as expected, though it is understandably annoying. We're working on better shallow testing tools.
  JSXTransformer (the script, used by JSFiddle) is only intended for basic development needs, it's slow (at startup) and generally a very bad idea. Pre-processed JSX has no run-time overhead.
 Also, you're using the development version, which offers good error messages and other checks while compromising on perf.
 @ricardosoeiro Frameworks always have overhead, you'll have to compare it non-naively to some other suitable framework for it to make any sense. My general guideline is that if you have so many DOM elements that first render is visibly slow, you're doing it wrong... faster performance is not the solution, it's a band-aid. Add content dynamically as it is scrolled into view, etc, that way it scales properly.

PS. Also React will become faster and faster over time.
 This is a good topic for a mailing list (sorry, I should have said that sooner). As mentioned, there appear to be some discrepencies on what is causing performance issues for you. React does more than simple string templating so yes, there will likely be additional overhead as React sets up and maintains references and other stores and caches so that updates can be fast.
 > I confirm that react is VERY slow when there are many elements. It is drastically slow. It has nothing to do between its name and real-life usage.

Hi, we‚Äôd love to help you but this is very vague. How many elements? If you render more than a thousand elements in a page, you probably can‚Äôt show them all at once anyway. In this case it is better to used [virtualized lists](https://bvaughn.github.io/react-virtualized/) so that you can render as many items as you need and stay performant. You can also use something like [MobX](https://github.com/mobxjs/mobx) for automatic granular subscriptions if you‚Äôre hitting performance limits with thousands of items with traditional React data flow.

That said, it is equally likely that React can be fast in your case if you:
- use production build instead of development build (they can have 3x-5x difference in perf);
- provide React with some [performance optimization hints](https://facebook.github.io/react/docs/advanced-performance.html).

This is a [good guide](http://benchling.engineering/performance-engineering-with-react/) to optimizing performance of React apps. Please check it out if you‚Äôre interested!

> It is definitely not reactive.

‚ÄúReactive‚Äù refers to the fact that when you update the state, the DOM is updated automatically, ‚Äúreacting‚Äù to the state change. It doesn‚Äôt mean React claims to be the fastest library possible. However it is definitely used very widely at Facebook, including React Native where performance is very important, so it enjoys a ton of real-world usage.
  @gabrielecirulli Yea, seems like it wouldn't be a bad idea to have a check in createElement.

@johanneslumpe What was working fine before? createElement didn't really exist (it was added in 0.11.x but would likely not have been used). And react/addons has always been the full React object with addons inserted.
 Talked it through with @johanneslumpe on IRC, same cause just not via addons. An undefined component was being used.
  The goal of the `keyMirror` function is to be compatible with the advanced mode of Google's Closure Compiler, which means that the keys have to appear as unquoted property keys in the JS source, so we can't use arrays and strings as you're suggesting. Since this is only an internal API anyway, I think we're going to leave it as is ‚Äì but thank you for sending in the idea!
 What @spicyj said. When I first saw keyMirror I actually wrote something very similar before being told the same thing. It's weird but it has a purpose. I encourage you to release any tools you find useful for yourself on npm / wherever. I'm sure others might find this useful.
  Can you provide a simplified test case demonstrating the issue? Thanks.
  @jiyinyiyong What @browniefed meant is two copies of React, as discussed/described in: https://gist.github.com/jimfb/4faa6cbfb1ef476bd105

I'm not sure if that's actually the problem, but it's worth checking.
 @lencioni Since you're just jumping in on this thread now (months later) with a stack trace, I'm assuming your stack trace does not correspond to the code above, right?

It looks to me like this bug does not have a clear repro.

Based on @gsantome's response, it looks like he was running into https://github.com/facebook/react/issues/3298

I'm going to close this issue.  We can reopen if this is incorrect.  Or open a new issue if we can get a consistent repro that indicates a bug in React.
  ![24](https://cloud.githubusercontent.com/assets/13243/5176939/bb971f60-7405-11e4-81f0-ca83ee39ddab.png)
  What environment/browser are you in?
  See #2429
  lol @petehunt changed that to html after people complained about the mention of xhtml. Guess you really can't satisfy everyone
 I'm not sure where specifically in the docs you're talking about. Additionally I don't think this should make all the difference in picking React and it only adds noise to the docs, so I'm going to close this. Feel free to reopen if there's disagreement. Thanks!
  I just deleted the syntax.js file in #2601 because we didn't actually use it (and updating the optimist dependency there is messy because it's synced with an internal file). Can you rebase and then we can merge this.
 Yea, I think I'll just close it. Thanks for the initiative though. It's only used for building docs. If we revamp the `jsx` executable then I'll probably revisit this. Sorry this didn't work but don't be a stranger :)
  @RileyTomasek let me know if you want to followup here.
 I think this sounds good. Thanks :)
  This will probably sort it self out over time, but running multiple React instances is currently not supported. If you absolutely need to you can easily mod the React library to use a different attribute name for the different instances.
 @syranide i thought we randomized the root keys when server rendering?
 @zpao Oh right, yeah that does work for server-rendering actually (but not client-rendering...), but you have to be absolutely certain that there aren't race-conditions that could cause a checksum mismatch. Good call. Just remember that can't dynamically render any new roots client-side.

I can't remember, but I think there are some (perhaps non-fatal) issues with the node cache too... wouldn't it actually cache all foreign nodes indefinitely due to events priming the cache? I'm uncertain about this... but it sounds familiar to me.

I think the only really sane way of doing this is to have the different React instances use different attribute names for `data-reactid`.
 Right. Multiple Reacts on the client is going to be problematic but I didn't understand that to be the actual case here. We don't reassign keys on mounting existing markup, I thought we picked up the root key from the DOM (I think we have to for the checksums to match).

Unless the "server side" generation here is actually in something like Phantom and we're determining if we randomize the root id based on execution environment instead of the code path. Then we would start at 0 on the server too.
 @zpao Oh, it seems I conflated JaRails comment with the issue itself. Now it makes sense :)

Yeah, client-side reuse of server-rendered markup adopts the reactid in the DOM and should not increment "next index". The issue here is quite plainly that the server-rendered markup for some reason has non-randomized reactids... which is very weird because the checksum is there so it seems correctly done. Could Math.random() be monkey-patched/broken in the server environment? I'm not aware of any reason why React would not generate randomized reactids.
 @zpao It seems you're right, http://jsfiddle.net/ze6vc7L2/ I'm quite sure it wasn't broken like that before...
 @syranide No, it's unfortunately always been this way. On my infinite to-do list to fix.
 @JohnyDays It will simply discard already rendered markup, so the client will rerender it from scratch and also clear whatever was on the screen (say if the user had begun to type in an input).

**EDIT:** PS. You're not getting any warnings because React doesn't think it's rendered by React and silently discards it.
  Done, thanks.
  That's an interesting idea for the current React. PropTypes involves running a bunch of code but I think the end goal here is to make them static and use something like Flow to analyze these. We'd like to even move away from `getDefaultProps` and make that a static property. Take a look at https://github.com/reactjs/react-future/blob/master/01%20-%20Core/01%20-%20Classes.js#L11-L13 for some of the ideas we have and are working towards.

cc @sebmarkbage.
 Yeah, we're moving to static properties for these so I'm going to close this out.
  cc @sebmarkbage 
 First of all, thank you for an excellent bug report. Very well structured and easy to test.

The bad news is that the various wrappers and undoing of wrappers is very complex. It was difficult to get 0.12 into a form where it was a perfect upgrade path. I guess this is a special case where something broke down. I ended up spending a lot of time on this so I'm inclined to just leave 0.12 as broken. :/

The good news is that this works in the master branch so this will be fixed in 0.13.

Would you mind submitting a formal pull request with these unit tests added to our tests to ensure that it doesn't break again?

The exception is asserting on props on mockComponent. We probably won't support that. `mockComponent` is considered legacy at this point. It shouldn't be as important in 0.13, since auto-mocked components works better out-of-the-box. We'll probably encourage shallow testing for this use case.
  This seems to be a bug in **6to5**. Methods in ES6 classes should be enumerable. Please report it to the **6to5** project.
 That document is outdated. AFAIK, the spec draft has changed since then.

> On Nov 25, 2014, at 8:28 AM, Ceane Lamerez notifications@github.com wrote:
> 
> It seems that methods are not enumerable on ES6 classes.
> 
> In a class body, a prototype method declaration:
> 
> m(args) { body }
> is equivalent to:
> 
> m: {
>    value: function m(args) { body },
>    enumerable: false,
>    writable: true,
>    configurable: true
> }
> Prototype getters and setters are similar.
> 
> ‚Äî
> Reply to this email directly or view it on GitHub.
 The first one is just the constructor which is not enumerable.

The rest of the elements uses PropertyDefinitionEvaluation which SHOULD make them enumerable.

> On Dec 4, 2014, at 2:15 PM, Ceane Lamerez notifications@github.com wrote:
> 
> ES6 draft class definition
> 
> Also in the latest upcoming ES6 draft (October 2014), it seems that the PropertyDescriptor of methods on a class are as
> 
> Let desc be the PropertyDescriptor{[[Value]]: F, [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: true}.
> ...
> For each ClassElement m in order from methods
> a. If IsStatic of m is false, then
> i. Let status be the result of performing PropertyDefinitionEvaluation for m with argument proto.
> b. Else,
> i. Let status be the result of performing PropertyDefinitionEvaluation for m with argument F.
> So it seems that class methods are not enumerable with the current ES6 spec.
> 
> ‚Äî
> Reply to this email directly or view it on GitHub.
 The problem with enumerability is that it can't be polyfilled in old IE (we still support IE8). Both the detection and definition. If we want to support IE8 we don't want there to be different React behaviors depending on which browser you use, so we can't depend on detecting enumerability. Otherwise someone may accidentally rely on it working, yet in IE8 it will break (and nobody properly tests IE8 these days).

Luckily, we have first class support for ES6 classes in 0.13.

http://facebook.github.io/react/blog/2015/01/27/react-v0.13.0-beta-1.html
 There is a flag to turn it back to the old behavior as a workaround until we can get it fixed in jest.
 In your preprocessor `ReactTools.transform(code, {harmony: true, target: 'es3'})`
  At this point, I don't think we're going to take this.  No updates for nearly a year, merge conflicts, etc.  Also, `replaceState()` is mostly frowned upon anyway (possibly going to be removed in the future), doesn't exist on ES6 classes, etc.  So... I'm going to close this out.
  1. You should perhaps reconsider use of replaceState (but that's not the issue here)
2. The real issue is that you're passing `undefined` to value.

I think I remember seeing something else about this recently but can't find it at the moment. Thanks for the report!
 I just meant that I don't like the replaceState API and I wish we only had setState.
 > I just meant that I don't like the replaceState API and I wish we only had setState.

Why?
 Because I'm a jerk. I understand replaceState is useful, it just gets abused (it makes sense for forms as long as that's the _only_ thing in state).
 This sounds like a dupe of #2533.
  Yeah, we're not planning to change this now.
  Thanks for tracking this down ‚Äì going to close this as a dupe of #1302.
  Your proposed alternative with the CustomButton as a wrapper is good. In general we don't want to do deep merges because your props could look like anything ‚Äì they're not necessarily plain JS objects that can be automatically merged. As such, I'm closing this out.
  Followup work for recent PRs
  See #1657 
  It's by design #2429, continue the discussion there if you feel it's necessary.
  Going to mark this a duplicate of #984 ‚Äì please comment if you disagree with the reasoning there.
  I don't buy the arguments listed in "Why not mock at the module level?"

1) Sure it's slower, I'm skeptical it's too slow. jest is pretty fast and we're using it for many thousands and thousands of test. Do you have a test suite that significantly hinders you workflow because it uses module mocking?
2) We often use clearCache to reset the cache. This is a limitation in jest. It's not inherent to the model. It could be done automatically for you. Let's fix it. It's not too slow.
3) Arguably the distinction is arbitrary and it's an academic terminology argument. Not a practical argument.
4) This is a confusing part of jest because you can require outside of `it`s and inside. We can forbid requires or automatically ensure that each `it` runs in an isolated scope. It's not a limitation of the model, just the implementation. I'd love to see a pull request to fix this. :)
5) Arguably over-reliance on statics is a problem but I have yet to see dependency injection automatically solve it. It still requires restructuring. I think that the point you're making is orthogonal to testing because I assume that you want the dependency injection for production runtime to solve those issues.

That said I would like to be accommodating. So I'll try to address your concerns.

First, we're moving toward encouraging shallow testing rather than deep testing. You should be asserting about renders one level deep rather than implementation details of lower level components. See:  https://github.com/facebook/react/issues/2393

That avoids the need to mock nested components. You assert on the ReactElements rather than asserting that the classes get instantiated.

Second, we're moving towards using stand-alone plain classes instead of React.createClass. So you can use any DI system that you would use on top of ES6 classes. I.e. you will be able to just wrap your classes in a DI provider.

Third, your concern about `getDefaultProps` being memoized is solvable by just wrapping it in a function.

``` javascript
  getDefaultProps() {
    return {
      model: () => new MyComponentViewModel(new HTTP())
    };
  },
```

Then you invoke the function in getInitialState time. That makes it effectively lazy. The function can capture any additional dependencies in it's closure.
  It's just courtesy addon, feel free to fork and improve. I believe the _intent_ of `classSet` is to be compatible with CSS selector minification, that is not compatible with dynamic class names.
 This has come up before. Right now we're just exposing a stub implementation of `cx`, which internally gets statically transformed to string concatenation. So far I've wanted to keep these things in sync so that we don't have diverging patterns. So because of that, I'll close this out.

A more generic `classSet` is totally writable and I would support people publishing their own / better impl on npm and then perhaps deprecating the one we expose.
  Since we still use jstransform we'll get this when it does. For now I'm going to close this since there's nothing actionable to do here but wait. Thanks for filing and for filing in jstransform :)
  I don't think we're going to change this but I'll let @sebmarkbage make that final decision.
 I can understand how this might be confusing at first. I guess it's just one of those terms that you have to learn. I'm not sure that this clarification is worth churning people that are already using it and accustomed to these terms. Generally I'd be open to improving terminology because most people that will use React haven't started yet. But I predict that a lot of them will use Flow, TypeScript or another dynamic type syntax (guards).

Out of curiosity, what do you guys think about Flow and TypeScript's syntax for object shapes? http://flowtype.org/docs/objects.html

`{ [key:string]:number }` to ensure that all properties are numbers. It's kind of weird too but once you learn it, maybe it makes sense?
  Thanks!
  Yea, this reads better. Thanks for clearing it up :)
  :+1: Can you remove the commit with the documentation update? We'll take care of that when we do the release (this makes it easier to cherry pick into stable branches)
 Oh also, did you test that `node.headers = value` works and we don't need to use `node.setAttribute`?
 @zpao I confirm that `.headers` exist on IE8.
 @mhuggins yea, we just manual test it for now because behavior hasn't been consistent. We may make this better in the future.

Thanks btw!
  Thanks guys for the confirmation. I'll try to take a closer look at this patch soon and get it (or something similar) in for 0.14.
 Thank you! Sorry it took me so long to get to this. Just merged with a couple small fixes in 08e4420019f74b7c93e64f59c443970359102530.
  FWIW, I don't think we'll end up doing this. React just wasn't designed to work like that and I don't think we would want to support it long term.
  Interesting pattern. I think it might be a mistake to add `unmount()` to the component API since it would only be usable by top-level components (though we do have a similar restriction for `setProps`, though I think we still want to remove that API). But some way to do this seems like it wouldn't be a bad idea..

When we did something like this in the past we cached a reference to the node so we didn't have to go through the component itself. I see you're doing that and stashing it on the component reference which I think is an ok way of working around this.
 I'm pretty sure our recommendation at this point is: `ReactComponentRenderer` from https://facebook.github.io/react/blog/2015/10/01/react-render-and-top-level-api.html
  lgtm, thanks!
  We might make warnings louder in general, but we're moving more towards warnings so that the prod build can skip unnecessary checks, so I'm closing this.
 Sorry, I actually misunderstood this and thought from the description that there already was a warning. I actually just checked and there was an error added at about the same time this issue was filed, so this is actually fixed:

https://github.com/facebook/react/commit/aef7c4d1a16133f2f6d3ae3bfd18f01f8fc1403b
  I'm inclined to say no. We've talked a lot about making use of different syntaxes and we're trying to keep it as minimal as possible. Adding the `{...spread}` was already a pretty big deal.

cc @sebmarkbage 
 We try to keep syntax discussions over in: https://github.com/facebook/jsx That way we can have a wider group contributing to this syntax to make it worth it's extra weight to the language.

I think that the difference between `<Foo {item} />`, `<Foo {...item} />` and `<Foo item />` might be too confusing. The last two are already supported.

I like the way you think though. If you feel strongly about this you should open up an issue at https://github.com/facebook/jsx
  Closing in favor of #1657.
  Can't test right now... but if I'm understanding it correctly it shouldn't even work correctly (can you actually edit an uncontrolled textarea now?). The logic can be simplified and `this.props.children` isn't actually supported by textarea AFAIK?
 Superseded by https://github.com/facebook/react/issues/5013
  I believe it's `input` that is misbehaving here, not `textarea`. Setting `value` to `null` makes it uncontrolled and it should make no attempt to change the value.
 @syranide does setting to null make it uncontrolled? That doesn't sound right to me, but I haven't looked at the linkedstatemixin in a long time. I also would expect the behavior of the input here, not the textarea.
 @zpao http://jsfiddle.net/91khmysc/ `null` is treated as (mostly) identical to `undefined` (or not set) through-out React I think?

Also yeah I agree, the more I think about it more it makes sense to "reset" it when becoming uncontrolled, it's the "most deterministic" one and also the one easiest to reason about.
 @rymohr While it makes sense in a way, it breaks with how all other props work and I feel like there's something inherently wrong about `<textarea value={undefined} />` being a controlled component as well. While I don't have this on authority, I'm pretty sure that JS defines `undefined` as meaning to be literally undefined, treating it as anything else breaks expectations.
 cc @yungsters (for here and #3041) - I know it's been a while but you may remember some of your early thoughts around controlled components.

I'm not sold that returning to `defaultValue` is the right call. But in general this whole thing is a bit of a grey area. We should be consistent, regardless of which route we take.
 @zpao Returning to `defaultValue` is the only that makes sense to me, it would be the equivalent of treating them as separate modes/components, i.e. it resets when you switch between them. It was you who convinced me first :P

To me it becomes quite obvious when you think of React as being inherently kind of stateless, for a certain set of props you should always get the same output. So rendering `<input defaultValue="test" />` sometimes rendering to "test" or ""/last value (without user interaction) depending on whether the input was previously controlled makes no sense to me, there's no transition between controlled/uncontrolled that really makes practical sense. They're different.

```
1. <input defaultValue="foo" />
   => "foo"
2. <input value="bar" />
   => "bar"
3. <input defaultValue="foobar" />
   => "foobar"
4. <input defaultValue="barfoo" />
   => "foobar"
```

Nothing else really makes sense to me in the context of React.
 But if the user typed something, we leave that value in the DOM on subsequent renders. You could think of React as stateless but the DOM isn't and we respect that for uncontrolled components.

```
(same render fn I assume)
1. <input defaultValue="foo" />
   => "foo"
2. user types "bar"
   => "bar"
3. <input defaultValue="foobar" />
   => "bar"
```

If we treat changing the `value` prop like we treated a user manually changing the value, then we wouldn't return the `defaultValue`. I'm not saying that's the right thing, just that we have precedent.
 @zpao Yeah ofc. I improved my post a bit after I posted it. To me it comes down to the fact that transitioning from controlled to uncontrolled doesn't really make sense to me, you pick one and stick to it. You're not supposed to use controlled as a read-only state for your uncontrolled input. So if there's a controlled to uncontrolled transition, it's really a transition from `<ControlledInput>` to `<UncontrolledInput>` so it should reset... i.e. you forgot to give it a proper key.

**EDIT:** Or is there a use-case for transitioning from controlled to uncontrolled? Then it could make sense to keep the value, but I can't think of any...
 Also; it's easy to reproduce the behavior of the value sticking by simply updating `defaultValue` appropriately. But if it always keeps the last value then the only way to get it back is to manually detect the transition and update the value of the DOM node.
 @zpao Hmm, actually, let's rephrase it like this:

```
1. setState({value: 'foo'});
2. <input value={this.state.value} />
   => "foo"
3. (something happens)
4. setState({value: 'bar'});
5. <input value={this.state.value} />
6. <input defaultValue={this.state.value} />
   => "bar"
```

That was easy, now let's consider this instead:

```
1. setState({value: 'foo'});
2. <input value={this.state.value} />
   => "foo"
3. (something happens)
4. setState({value: 'bar'});
5. (noop or batched updates)
6. <input defaultValue={this.state.value} />
   => ???
```

I'm quite convinced now that the correct answer at step 6 is "bar" (i.e. it should reset to `defaultValue`). If it was "foo" you would be looking at an old irrelevant value, whether React re-rendered in-between (consider rAF-batching or whatever) should be irrelevant to the visual state shown to the user.
 @martinstein You still have transitions between controlled and uncontrolled inputs regardless of whether `value={null}` is considered controlled or not.

**EDIT:** I think turning `value={null}` into a controlled component is rather counter-intuitive, the solution should be to make uncontrolled and controlled inputs separate components, not using magic properties/values. Also, note that you can easily create your own wrapper to enable the behavior _you_ prefer.
 @martinstein It's not so much that I find `<input value={null} />` to be controlled counter-intuitive, but that it breaks basic expectations of what a `null` value means and that is counter-intuitive. `null` means default/no value if you ask me, you would expect `foo(null) === foo()` to hold, just like I would argue that `foo({enabled: null}) === foo({})` should hold and by extension `<input value={null} /> === <input />`. `null` is also commonly used to optimize hidden classes where it's generally expected to have the same behavior as if not having been specified unless for merging objects.
 I don't think that setting `value` to `null` or `undefined` should reset the DOM to `defaultValue`. If this behavior is desired, the composing component should continue setting `value`. Otherwise, setting `value` to an uncontrolled state should do just that ‚Äî leave the DOM as-is. Letting component authors rely on conditionally setting `value` in order to reset `defaultValue` is pretty confusing, and I would not want anyone relying on this behavior even if we were consistent about it.

As for whether or not `null` should control the DOM, if we allow `null` to mean that a component's value is controlled, what is that value? For `<input>` and `<textarea>`, you may argue it should be an empty string. But what about a `<select>` with `<option value="" />` and `<option value="null" />`? This ambiguity make me think that `null` should not control a prop value. Besides, it is very reasonable for component authors who want a controlled value of the empty string to set `value=""`.

We should fix `<input type="text" />`.
 @yungsters But if we take my example above (copied below), I think the only thing that make sense is to "get the latest value and set it before becoming uncontrolled" which is equivalent to a reset.

The example from above, consider this scenario:

```
1. setState({value: 'foo'});
2. <input value={this.state.value} />
   => "foo"
3. (something happens)
4. setState({value: 'bar'});
5. <input value={this.state.value} />
6. <input defaultValue={this.state.value} />
   => "bar"
```

That's obvious, now let's consider this instead where the new state is not rendered due to batching (or w/e):

```
1. setState({value: 'foo'});
2. <input value={this.state.value} />
   => "foo"
3. (something happens)
4. setState({value: 'bar'});
5. (noop or batched updates)
6. <input defaultValue={this.state.value} />
   => ???
```

I would argue quite strongly that the value should still be "bar", whether or not the component actually performed intermediate re-renders should be irrelevant, especially as it's affected by the batching strategy. If we _reset_ when becoming uncontrolled then it's always consistent.

That said however, I don't think going from controlled to uncontrolled is something you should do (the best solution would be if it wasn't at all possible if you ask me), we should simply make the best of it. But _if_ you do, this is the only one that makes sense to me in the context of how React is meant to work, this is deterministic in a way that "keeping the last value" simply isn't.
 @rymohr

> The form has a "controlled"  <textarea>  bound to  this.state.slide.text . If you move from a slide 1 to slide 2, you'll still see the old text.

Huh? If it's controlled then it by definition always shows the correct value.
 @rymohr It is the consumer of `slides` that is responsible for translating a configuration of `undefined` text to an empty string when rendering a React component.
 @syranide But what about when no `defaultValue` is supplied?

```
1. setState({value: 'foo'});
2. <input value={this.state.value} />
   => "foo"
3. (something happens)
4. setState({value: 'bar'});
5. (noop or batched updates)
6. <input /> // No defaultValue
   => ???
```

In this case, I would argue that the input should have a value of `bar` and not be empty.
 @yungsters I don't think there's anything ultimately right or wrong here and there's no use-case that _really_ makes sense.

I see two options to this ambiguity:

---

**Keep the last value**

```
1. setState({value: 'foo'});
2. <input value={this.state.value} />
   => "foo"
3. setState({value: 'bar'});
4. <input value={this.state.value} />
   => "bar"
5. setState({value: 'foobar'});
6. <input defaultValue={this.state.value} />
   => "bar"
```

```
1. setState({value: 'foo'});
2. <input value={this.state.value} />
   => "foo"
3. setState({value: 'bar'});
4. (batched update)
5. setState({value: 'foobar'});
6. <input defaultValue={this.state.value} />
   => "foo"
```

Even though it may make intuitive sense I don't see when you would ever want that behavior. The final value depends on the batching strategy and whether or not the operations were batched. Regardless, if the controlled to uncontrolled transition should make _any_ sense there has to be a relation between the two (otherwise you should key it properly) and I would argue that in this case you are **always seeing an old value**. Consider:

```
render: function() {
  return (
    this.state.value !== 'magic' ?
      <input value={this.state.value} onChange={...} /> :
      <input />
}
```

If you type `magic` then it will be uncontrolled and if we weren't relying on the stateful DOM ideosyncrasies the value of the input would actually be `magi`, not `magic` (can be reproduced other ways as well, feel free to replace `magic` with `wizard` in the change handler to the highlight the issue).

I fail to see when this ever makes practical sense, not saying a use-case doesn't exist, but I don't see it. It just seems arbitrary and in some sense condones controlled to uncontrolled transitions as being legitimate, which I'm not sure if I agree with in the context of React and batching strategies, etc, etc.

---

**Reset to default value**

```
1. setState({value: 'foo'});
2. <input value={this.state.value} />
   => "foo"
3. setState({value: 'bar'});
4. <input defaultValue={this.state.value} />
   => "bar"
5. setState({value: 'foobar'});
6. <input defaultValue={this.state.value} />
   => "bar"
```

```
1. setState({value: 'foo'});
2. <input value={this.state.value} />
   => "foo"
3. setState({value: 'bar'});
4. (batched update)
5. setState({value: 'foobar'});
6. <input defaultValue={this.state.value} />
   => "foobar"
```

Again we're seeing two different values, but the reason for this is simply the nature of uncontrolled components. But more importantly **neither is inherently wrong** in my opinion, the value shown is simply subject to the inherent shortcomings of uncontrolled components. Consider this example again:

```
render: function() {
  return (
    this.state.value !== 'magic' ?
      <input value={this.state.value} onChange={...} /> :
      <input />
}
```

When you type `magic` it resets and becomes empty, don't ask me why you would want this. But we're showing a deterministic state, not `magi`. If we also take the alternative example you have:

```
render: function() {
  return (
    this.state.value !== 'magic' ?
      <input value={this.state.value} onChange={...} /> :
      <input defaultValue={this.state.value} />
}
```

When you type `magic` it resets and becomes `magic` as you would expect. Again, don't ask me why you would want to do this, but we're again showing a deterministic state.

Now include the fact that resetting like this is also near identical to proper keying (except for maintaining focus), that seems like another benefical side-effect. We're treating controlled as separate and incompatible with uncontrolled just as they should be (but still maintains a practically reliable behavior).

To me this is the obvious choice all things considered...

---

Ultimately (from an academic perspective), I wouldn't mind `<input />` being controlled **only**, if you want the uncontrolled behavior you'll have to use a wrapper or a generic `makeUncontrolled(React.DOM.input)` if it's reasonable to agree that `value` and `onChange` is the de-facto interface for all controlled components.
 @rymohr What you're describing is how `getDefaultProps` used to work. If any value was provided (including `null` or `undefined`), we would use it over the default value.

However, this was a pain for building components that sometimes wanted the default value and other times wanted a specific value. For example:

```
var Button = React.createClass({
  getDefaultProps: function() {
    return {type: 'submit'};
  },
  // ...
});
var FancyButton = React.createClass({
  render: function() {
    // This sucks.
    if (this.props.hasOwnProperty('type')) {
      return <Button type={this.props.type} />;
    } else {
      return <Button />;
    }
  }
});
```
 > We're treating controlled as separate and incompatible with uncontrolled just as they should be.

Hmm... actually, I like this a lot. @zpao, what do you think? I'm willing to go with this as a reason for "resetting values" when changing between controlled and uncontrolled.
 > Reset yes, but while you're at it why not simplify the entire controlled vs uncontrolled thing as well?

What kind of simplification are you looking for besides resetting the mounted value when switching in/out of being controlled?
 @uptownhr As far as I know the behavior is the same across input/textarea. Am I misunderstanding?
 First thing we need to decide is what the ideal/correct behavior is, since no matter what we do here it is a behavioral change.

One option is that null clears the input element and makes it uncontrolled.  Another is that it makes the input element uncontrolled without resetting the value.  Another is to return it to the defaultValue.  Another is that we keep the current semantics (or forestall the change in semantics - for now, text areas and input fields behave differently) which avoids introducing subtle changes in behavior that will break people's apps.

Once we decide the desired behavior, we can move forward with a fix.  cc @spicyj @sebmarkbage Thoughts?
 @davidreher IMHO that's a bug in your code, you should not be relying on this behavior. Even though inputs behave as you expect, you're not using them as intended and I'm sure there are some unintended side-effects as a result for certain edge-cases. **EDIT** I should add; that is if you're using nulls instead of empty strings, intentionally switching between controlled and uncontrolled behavior is fine and that's what should be fixed.
 @rymohr Our intention was that a prop value of `undefined` is always equivalent to not providing it. This is how defaultProps, etc. works. In most cases, `null` is what people end up passing and so we could make that mean the empty string, as discussed above.
 @spicyj What we're really concerned about in the end is unintentionally switching controlled/uncontrolled right? Perhaps something we should warn for (once) too?
 I'm tempted to agree with @syranide and say we should warn (once) when a component switches from controlled to uncontrolled.  Valid use cases are exceedingly rare, and I'm thinking it's almost always a mistake.

Warning in such cases also gives us an upgrade path to change the behavior of passing `undefined` to a controlled textarea, since it is sounding like the best behavior is to reset to the empty string.
 > Valid use cases are exceedingly rare, and I'm thinking it's almost always a mistake.

@jimfb Expanding on that, I would go as far as saying it's either a mistake or bad practice. First; if controlled/uncontrolled where separate components (as they really should be IMHO), it would be impossible to switch like this. Second; it's trivial to implement uncontrolled behavior using a controlled input, so if what you really want is some non-standard behavior you're best off implementing your own component on-top of controlled inputs that implements whatever behavior you want, not switching between uncontrolled/controlled.

My point being; yes, there may be _valid_ use-cases, but anyone being serious about their code can and should always avoid the warning as above. So I personally don't see any negative sides to having this warning.
 You mean 15.0

> On Feb 23, 2016, at 2:24 PM, Andreas Svensson notifications@github.com wrote:
> 
> @iboxgithub You should not rely on this behavior and I believe 0.15 will issue a warning if you do.
> 
> ‚Äî
> Reply to this email directly or view it on GitHub.
  This is intentional. The spans are there as a React implementation detail so that the diffing can be done more easily. Since `renderToStaticMarkup` means you don't use React on the client side, there's no point in wrapping them.
  Just to clarify‚Ä¶ you're explicitly setting it to 0 but React ends up setting it to -1 instead?

cc @syranide
 #1510 is the fix (default value is not identical to no attribute). I'll try to review and re-test it wednesday, it fixes quite a lot of edge-cases so it would be good to have it merged...
 @mczepiel I believe you mixed up the order, anyway... there are a handful of DOM attributes which do not exhibit default behavior when set to the default value, the attribute has to be removed to restore default behavior.
 Oh wait, my bad @mczepiel ... yeah there's a second bug here, that you were referring to.
  @zpao Sanity check?
 We're reusing the JSX transpiler code directly from the react website in order to show how types are being stripped in the Flow website. I'm going to pull this in and update the React website. See this for an early demo: http://172.24.226.36:4000/flow/docs/transpiler.html
  IE8 says:

```
> document.createElement('th').headers
  ""
```

So all good it seems :+1:
 Sorry I missed that this came in before #2553 and just merged that instead. Thanks for the PR though and hopefully we'll see some more :)
  This is a build bug in the release build.

Closing as duplicate of #2247.
  I missed that this came in before #2544, but it looks like somebody else had the same idea. Definitely let me know if there are any other things we can do to improve the docs Jared :)
  This isn't actionable as-is; if you're still having trouble please post a minimal repro.
  We're in the midst of revamping context so now is a good time to bring this up.

I think it's important to have access to the things inside both context and props and not be prevented from using some key for prop/context just because it's used elsewhere. Context is a distinct thing from state and props, so I think it's important to make sure that distinction isn't lost and uses are intentional. We actually had very similar discussions a long while ago about merging props and state into a single data blob but the same arguments about ownership and intention came up them

So I'm going to say "no _but_ I like that you're thinking about this (seriously, it's awesome)". I'm pretty sure @sebmarkbage will agree with me here but I'll let him comment just in case.
 Closing out, I really don't think we're going to do this.
  `source == null` is often intentional and a poor lint warning.
`source === null` does not test true for `undefined`, unlike `source == null`.
 We use `== null` in a few places to check for `null` or `undefined` and I think we'll continue to do so. I appreciate the recommendation though and who knows, maybe we'll change in the future.
  I put this into the "tips" section. Perhaps this should be in the "reference" section - let me know if you have a preference.
 Cool, I added a sentence saying the HTML passed in should be well formed / pass validation (which implicitly requires tags be closed, since that's required for validation).
 Modified to better explain the reasoning behind {__html}
 @zpao Ping.  Ready to merge?
 @zpao Ping.  Since we've been waiting on this one for months, merge conflicts have appeared, which have been resolved.  Can we get this one merged?
 lgtm otherwise
  This is an extremely good question.  Thanks for raising it!

This is a case where you're manually pruning/optimizing the tree recalculation.  It seems to me that you'd need to request access to any context variables that are of relevance to your calculation.  We could also consider doing other fancy things like pass in a hash of the full context (or even the full context) if necessary.

@sebmarkbage - thoughts?
 The use case for context has been for parameters that are applicable across a potentially large subtree, but which you don't want to pass through more generic container nodes.  An example might be a color theme, where a large number of nodes might listen to see if the background color is supposed to be white or black; you wouldn't want to pass those around everywhere as parameters.

Making getChildContext() behave more like getInitialState() wouldn't actually solve the problem, because you could always replace a parent node which provides a given context value with another parent node that provides a different context value.  For the affected subtree, this is indistinguishable from mutating the context variable's value.

I think we can find a solution that avoids having users wire up change listeners.

I think @andreypopp may be right.  Or at the very least, we need to provide a way for shouldComponentUpdate to know if anything in the context has changed, so it can decide to always return true if there was a context variable change.

I'll chat with @sebmarkbage later today and see what he thinks.
 Currently, yes, it will re-mount, but that is partly an implementation detail.  You can imagine (and we have been discussing the implementations and ramifications of) reparenting subtrees without loosing node state.

@sebmarkbage and I chatted, and came to the following conclusions:
- shouldComponentUpdate is a complex escape hatch, the implementation of which requires you to have a solid understanding of what is happening under the component.  For this reason, it's not unreasonable to assume you know which context variables are being used, since you already need to know which properties are being used and how they're being used.
- This change probably isn't making the situation much worse than it already was, and it's an improvement over using the old "owner" relationship.  Therefore, this issue is still worth discussion, but is probably non-blocking.
- Contexts are a complex feature/experiment at this point, and we're probably going to need to do more thinking before we officially support/document them.  As we learn more, we'll likely continue to iterate on this topic.

@sebmarkbage, let me know if I missed anything!

Good discussions though!  Thanks for all the feedback!
 This has been known from the start with introduced contexts. We need to be able to have undocumented and unsupported features as experimental features to be able to iterate on them to find special cases. For example, if we didn't have contexts we wouldn't have known that they need to changed to be container-based instead of owner-based. Subtle breakage is part of the contract of using undocumented features.

I think what we need to do is by-pass `shouldComponentUpdate` if there's a new context anywhere in the parent tree. Potentially with a `shouldUpdateChildContext` or something that determines if the entire subtree needs to reconcile.
 Correct, it was always kind of useless.
 @cody et al, To be clear: Context is still subject to change. We're still experimenting with it, and still recommend avoiding it until we've decided on a final API.  Usage is at your own risk.  Is it useful: probably.  Is it ready: no.
 If you design a nice API and implement it. :)

It should include some way to determine that only the children that is listening to context keys that has actually changed are actually updated. Instead of everything.

It is unlikely that our full time core team alone will have time for it. :(

> On Apr 9, 2015, at 1:32 PM, Dan Abramov notifications@github.com wrote:
> 
> Any chance for this to go into 0.14?
> 
> ‚Äî
> Reply to this email directly or view it on GitHub.
 @Chrisui Cool, great to see some progress on this!  We should also add a bunch of unit tests to sanity check basic functionality.  At a minimum:
- Verify child updates even if parent `shouldComponentUpdate()` returns false.
- Verify child updates even if parent `shouldUpdateChildContext()` returns false.
- Verify child does not update if component `shouldUpdateChildContext()` returns false.

Additionally, if these are supported features, we might want to verify:
- Verify `shouldUpdateChildContext()` does not get called if a grandparent changes their provided context, but a direct parent overrides that context and does not change.
- Verify `shouldUpdateChildContext()` does not get called if the component does not read from the context variable that changed.
- Verify that if a prop changes and a context variable changes, we don't update/render twice.

cc: @sebmarkbage for feedback on the API design/idea.
 @Chrisui @sebmarkbage So my concern (unless I'm forgetting/missing something obvious) is that every time a context-provider re-renders, it will cause all the (potentially hundreds) of child components that depend on the provided context variable to re-render, even if the context variable has not changed.  My intuition is that we should only trigger a context re-propagation if we've had some sort of indication that a new value is available (like new value not being triple equals to old value, or some flag/notification).

Actually, this implementation is starting to look like a subscription system.  Since `context` is effectively a scoped global, maybe the correct solution is to require components to sideways subscribe to context variables, thereby allowing us to utilize the same mechanism for context that we are going to use for all other subscriptions to global data.  See https://github.com/facebook/react/issues/3398, https://github.com/facebook/react/issues/3858, and https://github.com/facebook/react/pull/3920 for relevant information.

Poking @sebmarkbage.  I think my latest thinking is in favor of using our sideways data loading solution to solve this problem, to avoid API surface area.  I'm curious to hear your thoughts.
 @Chrisui I think the difference is that a single shouldComponentUpdate in a child component can cut off huge branches of the tree, whereas with context, it's much harder to find/fix all the places that will be re-rendered.  Even if you bail out, a child that depends on the context variable will still re-render.

Yeah, I'm curious to see what others think about using the sideways data loading solution.
 I opened up a PR for you: https://github.com/facebook/react/pull/3973

It is more likely you'll get quick feedback on PRs since they're more easily reviewable compared to master and get priority over issues.

You know I think that I was originally wrong about `shouldUpdateChildContext`. Do we really need it? Sorry about the thrash.

It seems like `shouldComponentUpdate` is a strategy that makes it the responsibility of a child to determine whether something has changed. For example, it may not use all the data that you provided to determine its output. As a parent, you don't know that. Perhaps that is enough.

I also think that we might want limit the parent->child connection to a fixed set of properties, like props. I.e. you wouldn't be able to have multiple different contexts supplied from one source, where any given child uses only parts of the context. There could be a 1:1 mapping. Additionally, I was always hesitant to have context bubble straight through a child that consumes it, while the legit use case is generally a "wormhole" between two components, rather than just broadcasting to everyone (which is an anti-pattern).

I'll think of it some more and comment on the PR with details...
 @sebmarkbage I could go either way on `shouldUpdateChildContext`.  My preference is always to minimize API surface.  We could always leave it out of the initial API (context just jumps through and initiates re-renders on any component that reads the context variable).  If people need the additional escape hatch, we add it later.

I think the bigger problem, as @mjackson pointed out, is that we don't know when the context variable has changed.  Do we really want to re-render every fbt/i18n text node every time the i18n ContextProvider happens to re-render?  We haven't yet provided a way of saying "don't worry, nothing has changed, don't bother re-rendering every text element on the page".

I'm a little confused about your last paragraph; can you elaborate?  I assume you're not suggesting that the following is an anti-pattern of context: An i18n component 'broadcasts' to all i18n-aware child components the user's preferred language/timezone/formatting/etc.
 I actually thought the "wormhole" pattern was the antipattern, and broadcast was the expected pattern.  Context is only interesting if there are lots of consumers of the variable (ie. if passing the prop explicitly would result in it being added to virtually every component and is therefore a lot of boilerplate), otherwise, probably better to pass it explicitly as a prop.  But @sebmarkbage appears to have said the opposite (and he is usually right about this stuff), so now I'm confused and would like to get a clarification from him.

@sebmarkbage @eplawless What is an example of the wormhole pattern that you think is valid?  What is the parent providing, how is it being used by the child, why can't it just be a prop on the child, etc.
 ``` js
<Table>
  <Cell />
  <Cell />
  <FancyCell />
</Table>
```

``` js
class FancyCell {
  render() {
    return <SomeWhatFancyCell>Some content</SomeWhatFancyCell>;
  }
}

class SomeWhatFancyCell {
  render() {
    return <Cell>{this.props.children}</Cell>;
  }
}
```

Take `borderWidth` and pass it to all cells of a table in the form `borderLeft/Top/Right/Bottom`.

One neat way is to pass `borderWidth` to `<Table />`, split it up and pass through context.

It provides a way for something that might render to a Cell to communicate with its conceptual parent like a Table through a hidden channel. This is already what DOM elements do with each other and likely required for doing layout in React.
 Don't overfocus on the concept of a "context". The current concept isn't ideal. Maybe the ideal is something like two different concepts or some other channel?
 Plausible alternative API:

``` js
class Table {
  render() {
    var w = this.props.borderWidth;
    var borderStyle = { left: w, right: w, top: w, bottom: w };
    return <context key={someSymbol} value={borderStyle}>{this.props.children}</context>
  }
}
class Cell {
  static contextKey = someSymbol;
  render() {
    var borderStyle = this.context;
    ...
  }
}
```

Just spitballing here.
 Continuing the spitballing...

Could use an alternative syntax...

```
<Table borderStyleChannelKey="myKey">
  <Cell borderStyle={myKey} />
  <Cell borderStyle={myKey} />
  <FancyCell borderStyle={myKey} />
</Table>
```

Now you've made the communication channel explicit, avoided all possibility of name conflicts, and etc.  (https://github.com/reactjs/react-future/pull/28)
 A symbol doesn't have name conflicts neither, but you've made the communication channel at a cost. You've passed it through multiple levels of indirections. Anytime you need to change or add another channel, such as background color, you need to go update everything even though the documented contract (Cell within a table) is still the same.

Btw, the essence of React already IS a hidden communication channel: state. It doesn't explicitly pass through each child.
 Call it 'styleinfo' or 'celldata' instead of 'borderStyle', and make it an object.  Then adding fields/info doesn't require changing the API contract between `Table` and `Cell`.

The only difference between my variant and your variant is that (in my variant) the only way for the child to actually "read" the value is to have it passed explicitly as a prop from the parent.  Functionally, your latest proposal is literally identical to my proposal from https://github.com/reactjs/react-future/pull/28.

To be clear, I really like your latest proposal... so I'm not going to complain... but it does solve a subtly different problem.  That's what you told me back in March, and I ultimately came to the conclusion you were right (for instance, the broadcast problem).  If we're ok with not solving the broadcast problem (which was how I was convinced that context did provide some value), then by all means, let's do something like this!
 An arbitrary symbol does have name conflicts, unless the key name is always decided by the owner, in which case you might as well make it visible to the owner because the owner needs to communicate the key name to the child anyway (otherwise, how would the child know where to look?).  By forcing the owner to be involved, you naturally encourage components to use symbols instead of hard coded keys.
 I mean a global Symbol (capital S) that have to be orchestrated through some channel such as a common module. https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol

The nice part about my new proposed API is that the key is not an "object property" key which gets confused with control flow and program analysis. In my proposal is a first class dynamic value just like the key that powers state.
 Oh, ic, @sebmarkbage is pulling out fancy new javascript again :).  I should have known; he is at a TC39 meeting today.

Ok, you're right.  That would be very effective in avoiding name conflicts, and would solve the broadcast problem.  You've sold me.  I like it!

I wish you were in the office today!  I feel like this would have been a fantastically fascinating conversation to have in person!
 To be fair, Symbols are already possible to work on the current objects. Even if you use Symbols, you probably end up requiring a module through a potentially global namespace such as an npm top level module name (although hopefully it is relative).

It is just that the current API makes it very natural to use a simple string name. It also conflates runtime semantics with specific property identifiers, makes things like closure compiler advanced mode more difficult to reason about. Also screws with VM optimizations.
 @sebmarkbage You could use UUIDs (aka Symbols), yes, but your new proposal does allow the key to be decided at runtime, meaning the parent COULD influence it via props (not sure what you think of that though).  Having said that, I'm not sure how useful that is without making the values available within the jsx scope, I'll need to think on that more, but it does add some cool flexibility (maybe).
 @taion

> wouldn't easily be able to prevent updates to link active state on the transitioning-out route component.

I'm confused, what's the desired use case?  In general, `shouldComponentUpdate` should NOT be used to block updates which would result in UI changes.  It is a hint intended purely as an optimization mechanism to allow you to avoid doing unnecessary reconciliation work.
 @taion I'll go talk with the Relay folks and figure out what's going on there.  Until we have a definitive answer on that, I wouldn't recommend applying that technique in your own code.

cc @sebmarkbage 
 @taion Yeah, I understand what it's doing, but I'm skeptical that it's a pattern we want to support.  I'll talk with Sebastian and the relay people, but my guess is that the answer is going to be "yeah, that was a hack, don't do that".

Normally, the way you accomplish that behavior, is to put the old values in to state (until the new values show up / arrive) and render the old values from state.
 @taion The approach you're considering seems even more error prone to me ESPECIALLY in the case where you have mutable data.  If your data is mutable, then you're going to have race conditions where children sometimes randomly update (due to an event handler, a context change, a force update, etc), and your code becomes very unpredictable.  Let me sync with some people and figure this out.  Ping me in a couple days if I haven't posted the outcome of that discussion.
 @taion Ok, I just talked with one person on the Relay team, and a couple of other React people.  We are all in agreement that this is not a good pattern.  Please don't do it.  Using state to store your data while waiting for an update is the official solution, until we come up with a better api/recommendation for that use case.
 @aghosh47 I think a context change does trigger a rerender, but it's possible we missed an edge case.  If you could create a simple jsfiddle that demonstrates the issue, that would help us investigate.

Also, please post it to a new issue, as we want to keep github issues on topic, to the extent possible.
 @jedwards1211 To be honest, I don't remember where it was discussed.  It's entirely possible that it was an in-person discussion, but there are many reparenting discussions online and maybe you'll find it there.
 Ping @aghosh47
 @cauburtin Context is useful because:

1) It can change and trigger re-rendering unlike module exports
2) It can be overridden by the parent, which is its most useful feature
3) It doesn‚Äôt have to be a singleton, which is useful for server rendering where you want to isolate data
  This has come up a couple times now and even we get it wrong when building things ourselves.

This is happening because esprima is actually doing entity parsing. So when it sees `&` in a JSX string it treats it like the beginning of an entity. It then looks for known HTML entities (eg `&middot;` and does the replacement) or unicode fallbacks. In this case I think we're seeing an unteminated entity and then since you had all characters, treats it as a "known" entity and then looks in an object map. `map['abcdefghi']` is then undefined and we stick that in for some reason.

I think we all agree that entity parsing in esprima was a bad idea but it was related to the XML behavior we were trying to achieve. We should probably actually remove this since it's so rarely the desired behavior. cc @jeffmo  (we'd want to end up closing this here and tracking elsewhere but I'll leave it open for now).
  Thanks!
  No, that wouldn't solve it. Closure will still see the bare `d` as a key and try to crush.

The only real option is for you to set up an externs file and make sure `d` is in it. We don't have an extern files that we maintain (though I would guess it's not too difficult to at least partially automate based on the property config files).
 Since you aren't using JSX, you could also of course quote `d` in the props object so closure skips it.
  "appear" differs from "enter" in that all children of a transition group at mount time will "appear" but will not "enter". All children later added to an existing transition group will "enter" but not "appear".

This extra transition phase allows for animation-on-mount effects.

A mirroring "appear" prop has been added to ReactCSSTransitionGroup, however for reverse-compatibility (and because "appear" is less common) it defaults to false.

Thanks to @appsforartists for his work investigating the possible ways to implement this.
 cc @petehunt 
 also cc @zpao and @sebmarkbage - just want another set of eyes before merging this.
 Just FYI, I think that we'll want to build in some native support hooks for transition groups that works better with composition. Which will later replace ReactTransitionGroup.

This doesn't "appear" to use any additional internal APIs so I don't think this could be harmful.

Thanks.

> On Nov 13, 2014, at 9:34 AM, Lee Byron notifications@github.com wrote:
> 
> also cc @zpao and @sebmarkbage - just want another set of eyes before merging this.
> 
> ‚Äî
> Reply to this email directly or view it on GitHub.
 Agreed, @sebmarkbage. The mixing of parent and child lifecycles is a bit confusing and incorporating transitions into the component lifecycle directly will be much clearer and more powerful when we get that worked out.
  Hey @appsforartists - I forked your fork and added CSSTransitionGroup change and tests - https://github.com/facebook/react/pull/2512

let me know what you think
 @appsforartists, yeah thats the only major difference.
 Both present some new ideas to consume. `enter` is also called directly after a mount. Describing the difference between `appear` and `enter` is a little tricky either way, because they're both relative to the _parent_ lifecycle, which is uncommon for React components. So the more verbose (but accurate) way to say `enterOnMount` would be `enterOnParentMount` or `enterOnGroupMount`.

I'm actually in favor of avoiding referring to "mount" here because it's easy to get confused between the parent mount vs the child mount.

Either way, we will need to update the wiki to describe these concepts.
  ReactTransitionEvents isn't a public module so we're not particularly concerned about its API. This doesn't sound like a bug per se, so I'll close this out. Let me know if I'm misunderstanding. (Also willing to consider a pull request if you feel so inclined.)
  Yea, it sounds like `context` will fit the bill here. We're in the process of revamping it a bit for more official support.
  You need to use `require('react/addons')` everywhere for now it seems or it may break, it's weird. Could be what's causing it.
 @skiano I think reactify@0.15 uses the JSX compiler for react 0.12 so you may run into issues there. You should check and make sure the react-tools version matches what you are using. But shouldn't be related to what you're seeing.

`<img>` is special because we have an internal wrapper component to do some specific event handling.

Mostly likely something in your packaging for the browser is screwing up. We've seen this before (#2456 is the most recent).
 Going to close out but feel free to reopen if there's something we can do here.
  If you make a window bigger past the end of a page, those values will change, right?
 It will if you're at the end of the page and you're making the window wider so that it has to scroll up to avoid being past the page.

However, that also causes a onscroll event to be fired.

@fabiomcosta Can you list browsers and conditions that you've tested?

@petehunt Do you know a special case where this would fail?
 I'm trying to think of an edge case (maybe involving media queries?) but can't think of one. Though now I'm wondering if we should be listening to orientationchange...
  We're not going to suggest any specific tools there in the docs at this point. We do refer to the wiki page which has a lot of related packages, I suggest adding yours there. https://github.com/facebook/react/wiki/Complementary-Tools

We may want to link to the wiki from where you're editing though. I'd be happy to take that PR but not this one.

Thanks for taking the time to write this up (and of course for making the package)!
  `mockComponent` is legacy and is not needed by Jest anymore really.
 Our preferred way of testing React is now using shallow rendering. http://facebook.github.io/react/docs/test-utils.html#shallow-rendering

This doesn't suffer from the need to mock your components, and even if you do it doesn't do anything.
  :+1: Thanks!
  Reassigning `ref` like that does not make sense as it will not be exposed in the owner, but your component that cloned it.
 This only works because your ref is on the top level. If you wrapped it in an owner, you would silently be stealing it from another owner - which would require a warning.

This use case only works because string-refs doesn't work at the top level, anyway. However, ref-callbacks does work at the top level so you would end up silently stealing a ref.

It seems like a bad idea to support this as a general pattern because it is not universal and only works in this limited case.

Long term we could support chained refs which would allow both owners to retain a ref handle.
  Good catch. Let's put an addons section with the other polyfill docs so it's all contained. It might also be worth mentioning that "additional polyfills may be required, see ___" from the addons index too.
 Since `classSet` is getting deprecated (#2910) I'm closing this. The new version (which doesn't require filter) lives at https://github.com/petehunt/react-classset
  No that's intended, that it translates to `<noscript>` is a temporary implementation detail.
 `getDOMNode` actually always returns `null` when you return `null` from render. You'll want to guard appropriately if you're doing direct DOM operations.

But which component's `componentWillUnmount` is the failure happening in? It sounds like you're saying `ModalInner`, which as long as you're rendering something there, its `getDOMNode()` should work (and it unmounts if you return null from `Modal`
 Hmm, in that case, it does sound like a bug. And I bet it's because we're just adding something to the null component cache and then when we try to get the dom node in the unmounting child it hits that cache as it's traversing and bails out, never getting the actual existing node before it disappears.

cc @chenglou, did we not have a test for this case? Want to fix it?
 Can't decipher the actual issue here, but it sounds like #2353
 This is a bit separate from #2353.
 @schotime Glad to hear it!
  You can use write something like

```
<div {...this.props} className={(this.props.className || '') + ' table table-bordered'}>
    <span>a box</span>
</div>
```

or, using the [`joinClasses` helper](https://github.com/facebook/react/blob/7a162ce73129067c0355388c15177be5040c04ad/src/utils/joinClasses.js) (not available in the built React or via npm, sorry):

```
<div {...this.props} className={joinClasses(this.props.className, 'table table-bordered')}>
    <span>a box</span>
</div>
```
  I'm going to close this out and probably just do #2369 which will be better for us longer term. Thanks for bringing this up!
  We're actually just going to get rid of this mention in the docs entirely in #2636. Thanks for the effort though! We appreciate you taking the time.
  Thanks! Sorry for the delay.
  That syntax isn't currently documented. If we decide to encourage/document it, we'll be sure to mention any required polyfills at that time as well.
 Thanks, didn't realize we wrote that in the docs.
 Maybe we should just drop it from the docs and refer to the proposal? It's not needed for any supported React-specific patterns.

This was a copy/paste mistake from our internal docs. As evident by `"In fact, you can already use this in our code base as an experimental syntax"` - referring to the FB code base.
 So drop it and don't mention `Object.assign` at all?
 Yea. We'll need to document our harmony stuff separately with all their edge cases and considerations.
 Removed from docs.
  This isn't super well documented, but you need to use `OTransform` (as well as `WebkitTransform`, `MozTransform`. `msTransform` is a special case because MS did something different). This is because we're setting styles vis JS. Same reason you must specify other styles as camelcased, eg `backgroundColor`. Can you update your code and report back if that fixes things?

Read more: http://www.andismith.com/blog/2012/02/modernizr-prefixed/

Also, fwiw, latest Opera is now built on blink. Did they maintain the `-o-` prefix? I would have thought they just picked up the `-webkit-` one...
 Maybe we can warn for this.
  Closing this out as it's not super actionable, but #2512 added an "appear" phase.
 Me too. :) Just going through issues today.
  Trying to clean up issues so I'll close this out but I'd take a PR to clarify.
  Yes, currently you have to replace the entire contents of a container. After #1711 this won't be true any more, but the best workaround is probably to add an extra wrapping element around the `<ul>`.
 No, I wouldn't expect this to change anytime soon. Maybe eventually.
  Thank you!
  Thanks! Can you tell that we did find/replace when renaming descriptors to elements? ;)
  The original is correct. The word "react" is the English verb; it doesn't refer to the React library in this case.
  Hmm, an interesting special-case, but I'm curious... won't pressing CTRL-B or w/e wrap the selected text in `<b>`?

Operating `<input>` in controlled mode is made possible by `value` being marked as `HAS_SIDE_EFFECTS`, which means that for every update it checks the DOM `value` and compares it against the current value. This stops the cursor jumping to the end for every key press. But this cannot be realistically applied for `contentEditable` as it may become prohibitively expensive.

I'm not the expert on this, but I believe `contentEditable` is best handled through manual DOM interaction.

I feel the warning may be preferable regardless, you're free to ignore it if you can guarantee that it is not an issue for you.

cc @salier 
 I think I can close this out. As noted there is a child so we warn but if you really know what you're doing then feel free to ignore it.
 @halt-hammerzeit You can rope it off from React (render an empty tag using React, attach a ref, and add a content-editable child in `componentDidMount`).

FWIW, my recommendation is to build (or use) a React component which implements the editable semantics you want.  It's unfortunate to be forced to implement what the browsers already have builtin, but you'll have a better end experience in the end, because you'll have an editable component that plays nice with a declarative framework like React.  Worth reading: https://medium.com/medium-eng/why-contenteditable-is-terrible-122d8a40e480#.aq2xacp42
  `React.addons.cloneWIthProps` is the correct way, but it currently has some drawbacks you need to be aware of (check the docs).

PS. Yes it's very bad, props is considered immutable and shouldn't be mutated (and may not be mutable).
 @totty90 `props` on ReactElements (i.e. what you return in render()) is considered immutable AFAIK, in-fact I believe the entire ReactElement is to be considered immutable.
  :thumbsup:
  The devs have explicitly rejected IE7 support, see #2169. While this may be one of the few things that prevents it from actually running, I'm sure there are many inconsistencies and presents major obstacles for further "React improvements". If you want this, fork an IE7 branch of React, or if someone has already made such a thing available. (**EDIT:** https://www.npmjs.org/package/react-ie)

cc @zpao
  I can't imagine `foo` being a variable used inside React, this is most likely something in your code.
 @andreynering Might be a bug in FF, Chrome had a similar issue a while back where it would suppress error messages. If it's possible to enable "pause on exception" in FF, then try that and see if it helps.
  ```
npm WARN unmet dependency /.../node_modules/react/node_modules/envify/node_modules/jstransform requires esprima-fb@'~6001.1.0-dev-harmony-fb' but will load
npm WARN unmet dependency /.../node_modules/react/node_modules/envify/node_modules/esprima-fb,
npm WARN unmet dependency which is version 4001.3001.0-dev-harmony-fb
```

cc @zpao 
 How did you get that? A fresh `npm install` doesn't give me any errors.
 @zpao It's really weird:

```
development:~/r2# npm install react
react@0.12.0 node_modules/react
‚îî‚îÄ‚îÄ envify@3.0.0 (through@2.3.6, esprima-fb@4001.3001.0-dev-harmony-fb, jstransform@6.3.2, xtend@2.1.2)

development:~/r2# npm update
npm WARN unmet dependency /root/r2/node_modules/react/node_modules/envify/node_modules/jstransform requires esprima-fb@'~6001.1.0-dev-harmony-fb' but will load
npm WARN unmet dependency /root/r2/node_modules/react/node_modules/envify/node_modules/esprima-fb,
npm WARN unmet dependency which is version 4001.3001.0-dev-harmony-fb
xtend@2.1.2 node_modules/react/node_modules/envify/node_modules/xtend
‚îî‚îÄ‚îÄ object-keys@0.4.0
esprima-fb@4001.3001.0-dev-harmony-fb node_modules/react/node_modules/envify/node_modules/esprima-fb
jstransform@6.3.2 node_modules/react/node_modules/envify/node_modules/jstransform
‚îú‚îÄ‚îÄ base62@0.1.1
‚îú‚îÄ‚îÄ source-map@0.1.31 (amdefine@0.1.0)
‚îî‚îÄ‚îÄ esprima-fb@6001.1.0-dev-harmony-fb
```

It doesn't warn on install, but obviously installs `4001`, on update though it complains about `6001` being unmet.
 Weird. I don't understand npm sometimes.

I bet this goes away when https://github.com/hughsk/envify/pull/14 gets shipped so envify doesn't have its own esprima dependency.
 @zertosh :+1: PS. Your talk/presentation was excellent :)
 So I think with envify publishing 3.1.0 and our deps being `^3.0.0` we should just pick this up automatically.
  `event.nativeEvent` gives you the original event, React does not bring along or polyfill non-standard attributes.
  @iamstarkov looks like the version with fixes is not shipped yet
  What are you using to do the JSX transform? If react-tools, what version?

AFAIK, we've always kept the empty string case correctly (`<Component prop="" /> -> {props: ""}`) and only do the boolean for naked props (`<Component prop /> -> {prop: true}`).

We are currently doing this correctly and `this.props.prop` in the above case is indeed an empty string.
 Closing out. Reopen if you can repro.
  Insert them explicitly with `{'\n'}` or similar, but if what you really want is white-space then I recommend you use white-space instead.
 Sounds like you have a solution, so closing out.
  Summary:
Changes the way we instrument methods for `ReactPerf` so that developer tools can assign implicit method names to measured functions.

Reviewers: @zpao @sebmarkbage
 Oh, wouldn't it be nice if GitHub could ignore whitespace changes?
 Add `?w=1` to the URL.
 Whoah... that is amazeballs.
 We need to drop ReactPerf and do some replacement because it won't work with the refactored internals.

Btw, you could wrap the `ReactPerf.measureMethods` call in `__DEV__` so we don't have to take the initialization cost.
 It's likely going to be replaced by a completely new model. I don't know what though - which is why I'm hesitant.

Why do you ask? Do you have concerns or ideas?

> On Nov 7, 2014, at 7:33 PM, Phips Peter notifications@github.com wrote:
> 
> What is happening to ReactPerf? Is there a design of where it is going?
> 
> ‚Äî
> Reply to this email directly or view it on GitHub.
  Thanks!
  Yes, the docs are correct already for 0.12 and up.
  There are quite a few places where you can't throw exceptions without React ending up in an invalid state. If you can't trust your developers then the only solution I know of is to put a try/catch in each render.
 @longlho Not my area, but I believe the two biggest blockers are; many browsers ruin the error/call-stack when rethrowing and try-catch incurs performance penalities and these are hot paths.
 Yeah, you may hear conversation about "error boundaries" which means making a way to handle this sort of thing more gracefully and something we want to find a good solution to. I don't think we have a tracking issue for it though so let's use this one.
 https://github.com/facebook/react/issues/3313 has a really nice unit test that we should probably start using once the error boundaries issue is fixed.
 @skiano If that's working for you, no reason to stop. Our eventual solution should be a little more flexible than this and more efficient but will be similar in spirit.
 I'm willing to but it doesn't require much discussion, it just needs to get done.
 +1, been thinking about this lately
 Let's leave this open until the new feature is complete.
 An error bubbles up to the nearest error boundary (that is, a component with `unstable_handleError` defined). If that component errors when trying to handle the error, the error will keep rising.
 #5602 has the first code for this which catches errors only on initial render but not at any other time. When we have more I am sure that this issue number will be mentioned in the description so you will see them in the comment history here.
 @DanielSundberg Yes, basic/unstable support was added for initial render in v15, and support for updates is being added in a future release.  It will be documented when it becomes stable.
 @thom-nic Officially, v15 does not support error boundaries.  Unofficially, https://github.com/facebook/react/blob/master/src/core/__tests__/ReactErrorBoundaries-test.js
  It's not very easy to follow what's actually going on there, would it be possible to create a repro?
 Going to close this out but if you can make a minimal repro case, please post it here and I'll reopen.
  Definitely not by design. I can't think of why this would happen; it doesn't even sound like something we can control because the files should end up referencing the same module and browserify shouldn't run (or bundle) it twice.
 I just created a simple example doing what @tkafka explained originally - https://github.com/zpao/react-bundling-example. I'm bundling with browserify & reactify (though the latter should have no effect on bundling). I looked through the generated bundle and there is only a single copy of React bundled.

I would love to see a case where this repros. My guess is typically that some other (third party perhaps) component is being required which also requires React. And it has a different version dependency. Or maybe its even the same but because of the way you ran npm install, there are dupes.
 Thanks for investigating! I don't think you're the first to do something like that (nor the last) so hopefully we'll be better able to diagnose this in the future. And then kill `addons` so it doesn't happen ever again.
  If I'm understanding the Capybara commit right, setting the value does not trigger a change event. The test has to click on the body in order for the event to fire (which would happen if an input has focus, .value is set via js and then the click is triggered).

Is the change event actually firing without that?
  Our plan here is to make onChange consistently fire on every change in all browsers; see #554. You can use `onBlur` or maybe `onMouseUp` if that's the behavior you're looking for, but the native onChange event varies widely across browsers even if we don't do anything special in React so that's probably not what you want.
  It's not in the standard (yet), http://www.w3.org/html/wg/drafts/html/master/forms.html#range-state-%28type=range%29. If it's most likely going to end up in the standard then it makes sense to add it, otherwise it should use whatever mechanism we add for adding "non-standard" attributes in the future.

For now though, simply `<input ref="i">` and in componentDidMount call `this.refs.i.getDOMNode().orient = 'vertical';`.
 Closing until it's in the standard.
  Yea we can do this. For our pre-built files we run them through es3ify, which strips trailing commas and quotes reserved words. We don't run this for the npm package though (apart from `dist/` which is just the pre-built files).

We may end up going in the other direction and sync out a transform that strips trailing commas as part of the earlier build step. At FB we've actually moved in the opposite direction and don't discourage trailing commas (they do help maintain blame and it's standard procedure in our PHP code).
 If we do a 0.12.1, we'll ship this with it.
  Awesome. Want to add these to the wiki? We can also add the video to our [videos page in the docs](http://facebook.github.io/react/docs/videos.html) (though that's growing a bit unwieldy these days). Want to put it somewhere in there?
 (going to close out since the real things can happen outside of the issue)
  I just removed target dates. They were never solid commitments just our estimation at the time. Thanks for the reminder.
  This is simply a limitation of React's current "DOM implementation" and will certainly be dropped in the future. You can return `null` at current but it will simply translate to `<noscript />`.

However, I'm not entirely sure what you're asking for, if you intend to render "dummy components" which never have any DOM themselves then while it will probably be supported in the future, it will probably not be considered good practice.
 @jiyinyiyong Ah now I see, same answer though, it's a limitation of the current "DOM implementation" in React. There's nothing wrong with your example, but `group-a` must wrap `this.props.children` in a DOM component for it to work or it will return an array (which is not allowed). AFAIK devs have expressed intent to fix this in the future.
 @leoasis I haven't really investigated the exact obstacles, but broadly speaking, the problem is the current implementation expects _all_ components to correspond to exactly one DOM node (can be shared) which is a very simple case to handle (in-terms of lazily associating node and component, and also mutating the root components). To be able to handle 0 or 2+ is a lot more complex and none of that "infrastructure" currently exists in React (components would need to be aware of sibling components, etc, etc).
 @leoasis If you're looking to contribute in general I would recommend looking to other areas of React. I would expect this to affect the internal API considerably in quite non-trivial ways and even if you managed to get it working, that it may just be too much friction to realistically get it approved. That being said, figuring out what needs to be done and pushing bite-sized PRs is always a possibility, or do you have any objections @sebmarkbage ?
 Closing this as a dupe of #2127.
  :+1: I think many don't _really_ understand what `$(function() { ... })` does and do it just because their code didn't work otherwise, I like the "document.body warning"!
 This sounds vaguely reasonable, but I think we're going to do #3211 instead so I'll close this.
  Setting a `displayName` for each component should fix that, it's done automatically if you use JSX.
  Thanks!
  This is correct and by design, by updating the value of input with `event.target.value` you have a controlled input. There is more information in the docs.

http://facebook.github.io/react/docs/forms.html#controlled-components
 @menelaos No problem.

> The input value in the example above is fixed for all times (value="fixed").

You never update the value and thus it _appears_ read-only/fixed. A read-only/fixed input field is a side-effect of a controlled component that has a fixed value.

Read the link I posted and it might become clearer:
http://facebook.github.io/react/docs/forms.html#controlled-components

PS. If you want a read-only input then set the `readOnly` attribute.
  And you win, beating out #2422 for the win :) Thanks!
  Thank you for the PR, and sorry about the long wait. Now that #5714 is merged, all attributes on SVG elements will be passed through as is, with no need for the whitelist. I'm closing this but please let me know if you have any troubles in master.
  The spread operator is part of the ES6/7 spec, JSX shouldn't change implementation details (which is also specific to DOM components). You'll have to do something like `{...this.props, className: mergeClassNames('...', this.props.className)}`.

Closing as this is intended behavior.
 `joinClasses` is an internal helper that we could expose as an addon. You can also just use simple concatentation:

``` javascript
var { className = '', ...props } = this.props;
return <div {...props} classList={className + ' someClassName'} />;
```

I was hoping on being able to do something like:

``` javascript
var { classList, ...props } = this.props;
return <div {...props} classList={[ ...classList, 'someClassName' ]} />;
```

But that might not be very performant.

Either way, it's more explicit and less magical. It should make it easier to understand what's going on. That tends to be more convenient than saving the typing. The problem with magic is that you don't know which props have magic behavior and what exactly it might do.
  1. In React you are wrapping each `<li>` in a composite component `Number`, these currently have "significant" overhead when used in large numbers. You're not doing the same thing for Angular.
2. For React to remain performant at scale, you must use `shouldComponentUpdate` (can't do both this and 1 though for your example, adding this should reduce your update time _significantly_).
3. I'm pretty sure you are running React in debug mode which is significantly slower.
4. React is not the best brute-force performer (i.e. tons and tons of nodes), but it tends to perform 
   _consistently_ when dealing with more complex UIs, which Angular/KO often buckles under.

An important consideration is that React is _not_ meant for every use-case, that's why it's so easy to "escape it" when you need and render a huge list of DOM nodes yourself (or with Angular) if you need to... but I've never had to. React also makes rather easy to "render on-demand" which is preferable IMHO.

My personal opinion is that React is more than fast enough for my needs, I notice no slowness and everything is very snappy, even when switching views. I'm confident that as our app grows it will continue to perform equally well... but even if that wasn't the case, the component model of React is just fantastic and I would give up _a lot_ just to have it.

PS. Updating a single huge array of items is the worst-case for React, it always has to create the "virtual DOM" element for all items even though only 1 may have changed. If you absolutely need to do this (and not on-demand or w/e) then grouping your "items" in some way can increase performance significantly as it can then skip large parts of the array.
 (Sorry, another tl;dr :))
1. You are rendering X amount of `<Number />` instead of X amount of `<li />` directly.
2. That's why React recommends immutable data, `shouldComponentUpdate` becomes super cheap and super simple. You don't implement it by hand for every component, you mostly just use a mixin for it. If you find that a component is a hot-spot then you add a simple check or two.
3. I'm not all that familiar with the different tests, Angular can render simple but large lists just fine, but when the data and its dependencies become more complex and non-obvious it tends to become a huge issue and there's rarely a good way to solve it it seems (I had this exact problem with KO across our entire app).

From my experiences and understanding of React; React will never be the best performer for simple (somewhat synthetic) use-cases, there's too much overhead setting up things and dealing with components. But it's a much more consistent performer, even as you approach worst-case. I think my main takeaway is that when performance is sub-par in a React app, the solution is just to apply simple and intuitive optimizations (mostly `shouldComponentUpdate`), whereas in Angular/KO/etc the go-to is often to _avoid_ language features or apply various workarounds.

Personally, after having used and been disappointed by every framework there was, React has worked fantastically from start to finish. Consistent performance, the code-base is more beautiful, readable and reusable than it has ever been.

I'm also confident that there are tons of research-type optimizations React can eventually apply to squeeze every drop of performance there is (React is incredibly naive at current) ... but your existing code-base of components will look and work just the same. For me, my reason for choosing React is because that's _how I want to work with UIs_, not that React is the best at everything _right now_.

Feel free to drop by our channel on IRC if you have any questions.
 @pselden We try to keep issues related to development, so I'm closing this as I don't think there's anything actionable here (we will continue to optimize React), but feel free to continue the discussion if you still have questions.
  0.12 just came out, and it introduces lots of (trivial, but still) breaking changes. The docs are not yet pushed, but if you check the repo's [md files](https://github.com/facebook/react/tree/master/docs/docs) they're up to date.

Is this issue recent? I was under the impression that the docs page was very up to date until this week.
 What's out of date here? I know there are a couple small things left to do (mention deprecated APIs, 1 new adding) but docs were otherwise updated for 0.12 launch and are pushed to the site. `React.render` is the latest API.

If there are mistakes or omissions, please do tell us and don't bottle this up. We can't fix problems we don't know about. This is the first we're hearing about problems to the extent you seem to be describing.
 #2434 solved this. Check the md files linked above for the most recent documentations. Sorry about that; keeping docs up-to-date during transition periods isn't easy but I think they've been relatively well-maintained til now =)
 Pushed, sorry for the delay and confusion.
  If you're using JSX you _must not_ use `React.createFactory` or `React.createElement` and then use the result as a tag in JSX, you should only use the class itself, i.e the value of `React.createClass`.

I'm not intimately familiar with the tests for the various warnings, but it explicitly says "Warning: This JSX uses a plain function. Only React components are valid in React's JSX transform.". I.e. you're doing:

```
function Foo() {
  ...
}

return <Foo />;
```

Which is not valid anymore.
 One place we're seeing people get tripped up by this is tooling. They are upgrading React without upgrading the JSX transform pipeline. If you are using react-tools directly, reactify, or any other library doing the transform, it must also be updated. You said you updated gulp-react but l I would double check that. Inserting createFactory calls would only fix JSX uses if you are still transforming with the old pipeline.

An easy way to check is look at compiled output. If createElement is nowhere to be found, then you are still using the old JSX transform.
 @TrySpace Please post your code/repro.
 @TrySpace You shouldn't use `React.createFactory` for JSX.

PS. Also, you _definitely do not_ want to create a new `ButtonComponent` every render.
 See this blog post ‚Äì library authors should export unwrapped classes:

http://facebook.github.io/react/blog/2014/10/14/introducing-react-elements.html#anti-pattern-exporting-factories
 I don't think there's anything actionable here so I'm closing ‚Äì please correct me if I'm wrong.
 @TrySpace It looks like you're using both createFactory and JSX ‚Äì is that right? If you're using JSX to specify the elements you shouldn't ever need to call createFactory.
 @sebmarkbage Do you want to do an explicit warning when using the output of createFactory with JSX instead of the generic "don't use functions with JSX" warning? Doesn't look like there's a real way to identify them at present but we could always add a `._isReactFactory` or something‚Ä¶
 @spicyj As it's only for a temporary warning, detecting if `.type` exists may be enough.
 @TrySpace Sure it is, otherwise just invoke `React.createElement(MyClass, ...)` manually if you want to avoid JSX there.
 @irvinebroque Unfortunately it's not possible for us to print out a better error but you should be able to set a breakpoint at the warning and then inspect the call stack to see what part of your code is causing the problem.
  Ah, good catch. Thanks!
  Duplicate of #2429, it's by design.
  Sounds fine.
  `component` was an example there. It was being used to indicate that **if** there were an HTML tag called `component` then React would use that, **not** your custom component.

Currently in the JSX transform we still check a whitelist of known HTML elements. We won't be doing that in the future, so 0.12 is a release that allows you to upgrade without breaking in completely mysterious ways. Eg, here we break at compile time so you don't ship code like this to production.
 Correct. And yea, I wouldn't add webview to the whitelist anyway. Not because it's obscure but because it's a non-standard tag.
 As I was closing that issue I noted that you could use `React.createElement('webview')` directly. However it's not available on `React.DOM` or as part of the JSX transform.
  By design I believe, @sebmarkbage 
 Yea, this is by design. We had a note about it in the change log: http://facebook.github.io/react/blog/#changelog

The reason is that the concept of a key is something that is controlled by React internals before your component gets created. The same thing for refs.

You can think about an array of `ReactElements` as a Map.

A Map is a series of `key` and `value` tuples. A React fragment is a series of `key` and `props` tuples (and also `type` and `ref`). The key is designed to decide what the value is in each slot, but not the actual value itself.

If you're reading a prop named `key` you might be overloading the meaning of `key` or accidentally using it for something unrelated.

This change makes the concept a bit more strict. This helps avoids bugs with transferring props to another component which shouldn't bring the key and ref along with it. It also helps performance by ensure that types in React internals are consistent and stable.

I would suggest renaming or duplicating the prop name as a possible fix if you really need to access it.
 @willdady `this.refs` is the result of `ref` assigned to children (not the value), just as the component updating or unmounting is a result of the `key` assigned to "its associated element". Element refers to `<div />` which is _not_ an instance. `key` and `ref` are defined as special use for React and their values should not be used for other purposes.

So to address what seems to be the confusion; `<div key="foo" />.key === "foo"` is correct, `this.key`/`this.props.key` from within a component instance is not.
 @hpcodecraft That's already gone in master.

@jhudson8 It's likely that ref will change from a string to a richer data type which allow you to share a reference between siblings. See https://github.com/facebook/react/issues/1373 Could something like that work?
 @jhudson8 We take breaking changes very seriously. We want to make sure that it's always at least possible to upgrade every use case... and ideally make it somewhat convenient. I think that either the first-class refs or context will be able to help you solve the use case though. :)

Feel free to ping me if you have trouble solving the upgrade path.
 React shouldn't complain if you provide a second argument. E.g. `this.method.bind(this, index)` should work without warnings since that is not useless.
  Thanks! Nice catch. I blame @sebmarkbage :)
 _hides_
  There isn't quite enough info to help you here. Can you attach a stacktrace? It's possible we're hitting code that is using implied globals (eg, `window`), though I thought those were all safe-guarded.
 A Java stack isn't interesting or helpful here. Can you get a JS one?
 @zertosh thanks for the repro!

cc @jsfb I know you have more Java background than I do - could you look into this?
 @zertosh Yes, thank you, great repo.

@zpao I can confirm that it fails using npm-react 0.12.2.  I hacked in my internal build of v0.13.0-alpha, and the error went away.  That means it is likely either an issue with the npm build process, an issue which has been fixed in master, or a heisenbug bug in nashorn.  I'll do an npm-build of 0.12 and 0.13 to see what happens, and then I think we'll be able to close this one out.
 I shimmed in an internal build from 0.12.2, and it didn't work.  Since it sounds like it was broken for a while (at least since 0.11.2), and it appears to be resolved in 0.13, I'm going to close this bug out as resolved.

@zertosh It may be worth checking/building master, and using that version of react.  If you run into this issue again on master/0.13, let's re-open the issue and we'll dig further.
  In general I'm in favor of better error messages. Typos are always easy to make. In this case `mixin` is totally valid to have, so we want to make sure we don't swing in the other direction and carelessly warn for something that isn't an issue. We could scope this tighter and only warn if `mixin` exists, it's an array, and `mixins` doesn't exist, which effectively covers the same case just with less potential for being noisy. Let's do that instead.
 @zpao, I think I disagree here. It's perfectly valid to have a `mixin` property to be an array for your purposes. I'm not sure this warning carries it's weight of this special case.

We've generally opted not to do warnings for typos (other than `shouldUpdateComponent`) because it's such a slippery slope. What about `mixns`, `mix`, `mixinss`, `mixinClasses`...?

`shouldUpdateComponent` is special since it's such a unique name and the particular grammar rule, that we take advantage of, isn't well understood.
 I think at this point we're not going to do this. Thanks though.
  `form`, `formNoValidate` are in there. `autoFocus` is handled at run time. The others are missing.
  I totally agree. I was actually planning on at least initially linking off to the documentation in the stable branches as a stop-gap solution. Since it's not just API documentation but a lot of explanations and inter-page links and sometimes just wording updates between releases, it's a little tricker than the node docs.

And yes, we're open to change. Let's discuss before you drop a complete change on us thought :)
 That wouldn't work for us but it's a great idea. Maybe we can do something in that vein though.
  Can you include some minimal code that reproduces this error?
 Bah, I know what's happening. This is a reactify issue (filed https://github.com/andreypopp/reactify/issues/23). Details are there. Basically it's install react-tools 0.12 for you when it shouldn't.
 @Natim Hmm, so you _should_ be able to fix your issues by upgrading to reactify@0.14 (which locked the react-tools version correctly). However, I'm still not seeing the issue when cloning that repo and running `npm install` (using npm@2.1.4). I'm suspicious that different npm versions are installing packages in different orders. If reactify is installed first (and for some reason doesn't see that the react-tools which is also going to be installed meets its version dependency) then it'll install react-tools 0.12. What version of npm are using?
 In case you aren't following along in the reactify issue, updates were released for all of the branches, locking the react-tools version. I still suspect something related to npm is causing the inconsistent repro, but we should be fine. Thanks for bringing it up!
 Installing react will not install reactify.
  The author of the other PR beat you out to signing the CLA so that one is going in. Hopefully you'll get a chance to contribute in the future!
  Ah yes. This is one of the reasons for why `transferPropsTo` has been deprecated. We should probably mention this more clearly in the release notes. I thought this was changed in 0.11 but I guess it wasn't.
 Also, http://facebook.github.io/react/docs/transferring-props.html
 Yes. That's what we try very hard to do. There was a lot of changes that went into this one so the sequencing was very difficult to get right. We could've deprecated it in 0.11 and introduced the spread syntax earlier. Hindsight.

transferPropsTo was very rarely used outside of Facebook so we deemed that we didn't need to release a codemod to go with it. We didn't consider that former Facebookers might use it more prevalent. Sorry. :)

> On Oct 29, 2014, at 8:10 AM, "Stefano J. Attardi" notifications@github.com wrote:
> 
> Typically the whole point of deprecating something is to give people time to transition away from it. If you break the semantics as you're deprecating it you might as well remove it entirely. At least that way you're avoiding potentially insidious bugs that come from the breaking change, and making it clear to people what they have to do to upgrade to 0.12 without their code breaking.
> 
> ‚Äî
> Reply to this email directly or view it on GitHub.
 Technically, transferPropsTo didn't change semantics, but it's affected by defaultProps changing semantics. It only breaks when both are used together. We'll update the post to reflect this breaking change.
 Sorry that this bit a few of you, but it's too late to do anything now so I'm closing this.
  It's all set. Previous versions of the docs are available on GitHub if you are using < 0.12. in the `X.Y-stable` branches if you need them.
 FWIW, you can still write `React.DOM.h1(null, 'Hello, world!')` in 0.12 and that will work. We left those convenience functions in place. However CompositeComponent need a bit more wrapping (See docs for details)
  Thanks!
  Thanks!
  @dandelany This feature was never announced in 0.11.2 because it wasn't quite done yet. In 0.12, the spread attributes in JSX do not require `Object.assign`. It calls into `React._spread` for now.

The original intention was to require an `Object.assign` polyfill for all of React Core just like we do for ES5 features. This is the direction we're heading. Checkout this presentation for rationale: http://2014.jsconf.eu/speakers/sebastian-markbage-minimal-api-surface-area-learning-patterns-instead-of-frameworks.html

Both our `--harmony` transpiler and React will likely take on dependencies on ES6 polyfills in the future. Especially for ES7 features.

Unfortunately, the wider JS community's polyfilling infrastructure is pretty poor. So we eventually decided against taking on the dependency in React Core for now.

@dexbol The main docs was updated with alternative patterns if you don't want to follow along with the progress of standards. http://facebook.github.io/react/docs/transferring-props.html#transferring-with-underscore
 Closing out since this was already addressed in 0.12.
 That seems like react-rails might be still using the old compiler. That's not the 0.12.0 behavior. Perhaps you're using the 0.12.0 runtime with the 0.11 compiler.
  Do any visitors need to be added to make sure we run that (or any new) transform?
 Does jstransform transform that code or does it simply not barf when parsing that code? If the former then I'm guessing we need to enable more transforms (aka visitors)
 Cool :)
  Thanks!
  Thanks!
  In general, there's no way to statically identify what might be a valid component. Consider the last example here:

http://facebook.github.io/react/blog/2015/01/27/react-v0.13.0-beta-1.html

Any function or string might be valid; there's no more specific type we have.
  Like the error says, it seems your calling `getDOMNode` on a component after it has been unmounted. Go through all your `getDOMNode` calls and make sure they're correct, then do the same again but log `this.isMounted()` and figure out which one it is that's called "too late".
 @m4tthumphrey Can you build a simple repro case for this on jsbin or jsfiddle? This does sound like a bug but without a way for me to reproduce it it'll be hard to fix.
 I think this should be fixed in master thanks to #2503
 0.12.1 just had changes to JSX so if you were on 0.12 before you shouldn't see any difference.
 @m4tthumphrey Do you have a repro case for this? Are you sure you're calling getDOMNode at a time that the node is still in the DOM?
 @gaearon Tracking error mesage verbiage as https://github.com/facebook/react/issues/4233.
 With regards to the original issue/topic: It sounds like the issue might be related to react-bootstrap calling update on an unmounted ReactDOMInput component, right?

So next steps on this issue are:
1.  Confirm/repro the bug with the latest React and react-bootstrap, and if the issue is still present, file a bug on react-bootstrap for updating an unmounted component.  @mfunkie @wilkerlucio @chetstone, can you help with this one, since you guys are the ones who see the bug?
2.  On our end, updating an unmounted component should be a noop, meaning that componentDidUpdate probably shouldn't be called (or at the very least, shouldn't throw in ReactDOMInput).  See: https://github.com/facebook/react/blob/b7cd3e7d1de31108594a6698215bfa7bf8619b34/src/browser/ui/dom/components/ReactDOMInput.js#L98  Error boundaries should help.
 @aaronjensen Any chance you can post a simple repro case for us?
 @m4tthumphrey Yes, but it's terribly difficult for me us to debug without a repro case, which your original issue also didn't provide.
 @aaronjensen Thanks for the repro case. I'll try to look into this.

@m4tthumphrey No worries.
 Okay, I tracked down the root cause.

If updates to a parent and child component are both enqueued during a batch and while the parent is updating another update to the child is enqueued, we end up reconciling the child twice which breaks other assumptions and interleaves lifecycle methods incorrectly. In both 0.13.2 and master (if you fix the batchedUpdates reference), this code

``` js
var Parent = React.createClass({
  getChild: function() {
    return this.refs.child;
  },
  render: function() {
    return <Child ref="child" />;
  }
});

var once = false;
var Child = React.createClass({
  getInitialState: function() {
    return {updated: false};
  },
  componentWillUpdate: function() {
    if (!once) {
      once = true;
      this.setState({updated: true});
    }
  },
  componentDidUpdate: function() {
    console.log('child update');
  },
  render: function() {
    console.log('child render');
    return <div />;
  }
});

var parent = React.render(<Parent />, document.getElementById('container'));
var child = parent.getChild();
console.log('--- start of batch');
React.addons.batchedUpdates(function() {
  parent.forceUpdate();
  child.forceUpdate();
});
console.log('-- end of batch');
```

produces the output

```
child render
--- start of batch
child render
child render
child update
child update
-- end of batch
```

where the render and update lines should be interleaved.
 I thought we had a warning for setState in componentWillUpdate but I guess not.
 @m4tthumphrey That message means the same as "Invariant Violation: getDOMNode(): A component must be mounted to have a DOM node." In #4727 I improved the message to make it a bit clearer.

I wouldn't expect this issue to be fixed until we make a specific attempt to fix it at which time you'll see stuff happening on this issue.
 No, it isn't fixed. The test case I posted still has the problem.
 #3762 has a nice repro from @scarletsky; should verify that it gets fixed too.
  Thanks!
  Thanks! As soon as you get that signed we'll merge this in.
 @Peeja If you sign the CLA I can merge this, otherwise I'll just update it myself later today.
 Thanks!
  :+1: For posterity, this is probably the IE8 workaround that back-fires, but haven't actually verified. 

**EDIT:** This is really weird, the IE8 workaround should actually _fix_ this it seems, but doesn't for some reason...
 Highlights the problem without diving into the markup: http://jsfiddle.net/wc95h405/
 The issue here is that we only unset background image, position, repeat, and color and not attachment, clip, origin, or size. Not sure where I came up with that original list. I think the best course of action here is to make sure we unset all the properties that IE8 supports, then take your #1953. These shorthand properties are kind of a pain. :)
  Have you tried this without React? I doubt React is the culprit here.
 ~~If it doesn't fire an event I doubt there's anything React can do.~~ Sniped :)
 Sounds like it fires but doesn't bubble?
  Blame that lib, use es5-shim before sourcing that lib, replace what gets added with a better polyfill. If you have more details we may be able to suggest more targeted solutions. React uses whatever is on `Function.prototype`. As is, there's nothing React will do so closing this out, but we can keep discussing here.
 > replace what gets added with a better polyfill

Yup :)
  There should already be a warning for this in the 0.12 RC and it'll be in 0.12. Please shout if you see differently.
  @sebmarkbage @zpao ~~This is a commonly recurring problem that is very hard to debug, simply setting `window.ReactWasHere = true` and testing whether it is set would save a lot of people a lot of headache. Any objections to this?~~ Should be preferable to just extend `isValidElement` (or w/e) with simple duck-typing that warns if it looks like a ReactElement but isn't... or something like that. It's free and doesn't interfere with intentionally running multiple React instances.
 I think that in the future, this will actually just work. In the meantime we can warn here: https://github.com/facebook/react/blob/master/src/core/ReactElement.js#L230
 > Would it catch all of the issues listed above though? Usually the problem comes up when some component or helper library loads its own version. Will we get to  isValidElement  in this case?

I might be mistaken, but ignoring weird hacks then the only issue with multiple instances of React are when ReactElements from different instances gets mixed up. Depending on which API you feed them to, you're going to see lots of different errors though. So yeah... I think that should take care of all, or most at the very least.

> Besides, does React truly support independent Reacts on page right now? Do they not interfere in any way at all if they aren't mixed (e.g. browser event handling)?

As long as you never stop event propagation or mount them inside each other it should be OK I think (but still not great though).

> I think that in the future, this will actually just work. In the meantime we can warn here: https://github.com/facebook/react/blob/master/src/core/ReactElement.js#L230

Good point.
 We should already be warning in the case that an element from one copy of React is passed to React.render in another:

https://github.com/facebook/react/blob/d75512f211e4240a040eba4c4cb337f539281bc3/src/browser/ui/ReactMount.js#L363

I guess the cases here are when nesting elements from different versions inside each other?
 Reverting #3580 for now (in #3646) as we sort out some problems.
 Fixed by #3332, hopefully.
 The nested links thing is due to invalid HTML and we have a new warning for that in 0.14.
 Please do not report random problems in this issue. File new issues.
 @aphillipo I thought we fixed this in 0.14 (https://github.com/facebook/react/pull/3332); is it not displaying a warning?
 @aphillipo Part of the problem is react-datatable having `react` as a non-peer dependency (cc @pieterv) which can cause NPM to fetch a separate react installation for just that module.
 @Diokuz Can you say what symptom you experienced?

Also, if you are using the prebuilt react.js I would recommend using the prebuilt react-dom.js as well and using `'ReactDOM'` in your webpack config since the secret property is unstable and will change in the next version (hence its name).
  @mikesherov Unless there's a static transformation for the template string then it's intrinsically a bad idea I would say, the hint is in the name "template **string**". That would require run-time parsing _and_ there would be no way to actually translate the tag names to locally defined classes (unless you want to use variables for that too, but then we've left HTML so far behind that we could just use JS instead).
 > Not true. Just because a tagged template doesn't make use of {$} doesn't mean it's undermined.

The point is that this would leave `MyComponent` as an unused variable:

``` javascript
var MyComponent = ...;
return jsx`<MyComponent />`;
```

A linter or minifier would both be useless on this code. Probably also a type system. Perhaps you could do code highlighting but even that would not be very helpful because we would expect highlighters to work well on this code.

Worst case, the minifier just proceeds without error because there's no reason to think that anything inside the template literal referred to anything in the outer scope. You don't even notice it before it hits production.

At best they could start assuming special semantics about the content of template literals. Both of these undermine the meaning of template literals.

> By requiring an additional parser, you're requiring all tooling to be able to except custom parsing, and understand grammar.

Yes. As in my example above, it's better if any incompatible tooling fails early than tries to proceed under the wrong assumptions.

> It also means you can't use jsx with other transpilers easily.

The only thing that is needed is for our parser to be compatible so that we can transpile only the JSX calls and leave the rest untouched so you can pipe it to another parser. We're pretty quick on updating the parser for new syntax that is being proposed for standardization (e.g. async/await etc). There are also third-party forks of other parties like @RReverser 's awesome work on acorn.

If you're expecting to use experimental syntax, then you can still use it with something like Sweet.js which is ideal for mixing various experimental local DSLs.

You can still build one of these JSX template literal systems for yourself. If it becomes popular enough, we might adopt it. So far, it seems that most people prefer to use either JSX, function calls or a third-party language.

I think JSX shows that JS is lacking certain syntactical features and that pure JSON isn't a very readable format for these data structures. Hopefully this will spark some ideas to introduce a new object literal form to JS. Even if that is not based on XML-like syntax.

I'll close out this issue because there's nothing new here so there's nothing actionable. Feel free to keep discussion going and we'll reopen if some new information arrives.
 @mikesherov, familiarity is also an issue to be overcome.

I just want to make it clear that nothing would make me happier than a standardized solution to this issue. I think custom DSLs and even custom high-level libraries should be avoided if possible.

Not just because of the tooling issue but because the issue of having one more thing to learn.

However, it says a lot that many smart people tend to think that the familiarity and terseness of JSX is worth the downside of complicating the tooling story and increasing the language surface area.

Some people are on the opposite side and don't think the tooling/compatibility is an issue. They just don't like the look of it.

That indicates that the issue remains. Perhaps, the solution is better editors that allow you to customize what your code looks like? Then the source code representation doesn't matter. We can all use our own syntax preference. Unfortunately, IDE tooling isn't there yet. At least not in terms of popularity.
 > In this case, it is Possible, just seemingly not desired.

Possible, in the sense, that we can't **possibly** deprecate it without an uprising. :)

> I just don't think appeal to unnamed authority is a good argument here.

I didn't mean that as an authority but as the populous. I.e. the majority sentiment.

> The solution for me would be allow the user to define the default template string parser and define the boundary markers for expressions. 

Macros.
 > Appeal to majority opinion is no better than appeal to authority. Also, I'd dispute that a majority think its preferable over language unification.

I should've clarified, that I meant within the React community. I'm sure the larger JS community would prefer unification, but they don't have to bare the cost.

Even within the React community, it's those with large code bases that suffer. Not those with a few components or higher level abstractions.

The apparent cost of switching to a less familiar/terse syntax is higher than the pain they're feeling from divergent tooling.

>  I would say that these smart people may not have thought about using template strings fully

We've explained these considerations in earlier posts, in person at various companies using React, and internally at Facebook. So I don't think these people are unfamiliar with the issues. It's just that they're not hurt by it personally.

> I'd gladly write the migration tools along with an army of folks who would help make the switch easy for devs.

We already have that tool. It's the transpiler itself. :) The upgrade path is not an issue. We break things all the time and make sure to provide an upgrade path.

The problem is that the people that would bare the cost of working with a subjectively worse syntax doesn't currently hurt from it. By trying to deprecate it, we would only make their lives worse.
 @jussi-kalliokoski You mention `React.createElement()` as being too much boiler-plate, that's why `React.createFactory` exists, explicitly for non-JSX users. Your syntax is also reponsible for significant amounts of unnecessary allocations. As of 0.12 ReactElements are plain objects, I don't think you can provide manually created ones just yet, but that's the intention IIRC.
  I personally made sure that was changed in MooTools 1.3 back in the day. You're going to have a bad time with anything before that. Sorry. Upgrade. :/
 This is the same as #2404 where I suggested using a better polyfill.
 Chrome extensions can execute code in an isolated DOM environment using content scripts. That way you can execute in an environment completely isolated from the web page's realm. You can still touch the DOM, just not scripts on the page. You'd have to interact with them through message passing, if you need to.
  If you want a couple extra points, you can have a few other missing semicolons. `grunt jshint:project` will tell you :)

If you don't want to, that's fine and this is ready to go.
 Thanks!
  tutorial4.js isn't meant to work on its own before getting to tutorial5.js. It might be worth making that clearer.
 Ah sorry, I totally missed that part of your comment. That seems reasonable to me. Feel free to have a go at it.
 #2968 merged. 
  We need a way to test the output of a single level React component without resolving it all the way down to the bottom layer (whatever that is).

I'm thinking something like this:

``` javascript
var shallowRenderer = ReactTestUtils.createRenderer();
shallowRenderer.render(<SomeComponent />);
shallowRenderer.attachRef('myRefName', someMock);

var result = shallowRenderer.getRenderOutput();
expect(result.type).toBe('div');
expect(result.props.children).toEqual([
  <span className="child1" />,
  <span className="child2" />
]);

shallowRenderer.render(<SomeComponent aNew="Prop" />);

var updatedResult = shallowRenderer.getRenderOutput();
expect(updatedResult.type).toBe('a');

updatedResult.props.onClick(mockEvent);

var updatedResultCausedByClick = shallowRenderer.getRenderOutput();
expect(updatedResult.props.className).toBe('was-clicked');

var instance = shallowRenderer.getMountedInstance();
instance.customFunction();

var updatedResultCausedByCustomFunction = shallowRenderer.getRenderOutput();
expect(updatedResultCausedByCustomFunction.props.className).toBe('custom');
```

Basically, this fix needs to go through the entire life-cycle of ReactCompositeComponent. It just needs to bail out whenever it would've continued rendering.
 Reopened so that we can track the remaining features (refs etc.)
 Weird, I thought GitHub only closed issues if you used language like "fixes #NNNN", not if you simply mentioned the issue at all. Sorry about that.
 The PR text included "WIP to fix #2393."
 Is the rest (refs support) blocked by #1373 or can more work be done now? @sebmarkbage
 @gaearon, that's supposed to work. Can you post a minimal repro?
 The idea was to make the `React.Children.forEach/map` helpers ignore null which could help with that. Perhaps we could have `React.Children(element.props.children)` return an iterable which traverses nested arrays and ignores null.
 @sebmarkbage Really? Allowing nulls was a change intentionally introduced a long time ago. In #3650 I have an implementation of toArray.
 Allowing empty children (null, undefined, boolean) was a controversial topic, where we eventually landed on null/boolean/undefined being passed through. That way you could explicitly treat an empty slot as something special. This landed very early on before we really started seeing pattern developing.

However, IMO, we've seen that this leads to inconsistent implementations where null slots will break and is not possible to use. It is unclear whether a set of children allows nullable slots, and if they do, it is unclear what that means. For example, in a grid layout component, does an empty slot mean that  there should be an empty column in the grid, or that it should be skipped?

Therefore, a lot of our components end up with explicit null checks. Meaning boilerplate, and inconsistent behavior when they're forgotten. Therefore, I think the default should be to filter out nulls which is consistent with the behavior of the built-ins components.

It is still possible to get access to the raw data if you have a different type of children in mind where empty slots is meaningful.
 Hi David, the `scry` and `find` functions are meant to be used with the output of `renderIntoDocument`, not shallow rendering. React doesn't currently provide a helper that will traverse `ReactElement` trees for you. Your options for now are to describe the structure of the tree explicitly as in lines 4-5 of your example, or write your own helper module to find descendants you care about.

 `getMountedInstance()` hasn't been implemented yet. Refer to the [docs section on test utilities](https://facebook.github.io/react/docs/test-utils.html) for what's actually in React.
 New issue please.
 @davidgilbertson Super late reply, but "scry" is a fancy word for "find". I'm not sure why we don't just use "find". Maybe to avoid confusion between the plural and singular forms, whose names would otherwise differ only by one "s".
 scry is because of legacy internal FB APIs. No reason.
  `React.renderComponentToStaticMarkup()`, but it obviously won't be dynamic then. If bootstrap messes with the DOM, then you can't have React manage it also.
 Nothing actionable here. You have the option to render to a string if you want (and you could easily do that on every render). That would fit in with the other jquery stuff that bootstrap depends on. You could also create your own hooks to update on certain events or use something like react bootstrap as mentioned.
 I also wrote an explanation of how to do this here:

http://stackoverflow.com/questions/20033522/rendering-a-react-component-inside-a-bootstrap-popover
  If you want to be able to apply CSS name minification down the line then you cannot do this. If someone writes a transformation that implements this, then it might very well be added, but I doubt any of the devs would take their own time to do this.
 React picks up ES6 features via [jstransform](https://github.com/facebook/jstransform). This isn't JSX specific so this falls into the category of general JS transforms that we would need to pick up from there. As a result, I'm going to close this out here but I think this is a good candidate for a request over in the jstranform repo. Can you file an issue over there?
  This has nothing to do with React. You're setting an attribute on a DOM node that doesn't have a corresponding property. You can safely get the attribute value by using `getAttribute` (`evt.target.getAttribute('value')`).

Or more appropriately for storing data on random DOM nodes, use the data-\* attributes.

`<div data-value="foo" />` and then access it with `evt.target.dataset.value`
  Thank you for your contribution, but these doesn't really make sense to me (our tabs are 2 spaces wide) and the `webdriver` one is definitely incorrect.

Closing, cc @zpao 
 @TJZenkai Check the changes tab above. Here's an example of where the code is intended by 4 spaces instead of 2 that is used elsewhere in the code-base.

```
       var map = inlineSourceMap( 
+          output.sourceMap, 
+          input, 
+          options.sourceFilename
       ); 
```
  Related #2271 (my second paragraph)
 cc @yungsters 
 @sebmarkbage @spicyj cool taking this in 0.12? it's small...
 I think it can wait for 0.13. The fix has received no testing and this has been here since forever, so there doesn't seem to be an imminent need.
  I _think_ this is quite common in the codebase and unless it's part of the API I feel like there's little to no incentive here. If it involves objects I imagine there could be a GC/perf win, but here it's just `undefined` vs `false`.

However, changing it to `id in nullComponent` could make sense.

@zpao ?
  Thanks!
  Can you please prepare a fiddle that demonstrates the issue and add steps to reproduce it? Unfortunately I can‚Äôt figure out what to do with the fiddle in https://github.com/facebook/react/issues/2380#issuecomment-59807316. Thanks!
 Whoops, never mind, I reproduced it in 0.14.
This appears fixed in v15 RC2: http://jsbin.com/getiwetolo/1/edit

I‚Äôm closing but please let me know if I missed something.
  When it's ready.

Please don't use issues for this. Mailing lists, stackoverflow, and direct communication are more appropriate venues.
  @spicyj Brought up a good point yesterday as well. `DOMChildrenOperations` `'INSERT_MARKUP'` [(source)](https://github.com/facebook/react/blob/master/src/browser/ui/dom/DOMChildrenOperations.js#L143) is affected as well. But we probably don't want to require `ReactMount` from there... so we should probably return the rendered nodes from `DOMChildrenOperations.processUpdates` and `ReactMount.getID` them afterwards.

Perhaps @zpao @spicyj has some thoughts on this.

~~PS. Ultimately this will probably have to change when web workers arrive as `DOMChildrenOperations` is supposed to be async I believe? But then it should simply be a matter of using a callback or requiring `ReactMount` or similar anyway I would think.~~
 @ThomasCrvsr I think it looks good! Can you write a test that verifies that it works and doesn't regress? (Mock `ReactMount.findComponentRoot` and assert the number of times called should work I think...)

@sebmarkbage Do you have an issues with this PR?
 Stale. I'm going to close this out. We can revisit but it is likely this path will have/get more drastic changes.
  This lets you use any kind of iterable as a container of react child elements. It also preserves keys when possible if the iterable is keyed.
- Use an ES6 Map or Set to hold children.
- Use an Immutable-js collection to hold children.
- Use a function\* which yields children.

Concretely, this removes the necessary conversion to JS objects if you're mapping over Immutable-js collections to get children, i.e.:

```
<div>
  {myImmutable.map(val => <span>{val}</span>).toJS()
</div>
```

Now we can remove the `toJS()` and the intermediate allocation along with it.
 cc @sebmarkbage @zpao @spicyj 
 Testing to ensure that map keys and implicit index keys work as intended would be great IMHO... a while since I last looked at traverseAllChildren so my memory is fuzzy, at first glance it isn't obvious to me that the final key is actually computed correctly for iterables.
 @sebmarkbage Does "drop support for Objects" include Maps, or was it just Objects because those are a bad idea?
 I just updated this diff to fix a problem (that I added a test for).

Strings are iterable, so the order of conditionals was off in my original diff, it would have iterated over the characters in a string. - I needed to check for iterable only after every other specific case has failed, but before doing object key iteration.

Also added in suggestions from @syranide 
 @syranide Objects should be replaced by Maps.
 Actually, this also needs to work with the key validation. Can you add something here?

https://github.com/facebook/react/blob/5d3b12bb3bd6a092cf00ede07b8255a8399c2e58/src/core/ReactElementValidator.js#L166
 Updated to include ReactElementValidator
 A test for the validator would be nice: https://github.com/facebook/react/blob/631b6a097c4039d945d6c62e7e5a276b9a47633c/src/core/__tests__/ReactElement-test.js#L180
 will do
 Moar tests
 @worklez Feel free to file issues or PRs for those.
  This is post-0.12 changes. It drops the legacy factory from around the class.
 :shipit: 
  We should deprecate isValidClass. In 0.13, any function that returns an object with a render method will be a valid class.

We probably don't want to assume that there is a valid prototype because that doesn't allow the module pattern to be used:

``` javascript
function MyComponent(props) {
  return {
    render: function() {
      return <div />;
    }
  };
}
```

It's really difficult to validate these without invoking them. This is where a static type system shines. For a dynamic check, isValidClass would turn into: `typeof fn === 'function'` which doesn't need its own function.

Generally, you'll want to validate something extra about the class anyway. E.g. will it have a `getDOMNode` method on it? Does it render into a table cell?
 So you know we put out an RC already, right? We really should have decided this _before_ that happened. But sure, let's deprecate it. Want to put up that PR?
 ![Thanks, Captain Hindsights](http://i3.ytimg.com/vi/RpwGu8yNTNI/hqdefault.jpg)

I didn't see it coming until I started working on it. We can also deprecate it in 0.13 but that'd change the semantics to just be `=== 'function'`.

I'll put up a PR and we can decide later.
  lgtm, thanks!
  Documentation will get up dated when #2373 gets synced out. So I'm going to call this closed. Thanks for taking this on!
  Thanks for the consideration, but I think we're going to leave it. While it might not be the best example, it helps convey how to do normal JS string concats in JSX.
  This was fixed in #2359; we just haven't rebuilt the docs from source yet.
 Will do that in a bit.
  ReactMount caches all children for each parent it visits, this avoids worst-case exponential cost. However, use of ReactDOMIDOperations for updates forces ReactMount to populate the cache with the previous children.

If a newly rendered node needs to be found, then "the children of the parent" of "the newly rendered root" has to be re-traversed as it does not exist in the node cache. Since it's guaranteed that all the siblings of newly rendered roots are cached and that we have a reference to the node, it's trivial to manually add it to the node cache which should avoid "double-traversals" entirely.
 I am not sure I understand what you meant originally, but I think #4983 fixes this. In any event, this is not really a "good first bug".
 @spicyj Scanning #4983 quickly it _seems_ like it does yes, anyway the basic issue is/was:

```
<div>
  <u />
  <b key={random} ref={} />
</div>
```

Every time it re-renders and the DOM node for `b` is looked up, it would re-cache all the nodes of `div` because `b` could not be found in `nodecache`.
 Oh, I see. I think this is slightly separate then. I'll probably get to fixing this soon though.
 @spicyj FYI, IIRC this is not currently a very big issue as `childIndex` is used in some places to reach the actual node inside the parent node instead (rather than the actual node directly), but it probably will be when React gets around to dropping the wrapping spans and thus `childIndex` I would assume.
 Yeah I got rid of all this! It should be a lot easier to reason about now.
  @krawaller "it's generally preferable", if you're dealing with fixed keys then setting to undefined/null should be preferable (to avoid creating new hidden classes), but if you're dealing with dynamic indices then deleting probably makes most sense. It was just intended as a reminder for anyone stumbling upon it.
 Nagging @petehunt because we wanna pull this in and deprecate `update` in favour of immutable-js
 Prefer using immutable.js. We don't want to turn this into a crazy DSL.
 It already is: http://facebook.github.io/react/blog/#two-packages-react-and-react-dom
https://www.npmjs.com/package/react-addons-update
 @dustingetz Would you want to maintain it?
 It is used internally (unfortunately). And yes, while it's available standalone(ish, it still depends on react), it should be split off in a real standalone project. Give me a good name and I'll do it sometime soon. I kinda want to call it `ognom`‚Ä¶
 @peteruithoven It currently only lives here, where you found it. The npm module (all of the react-addons- modules in fact) just require deeply into react for the time being until they can become standalone / get removed.
 You might be interested in https://github.com/kolodny/immutability-helper that lets you define custom operations by name.
 @krawaller updated the pull request.
  Can you just combine this with #2360?
  Thanks! And sorry for the _massive_ delay :(
  Can you do this in the same commit you already have in #2357?
  This seems like a good change. However we actually have this content duplicated into a more permanent place in our docs - https://github.com/facebook/react/edit/master/docs/docs/thinking-in-react.md. Since this change is small, lets update both places.
 Thanks!
  ![community round-up 23 react](https://cloud.githubusercontent.com/assets/197597/4652638/b21d264c-54a6-11e4-9033-aac273be97bb.png)
  We'll need to set up a redirect from the old URL if we want to rename the post. Can't remember if we've done that before.
 Oh sorry, I totally missed this when I made #2359. I even responded to your comment on the commit‚Ä¶ I'm not doing computers well today.

I appreciate you doing this and bringing it to our attention. I hope you don't mine but I'm just going to merge mine since it does the redirect already.
  :+1: How sneaky, the fix _seems_ sound, but it shouldn't actually be needed. Something else must be the root problem here. When the new component renders it should automatically get deregistered and this shouldn't be a problem (it doesn't happen when I simplify the repro).
 @cody That's awesome... but I still can't wrap my head around how the null ID isn't deregistered when rendering OtherView. Something is :fish:y.
 Ooooooh, now I see. What's happening is that the implementation is flawed. Only `ReactCompositeComponent` takes care of registering and deregistering null IDs (only on mount+update), whereas when a `ReactDOMComponent` takes its place it obviously doesn't happen.

@chenglou Why was it done this way instead of having `ReactEmptyComponent` doing the registering and deregistering at mount and unmount? Every instance of `ReactCompositeComponent` does it now. ~~Also, shouldn't `ReactEmptyComponent` belong in `dom/` as it's really a flaw in our DOM implementation at the moment and not at all related to core, but perhaps the current internals aren't really up for it.~~
 Minimal repro http://jsfiddle.net/9yvs1zu5/2/ or http://jsfiddle.net/9yvs1zu5/3/ distilled from @cody's
 It's been a while so I don't recall. Maybe I just missed this completely. Sorry about that
 Hey ‚Äì I ended up including this fix in a larger PR (#2503) so this didn't make it in directly. This was a great catch though; we'd love to have you contribute more in the future.
  As far as I understand `update` it looks great. AFAIK the intention was to imitate the MongoDB interface which does support `inc`, but I'm not sure if it's really necessary in React as you can just add to the value directly (obviously a bit more verbose though) and `update` is intended to just be a really simple helper.

That being said, big thanks for contributing, I'd love to find something of significance that you could attack... :)
 @totty90 If your goal is to be compatible with MongoDB, I would recommend that you fork/reimplement this helper for that specific goal. That's not to say it shouldn't be added to this React addon, but AFAIK MongoDB is just an inspiration for this helper, not the goal (as far as I'm aware, it's provided just to kickstart people who are new to React).
 @totty90 `React.addons.*` is not part of React, it's just shipped as part of the React bundle for now. The plan is to move them out into separate NPM modules when everything is figured out, [wiki link](https://github.com/facebook/react/wiki/Projects#ship-reactaddons-differently). `React.addons.update` has no React core dependencies.
 @petehunt
 update is deprecated in favor of immutable.js

We don't want to turn this into a DSL.
 You might be interested in https://github.com/kolodny/immutability-helper that lets you define custom operations by name.
 @ThomasCrvsr updated the pull request.
  I thought I'd bring this up before it's set in stone. Since `React.createElement` is intended mostly as a non-user feature as I understand it, wouldn't it make sense to take the opportunity to also change its signature to `React.createElement(type, children)` to avoid varargs for a potential perf boost.

Non-scientific test: http://jsperf.com/varargs/2

PS. Hmm, I guess we already support this... by simply providing only an array to children. But it seems that just touching `arguments` is a significant slow-down (relatively, not necessarily in practice).

cc @sebmarkbage 
 createElement isn't only an internal API, we use arrays vs. varargs to distinguish child keys, and I believe these have been benchmarked to be comparable (or even faster with varargs?) so I'm going to close this.
  There are bunch of things we need to document/update for 0.12
- [x] new terminology (elements, nodes) (#2399)
- [x] rewrite JSX In depth (it's a bit tough to update piecemeal)
- [x] factory usage + best practices
- [x] `@jsx` changes
- [x] fix documentation re: `@jsx` changes
- [x] new/fixed dom attributes (#2399)
- [x] docs license (#2399)
- [x] new methods
- [ ] old methods
- [x] authors & acknowledgements (#2399)
- [ ] addons update

(probably more, mention them)
 Deprecate isValidClass #2374
 Hey we shipped! But there are still a couple things to get into the docs from that checklist.
 We're going to ship 0.13 so let's call this one done.
  Order _does still_ matter unless you also force z-index or guarantee that there is never any overlap. I imagine this is best solved with a helper function that retains ordering between a previous and next array rather than add this to core, where we have to consider issues when going from map to set to map. It seems like such an edge case of an edge case, the cost of delegating to a helper function shouldn't be an issue (and probably what React has to do internally anyway).
 FWIW, ES6 Set is actually ordered. It's ordered by insertion order. It also doesn't have the same problem as Objects where numeric keys mess with the ordering.

```
> s = new Set()
Set {}
> s.add(1)
Set {1}
> s.add(2)
Set {1, 2}
> s.add(-1)
Set {1, 2, -1}
> s.add(-3)
Set {1, 2, -1, -3}
> for (var x of s.values()){console.log(x)}
1
2
-1
-3
> s.delete(2)
true
> s.add(2)
Set {1, -1, -3, 2}
> for (var x of s.values()){console.log(x)}
1
-1
-3
2
```

Still a pretty interesting suggestion!
 I'm curious what your helper function looks like. Care to share a gist?
 I'm not sure doing this is going to win you anything over the stock reconciliation pass. Have you tried this and actually measured significant performance wins in a real application?
 If you don't care about the order and all children have keys, it might be more straight forward (and make `render` more idempotent) if you sorted children by key first. Then it would be very predictable where inserts and removes would occur.
  If we do this, we should do it for `componentWillUnmount` too.

~~I think this makes sense, if we're going to rely on internal implementation details we should rely on the best implementation details available, reading from the DOM is just dirty (and slow). In the future this will use `Map` (unless we can get rid of it entirely), the DOM node is irrelevant (**EDIT:** but that's not actually true... hmm), we just want something stringy that is unique to each component.~~

@zpao @sebmarkbage I added `review-needed`, slap me if I'm doing it wrong if you prefer to handle it yourselves. :)
 @ThomasCrvsr Yeah I'd say so, getting the same ID from two different places is just asking for trouble :)
 It's used in `_handleChange` too.
 Hmm, no you can't because it's a DOM node. I guess `_handleChange` will just have to remain as-is if we go with this.

Argh, the correct solution is probably to leave it as it was, but only set/use `instancesByReactID` if it's a radio.
 @ThomasCrvsr for `_handleChange` yes, but not `componentDidMount` and `componentWillUnmount` which are the ones we actually care about, as they currently apply to all variations of input type.
 After some more thought...

The radio workaround is pretty much a big hack, are we OK with simply assuming that `instance._rootNodeID === getID(node)` for now? Or better to just do it properly and only use `instancesByReactID` when `type="radio"`? I'm tempted to just throw it all out and not query the DOM nodes at all, simply storing instances by name and iterating that list.

Devs, what's your take?
 I was planning on refactoring the internals so that they're not exposed on composite component classes. This would not work in the future anyway. Will close out for now. This perf improvement is noted though.
  The preferred approach is to use `var ExampleApplication = React.createFactory(...);` and then `ExampleApplication(...)` I believe, `React.createElement` is not generally intended for the end-user.
 Oh, I just saw #2315... @zpao shouldn't they use `React.createFactory` instead?
 Oh yea, I suppose they should. I was thinking about the general case of just putting in what the JSX got transformed to, but showing the normal approach is a good idea. Let's do that.

Also, nits: let's use //-style comments, and not put them inside the function call. Make the comment when calling createFactory.
 I really appreciate this. I may end up tweaking this a little bit as I do a more general update to the examples.
 Thanks! :+1: 
  React binds functions defined on the component automatically:

http://facebook.github.io/react/blog/2013/07/02/react-v0-4-autobind-by-default.html

We realize this can be confusing to newcomers and might make it more explicit with arrow functions in the future, not sure yet.
  `cloneWithProps` discards `ref` regardless (it's necessary, but not intentional). However, I guess `ReactTransitionGroup` could really just wrap it in an internal identity component and ref that instead, `<Identity ref="...">{child}</Identity>`.
 @duro That unfortunately won't work in this case because ReactTransitionGroup needs a ref to the element too (so you can't just keep the old one). @syranide's suggestion of creating a wrapper should work though.
 I believe this still is broken (using cloneElement now instead of cloneWithProps).
  (Closing in favor of #2127.)
  React JSX(Transformer) probably never will, but other JSX implementations certainly can.
 We're not going to do this. You are free to write your own transform if you'd like.
  Sounds like you figured this one out :)
  @fisherwebdev How would you feel about adding a line below the jest intro mentioning that there are other things you may need to specify in your package.json and linking to jest docs? I don't think we should get into the exact specifics.
 Hey, can we followup in an issue in the flux repo? I don't want us editing the flux documentation here since the flux copy is getting updates.
  1. Use backspace/delete/paste/cut in the input field
2. Undo (notice the entire document revert)
3. Redo or type something
4. :boom: React will throw an invariant and stop to function as the DOM has mutated

Normally, when the DOM updates IE8 will clear the undo history of all inputs. However that does not happen under these circumstances for some reason. I would assume this is because `onChange` listens to many different events and some of them are broken like this.

```
var App = React.createClass({
  getInitialState: function() {
    return {changes: 0};
  },
  handleChange: function(e) {
    this.setState({changes: this.state.changes + 1});
  },
  render: function() {
    return (
      <div>
        <input onChange={this.handleChange} defaultValue="text" />
        {this.state.changes ? <div>{this.state.changes}</div> : null}
      </div>
    );
  }
});

React.renderComponent(<App />, document.body);
```

You can test it yourself here: https://dev.cetrez.com/jsx/2/index12.html

cc @spicyj
  Eh, sure. I don't know that it's really adding much without any context, but it doesn't hurt.
  While most browsers tend to parse data attributes starting with a number, it is actually not valid according to W3. The most likely reason being that `{100Bucks: ''}` is not valid, but `{bucks100: ''}` is (and same is obviously true for variables).

See:
http://www.w3.org/html/wg/drafts/html/master/dom.html#embedding-custom-non-visible-data-with-the-data-*-attributes
http://www.w3.org/TR/xml/#NT-Name

Closing, reopen if you disagree.
 It's valid. We forced some stricter guidelines than the spec does because we thought the spec was poor and we wanted people to have better practices. There may have been some issues with browser support earlier but I can't recall. Anyway, the choice hasn't been a real problem before. But we're more popular now and should make spec-compatible things work unless we have something better. Hopefully we'll make `dataSet` as a prop work instead someday soonish.
 One place where I think we'll keep deviating is the allowance of upper case data attrs in html. as noted in the link they get lowercased by parsing rules anyway so they're technically fine to use, but it's confusing behavior going from JS<-->DOM so we'll be noisy there.
 > That being said,  data-100  is a valid XML attribute and contains at least one character after the hyphen. It also does not contain uppercase ASCII letters and is in no namespace.

@Prinzhorn You are indeed correct. I don't think there's any reason in particular not to allow it so we probably should change it then I would think.

> but it's confusing behavior going from JS<-->DOM so we'll be noisy there.

@zpao But that's how the HTML5 spec defines `dataset` so it's not really "our problem"? :) (Or did the PR to change it to use "hyphenation" get dropped?)
 No update.
  Can you construct a complete simplified example? I don't think this should be happening (since react/addons just requires the same thing react does and then adds a couple more properties).
  Per discussion in https://github.com/facebook/react/pull/2352, we don‚Äôt plan to add new features in `update()`. Sorry!
  https://github.com/facebook/react/pull/2311#issuecomment-58743271 is relevant here as well, you're not supposed to update anything that's not inside body via React.
 Correct ‚Äì we don't support updating anything outside of body; see Pete's comment here:

https://groups.google.com/d/msg/reactjs/4jI5xe7TXzQ/3sjSBbpDpEwJ
  You're using the same `ref` name multiple times and overwriting the same spot. You can instead get a reference to the erroring image from the event object:

http://jsfiddle.net/1zebf4cf/2/

Note though that it's not generally safe to modify attributes in the DOM directly, especially if you plan to update them with React later. It would be better to store in JS info about each image including whether it has errored, then update the src property just by rerendering based on the new data.

(This is also the wrong forum for help requests like this ‚Äì in the future, the mailing list, IRC channel, or Stack Overflow would be more appropriate.)
  You're not allowed to manually mutate nodes created by React. When you're mounting into the div, the span and text is managed by React but will be blown away when you mount Component2 (why would you do that?).

The error you see is because React sees that the existing markup has `data-reactid` which usually indicates that it is server-rendered and should be reused. But yeah, the "is server-rendered" check could be smarter and renderComponent could throw an invariant if any React children are not roots and not server-rendered.
 @zpao Good first bug?
 This is a dupe of #2045, I think.
  > In Web Components  <content>  is used as an intertion point.

```
<div>{this.props.children}</div>
```

But I'm not really sure what you are actually asking for, your last example is done using the above "insertion point" as well. If you want _multiple_ insertion points you either have to use props or filter `this.props.children` and pick out the ones you want (either by type or some prop).
  There's at least one that doesn't use JSX.
 PR was merged, closing for the milestone.
  There are plans to disable. Right now the detection is a bit tricky and nobody is working on it. see #953
  Can we get a repro? If this is indeed a flaw in React then this should be the symptom, not the cause.
 @lrowe You should be using `dangerouslySetInnerHTML` for setting the content of `style`, additionally, you really _really_ shouldn't update the content after it has been set. Updating `title` is plain just not supported anymore because browsers are really weird when it comes to updating the tags you normally put in `head`.
 @lrowe React previously had "full-page" support with considerable amounts of workarounds implemented, but they dropped it because it just wasn't very reliable/useful, crashes, flickering, etc. It's not up to me, but I don't think they want to revisit that. cc @zpao 
 Hey @lrowe, I‚Äôm really sorry we left you in the cold here.

IE8 issues have been a low priority for the past few years as they are quite unique, take a lot of time and effort to fix correctly, and it can be hard avoid regressions or bugs in other browsers later. In this particular case, the tags themselves are not very commonly used in React apps, so that might have contributed to the lack of an in-depth review.

React is officially dropping support for IE8 in v15, so I don‚Äôt think we‚Äôll dedicate time to merging, testing, and supporting this. If this fix is vital to your project, you can consider creating custom `SafeTitle` and `SafeStyle` components that implement this behavior manually for IE8 and have `shouldComponentUpdate` return `false` in it. This is not ideal but that‚Äôs the way things are right now.

Sorry for the trouble, and we hope to see you contributing to React again!
  Looks like `list` should be `MUST_USE_ATTRIBUTE` [in HTMLDOMPropertyConfig.js](https://github.com/facebook/react/blob/18209a111208c5d1c3f68f578cdb62804b03b960/src/browser/ui/dom/HTMLDOMPropertyConfig.js#L109).
 To clarify, `id=` is updated, `list=` is not. and yup, using the [MDN example](https://mdn.mozillademos.org/en-US/docs/Web/HTML/Element/datalist$samples/Examples?revision=667035), `$0.setAttribute('list', 'str')` works, `$0.list='str'` doesn't.

Interested in fixing it @tmcw?
 #2310 is in, thanks for the quick fix :)
  We're making efforts to move development of React to happen on GitHub first, with Facebook being simply another consumer. Historically we've mostly done it the opposite way. PRs needed to be pulled into FB to ensure we didn't break products, etc. The result of this is that we've moved slow and occasionally just dumped large changesets without any context. And syncing commits out, while it worked, has been awkward and has resulted in some mistakes. (_something about 2 way data flow being dangerous_)

There are a number of things we need to do, both internally and externally. It won't happen overnight. We can use this issue to track the things we need to do externally.

---
- [ ] Make lint work consistently (it's noisy and unusable right now).
- [ ] Faster everything (the basic build/test process is too slow, jest helps)
- [ ] Resolve any differences between internal and external code (#1998, React.version, commented-out warnings)
 Commendable :+1:
 We've been GitHub-first for a few months now.

@zpao Are there more things here or can we close this issue?
 There are still a few things that can be improved in the process (perhaps "go github only"), but otherwise we're good to go.
  ReactLink supports a sort of adhoc two-way data binding. We've found it to be a distraction rather than helpful so we don't plan on adding it to the core outside of addons anyway.

We should take the support out of controlled components and make wrappers that can be used instead of the controlled components, and put the wrappers in addons. This provides backwards compatibility without having the legacy remain in core.
 :+1: 
 This should be rather trivial, should I draft a PR?
 Yo @petehunt this was your jam. Any opinions?
 @saulshanabrook 

The two following are equivalent, it's just sugar really.
`<input valueLink={vl} />`
`<input value={vl.value} onChange={vl.requestChange} />`

https://github.com/facebook/react/blob/master/src/addons/link/LinkedStateMixin.js
https://github.com/facebook/react/blob/master/src/addons/link/ReactLink.js
 @tobia Like I mention in #3591, you can wrap an `input` in your own component of your own which can provide the same functionality (and more). If/when it's dropped React would certainly provide such wrappers out-of-the-box in addons, but it wouldn't really be special or anything you can't already do yourself.
  It's not "scary", but "scry", which is a fantasy word that means to search for something:

http://en.wikipedia.org/wiki/Scrying
 @spicyj But how does that differ from `findRenderedDOMComponentsWithClass`, why not name it something actually descriptive? (but perhaps it's common for testing?)
 Historically we have had `find` and `scry` methods on our DOM helpers where `find` returns a single result, `scry` returns the set.
  I only very briefly examined your problem, but generally the problem is logic being put in the children rather than a parent that would be better suited for that responsibility. If the root component has the global loading indicator, then it should probably be the one to have the logic and simply forward the data to the children (this seems to be the general recommendation, don't view components as isolated black boxes, move logic/data up the hierarchy).

Perhaps that makes no sense at all in your context, but I recommend taking this up in the React discussion group or coming to IRC. Closing to keep GitHub issues focused on development.
  That looks like a weird fix, what's the actual issue?
 If you could, I would like to have a repro so that I can understand how the problem surfaces, it's not clear to me from looking at the fix.
 But what's the actual issue? Some value is causing a problem but what is it? Can you make a reduced test case?
 @genxstylez If you replace all instances of `e.target.text` with `e.target.innerHTML`, the demo appears to work fine for me.  Using Safari Version 8.0.7 (10600.7.12).

https://jsfiddle.net/qe3avvnt/
 @genxstylez I think that's unrelated to the reported issue, which is specifically about the `updates` addon. Using `e.target.textContent` should also work (I don't think `.text` is standard)

There have been no other reports and no test cases of the original issue, so closing out.
  Hey, really sorry for letting this sit here. We got caught up in the push for 0.12 and dropped the ball. This file has been changed a bit since you wrote this, so it'll need to be rebased but otherwise let's do it.
  I imagine this is because the elements are removed and then new ones added, the browser viewport temporarily becomes smaller which stops scrolling. A solution should be to force the minimum height of the body/outer element before update and then unset the minimum height.
 @cody Aha, yeah I would expect it to be a bug with webkit unless the issue isn't present when doing the same thing with just plain JS. It _could_ be that React is doing something that stops that scrolling that could be fixed. If you have the time to do a plain JS repro that would be awesome.
 @cody Ah awesome, thank you. I wonder if there's a way around it somehow, I asked Google quickly but couldn't find anything helpful.
  @gabor It should use `Map` eventually and if the order of keys in objects isn't maintained, then React won't function at all, so there's that :)
 I don't see how we could have arrays of key/value pairs, as that would exclude the possibility of having (non-keyed) arrays.
 > hmm, right now you support having a non-keyed-array, or an object-with-keys, right?

Yes, iterables are coming though.

> i guess the code simply checks if it is an array or not, and behave accordingly. the checking could simply see, if the array's items are pairs or not.

That would be very ambigious, `[['Hi', <NameComp />], ...]` does not necessarily mean that they should be treated as pairs.

> also, could you please respond to the first part of my response? is it true, that react is internally relying on the ordering of Objects? are there any plans to fix this problem?

It's intentional (for performance reasons) and as React is used all over Facebook and Instagram it's safe to say that it's not an issue in practice. React will move to use `Map` and `Set` internally in the future.
  React doesn't mutate the native object, just our own synthetic event. As mentioned we do poll these objects to mitigate GC and you can hold on to one by calling persist.
  I'm having enough trouble convincing myself that your fix is correct that I don't think I want to take this. If we ever support rAF batching in core, perhaps we will want a fix for this. I'm curious though ‚Äì what problems does rAF batching solve for you? Does React.addons.batchedUpdates fix the same problems?
 The idea sounds good but the code is still tricky, especially for the re-entry case.

That makes sense. Have you looked at all at throttling the scroll events instead? That's the typical way to deal with this. You could do something like this if you still want to do it on rAF boundaries:

```
function throttleAF(fn) {
  var interval = null;

  function onFrame() {
    interval = null;
    fn();
  }

  return function throttled() {
    if (interval == null) {
      interval = requestAnimationFrame(onFrame);
    }
  };
}

// ...

this.throttledScroll = throttleAF(this.handleScroll)
onScroll={this.throttledScroll}
```

Basically, rAF batching introduces complexity and makes things harder to reason about (like necessitating your fix here) so we've so far tried to avoid using it.
 No problem. Let me know how it goes!
  Yeah, a CSSTransitionGroup turns into a `<span>` by default; see http://facebook.github.io/react/docs/animation.html#rendering-a-different-component. I expect this will work if you use a `<g>` instead, as so:

```
<CSSTransitionGroup component='g'>
```

Sorry for the slow response.
  #2241 should solve this case as well.
 @stephenjudkins Definitely, more tests are better :)

Yep, let's keep this open for now until that PR is approved, just in-case .
 @stephenjudkins My other PR is accepted so I poached your test-case as we agreed, sorry we couldn't take this PR but thanks for contributing anyway! :)
 :+1: 
  ``` JS
React.createClass({
  render: require('...')
});
```

React doesn't care where the `render` callback comes from or what created it. If you want to load templates on-demand it seems far preferable to use code-splitting `require.ensure(...)` to achieve the full benefit without any involvement from React.
 React will not be supporting string templating options. We've argued against these from the beginning and the biggest point is that JSX is not a template, it is a simple transform that is otherwise JS. It transforms to JS directly, no sting parsing at runtime. We won't be adding more syntax for conditionals or loops because those are supported by the language. You shouldn't have to go learn a whole language (see handlebars, ng-*, etc) to do something you already know how to do in the host language.

As @syranide mentioned, you could easily refer to some other file or function for your render function if you want.
  React does not deep clone props/state, if you want the benefits of using `prevProps` and `prevState` then you need to ensure the objects are immutable/not mutated yourself.
 @cigzigwon There is almost always someone knowledgeable online in our IRC channel, for all your getting-started related questions, if you feel inclined.
  This is sadly the nature of JavaScript and it does not apply to just `propTypes`, it applies to all magic methods and everything you define yourself as well. I don't believe there's anything sensible React can do here that isn't cherry-picking, other than case-insensitive testing of all defined properties against a list of all supported React properties.

However, I'm hesitant as it would only patch a fraction of a problem that is inherent to JavaScript and ultimately not React's concern. Static analysis (or possibly future ECMAScript proposals) is the only truly worthwhile solution I'm sure.

I'll defer to @zpao @sebmarkbage for final say in this.
 We already do this with `componentShouldUpdate` so there is precedence. Cherry-picking these are difficult though.
 @sebmarkbage Is that a go ahead to emit warnings in DEV for all React properties with incorrect casing?
 I recognize the problem but I don't have an idea for a good solution. Casing is not the most common one so it doesn't sufficiently solve the problem. Misspellings like `prpoTypes` or `propType` are as common and we can't really catch all of those.

In the end, we would prefer to get rid of propTypes for the benefit of other type checking systems like Flow or Safe TypeScript. Both of these have new syntax extensions that are harder to misspell and will warn you if you do.
  This won't work in IE8 because defineProperty doesn't work there. Also, it'll be slow in production code even though it's not necessary. So we need to hide this whole getter/setter behind `__DEV__`.

In general, this seems like a good idea but I'm not sure how this will work once we switch to ES6 classes and arbitrary third-party classes since we have less control there. Not sure how exactly we will update the state property neither.
 @sebmarkbage Wouldn't `Object.freeze` work very well here? But perhaps it's a bad to freeze the `props` object as we do not require the use of immutable data...
 We'll probably make props immutable. But this is on the class instance where people put all kind of extensions like `this._timer = setTimeout(...)` which would be more of a stretch.
 @sebmarkbage Do we want to do some version of this or will this not work with ES6 stuff?
 I think that we'll want to move the authoritative state object into a separate internal store. E.g. `_currentState`. Then we can simply compare against `inst.state` to see if it changed and warn in that case.
 @cirocosta I know this is an old one, but would you be interested in updating this one so we can merge it in?

As per Sebastian, we should use a shadow state object (like `_currentState`) and then calculate if the user modified state, and emit a warning if modified.

Any interest in fixing it up and merging it?
 @cirocosta Sounds good to me!  Thanks!  Good luck with your exams!
 Ping @cirocosta - How'd your final exams go?  Any chance you have some time to rebase and use a shadow state object as per above?
 Ping @cirocosta 
 Ping @cirocosta 
 I‚Äôm closing as the PR has been requested to change, but has not been updating since. The issue is still tracked in #2272, and you are welcome to submit a new PR that incorporates the feedback you received in https://github.com/facebook/react/pull/2283#issuecomment-76110546. Alternatively, if you are busy, somebody else might take it from here.

If you start working on it again, please let us know both here and in #2272 so somebody else doesn‚Äôt start at the same time. Thank you for taking the time to contribute!
  #2156 fixed this and we missed getting it into the branch the docs are published from. I just brought it in now and will repush the site.
  The `submit`-event bubbles up to the root (as per HTML). `<div onSubmit={this.handleDivSubmit}>` is a DOM-component and exists in the DOM-hierarchy it receives the DOM `onSubmit`. `<Child onSubmit={this.handleChildSubmit}/>` is a composite component and is not part of the DOM-hierarchy, so it does not receive the DOM `onSubmit`.

If you want to expose an `onSubmit` for `Child` you'll need to expose it yourself, i.e. call `this.props.onSubmit` at the right time.
  I'm not all that familiar with Flux but use of `forceUpdate` is not preferable from React's point of view (but it's not _wrong_). React really comes into its own when used with immutable data largely propagated up through the root. Then you would simply batch/defer updates to the root properties/state and you would get a single (near) optimal update. Immutable data is generally preferable for many reasons in React.

#1060 has landed in master, but is not available in a release yet. I haven't actually dissected the exact details of it so I'm not sure if it applies to `forceUpdate` as well (but I think it might). You could then simply wrap your updates in a single `batchedUpdate`. That could be an easy fix for you if it applies.

I'm not really familiar with the practical intricasies/recommendations for using React with mutable data, so I can't give you an authorative answer on the best plan of action. But I think switching over to using immutable data is preferable, but that's obviously not always practical depending on your project.

> (meta: are issues like this encouraged or frowned upon here? I know it's a large project with a lot of "real" issues the core devs need to be paying attention to.)

Self-interest questions are frowned upon, but anything that is for the benefit of React seems fine to me at least. I also know that you're not alone in bumping into this issue. :+1: 
 This is squarely in the realm of "that makes sense, but I've never tried it" (in a sense) for me:

> What's nice is that I usually don't run into the problem immutables solve, since I usually have only the component tied to the Store listen to its changes, so  shouldComponentUpdate  is rarely necessary, 
> ...
> And I think I can use Backbone's  changed  property for the same purpose when that's not true, though I haven't tried yet. 

Everytime I've heard Backbone and React mentioned in the same sentence it has been "Backbone is a poor fit for React".

The problem with the evented setup is that it only works great in React as long as there's only a single event emitted per action and none of the components listening for the event are parents/children of each other. As soon either of those are broken you get overlapping updates unless you're able to batch/prune them somehow.

This is the beauty of pushing everything through the root, as long as the action has a clearly defined end .. that's when you push the current model data up through the root. No redundant renders, no inconsistencies, etc. If you also use immutable data you also get the benefit of virtually no unnecessary renders, for cheap.

That's the theory anyway. I'm running something similar to this myself and it works great. Last I heard a discussion on the subject this was "best practice", but I'm not really sure if it that is entirely up to date.

Perhaps some dev can shine some definitive light on the subject of using Reacts with events + forceUpdate.
 We currently batch multiple `setState()` calls made in a DOM event handler so in most cases calling it multiple times shouldn‚Äôt be an issue. We don‚Äôt recommend `forceUpdate()` and instead recommend you to use `setState()`, immutable values, and shallow equality checks in `shouldComponentUpdate()` for best performance. Of course you should only optimize perf once you find specific bottlenecks. [This](http://benchling.engineering/performance-engineering-with-react/) is a good guide on that. In the future, we might move to batching `setState()` calls outside DOM event handlers as well.

I hope this helps! I don‚Äôt see anything actionable here so I‚Äôm closing but please feel free to continue the discussion.
  Take the alternative approach discussed in #2161. I think we can take advantage of the self-closing information we already have in ReactDOM (and make use of in ReactDOMComponent).

cc @audreyt in case you're interested in taking a stab at this.
 Just to explore it, what is actually needed for this other than throwing a `/>` at the end of self-closing tags?
 Boolean attributes need to be like `disabled="disabled"`; not sure if there's anything else.
 @spicyj Interesting, I'm curious how `<a download="download">` would be interpreted...
 Is `download` the same as `download=""`? MDN isn't very clear.
 `download` uses the value as a filename. IIRC, empty `value=""` is interpreted as a truthy "this is a download link but without a provided filename".
 Edit: I'm going to leave this open because there are other XML-ish features mentioned by @Acubed.  The core of this bug (closing tags and boolean attributes) are done.

@dcousens This should work in 0.14; let us know if you run into any issues.
  #1060 added a batchedUpdates method to addons for this. I think it'll be in 0.12.
  I imagine it's intended as `setState` is valid during `componentWillMount`, but perhaps in need of renaming then.
 @cigzigwon Oh ok then, I pulled this from the comments of another issue I had and wasn't aware that it had been fixed. Thanks!
  For #1300, only IE8 lacks `pageX`/`pageY` (and perhaps really old FF or w/e I guess).
- [ ] Test plan: not yet (want your input on the PR first)
- [ ] If approved: will need to make a manual test and verify in all browsers

From my https://github.com/facebook/react/issues/1300#issuecomment-52509117:

---

https://github.com/facebook/react/blob/master/src/browser/ui/ReactEventListener.js#L65
https://github.com/facebook/react/blob/master/src/browser/ui/ReactEventListener.js#L165

That makes no sense at all to me, `refresh` does not take an argument, yet we get the scroll position and provide it as an argument. Instead, `refresh` gets the scroll position internally and uses that? So we call `getUnboundedScrollPosition` twice, but only use the result once (also, this should be broken for events inside iframes, for IE8).

---

https://github.com/facebook/react/blob/master/src/browser/eventPlugins/TapEventPlugin.js#L54
I'm pretty sure any browsers that supports touch also supports `pageX`/`pageY`... ?
 This seems pretty reasonable, though I know there's some internal FB code that uses ViewportMetrics that will need to be changed if we do this.
 @syranide This seems good ‚Äì mind rebasing?
 I rebased this in https://github.com/facebook/react/pull/6129.
Let‚Äôs continue the discussion there.
Thank you for the fix, @syranide!
  `<p><h1></h1></p>` is transformed to `<p></p><h1></h1>` by browsers (due to invalid nesting). If you would try to update the contents of a component with invalid nesting React would throw an invariant violation exclaiming the DOM has been mutated and is unusable.

Invalid nesting is a known problematic behavior that cannot be _fixed_, but there will be improvements to alerting the user of such problems.
 Also, this is related to #1400, if you try to mutate content inside invalid nesting you will get the error in that PR.
 Going to close this as a dupe of #101 as it's essentially the same issue.
  Throw invariant for _void elements_ with children (i.e. `<input>text</input>`). Void elements also avoid all overhead related to processing children props.

~~`menuitem` is a void element but still requires the closing tag to combat browser behavior. After much back-and-forth I chose to use `menuitem: null` to set this special behavior (rather than a separate call to `createDOMComponentClass`). If you disagree and prefer the verbose path then I won't disagree.~~
- [x] Test plan: `grunt test`
 Makes sense. However, this is going to need a rebase after my next diff. I'm sorry. :(

@zpao should we warn for one release before we throw this invariant? Do we have a secure way to find callsites that do this?
 As the self-closing elements do/did not have a defined `_tagClose` _at all_, any code that provide them with children should be _severely_ broken already I'm quite sure. That's not a guarantee obviously, but it seems highly unlikely.

@sebmarkbage Do your magic! Just give me a shout when this is ready to be rebased.
 @sebmarkbage Rebased.
 We should probably warn for a release.
 @zpao Sorry, thought of another PR, I'll make it a warning instead.
 @zpao I don't mind making it a warning, but is there really any point considering the generated markup is broken and throw invariants already if you update it. I.e. it seems to me that this is a serious user error that we should proactively guard against.
 @zpao Rebased and made warning only. I'll provide a follow-up PR which turns it into an invariant and also avoids the children-processing overhead for void elements.
 @zpao Before 0.13? It's just a warning for something you really _really_ shouldn't be doing and allows us to throw in 0.14.
 Older browsers don't support the menuitem tag so it's safer to have the closing tag regardless so it doesn't mess up the DOM structure.
  The two are not identical (yours can return a non-boolean), that probably doesn't mean that it's wrong though, but you'll need to check the call-sites.
 Closing this due to lack of activity, but I'd be happy to take this with a cast to boolean if you're still interested:

```
  return (
    prevDescriptor && nextDescriptor &&
    prevDescriptor.type === nextDescriptor.type &&
    prevDescriptor.key === nextDescriptor.key &&
    prevDescriptor._owner === nextDescriptor._owner
  );
```

You'll also need to rebase.
  Because FB.me isn't a real CDN. It also does redirects and as much as we have it on the site, we really suggest people self host or use a real CDN like cdnjs (http://cdnjs.com/libraries/react) or jsdelivr (http://www.jsdelivr.com/#!react)=
  Closed with #4157
  üëç thanks!
  We do generate them from markdown files in docs. Some of these were already fixed actually in #2237 (though I don't think we synced out to the site yet, will do today). See that PR for the file to edit. And if you just want to me fix "Putting" real quick, let me know.
  #1414
 Is it safe to assume since you specified that this is only modifiable via the attribute?
 @zpao I couldn't find any information for a related property, not via documentation or manually in Chrome. Also, considering older browsers definitely didn't support `manifest`, it's safe to assume they wouldn't have the property anyway.
  This would affect minification and it's an internal API that's subject to change at any time. If you want a function, use your own copy I'd say. (PS. Also use webpack instead of require.js :))
 @totty90 "can" and "should" are two different things. They're not publicly exposed, by reaching into `react/*` you are accessing internal modules, React offers no guarantees.
 I'm not an official dev so that's not my decision. I imagine that it was simply with the intent of keeping the meat of the examples simple rather than having link to all the different implementations.

It's not React's purpose and it's rather arbitrary; what should be exposed and what shouldn't. Should helpers not useful to React but users also be exposed? Should library X also expose `merge`, which one should you use? What if React no longer needs `merge`? What if React suddenly requires a specific semantic implementation of `merge`?

I think the idea that React should expose helper methods is flawed, if anything, it should probably be the other way around. React should depend on shared modules, if you depend on the same module and your dependency requirements are compatible you would share the implementation.

Again I'm not on "Team React" so this is not my decision.
 @totty90 This is not my responsibility, but if you want to submit an issue to petition for moving share-able utils from core into separate packages then that seems sound to me (not that I would expect it to happen anytime soon).
 Apparently it's "kind of" happening #2317
 Not going to do this. trying to move away from this as much as possible. Flux examples should probably not use the internal modules.
 Filed https://github.com/facebook/flux/issues/77 for Flux.
  @lennerd My understanding is that the xmlns:xlink is not required in HTML.
 Yes, as `xlinkHref` this should work in the upcoming 0.14 release.
 @QuietOmen you want `<use xlinkHref=` not `<use xlink:href=`
  This file is actually gone from our repo now. I still need to update the website to reflect that (thanks for the reminder!). We've moved flux documentation over to the [flux repository](https://github.com/facebook/flux). The file over there might need to be updated but I'm not sure. We diverged a little bit which is a big part of why we got rid of the flux docs here.
  What encoding are you serving your HTML with? My guess is if you add `<meta charset="utf-8">` to your `<head>` then this will work correctly, though maybe we should use only ASCII chars in our minified builds.
 Never mind, I see that the character is actually missing. Maybe a bug in uglifyjs?
 @spicyj As it's encoded the charset is irrelevant unless uglifyjs decodes it, being zero-width/invisible I imagine it would look like nothing is there... but it really seems like nothing is there. Very weird.
 https://github.com/mishoo/UglifyJS2/blob/master/lib/parse.js#L209

Is apparently the culprit, but it doesn't seem like it should be. Perhaps uglifyjs decodes strings first and then strips for some reason...
 mishoo/uglifyjs2#556
 Hmm, this is interesting, this problem only surfaces if you double-uglify the source, perhaps something is wrong in our build-process?
 PR #2249
 @cascadian I should add; if this is a priority for you simply replace `.innerHTML=""` with `.innerHTML="!"` (you can replace `"\uFEFF"` with `"!"` in the source too) and it should work.
 > this problem only surfaces if you double-uglify the source, perhaps something is wrong in our build-process

Yes, we double uglify to remove dead requires from the tree (see #1933).
 Ping, this is resolved in uglifyjs/master now at least. React should go the way of #2340 if you ask me though.
 @markplindsay I haven't verified, but this was fixed upstream in UglifyJS some time ago so it _should_ have solved itself... @zpao is it possible you're running the build process with an older UglifyJS?
 @zpao Ah, apparently we've locked the uglifyjs dependency to `2.4.0` whereas the fix is in `2.4.17` (or perhaps the one after it, not sure what the tag means in https://github.com/mishoo/UglifyJS2/commit/24bc09b79bf9ca3a09eef4f536e7637568f7097a). There's no reason not to update the dependency right?
 AFAIK no reason not to upgrade. @syranide want to send a PR to the 0.13-stable branch? (I forget how to update shrinkwrap files properly though‚Ä¶)
 Send to master and I'll pull it in with other things

cheers,
Paul

On Apr 10, 2015, at 12:26 PM, Ben Alpert <notifications@github.com<mailto:notifications@github.com>> wrote:

AFAIK no reason not to upgrade. @syranidehttps://github.com/syranide want to send a PR to the 0.13-stable branch? (I forget how to update shrinkwrap files properly though‚Ä¶)

‚Äî
Reply to this email directly or view it on GitHubhttps://github.com/facebook/react/issues/2247#issuecomment-91658188.
 Just confirmed that this is correct in the minified build now. We'll ship 0.13.2 this week with the fix.
 @ledowong No, we don't generally do point releases except for the newest minor release except in the case of a security vulnerability. You can patch in the change locally and make your own build of 0.12 if you're unable to upgrade to 0.13.
  Perhaps worth calling it `mergeIntoWithNoDuplicateKeys` or something to emphasize that it's like `mergeInto`?
 Revised without `forEachObject`!
 Perhaps it's too performance sensitive to justify it, but wouldn't it make sense to use `Object.assign` instead but just "manually" assert that there are no duplicate keys... perhaps even change the invariant to a warning and only do it for DEV?
 See #2464 (which coincidentally has the same numbers as this pull request, but shuffled).
  In Chrome, React expects to hear the `input` event. Maybe we could listen for the others as well, though I don't think it should really be necessary.
 Closing as this seems resolved and was an issue with the plugin.
  @slorber React cannot use the prototype as it auto-binds all methods, this will eventually (in 0.13 it seems) be a non-issue as you will then provide classes to React. React will no longer require the use of `React.createClass` (or not even have it in core, I'm not sure).
  IE8 throws if you change input `type`, It applies to all values of `type` (even unsupported ones).

``` JS
React.renderComponent(<input type="radio" />, document.body);
React.renderComponent(<input type="checkbox" />, document.body);
[ERROR for attribute]  Could not get the type property. This command is not supported.
[ERROR for property]  "This command is not supported."
```

Additionally, all other versions of IE does not respect `checked` unless `type="checkbox"` or `type="radio"`. So changing from `type="textfield"` to `type="checkbox"` while `checked` causes it to be unchecked. Which **should** be an issue for React, except that `ReactDOMInput` explicitly calls `DOMPropertyOperations.setValueForProperty` for every `componentDidUpdate` ([source link](https://github.com/facebook/react/blob/master/src/browser/ui/dom/components/ReactDOMInput.js#L107)). Why? Seems wasteful.

It seems to me that the correct solution (to all of this) is to consider a different `type` as a different component. `type` is a really weird HTML feature, which to me is akin to transforming `span` into `div` rather than remounting... which we don't.

cc @zpao @spicyj 

(PS. PR just because, not saying we should take it as-is)
 Accepted ‚Äì @syranide feel free to merge after we branch for 0.13.
 @spicyj Hmm, I made `getActualType` return `''` instead of `'text'`. It works with `'text'` currently in IE8 as it is mutated as a property. But #1510 will introduce `removeAttribute` for properties, so it would throw in IE8 when removing the property. Additionally, toggling between `<input />` and `<input type="text" />` seems incredibly rare and would also toggle the attribute in the DOM, while ultimately kind of irrelevant it seems preferable to treat `type(null) !== type('text')` for technical reasons and _hopefully_ the user will be made aware of the unintentional toggling (hmm, perhaps a warning _could_ make sense if really feel like it?).

Sounds good?
 Yeah, okay.
 This no longer works with the new implementation of ReactDOMInput. :\
 This no longer merges cleanly and has been stale for a few months so I am closing. Additionally, we no longer support IE8 officially in React 15, so bug fixes to it have a much lower priority now.
  Thanks!
 I didn't catch you soon enough before it got merged. We're deleting that page. Can we make sure it's updated in the flux repo?
  cc @sebmarkbage 
 Why is it important to not just create your own wrapper that calls createElement? Why is it important to have in 0.11.x and not just wait for the jump to 0.12?
 ``` javascript
function createFactory(type) {
  return React.createElement.bind(React, type);
}
```
 0.12 is less than a couple months away.
 Oh I see. You want a way to create the ReactElement without passing a factory. That's not something we can immediately support in 0.11 without further consideration. Your use case is exactly what we are working towards in 0.13 but we can't really fast track that without an incremental upgrade path. Because we won't know if that is final before we try upgrading.

> On Sep 24, 2014, at 5:47 PM, Yury Selivanov notifications@github.com wrote:
> 
> Correct me if I'm wrong, but in 0.11 React.createElement(type, props, children) simply returns type(props, children), whereas I'm asking here to expose ReactDescriptor.createFactory() which is a completely different beast.
> 
> ‚Äî
> Reply to this email directly or view it on GitHub.
 @1st1 You can make your own custom React build that exposes those modules/functions, though we won't be able to help you if you run into trouble.
 Those functions aren't part of our supported API so they're intentionally not exposed. `React.__internals` is also not part of the supported API and shouldn't exist, but it's currently used by the React devtools which we can do with confidence because we maintain the devtools and can update them in accordance with any breaking React changes. You should not use `React.__internals` because the modules are not designed to be used individually and will change from release to release without notice.
 It is good feedback though. What @1st1 is essentially saying is that:

1) We're pretty sure where we're going.
2) We are not moving fast enough to get there.

I think this is fair feedback. We're certainly trying to figure out how to solve (2). The problem with exposing features early is that (1) is not 100% true. We might change where we are going if the upgrade path shows that it's problematic.

That's why we wouldn't want to expose features that are not yet finalized.
 @sebmarkbage, Anything actionable here before 0.12?
 I think that this was just a way for early upgrade and since we have a RC, that's the solution.
   You could certainly write tests that way, and I have at times followed that route.  There is nothing "wrong" with it per se, it simply adds another thing (theoretically, or who knows, maybe practically) to consider when things don't work as expected.  

The ideal of _unit_ tests is to test a single _unit_.  Integration tests, on the other hand, test the interaction between multiple parts of a system.  So what you are describing is moving toward an integration test, not a unit test.  

Whether or not mocking the dispatcher matters in practice is a matter of debate, but in theory, _at least_, we can all see that we're no longer testing the store in isolation if we don't mock the dispatcher.  In that case, there is always the outside chance that it's something outside the store that's to blame for failing tests -- you won't know exactly where to look to find the bug.
 By the way, on this topic -- definitely check out that classic Martin Fowler essay that I recommended at the end of the post:  [Mocks Aren't Stubs](http://martinfowler.com/articles/mocksArentStubs.html)  -- Fowler might agree with the point you're making, but he has sympathy for both sides of the argument.
  I think we're getting rid of the need for the docblock in 0.12 so this may become unnecessary
  Soon. It won't be introducing components as ES6 classes (apologies, but our projects page is out of date).
 When it's ready. Going to plan to have preliminary support in 0.13 but that might not be what you really want. Stay tuned.
  Overlapping styles are not currently supported by React, see #2013. While it would be nice to support it, run-time performance is affected so it's a tricky subject (although offline transforms is definitely an idea).
 I actually think that it wouldn't be terrible to make this work. I'm betting that the reason it doesn't is that we expand shortcut properties and set each individual property (eg `margin` gets expanded into `marginTop, marginRight, marginBottom, marginLeft`) and we probably screw up key order (which is isn't technically guaranteed anyway). There would be some perf tradeoffs to make this work but technically shouldn't be too hard. Not sure if it's worth it. #2013 has some good points.
 @azazdeaz `{border: 'solid 1px black', borderBottom: 'none'}` is invalid, you may not set overlapping styles.
  Looks like there's already a note in this file. Can you move that note up instead rather than create new text? Thanks!
 And the CLA bot missed this, but I can see you signed it. Thanks!
  Closing in favor of #2104 as these sound pretty similar.
  Thanks but I think I might want to just kill this page entirely instead (#2229)‚Ä¶ I'll let you know soon.
 We'll be moving forward with #2236 so this won't be needed anymore. Thanks for taking the time!
  :thumbsup: thanks!
  :thumbsup: Let's ignore that option for now. This update to jstransform also brings in the reserved words transform which we aren't exposing. Longer term I think we might want to separate the other transforms from the jsx tool and make everything a bit more composable.
 FYI, I don't see anything wrong with this. It might take a little bit of time to get checked in just because we need to get jstransform all synced up internally before we can bring this in. I'm trying to make sure we don't fall out of sync :)
 Ok, I just got jstransform in order and I can finally bring this in. We already updated the jstransform dependency, so we'll need a rebase before this merges cleanly.
  Thanks!
  Agreed. We build on top of commoner so we need the fix to go in there. There's an open issue in that repo so let's move discussion there. https://github.com/reactjs/commoner/issues/64
  We'll be moving forward with #2236 so this won't be needed anymore. Thanks for taking the time!
  cc @petehunt 

I think this is right but I haven't looked at the valuelink stuff in a long time. Pete might have a better idea.
 Looks good except a few style nits ‚Äì mind fixing those up?
 Just bumped into this myself :+1:
 @cirocosta The implementation looks great to me.

For completeness, perhaps we should copy/reuse the `checkbox` test and apply it for `radio` as well, while we're at it?
 @cirocosta Checking that ReactLink works before checking specific details of it seems sane yes. I'm not all that familiar with tests myself yet, but apart from my two minor nits it looks good to me at least. :)
 There's no doubt to me that the fix is correct :+1:

In light of separate discussions about possibly dropping ReactLink support from core, having tests for non-ReactLink controlled inputs too would probably be a good idea. But I'll let @zpao weigh in on that (sorry for being annoying :)).
 This PR is over a year old, and doesn't merge cleanly.  Plus, we're getting rid of value-linking in the core.  So... I'm going to close this out.
  cc @petehunt @joshduck 
 Is it possible to call `ReactDefaultPerfAnalysis.getInclusiveSummary` directly in your CI pipeline?
  I just moved this page from our docs to the wiki for easier editing - https://github.com/facebook/react/wiki/Examples. Please feel free to add this and any other examples you may have there. Thanks!
  This transform is actually just picked up from jstransform. I filed an issue to add it over there https://github.com/facebook/jstransform/issues/31 so I'm going to close out and we can discuss more there.
  If you adhere to very simple rules this could very easily be solved statically/automatically in the future instead. That way everyone would benefit, regardless of whether you specify propTypes or not. Definitely not saying this shouldn't be done though, but that's where I would focus my effort if I would.
 Merging this into #1587 which has more discussion.
  Probably not because it's not statically typable (@sebmarkbage)
 This sounds like assert-territory to me, not propTypes, there will always be a demand for more complex constraints and propTypes is about the type, not the value. Only assert is sufficient capable in the end I would think.

While it doesn't discredit your idea, you've overlooked the mathematical notion of inclusive/exclusive which should be somewhat important. Also, don't use strings when numbers work just fine and would be by far preferable.

PS. But yes, sebmarkbage or whoever certainly has final say in this :)
 Yea, I don't think we want to support this. Enum (`oneOf`) is the closest thing we have to arbitrary value checking and those could arguably be considered a type. As @cirocosta mentioned, I think this falls into the territory where you could provide your own proptype.
 This is a feasible request but I'm not sure how much value people will get out of it. At this point, I'd rather strive for feature parity with Flow/TypeScript. We could add this request to Flow.
  We actually use "lifecycle" consistently throughout the docs. I know spell check says it's wrong and we may want to distinguish our uses ("lifecycle method" vs "this point in the life cycle") but we should do it across the board, not just here. Want to take a look at the other uses and see if that makes sense? If so, comment here before doing it and let's hear the argument.
 @ateich Interested in following up here? If not, no worries; I can close this out.
 Going to close out.
  It seems our CLA bot never came around and confirmed that you signed this but I can see that you did, so we're all good to go. Thanks!
  Thanks!
  Dupe of #1225, more or less.
  Makes sense to me.
  You're specifically asking for that behavior so I'm not sure what else you would want to happen. More specifically, triggering callbacks from life-cycle methods which then trigger a re-render sounds like a flaw on your end. React components are only views. It sounds like you have too much non-view logic in your components.
 Here's a mixin to prevent this =)

``` js
var screwupPreventor = {
  componentDidMount: function() {
    this.updateCount = 0;
  },
  componentDidUpdate: function() {
    if (this.updateCount++ > 999) {
      throw 'infinite recursion';
    }
  },
};
```
 Throwing in the setState/forceUpdate call would be better for debugging so that you see what's causing it.
  Isn't this what React.PropTypes.shape is for?
  > Data passed ‚Ä¶ is called props.

This should be "is", at least to me (even if "data" technically isn't singular).
 I agree that grammatically "are" is probably more correct here but using "is" feels a bit more how people talk and is pretty accepted. It's small but "is" feels a bit more human.

I appreciate you making the effort though! I don't feel super super strongly so if somebody else comes in and says I'm an idiot, let's revisit. We're not perfect, so if you see other things that should be fixed, definitely say so!
  If a number input contains non-numeric values then its `value` is always `""`. This is simply browsers being browsers, AFAIK there's nothing that can be done other than abandon it and do your own thing (IIRC you can trigger the numeric keyboard for regular inputs too).
 ```
document.body.innerHTML = '<input type="number" value="abc">';
console.log(document.body.firstChild.value === ''); // true
// type anything non-numeric input the input
console.log(document.body.firstChild.value === ''); // true
```

@cody There is nothing we can do.
 @cody React does not poll the DOM, it set the value of the input to `""` and doesn't bother setting it to `""` again as it's not supposed to have changed (and this is what makes React fast). Even if it would force it, the outcome would be equally poor, type `"1234"` then `"1234a"` and it would become `""`.
 @zpao @sebmarkbage Closing this as `wonfix` as I'm quite confident there is nothing we can do here, yell at me if you think otherwise :)
  Yup, this is right. Thanks! @evanbleiweiss line 10 is what is actually calling the callback. Line 17 is calling the component's own method (and is unchanged from a previous example).
 Err sorry. It's already correct. The rest of my comment still applies.
  I bet the transforms run in order, so `uglifyify, envify` probably needs to be reversed. The envify transform is the one that will make sure you actually have dead code paths (specifically dead require code paths) that uglifyify removes.
 This isn't really an issue with React so I'm going to close this out. Feel free to keep discussing though. In the future, this might be a better question for stack overflow or the mailing list.
 I don't think there's anything to take up, uglifyify just doesn't know code is dead yet so it can't remove it until after you run envify.
  :exclamation: DO NOT MERGE :exclamation:, I'll just push all of this directly, and I still need to amend with the starter kit before that happens.

any last minute feeback? These are the last bits of #2137
 lgtm
 @gurdasnijor As I understood it it's for "Flow", its type annotations look like TypeScript.
  **Summary:**
See the style proposal on react-future: https://github.com/reactjs/react-future/blob/master/04%20-%20Layout/Inline%20Style%20Extension.md

The goal is to enable writing CSS purely in JavaScript. We've been using this for a couple of internal projects and it's proven to be a very expressive tool.

Note that this diff doesn't bring `StyleSheet.create` nor `StylePropType`. I'm keeping it simple by just allowing arbitrary arrays, objects and falsy values.

Example of use:

``` javascript
...
  render: function() {
...
    <div style={[styles.base, this.state.active && styles.active]} />
...

var styles = {
  base: { color: 'red' },
  active: { fontWeight: 'bold' }
};
```

**Test Plan:**

```
grunt test
```

**Reviewers:** jwalke zpao sema
**CC:** tomocchino
 If this allows us to remove all the third-party react-style libraries/mixins/preprocessors then I'm all for it!
(@SanderSpies @andreypopp)

But I still think it's much more performant if you manually merge the styles outside of render and turn it into an id for `className`. No proof on this though.
 The way we "corrected" `style` for DOM components before was easy to explain. It reflected the DOM API. This doesn't and I'm not completely sold yet that we should overload style again in a different way. We've gone from a strict type to a very loose type built into core that doesn't have a DOM corollary (at least if we ever get around to `classList`, that concept exists in the DOM).

This is easily extracted into a helper function (a la `cx`) - just pull `flattenStyle` out and you have to call `style={flattenStyle([.........])}`
 The goal is to move to a world where we don't use CSS anymore. Inline styles are actually a very good abstraction to replace most of CSS. I thought a lot about how to plug it into React and settled on extending the API just slightly.

@sebmarkbage has a spread operator proposal for objects but the syntax overhead is dissuasive

```
var style={{...styles.base, ...(this.state.active ? styles.active : {})}}
```

Using flattenStyle is an option but is still verbose. Also, it has a big downside that going from 1 to 2 styles requires a high cognitive overhead.

```
var flattenStyle = require('flattenStyle');
var style={flattenStyle([styles.base, this.state.active && styles.active])}
```

Inline styles are something that's used very heavily. In the biggest project where we tried this, we have 50 React components, and 100 inline styles. In another, 30 components for 130 inline styles.
 So, the idea would be to re-write

``` javascript
var styles = {
  base: { color: 'red' },
  active: { fontWeight: 'bold' }
};
```

into 

``` javascript
var styles = StyleSheet.create({
  base: { color: 'red' },
  active: { fontWeight: 'bold' }
});
```

which would return a value

```
{ base: 1, active: 2 }
```
- If nothing changed, then we're just going to diff [ 1, 2 ] against [ 1, 2 ] which is going to return false and we quit.
- If something changed, then we actually flatten and pay the cost of memory allocation and copy.

This is strictly an optimization and we'll still need to support inline styles. So my intention is to first ship the easy but not so efficient version and then bring the infrastructure for the stylesheet.
 I could be convinced, I just want to make sure we don't get too loosey-goosey. We have a DOM story and changes like this make it much harder to say no to other changes. Let's let it simmer for a few days (I'll be on PTO anyway), get some perf numbers, and hear from others before doing anything.
 Note that we've been building two major features with this on the mobile website. We forked React and this is an attempt to converge again.
 > which would return a value
> 
> `{ base: 1, active: 2 }`

If that is the goal, wouldn't we be better off by simply creating classes dynamically and returning those instead? (performance win too) As the class styles would have to be static anyway.
 [Ugh. I thought I answered this before. I guess GitHub lost it during poor connections.]

This data model is effectively a single record and the correct data model is to create a new record. This is why we have the `...` syntax. The whole point of that syntax is to enable these use cases of functional updates and to build persistent data structures into VMs and optimizers.

If the syntax isn't palatable we should come up with something new and standardize that instead. The last thing we should do is make up our own new proprietary data structure that is not generalizable. (See my JSConf.eu talk for why that is bad.)

This is a general concern with the lack of persistent immutable record types in JS which needs to be addressed at a larger scale and whatever solution we come up with should be generalizable every large immutable record type so that people don't have to come up with their own solution every time.

These data types require special methods to operate on that is specific to this field. There's no automatic conversion. Our ReactChildren data structure is bad enough. We shouldn't introduce more of them.

There's two parts to this proposal.

1) The ability to store constants as lighter representations (for example an ID but could also just be a shared pointer reference). Functional languages do these kind of optimizations all the time by treating constants as by-reference equal.

There's really no such thing as a constant because these things need to be cleaned up at some point if you have a long living app where you're able to unload modules for example. These are also not constants because they're often calculated a head of time. However, since we can assume that these objects are immutable, we can automatically or manually move declarations to the module level scope if all they depend on is branches that execute in module level scope. Thereby giving them a shared reference.

2) The second feature is the ability to combine multiple of these constants in a light-weight way without actually copying. As has already been pointed out, it's even more efficient to just do this at the module level scope. The only exception is for dynamic values such as: `{ ...styles.base, width: this.props.width }`

These might need a persistent object. The goal should be to get these into engines and to do that we need to start designing with that in mind.

We can polyfill with an immutable record object from immutable-js or something like that. A general data structure that can later be replaced with a native record object or we can compile to support it.

As it stands right now, there's not a lot of uses of these styles on the web because it is inefficient to apply inline styles in the DOM. We would need to generate classes (the precedence is solvable).

I don't think we should introduce a new proprietary data type that will be difficult to upgrade a more general solution for persistent records. Not until there's an imminent need. There won't be an imminent need until the other aspects of this style model has proven itself. E.g. the application to DOM nodes, automatic reuse of constant values, class generation and the applicable programming model. By the time that happens, we may have the other language level optimizations in place. For example, in a compiler step.

There is a serious abstraction leak in using a non-restricted syntax for it with possible unconstrained manipulation of the arrays. That will make it difficult to minimize all the possible misuses of this feature. So it will be difficult to undo.

If we can introduce something that is more difficult to undo (such an ImmutableObject abstraction that is palatable and upgradable) then we can move forward with that instead. Or if we can prove the imminent value of this (that can't wait for other data types).
 I'll get back to it when time is due.
  We'll be moving forward with #2236 so this won't be needed anymore. Thanks for taking the time!
  > If I need a component that doesn't have a DOM representation, I can use render function that returns  `<noscript>`.

You can return `null` and it will (internally) translate to `<noscript>` for now.

> However recently I had to have a component without DOM representation, but that also has children, that I want to be mounted (so that their lifecycle methods trigger correctly).

I'm not sure if I really undersand you. Composite classes (your own classes) by definition doesn't have a DOM representation, only `React.DOM.*` has. What you're asking for it seems is the ability to return multiple components from `render()`, see #2127. It's likely going to happen _sometime in the future_, but as you might hint from reading my comment in that PR I'm not convinced that it's generally a good idea and your solution is probably to refactor/rethink instead.
 @freiksenet What you're asking for should still be to return multiple components. If you genuinely don't want them to be mounted into the DOM then you're using React components too much like OOP, which is not a good idea. React is only concerned with "views".
 Ah yes, I see your point. But I don't think React (master branch) is well-suited to this at the moment, you can look at ReactART, it's a branch of React that works on SVG (or was it canvas) instead. Some dev probably has a more definitive answer for this.
  It's most likely coming (#1570), just not very soon.
 We need it on the DOM nodes for now, though it may get removed in the future. I'm going to close this out so we can try to keep the conversation on the PR as much as possible.
 @Aweary Only for client-side rendering, SSR still has them :/
 @dschinkel SSR = Server Side Rendering
 I'm not sure how `data-reactid` would be impacting Casper. `fetchText` takes a selector and `'h3'` should still select an `<h3 data-reactid=...>test</h3>` (I would assume this should be the same as `document.querySelector/All`).

Anyway, I think commenting on an old issue isn't an appropriate place to discuss this though. If you think this is a specific issue with React, please open a new issue with a test case we can run. Otherwise, this seems to me like potentially an issue with Casper or your usage of it (maybe querying the DOM before your component has rendered) and would be better discussed on stack overflow or potentially in the Casper repository.
  Old issue: #175

I've come to believe that it's better left this way. You've got one way to do things and `setState({a: b})` is just as concise as the shorthand.

Somewhat related: with immutable collections, it'll probably be `setState(wholeStateObj)` all the time. `setState({a: b})` would mean your new state has nothing but `{a: b}`. Under this situation `setState('a', b)` doesn't make much sense anymore.
 Thanks for finding that @chenglou. There was also #282 where somebody made this work.

I think at this point, we're going to wontfix it again. I do understand the desire _but_ I also think an explicitly (and consistently) typed API is more readable and usable long term than something more polymorphic like this. This is the direction we've tried to move with our code and I think we'll stick with it.

There hasn't been a strong need for this and it's really only people making the transition from Backbone that have even asked. But _if_ we do add this, I think we'll want to do it with its own API, not reuse `setState` like this.
  This is no different from the same events outside of React. You probably want onMouseLeave.
  This was fixed by #6005 & be in v15.
  I can't reproduce it outside of React and I can't find any related code in `ReactDOMInput`, I'm assuming `ChangeEventPlugin` is the culprit.
 @browniefed Sorry for forgetting about this, you are indeed correct about `oninput`. It affects inputs with any char not in the range `x01 - x7F` and appears on both IE10 and IE11. The `oninput` is not dispatched during `innerHTML`. It can easily be feature-tested for if necessary (but a positive result will be received after the current tick).

However, I see no obviously best/neat solution.
1. `ReactDOMInput` could test `value` for any char not in `x01 - x7F` during `componentWill/DidMount` and (in some way) set a flag for the node. When an `input`-event is received it is discarded if the flag is set, the flag is then cleared, could also use `setImmediate` from `componentWill/DidMount` for clearing the flag (or both). Requires feature-testing and is potentially fragile.
2. `ReactDOMInput` could store the initial value (in some way) for the node. When the `input`-event is received it is discarded if the current value equals the initial value, the stored value is always cleared when the event is received, could also use `setImmediate` from `componentWill/DidMount` to clear the stored value (or both). Can use feature-testing. Seems robust and simple. Unless there can be noop `input`-events then this should be 100%.
3. `ReactDOMInput` sets a flag during `componentWill/DidMount` which is cleared by `setImmediate`. Super simple and robust, but if a legitimate `input`-event is somehow dispatched in the tick immediately after creation then it will be lost. I can't imagine how/why that would happen though (or?). Can use feature-testing.
4. Have I missed something obvious?

Related: https://connect.microsoft.com/IE/feedback/details/816137/ie-10-11-input-elements-with-unicode-entity-character-values-cause-oninput-events-to-be-fired-on-page-load

cc @zpao @yungsters 
 cc @salier 
  There is such a diagram. @zpao 
 @chenglou Can you find me a good place to put it?
 http://facebook.github.io/react/docs/component-specs.html#lifecycle-methods
here? Or maybe even a tip, lol
 @thechrisproject This issue is still open.
  We do different wrapping around Constructor in 0.11 than we did in 0.10 so you probably need to adjust for that. You're hacking the system in unsupported ways so I don't think we have any intention of supporting your case directly.

cc @sebmarkbage in case he has anything to add / wants to reopen / think about things
 Basically you can just replace the line:

``` javascript
var Ctor = this(model);
```

with

``` javascript
var Ctor = React.createElement(this, model);
```

(note that this was called `createDescriptor` in 0.11.1 but will be called `createElement` in 0.11.2)
  Kind of related #2094
 @contra If you someone cares enough to submit a PR it will surely be accepted. :) The React team is currently more focused on getting React core stable I would say, most DOM fixes are by the community AFAIK. I could look into it some time but I've been busy elsewhere lately.
 Yes, these were added in 0.14.
  Good catch. We updated a lot of other places as we evolved the API but obviously missed at least one. Let us know if you see any more!
  I think you are right, thanks!
  That's what `ReactLink` is for, in-fact you don't even need to use `ReactLink` as it's just an unhelpful helper IMHO. The API is simply `{value: ..., requestChange: function(v) { ... }}`.
 Closing as `wonfix` as I don't think there's anything actionable here, feel free to object.
  lgtm. This might live better in a didPutListener hook in SimpleEventPlugin but I think my diff adding that was reverted and hasn't been reapplied yet.
 :thumbsup: @arasmussen want to fix the test we have for this error?
 Moving over to #2181 with an extra commit for the tests.
  Exposing a hook does not seem preferable, making anything with global implications user customizable is generally not a good idea. What @browniefed linked to seems preferable or simply dissect and recreate the functionality in React, I imagine it would be quite possible to do the same thing in React and lose some "bulk".
  For what it's worth, https://github.com/facebook/regenerator should already work for generators with JSX and will support async/await in the near future.
 I think we would support somebody else doing it but we don't have a vested interest in doing it ourselves‚Ä¶ We are also adding ES6/7 features as they come in (perhaps not at the exact same pace). We are revamping a lot of our transform stack making it easier to write new ones and aligning so the regenerator transform will work with others we write more easily.

Also, it is possible to write a pretty simple script which does a JSX transform then hands off the output to Traceur to do the rest, if you want.
 > I think my immediate needs will be solved when fb-esprima merges parsing async functions.

It was merged a few minutes ago. :)
 > and JSX cannot parse async functions

Sorry, you're totally right. I meant it in the general sense not considering the parts we can't even parse.
  I personally recommend: #1912
 @silver83 React clears the content of the element you render into when you render normally, so (I think) the same behavior should be maintained for reusing server-rendered markup. Also, if the client is for some reason unable to reuse the server-rendered DOM the content would again be completely cleared and rendered as normal (i.e. if we allowed whitespace there it could have affected rendering).
 Closing via #1912, thank you for your contribution anyways :)
  The algorithm for 1 doesn't seem very robust, I'm pretty sure (but not certain) that it could be made without arbitrary thresholds for time.

I don't have access to IE6/IE7, but I really doubt that `typeof renderNode[RESULT_INDEX_ATTR] !== 'undefined'` is identical to `renderNode.hasAttribute(RESULT_INDEX_ATTR)`. There are lots of (non-standard) attributes that doesn't have properties.

Also, does IE6/IE7 support value-less attributes?
 I'm going to wontfix this based on what I said before. We will undoubtedly break this and that just means unknown pain down the line. The changes now are small but it's unclear what they will become. And honestly, the day I can make a case for dropping IE8 support is the day I make a case for removing a bunch of code from React.

But like I said before, I totally support you or somebody else maintaining a fork and keeping it up to date. We'll even point people who ask towards it. But we won't be maintaining it ourselves.
  I think @petehunt has some in-progress effort to make this better but I haven't heard anything recently‚Ä¶ It's definitely a good idea.
  :thumbsup: 
  Yes, we intentionally treat `undefined` and `null` differently, as does JS. Basically, reading the spec definitions is our explanation.

> [4.3.9](http://www.ecma-international.org/ecma-262/5.1/#sec-4.3.9) undefined value
> primitive value used when a variable has not been assigned a value
> 
> [4.3.11](http://www.ecma-international.org/ecma-262/5.1/#sec-4.3.11) null value
> primitive value that represents the intentional absence of any object value

I think the proptypes warning is a bit confusing here. It seems like `isRequired` should allow `null` since it has intention. However `isRequired` is equivalent to saying your type is non-nullable (which means no `null` nor `undefined`). So we don't really have a way of saying "any defined value which includes `null` but not `undefined`". Maybe we should but I don't really know how to express that.

cc @sebmarkbage who talks to me all the time about types and could surely form an opinion if he doesn't already have one.
 It's true that `isRequired` should only check for `undefined`, not `null`. That way it's possible to explicitly allow a `null` value as a valid value. This could be important in a union type.

It would open up some other confusing scenarios. E.g. `null` is a renderable but a required renderable would still allow `null` (it already allows `false` which is equally confusing).
 I agree that null should be a valid value even if it's required. I don't think that the breaking change is too bad since it's more lenient. It wouldn't spam you. We could introduce nullable types `PropTypes.Nullable(PropTypes.string).isRequired`.

We could also rename `isRequired` -> `isDefined`.

Our goal is to align with Flow, which doesn't really model this distinction clearly right now. So any change in the type system should also be brought to http://flowtype.org
 No, `this.props` is not available inside `getDefaultProps` because it gets called before there even is a `this`.
 I wouldn't expect there to be further changes to PropTypes. Flow has become much more mature recently, and from what I heard from the React team, it is the longer term solution to type checking. This puts PropTypes into the same "compatibility" bucket in terms of priorities‚Äîlike createClass or React addons, they are still supported, but only with bugfixes and performance improvements, without adding new features or changing the API.

(Note: this is not an official position, but my impression of it based on conversations in other threads.)
  :thumbsup:
  @spicyj, you know what's up.
 Yea, I can close this.
  Any logs that could help us here? My first assumption is always going to be that you're missing the polyfills but I can't say that with any certainty without knowing what your console says.
 These are both listed on our polyfills page at http://facebook.github.io/react/docs/working-with-the-browser.html#browser-support-and-polyfills (the RegExp one is because Function.prototype.bind doesn't exist and we call that out). We also do feature detection when the React script is loaded by the browser and warn if we're missing anything. I don't think there's much more we can do.
  [You can render `null` from your child](http://facebook.github.io/react/blog/2014/07/17/react-v0.11.html#rendering-to-null), effectively removing it. But it will still exist in the virtual hierarchy (memory will be retained, lifecycle methods will still fire, etc). You can not truly unmount yourself like you're hoping.

If there's a condition where you don't want an item to exist at all, you may want to restructure your data hierarchy so the parent can decide what to render (which is typically what we suggest).

I'm going to close this out since there's not really an issue. Let's try to keep "how do I _____?" discussions to slightly more appropriate platforms (mailing list, stack overflow).
  Related #2273
 If we support this, then we should generate XML compatible markup directly. There are certain performance expectations that goes with this change.
 @sebmarkbage so what's the actionable feedback here? Generating XML compatible markup would likely fall under a whole different PR and shouldn't be done here. Should we close this and work on that separately? Do we really want to generate XML compatible markup all the time? HTML5 allows the use of self closing tags but HTML4 doesn't (at least if you want to actually validate, I assume browser don't care). Which means some real person will care.
 I'm not sure how important it is to validate beyond the parsing rules in HTML5. The HTML5 parsing rules should be enough. We could always generate XML compatible markup, if that's viable. I guess the other PR would need to explore that. Otherwise it could be two different branches.

Closing this out so that we can get another PR that generates XML compatible strings.
  Fixed in #2156
  See #1657 for some more discussion about the future of SVG in React. Going to close here and track there.
  :+1: 
  thanks for doing this!  i don't have merge privileges on this repo, but the changes look good to me.
  We should create a new benchmark suite for patterns that are relevant to React.

We should write test for four different target audiences:
- JS Engine (Low-level micro-benchmarks of important language features like Object.assign)
- DOM Engine (Low-level micro-benchmarks of document.createElement, innerHTML, cloneNode, updating and setting the .style property etc.)
- React Core Engine (Low-level and real worlds tests of the React algorithm before the DOM layer.)
- Integration Benchmarks (Real world DOM tests that benchmarks the whole thing.)

We need to figure out what format to use for all these benchmarks and how easy they are to incorporate into the engines' benchmark suites.

We should also set up a more stable CI environment to track regressions. The one we have now is too noisy.
 :+1: "Integration Benchmarks" is incredibly hard to pull off meaningfully in just a single number, I think. I imagine it would be great if each "task" was benchmarked separately, so that trade-offs could be properly considered (animation fluidity/stutter, etc) rather than simply seeing the sum of the most costly operations.

PS. Also letting browsers breathe between benchmarks, too many benchmarks end up benchmarking mostly the GC under enormous pressure rather than something meaningful.
  Sweet, thanks. Can you keep an eye on the upstream issue and open another PR when that gets done right?
  cc @jeffmo @sebmarkbage 
 Commented on the issue. This is the wrong fix according to the current spec, so we'd have to agree on a spec change first.
  This sounds like #1326.
  I kind of want to keep it so it's noisy and bothers you and you don't forget to remove it in production. If it's not processing scripts and being quiet it becomes easier to leave it in in production. That might not really be our place to tell you, but could be helpful.

I don't feel super strongly though, so would be interested in hearing what you think.
 I'm inclined to agree here and leave it as is.
 That's a good point. I still want to be noisy so this seems like a fine compromise. You fine with that @spicyj?

I was trying to think of other compromises (leading idea I had was starting a 5 second timeout and tracking if any other APIs were called, then warning if not) but they're all a bit overkill.
 @imcotton Oh that's interesting. We haven't really done anything with log levels (but we've talked about it). Definitely might be worth exploring in JSXTransformer first before we do anything in React...
 Let's just do it and if we need to change out minds later and/or refine this, so be it.
  Thanks!
  Thanks :)
  Perhaps "don't like" would be more appropriate.
 "haven't liked"? 
 Do you mind signing the CLA? Once you do I'll merge this.
 Thanks!
  :thumbsup: 
  :thumbsup: thanks!
  What if we considered 2 a feature instead? It'd be rather close to facebook/jsx#8 and could turn out to be quite useful.

Sequence expressions shouldn't make sense inside `{}` as you're not allowed to have side-effects in render, sequence expressions are only useful for side-effects.
 @RReverser Not saying I disagree, but `a + b` is obviously not equal to `a, b`, `{a}{b}` is however. Users could also always access `SequenceExpression` with parenthesis `{(a, b)}` which I would arguably prefer as good practice. It's not immediately obvious that `{a, b}` is a `SequenceExpression` (EDIT, my intuition is that `{a, b} === {a}{b}`).
 > They are not in JS, but with your assumption we're making those operators behave equally (both concatenate output). And that doesn't feel right, as we're changing the basic meaning of operators.

Hmm? No they're not, `{'a' + 'b'}` and `{'a'}{'b'}` does not have the same meaning or even necessarily the same result.

I don't agree that we're changing basic meaning of operators, `abc{...}def` is something entirely JSX-specific and the meaning of what's inside is ours to define, just like functions. `f(a, b)` is not a `SequenceExpression` and I don't see why `{a, b}` **can't** work the same way (not that it has to).

I'm not going to stand in the way, but to me `{a, b} == {(a, b)}` is useless and rather unintuitive, `{a, b} == {a}{b}` is somewhat intuitive and quite possibly useful (but perhaps not preferable). In my opinion even `{a, b} == ERR` might be preferable to `{a, b} == {(a, b)}`, it takes the guesswork out of the equation.
 > then we should strictly follow the spec and parse contents inside as AssignmentExpression (and SequenceExpression is one of it's possible subclasses).

I'm pretty sure that a sequence (known simply as Expression in the ES spec) is not included in AssignmentExpression. In fact, Expression is exactly just a sequence of AssignmentExpressions. I intentionally chose AssignmentExpression instead of Expression since I knew this wasn't supported.

If we want to support this, let's open up a task on the JSX spec and have the discussion there so that other interested parties can follow along in the rationale.

Leaving this bug open to chose either solution but, until we decide to fix the spec, the correct fix is to throw to a syntax error.
  cc @salier @joshduck 
 Yes.
  `scrollLeft` and `scrollTop` are specified in HTMLDOMPropertyConfig, I understand what they're probably for. But what is the use-case? Doesn't it make more sense to just let users set/update them manually (on DOM nodes)?

I'm asking because we currently emit invalid attributes for them, we also don't set the properties when reusing server-markup, so they seem really really hacky right now.

cc @zpao @spicyj @yungsters 
 (I've no idea.)
 Looking back at pre open source history this blames to when @yungsters created the property whitelist. I can't see a good reason it was added, perhaps there was some legacy reason which made sense at the time. I can't find any consumers on DOM components, only composite components so I think it should be fine to remove them.
 @lojjic There are other properties you can set on a DOM node that we don't expose. Proper setting of `scroll*` should be done directly on the node (the getting out of sync is a very good reason).
 Closing in favor of PR #2202.
  It seems you assume that `key` only applies to ReactDOMComponents, it does not, it applies to all components and is local and relevant to the parent only. You're putting a keyed component as the only child of a non-keyed parent component, you then put the non-keyed parent component in an array. Thus the non-keyed parent components are not keyed, but only their children (which is irrelevant).

This is by design, it's not a bug. You can use `cloneWithProps` if you need to attach a `key` afterwards.
 @radubrehar 

The concatenated reactids (which React bases its reconciliation on) works as follows, the view below shows the final expanded hierarchy (not as returned by an isolated `render()`):

```
<div reactid=".1">
  <MyList reactid=".1.1">
    <MyItem key="a" reactid=".1.1.$a">
      <div key="b" reactid=".1.1.$a.$b" />
    </MyItem>
    <MyItem reactid=".1.1.2">
      <div key="c" reactid=".1.1.2.$c" />
    </MyItem>
    <MyItem reactid=".1.1.3">
      <div reactid=".1.1.3.1" />
    </MyItem>
  </MyList>
</div>
```

If `prev reactid === next reactid` then a component instance is reused/reordered, else the old instance is unmounted and a new instance mounted.
 @radubrehar I'm closing this as `invalid`, reopen if you feel that it is incorrect.
  I think we want to get `React.createElement` out there. We can take some ridealongs for new elements or properties or any non-breaking bug fixes. List them if you have them.
- [x] #2033 
- [x] #1848 
- [x] #2177
- [x] #2153 (needs jstransform & esprima bumps - bcc291b5918f62129d8411d5a9d8fdd53d9b5d07 - slightly risky but needed for some tooling)
 Can we have `.key` and `.ref` on the descriptor (and still in `props`) in this release to allow people to switch to using `.key` when appropriate for future-looking code? @sebmarkbage 
 Can we have createFactory too? Trying to preemptively start fixing up KA code (before upgrading React) and it's easier if I can do it all now instead of having to do it synchronously with the upgrade.
 I thought we already has createFactory?

> On Sep 4, 2014, at 12:51 AM, Ben Alpert notifications@github.com wrote:
> 
> Can we have createFactory too? Trying to preemptively start fixing up KA code (before upgrading React) and it's easier if I can do it all now instead of having to do it synchronously with the upgrade.
> 
> ‚Äî
> Reply to this email directly or view it on GitHub.
 Me too but it doesn't seem to be in 0.11.1.
 We didn't need an intermediate release for key/ref because it is greppable. You can probably find your uses using just grep. We did. So I figured it would be ok to play hardball on that one. We've always introduced some breaking change with releases without deprecating them first.

Do you foresee trouble upgrading at KA?

> On Sep 4, 2014, at 12:47 AM, Ben Alpert notifications@github.com wrote:
> 
> Can we have .key and .ref on the descriptor (and still in props) in this release to allow people to switch to using .key when appropriate for future-looking code? @sebmarkbage
> 
> ‚Äî
> Reply to this email directly or view it on GitHub.
 No, shouldn't be a big deal.
 Ping @sebmarkbage #1988 (no rush from my side, just a reminder)
 @kossnocorp We won't be bumping the minor version even if we add a couple small things. Right now PATCH really is our MINOR.

> 1. Major version zero (0.y.z) is for initial development. Anything may change at any time. The public API should not be considered stable.
>    ‚Äî [semver](http://semver.org/)

I totally understand your argument though and I'm not trying to be rude, just letting you know we're taking advantage of the "fuck the other rules pre-1.0" rule while we can. API additions are for transitional purposes while updating your own codebase. We won't break or change existing APIs though. We're trying to be as interop and semver as possible while sticking to a slower-moving schedule (it's not practical for us to bump versions at the rate of say [browserify](https://github.com/substack/node-browserify/releases)). When we get to 1.0, the plan is to be much more strict about the real rules.
 @mtscout6 it's currently in 0.11.x as createDescriptor, which just calls the function it's passed. It will be more involved/versatile in 0.12
 @syranide you mentioned #1988 here but I don't think we should take it in the branch. Did you want it there or just reminding @sebmarkbage in as many places as possible?
 @zpao Just a reminder, push ahead :)
 http://facebook.github.io/react/blog/2014/09/16/react-v0.11.2.html

cdnjs and jsdelivr should be set up to pick up the changes from npm/bower automatically. I think that's all folks.
  cc @syranide @jeffmo - I don't know how the whitespace parsing in JSX works these day...
 This is because we try to put a span inside an option, which doesn't work.
 I think this has been fixed (my jsfiddle: http://jsfiddle.net/ve84suby/).  Closing.  We can re-open if someone can reproduce with a fiddle in 0.14.
  ``` JS
f = document.createElement('form');
f.enctype = 'multipart/form-data';
console.log(f.enctype);
console.log(f.encoding);
console.log(f.getAttribute('enctype'));
```

Outputs (on IE8):

```
LOG: multipart/form-data
LOG: application/x-www-form-urlencoded
LOG: application/x-www-form-urlencoded
```

Whereas with `f.encoding = 'multipart/form-data';` or `f.setAttribute('enctype', 'multipart/form-data');`:

```
LOG: multipart/form-data
LOG: multipart/form-data
LOG: multipart/form-data
```

Unlikely that anyone would ever bump into this, but it is super-weird if you would and it's pretty much for free so why not.
 Switched it to use `encoding` instead, now both attribute and property access works. Works in all browsers I have my hands on, including FF3 (it should be more backwards compatible than `enctype` and as such safe, W3 HTML5 requires `encoding` to alias `enctype`).
 cc @yungsters 
 @yungsters IE8 throws, but I figure it's not worth special-casing as you really _really_ should use valid mimetypes (and everyone uses one of the two common, with one of them being default too).
 Perhaps we should introduce an `THROWS_IN_OLDIE` which we can apply to some of the less common properties which offends old IEs when given a non-supported value, which would simply do the assignment inside a try-catch.
 @yungsters 

```
React.renderComponent(React.DOM.form({encType: "multipart/form-data"}), document.body);
> "multipart/form-data"
React.renderComponent(React.DOM.form(), document.body);
> "application/x-www-form-urlencoded"

React.renderComponent(React.DOM.form({encType: "multipart/form-data"}), document.body);
> "multipart/form-data"
document.body.firstChild.removeAttribute('enctype');
> "application/x-www-form-urlencoded"
```

It works because of `getDefaultValueForProperty`, I also tested with `removeAttribute` if/when #1510 is accepted (**EDIT:** tested in IE8 ofc).
 @yungsters Pinging here as well :)

As for IE8 throwing when setting invalid values, it is a widespread issue with IE8 and I would say outside the scope of this PR.
 Looks good to me.
  From #1515, thoughts?

`dangerousInnerHTML`, `unsafeInnerHTML`, (`disasterousInnerHTML` :)) or something else? (I prefer the sound of `dangerous`)

It also makes sense to add a `dangerousDefaultInnerHTML` (`default` is the word we use elsewhere) which could be very useful for content-editables to avoid "hacks", etc.

cc @sebmarkbage @zpao 
 `dangerous`! _bikesheds_
 I don't mind `dangerouslySetInnerHTML` but out of the options you listed I prefer `dangerousInnerHTML`.
 @rymohr The reason for `dangerous` _is_ to scare people into actually thinking very carefully before using it AFAIK. It _is_ dangerous to use it, but dangerous does not exclude safe or useful.

If the HTML is in any way invalid then you risk breaking the entire app, if the HTML also contains anything user-supplied you've very likely enabled a very serious security issue. Personally I think that means `dangerous` is more than justified.

Also, here's the justification for `{html: ...}`: #2256
 @appsforartists `{__html}` is not intended as another "warning", it's meant to signify that a value is safe for use as HTML, using it inline as `dangerouslySetInnerHTML={{__html: ...}}` is NOT how it's intended. `dangerouslySetInnerHTML={getHtmlValue()}` is the intention, where it makes _a lot_ of sense as the burden is now on the function to guarantee that the value is safe for use as HTML.
 Really the "dangerous" is in the wrong place and it should be `innerHTML={{__dangerousHTML: ...}}` so that when you write `innerHTML={foo}` it looks safe (and it is, as long as whoever wrote the `__dangerousHTML` key made sure that the HTML was safe).
 @spicyj :+1: (I guess `dangerous` still alludes to it expecting a special wrapped value though)
  This is currently in an unmergable state (looks like it was based on 0.11 branch originally). You would need to rebase it on master which shouldn't be too bad. Actually, I bet you probably just want to create a new branch from a clean master, and bring https://github.com/mtsyganov/react/commit/703f382b10c5f7f19505745d074fdbc8250a4153 into it.

Now that said, I'm pretty sure I don't want to take this. I think it's a commendable effort and I would be in support of you maintaining an IE6/7 compatible fork for others to use. But we (Facebook) dropped support for these browsers ~2 years ago and none of us has any desire to go back to that world. IE8 is bad enough. I'll leave this open for a bit of discussion but that's where I am.
 I personally wouldn't mind having the charAt/hasAttribute fixes in the main repo. If it's possible to globally shim Element.prototype.querySelectorAll in old IE then it seems preferable to recommend that instead of inlining a polyfill here.

@mtsyganov It's unclear to me how your `data-ie8_value` tracking works. It looks like that stores only the last React-rendered value of the input and will incorrectly fire onChange if non-React JS code sets `.value` on the DOM node. Am I reading this wrong?

@zpao I agree that we shouldn't let IE6/IE7 hold us back, but having at least basic compatibility seems like it could be a nice feature, especially given that the necessary changes are small.
 @spicyj I think the idea is nice, but unless we commit to supporting IE6/7 then it will break again. Are we even sure that _everything_ works as it should with just this PR? I imagine there are bunch of edge-cases that might not actually work as intended but doesn't show up in tests.

I agree with @zpao, the best course of action is for someone to maintain a separate branch and pull in compatible features from React once tested. Putting this restriction/burden on React seems counter-productive as most have given up on IE7 (including me), _especially_ for newly started projects.
 I think the best approach would be to maintain your own IE7-compatible branch and just pull in React's master every so often to keep it up-to-date. :+1: 

@spicyj - I wish `Element.prototype.querySelectorAll` was globally shimmable in old IE. Unfortunately IE7 and below don't expose these prototypes. Libraries like MooTools and Prototype worked around it by wrapping the native DOM elements in a wrapper object whenever you used the `$` function to grab an element, but that ends up being pretty difficult to do correctly. I attempted the same thing myself a few years ago.
 I haven't changed my mind yet, but we can move further discussions over the the new PR.
  I'm pretty sure that's how browsers implement it and it's not React-specific, I'm partly inclined to agree with their implementation as well.

"doubleclick" does not represent two consecutive clicks but the "doubleclick" action (or "gesture"), just as there could be "tripleclick", "quadrupleclick", etc. If you click 4 times fast it's a "quadrupleclick", not a "doubleclick". Semantics. If you require a specific semantic interpretation, the only safe bet is probably to implement it yourself.
 @binarykitchen It should work just as fine and as intended.
  You messed up a rebase or something:

Switch to master, pull against upstream master, switch to branch, rebase against local master... and it should be fixed (always back up your changes first).
  If I understand the problem correctly, you are unmounting a component that later calls `setState` after the data is fetched, and this causes an error.

It should no longer cause an error in v14 as it has been replaced with a warning in #4091. Additionally, we advise you to use an async primitive that supports cancellation (e.g. Observables), so that you can cancel those requests and their callbacks in `componentWillUnmount`. This way you can unmount children safely without worrying about the warnings when their requests complete.

I hope this helps! Please let me know if I misunderstood, and we should reopen. Thanks!
  Making tags configurable seems like a cop-out, essentially pushing the problem on the users instead. Closing as #1657 addresses this concern, feel free to voice your opinion there.
  Because when you don't put the wrapper, it desugars to this:

``` js
return React.DOM.div(...)React.DOM.div(...)
```

Which doesn't make syntactical sense. The [jsx compiler](http://facebook.github.io/react/jsx-compiler.html) page might help if you need a visual mapping.

That being said, it's possible to desugar this to `[div, div]` instead. This is hard, somewhat controversial and won't be implemented in a near future.
 (I don't think it's particularly controversial but it does add code complexity and hasn't been done yet.)
 IIRC @syranide has a few comments on this
 @chenglou Hehe.

I had a brief chat about it with chenglou a little while ago, I don't really lean one way or the other at the moment. I see a lot of hidden dangers in allowing a composite components to return multiple components and it breaks a lot of intuitive assumptions, but I don't know of any (right now) good practice use-cases that would obviously benefit from this.

The simplicity of returning at most one component means that it's very easy to reason about what you see, if not, `<table><TableHeader /></table>` could actually render any number of rows, you have no way of knowing other than inspecting `TableHeader` and whatever composite components it returns.

I feel like being able to return multiple components only moves the responsibility of wrapping components as necessary from the "composite component" to whatever "renders the composite component". The component "that renders composite component" rarely has or should have the knowledge of whether to wrap composite components or not, whereas children are more likely to have knowledge of their parents.

But perhaps it's simply a case of developer responsibility. There may be good use-cases for both and we should just look past the inevitable misuse.

@sebmarkbage Probably has a few comments too :)
 We will probably never allow that syntax implicitly. You would need a wrapper like 

``` javascript
<>
  <div className="col-md-8">
  </div>
  <div className="cold-md-4">
  </div>
</>
```

OR

``` javascript
[
  <div className="col-md-8">
  </div>,
  <div className="cold-md-4">
  </div>
]
```

However, even this doesn't work. Often, it's probably for the best. It can be confusing for consuming components when a child might expand into multiple elements.

But, really, the only reason we don't support this right now is because it's hard to implement. Hopefully, we'll be able to support it sometime in the future but probably not short term. Sorry. :/
 @gabssnake You should have gotten a JSX compile error with the error "Adjacent XJS elements must be wrapped in an enclosing tag"; did you not see the error or was it not clear in its explanation?
 @gaearon You can do that already though, you just need to return an array for now (which is a bit cumbersome though yes) ... buuuuut, you can work around that, I have hacked my own `<Frag>` component which is translated to an array (overloaded `React.render`) ... you could also do `return <NoopComp>...</NoopComp>.props.children` I assume, if you want to avoid hacks.

**EDIT:** My bad, I overloaded `React.createElement` not `React.render`.
 @gaearon Yeah you can avoid the commas using either of my two workarounds for now (if you find either acceptable)... but what you do mean with explicit keys?
 @gaearon Ah yes, I choose to just mentally ignore that warning for now :), if you really want to to avoid it, you can do `<MyComp children={this.renderWhatever()} />` to avoid it (**EDIT:** although you obviously can't use that if you have adjacent children, you could use some flattening helper... but yeah).
 For all the use-cases presented here I'm pretty sure you could replace `<BunchOfComponents />` with `{getBunchOfComponents()}` and the visual output would be the same, without introducing the practical and technical issues related to having components with fragments as root.
 > @syranide but every time one of the components changes all of its siblings need recalculating... 

 @wmertens Yes, but many times you would have that anyway because the parent would need to rerender for other reasons, or simply because you receive the data through props anyway. But yes, that is the difference, but it doesn't mean this approach is right, it's an optimization and there are many ways to accomplish them.

> Also if you use plain coffeescript it's easy to return an array, so please decouple the functionality from the jsx representation. 

That is irrelevant and this is not a problem with JSX. A big issue is that you lose the technical, practical and intuitive assumption of **one component = one element/node**. I can't speak for the devs but I would not give up that willingly, it's a very useful assumption to have. I'm sure there are equally good or better optimizations that could be designed if optimization is the only the reason people want this.
 @thomasboyt

**EDIT:** My mistake, I conflated some of your arguments with the table-discussion above, I largely agree with what you're saying I think. But there are still problems with components being opaque, so what's intended as a useful transparent wrapper becomes opaque to the parent. Imagine `<Wrapper1><Wrapper2>...</Wrapper2></Wrapper1>`, `Wrapper1` cannot see the children of `Wrapper2`. So perhaps `wrapMyElements(...)` simply is a better solution all-around still (including any other necessary supporting functionality).

> I have a problem with the idea that a component needs to return one "element/node". To me, it seems perfectly reasonable for a JSX structure of:

Components are more than just dumb wrappers, they have a purpose. IMHO it seems that returning multiple elements blocks some very useful expectations. For example, `React.render` will get a companion in the future which renders an element and returns the nodes, this must now produce an array of nodes instead.

But I think a very important issue is that of readability which IMHO is the biggest selling point of React, everything is explicit.

``` html
<table>
  <tr>
    <td />
    <td />
    <td />
  </tr>
  <tr>
    <Columns1 />
    <Columns2 />
  </tr>
</table>
```

Looking at that it makes no sense, where is the 3rd cell coming from? Perhaps it's actually wrong and it's rendering 2 or 4 cells, who knows, perhaps it's actually dynamic and depends on a prop or external state? There are many of variations of this problem which only get harier when you consider other non-HTMLDOM frontends which may have explicit expectations. Another thing to consider is that elements are opaque, so if you replace `<tr />` with `<MyMagicalTr />` then it is not able to interact with the individual cells or even deduce how many there are, so even though `<MyMagicalTr />` may only accepts `<MyMagicalTd />`'s there is no guarantee it can actually interact with them.

> This requires developers to compromise on making isolated, reusable components - heaven help them if they decide they want to reuse their bunch of components elsewhere - because of an underlying implementation issue in React. I don't think that should be accepted.

"This requires developers to compromise on making isolated...", but that is exactly the problem if you ask me, if a component can return multiple elements it's no longer isolated, it's substituted, the component is leaking into the parent.

Hammer, nails. It being an underlying implementation issue is a separate issue from whether or not this should actually be done at all. It's not my decision, but I don't see how one rare use-case is convincing argument without considering the trade-offs that comes with it or what other alternative solutions there are.

IMHO I don't see the problem with `{getBunchOfComponents()}`, it's explicit, it allows us to keep our useful expectations. If performance is a problem then `React.createSmartFragment()` (or w/e) to the rescue, a transparent array/object-like type but one which can update independently from its parent.

Again, the React devs are the authority (not me), but I don't see a convincing argument here considering the various side-effects. I'm not even sure I agree with the presented solution being a good pattern at all, even if it was supported.

**EDIT:** To clarify, perhaps components may be able to return multiple elements in the future because there are other obviously beneficial use-cases, especially in the context of passing through children (like the one you show @thomasboyt), readability is maintained.
 @thomasboyt IIRC the main implementation obstacle comes from React referencing child nodes by `mountIndex`, this does not work when one "node" can suddenly become any number of nodes and this may happen without invoking the parent and it may also happen several components deep (wrapping). If I'm not mistaken it's pretty trivial to have React support multiple root elements as long as the number never changes.

So I don't think it would be especially hard to just make it work in React, but a truly proper solution is more problematic and should probably involve dropping `mountIndex`.
 @landabaso 

``` js
function getBunchOfComponents(...) {
  return [<ColumnA key="a" />, <ColumnB key="b" />];
}
```
 @slorber Yes, that's probably true.
 I added a note to the top of this issue. Please read it before commenting. https://github.com/facebook/react/issues/2127#issue-41668009
 None other than the ones already mentioned.
 @whatknight That won't work except in cases that `return renderABunchOfComponents();` already works.
 @mwiencek Looks like your implementation doesn't work if the number of children in a fragment changes in an update (_nestedChildCount is set only in mountComponent)? There's a little trickiness to make that all work well. Looks like you've got a good start though. I've actually been thinking about this again recently and I may have figured out a robust way to make this happen. I'll report back if I find success.
 @spicyj Isn't the way forward to use `createFragment` and have JSX transform into that? Or do we really want fragments to be elements?
 Thanks all for the words. We know this is hard and still have it on our to-do list. (Asking enthusiastically won't make it happen sooner @janryWang.)
 Unfortunately GitHub's markdown handling behaves differently when a comment comes from an email. I edited the comment to remove a blank line and now it shows up.
 Not strictly, but they made the implementation simpler in this instance.
  This sounds like #1326.
  Thanks for filing. This is unfortunately because Safari doesn't seem to fire any events when it does this. There's a bit more info in the stackoverflow link in #1159 (of which, I think we should just call this a dupe)
  Are you asking for the parent or the owner? In the case of passing components around, these are different. Consider:

```
// A:
return <B><C /></B>;

// B:
return <div>{this.props.children}</div>;
```

C's owner is A but it's mounted into a div (and that div's "parent" is B, I suppose).

Concrete use cases would be helpful. (It doesn't look like there are any uses of _owner in react-router right now?)
 Sounds like the parent hierarchy would work just as well for this ‚Äì the Routes component will still be at the top. This is probably best solved by [contexts](http://facebook.github.io/react/blog/2014/03/28/the-road-to-1.0.html#context) (still undocumented; currently owner-based but soon parent-based per #2112).

It may also be worth encouraging the use of https://github.com/brianmcd/contextify for server rendering so that the execution environments are completely isolated (that's what [react-page](https://github.com/reactjs/react-page) does).
 I wasn't proposing any particular API, but it could give access to the instance.
 The idea is you could have the Routes component return in its getChildContext method whatever info the Link needs and then the Link could access this.context.routeInfo.blah or whatever. This commit message and tests gives a general idea of the API:

https://github.com/facebook/react/commit/b91396be8eac3dc57ab1dbd2d3bb27c791d88169

(withContext is probably going away, use getChildContext instead.)
  jsfiddle doesn't support https so there's nothing we can do about that. View our site over http and everything will work.
  Thanks ‚Äì closing as a dupe of #1301.
  Probably time to move these to the wiki, but for the time being, sure
  Closing in favor of #1301.
  Seems like a good move. cc @yungsters
 Thanks!
  I'm pretty convinced at this point that Contexts are more useful in the Parent tree than the Owner tree. It also opens up new use cases for parent->child communication that wasn't possible before.
 @sebmarkbage I'm not entirely sure exactly what problem contexts are meant to solve. But in the hypothetical context of reinvented styles (without selectors) I can imagine a benefit in being able to propagate `hoveringOverTheBigButton` (active/etc) to all descendants... and same for implicitly passing props from far up the hierarchy to far down (as is often requested). This should obviously be in the Parent tree then.

It seems that using a GUID style approach would be preferable for avoiding any and all conflicts, components would instead opt-in. Something like:

```
var Child = React.createClass({
  contextSources: {
    ancestorIsHovered: Parent...hovered
  },
  render: function() {
    return <div>{this.context.ancestorIsHovered ? 'Ancestor hovered' : 'Ancestor not hovered'}</div>;
  }
});

var Parent = React.createClass({
  childContextTypes: {
    hovered: React.PropTypes.boolean
  },
  getChildContext: function() {
    return {hovered: true};
  },
  render: function() {
    return <Child />;
  }
});
```

But again, I'm not exactly sure what contexts are meant to solve so I could be way way of the mark here.
 @sebmarkbage I assume we'll want to support reparenting someday‚Ä¶ is there anything we need to keep in mind while doing this? Guessing not but wanted to check.
 cc @jsfb
 Contexts are still an experimental feature, and while they're probably not going to be deprecated, they are not yet documented and may be subject to change without notice.  For this reason, you may want to avoid using them in production applications until the API solidifies.  That said, a flux store is a perfect example of a good use case for contexts.

On the server-side, I see no reason that everyone can't share a single flux store.  Each request to the store would also need the userid for whom you're fetching the information, and apps running client-side would get a 403 error when trying to access data for another user.  Your flux store may act as a cache, or may query the database directly, but either way, by making store requests that include the user, you can now share a single store across the app again.

Current status for contexts is: optimistically hopeful, but not ready for prime time yet.
 I'm pretty sure there is currently a bug in the warnings in trunk too. The risk of running on trunk. :) cc @zpao for a stable build.
 @insin @gaearon  Master currently only warns if the contexts differ, but uses the old notion of context.  To change over to use parent contexts should be a two line change, but we wanted to maintain the old behavior with warnings for a period of time until we're ready to pull the trigger on a switch.

Yes, it's entirely possible there is still a bug.  Looking into the masking on _performContextUpdate now.
 @brigand  Yes, singletons are not without their drawbacks.  Thus the motivation to pass flux stores as context variables => thus our desire to implement context variables.

Your interpretation is correct: If you use a singleton store server side, you will need to have stores act like they're serving every user at once.  You may likely end up with a different server-side store implementation (conforming to the same interface) that is backed directly by the database (since the cost tradeoffs are entirely different on the server side, your security enforcement policy is inherently different, etc).  If you are backed by the database, you are by definition the source of truth (can go straight to the database), and you therefore don't need to worry about tracking a 'done' state nor worry about 'change' events.  You sacrifice a little isomorphism, to gain simplicity in your implementation (ie. you don't need to track done state because you aren't dealing with 'change' events server-side), which you may have wanted to do anyway for security/perf reasons.

It was not my intent to hijack this thread, merely to point out that there are alternatives for flux stores.  You can use a singleton model as long as your store implementations conform to a multi-user interface instead of a single-user interface.  That said, we are implementing context variables because we think they may be valuable in these situations.  I'm not advocating one solution over the other, and both solutions have their tradeoffs.

@natew Even after we switch to parent based contexts, there are a number of design decisions surrounding contexts that we'll still need to figure out.  It will likely take us some time before we feel comfortable publishing them as a supported feature.
 @1st1 That's the plan.
 React Native is still on React 0.13.2. We'll update after the 0.14 final release.
  I need to do a general update of that page. I think we aren't going to have ES6 classes in 0.12 since we have a bunch of other changes, likely 0.13.
  Ohai this is an old issue. We ended up fixing this and we use keys in the tutorial now.
  You could easily create and attach it yourself during `componentDidMount`, it's obviously not the same thing, but I imagine that it will work just as well for you and you don't have to wait for another release for the fix (which might not happen "soon").
 Well, I said I wouldn't support it because it's not real html, so I guess I need to follow through. We no longer use the whitelist for dom components when going through `React.createElement` in 0.12 so if you wanted to use that directly you could and it might work (no guarantees). But we do still use the whitelist when transforming JSX, at least for now to provide a clean upgrade path to the future.
  In ReactCompositeComponent mixSpecIntoComponent, we join them by underscores ‚Äì which I assume we would have done only if there were a problem with using a dot? :+1: otherwise though.
 lgtm :+1: 
  Perhaps a dupe of #1931.
  Here is an example of how `<ReactCSSTransitionGroup>` is explained in the README:

http://jsfiddle.net/deadlyicon/kb3gN/4984/

It works. 

Here is that same example except I've added a `componentDidMount` method that focuses a button within the component being transitioned:

http://jsfiddle.net/deadlyicon/kb3gN/4985/

Notice how the `enter` transition fails to animate.

This is possibly a browser bug but I thought I'd let you know anyway. 

It's also worth noting that this bug can be worked around by moving the `transition` out of `.example-enter` and into `.example-enter.example-enter-active` like so:

http://jsfiddle.net/deadlyicon/kb3gN/4986/

Hope this helps improve React :D 
 Good find @cody can you link to your fiddle?
  Please submit this to #1657 instead.
 This should be fixed by #5714.
  Thanks!
  This is a convoluted (but hopefully good enough) example: http://jsfiddle.net/deadlyicon/js16uaxp/2/

When the root node returned from a render function changes the value of `this.getDOMNode()` is going to change. This breaks binding and unbinding via `componentWillUnmount` and `componentDidMount` 

Whenever the value of  `this.getDOMNode()` is going to change it would be nice if  `componentWillUnmount` was fired before the change and `componentDidMount` was fired again after the change. Essentially a re-mounting. 
 This is by design, `mount` and `unmount` does not refer to the removal of child (DOM) components in any way, but the creation and destruction of your (composite) component, i.e. its state.

What you could need is a way to register to life-cycle events for DOM nodes, similar to my `react-unmount-listener-mixin`, except that it would have to be exposed by React or be injectable.

However, I imagine that the correct solution to your problem is to sub-divide your component instead:

```
  render: function() {
    return cond ? <div /> : <span />;
  }
```

So instead of that, you do:

```
  render: function() {
    return cond ? <CompA /> : <CompB />;
  }
```

Now `CompA` always returns the same root DOM node, whenever it should change to the other "DOM node" it will render `CompB` instead which will effectively destroy `CompA`, calling its `unmount` and `mount` for `CompB`.
 @chengyin It seems you both want kind of the same thing, however you're assuming that you're allowed to add/override life cycle methods of descriptors. You cannot and you must not. If you need to know when a specific ReactDOM component mounts/unmounts, you need to wrap it with a custom (composite) component of your own, that houses your own life cycle methods.
  I was only able to get these animations to work by placing the `transition` declaration within the `example-enter-active` selector. When it was in the `example-enter` selector it didn't work. 

For whatever reason the animation began when the `example-enter` classname was added and was then halted when the `example-enter-active` classname was added. 

Chrome Version 36.0.1985.143
 Thanks @cody for trying to recreate this. This is closer to what I am doing http://jsfiddle.net/deadlyicon/kb3gN/4981/ but it works outside of my app. I'll keep trying to hunt down what I'm doing weird. Thanks!
 I figured it out:

http://jsfiddle.net/deadlyicon/kb3gN/4982/

when you add:

``` js
  componentDidMount: function(){
    this.getDOMNode().childNodes[0].focus();
  },
```

it only works when you move the transition.

Weird right?
  Running this indicates to me that the value attribute is kept properly:

```
React.renderComponentToStaticMarkup(React.DOM.option({value: ''}, 'x'))
// '<option value="">x</option>'
```

Perhaps something is wrong elsewhere in your code ‚Äì if you make a minimal repro perhaps I can take another look.
 @taarimalta This was a bug in the RCs; will be fixed in 15 final when it comes out this week.
  Just a few small things ‚Äì otherwise looks great, thanks!
 @fitzgen Want to update and we'll ship this?
 Thanks @fitzgen! I'll sync this out with the next site update (today or tomorrow)
  @keyvanfatehi Close developer tools and open it again when React is available, it seems to only check for React when you open developer tools.
  > Does react automatically lowercase attribute names?

It doesn't, but I believe HTML attributes (unlike SVG, for example) are always case-insensitive so the mapping isn't necessary.
 `currentTime` is not a DOM markup attribute and should not be supported by React (see #2140), I believe the same applies to some of the others too including `playbackRate`.
 @contra Hmm? Which ones. The only ones I know of are `scrollLeft` and `scrollTop` and no one seems to think they should be there. Nor do I see why we should add more when the ones we have are broken and shouldn't be used.
 `scrollLeft` and `scrollTop` are there but shouldn't be (artifact of times forgotten). If you see others, please let us know.
 Let's get the non-markup attributes removed and then we can move forward.
 http://www.w3.org/TR/2012/WD-html5-20121025/media-elements.html#mediaevents

Are there new events we should support? (I'm not really familiar with the new media elements)
 We can't take this as-is so I'm closing this out ‚Äì if you do want to remove the non-attribute property names and rebase, I think we can take this though.
 @contra Ambigious behavior is best handled by community components, put audio/video in a component of your own and you're free to do what you want with the properties. Anything React could do that you can too.
  Little-known fact: the `<button>` tag defaults to `type="submit"`. If you change it to `type="button"`, your fiddle works as intended.
 This is part of how HTML works, not specific to React at all.
  We're working on changing some of the terminology. I think `componentClass` is probably going to be ok though. Thoughts @sebmarkbage?
 We've moved forward and don't think we want to do this (and would need to be drastically changed anyway). Closing out.
  Maybe we can call it `text` or `message` or something along those lines?
 Sure, thanks!
  @contra Be sure that you understand the current limitations of audio/video/etc in React: #870 (just so you don't go on ahead and face unexpected issues)
 @contra If it or its (parents too!) siblings move/reorder the audio/video will stop playing, if that isn't a problem for you then great. :)
 I think we support all these now.  https://facebook.github.io/react/docs/events.html#media-events
  They're not broken (they're just decoded), however if you're not serving your page with charset `utf-8` then you might need to add `<script charset="utf-8"` to your script-tag to avoid it being parsed with an incompatible charset.
  @misuba You're not using an IE8-hostile minifier (or options)? I know UglifyJS has a quite a few fixes for dealing with IE8 issues.
 The original error as reported by @howtomakeaturn is because of a lack of polyfills (the error is actually pointing at the `Array.isArray` call in the invariant). I can repro that easily and the fix is simple.

@misuba I'm not sure what's up with your case. I assume you're hitting this while actually running code, not just loading the file. I made a test case using our invariant module and it works for the cases I could think of. Could you create a minimal repro with React or maybe output the value of `format` so we can see if we perhaps used invariant incorrectly.
 @misuba though if you're using our minified build, we shouldn't even hit that line of code because `format` is undefined.
 @misuba Any update? On the surface it seems to be a problem with your build process and not a flaw with React.
 This is long stale, so closing out.
  We're not currently using 3.2 in the example so why don't we update the whole thing and put in the updated bootstrap js and css files?
 Fair enough.
  This got fixed.
  :+1: lgtm ‚Äì thanks!
 @kimagure This doesn't merge cleanly anymore. Can you rebase? Then we can merge this in.
  This isn't true at FB so I think we still need these. It's an empty function but it's still an extra call. (perhaps that'll change in the future, but not yet).
  As you saw, we already have a couple other non-standard attributes so I'm game. Do you know if these exist on any sort of standardization process?

Have you tested these to make sure they update correctly? (ideally testing that changing the autosave and results values between renders results in the DOM and UI being update correctly). Do they need to be set as attributes (`node.setAttribute('autosave', ...)`)? Or is default setting via the property (`node.autosave = ...`) going to work?
 @zpao Just floating it again as it's kind of related, is it imaginable to add something like:
 `<div attrs/nonStandardAttributes={autosave: ...} />` as a catch-all for non-standard attributes (which are also sometimes necessary for other libraries/frameworks)? That way core can stay "standards only".
 @rexxars That's the default behavior IIRC, simply use `null`. `HAS_OVERLOADED_BOOLEAN_VALUE` allows you to specify a boolean OR value, i.e, the value `true` emits a value-less attribute and anything else that is truthy emits an attribute with a value. 
 Let's make it autoSave. Sorry for the long delay ‚Äì needs a rebase.
 Thank you!
  Nope, sorry! No one gets notified when you push commits so it's best to comment back so we know.
  renderComponent throws if passed a non-node; unmountComponentAtNode should too.
 > I've been slightly annoyed in the past with silent failures coming from this method.

Next time, file the feature request yourself. :) Whenever possible we go for clear errors.
 Looks to me like this fix was merged, so I'm going to go ahead and close out the issue.
  returning `false` from an event handler is getting deprecated (#2039). Can you take this occasion to change it to a `e.preventDefault` at the beginning of the handler, and plain `return;` in both places? Thanks.

(Also, please submit the change here too: https://github.com/reactjs/react-tutorial/blob/master/scripts/example.js)
 Cool. You just need the CLA now! =)
 Thanks!
  This doesn't actually work in the browser as is so I don't think we'll make it work in React.

See http://jsbin.com/daxep/1
 I don't think we should overload the DOM like this. It adds too much magic. You could clean up your example by reading the file and storing the dataurl in state, then you would still get the nice clean.

```
onChange: function(e) {
  setState({file: ..., fileData: ''});
  // read the file
  reader.onload = function(ee) {
    this.setState({fileData: ee.target.result});
  }.bind(this);
},
render: function() {
  if (this.state.fileData) {
    thumbnail = <img src={this.state.fileData} />
  }
  // ...
}
```

Or you could create your own `<FileImage>` component that allows you to pass a file reference to it and does something like the above.
  Thanks for jumping on this, just a couple things and then we can push it out :)
  I said it in the other task so I'll say it here too: I think it might be time to move that list to a wiki page. We'll take this for now but we may remove the whole list at some point in the future.
  Kind of related #2073

It seems to me there's a natural correlation between mount and update methods:

```
getInitialState    => componentWillReceiveProps
(always true)      => shouldComponentUpdate
componentWillMount => componentWillUpdate
componentDidMount  => componentDidUpdate
```

In many situations you want to have the same code for mount/update, but you have to put it in a shared method and call it from both places. It's hardly common enough that it's an issue, but it seems common enough that it strikes me as a bit odd... perhaps. Just an idea, could it make sense to e.g. get rid of mount altogether and instead have the following  (it's extreme perhaps, but just as an example):

```
// mounting
getInitialState
componentWillReceiveProps(update = false?)
componentWillUpdate(update = false)
componentDidUpdate(update = false)

// updating
componentWillReceiveProps(update = true?)
shouldComponentUpdate
componentWillUpdate(update = true)
componentDidUpdate(update = true)
```

It would unify the life-cycle and move away from mounting being treated as entirely separate from updating, it would then be seen as an exception. There would be less potential for inconsistencies causes by mistake/neglect.

I haven't thought this through extensively and bring it up mainly to start a discussion, I know many others have wondered why there isn't a life-cycle method for mount+update.
 I'm not saying you're wrong, but at the heart, React works much like old-school server-rendered pages. Render page, click something, throw everything away, render page. In this model there is no separation between first and subsequent renders. Now that's obviously not exactly how React works in practice due to reconciliation, so there are obviously a need for `mount` and `unmount`.

But my curiosity lies in that my "proposed" change makes inconsistent/broken behavior less likely to occur as only listening to `mount` is a special-case, rather than the other way around:

```
React.createClass({
  componentDidUpdate: function(first) {
    // suboptimal (but not necessarily broken)
    addEventListener(...);
  }
});

React.createClass({
  componentDidUpdate: function(first) {
    if (first) {
      // optimal
      addEventListener(...);
    }
  }
});

React.createClass({
  componentDidUpdate: function(first) {
    // optimal
    measureDOM();
  }
});
```

Whereas with the old separation you can "easily" have inconsistencies:

```
React.createClass({
  componentDidMount: function() {
    // optimal
    addEventListener(...);
  }
});

React.createClass({
  componentDidMount: function() {
    // inconsistent / broken
    measureDOM();
  }
});

React.createClass({
  componentDidMount: function() {
    // optimal / correct
    measureDOM();
  },
  componentDidUpdate: function() {
    // once more
    measureDOM();
  }
});
```

I also think my proposed change makes it easier to understand how a component is implemented, as you no longer need to correlate the differences of `mount` and `update`.

PS. Again, I'm not forcefully pushing for this, but I think it's an interesting topic.
  Merging into #1032.
 It's not implemented yet. #1032 is a issue for tracking any SVG tags or attributes that we're missing so I added your request there instead.
 @edmspjp surround code with 1 or 3 ` and it will not be messed up.
  Just some nits, otherwise it's good! Also, I didn't even know that. ~~Shouldn't this be a bug?~~
 I guess you made this change through Github's edit button? I think you still can't amend the same PR through Github. You'd have to clone the repo locally, set up the branches, make the changes and yada yada (you can try that). Let's just finish correcting this if no one else has comment (@spicyj), and then you can close this PR and submit a new one.
 That'll be good for now. Thanks!
  (Kind of related #1912)
 A bunch of nits without a proper review! I think it mostly makes sense though. I'll give it a closer look soon.
 http://inimino.org/~inimino/blog/javascript_semicolons is probably a good thing to read.

In the case of `return`s, a semi colon is inserted at the end of the line, so

```
return
  4;
```

actually returns `undefined`, and then 4 is never reached. But this

```
return (
  4
);
```

ensures that an expression is started (via the opening paren) and gets evaluated. So that would return 4.

```
return 4;
```

of course returns 4 because it's on the same line. The other example in the file has everything on the same line, so that works.

Other cases in JSX work as long as you start it on the return line, but we don't like the way that looks so we prefer the explicit opening paren.

```
return <div>
  4
</div>;
// becomes
return React.DOM.div(null,
  "4"
);
```

You can see that the opening paren on the return line means that this works.
 @crm416 I agree that the parens in ReactMountDestruction-test look unnecessary.
 Ah, I was looking at the wrong file. Yea, the ones in the preceding test in ReactMountDestruction-test are unnecessary.
 Sorry for the long delay on this, @crm416. A few last inline comments, and then I think we'll be good to go. You'll also need to rebase for a clean merge ‚Äì you'll at least need to change renderComponent to render; not sure if there's anything else.
 Merged in 10ab0c8915f4bb2c4bdc69e12f824e004814ada0.
  Feel free to submit a PR!
 @chenglou No, I think we just need to cherry-pick to 0.11-stable.
 Oh sorry, read that a bit too fast...
 This happened
  http://jsfiddle.net/haa2euy9/1/

Enter inside the square, then enter in `Hello`. Expected nothing to happen. Recorded a `leave` instead. Same for exiting `Hello`.
 @taddei If you want that, you can use onMouseOver and onMouseOut.
 @crm416 yeah it is tricky, here's how react made nested root event propagation work correctly: https://github.com/facebook/react/blob/master/src/browser/ui/ReactEventListener.js#L69
 "correctly"
  Thanks!
  It's arguable for `e.preventDefault()` to be called by `TapEventPlugin` if a handler is defined, but it's not always what you want and there would be no way of "undoing" it, I don't see a way around that.

Since what's really going on here is the browser trying to play nice by emulating mouse events for touch, a way to selectively disable emulation is an idea. But node-wise sounds kind of useless (and becomes yet another reserved non-standard attribute) and I'm not sure how you would do it "owner component"-wise, it would probably introduce additional issues for when components are supplied as children to another component.

PS. You can currently return `false` instead I think, but that's about to be deprecated it seems, so don't do it. :)
 It seems this is a wide-spread issue, some quick googling reveals that a lot of people seem quite confused about what to do, didn't find any useful answer during my quick search. Additionally, it doesn't seem to be `preventDefault`able in IE10 if "some guy is right".
 @piranha It also means you have to support touchevents for all components, you cannot fallback in places you don't care.
 @s0meone Hmm, regarding 750ms, are there actually emulated mouse events that fire delayed from the touch action/does not have a touch action? I would assume that a delay of "0" would be enough (if it happens immediately it's from the touch event, else it's from a mouse).
 @s0meone Oh right, the click/tap event has "intentional" delays, but all other emulated mouse events I assume would be called immediately.
 @s0meone I was talking about the "browser-imposed" click delay. Hmm, it's interesting that there's a delay on `mousedown`, could it be that the delay is actually because of significant processing associated (i.e. re-rendering) with a touch event, which would delay the emulated mouse event?

Intuitively I would expect emulated mouse events to fire in the same frame as the touch events (but not necessarily with the same timestamp), if so, simply setting a global `touched = true` and clearing it with `setTimeout(, 0)` would be more exact. (Obviously can't be used for click though)

And I'm assuming you've checked that there aren't properties added/set for the emulated mouse event that would indicate that it's emulated?
  > I've added a test case for this and it succeeded, though since 04c982 it seems I can't run any tests at all (even on master).

Try `rm node_modules -r` and `npm install`, that usually does it for me when tests no longer work.
 It sounds like there may have been a bad merge there:

https://github.com/facebook/react/pull/1601#issuecomment-52408879
 @erikbrannstrom Rebasing is fine, but you need to rebase your local master branch first (i.e., pull against upstream) and then rebase your PR-branch against your local master branch.
 @erikbrannstrom I think you need to fix it. Don't quote me on this (so copy relevant files first if necessary), but I think if you pull/rebase master against upstream master, and then rebase this against your local master (and force push) that this should be corrected.
 @erikbrannstrom No problem! It wasn't long ago that I was just as git-confused myself (_ahem_ #459 :)).
 This is fine for simple components, but a very common pattern is for a component to wrap and extend an existing component.

Pulling from your test, let's pretend FancyComponent exists. It's sole purpose is to be a specialty version of Component. Ignore the fact the this composition here doesn't really make any sense.

``` js
    var Component = React.createClass({
      propTypes: {
        type: React.PropTypes.string
      },
      render: function() {
        return <span>{this.props.prop}</span>;
      }
    });

    var FancyComponent = React.createClass({
      propTypes: {
        color: React.PropTypes.string
      },
      render: function() {
        var {color, ...props} = this.props;
        // do something with color maybe
        return <Component {...props} />;
      }
    });

    ReactTestUtils.renderIntoDocument(<FancyComponent color="green" type="alert" />);
```

This is going to warn me - `'Warning: Prop 'type' was not expected in 'FancyComponent'.'`, but it's actually a totally valid and encouraged use. I mentioned this in https://github.com/facebook/react/issues/1587#issuecomment-43940474

We've talked about doing this for a while and I think we'll get there, but we need to build this composition knowledge in better. Until we have a clearly defined path for that, this is just going to be really noisy.

So put simply, while this is a great effort, we just can't take it :/
  `{...myObject}` implies cloning (to an empty object), AFAIK, and is not strictly a React issue.
 The immutable objects advocated by React are simply plain objects that you don't mutate. Using immutablejs should be no problem (AFAIK) with React unless you make the props-object a non-plain object. Which is a general issue with JS, there is no facility for cloning objects, avoid using immutablejs for the props-object and it should be fine?

As for `{myObjects.map(object => React.DOM.div()}`, sounds like JavaScript iterables or something should be implemented and supported by immutablejs and React.
 We don't have first-class propTypes support for immutable-js, the same way we don't have propTypes support for backbone models. Until immutable stuff are built into JS (es7/8 please!) I think propTypes will have to stay this way, for the better.
 @chenglou On another note, I'm curious, would it be imagineable to turn propTypes into an addon/mixin instead? I'm guessing it couldn't use `componentWillMount` as `getDefaultProps` would already have been added, perhaps if we expose another life-cycle method? It's not a core React feature and I'm sure a significant fraction don't use it, or have varying preferences.

Anyway, not really pushing for it, it just seems natural to shed things that aren't intrinsic to core.
 Now that [Flow](http://flowtype.org) is out, guess this issue is less important? Just need to have immutable-js type checked with Flow (@leebyron).

Someone could also make a new mixin a-la propTypes for immutable-js.
 Yeah, the practice that I've been using is to refer to the `Immutable` value as a prop:

``` js
<MyThing data={immutableMap} />
```

I usually do similar with state being an object with a single key.

For propTypes I use a technique similar to @davidtheclark's proposal.

---

Object spread operator (`var obj = {...spreadMe}`) doesn't work with Maps of any kind, ES6 or Immutable. It's sugar for Object.assign(), and it's usage within JSX is the same:

``` js
<div key="foo" ...myProps />
// becomes
React.createElement('div', {key:"foo" ...myProps})
// becomes
React.createElement('div', Object.assign({key:"foo"}, myProps))
```

I don't think it's likely that props will move from Object to Map anytime soon, but it's certainly possible to create a custom version of JSX transpiler which generates Maps instead of Objects.

---

Mapping over collections (Immutable or ES6 or otherwise) has been possible in React master branch for some time now and will be included in v0.13

```
// v0.12, toArray with Immutable collections, not possible with ES6 collections
<ul>{{immutableItems.map(item => <li>{item}</li>).toArray()}</ul>
// v0.13, works fine for all iterables.
<ul>{{immutableItems.map(item => <li>{item}</li>)}</ul>
```
 @leebyron 

> I don't think it's likely that props will move from Object to Map anytime soon, but it's certainly possible to create a custom version of JSX transpiler which generates Maps instead of Objects.

From my understanding that seems counter-intuitive, isn't props what Objects are intended for? A rather static set of keys, used over and over... whereas Maps are for dynamic lookups?
  Thanks!
  `this.refs[name]` is not verbose.

Anyway, it's most likely going to change:
https://github.com/reactjs/react-future/blob/master/01%20-%20Core/06%20-%20Refs.js
 We're going to make refs to DOM nodes be the node soon.
  Thank you for the PR, and sorry about the long wait. Now that #5714 is merged, all attributes on SVG elements will be passed through as is, with no need for the whitelist. I'm closing this but please let me know if you have any troubles in master.
 In the next release, that is, 0.15. 
  @taddei Yeah, that's "expected", React attaches event listeners to the document. iOS doesn't fire click events for nodes (at all) unless they seem "clickable" (i.e., has a click event listener or `cursor: pointer`).
 See #1169.
 This should have been fixed in 0.14 already.
 This is closed which indicates no one is looking at it.

But http://react.jsbin.com/mimovoluci uses React 15 and works on my iPhone. Can someone post an example that is broken?
 Oh, I totally misunderstood you. It is expected that you get the same click delay as any other onclick handler. The bug that this was tracking is that clicks didn't work _at all_ on iOS. You have to use something like react-tappable that listens to touch events or a script like fastclick.
  In case somebody doesn't want sourcemaps (eg, react-rails) or r.js

Should fix #972. cc @philix @thomasboyt - Looks like you can stop shipping a modified JSXTransformer (or whatever we end up calling this by the time 0.12 happens - cf #1966)
 :( That's unfortunate. It actually sounds like an esprima bug because there's not reason it shouldn't be able to parse a string like that.
 We should probably have this discussion elsewhere but whatever‚Ä¶

I'm actually a bit surprised about r.js... esprima via npm and r.js (via npm install requirejs, which actually packages the same version of esprima, 1.2.2) can both parse this piece of code. I think it covers the same ground that your changes are working around.

``` js
"use strict";
console.log('hello world');
console.log('"use strict";');

var s = '';
if (s !== 'use strict') {
    console.log('use strict');
}
```
  Sorry for the delay! TBH, I'm not totally sold on the specialized message like this. In the case of `undefined` (which is what your case really catches) it could be anywhere in the stack with something being misspelled or exported wrong.

Would it make sense to roll this into the other message? Perhaps check the `if ... in ...` case and append something like "Did you mean to pass undefined to onChange?"

cc @spicyj
  Work in progress. `enterleave` plugin (and maybe `analyticsPlugin`) is broken because it relied on the old behavior. But wanted to put this out here for suggestions. There are also some comments that need to be changed, I'll do it when the code is finalized.

If we attach the event listening/dispatching at container level, it'll benefit the case of `<Editor/><Plugin1/>` (both are container roots), since `Plugin1` won't disturb `Editor`.

We also detach those listeners now. There wasn't really a need in the past.

@spicyj @zpao @nathansobo

Fixes #2043
Should help with #1964
 Didn't consider nested `renderComponent`. Will take care of that later =(.

Edit: seems like it took care of itself in `ReactEventListener.handleTopLevelImpl`.
 :+1: This should be a major step towards playing nice with non-React DOM and separate React instances.
 @nathansobo what else do you need for react atom to get faster?
 @nathansobo this is kind of a big change and it's not set in stone. And frankly I'm not even sure how much this helps. 
 @chenglou It seems to me that it is a critical step towards playing nice with other frameworks and instances.
 I think at this point we aren't going to do this. We can revisit later if we need.
  Fixes #427
- [x] Test plan: will test against our application with the browsers I have access to.

PS. View changes with ?w=1
 :+1: 
 Note: I assume that mouse coordinates that originate from an iframe are currently incorrect for IE8, this PR does _not_ fix that.
 cc @yungsters @salier @joshduck 
 Sorry for slacking off on this, I'll create a manual test to ensure it's working as intended.
 I've have rebased and tested against our own application, no apparent issues. Our app is not very event-heavy so it's hard to be absolutely sure but it works great in the few places that are, I've reviewed the code changes a few times and not found anything funky.

PS. Also submitted #2328 for tracking any info on the weird IE8 comment.
 https://github.com/facebook/react/issues/2328#issuecomment-58822097

I'm quite certain that is the case. I don't think `document` can actually be a target for an event, but I chose to go the overcautious route and use:

```
target.ownerDocument || target.document || target
```
 I am going through old PRs and closing the ones that have been stale for a long time. In this case I think it‚Äôs a great change but there hasn‚Äôt been enough momentum to get this shipped, and the support risk is relatively high. In the future we might have some more eyes on the DOM side of React, and I have no doubts we‚Äôll get to this eventually. For now, people can track #427. I am closing and adding a ‚ÄúResolution: Unsolved‚Äù label here for posterity. Thank you for your work!
  #554 

There seems to be lots of related issues/bugs, the browsers simply don't seem to provide a hook for it. Personally I just roll my own versions of all the components I need except for basic text fields.
 (Dupe of #554.)
  The caret doesn't jump when you update `value` (to the new value) because it has the `HAS_SIDE_EFFECTS` flag in the React, so React polls the DOM before updating the value. This prevents the caret from jumping.

Polling `innerHTML` would not make much practical sense at all I think, it could be prohibitively expensive and for most cases you wouldn't want it. I think there's some experimentation going on with controlled content-editables, but uncontrolled is the only sane way for now AFAIK.
 @cody Updating from script inherently resets the cursor, there's no way for the browser to know where the cursor is in the new content. You need to get the cursor position before setting and restore it after.

PS. Also beware of _tons_ of undo bugs when you set from script.
 Realistically I don't think there's anything React can/should do here, closing as `wontfix`, reopen if you disagree.
  > As with most library/framework sites the examples of "getting started" is too simple

Amen :+1:

Personally I use webpack + a custom resolver to avoid having to specify paths, I also use a slightly tweaked uglifyjs which allows me to mirror the original line-breaks as closely as possible, which is awesome for production errors.

But yeah, even setting up the config for webpack for the first time isn't that simple.
 Both of these are reasonable starting places:

https://github.com/rackt/react-boilerplate
https://github.com/petehunt/react-boilerplate

Maybe we can link to them in the docs somewhere.
 @madebyherzblut https://gist.github.com/syranide/07c6897c005fa9bc70e4

Beware though, unless you run my branch of uglifyjs, you explicitly do not want to use `preserve_line: true` (it's broken, and `no_empty_line: true` is not standard).
 Going to close and track as a part of #5679
  Suppose you have:

``` js
var TaskHeader = React.createClass({
    render: function() {
        return <div className="task-header-mid-container">
            <img />
            <h2>I'm a task!</h2>
        </div>;
    }
});

React.renderComponent(<TaskHeader />, $(".task-header-container")[0]);
```

and then you intend to run

``` js
React.renderComponent(<ADifferentTaskHeader />, $(".task-header-container")[0]);
```

to replace the header but accidentally run

``` js
React.renderComponent(<ADifferentTaskHeader />, $(".task-header-mid-container")[0]);
```

instead.

You should get an error or warning because you're blowing away the React-rendered contents of `.task-header-mid-container`, but none is given. You actually get the server-rendering checksum warning, but that's more confusing than anything and we should have an explicit warning for this, much like the one you get when calling setProps on a non-root component.
 @crm416 I know you were looking at #1858 ‚Äì maybe you'd be interested in looking at this too.
 Good first bug?
  This should work in master now with PropTypes.element (though you may actually want PropTypes.node)
 @zpao The example is incorrect. It doesn't call the React.DOM.div factory.
 @contra Oh. No, there used to be isValidClass but that's deprecated and going away. https://github.com/facebook/react/issues/2374

Basically, the issue is that almost any function can be a valid class in 0.13 since almost any function can return a valid instance and we support arbitrary class patterns. We might also support non-functions to support the module pattern. In 0.12, strings are also valid for constructing instances because that's how HTML tags are specified.

I think that the solution is usually to try to go more specific. Can you elaborate on your use case where you pass classes as props?
  @nathansobo will that help your event perf issues a bit? I'm not familiar with atom's plugin infrastructure, But this'll help if you have `<Editor/><Plugin1/>` (two `renderComponent`s). Doesn't help if you have `<Editor><Plugin1/></Editor>` though, but I have some ideas to optimize events a bit more.

This is nonetheless an ok idea, I think.
@spicyj 
 @nathansobo Can you clarify what you mean, "without requiring the use of the shadow DOM"? I'm a bit uninformed about how HTML custom elements work right now.
 @chenglou It seems we have your #2050 to track this. Closing, reopen if you disagree :)
 @syranide I don't see why we should close issues just because there's a PR open ‚Äì what if we don't go with that particular implementation? We may still want to make the same fix.
 @spicyj Fair enough :)
  Give it a non-falsy value (i.e `true`) and it works.
  Add it to https://github.com/facebook/react/wiki/Complementary-Tools :)
  Nope. Ill just fix that PR and pull it in quick. 
 @crm416: @sebmarkbage has spoken. You can take out that `monitorCodeUse` completely; I just tested internally and the important things don't break, so we probably don't need to track that anymore. Sorry for the back and forth!
 @sebmarkbage ^
I think this should be ok? It's kinda hard to track and there's apparently no important users of `return false` anyways.
  What about just:

```
      'Tried to merge two objects with the same key: `%s`. This conflict may ' +
      'be due to a mixin; in particular, this may be caused by two ' +
      'getInitialState() or getDefaultProps() methods returning objects with ' +
      'clashing keys.'
```
  I like this.
 I know I told you that getDefaultProps in statics should work but now that I'm looking again, I'm not sure if that was actually intended:

```
  /**
   * Special case getDefaultProps which should move into statics but requires
   * automatic merging.
   */
```
 For now, maybe it's best to throw an error if getDefaultProps is in statics.
 Although you'll probably be very confused if you use `componentDidMount`, etc. as static properties, I don't think there's a real reason to disallow it ‚Äì I think getDefaultProps is the only problematic one because that gets stored on the constructor.
 Yes, I'm an idiot. Carry on.
  On the surface, your request is out of scope for React. Note however that in most cases, you don't need to find nodes based on a selector. For example, if your component looks something like:

```
var MyComponent = React.createClass({
  render: function() {
    return (
      <div className="mycomponent">
        <h2 ref="header">elephant</h2>
        <p>zebra zebra zebra zebra</p>
      </div>
    );
  }
});
```

then you can access the `h2` DOM node by doing `this.refs.header.getDOMNode()`. If this isn't flexible enough for you and you really do need to reach into the DOM, jQuery is a great solution ‚Äì but you usually don't need it.
  Thanks :) I may have oversimplified just a bit in the other issue - I didn't look closely at what was involved with dialogs.

How does one use a `<dialog>` in a React world? Looks like we might want to add support for the `open` attribute as well (according to [MDN](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/dialog) anyway). Otherwise it looks like it has to be via refs + getDOMNode.

We don't have tests for our actual supported elements but for things like this it would be good to paste some sample code here (or in a gist) or just describe how you made sure this worked in React.
 Thanks!
  The short answer is that each time createClass is called, a unique `type` function gets created, which is used to determine type identity and if the next component is the same as the previous component.

In [`React.renderComponent`](https://github.com/facebook/react/blob/master/src/browser/ui/ReactMount.js#L356-L368) we call a function to do this type check. [`shhouldUpdateReactComponent`](https://github.com/facebook/react/blob/master/src/core/shouldUpdateReactComponent.js#L33-L41) is what does the slightly more complicated than what I said check.
 Today, yes that will hold true. We're going to change a bit of the interaction between the return value of createClass and JSX, so the simple function call might not work forever. My advice would be to not wrap our APIs and let our values be used with our APIs as much as possible.

Do you have a specific use case in mind or just figuring out how things work?
  There are a few technical qualms I have about this. But first, let's decide if we even want something like this. I do wish you would have proposed this somewhere before just doing it. Discussions should be had before making non-trivial architectural changes.

@sebmarkbage @jordwalke @petehunt thoughts on this in general? Opening up the doors for anybody to define how any method on a component can behave sounds like a recipe for compatibility disaster.
 Global method overrides creates compatibility issues. We could possibly do this on a component basis, but that defeats the purpose of having mixins do all the boilerplate. I think explicit chaining of super calls would solve this issue with minimal extra boilerplate: https://github.com/facebook/react/issues/1380 
 Isn't this kind of solved by itself in 0.12? (unless I got it wrong)

Then, you'll supply the class and not necessarily have it created by `React.createClass`, which means that you can simply augment the prototype or create the class however you like. You can do this already by reaching into `MyClass.type.prototype` (or augmenting the class object you send it), I haven't tested it and perhaps there's something preventing auto-bind from working there?

**EDIT:** Hmm, perhaps I misunderstood the actual request here, but it seems like turning `React.createClass` into a framework for creating classes is to go the wrong way (people want inheritance, etc, etc and drawing a line is rather arbitrary).
 @anatolikurtsevich Sorry, I was a bit unclear perhaps, what I meant was that this goes one step in that direction (in my opinion), inheritance is another and there are plenty of other requests for similar features. I don't know how the devs feel, but I feel as if `React.createClass` is a bit of an abomination, React shouldn't concern itself with how classes are created, it's a very grey and complex area and subject to much debate (especially as ES6 classes will be around some day).

The React mixin-behavior with the magic `DEFINE_MANY` flags is nice, but it's also very very weird. If this is not something that is a traditional (mixin) pattern, then perhaps the solution is not to have `DEFINE_MANY` at all, but to e.g. have `addLifeCycleListener` which mixins would be free to call during initialization. Mixins could be applied as a call from the constructor to `MixinX.constructor.call(this)` rather than `Mixins: [MixinX]`.

I'm not necessarily proposing that as _the solution_ (I'm sure there are better ones), but as an example, it uses only traditional patterns to solve the problem and would move the entire responsibility of how to create classes away from React, rather than give React more responsibility. It's now a clear-cut division of responsibility and React no longer forces users into a specific "interpretation of classes". React can certainly still provide helpers.

Again, this is up to the devs, but that's how I see it.
 I'll close this out and refer to #1380 which does provide a solution to this problem but we might need a pre-ES6 alternative to do this as well. Let's handle it all in one issue.
  @ghost23 You can already do `React.createElement('clipPath')` or `<clipPath />`, right?
 We'll bring this in but it didn't make the cut for 0.13. Note that any new attribute is a potentially breaking change.

``` javascript
var Component = React.createClass({
  return <div {...this.props}><span>Clip: {this.props.clipPath}</span></div>;
});
```

This is currently ignored but will now start transferring to the DOM. It is probably safe to assume that the DOM ignores it but in the case of nested SVG children it might not.

We're working on getting rid of the whitelist completely. Step one is #3104
 I believe it should be support in JSX in 0.13 RC2.
  ~~Related #759~~

~~It's very much possible and technically shouldn't be _that_ hard. However, from the discussions so far the devs most likely don't want to officially maintain JSX for any non-JS language out there. I don't think they should either, it's arbitrary and better left for the community, in the case of TS there are syntax conflicts that need to be solved/worked around.~~

~~If there's a robust solution that covers the vast majority of languages at the same time it would perhaps make sense, but perhaps an unlikely reality.~~
 Oh ofc. Although it may not be the entire story, it seems that the next release (0.12) will not feature `React.createClass` as a requirement, but you will provide the class to a function similar to `React.createDescriptorFactory` instead. That and there's a lot of work being done to make React statically analyzable which I imagine will go some way to improving this some more, but I believe `React.createClass` is the by far biggest issue with TS today?
  Thanks!
  The sentence isn't redundant; the first group refers to es5-shim; the second, to es5-sham.
  :thumbsup: thanks!
  Related #723, it's complicated because vendor-prefixes are there for a reason and simply acting as if they weren't there means disregarding at least a part of an intentional design decision. For run-time styles, for maximum performance, one should feature test the browser and only apply styles that are valid (and perhaps fall back to a different layout entirely sometimes). Only for server-rendered DOM would the full list of variations be output.

I have no practical advice/insight here for the time being though.
 Right now the only way to do this exactly as you want is with regular CSS. Stylus/nib generate CSS so it works for them. We operate on the DOM node itself which doesn't allow you to specify multiple values like this.

You could do what @syranide said and feature/browser detect before specifying the style value. I actually think that's something a whole library could be built for to target React users, but I don't think React should do it itself.
 FWIW, that hack only works on initial render and only because we use `innerHTML`. Any updates to `display` will then break. If at some point we change to actually using `createElement`, there is no guarantee it will continue to work.
  That errors comes from `document` not being globally defined I believe.
 Here's the block that determines if we are in a DOM environment: https://github.com/facebook/react/blob/master/src/vendor/core/ExecutionEnvironment.js#L23-L27

And here's the block in jest where we set up jsdom (well, mostly): https://github.com/facebook/jest/blob/master/src/JSDomEnvironment.js#L25

@jeffmo might have a better answer about this, but it certainly sounds like it's not a React issue, but a config issue of some sort. We can reopen if it is though!
  :+1: 
  ~~You'd also need to polyfill it for other browsers, which gets complicated I think.~~

Edit: nvm.
 @chenglou Well no, we have lots of tags that we don't polyfill but simply output as-is.
 @pekim Adding it to ReactDOM is part of it. The other part is making sure the JSX transform catches it. It looks like we already do - https://github.com/facebook/react/blob/master/vendor/fbtransform/transforms/xjs.js#L54.

So if you want to submit a PR, you can have some blame in here :)
  Cool, thanks!
  Ah, looks like the bot didn't respond when you did sign this :( Somebody came along and fixed this the other day (#2058). I'll take a look at the bot and see what happened so hopefully it doesn't happen again.
 The same fix was made in #2058 and merged before we got back to this. The site may not be updated to reflect this yet though.
  Not sure what the devs feel, but it's technically invalid to have both `border` and `border-color` at same time (in the style object). This also affects performance as one style update has now become two. Invariant/warning may be preferable here. The only case I can make for this is animating foreign style objects, but I'm not sure why you would do that.
 @syranide Is it really invalid? I often write something like

```
border: 1px solid #000;
border-style: solid none;
```

to get borders on only top and bottom.
 @spicyj That's why I added "in the style object" :). `border` is an alias/shorthand for all the other properties, you cannot set both and then unset only one of them. However, that being said, supporting this is not bad in itself (it's the most intuitive solution to ambiguity), although I would be careful to compare it to CSS as there you can do:

```
border-style: solid none;
border: 1px solid #000;
```

... and only the last line would end up being used, this is not something we can offer (because: map) and there's no reason to either. There's no harm in supporting this I imagine, but it does add bytes, it adds redundant bytes to the generated HTML too and it does have a non-obvious performance implication (apart from actually adding more styles to be set initially too):

```
border: 1px solid #000;
border-top-color: #ff0000;
...
```

... adding/modyfing/removing only `border` will require **all** additional border properties to be restored (and this applies to `border-style` and friends as well). Is it a real-life performance issue? Probably not, but it is a consideration. I think the biggest danger here is laziness, given that this performance issue is rather unintuitive/unexpected in some sense, it could come to bite a number of people (especially if inline styles become more common).

So there's no doubt to me that this would be the best/correct solution, if for example we would parse `border` and `border-style` and merge it into only a single `border` style update. However, considering that this is a hot path and it always will be, I don't see that happening (for other reasons too) and perhaps it's better left to a user "style callback"/"border helper".

So I wonder, is there any "valid" use-case that would require this, that would offset the hidden danger? 

**EDIT:** As spicyj mentioned, being able to set all borders and remove one is a pretty common pattern in CSS, so there's that...
 The test shouldn't mutate.

This pattern currently relies on enumeration order. This might not be possible in the future (e.g. using ES7 value types). We might need to rely on alphabetic order. We should consider not allowing conflicting style rules at all.
 Thank you for sending the PR! It has not been updated in response to the feedback for quite a while, so I am closing. For an up-to-date issue about this with a summary and the discussion of the desired behavior, please see #6348. We hope to see you contributing again!
  Duplicate component*-methods are all called, they are not replaced. Anyway, you are free to implement whatever form of class composition you want to create the object for `React.createClass`, mixins are just a convenience. I suspect `React.createClass` will also be deprecated as part of 0.12, or remain only as a helper (I'm not 100% sure about the details).
 @AdamKyle https://github.com/reactjs/react-future/blob/master/01%20-%20Core/05%20-%20Elements.js

Most of the information is kind of spread out, and in some ways it's simply being renamed I guess. But the idea is that _you_ will supply the class and you can ask React to create an "element factory" from it (`React.createClass` currently creates the class _and_ element factory). This means that you're free to use ES6 classes if you want, or any other class utility you prefer.
 > Why can I not use inheritance to say "did my component mount, yes do this - oh and call the parent

It's not clear to me what you really want. The code you have in your example calls both methods.

> yes they are called but it errors out stating that you have defined this else where

I haven't seen this be the case. Only 1 lifecycle method restricts itself to be defined once (`shouldComponentUpdate`), the rest are all chained. If you had a repro case that would be helpful.

There's more discussion about the future of mixins in #1380.

There doesn't appear to be anything currently actionable here so I'm going to close out.
  cc @syranide our resident event export these days
 Haha, I believe I've seen some code in there that's meant to fix this, I'll have a look tomorrow and see what's going on. @leoasis I'm curious what you need this for.
 @leoasis That sounds like something you could/should solve with `onMouseEnter` and `onMouseLeave`. There's generally no reason to use the reported nodes in an event for React. That being said it should still be fixed.
 @leoasis So `onFocus` and `onBlur` then? Or whichever event fits your use-case. It's your choice obviously, but I'm quite certain that your solution has a React-only solution.
 @leoasis `event.stopPropagation()` I think?
 Yep, your choice, but AFAIK, the React-way would be to handle it in the children and propagate a callback through props instead. Anyway, I'm going to have a look at fixing this either way.
 @zpao @leoasis OK, so `event.nativeEvent.relatedTarget` is apparently always `null` in FireFox (and IE11) for `FocusEvent`s. The `FocusEvent` does not provide _any_ information on the element being focused. So there doesn't seem to any easy fix for this that isn't `relatedTarget = null`.

I imagine it could be solved by simply keeping track of the last focused element, but I suspect that it's more fragile in practice than you would expect, so it would probably not be a great fix. It also doesn't really fit with how React is meant to be used...

~~So that's another interesting topic, how should/would you accomplish this with React? There's inherently nothing we can put in events that would make sense, I think. You could probably track focused element in the parent and if the parent discovers it doesn't have a focused element during `componentWillUpdate` (can't call `setState` there...) it would be the signal to close, batching should prevent the time between blur to focus from being a problem I think.~~
 Follow-up to the previous, I haven't tested it yet, but I imagine `onFocusIn` and `onFocusOut` is the correct solution to all problems? (both React and non-React)
 Hmm, it says listening to `focus` with capture should have a similar effect (`onFocusCapture` in React I think?), perhaps there's something there we can use to shim it... although the persistent threat of `event.stopPropagation` being called outside React's control is always there.
 @nbergseng I'm pretty sure the correct solution is to use `focusin` and `focusout` unless you have a very specific use-case.
 @ezequiel They kind of are, `focus` and `blur` bubbles on FF. Regardless it can be normalized by React, I don't remember if it is or isn't right now, but if it isn't we should normalize it.
  `withContext` is still unofficial and there are varying opinions on its legitimacy I believe.

~~I'm curious why there is a `constructAndRenderComponentByID`, it doesn't sound like something that needs to be exposed (especially with that unintuitive name).~~

The other 2 are deprecated.
 Yea, the other 2 are only relevant to FB (allows some special cases) and we're going to remove them soon. They really should have been removed before we even open sourced. I agree on not documenting `withContext` yet. We're still working on the context story.
 We're going to need to do a pass through all of this before next release, but this looks better. Thanks!
  We're in the process of building up more Flux documentation in the https://github.com/facebook/flux repo.

Feel free to keep discussing here but I'm going to close out - I don't know how much we're going to actually do here vs the flux repo.
  Awesome, thanks!
  It only got public a week ago btw.

Pull request welcomed!
  :+1: 
 I'm going to take #2824 instead but I really do appreciate you taking the time to work on this. I'm sorry we let it sit here for so long!
  `<MyComponent>{real dom node}</MyComponent>`

Should work and not trigger the warning where we try to enumerate all the keys of the object.
 :+1: ... is it actually possible to insert DOM nodes like that today?
 Hmm, I can't seem to repro the errors I was seeing internally, let me make sure we're all synced an there isn't something else at play.

> do you want to subscribe to all the children DOM node events and delegate their handling to owner component

No, we aren't doing anything at all with these nodes, just simply making sure don't break if a DOM node is passed as children. I think it should be a simple as skipping a loop somewhere.
 @RReverser This issue is specifically about the key check in ReactDescriptorValidator; you should be able to specify a dom node as `props.children` to a custom component that does something intelligent with it (like your ReactDOMWrapper).
 Kind of unrelated-related (#1991), wouldn't it make more sense to move the check to the rendering stage instead? I feel that props should simply be opaque values, what a component does with them is its concern (i.e, sending children as a prop instead of `children`, or some kind of template:y thing where not all children are rendered as-is). Warning-wise we would lose information about the "creator" as-is, but I'm pretty sure that it is something we want to change sooner or later anyway and keep a reference to the creator of each descriptor.

Again, perhaps not something worth digging into for this issue, but it may be worth keeping in mind.
 @syranide It would, except by doing it at descriptor creation time you get a call stack that includes the actual render method.
 Haven't heard any more of this ‚Äì @zpao please reopen if you have.
  It was :)
  I'm pretty sure this is actually correct as-is. In fact, your suggestion

> make sure to never access as a property that was specified as a string

isn't quite right, although

> make sure to never access a property that was specified as a string

would be too. Here, "what" is like a pronoun that means roughly "something that".
  https://github.com/facebook/react/blob/master/src/vendor/polyfill/Object.es6.js#L23
https://github.com/facebook/react/blob/master/src/browser/ui/React.js#L23

This goes against our "policy" (AFAIK) for dealing with polyfills/shims, if we want to ship the polyfill it should be returned and not shim the global Object.
 cc @zpao @spicyj 
 I thought I had another issue here somewhere about this but can't find it. We're probably going to need to cave and ship something that modifies the global Object. We'll have a better story by the time we ship 0.12.
 The whole point of polyfills is that you use the same syntax you would if it was supported in the environment. `Object.assign(...)`, not `require('objassign').assign(...)`. Otherwise you need to teach _everybody_ to use that module. And then change all of your code when it's natively supported.

We're also going to start supporting some native ES7 syntax in our transforms which will desugar to use `Object.assign`.

Eg

``` js
var a = {foo: 1};
var b = {...a, bar: 2};
b; // {foo: 1, bar: 2}

// transformed becomes
var b = Object.assign({}, a, {bar: 2});
```
 For something like Object.assign it's possible that we could pull out all the calls at build time but for things that modify built-in prototypes (like Function.prototype.bind) it's not.
 I assume we just shouldn't ship `Object.assign` with React (as with all other polyfills), but there's no obvious/suitable package/library right now?
 @syranide that's what we need to figure out before we ship 0.12. It might make more sense to ship this polyfill since it's still new (spec changed last week) and we can control distribution a little bit better. It would definitely be a change for us. There's a problem looming in the likely-not-too-distant future where Maps and Sets are used and we have a bigger polyfill problem.
 If we will require support for non-string indices... yes, that would be an issue. :)

You can always fall back to an implementation that mutates non-string keys, which may be acceptable where the injected property could be made non-enumerable, but that's not supported by the oldest of browsers (IE8, and perhaps the Andriod 2.x browser?), cloning might be an issue? For the oldest browsers, I imagine that it would be possible to hijack a default non-enumerable method and replace it with a pass-through function, but one which we could inject a property into without fear.

Or what's the plan?
 We'll figure out the details before we ship.
 Not going to polyfill, will just use our own impl and not depend on `Object.assign` existing. #2350
  Do you have a repro? Very simple testing on my end doesn't show any obvious issues with it in IE8 (don't really know what to look for either).
 We actually have some other changes coming through to this polyfill after TC-39 meetings last week where the behavior of `Object.assign` is being changed slightly. We'll sync that out shortly. And I'll let @benjamn and @sebmarkbage comment with their thoughts here. (I have style comments too, but I'll let them decide big-picture first)
 @zpao We actually have a separate polyfill for IE8 so that those bytes don't get shipped to other clients. Maybe we should sync that out too somehow?
 @bloodyowl Thanks for jumping on this and reminding us. We're going to just use our own polyfill code for now to make it easier to keep things in sync. We'll end up with a little bit of duplication as a result but that's ok.
 @bloodyowl If your IE8 polyfill is forwards-compatible, can we use that here instead?
 Never mind, I see #2023.
  Yup ‚Äì good catch! Just fixed in the docs source.
 `// This must be exactly one element or it will throw.`, say what? No it won't...
 Well the prop types will warn‚Ä¶
 @spicyj Right, but it won't throw... and especially not there.
 Yea, that comment is wrong too, feel free to update @syranide :P
 :no_mouth: 
  This needs to also work in non-browser environments, at least for the time being. react-rails, react-python (React.net too I think) use this file to parse JSX in basically raw _insert JS engine_ processes. We could build & ship a different file for those cases, though I'm not sure how much we really care. 10% is a nice win but it's a dev tool for browsers so I don't think it needs to be terribly optimized.
 > Why don't those projects use `react-tools` instead?

Because we don't have a react-tools bundled file. It needs to be a standalone bundle, not an npm package. We could do that, and I'm thinking of getting rid of JSXTransformer in its current form and just doing that (see #1966). JSXTransformer currently happens to work just fine in both places so there's been no driving force.

Also, I meant "terribly optimized" in the best way. s/terribly/very/ and it's probably a better sentence. Right now the benefits outweigh the additional 10% size. I mean, we could also ship a minimized version (#1855) and shave off more, but we don't because it shouldn't be used for production where these things matter.

Let's talk in #1966 about what we can do for a possible ReactTools.js. In the meantime, I'm not going to make a change like this to JSXTransformer as it exists. I appreciate you making this and starting the discussion though!
  Not sure about the first one. But I love the other two!
 Ah nvm, misunderstood what that meant. I'm ok with that.
 @zpao 
 The changes to browser-transforms look fine. I think I have some internal changes to the actual transform I need to sync out. Let me get those done and we can figure out that part of it.
 Aren't we killing the pragma in the 0.12 release?
 Yea, it would seem so. I wasn't sure if that was going to end up coming in 0.12 or not. I need to do some syncing and finalize the plan for 0.12 this week.
 These tags will become strings. See https://github.com/facebook/react/commit/c4658c1728b39c452a86f371ecb1c51874456107
 `React.DOM` will still be available as helper factories for the non-JSX case. The annoying part is composite components where you're supposed to create a local factory helper. I'll elaborate more on why it is important and how it can be mitigated in a blog post.

One benefit is, IF you do have special language features, you can now reason about the input without expecting arbitrary functions there.

You will also be able to use plain objects as ReactElements. That's not possible right now because you don't know how many wrappers are around your helper function.
 > Not sure what do you mean. But I'll be waiting for blog post for further explanations :)

@RReverser I think it's simply that `<abc />` can return anything today, there's no guarantee that what you get is a "descriptor". This is obviously practically limiting as JSX is just sugar for function calls then.
 @RReverser I'm not talking about user error, but things like:

```
function Frag() {
  return arguments.slice(1);
}
```

or

```
function If(cond, elem) {
  return cond ? elem : null;
}
```

I'm quite sure things like these are already used out there from time to time. If I understood @sebmarkbage, he refers to making these explicitly invalid. So that `<abc />` can _only_ create an element/descriptor with the given arguments and is not necessarily sugar for a function.
  See #953.

cc @pamelafox
 Thanks for bringing it up @pamelafox! Always better to have helpful & polite messages than helpful yet anxiety-inducing messages :) We'll kill the message entirely sometime soon (right @spicyj? :wink:)
 Maaybe.
  Dissected from my #1570

Provides a human friendly path instead of just a rather opaque reactID. Chrome still has intermittent issues with long error messages being truncated, but this is supposedly fixed (again) in Chrome 37. No other browsers should have issues displaying the full error message.

Now that we have friendlier error messages, how far do we want go to "resolve" implicitly added DOM? Personally I feel like we should get rid of the "blind jumps" we do now (primarily missing `thead`), it seems like unsafe behavior and it would be preferable for users to just be notified of the issue instead (technically, they provided _invalid_ markup).

```
Invariant Violation: findComponentRoot(..., .0.1.0:0:0.0.0.0.0): Unable to find element.
This probably means the DOM was unexpectedly mutated (e.g., by the browser), usually due to
forgetting a <tbody> when using tables, nesting tags like <form>, <p>, or <a>, or using
non-SVG elements in an <svg> parent. Inspect: Root > DIV.0 > SPAN.1 > Children1 > Children2
> Children3 > FORM.0:0:0 > TABLE.0 > TR.0 > TD.0 > FORM.0
```

(That error message is for nested `form`, which is invalid)

```
 +3123   +798 build/react-with-addons.js
    +7     -1 build/react-with-addons.min.js
 +3123   +809 build/react.js
    +7      = build/react.min.js
```
 I added validateDOMNesting so I don't think this is as useful any more.
 AFAIK all the current errors that mention data-reactid are completely unactionable for someone unfamiliar with React's internals.
  You should always treat state like private instance variables and should never call `setState` except on `this` ‚Äì if you want to allow other components to set your state, you can expose specific setter methods. In this case, you should simply set the value in the DOM directly by setting `this.refs.textf1.getDOMNode().value`. You can also of course use controlled components and take advantage of React's data flow, which is recommended ‚Äì it takes a little more work initially but tends to be much easier to reason about down the road.
 ```
instance.state.value = 'something new';
instance.forceUpdate();
```

This is better as `instance.setState({value: 'something new'})`.
  Thanks! Sorry this was so tricky.
  Sorry this is so confusing, but you should actually send a PR to the master branch (or else it'll be lost when we make the next release).
  cc @benjamn - sounds like a commoner problem.
 I can't repro this in master. If you still can make this happen (perhaps with a smaller test case :wink:) then please let use know what version you're using.
  This is the html output that you don't have to touch. Here's the md file that generated it: https://github.com/facebook/react/blob/5d288deba5355f56b2f4380bc841aaf9a1f2ef00/docs/docs/09.4-test-utils.md

You should change that instead.
 You can change your commit locally and `git push --force` too btw.
  Kind of related to #1978 (concerns polyfills)

It seems to me that we should really treat server-rendering as distinct from client-rendering, they have different requirements and priorities.
1. Server-rendering should be able to generate optimal markup for SEO, markup must also be fully cross-browser compatible and small markup is preferable.
2. Client-rendering sees SEO as largely irrelevant, full cross-browser compatibility is also irrelevant and rendering performance is of greater importance.

So I propose that we treat server-rendering as uniquely distinct from client-rendering, e.g. as a separate flag`React.serverSide = true` (which would default to true if document is not available). It's even imaginable that we could extend this with e.g. `React.targetClient = 'SEO' / 'legacyClient' / 'everGreenClient'`, which would optionally allow the markup to be tailored for a specific purpose.

So when reusing server-rendered markup client-side:
1. The client should do an initial server-rendering pass being passed the exact same props (and time) as during the server-side rendering, but instances are actually allocated on the client.
2. Immediately afterwards a client-rendering pass is done with any props (and current time) you like, instances/markup is efficiently reused and should not add significant costs as little DOM manipulation should be involved.

I'm not really affected by this, but for those that do use server-rendering; this seems like the _correct_ way of approaching it (as opposed to just rendering everything exactly the same). However, I'm working on `img`\- and `picture`-element polyfills, but without this they cannot be made to generate sensible server-side markup.

**PS. I realize this can be done today using a global + mixin**, but without a standardized solution, it's unlikely that third-party (and polyfill) components could ever participate in this. But that doesn't mean that it needs to be shipped with React even (none of this requires core support I believe), as long as it's standardized.
 It's unclear to me what you're proposing. We already have ReactServerRenderingTransaction internally which makes a few things behave differently when doing server rendering. What else were you thinking might differ?
 The way server-rendering is handled internally does not allow for different nodes to be generated, only different attributes. What I'm proposing is exposing an API for being able to have server-rendered markup be (potentially) entirely different to the client-rendered markup. For the purpose of better SEO, UX and speed.

What I'm suggesting is the _general idea_ of this:

```
render: function() {
  if (this.isServerSide()) {
    return <div><Button ... /><Content hidden ... /><script ... /></div>;
  } else {
    return <div><Button ... />{this.state.expanded ? <Content /> : null}</div>;
  }
}
```

I.e that you can generate completely different markup server-side without affecting client-side performance, the script-block above could theoretically allow the button to show/hide the Content-component until the page has finished loading, the same approach could also be used for SEO-purposes or for limiting the size of the generated server-side markup.

Personally, my `img`\- and `picture`-element `srcSet` polyfills **require** this for them to at all work after server-rendering. As rendering `img` and `picture` as-is without clearing `srcSet` on browsers with no/partial support will break.

So to me it seems that exposing e.g. `this.serverSide()` AND introducing new behavior for reusing server-rendered markup is the correct solution. E.g something like `React.renderComponentAndReuseMarkup(serverDescr, clientDescr, targetNode)`, when reusing server-rendered markup, the client would first render normally using `this.serverSide() === true` and `serverDescr`, immediately afterwards it would render again with `this.serverSide() === false` and `clientDescr` instead. DOM generated by the server has been reused (as much as possible), while also enabling server/client to generate tailored markup.
 I'm assuming contexts would be the right and super easy solution to this, it would just need to be standardized to _really_ make work and be usable throughout.
 @yaycmyk "parse this server-side code out of the JSX client-targeted bundle at bundling time" huh?
 Don't we already re-use existing markup for isomorphic apps?  Isn't that the point of the the checksum?

I'm not entirely sure I understand the motivation for having components render different markup if they're on the server side.  You're just adding more branches/codepaths that need to be tested/maintained (the point of isomorphic rendering is to avoid exactly that, otherwise, just implement your SEO version separately).  Also, sites are penalized if the content they display to users deviates from what they show Google, so I'm not entirely convinced this is a good SEO story in the first place.

My intuition is that: We don't recommend this, but we aren't going to stop you.  If you're going to do this, you can use a global.  This is probably not behavior that third party components should be participating in.

Is there a specific example usecase that isn't easily handled with a implementation-specifc global?
 @jsfb You can't do feature detection server-side, hence most complex inline styles and polyfills are impossible to do server-side, there's also no way to generate placeholder content and apply the styles/polyfills once the client-side mounts as there is no transition taking place. I worked on a Picture and ImgSet polyfill which works great, but it's impossible to make them work _at all_ when server-rendering, it simply cannot be done at current.
 > as there is no transition taking place

Perhaps I'm miss-understanding, but couldn't you do a forceUpdate when the page loads to update the placeholder content?  Perhaps triggered by onMount, which I think doesn't get called server-side.

I'm still feeling like a global+useragent is sufficient for the vast majority of cases.  It would be useful to have a specific example of a piece of markup that is both useful/desirable and unworkable server-side.    I'm not saying such examples don't exist, but I looking for a persuasive example.
 > Perhaps I'm miss-understanding, but couldn't you do a forceUpdate when the page loads to update the placeholder content? Perhaps triggered by onMount, which I think doesn't get called server-side.

You're still lacking a way to find out if you are server- or client-rendering. Hmm, yes `forceUpdate` should actually work and be batched, it could be preferable... something based on context would be more seamless and Reacty, but that isn't a necessity I'd say.

I guess the neat thing about the `forceUpdate` approach is that it could (technically) just be exported globally via `React.isServerRendering()` and that is all that would be needed.

> It would be useful to have a specific example of a piece of markup that is both useful/desirable and unworkable server-side.

Anything that requires feature detection; i.e. vendor styles and polyfills by and large. User agent sniffing is generally a big no-no and very fragile for feature detection... but it can work and could be the ultimate approach in a way, but you would still need a backup `forceUpdate` when it makes a mistake.

tl;dr `forceUpdate` should work great, but there still needs to be a way to detect server-rendering.
 @jsfb Oh right, lazy images/lists/etc require something like this too to be server-renderable.
 @kryptt Yeah I think so. Really it all just boils down to being able to determine client/server somehow and there being an update when the transition happens, i.e. (I assume) a value in context would be sufficient.
 You should be able to do this with context fairly easily in 0.14.
  I recommend that you not use JSXTransformer for any serious development, if you can, use the `jsx --watch` tool instead. Anyway, you're not wrong, although I imagine that the best solution would be to override the `DOMContentLoaded` event instead (if possible... it just might be) so that you do not require special code when JSXTransformer is used.

But otherwise, it seems like a `DOMAndJSXContentLoaded`-event should be added, yep.
 Let's move any discussion if there is any into #1913
  ![react community round-up 21](https://cloud.githubusercontent.com/assets/197597/3787935/add341b8-1a43-11e4-8ec8-51e9dde093b9.png)
 I already mentioned react-router in round-up #19. Guess it doesn't hurt to highlight it again?
 Yeah, it didn't get a full blown section ... :p
  I'm not saying you're wrong, but I think in real-life scenarios that both of those become close to immeasurable. Performance of lookups should be minimal in the scale of things and compression should eliminate the cost of the "wordiness".

So I think there is little pressure to improve this, but I imagine that if you or someone else put the time in to do implement this that it would be greatly appreciated.
 I'm willing to bet a large sum of money that there are more important things to optimize elsewhere in your own code and in React before optimizing the object lookups in React.DOM.*.

JSX complication may change in the future - we've talked about maybe assigning local variables or maybe dropping React.DOM entirely and forcing you to import explicitly. We're not going to put any effort into this right, maybe with recast. I don't think that anybody should spend the time right now, so I'm going to close this out.
  Lots of places in the docs we use

```
> Note:
>
> Blabla
```

This gives you that red box around the block.

Also, it might be nicer to explain why we use jQuery if it's not needed: because people are familiar with jQuery's AJAX API.
 That's good enough, thanks!
  It's most likely because the canvas is transparent by default, and transparency in FF has a propensity to not catch events but pass them through to the element below.
 @nhunzaker Immediate fix is to just attach the click handler on the DOM element yourself (if that doesn't work then FF is broken).
  :thumbsup:, we can get this in when once the CLA is signed.
 Thank you!
  We'll get it when commoner gets it. There's an issue open there: https://github.com/reactjs/commoner/issues/64
  It's a little tricky because (for example) what if Editor doesn't render a div but instead renders a span or some other tag? If `editorRoot` is in the DOM then React can do a replaceChild but if it's not you're out of luck. Maybe it just throws an error.

We are planning to do something similar though where you can render and call `toElement` in order to get a DOM node that you can put wherever you want: #1711. I'm guessing that would solve your problem? It requires some changes to the events system though so it's not likely to happen immediately. I'll close this issue in favor of that one but let me know if I'm missing something.

I don't think I can help get rid of the extra wrapper div but perhaps you could do it consistently if you render some EditorWrapper component when rendering from React but with the shim layer, render Editor inside a div you make. Sorry I don't have a better suggestion.
 I'm curious, if we add the constraint that the root component must have a fixed root DOM component type and that it must export its type as a static variable (yuck, but easy short-term solution). Then it seems like it should only require a few minor tweaks for you to get some temporary solution in-place until `toElement` comes around. I'm not super familiar with the affected code so I can't guarantee that it is that simple, but it should be.

Does that sound like an acceptable workaround?
  I'm wondering if this needs to be extrapolated...? If it's needed here, isn't it also needed in every possible error message? Currently, the solution is to insert breakpoints so that you can inspect the exact value. It may be any other object which is also not valid.

Seems like this is trying to address arrays in particular, which is a confusing aspect of React. I think an `isArray` check with an error message linking or explaining why Arrays are not supported and potential workarounds would be better.
  I imagine it's because of the way React binds event handlers to the document. React provides an overloaded `stopPropagation` for its own synthetic event dispatcher which correctly stops propagation, but it most likely does not take separate mount roots into consideration.

Another argument for binding event handlers to mount roots perhaps, @chenglou ?
 Thanks, this is a dupe of #1691.
  Fixes #1392.

Previously, ReactComponent.updateComponent set the new props and owner and updated the component's refs. Because it did the actual props assignment, it had to be called by ReactCompositeComponent between componentWillMount and componentDidMount, meaning that it was skipped if shouldComponentUpdate returned false. Now, updateComponent takes the old and new descriptors and only updates refs, allowing a subclass to call updateComponent at a convenient time (specifically, it can be before `this._descriptor` is updated if the subclass also overrides performUpdateIfNecessary).

The new update cycle for composites is:
- receiveComponent is called which stores `this._pendingDescriptor` and calls performUpdateIfNecessary directly or a state update is enqueued, in which case ReactUpdates will call performUpdateIfNecessary
- performUpdateIfNecessary ensures that an update is still pending (which might no longer be the case if an update is queued for a subcomponent that was updated through a parent's reconciliation) and calls updateComponent with the old and new descriptors
- updateComponent calls super to update refs, then calls componentWillReceiveProps (if applicable) and shouldComponentUpdate -- if shouldComponentUpdate returns false, `this._descriptor`, `this.props`, and `this.state` are updated and the update is skipped; else, _performComponentUpdate is called
- _performComponentUpdate calls componentWillUpdate and _updateRenderedComponent, and enqueues the componentDidUpdate call (in that order)
- _updateRenderedComponent calls render and updates the rendered component appropriately

For DOM components (essentially unchanged):
- receiveComponent is called which does a short-circuit check for descriptor equality and delegates to super (which stores `this._pendingDescriptor` and calls performUpdateIfNecessary)
- performUpdateIfNecessary (not overridden) sets new values for `this.props`, etc. and calls updateComponent
- updateComponent does the DOM property and children updates (some synchronously, some queued for the transaction close)

For text and ART components (unchanged):
- receiveComponent updates the DOM or ART directly based on the new props
- updateComponent is never called

Notable changes:
- When shouldComponentUpdate returns false, refs are still updated
- ReactDefaultPerf now includes lifecycle methods in component timings
- updateComponent's signature changed (technically this is part of the public API, though we've never documented it)

Test Plan: jest
 @sebmarkbage @jordwalke 
 (Probably a pain to review, sorry; basically everything is just moving code around.)
 @sebmarkbage If it wasn't clear, this is separate from the batching changes; it should be safe.
 This is good. Will accept as soon as I have a chance to read it.
 say what?
  React should only attach top-level handlers for events that you're using in your components ‚Äì are you seeing otherwise?
 @nathansobo I'm curious whether it is the simulated dispatcher (i.e, capturing, bubbling, etc) or the initialization of the synthetic event that is most costly for you.

I assume it is the simulated dispatcher, which currently does a lot of ugly string hacking to do its thing (chenglou is working on that I believe). While the `SyntheticKeyboardEvent` has a lot of polyfills, they're all very simple and I don't imagine that they're the issue (but perhaps they are... because browsers).
 Also, you can easily opt-out of React's event dispatcher by just not using it and calling `addEventListener` from inside `componentDidMount` instead. You pay a slight up-front cost though.

PS. I imagine that since you're operating in a single modern and fast environment, React's entire event dispatcher is quite redundant for you, you could probably just replace it internally with immediate calls to `addEventListener`.
 @nathansobo Ah, that explains it. Yeah, `React.DOM.input` (overloaded by `ReactDOMInput`) always attaches an `onChange` handler (does not behave like HTML `onchange`), which is implemented by `ChangeEventPlugin` and listens to quite a number of events. If you're using controlled inputs it's obviously required, but it seems like it should be possible to discard it for uncontrolled inputs, but I'm not 100% sure without further examination of the code.

So if you're using uncontrolled inputs, it's probably something we should have a look at to see if it can avoided. If you're using controlled inputs, your best bet is probably to implement your own controlled inputs on-top of uncontrolled inputs (again, we should have a look at if the change handler can be avoided for them). However, you can remove `ReactDOMInput` from `ReactDefaultInjection` right now, and you get the raw input component in `React.DOM.input` instead, which you could use to implement controlled inputs using native events if you want.

As for using native APIs directly, I'm not super familiar with the event system code in React. But apart from `onChange` (which has a different HTML5 equivalent I believe), all the events represent the equivalent HTML5 events. So simply discarding/ignoring the entire synthetic React event system and updating `ReactDOMComponent` as necessary (look for `putListener`, `deleteListener`, etc, perhaps you could just update those instead...) to add native event listeners directly should be a piece of cake (and not a hack). Again, you pay a higher up-front cost for each event listener though, but that may be preferable in your case.

(You probably want to remove `ReactDOMInput`, etc, regardless of if you decide to switch ReactDOM to native events or not)
 Pretty sure we don't need to attach the event handlers for uncontrolled components. I'll check and let you know.
 @nathansobo If you're stopping propagation of `textinput` and `keydown` then you have not removed controlled inputs, you've broken them instead. (**EDIT: Or perhaps that's not true now that I read it again, as it seems you're preventing the events further up the tree**) You can very easily reimplement controlled inputs with the raw input component, if that's something you want to expose for users (but don't want to replace the synthetic event system entirely)... so no real harm done.

That being said, the synthetic event system in React exists for two reasons AFAIK:
1. Normalize browser inconsistencies (lots of them), especially old browsers.
2. Drop up-front O(n) addEventListener cost, for slightly more expensive event handling.

1 should be irrelevant for you, and 2 is probably not as important for you as you're in a faster modern environment. Also, dropping frames is far more noticeable (as you say) than a popup taking a few frames longer to open in worst-case. Just food for thought.

I definitely see Atom becoming my one-and-only editor in the future, so I'm just happy to help. :)
 Just made #1968 with a possible fix, though I'm unsure how well I like it.
  There's also #1623 to add this. I'm going to close out and ping that PR again. If it doesn't happen there we'll reopen here.
  Simple example outside of bootstrap: http://jsfiddle.net/8mXLr/

ReactTextComponent is supposed to be an implementation detail and we shortcut to just use a string as props there for perf (since it's internal). But perhaps we need to make it an object now so this work. @sebmarkbage? Alternatively we can make cloneWithProps skip ReactTextComponents?
 Interesting, isn't `ReactTextComponent` supposed to be strictly internal only? I.e, the children should be strings/numbers/whatever you passed in rather than `ReactTextComponent` I would've thought?
 Yes. @syranide is right. I think it was converted for legacy reasons because of the shared code path with traverseAllChildren.

This will need to be fixed as part of the effort to hide internal implementation detail.

> On Jul 31, 2014, at 1:21 AM, Andreas Svensson notifications@github.com wrote:
> 
> Interesting, isn't ReactTextComponent supposed to be strictly internal only? I.e, the children should be strings/numbers/whatever you passed in rather than ReactTextComponent I would've thought?
> 
> ‚Äî
> Reply to this email directly or view it on GitHub.
 #1988 is merged, closing.
  :thumbsup: Thanks!
  We can skip line wrapping (except in a couple special cases, mostly code blocks) in Markdown files. I did that once for all of the docs but it was a no-go (we aren't entirely consistent here and the contributing docs say to wrap at 80, so I don't blame you!)
 FWIW the .editorconfig says not to wrap *.md: https://github.com/facebook/react/blob/master/.editorconfig. Let's update the contributing docs?
 Updated: 62a336f9abf07481f445cc195c9edf1405bad166
 Thanks!
  https://groups.google.com/forum/?utm_medium=email&utm_source=footer#!msg/reactjs/vjQuIpXL1oY/Hve10Cu8SycJ documents a few things that are confusing and seemingly broken around key events. Let's fix/clarify things here.

cc @syranide @salier 
 Need to investigate, but `key` polyfill is an "intentional" short-coming as is not something we can fully polyfill (although it does work significantly better in `keypress`), the reason why it differs between browsers is because we use the native `key` whenever it is available. We can only polyfill the non-printable keys reliably (in keydown/up).

As for the difference in keypress on FF, it is largely intentional, although I'll have to check why enter got caught in the cross-fire.
 Pushed a fix for the missing enter in FF, but as far as I understand his concerns, everything else is as it should be. `key` support is seriously crappy in browsers, even when it's available, you should stay away from it for everything but non-printable keys. It's so long since I authored that PR, IIRC even using `key` in onKeyPress is a disaster I believe, we polyfilled it for browsers that don't support it but we have to fall back to the native implementation which is broken in all "ever-green" browsers if my memory serves me right.

But it does work for numeric keys and odd things like that IIRC. But moral of the story is, it will take a lot of years before you can use `key` cross-browser _accurately_, and unless I'm mistaken, you can't use it for predicting which key is going to end up in the input anyway, so the practical use of it is quite questionable.

But :+1: for documenting what works and doesn't.
 @talgiat Fix is in master (only enter is affected and only FF).
 Or better yet, `onKeyDown`, which is arguably probably the correct approach as you're (probably) not interested in the chars, but specific keys being pressed.
 #1956 merged, closing.
  I'm not weighing on whether JSX should do it or not. But it's generally accepted "common practice" to always leave an empty line at the end of text files. Most editors do it by default. That being said, unless there's a good technical reason I don't see why JSX shouldn't just mirror what it got.
 @n1k0 My bad, I looked at the end of your file and saw the empty line there. Anyway, this is an "intentional" short-coming currently as a result of my PR which improved white-space behavior of JSX output. Fixing the tailing whitespace is technically quite non-intuitive due to the way it all works, so it was postponed for the time being.

I'm personally not really keen on digging into that code at the moment, but if someone else is feeling adventurous, have at it. :)
 react\vendor\fbtransform\transforms\react.js + xjs.js

You'll find a bunch of `', '` in there, problem is that there's no easy way to know if what's next is actually going to be a newline (I think?), and since most of it is in esprima-territory, it's not like you can just step back and remove whitespace after the fact.
 Longer term we're going to switch away from using jstransform and will use recast. jstransform does AST assisted string->string transforms, while recast does AST->AST, which will allow us to use consistent printing and _not_ hand insert whitespace characters.
 @zpao :+1: (although it does not _necessarily_ mean that we don't have to care about whitespace).
 We're deprecating react-tools & JSXTransformer so closing this out.
  :thumbsup: this looks fine to me now. The defaulting to `on` is still a little bit confusing but I see that this is just a byproduct of the DOM. Thanks!
  Thanks! It'll got out the next time we update the docs.
  TransitionGroup clones your children, so the ref you hold are not actually used by it. Cloning is only one-level deep, so if you wrap it with some random wrapper, the inner `input` is indeed kept intact while the outer `div` is cloned.

If you check the console, it has this warning:

```
Warning: You are calling cloneWithProps() on a child with a ref. This is dangerous because you're creating a new child which will not be added as a ref to its parent. 
```
 @bjbrewster I'll close this because this is the intended behaviour. Maybe we should document that.

I'm working on a new, low-level TransitionGroup prototype. It actually uses the original children so refs work there (it's achievable). No guarantee though, because the prototype's API might change.
  This is incorrect. When componentDidMount is called, React has attached ("mounted") the elements returned from render into the document.
 What setTimeout? The docs (intend to) say that if you want to set a timer, you should do it in componentDidMount but it's certainly not necessary to wrap all DOM manipulations in a setTimeout.
 This is not because the DOM is not ready at the point when componentDidMount is called but because browsers won't start a CSS transition if the className is assigned immediately when an element is added to the DOM. (This is not React-specific.)
 Not always ‚Äì you can occasionally force it to do a layout by reading from one of the size properties:

http://stackoverflow.com/a/19907889/49485

but doing a setTimeout seems to be the most foolproof method.

Closing, but let me know if there's something in the docs that we should add that would have made this clearer for you.
  The recent descriptor change made it change its name. We haven't updated the docs yet.

@sebmarkbage 
  Thanks!
  Thanks! Let's ship it :)
  Thanks!
  See also #1439.
  Maybe we can do something smarter with the root index generation on the client side? Seems like this should work.
 Use the version number as a prefix could work? (You wouldn't have the same version of React twice, or else you didn't dedupe correctly).
 This could solve itself when we drop IDs from the DOM (and be somewhat supported). As we would use an internal Map for translating node to instance (and the fallback property could be randomly generated). If we run with the `data-react` marker compromise and want to support multiple versions, `data-react` would also have to randomly generated.

However, for multiple versions to really play nice, we would probably (optionally) need to attach event listeners to the root nodes instead of the document (as I suggested for playing nice with other frameworks too).
 @nathansobo Atom plugins was what prompted this issue. :) We're not going to support using multiple versions of React seamlessly together in the near term, though it's possible it'll work in the far future. Until then, your best approach may be to have plugins populate iframes with plugin contents so that the scripts run in an isolated window.
 Multiple versions of React cooperating is technically not very advanced (https://github.com/facebook/react/issues/1939#issuecomment-50279429). I think the biggest issue for now is that events handlers are always bound to the document, so events would not be playing nice **at all**.

Shimming is probably not going to be a viable strategy unless you're referring to maintaining a separate branch, but even that could probably turn into a major headache with some changes to come.

@nathansobo One possibility is to maintain separate Atom-branches of all major React releases, which _does_ play well with multiple versions, it should generally not be _that_ complex I think. It would probably be the more realistic approach, if any, I think. Although targeting different JSX versions is an interesting problem if that applies to you.
 @nathansobo Multiple numeric versions of React, or any library for that matter. If I'm not mistaken, there are only two parts of React DOM that currently prevents this, the event system and DOM reactids.
1. Fixing DOM reactids is simple, the simplest solution being just suffixing `ID_ATTR_NAME` with a random/unique string on startup. Each React version sees only the DOM that is managed by itself. 
2. The event system is a little more complicated, the problem is that all event listeners are bound to document, this does not play nice with other libraries (and event handlers). I've proposed moving event listeners to each mount root, which should be preferable as it would then also play nice with other event handlers/libraries. This is theoretically very simple, but does require a few lines of code so that the set of listeners is tracked per mount root instead and to prevent an event from being acted on multiple times by the same instance.

So, unless I missed something, that should be all that is needed to support multiple numeric versions of React. It does require maintaining a separate "Atom-compatible branch of each React version", but it should be possible to just rebase the fix onto each new version of React, without complications.

I don't know what the devs feel about # 2, but these are all rather simple fixes that I don't see why we wouldn't want to apply (one way or another) in the future.

But as I mentioned, I don't know if/how you use JSX today, but that is something that would also have to be available in a few different versions. There was one "breaking" JSX update a while back and it seems like there will be one or two more in the future.
 @nathansobo Fire away :)

I don't really have the full picture of what you're intending to do (so don't take my word for anything). As for my idea, one would have to use a "bridge" for rendering component of other versions, this could simply be a custom (generic) component that calls `ReactVersionXYZ.renderComponent` (this is roughly equivalent to how render() works internally).

Just something to visualize what I mean: (I assume that required React version is stored statically on the component class to be rendered)

```
render: function() {
  return (
    <div>
      <ReactBridge type={MyCompThatIsAnotherVersion} propA={1} propB={test'} />
    </div>
  );
}
```

So this would allow composition of components of different React versions (you own the instance of the bridge, not the actual component), but where the meat of each component should preferably depend on the same React version, everything should behave as you would expect (updates, callbacks, etc). However descriptors are version specific, so you couldn't pass unwrapped component classes or descriptors through the bridge and expect it to work. That is, the props you provide the component cannot be React-specific in nature.

Depending on how tightly you're integrating React, this could be a significant issue as batching wouldn't happen (by default) across such bridges/boundaries. It's definitely imagineable that one could rip out the virtual DOM/transactions out of React and have _all_ versions of React cooperate, but I don't know if that is practical.

It most certainly is not as neat as using a single React version from top to bottom, but I think the merit of _something_ like this is that each implementation ultimately becomes independent of whatever is on the other side. So when React 2.0 comes around, modules would simply adopt new versions as they please, rather than be abandoned.

But it also sounds like you might be integrating quite deeply with React and never being able to improve your API for React (as you would have to support each React version indefinitely) could be equally horrible.

Perhaps this is not at all applicable to what you have mind (if what I said makes sense :)), but you guys have an interesting problem at your hands, and I think a lot of it comes down to how long (or how far) you're willing to support "old addons".
 I understand this is a problem. Are your DOM trees nested within each other or completely separate?
 Off the top of my head I'm not sure how that causes problems. Do you know when that error is triggered? (In response to some event handler or something else?)
  See #1913
  That object spread syntax isn't supported yet ‚Äì it'll probably be in 0.12 but until then you should use `React.DOM.div(attrs)`. Note that 0.11.1 is 0.11 with a few commits cherry-picked, not a direct cut of master, which we're not quite ready to release yet.
  We're minifiying twice thanks to `uglifyify`. We need this to remove dead requires. But it also doesn't minify all the way, so we still need `uglify` as well. I haven't actually looked to see if there's a better way.
 I believe webpack is smart enough to strip out unneeded requires even before uglification so that might be faster than what we're doing‚Ä¶
 @spicyj Is it? I haven't actually checked, but I use `require('es5-shim')` to apply the shim and it's working in IE8 so I really doubt it's been stripped (unless it's really smart and knows when a module has side-effects).
 I meant if you do `if (false) { require('dev-only-stuff'); }` then webpack won't include that module.
 Some context... I did end up trying unreachable-branch and it mostly works (except it chokes on `if (__DEV__) { /* comment */ code }`, which we have at least 1 instance of). Even fixing that I didn't end up with any significant perf wins (and I even combined the multiple jstransforms we have happening at the browserify step).
 I think at this point things are pretty fast. We'll make some more changes to the build process in general.
  It's better to create the nodes with the correct namespace initially ‚Äì we'll likely go with #3808 or a variant thereof. Sorry for the long delay.
  @petehunt is on vacation right now but hopefully he'll have a chance to chime in when he gets back. @josh might be able to help out too if he's around.
 Probably @joshduck. :)
 Oops, sorry Josh! If you want to send some GH staff over to help debug though‚Ä¶
 Curiously, this seems inconsistent if I leave the (third) page open and just watch it update:

![image](https://cloud.githubusercontent.com/assets/6820/3710549/58961bac-1495-11e4-906b-34014709c60d.png)
 We haven't had a chance to look, no. Improving perf tooling is on our goals for 2015 but it won't happen before 0.14.
 Fixed by #4683.
  Agreed! Want to write the docs here?
 This was merged, closing this issue. Thanks!
  Thanks!
  We'll most probably leverage npm for this rather than reinventing the wheel. For this to happen, we also need an asset bundling solution (css, images). This is an unsolved problem afaik. @petehunt 
 You can just put the 'react-component' keyword in your package.json. This should be fine for the future component registry.
 FWIW, we're not going to do this and we'll leverage npm.
  I'll respectfully disagree on the serif here. I often do prefer it for body typefaces, but not here. We won't change that at this point. We'll consider it if we redesign.

As for colors, our contrast ratio on the normal body text is actually 8.69:1. That's well above the WCAG AAA level.

The font weights are a bit light (in fact it is the "light" variant), we could probably do to drop the `font-weight: 300` bit. 400 is normal.
 disagreeing ‚â† disrespecting ‚â† ignoring (I can edit too)
 My job is to handle issues. I could have just closed this issue entirely without any sort of response. That's rude. Instead I told you what we would and would not do here given the multitude of constraints we're working under. I really did appreciate the feedback, I did not disregard it. We're going to make a change based on it.

Design is such a personal & difficult thing to do such that everybody agrees it looks right. There's rarely an objective right and wrong. For example, I don't like the text shadows on your website. I find your screenshot harder to read than bumping the font-weight on Proxima Nova. Does that make me wrong? Is Apple wrong for changing the system font from Lucida to Helvetica? Google is probably using the wrong shade of blue.

Honestly, most of our design decisions came from a mockup a designer made in his spare time 18 months ago and we've outgrown some of them. We haven't spent much time really deviating at a big picture level. That's why some of the things are the way they are. When we have time, we'll redesign. That's been a pretty low priority. If there are actionable incremental improvements we can make in the meantime, great.

If you have _constructive_ criticism, keep it coming.
 Currently I see:

![image](https://cloud.githubusercontent.com/assets/6820/3696599/a6e01bd2-1391-11e4-80bd-a0ad92f5b2ce.png)

With the `font-weight: 300` removed, I see:

![image](https://cloud.githubusercontent.com/assets/6820/3696603/b4786862-1391-11e4-80a1-7c3354d4f524.png)

Maybe we can make the text darker, though probably we don't want to go all the way to `#000`. Right now it's `#484848` and looks noticeably non-black (presumably intentionally). `#333` is definitely higher-contrast but looks almost black to my eyes. (You'll note that almost no one uses black text ‚Äì for example, Google's search results are `#545454` on white.)
 My second screenshot shows non-thin fonts; do you disagree?
  (If I'm not mistaken, `rootCopy2` should have been `nested: { nestedProp : {$set: root.nested.nestedProp} }`. That might have been a typo?)

I'm fairly positive this is intentional. `update` is very lightweight and not meant to be used as a primary data structure for your apps. More for fine tuning a few `shouldComponentUpdate`s (@petehunt). Thus it doesn't try to do smart structural sharing. You weren't supposed to be able to use `===` on it, more like manually comparing fields.

[mori](https://github.com/swannodette/mori)'s what you're looking for perhaps.
 @chenglou I'm not sure if I agree, this is not about structural sharing, but simply about detecting equivalence of old/new properties before mutating. It shouldn't be many lines of code. Mori is a library for structural sharing, which is a vastly more complex problem and I sincerely doubt any reasonably common JS app use-case could at all turn that overhead into a benefit.
 I _guess_ I see the point then? Although in your example you did end up allocating a new object anyways so the benefit of not allocating is lost. If you feel `===` is still important then feel free to submit a PR (possibly without the `$set` allocation).

BTW, `update` is getting deprecate (as in, pulled into its own repo that other people can maintain) in favour of [immutable-js](https://github.com/facebook/immutable-js). We could get this in before that happens. @petehunt 
 We are handing over `update()` to the community so I‚Äôm closing this.
Please see my note in https://github.com/facebook/react/pull/6353#issuecomment-204219214.
  If you're minifying your code, I assume ReactTestUtils would be stripped out if it isn't being used.
 Are you using DefinePlugin with webpack? You'd need to do something like

```
plugins: [
  new webpack.DefinePlugin({
    'process.env': {'NODE_ENV: JSON.stringify(process.env.NODE_ENV)}
  })
]
```

to make webpack inline NODE_ENV properly (and I believe then it's smart enough to not require the test utils). You can also write `JSON.stringify('production')` explicitly there if you don't want to specify it on the command line.
  See #1898 ‚Äì for the enter key you should be using the keydown event. If you still can't get it to work with onKeyDown, can you post a jsfiddle showing the problem? Note also that you can now write `e.key === 'Enter'` instead of `e.keyCode === 13` if you want.
 @marcbelmont You need to use `charCode === 13` and not `keyCode` as it's onKeyPress. However, we've polyfilled a lot of `.key` so just use `.key === 'Enter'` instead.
 @marcbelmont That seems to work just fine for me.
 @marcbelmont Weird, I tested it in SauceLabs for your browser and got the incorrect behavior. Then I refreshed and I don't get it anymore and can't reproduce it.
 @marcbelmont Did this resolve itself or is it still an issue for you?
  You wanted oneOfType. :) We can probably make the message better though‚Ä¶
 Fixing this warning message.  We're drifting away from proptypes and toward flow anyway, but if someone is looking for an easy PR, improving this error message would be a good one.
  Sounds like we're not 100% sure what our wording here should be (see #1918) so I'll hold off on merging this for now.
 And we changed everything to Element and updated all the docs (though perhaps we missed something). I think we can close this out now.
  I can't repro but that should have been fixed in e8efa2a1e915da7aab90f6ad2ffcb226b7016293 and might be in 0.11.1 which is being released soon.
  cc @sebmarkbage, this has come up a couple times now. Our terminology around component vs descriptor vs class has gotten more hazy.

I think we should work like this:

``` js
// would need to revert the current behavior
React.isValidComponent(React.renderComponent(Comp())) // true
React.isValidComponent(Comp()) // false
React.isValidComponent(Comp) // false

// would need to add this API
React.isValidDescriptor(React.renderComponent(Comp())) // false
React.isValidDescriptor(Comp()) // true
React.isValidDescriptor(Comp) // false

// should actually work like this already
React.isValidClass(React.renderComponent(Comp())) // false
React.isValidClass(Comp()) // false
React.isValidClass(Comp) // true
```
 The direction we're heading there is actually no such thing as a component that can be statically verified. We have an internal discussion that I'll direct you to.

There are many different signatures that are valid components. It needs to be more precise such as instanceOf(ParticularComponent.type), certain categories like XHP or anything with a getDOMNode method.

> On Jul 23, 2014, at 9:27 PM, Paul O‚ÄôShannessy notifications@github.com wrote:
> 
> cc @sebmarkbage, this has come up a couple times now. Our terminology around component vs descriptor vs class has gotten more hazy.
> 
> I think we should work like this:
> 
> // would need to revert the current behavior
> React.isValidComponent(React.renderComponent(Comp())) // true
> React.isValidComponent(Comp()) // false
> React.isValidComponent(Comp) // false
> 
> // would need to add this API
> React.isValidDescriptor(React.renderComponent(Comp())) // false
> React.isValidDescriptor(Comp()) // true
> React.isValidDescriptor(Comp) // false
> 
> // should actually work like this already
> React.isValidClass(React.renderComponent(Comp())) // false
> React.isValidClass(Comp()) // false
> React.isValidClass(Comp) // true
> ‚Äî
> Reply to this email directly or view it on GitHub.
 @sebmarkbage did we want anything to validate an actual instance? `isValidComponent` was a pretty good name that we used up. We don't really have a good way to see if some object is the return value of `React.render` vs something like a backbone view. It sounds like you don't really want anything, but let's decide.
 `isMounted` is really the check the verifies if an instance is tied to the React system. We could make it static which is what I would prefer anyway: `React.isMountedComponent(instance)` That would allow you to differentiate which React version a component is mounted with, and that it is in fact a React component and not something else with `isMounted` on it. That seems like a good API.

A unmounted valid instance is just anything with a render function which seems like a useless test, and is also likely to change (new signatures). This makes it an unstable API. Failures might become passing in upgrades which seems bad. I'd like to hear the use case for those.
  This has been brought up before (but I can't find the issue) and I don't think anything happened. Personally I'm not really sure which I prefer. I've always been instinctively drawn to short methods, but really, clarity trumps concise in my opinion.

The use of `component` is an excellent reminder for the (less common) magic methods, it makes them stand out as you would never include `component` in the naming of your own methods. I instinctively assume that there's a getInitialState/render/etc in every component (and you always put them at the top/bottom)... but willMount could be "easy" to miss and has no obvious place (I always put them top though).

It's always relative, but when it's unfamiliar code, I would prefer if the author spent another second and wrote `component` rather than having to carefully scan all methods to make sure I didn't overlook anything (also, an official JSX style-guide would be awesome... @zpao :)).

But that's just my opinion :)
 We definitely spent a lot of time considering this (and I personally was in favor of it) however the general consensus at the end of the day was that the verbosity is worth it here.
  Just a side-note, I _really_ recommend that you use the `jsx --watch` util instead. JSXTransformer is inherently flawed with respect to script loading, use the jsx-tool and you have identical behavior for DEV and PROD (and also correct sources for all errors, in all browsers).
 @RReverser if you're really interested in doing this, I don't mind. I think this is _slightly_ more practical than #1995, but it still could encourage the wrong behavior. What do you think?
 I think the combining might end up being a bit more of a convergence. These things overlap a lot with slight API differences. The other big difference is that JSXTransformer finds script tags. I was considering smoothing out API differences, then having JSXTransformer be the [browserify override](https://github.com/substack/node-browserify#browser-field). Any new functionality we add to JSXTransformer now would in turn make it to the new place too.
 If you need this, I believe you can add

```
<script type="text/jsx">
MyApp.init();
</script>
```

or similar after the external script tags and that will queue it correctly.
  PR for #996

I choose to believe that users should be correcting their own "mistakes", rather than have React transparently fix and unknowingly introduce weird edge-cases and visual artifacts.

Quite simply, this PR enforces that there are no other nodes except the node rendered by React inside the target, it obviously does not warn if there isn't a node rendered by React inside the target. It only performs this check in DEV.

There is another test in #1903 which complements this PR.
 @oriSomething React require identical markup to reuse server-render nodes, but that is not what this PR addresses, this is just about an edge-case some people have gotten confused by.
 This throws if you have any existing markup in the element, regardless of if it was produced using React's server rendering? Seems a little aggressive.
 > it obviously does **not** warn if there isn't a node rendered by React inside the target

@spicyj  :)
 Can you add a test for that?
 @spicyj Added.
  Sorry about this -- you should have gotten warnings for this in the 0.10 development build, probably 0.9 too.
  cc @zpao 
 Yeah, I believe we run propTypes validation silently upon descriptor creation in 0.11 but only emit the error when mounting. In master we only run it on descriptor creation. Returning an Error object is indeed the correct API now; if that was a change new to 0.11 then that's an oversight in the release notes and we should fix them, sorry.
 Ah, indeed. We totally missed the warning/Error change in the release notes :( 8855d6153e252c735de0e6cc373787d22c1a467b
 Eh my bad. That seems so far away that I thought it was in .10...
 Release notes have been updated, but we aren't going to revert this in 0.11. It will likely go away at some point in 0.12+
  Can everyone who's interested in this list the specific modules/functions you're interested in? We intentionally ship a small public API so that we can feel free to make internal changes.
 cx is public as React.addons.classSet so that falls into almost the same category as cloneWithProps. What are you using EventListener for?
 Okay, going to count that feature request as a vote for #285.
 It's unlikely we'll ever expose ReactTransitionEvents as a public API as it's just a thin wrapper around browser events and is used only in ReactCSSTransitionGroup, not more widely. (Essentially, we don't want to commit to supporting that module.)
 https://github.com/facebook/react/issues/2251#issuecomment-58703611
  ```
React.renderComponent(React.DOM.noscript(null, 1), document.body);
React.renderComponent(React.DOM.noscript(null, 2), document.body);
```

Execute that and it goes boom, IE8 throws away all children of `noscript` after render and violently screams if you in any way try to add children afterwards.

Should you be mutating `noscript`? No, you shouldn't, but I imagine that reality is not quite as simple, where it could look something like:

```
<noscript>There are {count} items</noscript>
```

and there you have an error if `count` ever changes.

Practically though, `noscript` content is useless client-side and I see no reason why we shouldn't just discard any children passed to it client-side (for performance gains). If there are children left there from server-rendering, they will stay as-is until the `noscript` is removed from the DOM at a later time.

This could easily be done by adding a simple `ReactDOMNoScript` component that just returns `noscript(this.props, null)` if it's not for server-rendering. I could whip up a PR if you guys think it's a good idea? @zpao?
  That's how the key property works. Using a random id as the key is almost always an anti pattern. Instead try to use some sort of id from your data set (like an array index or db primary key)
 @petehunt From the discussion on IRC, my motivation with this issue was that scrolls to the top, which I believe we have code in-place for to prevent (or did I get that wrong). But apparently it didn't work in this case?
  Very simple PR, removes redundant uses of `window.*`, there's no point in doing `window.abc && window.abc()` as we already know `abc` is global when it's time to execute it.

Reject if you don't feel like touching all the different lines for "no good reason".

PS. Alternatively enforce use of `window.` everywhere it makes sense (i.e. not for Array), but that might be rather redundant and heavy-handed.
 In jsdom, window isn't the global, right?
 @spicyj Hmm, that could actually be true given that it isn't in Node (just checked). Interesting.

If that is, then it seems only `window.setTimeout(eventListener, 0);` has a redundant access to `window` as `setTimeout` is global in Node (and is a feature of JavaScript rather than the browser) and the rest are "invalid".
 I'll just go ahead and close this, the only actionable line it seems is `window.setTimeout` and that's not worth bothering about.
  This is probably something we should fix in React.
 React now uses `createElement` instead of `innerHTML` for the initial mount, and also respects the SVG namespace for any elements inside `svg`, so it should be solved now.

The original fiddle, updated for React 15 API, now works correctly in IE for me with React 15 RC2: http://jsfiddle.net/z3BQS/1/

<img width="975" alt="screen shot 2016-03-18 at 20 57 51" src="https://cloud.githubusercontent.com/assets/810438/13891964/4811054e-ed4c-11e5-9fb7-47fadbc46739.png">

I‚Äôm closing but please let me know if I missed something.
  It's not currently possible, though you could do `ref={'button' + i}`, then access it through `this.refs['button' + i]`.
 This will likely be more possible after #1373.
 Going to close out to try open issues down (even if we're currently failing). Let's make it an explicit goal/non-goal of #1373.
 @arcanis Yes, it is possible, setup a callback ref and save the ref to an array.  For more info, check out the docs (https://facebook.github.io/react/docs/more-about-refs.html#the-ref-callback-attribute) or ask a usage question on stack overflow :).
 @arcanis We use github issues to track bugs in the React core, and explicitly send usage questions to StackOverflow.  We encourage cross-linking, so feel free to post a link to you SO question so future travelers can go to the same place.

To answer your question of when elements should be removed, the answer is "when the callback ref fires a null".  You can create a closure to capture the name/identity/key in your callback function, and access/remove that value when the ref fires.
  Yeah, this was normalized (and "corrected") so that `keypress` only receives `charCode` and `keyup/down` only receives `keyCode`. Both receive `which` that is aliased to `charCode || keyCode` and is quite useless, but there is code that relies on it so what can you do.

However, unless you have specific needs, the new polyfilled `.key` property should be preferred over `keyCode` and `charCode` whenever possible.
  It seems that React will be moving _away_ from the current magic features, relying instead of the new ECMAScript classes/modules/etc. So mixins as a feature of React is probably going to go away in-favor of users using whatever utilities they want for handling "extend". They're also focusing _heavily_ on making sure that the code is statically analyzable.

Personally it seems like dependency injection is the wrong solution, especially in the context of React. The strengths of React is the simplicity of props, state and render. If a component should be "extendable", is there a reason why you can't do that via props instead?

Anyway, just a summary to the best of my understanding of where it's heading, but devs are the authority obviously :)
 @theporchrat Mixins are not magical in themselves, but mixins and classes are currently implemented by React, which really shouldn't concern itself with that. The proposal you commented in effectively removes React's custom magic for classes/mixins and relies only on ECMAScript proposals instead, which seems favorable. Then you're free to use as much DI as you want (given that it's technically possible, which I think it is?), React has no say in the matter.
 @theporchrat JSX already includes a number of static transforms from the ES harmony proposals and by the look of reactjs-future, we might not even go the way of classes (my bad), but just modules with functions. If that is decided, then they'll just shove the module transform into JSX and it's done. They will not wait for browser adoption.

Anyway, the devs are authority on this. But I don't think there's any demand for DI from the devs. Remember, it's being developed/used by Facebook and Instagram, pete mentioned on IRC the other day that FB that their number of components might be nearing 5 figures. So if DI was necessary for scale, they would have pushed it through or made it work, and perhaps they have, but I doubt it.
 We don't plan to do this, but with ES6 class support you can make your classes however you like.
 We're doing our best to simplify the React core as much as possible, which in this case includes slowly moving away from React.createClass and towards ES6 classes, so we're not planning to add more helpers for making classes. As you say, you can easily reimplement the same functionality yourself if you need it.
  Closing this as a dupe of my #1366 which is a little more robust and contains a test. (Still not completely sure if we're going to merge it though, sorry.)
  Add PureRenderMixin and Perf to this page. Also, I think it's better if the link titles reflect the name used by these addons.

(#1882)
 Nice catch, fixed.
  Looks good. Thanks!
  Huh? Your source and destination is the same, that's not what you want.
 `jsx --watch` doesn't exist anymore.  The transformer has been replaced by babel.
  There's currently no simple way of doing this. I've seen [this](https://github.com/tommyh/jasmine-react) but I don't guarantee its stableness.
 Yeah, unfortunately this is hard right now. Some of the changes we're making with ES6 classes will make this simpler.
 Sorry, I don't have anything to point you to right now but I'll come back and update this issue when we do have something.
 For components that are implemented as ES6 classes, you should be able to mock the class methods using jest's (or any other framework's) standard mocking mechanisms; there's nothing React-specific necessary to do any more. If that's not the case let me know and I'll reopen.
  Yes, the docs are correct in this case. Thanks for looking into this though!
  > it's appropriate to store props in state to be able to know its previous values.

Ah, perhaps what they're really referring to is basically "edit pages", where you might want to diff the before and after, so that you can send only the changed variables. But it really reads quite weirdly, especially for beginners.
  Rather than doing this, can you update the description [here](http://facebook.github.io/react/docs/addons.html)?

e.g. `React.addons.classSet`: blabla

(Also, on top of Perf, I forgot to add PureRenderMixin there. Can you generalize this PR to "[Docs] Note on to access React addons" or something? Thanks)

@jefffriesen yeah, I think there should be a sentence that refers to the measurements (from `Perf.getLastMeasurements` below) [here](https://github.com/facebook/react/blob/93712246c83d0d8731ded31793e9a87afee71a5c/docs/docs/09.8-perf.md#perfprintinclusivemeasurements).
 @chenglou I think it's valuable to mention it here too.
 Kinda feels like you'd need to add that to all other entries though. But I don't mind.

Edit: my suggestion doesn't affect this issue then.
 I think this is fine, thanks!
  We currently don't support `!important` as it has to be set using `style.setProperty(name, value, priority)`. This should be trivially easy to implement if it's something want to support, although I'm not sure about the performance implications (**EDIT:** #1886), although I can't imagine it would be measurable as we would be doing the string test ourselves and those are cheap.

http://www.w3.org/TR/DOM-Level-2-Style/css.html#CSS-CSSStyleDeclaration

~~OK... apparently IE8 doesn't support this _at all_, it might still be worth implementing, for the future and for those who don't care about IE8.~~ ~~After further experimentation, apparently it is! `style.setAttribute(name, value)` (priority is part of the value).~~ But apparently that was wrong as well, the only way to set it seems to be with `cssText`, an acceptable work-around may be to just use `cssText` when we detect an `!important` style, which should be seldom enough that performance is a non-issue.

An important consideration is that we _already_ support this for the initial render, but subsequent updates will _fail_ as `!important` isn't recognized for properties.
 On a random note, I thought that inline styles override !important but I was wrong ( http://jsfiddle.net/do0hpcvm/ ).
 @vjeux I'm going to leave this to you. I think we should probably just maintain status quo here and not support `!important`, but there may be valid uses somewhere.
 @zpao We do support it though, we just don't support updating a style that has it.
 That's not support, but I see what you mean (that's like saying we "support" hyphenated styles)
 @cody It would probably be easier to just manually manage the style property of the node itself ;)
 I had a longer post here and then lost it, oh well‚Ä¶

The summary is that it would be expensive to check every value for `!important`, so supporting this isn't awesome. Even if we do get a good option, it's unlikely we'd do this while we support IE8 because I don't want to go down that cssText path. This isn't really at all about dogma, I would say that it's more about perf. And the fact that we're faced with a number of limitations when working with styles in CSS.

What we could perhaps do is change the data structure for style.

``` js
style = {
  color: 'red',
  backgroundColor: {
    value: 'blue',
    important: 'true'
  }
}
```

It would be backwards compatible (if the value isn't an object, we do the exact same thing). And it would allow us to start using the `setProperty` API with `important`. Downside is obviously more objects. But we don't have to do any string parsing.
 No change. As we invest more in JS styles I think we'll end up with some changes to how styles work. In the mean time I don't think we'll make any changes without a fuller picture of how that will play out.
  We can already render into shadow roots, this diff lets us listen to events inside shadow DOM.
 Can you close #1167 if that's now out of date & not necessary?
 We'll have a different way of enabling custom elements that doesn't expose the internal class.

This needs to take into account detached containers. Surprised we don't have a test for that.
 The right solution is to use `event.path` to dispatch the event to the inner React component's ID. So I'm going to close this out. We'll still implement event handling the shadow DOM but a different technique.
  This has been discussed a bit before and while implicit `px` is super nice, it's also walks quite a slippery road. So while there's nothing decided either way so far AFAIK, something doesn't feel quite right about the implicit `px`.
 I agree with that and the current workaround for specifying unit less numbers (`1 + ';'`) isn't great. Also hard to keep track for the user.

This might be unfrequent but having `var newWidth = this.props.style.width + 10` is nice. You don't have to extra the number from the string since it _is_ a number.

It's certainly nice to have `width: x` rather than `width: x + 'px'`, but we might have to live with it here and do the latter.
 We're going to eventually stop doing this. It's going to have to go out over a couple releases so we can be nice to people and warn.
 Nah, I think I'd like to avoid configs as much as possible. We've seen that a lot of people don't even know that React will insert 'px' and are confused when it does. I don't think it will be confusing for people if we say we just pass values through.

I'm not even sure how you'd make it a boolean flag without affecting all components on the page. I'm interested to hear any ideas you have but I think this will likely need to remain a library-wide decision.
 @zpao Isn't this best handled in whatever way you decide to handle style user vendor prefixing, etc? This seems like it falls into the exact same category and is just another "user callback":
1. Nothing, the user has to wrap style with his own function call
2. Some kind of per-component callback for style (or DOM-props in general)
3. ???
 @jacobrask Since it would have no actual ties to core, that could be entirely up to you :)
  tl;dr: `<script></script>A<script></script>B` instead of `<span>A</span><span>B</span>`.

Old:

![image](https://cloud.githubusercontent.com/assets/6820/3631177/af021294-0eb3-11e4-8b4a-d334cef48dea.png)

New:

![image](https://cloud.githubusercontent.com/assets/6820/3631172/a74a7866-0eb3-11e4-9591-1320ba0c326a.png)

This is nicer in that if you add styles on `span`, your text nodes now won't be affected. Similarly, the target of mouse events will now never be a ReactTextComponent span because the script elements aren't rendered at all.

Test Plan: jest, and some simple browser sanity checking.
 Thoughts? Haven't benchmarked or tested in IE8 yet.
 I would think that we could just insert comments instead (but perhaps that messes with React)? But why not solve it properly? It can't be that hard to just merge adjacent strings just before rendering to the DOM, or can it?

PS. It might be worth using `<noscript>` instead as I assume it would have less overhead (and also less confusion if something tries to grab all scripts on the page, it's also what we use for `null` so it makes sense). To me this seems like an interesting short-term solution that I would be OK with (if merging adjacent strings is out of the picture for now).
 Btw, the image up there has an inconsistency, `b` disappeared in your final version. Bug or just a change in the source code? (I'm guessing the latter)

Btw 2, due to issues with non-visible tags in IE8, this will cause the workaround to trigger a lot more often, which will degrade performance somewhat (but it's not horribly slow and unlikely to significantly affect real-life use).

Also, :+1:
 Hmm, it should be quite easy to use comments instead:

```
<!-- .0.3.0 -->
If your BAC is
<!-- .0.3.1 -->
then test...
```

Which is much less hacky and not unreasonable for a framework to do. We don't need any special safeguards as users cannot create comments in React so it's safe "by default".
 b tag was just a change in the source when testing, not a bug.
 ~~I just realized that we sadly can't go this way at all. We still rely on `_mountIndex` and some browsers _do_ arbitrarily split TextNodes which would obviously offset child indicies.~~

However, I'm pretty sure we could start using the `data`-tag instead, it does apply to us according to my interpretation of mozillas interpretation, and would have the end-user same effect as this. Although, it is styleable too (but considerably less likely to be styled by the user).

https://developer.mozilla.org/en-US/docs/Web/HTML/Element/data There they use it to associate text with UPC codes as their definition of "machine readable", i.e. it is context sensitive and there is no implied context, so it should be totally fine to use with reactids.
 That's why I use `.children` instead of `.childNodes`. I believe this works fine.
 Aaah, I thought about that but it seemed like it wouldn't work, but you're absolute right it does. Awesome.
 Why is this better?
 @sebmarkbage No spans that can be styled. So for all intents and purposes these are "invisible" as opposed to the current spans.
 Yup ‚Äì script tags don't get styled and you won't ever get them as the target of a mouse event. I think it's a minor improvement but am willing to drop it in favor of fixing this properly later.
 I'll close this out but we can bring it back if we later decide we want it in.
 I'll think on it.
 For context, this is a breaking change that can affect a lot of existing code (including all of Facebook). Meaning it is a lot of work for us and others when they upgrade to make sure that styles or rogue query selectors still work.

That's why it's not so easy to just take it as interim solution. It still incurs a lot of work. That's why we figured that we'd only do that work once, with a proper fix.
  Someone's working on it
_looks around_

In the meanwhile, you can put some stuff here: https://github.com/facebook/react/wiki/Complementary-Tools
 NPM/bower is the go-to source for this AFAIK and probably preferable to maintaining a list of our own.
 This sounds rather broad, and with the explosion of the components around React, is not something we could maintain in a good shape, so I‚Äôm inclined to close. There are a few community resources available now:
- https://js.coach/react
- https://react.rocks/
- http://react-components.com/

I hope this helps!
  Good points I think :+1: 
 I don't think we want a runtime warning for key. The common case is to clone a component passed from owner to child, and keys in the owner don't make any sense when rendered in the child. Instead we can just lean on our existing key warnings I think.
 @WickyNilliams Can you give an example of how you were using cloneWithProps?
 React.Children.map essentially preserves the key property in its returned component list so you don't need to worry about providing it for React's sake (to help it with reconciliation). In master, `.props.key` is no longer accessible on props (in part to emphasize that it's not copied) and you should pass your own separate key (`itemKey` or similar).
 I created #1991 because the current situation seems illogical to me. Perhaps we can get some better clarity there.
 Seems good to take and have on the site for now.
  Wow this sounds like a big regression. Can you construct a simple repro case?
 This might happen always if you setState within a componentWillMount? Agree that we need to fix this.
 Oh, setState() is probably going through ReactUpdates which is using the (browser-specific as of 0.11) ReactReconcileTransaction I think.
 @gasl maybe? why are you doing that vs `getInitialState()`?
 Trying to figure out if the right move is to fix `setState()` in `componentWillMount()` or instead forbid `setState()` in `componentWillMount()` in favor of `getInitialState()`. Thoughts @spicyj?
 The former; we've always said this is supported.
 but why do we support it? seems like "more than one way to do it"...
 One use case is computing something based on props in both componentWillMount and componentWillReceiveProps; you can make a helper and call it in both places.
 ``` js
getInitialState() {
  return helper(this.props);
}

componentWillReceiveProps(nextProps) {
  this.setState(helper(nextProps));
}
```

does the same thing, no?
 We're going to put out 0.11.1 with this (and a couple other ride-alongs). Thanks for bringing it to our attention!
  Good call. I always forget `git push --tags`. It's up now. https://github.com/facebook/react/tree/v0.11.0
  Thanks!
 oops! Thank you!
  Thanks!
  ![image](https://cloud.githubusercontent.com/assets/6820/3618044/b163175a-0de5-11e4-9907-a8c17bbc7f13.png)

Tricky because you could actually use a React root element as a container‚Ä¶

cc @dylanvee
 It's kind of late, but isn't this straight-forward? You shouldn't be looking at the mount node, but the node being unmounted. If it isn't a root id only, you've done something wrong.
 @crm416 Well no, my point is that you do _not_ want to look at the container pointed to by the argument, but only its children. If it doesn't have a React-node then everything is good, if there's a React node there then it must be a root node or it's an error.
 @crm416 Unless I'm mistaken, it's the only error that makes sense.

``` HTML
<!-- OK -->
<div mount-here>
</div>

<!-- OK -->
<div reactid=".0" mount-here>
</div>

<!-- OK (empty) -->
<div mount-here>
  <div></div>
</div>

<!-- OK (reuse)-->
<div mount-here>
  <div reactid=".0"></div>
</div>

<!-- OK (empty) -->
<div reactid=".0" mount-here>
  <div></div>
</div>

<!-- OK (reuse) -->
<div reactid=".0" mount-here>
  <div reactid=".1"></div>
</div>

<!-- ERROR -->
<div reactid=".0" mount-here>
  <div reactid=".0.0"></div>
</div>
```
 @crm416 Perhaps we're misunderstanding each other. :)

It seems to me that your example is equal to mine (it's just deeper down the hierarchy), it's not about the node with `mount-here` at all, it can be valid to mount there even if its React ID is `.0` or `.0.1.2.3`. So only the child is important, if that child isn't a React root (i.e. `.0`) then it's an error, when it's a React root it's "reused".
  Is this no longer an issue?
 Never mind, I see #1900.
  Personally, I run with much simplified helper instead, that only supports the equivalent of `$apply`. That allows me to work with immutable data as if it was mutable, with the regular functions for mutating.

Something like: (`immutate` simply shallow clones)

```
var nextObj = immutate(prevObj, {
  user: function(obj) {
    obj.name = 'Test';
    obj.permissions = immutate(obj.permissions, function(arr) {
      arr.push(1);
      arr.push(2);
    });
  },
});
```
 https://gist.github.com/syranide/d75f32ebad237112d324
I haven't really vetted it yet, but it should work fine.

```
nextObject = immutate(prevObject, keysToMutateOrMutator);

var prev = {value: 1, permissions: { ids: [1,2,3] }};

var next = immutate(prev, function(user) {
  user.name = 'next';
  user.permissions = immutate(obj.permissions, { ids: function(ids) {
    ids.push(4, 5);
    ids.shift();
  }});
});

prev before: {"name":"previous","permissions":{"ids":[1,2,3]}}
prev after:  {"name":"previous","permissions":{"ids":[1,2,3]}}
next after:  {"name":"next","permissions":{"ids":[2,3,4,5]}}
```

I've also thought about getting rid of the redundancy when mutating by providing a second argument to the callback, that could look like: `function(user, mutate) { mutate({permissions: {ids: ... }}); }` but haven't thought that much about it just yet.

PS. As always, use at your own risk :)
 ```
var next = {
  ...prev,
  name: 'next',
  permissions: {
    ...,
    ids: prev.permissions.ids.slice(1).concat([4, 5])
  }
};
```
 @spicyj Oooh, very interesting use of the spread operator (or whatever it is called).
 @jardakotesovec #2362

@Gonzih: [immutable-js](https://github.com/facebook/immutable-js) is a fully featured immutable collection library that provides the helpers you want and more. Since `update` is getting deprecated/pulled out into its own repo, we can always come back to this after that.

@petehunt can we close this now?
 As far as I know the current thinking is that `React.addons.update` is in maintenance mode and will not get new features. We encourage people to look at Immutable.js or alternative libraries that deal with plain objects instead.
  It's not supposed to be used in production. You should precompile your jsx for that purpose.
  I'm assuming refs are cleaned up after `componentWillUnmount`, as opposed to after all life cycle methods in the current transaction have been called and the parent is apparently notified before the children. But this touches on another interesting question IMHO, shouldn't (notification of) unmounting occur from child to parent? (i.e, reverse of mounting)
 Well, I think the parent needs to be notified of the unmount before the child actually gets unmounted so you can clean up event handlers, etc. from a rendered child component? It might work to notify children first but wait for parents to be notified before actually unmounting the children.
 @spicyj Yeah, I would expect notifications to flow from children to parents, once _all_ affected instances have been notified they're all unmounted in some unspecified/undefined way.
  Can you provide a test case that fails before your fix?
 Can you add some test cases to `ReactTransitionGroup-test.js`? That way we can ensure that this works as expected in real-world cases.
  Your problem is that you're accessing uninitialized state properties?
 For components that don't need state (which could easily be the majority), avoiding an allocation is a win. There has also been informal mentions of not allowing setState to set keys that doesn't already exist, i.e. they must be initially set to `null` or equivalent... for code sanity and improving performance/memory usage. I like that idea a lot.
  :+1:
 @nschaubeck To be clear, ReactTransitionGroup will unmount and remount a child only if the key changes ‚Äì this means if you change the contents of a child without changing the key, it won't animate. If keys are omitted, React assigns sequential increasing keys to the elements, meaning that a single unkeyed child will effectively have the key `0`. If you're switching between no children and one child, you'll still get an animation even if you don't specify a key but usually providing a key is what you want, which is why it might be nice to give a warning.
  Please don't use GH issues for debugging. If you find a bug with React behavior or implementation, then reopen. Stack overflow, the mailing list, or IRC are all great places to get help with a specific integration point or questions about your specific use.
  Nice. We'll also want to make sure we transform `<picture>` so we'll need an entry here for now: https://github.com/facebook/react/blob/master/vendor/fbtransform/transforms/xjs.js#L111

Can `media` and `sizes` be set with `node.media = newValue`? Or do we need to use `node.setAttribute('media', newValue)`? Can you just confirm that you've tested modifying a picture element and seen the changes reflected in the DOM
 It's enough to open the console and do `'sizes' in document.createElement('picture')` and same for `media`.

PS. Also, the answer seems to be no, they're attributes only.
 @zpao Btw, it should've been asked before `srcSet` was added I guess. But before we go ahead with this and solidify it even more; shouldn't `srcSet` be handled the same way as `style` and "soon" `classList`? I.e, shouldn't it only accept `Set` (and perhaps `Array` as we are lenient with `style` right now) as opposed to a string.

Or perhaps it shouldn't because because http://www.w3.org/html/wg/drafts/srcset/w3c-srcset/#additions-to-the-img-element says it's a `DOMString`, which is kind of weird? It would seem intuitive to treat it like a `Set`.
 @syranide - not a bad idea, might be good to evolve to that. For the time being though, let's keep it as a string since that's the only API in the DOM (`style`, `classList` are exposed on a more granular level).

@fgnass - if these can only be set/get via attributes, then we need to make sure we specify `MUST_USE_ATTRIBUTE` in the config. Please test a React example using your changes in a browser that supports `<picture>`.
 @fgnass Did you test changing any of these attribute values? That's the real test. Initial render doesn't go through the path the needs to set `node.property` or `node.setAttribute()`, it only makes some html that's used for innerHTML.
 if attributes work everywhere let's just do that.

And there's no need to rebase (unless you want to rebase against master). All the files should still be in the same place...
 @zpao Hmm, an idea would be to have a `CAN_USE_PROPERTY` flag, it would check that the property exists for a specific tagName else fall back to use attribute. This would allow properties to be used when available and when browsers lack support it uses attributes (so polyfills/etc still work, etc). I'm guessing this flag could be applied pretty much across the board... #1512? :)
 @syranide Keep those ideas in the discussions they belong, otherwise they get lost :)
  As has been previously mentioned, `cx` is statically transformed at Facebook to a series of string concatenations so we're not planning to change it. You can of course make your own helper that works however you want. Also note that with ES6 syntax you'll be able to write

cx({  
  'block': true,  
  'block--active': this.state.active,  
  ['block--key' + key]: true  
})

(That transform isn't supported by `jsx --harmony` yet though.)
  I haven't really thought this through extensively yet, but I figured it could be worth just having a discussion about it.

We must currently run the entire `render()` function for every change that happens, regardless of how insignificant the change is. When animating we often just want to change the position or color of a single element, but still have to run the entire `render()` every frame.

Just to give you an idea of what I mean, it could look something like the code below. But I imagine that there are also more fancy ways of doing it, where you could instead get an observable for any variable in state/props, avoiding the creation of mutable observables in state and making it more React:y.

**Edit:** To be clear, this shouldn't replace the render()-function, it's meant as a feature for when you really need to squeeze every last bit of performance out of animations and other performance intensive (but individually simple) updates.

```
var Comp = React.createClass({
  getInitialState: function() {
    return {
      boundWidth: React.observable(this.props.width)
    };
  },
  componentWillReceiveProps: function(nextProps) {
    this.state.boundWidth(nextProps.width);
  },
  shouldComponentUpdate: function() {
    return false;
  }
  render: function() {
    return (
      <div style={{width: this.state.boundWidth}}>
    );
  }
});
```

Just food for thought.
 You can already do this by subscribing to boundWidth inside <div> and calling this.forceUpdate() on yourself.

The goal here is that for a high perf subset of the app we can keep track of update we need to make from the imperative action that occurred. I think a `this.updateChild(key, nextProps)` would make sense here.
 @petehunt Yeah I forgot to mention that my intention was for it to be unboxed by React, so you could use it on any prop and any component.

You have far more insight into this than me; `this.updateChild(key, nextProps)` seems quite intuitive, but it also seems kind of low-level and any mistake would make the rendered DOM fall out of sync. But it wouldn't be _dangerous_ at least.

Anyway, I'm curious, why not go with `this.refs.key.updateChild/setProps(nextProps)` instead? (I guess the upside with your version is that it cannot error, even if the element disappears during animation, unless we want it to)
 This would be the equivalent of `setProps()` basically.

Perhaps we should allow `setProps()` if the owner's `shouldComponentUpdate()` returns false. That would basically flip React into initial-render-with-imperative-update-mode.
 @petehunt Hmm, that actually sounds interesting. From which life cycle method would you call this? It seems like it must happen after `shouldComponentUpdate`, but there is no such life cycle method right? Do we need a new one, `componentWillNotUpdate`? :)
 I believe this would be called from an event handler, XHR or timer.

Maybe an `isStatic` key on the component spec?
 @petehunt Perhaps I fell of the train of thought, how would `shouldComponentUpdate` come into the picture then? My intuition of what you proposed was that the component could choose to `return false` from `shouldComponentUpdate` to avoid a full `render()`, but could still choose to act on lesser differences and update only a specific rendered component.

```
var Comp = React.createClass({
  ...
  render: function() {
    shouldComponentUpdate: function() {
      return false;
    },
    componentWillNotUpdate: function(prevProps, prevState) {
      if (prevState.left !== this.state.left) {
        this.refs.ani.setProps({left: this.state.left});
      }
    },
    return (
      <div>
        <Animated ref="ani" left={this.state.left} />
      </div>
    );
  }
});
```

So that it could look something like that, where it would still be stateful and you could even mount a component mid-animation if you really want (i.e, `setProps` becomes strictly an optimization only). If it isn't stateful, how would you then deal with a render() during animation? Wouldn't it overwrite the props you animated?

Or perhaps even something like:
(removed code)
**Edit:** Stratch that, it really wasn't a good idea to do that...
 @nhunzaker Definitely, but `forceUpdate()` invokes `render()` which can potentially be really quite costly when you only want to animate a single attribute, unless you isolate the animating node in a separate component (which is quite cumbersome).
 Closing this, nothing actionable here for the moment.
  And apparently IE8 needs this to be `styleFloat`‚Ä¶ :hurtrealbad: 
 #1854 went in, so this is fixed. Thanks for reporting!
  Awesome. Let's hold off until 0.11 is shipped and refer to that, then merge this in.
 Thanks!
  Used to work. Will no longer work with the upcoming descriptor changes. @sebmarkbage has some ideas.
 There are two pieces to this. The simple one is when you are expecting a single component. We should have a special propType for this.

``` javascript
propTypes: {
  header: React.PropTypes.componentOf(OtherComponent)
}
```

That's simple. Someone send a pull-request?

The second part is if you want to accept one of several unknown components that are considered compatible. In XHP in Hack we use something called categories.

The third part is when you want to combine these two types of checks with a set of items. What if you want to allow a union type? What if you want the first item to be of a certain type and the remaining items another type?

@azich has some ideas around this.
 Another case is if you want to accept any composite that renders to a  `<td>` (for example), not sure if that's covered by XHP categories.
 Yea, the current work around is something like: `shape({ type: oneOf([MyComponent]) })`

I think we need a broader solution than testing for specific types. Usually you want it to correspond to some specific interface but the actual implementation is flexible, or have a certain set of props defined on it.
 > propTypes are mostly in a sort of maintenance mode and we're not really planning to add more to them right now.

Proptypes are being phased out in favor of tools like Flow.
 > That's simple. Someone send a pull-request?

At least part of this is something we should "maintain".
  Do we want this above @petehunt's jsconf.eu talk? Guessing not‚Ä¶
  JSX and React are both GCC compatible AFAIK and intentionally do _not_ quote keys, meaning you shouldn't use quoted strings for them either, that way you benefit from the key mangling in GCC.
 I believe React is not quite closure compatible but we'd happily take pull requests to fix any small issues we've missed.
 So what's actually stopping this from working today? My understanding of GCC was that it would crush keys to the same value, so when you did `{foo: value}` and accessed `this.props.foo` in your component, it would "just work". Am I wrong in understanding how GCC works?
 I believe it is possible to use React with an appropriate GCC externs file listing all of the properties, though we don't currently have one. Ideally we could compile React itself with GCC but I believe this won't work properly right now.
 > because there isnt any way to tell GCC that POJO passed into SimpeComponent will be then available at `this.props` of AnotherComponent and he don't pair their names.

I was under the impression that GCC would always munge a property key the same way if it appears more than once, even if the two objects are unrelated. Am I off base? Compiling this

```
alert({prop1: "hi", prop2: "there"});
alert({prop2: "there", prop3: "!"});
```

at http://closure-compiler.appspot.com/home with advanced optimizations selected gives me

```
alert({b:"hi",a:"there"});alert({a:"there",c:"!"});
```

which looks like it's mapping `prop2` to `a` in both cases.
 My understanding is that GCC won't munge any property keys that appear in an externs file, regardless of whether the specific callsite refers to the third-party library.
 No, you should include an externs file for React and then build all of your app JS together; GCC will munge the app-specific properties and leave the ones that React cares about alone.
  ```
Invalid prop `0` ...
```

Seems straight up wrong to me as the prop name is actually `modifier`, so probably in need of a proper error message and I don't see why a (truncated) value couldn't be shown.
 haha, i have a pending change for this internally already :)
 Yo @petehunt where's this change?
 I left some comments on that diff but @petehunt's too busy all the time! =)
 yeah, @petehunt where's this change? :)
 `createEnumTypeChecker` (and others) uses the format `props[propName]` to get the prop value. So `createArrayOfTypeChecker` has no choice but to pass the index as the prop name. I think the correct way to do this is to pass the prop value explicitly. I think I might have a hack to make this work nicely though. Forgot what pete's PR looked like
 @brigand possible but that might require an API change? I'm not sure whether it's worth it at this point
 Looks like this might have been fixed in https://github.com/facebook/react/pull/3737

Either way, we aren't actively working on the proptypes feature anymore (everything is moving to static analysis tools like Flow), so proptypes are on their way out. I'm not sure if we'd accept a PR, but I don't think this is something we'd actively develop internally at this point.
 Since people have been coming in from Reddit‚Ä¶ PropTypes are not being removed anytime soon.
 Please read my earlier comment. PropTypes are not being removed anytime soon. PropTypes do not log in production applications either, only in development mode. Flow in its current form would only log in CI or on explicit execution (they are static checks after all). The idea of Flow gaining support for a development transform which would embed runtime typechecks has been discussed but we're not there yet.
 Let me also clarify: There is an idea to unify the type system semantics with Flow so that there are equivalent concepts in either direction.

In case people prefer early adoption of the syntax extension that Flow provides (which is being unified with other similar systems so that it can eventually end up on the standardization track) then they could compile those into development time runtime warnings.

However, there would likely be a runtime only alternative without syntax sugar available too. Although it might be less convenient. Compare something like `async/await` to `Promise`. If you don't want to use the syntax extension you don't have to. There won't be a requirement to use language extensions to use React. However, all of these are hypothetical ideas and until this becomes real and adopted: PropTypes will remain and be maintained.

It is unlikely that it will evolve in a direction that is incompatible with Flow-unification that is all. If a new unified system does evolve, there will be a suitable upgrade plan.
  We may end up dropping these in the future, it's hard to keep them current. But for the time being I don't think this hurts to have, especially since we don't expose them (though they are reachable).
  As I said on IRC, I'm personally kind of in favor of it, but not 100% sure that I really am. :) I do like the idea of JSX tags working as if they were part of the JS syntax and not a special "parser state".

The only issues I see is that any intended occurence of `//`, `/*` or `*/` in text would be invalid and would have to be quoted as `{'//'}`, etc. Is that a common occurence? I really don't think so.
 @glenjamin It doesn't _really_ understand comments today, `{/* ... */}` simply escapes to JS where comments are understood. While it should be simple to fix `{// ...}` to be rewritten into `{/* ... */}` for the sake of not messing up the output, it would be nice if JS-comments could be used anywhere (that sounds intuitive to me).
 `{//}` looks quite magic to me and I don't think there's anything to suggest whether or not it would be consistent, `{/*...*/}` is an entirely different beast as what comes after `/*` is no longer JSX, it's _anything_ (up until the closing `*/`). So, I think for it to _actually_ make sense it should be written as:

```
{// ...
}
```

Which I assume actually works today (but perhaps not, due to JSX intricasies)? Not that I would ever want to use that syntax. Anyway, by closing it as `{//}` you're suggesting that what comes after the comment actually is JSX again, to me. The closing `}` is actually part of the comment as well (but still affects the parser) which seems like an odd feature.

Alternatively `{// ... }<JSXAgain />` could make sense too, but I'm positive that that `}` would be too common inside comments for this to make any practical sense (it will also mess with non-JSX-aware highlighters).

Side-stepping, intuitively, it seems kind of weird that this is valid:

```
return (
  /*<div>
      <span>
      </span>
  </div>*/
);
```

Whereas this is invalid:

```
return (
  <div>
      /*<span>
      </span>*/
  </div>
);
```

cc @jeffmo any opinion on this?
 @glenjamin Right, but in practice, doesn't that basically void the entire purpose? Because I couldn't use line comments even for the following line `<Comp value={str} />` as `}` occurs in it, and I don't want it to stop there.
 I'm just going to close this out, I think there's very little chance we'll do it. There's also the issue of needing to make sure this is actually supported in the spec, which I'm not sure is even going to be possible.
  https://github.com/facebook/react/blob/8a47813baabcb200f5e0a496dd959cb0ef3adcf3/src/vendor/stubs/cx.js#L36

If we get rid of `Object.keys` we save one allocation for a potentially commonly used function (except for you guys running your internal transform). Yes no?
 @twobit You're free to implement your own version as you see fit, I think the idea behind classSet as it is, is that with fixed classNames they can be mangled/minified to use considerably less space.
 Closing this since we're deprecating `classSet` (#2910). The new alloc-free version lives at https://github.com/petehunt/react-classset
  http://stackoverflow.com/a/15153990 so not quite straight-forward to support apparently.
  If state needs to be shared among multiple children, it should live in the parent. If a child needs to update the state, then it should be done using callbacks, the parent provides `onXYZ={func}` which the child calls as `this.props.onXYZ()`.

Information flow from parent to child uses props, information flow from child to parent uses callbacks.
 Feel free to keep discussing, but closing out as it's not a bug.
  No worries, I appreciate the initiative! Don't hesitate to fix more typos or inconsistencies if you find them :)
  @nhunzaker ... @zpao or some other dev should weigh in on this.
 cc @yungsters 
 (Also, sorry! We're getting out of a large backlog of issues/PRs and unfortunately some have slipped through the cracks completely :disappointed:)
  Sorry for the confusion! I hope the docs cleared up our reasoning (I would have linked you to the note in [this part of the docs](http://facebook.github.io/react/docs/tags-and-attributes.html#supported-attributes))
 I prefer the tried and true "search all my files" since this is a very specific case. Here's how you could do it with `grep`. You IDE probably also has a "find all in project" feature.

``` sh
grep -rn 'for=' <path>
```
 Please read the above discussions and links. Our reasoning is covered.
  Thank you!

(CLA signed ‚Äì see #1812.)
  Thanks!
  :+1: 
 :+1: 
 :+1: 
 Not to be a downer, but Flux Capacitor does not sound intuitive to me (sounds more like buffer+flush / batching to me) and there are already people questioning the legitimacy of Flux. I sincerely don't think it would benefit from naming that obviously tries to be cute rather than descriptive.
 I think it's a funny (and as you point out, actually pretty fitting) idea, 1000 internet points to you @dansowter.

But I agree with @syranide and I don't think we should actually do it.
  `this.refs` is always an empty object since 6666538316c0a7384b4ceca01aa364c9f615c9d0 (will be in the upcoming 0.11).
  Perhaps this is supposed to use mergeInto instead of copyProperties.
 Using mergeInto seems like a sane option. I think we want to kill copyProperties anyway. cc @petehunt 
 @slorber Not disagreeing with your idea, but it's generally preferable to set it to `undefined` rather than delete it (as per how V8 handles objects).
 `Update` now uses the `Object.assign` shim, so this should be solved.
  This is more the problem of the packager than React, isn't it? But yes, it's indeed a problem for any module.

If A depends on React 0.9 and B depends on 0.10, making both depend on 0.10 will likely produce even more confusing errors. And even if you do that, there's no guarantee A will work.

I think the best you can do right now is keep the modules up to update (not always possible with third-party stuff...), and then dedupe them in browserify/whatever you use.
 Well, #1165 isn't really a problem of the packager, but is a problem with multiple versions being out with different modules depending on different versions. It's going to get worse when there is a pile of plugins and components that all depend on a different version and you end up with 5 copies of React. That's both a blessing and a curse of package managers with local version scoping.

You can `npm dedupe` but again, versions... I doubt it dedupes when different packages have incompatible dependency listing.

I don't know how we're going to solve it. `require('react/this')` doesn't really sound like it helps. I'd love to hear suggestions, but nothing is jumping out as some holy grail.
 @greim Intuitively the question is: where does it end? What modules are and aren't part of the core then? Should all these modules really have to be maintained by the devs? What about all the less common sugars/packagers out there? It's also really weird that all those tools would be tied to the release schedule of React, but if you're using the standalone bundles of React they're not?

It kind of also goes against the whole idea of NPM/decentralizing as I see it. Duping of React versions may be an issue (with NPM) in edge-cases, but to me that doesn't sound like invitation to bring more things into the React package, but rather, create a tool or add necessary code to React that ensures that there is only one version of React and throws an error if there isn't.
 80% of who's use cases? Yours? Mine? A Ruby on Rails developer? Packaging like this would have solved browserify users' problem. But what about people using webpack? Or require.js?

If we owned every single React-related tool and component, we would never have a chance to improve any of them. So we have to draw the line somewhere. Supporting CoffeeScript is a non-goal, so I'm happy to let people figure out how to make that work. We're going to continue changing what JSX desugars too and what characters React escapes as needed, so we might have more cases like #1165. We'll work on messaging to ensure downstream developers can test things out and stay up to date, but there's just no way we can build/maintain everything.

We definitely need to figure out public API parts and a plan for plugins. I'll probably reach out to the npm team and see what they're thinking. They know it's a problem and they've been talking with some other projects.

As this issue goes though, I think we can close it out. But feel free to carry on the discussion and we can reopen if we get to an actionable place.
  In a world where this component was server-rendered, we wouldn't want to call the data-fetching code there so it makes more sense to have it in componentDidMount.
 :thumbsup: Probably helps in that transition. We still tend to recommend willMount for client side data fetching, but I suppose that doesn't matter terribly (not at all for the example, might just send some mixed messages).
 Let's update the tutorial repo too
 774f5a022eacbb054b09aa5a7d596186874b2600
  We used to do this actually. But we don't look at `propTypes` in prod. We're also making some optimizations around getDefaultProps so we're not going to go back to this. I like that you're thinking about this though!
 Additionally, `getDefaultProps()` has the nice property that it allocates new objects. With your version if a user decided to mutate a prop (hey, it happens), since all default props would share the same reference they'd all get mutated.
 @zpao I don't see why the caching of `getDefaultProps` (or that's what I assume you're referring to) would exclude this possibility since these would be static values as well, but just added to the default props object before freezing. PropTypes could be more or less empty shells in prod, like they already are I assume.

(But I agree with your decision)
 @petehunt getDefaultProps is called only once and cached in master.
  This isn't true, but it replaces the contents of the node, which may be valuable to state.
 What @spicyj said. Let's reword it to be truthful. Also, let's use our other formatting we have for other notes (see it in action - http://facebook.github.io/react/docs/top-level-api.html#react.unmountcomponentatnode)
 @zpao My comment on IRC was with regards to react-future `toElement` which I don't see why we wouldn't support in the future, failing that for some obscure reason, `React.renderComponentAtIndex` should be near trivial to implement. So `React.renderComponent` will always clear the node it mounts into, that's simply the nature of that API call, but I'm sure there will be other API calls that don't.
 Yup, we plan to have a toElement: #1711.
 Thanks!
  There should be a way do do `<input type="checkbox" indeterminate={true} />` or similar ‚Äì right now the attribute is ignored. Need to figure out how this interacts with `checked` though.
 https://mdn.mozillademos.org/en-US/docs/Web/CSS/:indeterminate$samples/Example?revision=601267 is fun to play with.

Not impossible to support, but that's annoying.
 Sorry, what's annoying?
 The correct combination of indeterminate and checked. (eg indeterminate=true and checked=true is impossible, indeterminate=true and checked=false is ok _edit_, even when you explicitly say checked=false)
 The drawback is that your are mutating the DOM manually, which kinda sucks. You also want to make sure this happens in the right place for each subsequent render.
 Well, on a re-render `componentDidMount` will not get called so you also need to do it in `componentDidUpdate` to make sure it happens there if needed.
 Maybe we should do `checked` equal to `true`, `false`, or `'indeterminate'`? :\ I am clearly an API design genius.
 Ooh, good find.
 > It seems against React's nature to patch something that doesn't actually exist in declarative DOM land?

@yaycmyk Correct. IMHO it's arguable, but server-rendering in a way necessitates it and seems like a hard problem to otherwise decide where to draw the line. It's really weird that there isn't an attribute for it. Interesting.
 Our form components go a bit beyond what normal HTML attributes give you.
 @spicyj Huh? Yes they add additional run-time functionality (i.e. controlled), but the initial state of them all is entirely captured by attributes right? Or am I missing something.
 Yeah, that's true.
  What browser are you in? Does it work if you write `<section id="todoapp"></section>` instead without the wrapper div?
 Good find, but it looks like @spicyj's suggestion works. Let's just do that.
 Thanks!
  Yes, that's how key events work in JS ‚Äì what you want is to bind to key events on window, which we don't currently have a way to do. Closing as a dupe of #285.
 @bakesteve Setting `tabIndex="0"` in React has the same effect.
  Add `onPaste` to the list of events that don't bubble on IE8 I assume. If this is a priority for you, you can work around it by manually installing the event listener during `componentDidMount` for the input instead.
 @brendanmoore Keep it open, this should probably be fixed in core (other non-bubbling events have I believe). I don't think you _have_ to remove it during `componentWillUnmount`, but I too do it just to be safe.
 We are not actively supporting IE8 since v15 so I am closing as it‚Äôs unlikely somebody would work on this particular problem in the future. However if you feel strongly about this, you can submit a PR with a fix, and we can discuss again there. Thanks!
  Looks great. Thanks!
 Envify is used automatically when browserifying react.
  Going to close this in favor of #1293, which I believe would solve your issue.
  @volkanunsal Delaying focus() until the next requestAnimationFrame/setTimeout is probably your safest bet. It seems that even though elements have finished rendering and are attached to the DOM, that is not a guarantee for focus() succeeding.

Personally I wouldn't mind adding a focus() method on the base DOM-component that could incorporate this "fix", but it's tricky decision I think, since there are a lot of other features that could be considered equally necessary, but doesn't really have to be supported by React (you can just have your own external focus-helper). It makes sense to only keep the required features part of React in the core and anything that is optional out of the core.
  This is actually an `<input>` - we've added the workarounds to make sure disabled `<button>`s actually behave correctly here. This holds for all disabled inputs it seems.
  This is one of the main motivators for the recent changes to separate component instances from the descriptors specifying them ‚Äì this works correctly in master (and will work in 0.11 when it's released, hopefully soon).
 Perhaps it should be mentioned that moving children like that causes them to be **unmounted and then mounted** again, they will not retain state or reuse DOM. So it should be preferable to not move them around but rather add/remove CSS classes to achieve the desired effect.
 True. I believe @chenglou is actually working on a solution to preserve state in that case.
  cc @jordwalke who wrote those tests originally. I think that hopping is probably a good feature to continue supporting (probably opens up a few doors for performance hacks).
 I think it's very unintuitive if that doesn't work. We might need to restructure how refs are attached/detached a little bit in order to give an error in the right situations here.
 @kimagure apologies for the delay, it's a busy time so we may not have a chance to address this in the next few days, but stay with us, we definitely need to do something here. Also FYI, there's a change coming very soon that will move some of this ref stuff around (just off props) which might have an impact here.
 also cc @sebmarkbage, perhaps you could speak for @jordwalke 
 @zpao From what little I understand of the new ref-system, it seems that this specific issue would no longer be a problem, although reusing the same the ref-object would result in a similar issue unless already considered (although with a different fix than this one I assume).
 Unfortunately, I think no ‚Äì see my comment at #1782. Thanks again for sending this in.
  Sorry, been really busy and this has been lower priority. Let's get the spacing issue addressed. Getting this right the first time is important because remembering & finding the time to go back and update is not as likely as one might hope.
 Sorry for the long delay on this ‚Äì we've since changed the tutorial to reference the https://github.com/reactjs/react-tutorial repo which contains various server implementations for the tutorial so I'm not going to take this. Thanks for sending this in!
 Sort of treating that as my job for today. :)
  Well, I don't hate it so that's a good sign :)
 Ok. Let's do it. I won't be afraid to kill it if there's enough reason.
  What if we just had `transformRaw` (`rawTransform`?) and we just returned the result of `transform` without the cleanup you have? Maybe that's too raw‚Ä¶

If not, we should maybe return `sourceMap.toJSON()` since that's a real source map, not the raw object SourceMapGenerator object from the source-map module.
 Hmm, yea that's a good point. Ok let's do what you have there (I want to reformat some of this code in the future but that's not a big deal), but let's address my point about `sourceMap.toJSON()` - same reason as you gave, if we don't do that it's an internal representation.

I'm still not wild about `transformAsObject` as a name, but I still don't have a better answer. I sort of want `transformTo______` or `transformWithDetails` (though that's a terrible name too). Let me know if you get inspired with something else :)
 And yes, I think we should try to get this in for 0.11 :) I won't block on it but it's nice to have.
 Another option could be to use a different word like `compile` or something, but that might just be more confusing.
 Thanks!
  If you (presumably accidentally) use the same ref on two components and then remove the second one, you would expect the ref to point to the first one but it doesn't.

Either this test should pass:

``` javascript
it('should work when removing a ref with a duplicate name', function() {
  var Component = React.createClass({
    render: function() {
      return <div>
        <div ref="dupRef">A</div>
        {this.props.showB && <div ref="dupRef">B</div>}
      </div>;
    }
  });

  var instance = ReactTestUtils.renderIntoDocument(
    <Component showB={true} />
  );
  // Second <div /> tramples over the first
  expect(instance.refs.dupRef.getDOMNode().innerHTML).toBe('B');
  instance.setProps({showB: false});
  // Now only the first child <div /> exists so the ref should point to it
  expect(instance.refs.dupRef.getDOMNode().innerHTML).toBe('A');
});
```

‚Ä¶or we should throw an error upon first render when trying to use a single ref in two places.
 I think we should error in the first place (though perhaps that will be expensive?)

cc @sebmarkbage @jordwalke 

Could be a good bug for @thedekel or @chenglou to jump into if we know expected behavior.
 It would probably make the most sense to do it in ReactOwner, but in addComponentAsRefTo (not attachRef). This would be sort of analogous the existing check in removeComponentAsRefFrom.
 In light of first-class refs (#1373), I think we need to wontfix this. :( Thanks @kimagure for sending in this PR though ‚Äì I appreciate it even though we're not going to end up taking it.
  It's available through `this.type.displayName` or perhaps it was `this.constructor.displayName`, I never remember. :)
  :thumbsup: Thanks!
  Are you talking about this page?

http://facebook.github.io/react/docs/component-specs.html

Easy to change "Invoked once when" to "Invoked once before" ‚Äì is there something else you were hoping for? It already says "This method is invoked before getInitialState and therefore cannot rely on this.state or use this.setState.".
  Perhaps you can install jsx on a machine that has internet then tar up the node_modules folder and send it over?
 Something like:

```
mkdir throwaway
cd throwaway
npm install react-tools
tar czvf node_modules.tgz node_modules

# ...

tar xzvf node_modules
node_modules/.bin/jsx ...
```

should work.
 I think you'll want to tar up the whole react-tools directory and send that over. We do still depend on `node` being available - `jsx` uses it.

We do have a ruby and python package that is capable of transforming JSX -> JS but that's based on other asset pipelines (eg Ruby on Rails). They make use of JSXTransformer (which we ship for the browser) and loading that into an JS environment (eg V8 directly, but assuming Java, Nashorn should be doable as well).

Not really anything else actionable here at the moment, so I'm going to close out.
 I found this to be super helpful, removes the node dependency for nashorn: https://gist.github.com/aesteve/883e0fd33390451cb8eb
  - [x] @gasi - I consolidated your entries (changed email address in AUTHORS) - let me know if you want a different one listed.
- [x] @enome - Added your name from GitHub account. Let me know if you want it changed.
- [x] @remixz - Ditto
- [x] @irae - Ditto
- [ ] @georgesisco - Added your name from other commit in this repo
- [ ] @plievone - You had another commit with a different email address, so I associated with other one we had. Let me know if you want the one listed changed
- [x] @rayqian - just have "Ray", ok by you? I can put a full name if you want
- [ ] @davidxi - No name for you and none listed on GitHub, let me know if you want something else in there.
- [ ] @imagentleman - Ditto (sorry, I think I might have asked you this for 0.10, yours isn't new)
- [x] @volkanunsal - Ditto
 @remixz @volkanunsal Done & done.
  In 0.10 you can refer to the convenience constructor in `statics` with `this`, especially useful for mixins. This is no longer valid in master it seems.
 cc @zpao 
 Almost certainly caused by @sebmarkbage. What's our expected behavior there Sebastian (and let's add a test to ensure we at least know when we change this).
 Statics were defined twice. Both on the constructor and the convenience constructor. These previously got two different constructors and there if you called `<Foo />.type.method()` or `Foo.method()` you would get two different `this` values. Now it's consistently the constructor. This is inline with the react-future proposal to get rid of the convenience constructor around components. In that case, you would only be able to access statics on the real constructor.
 @sebmarkbage 

```
var Comp = React.createClass({
  statics: {
    createComp: function() {
      Comp()
    },
    createThis: function() {
      this()
    }
  },
  render: function() {
    return React.DOM.span()
  }
});
Comp.createComp();
Comp.createThis();
```

I would expect both to yield the same result (perhaps wrongly), shouldn't `this === Comp` inside the static method? It was true in 0.10, but in 0.11 the second one errors.
 "this" refers to the class and not the convenience constructor aka descriptor factory. "new this()" should work to create a component instance.

In master you should be able to do React.createDescriptor(this, ...) to create a descriptor from the class.

This change was introduced because previously it was possible to call static methods with two different "this".

It is also preparing to move out descriptor factory from createClass and into the consumer.

> On Jul 15, 2014, at 3:29 AM, Andreas Svensson notifications@github.com wrote:
> 
> @sebmarkbage
> 
> var Comp = React.createClass({
>   render: function() {
>     return React.DOM.span()
>   }
> });
> var Descr = Comp();
> var Comp = React.createClass({
>   statics: {
>     create: function() {
>       return this();
>     }
>   },
>   render: function() {
>     return React.DOM.span()
>   }
> });
> var Descr = Comp.create();
> I would expect both to yield the same result and they did in 0.10, but in 0.11 the second one fails.
> 
> ‚Äî
> Reply to this email directly or view it on GitHub.
 @sebmarkbage That's how I interpreted your previous post, but changing `this()` to `new this()` gives `TypeError: Cannot read property 'props' of undefined`. Trying it on our project gives `Uncaught TypeError: Cannot read property 'construct' of undefined` (not sure why there's a difference).

If I add an empty object like so: `new this({})`, it stays quiet, but if I try to render it I get:

`Error: Invariant Violation: renderComponent(): Invalid component descriptor.`

Code that produces that error:

```
var Comp = React.createClass({
  statics: {
    createThis: function() {
      return new this({});
    }
  },
  render: function() {
    return React.DOM.span()
  }
});
React.renderComponent(Comp.createThis(), document.body);
```
 @sebmarkbage 

```
var Comp = React.createClass({
  statics: {
    createThis: function() {
      React.createDescriptor(this, {});
    }
  },
  render: function() {
    return React.DOM.span()
  }
});
Comp.createThis()
```

I assume that's how createDescriptor is meant to be used (it errors on createDescriptor so I cut everything else for brevity), anyway it gives:

`TypeError: Cannot read property 'construct' of null`
 Yea, `new this()` is suppose to return an instance that can't be rendered but it can be accessed for unit testing or whatever. Currently we also have to call construct() on it which is weird but that was always broken.

`React.createDescriptor` is basically just a temporary place holder so that newer JSX transforms will work with older versions of React. It only accepts a descriptor factory as the type argument. There is a newer one landed internally that hasn't been synced out yet. It accepts either a descriptor factory or a constructor as the type argument. We can't pull in everything else with it. `React.createDescriptor(this, {})` will work in the next version.

I don't think we necessarily need a fix for this in for 0.11 since it's earlier behavior was undefined and ambiguous. It's unfortunate that there is no alternative solution for mixins right now though. :(

I'm curious how you're using this pattern. Could you give some more details? I've seen similar patterns used internally that were upgraded when we switched to descriptors. They were all using `this.constructor` on instance methods I belive.
 @sebmarkbage The pattern pretty much boils down to the above code, it's just a temporary artifact during our transition (from crappier frameworks) and I'm not at all depending on a fix for this, I would just have to fix all the call sites now rather than later.

I'm primarily floating this because it seems weird to me that there's **no way** to create a descriptor from `this` within a static method. But if all seems good to you, then I'm not standing in the way. :)
 @vkramskikh in 0.12-rc1 this is not an issue anymore because you cannot use the convenience constructor anyway (it warns). You would have to use `createFactory`, `createElement` or JSX on the "this" value anyway so you could do that.

E.g. this should work in a mixin:

``` javascript
...
show: function() {
  React.render(<this />, container);
}
...
```
 Oh... We could possibly remove this warning now since it'll actually start working in `0.13`. Or we just leave it broken until next release since it was also broken in `0.11`, right?
  :thumbsup: We should also put it in `npm-react/README`

Are you interested in adding that note?
 Awesome! We're planning on shipping 0.11 ASAP, so the sooner the better :) And yes, we need the CLA signed for all changes.
 #1793 fixed this.
  It's that time again.
- [x] Update `AUTHORS` (#1776)
- [x] Update authors list on http://facebook.github.io/react/acknowledgements.html
- [x] Release notes
- [x] Blog Post
- [x] Update `src/vendor` dependencies
- [x] Update supported attributes
- [x] Update polyfill list (incl. in React.js warning)
- [x] document anything new in addons (perf, tap plugin if that makes it)
- [x] document change to getDefaultProps (now cached, can't inspect this.props)
- [x] Write better react-tools readme (https://github.com/facebook/react/tree/master/npm-react-tools)
- [x] make sure examples work
- [x] make sure samples on website work
- [x] exclude todomvc-flux from starter kit (too many other dependencies)
- [x] merge #1840 
- [x] Update commoner (https://github.com/reactjs/commoner/pull/65), update dep in package.json
- [x] `npm shrinkwrap`
- [x] update versions in readme
- [x] Update changelog (from RC blog post)
  - [x] destructuring in --harmony
  - [x] details for react perf

---

Post-release
- [x] PRs for CDNs
  - [x] [cdnjs](https://github.com/cdnjs/cdnjs)
  - [x] [jsdelivr](https://github.com/jsdelivr/jsdelivr/)
- [x] update version in master
- [x] push `react-source` gem

Even more post-release
- [x] Update todomvc-flux example
- [ ] Update react-art
- [x] Update react-rails
 @petehunt Want to expose ReactPerf in addons this time?
 Oh hey, it's there. We should document it.
 @wvl Care to move discussion about that to #1699? I'm not going to block 0.11 on that.
 Would be nice to get Dispatcher in addons as well. cc @jingchen
 @vjeux In general, shouldn't we move addons that doesn't touch the core to separate NPM-packages as I believe is the plan?
 No Dispatcher unless somebody is going to actually support it AND we have it checked in with tests. Even then, I'd rather not.
 Static functions are now autobound to the class instance, which breaks code we had which did:

``` js
var Buttons = React.createClass({
  statics: {
    buttonSetsType: React.PropTypes.arrayOf(["basic", "trig", "prealgebra"])
  },
  ...
});

// ...

propTypes: {
  buttonSets: Buttons.buttonSetsType.isRequired
}
```

because `.isRequired` is no longer defined on the function. @sebmarkbage Should we suck it up and just rearrange the code? I can do `Buttons.buttonSetsType = ...` instead.
 Hm... Crap. No, don't rearrange the code. That pattern will begin to work again once we remove convenience constructors (descriptor factories) around classes.

Maybe we can also copy properties on the function after we bind it?
 #1840 
 #1773 I think it's _actually_ broken right now, but I'm not sure.
 #1774 
@chenglou Did you merge it internally or what's the status?
 #1774 is not going in, it's not a regression. #1773 I'm deferring to @sebmarkbage, but it sounds like that's a NOOP. #1840 is going in.
 #1773 There is a fix we could do but unless it's frequently used I think we can punt on it until 0.12 which will be coming very soon.
 FYI, I have no objections to pushing (or ignoring) #1773.
 Shipped!
 :+1:

Sent from iPhone
  I like this, but please run the test before committing, this is failing (we check the error message).

https://github.com/facebook/react/blob/master/src/core/__tests__/ReactInstanceHandles-test.js#L141-L154
 Note that this same error message is hardcoded in another place ‚Äì can you update both?
 Oh yea, I missed that - good find. Let's update both places.
 Sorry for the delay! Thanks!
  Thank you for the PR, and sorry about the long wait. Now that #5714 is merged, all attributes on SVG elements will be passed through as is, with no need for the whitelist. I'm closing this but please let me know if you have any troubles in master.
  Or better, only run for changes in specific paths. This is the first step in the effort to reduce the number of jobs we use on travis ci. cc @jeffmo 
 Yea, I know Travis doesn't allow this natively (yet?). I've been doing the `[skip ci]` bit when I remember but it's tough to tell people submitting PRs that when I can't even remember. I was thinking of having a script that looked at the diff range and got the modified paths. If it wasn't src/ or vendor/, then exit early, otherwise continue. It wouldn't really only run for certain changes but it would be a quick noop. It sounds like you were thinking the same with `before_script`. If we can check the range and not just the latest commit, I think it would be really helpful.

I'm trying to avoid splitting code away from docs. I'll argue until I die that there's a lot of value keeping them as close as possible :) It is an option though, so thanks for bringing it up.
 Yea, I think that would be awesome!
 Hah, I knew I had filed this already. I'll point that one here.
  (Republished.)
  Closing this since we're deprecating `classSet` (#2910). The new alloc-free version lives at https://github.com/petehunt/react-classset
  @sebmarkbage this is no longer valid, right?
 @petehunt Just checked with him :+1: 

https://github.com/facebook/react/commit/c4658c1728b39c452a86f371ecb1c51874456107
  We might be considering dropping ReactLink... Need to revisit this if we decide to keep it.
 I'm going to close this out because we want to move ReactLink support out of the core components. We will provide helpful wrappers such as React.Addons.Select or something. Once we add that, feel free to add it to the wrapper unless it's already there. See #2302
  Depends on #1758.

Fixes #1698.

Previously, controlled components would update too soon when using something like ReactLayeredComponentMixin (i.e., before the layer's updates could propagate from the parent), causing the cursor to jump even when always updating the new model value to match the DOM state. With this change, we defer the update until after all nested updates have had a chance to finish, which prevents the cursor from misbehaving.

Also cleaned up the logic around updating a bit -- the .value and .checked updates in ReactDOMInput weren't being relied on at all so I removed them and opted for a simple forceUpdate instead. I also got rid of _isChanging which hasn't been necessary since the introduction of update batching.

Test Plan: Tested the example in http://jsfiddle.net/Bobris/ZZtXn/2/ and verified that the cursor didn't jump. Changed the code to filter out numbers and verified that the field prevents typing numbers (attempting to do so still causes the cursor to jump to the end). Also verified that controlled and uncontrolled radio buttons, textareas, and select boxes work.
 Here's a build of this version, hopefully it works for you:

https://s3.amazonaws.com/uploads.hipchat.com/6574/26709/yXvD7Jm5JM0NBjs/react-pull-1759.zip
 cc @sebmarkbage 
 @Tvaroh No, it will not be in 0.11. It might be in 0.12 or it might not be. I haven't even tested to see if this fixes the rAF batching problem. rAF batching is not ready for use in production.
 @Tvaroh Sorry, I see. Controlled components won't work as-is for you as they assume you'll update the state value immediately. My best suggestion is to make your own wrapper around `<input/>` like Om does.
 Using controlled components with requestAnimationFrame batching is not currently supported and this PR doesn't attempt to fix it.
  A couple more comments but I think this should be good to go afterwards.
 It is kind of annoying that this is a significant perf hit. We should probably just make this use the `warning()` module instead? That way we can pull it out in production.
 @sebmarkbage Curious ‚Äì do you have a benchmark for this or are you assuming it's slower?
 We have no proper benchmarks that test this code path in isolation.

We have verified that invariants like this one has significantly impacted perf in critical paths (reconcilation/render). So I just do a dogmatic extrapolation.

> On Sep 29, 2014, at 8:32 PM, Ben Alpert notifications@github.com wrote:
> 
> @sebmarkbage Curious ‚Äì do you have a benchmark for this or are you assuming it's slower?
> 
> ‚Äî
> Reply to this email directly or view it on GitHub.
 @sebmarkbage I imagine if that's the case...

```
if (typeof func !== 'function') {
  invariant(
    false,
    ...
  );
}
```

... should make it a non-issues I would imagine?
 @zpao and @sebmarkbage (etc) handle approval + merge and are more familiar with the intricasies of this. But I think it sounds great, better error messages are always :+1: and if you put up more I'll make sure to review them to speed things along and make their job easier (sorry it has taken such a long time!).

I'll defer to @sebmarkbage but I imagine there some argument to be made for `warning` vs `invariant`. `warning` is stripped for production and thus avoid the perf/size hit. I know there's been mentions (but nothing definitive) of not wanting to add to many invariants for that reason.
 @sebmarkbage How (not) overzealous do we allow ourselves to be? I'm referring to https://github.com/facebook/react/pull/1757/files#r14382318, it makes sense to me to validate `children` being `object`, but there's always a cost. I imagine it's a sliding scale, something roughly like:
1. Anticipated incorrect argument types
2. Incorrect argument types
3. Anticipated incorrect argument values
4. Incorrect argument values

Where would you draw the line between invariant/warning/ignore, roughly.
 @zpao @sebmarkbage Ping :)
 As for type checks on both properties and arguments. We have annotations. These can be used to add runtime warnings if you need them. This function has one. We shouldn't have people using TypeScript or Flow for static analysis pay the cost of runtime checks.

Additionally, this adds more code to the internals that can be expressed with a simple type annotation. I'd rather have a build that adds dynamic warnings for all these annotations rather than ad-hoc type checks. This applies to both anticipated and not anticipated type checks.

For complex value assertions, the story is a bit different.

In general, things that execute in the render/reconciliation pass is performance sensitive because it is the accumulation of things that is the cost. We don't try to execute the minimal path. We rerender all of it all the time.

The beauty is that these flows are expected to be idempotent and **mostly** side-effect free. So an error in production doesn't need to terminate early. It's not expected to have critical impact. Those should be warnings.

Things that execute outside of the reconciliation is not as performance sensitive. E.g. class set up code etc. They may also have critical side-effects that may proceed if we don't stop code-flow. These might as well be invariants.

Since this is purely a type check of an annotation that is already there and can be automatically added by a dynamic type checker, I'll close this out. Let's not assert on type alone and build a dynamic build.

(We'll likely switch internals to Flow annotations at some point. We could compile these down to dynamic type checks.)
 @sebmarkbage Ah, I wasn't aware that that the type annotations were actually used. Is this available today or are "we" waiting for flow to be released?
  Haven't heard much desire for this so I'm going to close. It sounds like a likely antipattern to me to have a component that sometimes receives context from a parent and sometimes doesn't.
  At some point, checking argument types for all the functions feels like extreme overkill, but I probably wouldn't be opposed to asserting that the second argument is a function, especially because `forEach(fn)` silently does nothing instead of throwing an error.
 @sebmarkbage I guess is/will be solved by static analysis annotations as well?
  As with #1682, we're not likely to change the behavior of cx due to the unique way that it's used at Facebook internally. You can of course just use your own version if you prefer to have the fallback though ‚Äì it's simple enough that it shouldn't be a maintenance cost at all.
  I think it's likely that we'll do this, possibly as the default behavior.
 @slorber While it's arguable that it is bad practice to change state in-place, React does not enforce immutability, it only (strongly) encourages it.
 After my #2540, React will warn you automatically if you mutate this.props.
 @slorber You should take a look at https://github.com/facebook/react/issues/5306 and https://github.com/facebook/react/pull/5462
  `oneOfType(...).isRequired` works.
One array allocation here is fair imo. I wouldn't complicate the validation logic by hand-rolling some allocation-free solution.
 PropTypes checks always warn you but let you proceed anyways. It's not a strict type system.

The children warning is precisely that. This:

``` js
<div>
  {this.props.children}
  <TimeAgo timestamp={this.props.timestamp}/>
</div>
```

Is not an array. It's an array whose first item is an array (children), and whose second element is a component. This is the proper one:

``` js
children: React.PropTypes.oneOfType([
    React.PropTypes.component,
    React.PropTypes.arrayOf(
      React.PropTypes.oneOfType([
        React.PropTypes.component,
        React.PropTypes.array
      ])
    )
])
```

But at that point I'd say it's too extreme. `children: React.PropTypes.renderable` should be fine. Not sure how that `0` warning could happen.
 `React.Children.map` does flatten.

About making child always an array, there's a warning [in the docs](http://facebook.github.io/react/tips/children-props-type.html). It's been extensively discussed in #751 too. I'm for array but I don't think we're reconsidering this anytime soon unfortunately.

Anyways, is this particular issue resolved? Can it be closed?
  displayName is part of the supported API; see http://facebook.github.io/react/docs/component-specs.html#displayname.

Normally I lean towards just always doing it as in the first example, though it might be nice to special-case `exports`.
 @slorber We hit this internally at FB too, but in those cases we just say what @spicyj said - add `displayName` manually, or assign to a variable before exporting.

There's not much we can really do at this point. We _might_ be able to get the filename in the transform step, but that's a gamble too (how often will it be `index.js`?). Since it's a crapshoot either way, I'm going to close this out. Thanks for filing though! :)

So I suggest the manual approach here. Luckily it's pretty greppable (`exports = React.create`) so a little bit of manual work and lint rule should things better.
  @spicyj is right. That check is not really needed. I'll close this unless I'm missing something!
 @chenglou No, the logic is inverted.
 Oh sorry! @protron can you sign the CLA please?
 Thanks!
  Such honesty :) I'll sync out to the site now.
  `list.isMounted()` returns a boolean that tells you just that: whether it's mounted or not. You'd want `renderIntoDocument list`. This should work.
 Can you show the rest of that block?
 Sorry, I meant the test block.
  Can you post a jsfiddle with a minimal repro case? (What browser?)
 No, events are all handled synchronously right now.
 This popup? https://cloudup.com/czUUANUtcv6

That was with Firefox. Different browsers have different heuristics for determining if something is a popup and should be blocked. I don't think there's ever been a definitive guide on making `window.open` work 100% of the time these days. Having the call to the event handler in the callstack is the closest you'll get to a guarantee.

There's nothing else we can do here AFAIK.
  After #1642 we'll need `String.prototype.trim`. Not sure if we've added any others recently.
 Code update will come out separately.
  I'm guessing you've already found an answer to this or moved on.
Otherwise, I recommend coming to our IRC or posting in the Google group.
  This should go into a separate transpiler that implements the JSX spec, but not for React. We're going with convention over configuration in React. #1551
  In master the callback isn't called immediately but it looks like we have a bug where it's not called at all (which you can repro by using http://react.zpao.com/builds/master/latest/react-with-addons.js on JSFiddle).
 #4171 should have fixed this. The callback fires on the client but not the server.
 If it is fixed, is this comment outdated?
https://github.com/facebook/react/blob/1e8156143a6389e2235fa16536bb9161d26a23ce/src/renderers/shared/reconciler/ReactUpdateQueue.js#L140-L144
  The main reason (I believe) that this doesn't exist already is that on the client side, you basically always want to show some sort of loading indicator instead of deferring rendering. (It would also make the code significantly more complex, but we can probably deal with that.)
 @anatomic That's not React's responsibility, it's your job to chunk appropriately and defer rendering until all necessary chunks has been loaded. To put it differently, if one of your components has a dependency on some external library, it's obviously your problem to satisify before trying to use it, React couldn't do it even if it tried, so the same applies across the board.

Feel free to implement alternative strategies that may suit you better, say `<WaitFor for={MyAsyncLoadedCompSignal} until={...} then={() => <MyAsyncLoadedComp ... />} />`. But these are inherently opinionated and not something React should or even needs to offer, so it's best left to the community.
 > If we did the  <WaitFor ... />  approach, surely we'll still get a different DOM on the first render which will still cause the flicker/disappearance of content? 

If you don't want flicker (some do) it's simply a matter of waiting for all the chunks you depend on to have loaded before rendering, webpack provides this out-of-the-box with `require.resolve`.

PS. Yes, react-router and whatever else you're using surely complicates the solution, but it's still not React's problem to solve.
 > I'll look into that, my understanding of  require.resolve  was that it was a synchronous lookup of a module's id and didn't involve a trip to the server? We're using  require.ensure  to manage our chunk loading.

Sorry, yes I meant `require.ensure`. The callback is executed only when all the dependencies are satisfied, so it's a matter of just putting render/setState inside of it.
 > You are right that the  require.ensure  is the way to go, I guess our ultimate issue was that it should be linked to the route currently being visited so is directly tied to the router. With react-router being component based that ties it to the render tree. Without my hack above we're left fighting a way to view the tree before everything is loaded async (or duplicating the routing logic to allow for relevant chunks to be loaded at the top level).

I'm not intimately familiar with react-router, but I still imagine it simply being a case of `setRoute(...)` => `require.ensure([], function() { require(...); setRoute(...); })` which really isn't practical so you introduce another level of indirection. A map of routes and the async `require.ensure` loader for each. Write a helper `function asyncSetRoute(...) { loadRoute(route, function() { setRoute(...); }}`, now you call `asyncSetRoute` instead and it will defer updating the router until everything is ready.

Pseudo-code and kind of generic, but that seems like the overall approach to me. Maybe react-router should provide this, maybe not... maybe it's ideally provided as an external helper, I'm not sure.
 @NickStefan We don't currently support per-component async fetching. We'd like to add it. This issue tracks our progress, though no one is actively working on it and it will take major restructuring so it will be a while.
 > it is actually backwards to have the view specify what data to load.

I'm not entirely sure this is true.  Sometimes, the component is the only thing that knows what data to load.  For instance, suppose you have an expandable tree view that allows a user to browse a massive graph of nodes - it is impossible to know in advance what data needs to be loaded; only the component can figure that out.

Regardless, this discussion might become much more relevant if we pursue the idea of running React code within a web worker (#3092), where async is required to communicate across the bridge.
  Looks like our bot failed to come in and ask, but could you sign the CLA? https://developers.facebook.com/opensource/cla
 Thanks!
  Not really an issue, so I'm going to close out. I think this is a better discussion for the mailing list.
  I don't think it would make sense for stopImmediatePropagation on a touchend to stop a click event from firing. If you do `e.preventDefault()` on the touchend, my guess is it'll work already ‚Äì can you to test to see?
  We use PhantomJS to test React itself so you shouldn't have any trouble using it. In any event, the information you've provided here isn't enough to reproduce the problem so I'm going to close this issue. If you can make a minimal repro case showing an example that doesn't work with React (but works using direct DOM manipulation or another library), please feel free to comment here and I'll reopen.
  Can you give a quick example where `<data>` would be appropriate where we current use `<span>` (which we only do for text children when there are multiple).

I think for the majority of cases where we're using `<span>`, it's the best semantic choice. But if you want to use `<data>` elements, I'm pretty certain we support that, so long as you do it explicitly.
 Could it be you're confusing the `<data>` tag with `data-` attributes? MDN says:

> The HTML `<data>` Element links a given content with a machine-readable translation.
> 
> https://developer.mozilla.org/en-US/docs/Web/HTML/Element/data

which doesn't seem to have anything to do with data binding.
 I don't think we're going to use the `<data>` tag as you suggest so I'm going to close this out, but we do hope to eliminate the extra spans entirely in a later version.
 (If you add `<data>` tags manually to your components then no spans will be created.)
 It would also be _very_ easy to build your own version of React where you swap `span` for `data`-tags if you _really_ want it. Or you could probably quite easily just do a search and replace it in the prebuilt files.
  Thanks!
  Regarding the specific attribute, React favors the DOM API property names for attributes rather than HTML since they were designed to be usable JS identifiers, so we use `htmlFor` rather than `for`, identified it as a common source of confusion and added a warning.

Regarding the rendering of all attributes, there are a number of issues in play. Most importantly, if you use `transferPropsTo()` you will render meaningless attributes into the DOM leading to a potentially invalid document. Additionally React needs to know specific information about the properties so it can do efficient diffing (i.e. the style property is diffed differently than className) and perform the correct DOM manipulation (using attributes vs properties).
 It's not that React doesn't trust the developer, but that the various properties behave differently in browsers. For more info about the different kinds of attributes that we need to distinguish between, see the list of attributes/properties here:

https://github.com/facebook/react/blob/master/src/browser/ui/dom/HTMLDOMPropertyConfig.js

It's possible that this can be autodetected (see #1512) but right now we're just shipping the hardcoded list. I'd love to hear other suggestions for what we could do. We already have #140 open to track the ability to customize the custom attribute list.
  If you can provide specific use cases this would be helpful so we can look at your specific situation. In general we discourage introspecting your children and instead passing a JS object that describes the parameter in a prop.

You can also use `propTypes` to limit what types of children can be passed to you.
 React.Children.only is meant for asserting that you have a single child, not for testing whether you do ‚Äì if there are expected cases where you don't, you shouldn't use that method. I can almost promise that regardless of what you do, React.Children.only will not significantly affect performance for you.
  I haven't tried to reproduce the jest problem yet, but regardless, this is not a problem in React, so I'm going to close this out.
 Would be interested in knowing what exactly you were trying to test.
 @zpao If that invariant fails, you can't use mixins with functions that merge their outputs.
  It was reported to me on IRC today and confirmed on master / FF nightly myself. Also https://github.com/facebook/react-devtools/issues/40
 @syranide When I tested last week I couldn't get the source map to do anything at all in Firefox.
 Figured it out. I can't decide if it's a Firefox issue or something we're doing wrong, but https://github.com/facebook/react/blob/77150630e2f2832f83067a958b9aea194c68a126/vendor/browser-transforms.js#L128 is the problem. It seems when we pass URLs (eg "http://localhost/examples/example.js") here, Firefox chokes. If we pass a filename (eg "example.js") the sourcemap is usable. So short term, I'm just going to pull off the actual filename and use that. Inline scripts don't appear to have been a problem (supporting my URL theory).

cc @fitzgen from the Firefox devtools team, might be worth looking into on your end as well (can't remember if I filed that bug).
 @zpao Can we keep the full path but drop the domain-part perhaps?
 @syranide Good idea, I changed to doing that :)
  @maksimr here's a lib that does exactly what you want: https://github.com/tommyh/jasmine-react
It plays around React's internals to stub out the methods. We don't promise it's always gonna work in the long-term, as the core's still changing. Afaik we also don't have an official way of stubbing these yet and it's not a priority.

Btw, the object (whose methods you want to stub out) passed to `createClass` isn't frozen. The descriptor (when you call the thing returned by `createClass`) is (and only in dev build).

Closing this if you don't have other questions!
  (Closing in favor of #1448.)
  Thank you!
  Seems like the src of an iframe is immutable so in order to update the URL an iframe points to it is required to use the React-key as a cache buster.

Can we change React to recreate an iframe if the src prop changes?
 lol. nevermind me. Me no speak americano.
  https://github.com/facebook/esprima/commit/aad8a2b798ca80342a744aac2869fc1feb0065dd
replaced XJSIdentifer with XJSNamespacedName for namespaced items, so we
need to adjust here accordingly.
 Good thing we have unit tests for this.
 Yea, discovered this with the test I'm adding to bring aa044c6b61a798f20a37fe49c6a4722faf68211e in. Then I'm going to bring the test out here, even if we aren't running it
  Relevant: http://developer.zendesk.com/blog/2014/05/13/rendering-to-iframes-in-react/
 Should probably just apply the `<img onLoad`-fix (`onError`?) to `iframe` as well.
 Yes, thanks.
 @jketcham Yes! Want to send a pull request? I think we're missing onError and onLoad which can probably both go in a new subsection called "Generic Events" (no special properties). Also onReset should be listed under Form Events.
 @varungupta85 Try upgrading to React 14.0 and see if you're still running into the issue.  If you are, please open a new bug with a simple testcase/jsfiddle that demonstrates the issue.
 @varungupta85 Ok, perfect, thanks!
  Indeed, same issue. I don't think we'll stop pooling events in the near future so I suggest using `.persist` before passing your event around to anything that might be delayed.
 @johnhaley81 No, they get garbage collected like any other object.
  cc @yungsters as well who did a lot of our wrapper component work
 this lgtm :+1:
 Looks good. Why is Travic CI build failing?
 Thanks!
  I'm wary of exposing an API for this. As you can see, it's really just quick sugar for checking whether the prop is undefined. Adding a `props[propName] == null` check to your custom validator does the same thing.
 Also wary of exposing an API for this. In the long term you can use Flow or other systems and we'll probably move propTypes out of core eventually.
  I don't think it's _invalid_ markup. `value` just isn't used (unless you use `get/setAttribute`, which we don't do for `value`).

I was surprised that just deleting value would work, but I guess we're applying updates to value of the actual node manually, not relying on render. This seems like a good enough approach to me. We already render the initial value as a text child so we don't use this for server rendering.

@syranide another directive could make sense if we get scoped properties in there since this is only true for <textarea> but not for other inputs. But until then...

Want to submit a PR @somethingkindawierd? (cc @salier)
  Thanks!
  cc @jeffmo 
 @jeffmo, where you at? I'm inclined to say "no" and maybe it can be better in a recast world.
 We do want to allow this feature. However, we want to switch to Recast for the transform. So we would require that this feature was available in Recast before we added it.
  JSX currently transforms everything to double quote except these two. This way, it's at least consistent and will satisfy half of the people who do put a strict quotation linting on their project.

Test: `jest`, check the double quoted transformed `data-bla="something"`.
 Cool! I'll leave this as a backup then. Will close once yours get merged.
 We may move to recast before we ship another release but whatever. Want to rebase and do the `quoteAttrName` as well, then we'll merge this in?
 Done.
  Merging into #1326, but it sounds like TimeoutTransitionGroup is working for most people.
  #1481 (yes I know you mean the description, just posting for posterity)
 We fixed the miscommunication on the addons docs page. We had mistakenly grouped TestUtils in the wrong section.
  We're moving to use ES6 classes soon (see #613):

``` js
class Comp {
  plop() {
    console.log("plop");
  }

  render() {
    this.plop();
    return React.DOM.div(null, "foo");
  }
}
```

Doing it this way should allow just overriding `Comp.prototype.prop` directly.
 Hopefully in the next couple of months, but I can't promise anything.
 @josebalius Just preparations, AFAIK 0.13 will officially JavaScript classes. I'm not sure if it will ship JSX transpiler support for ES6 classes (they're available in a very limited form right now IIRC, but the proposal is still not final I think?).
 This basically became a request for ES6 classes, which have now been released.
  Suppose I'm rendering the following on the server:

```
var body = React.renderComponentToString(Component( {data:data} ));
var html = `<!DOCTYPE html>
<html>
<body>
${body}
</body>
</html>`; // ES6 template string
```

And on the client I do this:

``` javascript
React.renderComponent(Component( {data:data} ), document.body);
```

In that case the server-rendered markup will **not** be re-used because the firstChild of the body element is a text node (containing a new line). Therefore [shouldReuseMarkup](https://github.com/facebook/react/blob/e1c2d02fddb40cb0b246d2c2da97b41b6ba378bc/src/browser/ui/ReactMount.js#L367) (ReactMount.js) evaluates to false and React does not even try to re-use the markup and performs an innerHTML operation on page load instead.

The following (on the server-side) works as intended:

```
var body = React.renderComponentToString(Component( {data:data} ));
var html = `<!DOCTYPE html>
<html>
<body>${body}</body>
</html>`;
```

I think it's counter-intuitive that the first variant fails to re-use the markup silently. This should either be fixed or documented.

A possible solution could be to ignore the first child if it is a text node and use the second child instead.
 I'm using React v0.10.0. I did not test against HEAD to be honest... When do you suppose it has been fixed? Before or after the release of v0.10?

EDIT: The problem seems to be in this file: https://github.com/facebook/react/blob/e1c2d02fddb40cb0b246d2c2da97b41b6ba378bc/src/browser/ui/getReactRootElementInContainer.js#L36

and I can't spot a difference between that and v0.10.0. A big compliment on source code readability by the way! Awesome project!
 I don't think we fixed it.
 Yup. Closing this in favor of #996.
  (In the future, the mailing list is a better place for questions like this.)
  I'm going to take #1548 which has `patternUnits`, want to update this to just be `patternContentUnits` (also not in that other PR that there are 2 places that need to be updated). Feel free to also drop the docs change. We haven't been super consistent there so it's going to need a batch update before next release anyway.
 It's not valid on the `<svg>` element, but it's valid on `<pattern>`. SVGDOMPropertyConfig isn't about just the `<svg>` element but all of them. By default React downcases the string specified in `Properties` (downcased for initial markup and for most HTML attributes). Case actually matters for some of these, so for those we have the `DOMAttributeNames` escape hatch which allows you to specify the exact string that is valid.

As an example, `<linearGradient gradientTransform="rotate(45)">` works but `<linearGradient gradienttransform="rotate(45)">` doesn't. Most (all?) SVG attributes seem to be case sensitive, so while there's a bit of duplication in this file, it's necessary for now.

I _strongly_ encourage you to actually create a build of React with your change and then actually use `contentPatternUnits` in an SVG to ensure everything works. Until we have automated tests here, that's how we've been testing attributes.
 Thanks for the quick updates :)
  Thanks for the find. I'll update that and a few other outdated packages.
  It's nice to have prebuilt binaries available through the current package managers. Right now there's a prebuilt package for [Bower](https://github.com/reactjs/react-bower), but it'd be nice to also have them on npm / component / nlz.io.

What do you think is the best way to create and maintain these packages?

cc/ @zpao 
 See also #1635.
 @Daniel15 Yep, that's what I mean.
 We don't have plans to do this right now.
  See http://jsfiddle.net/Bobris/ZZtXn/2/ (try typing at the beginning of the text box).
  Will be fixed next time we rebuild the docs ‚Äì thanks!
  It would be useful to have bubbling of events follow a different order than the DOM. E.g. Layers that are technically part of a component but gets rendered outside of the component. We should have more explicit and defined behavior for how you can nest renderComponent calls that render to different targets.

That's a guarantee that we can provide in the framework.

I don't think we should try to guarantee bubbling behavior with regards to the rest of the DOM environment since we may choose to put everything at the top level (window/document/body) or in the nearest parent.

For that reason I think that this needs to move into React (even though the implementation is more difficult). :(
 @sebmarkbage How can we make things like EnterLeaveEventPlugin work with nested roots? The current dispatching strategy traverses the React tree which means that it can't happen properly if the start and end points are in different roots.
 @sebmarkbage #2043 is a rather simple solution to making React play nice with other libraries (and other instances of React). It's also imaginable that you could "omit" the listeners for a specific nested root (for performance reasons) if you know it's nested inside a compatible React instance.

Without that React does not play nice with other libraries at all, which is something we currently hype quite a bit (but doesn't quite live up to IMHO).

But to be clear, I will most likely only ever use React for full page apps so I'm not really affected by this one way or the other.
 > It would be useful to have bubbling of events follow a different order than the DOM. E.g. Layers that are technically part of a component but gets rendered outside of the component. We should have more explicit and defined behavior for how you can nest renderComponent calls that render to different targets.

Do you really need that? I would imagine that layers would simply stop propagation of all events when they're leaving the root of the layer (this would be compatible with HTML). Or what's the goal?
 We're not going to take this in its current state because the abstraction is a little too leaky, but I've noted on #3210 that we'd like to find a good solution here. Thanks for sending this in!
  Hi,

I would like to use all the available es6 transforms, the jsx transform and the [es6-module-jstransform](https://github.com/andreypopp/es6-module-jstransform) for my JavaScript code.

What I'm using is this:

``` js
var transform = require('jstransform').transform;

var visitors = Array.prototype.concat.apply([], [
  require('es6-module-jstransform').visitorList,
  require('jstransform/visitors/es6-arrow-function-visitors').visitorList,
  require('jstransform/visitors/es6-object-concise-method-visitors.js').visitorList,
  require('jstransform/visitors/es6-class-visitors').visitorList,
  require('jstransform/visitors/es6-object-short-notation-visitors').visitorList,
  require('jstransform/visitors/es6-rest-param-visitors').visitorList,
  require('jstransform/visitors/es6-template-visitors').visitorList,
  require('./transforms/react').visitorList,
  require('./transforms/reactDisplayName').visitorList
]);
var es5 = transform(visitors, sourcecode);
```

The problem is that it's difficult to use those jsx transforms without depending on the whole `react-tools` package which would essentially download a lot of dependencies (another jstransform, etc.) just for those two files, which is why I copied them into a transforms directory in my source tree, but that's obviously a bad solution. Wouldn't it be better to put those jsx-transforms into a separate npm package?

Also, I found a reference to something called `typechecks` in [/vendor/fbtransform/syntax.js](https://github.com/facebook/react/blob/2d048f1f34a7d10cca81336446920822ad7ea67c/vendor/fbtransform/syntax.js#L23), but the appropriate visitor doesn't seem to be open source. In my above example I essentially skipped all the typecheck code that's in syntax.js. Could that be a problem in the future?

Awesome library, by the way!
 One issue is that those visitors are potentially using different versions of esprima-fb and jstransform (the one inside their node_module directory instead of a shared one). I don't know enough about the architecture of jstransform to know whether that could be a problem or not.

Another minor issue is that `npm install` takes longer and that I like my projects to not have many duplicate versions of the same package, but that's purely based on taste, of course.

Another issue is that I would have to pin the version of _react-tools_ anyway if I did this:

``` javascript
require('react-tools/vendor/fbtransform/transforms/react').visitorList
require('react-tools/vendor/fbtransform/transforms/reactDisplayName').visitorList
```

Because I can't depend on the internal path of the files not changing between releases. I didn't see any documentation (or source code comments) that says that these are guaranteed to never change.

So I might as well copy the 3 files and save a lot of bytes in dependencies because I have to lock down the version anyway.

Or is there a recommended way to compose these transforms that I didn't notice?
 As far as I know npm only performs de-duplication on the network level (i.e. it caches packages) but it doesn't do so on the file system level (i.e. the package is extracted into multiple `node_modules` folders). Which is not a huge deal, though.

If you take a look at `es6-module-jstransform` and `es6-destructuring-jstransform` you can see that its dependencies are outdated:
https://github.com/andreypopp/es6-module-jstransform/blob/master/package.json
https://github.com/andreypopp/es6-destructuring-jstransform/blob/master/package.json

```
"esprima-fb": "~3001.1.0-dev-harmony-fb",
"jstransform": "~3.0.0"
```

The bigger problem IMHO is that I couldn't automatically update the version of react-tools anyway because the internal file path (`react-tools/vendor/fbtransform/transforms/react`) is not guaranteed to stay the same, as I mentioned.
 We're deprecating react-tools and jstransform so closing this out.
  Flux stores aren't necessarily React-specific, and many (most?) people use React without Flux, so it doesn't make a ton of sense to build direct integration between the two. If you want, you can define a mixin to keep track of the listeners like this:

``` js
var ListenToMixin = {
  componentWillMount: function() {
    this.listeners = [];
  },
  listenTo: function(store, fn) {
    store.addChangeListener(fn);
    this.listeners.push({
      remove: function() {
        store.removeChangeListener(fn);
      }
    });
  }
  componentWillUnmount: function() {
    this.listeners.forEach(function(listener) {
      listener.remove();
    });
  }
};
```

and then use it in your components like this:

``` js
var TodoApp = React.createClass({ 
  mixins: [ListenToMixin],
  componentDidMount: function() { 
    this.listenTo(TodoStore, this._onChange); 
  }, 
  render: function() {
  }, 
  _onChange: function() { 
    this.setState(getTodoState()); 
  } 
}); 
```
  > While I have to agree with the general consensus that testing and React is a breeze, I was thinking that it might be a very good benefit for new users if you updated you documentation page with a few examples under each API method.  Nothing is exactly clear, and when I first wanted to start writing tests I had to dig into the React source code in order to find implementation details. 

and

> I still have no idea how to use them, despite a few tries.  With the descriptors, I don't even know how to test without testutils anymore.  Currently, I've given up on testing my React components until there are examples I can follow.

https://groups.google.com/forum/#!topic/reactjs/1DacqrwosLM
 (I'm not qualified to write this.)
 TestUtils is only available in development mode (i.e., NODE_ENV !== "production").
  The only useful information from the stack trace when there's an exception in render is saying `React.createClass.render` but doesn't tell which one.

![bqh2farccaavka9 png-large](https://cloud.githubusercontent.com/assets/197597/3279732/ce0d3b9c-f413-11e3-9b47-e02af7e14423.png)

Unfortunately, Chrome dev tools do not accept displayName: https://code.google.com/p/chromium/issues/detail?id=17356

An idea is to update our JSX transform that already adds displayName to also output this crazy pattern, but that makes the stack trace look better

![screen shot 2014-06-14 at 3 19 36 pm](https://cloud.githubusercontent.com/assets/197597/3279726/dcbb8dde-f412-11e3-8702-77687314e9c6.png)

Discussion on twitter: https://twitter.com/seanbrookes/status/477934056835780608/photo/1
 If we're going to do anything, I think it would be more reasonable to transform it into this:

``` js
var MyComponent = React.createClass({
  render: function MyComponent_render() {
    ...
  }
});
```

Also, perhaps things will Just Work‚Ñ¢ with ES6 classes?
 My solution has the advantage of not having to add a name to every single method on the React component though
 `displayName` _does_ work in the debugger, so they definitely have the ability to make this work.
![screenshot 2014-06-16 16 45 02](https://cloud.githubusercontent.com/assets/8445/3294819/25dec3ec-f5b1-11e3-83d4-5abdacadc134.png)

But that said, let's make sure whatever we do is fine in all browsers and not just Chrome mmmmkay :)

I actually prefer @spicyj's because it's a feature of the language, doesn't rely on multiple assignments, and results in more sane output `MyComponent_render` (correct) vs `MyComponent.createClass.render` (not correct). We could also then get rid of our runtime assignment of `fn.displayName`.
 Looks like Safari's stack traces already show displayName properly.
 This no longer appears the be a problem in Chrome so I am closing:

<img width="712" alt="screen shot 2016-03-26 at 21 16 34" src="https://cloud.githubusercontent.com/assets/810438/14062470/1d662408-f398-11e5-8387-2c9422bb2465.png">
  Not really, unfortunately. We don't have a good model for how events for nested trees should interact. Synthetic events and native events are two different concepts ‚Äì for example, a native `keyup` event could result in a synthetic `onChange` event ‚Äì but if you call `preventDefault` on the `onChange` event, should that prevent the `keyup`? We dispatch the native event to each render tree and form the synthetic events separately in each tree right now, which we'd probably need to change to fix this properly. I'm afraid that any short-term solution here would be a patch that solves only a few cases and makes the code harder to reason about; we probably need a holistic rethinking of this problem to make a good solution here, and it's not something that we encounter very much because we're much more focused on React in a single render tree.
  I don't have an Android phone so I can't test easily, but do you get a native click event if you use plain JS without React? I'd guess you don't because React doesn't do any special filtering of when to fire click events.
 I don't think we're going to do anything here.
  This isn't really a React issue.
  Neat! Closing this issue ‚Äì this might be a better question for the mailing list.
  Thanks!
  Right -- this nesting won't work because it's invalid HTML. If you use a regular function (instead of a component) you can return an array of `<tr>` elements but then you can't use lifecycle methods or state. In the future we're hoping to have a way to return more than one element from a component.
 This is just because setState doesn't do a deep merge. You can use something like underscore's _.extend or React's immutability addon (`update`) to modify expandedDict properly:

http://jsfiddle.net/EzY3z/5/
  I'm not sure the original comic was referring to bugs vs. lines of code, but this seems better in any case. Thanks!
  I could imagine possibly supporting this with computed property expressions ‚Äì in ES6 you can already write

```
React.DOM.li({[this.props.keyName]: this.props.keyValue}, "bla")
```

though I've heard very little demand for this.
 I'm guessing [object literal computed property keys](http://wiki.ecmascript.org/doku.php?id=harmony:object_literals#object_literal_computed_property_keys) + the eventual JSX syntax for [spread](http://wiki.ecmascript.org/doku.php?id=harmony:spread) (or is it _only_ for spread?) is one way to do this.
 @victor-homyakov I don't know the details exactly, but as of 0.12 I believe the following code should work:

``` js
var extraProps = {};
extraProps[this.props.keyName] = this.props.keyValue;
return <li {...extraProps} />;
```
 There are now solutions to this that doesn't require leaving JSX and I'm confident this is not something we want to support. cc @zpao @sebmarkbage 
  This is pretty cool :)
 (This is already how the internal `joinClasses` helper works‚Ä¶)
 Internally at fb we statically transform `cx` into string concats and we can't really do that with arbitrary expressions (well, there's nothing stopping you, but you will get `false` in there). The implementation of `cx` here is meant to mimic our static transform so I think I'm going to veto this for the time being. I do agree it's saner behavior though, so maybe we can move the transform to behave the same way.
  I'm getting an `Uncaught object invariant` error, but it doesn't give me too much context about what is causing it. 

It happens when updating a store, on which my component listens for changes to update its state. What does this error mean?

**console**

```
Uncaught object invariant.js:52
invariant invariant.js:52
ReactMount.findComponentRoot ReactMount.js:622
ReactMount.findReactNodeByID ReactMount.js:518
getNode ReactMount.js:126
(anonymous function) ReactDOMIDOperations.js:211
(anonymous function) ReactPerf.js:57
processQueue ReactMultiChild.js:145
ReactMultiChild.Mixin.updateChildren ReactMultiChild.js:259
ReactDOMComponent.Mixin._updateDOMChildren ReactDOMComponent.js:393
(anonymous function) ReactDOMComponent.js:246
(anonymous function) ReactPerf.js:57
ReactComponent.Mixin._performUpdateIfNecessary ReactComponent.js:497
ReactComponent.Mixin.receiveComponent ReactComponent.js:468
ReactDOMComponent.Mixin.receiveComponent ReactDOMComponent.js:219
(anonymous function) ReactCompositeComponent.js:1328
(anonymous function) ReactPerf.js:57
ReactCompositeComponentMixin._performComponentUpdate ReactCompositeComponent.js:1264
ReactCompositeComponentMixin._performUpdateIfNecessary ReactCompositeComponent.js:1207
ReactComponent.Mixin.receiveComponent ReactComponent.js:468
ReactCompositeComponentMixin.receiveComponent ReactCompositeComponent.js:1292
(anonymous function) ReactCompositeComponent.js:1328
(anonymous function) ReactPerf.js:57
ReactCompositeComponentMixin._performComponentUpdate ReactCompositeComponent.js:1264
ReactCompositeComponentMixin._performUpdateIfNecessary ReactCompositeComponent.js:1207
ReactComponent.Mixin.receiveComponent ReactComponent.js:468
ReactCompositeComponentMixin.receiveComponent ReactCompositeComponent.js:1292
(anonymous function) ReactCompositeComponent.js:1328
(anonymous function) ReactPerf.js:57
ReactCompositeComponentMixin._performComponentUpdate ReactCompositeComponent.js:1264
ReactCompositeComponentMixin._performUpdateIfNecessary ReactCompositeComponent.js:1207
Mixin.perform Transaction.js:159
ReactComponent.Mixin.performUpdateIfNecessary ReactComponent.js:478
ReactCompositeComponentMixin.performUpdateIfNecessary ReactCompositeComponent.js:1157
runBatchedUpdates ReactUpdates.js:66
(anonymous function) ReactUpdates.js:86
(anonymous function) ReactPerf.js:57
Mixin.closeAll Transaction.js:242
Mixin.perform Transaction.js:175
ReactDefaultBatchingStrategy.batchedUpdates ReactDefaultBatchingStrategy.js:70
batchedUpdates ReactUpdates.js:35
ReactEventEmitterMixin.handleTopLevel ReactEventEmitterMixin.js:53
handleTopLevelImpl ReactEventTopLevelCallback.js:81
(anonymous function) ReactEventTopLevelCallback.js:140
```
 The fact that you can't see the error message is a Chrome bug; see #1665. Based on the stack trace, the error you're seeing is:

> findComponentRoot(..., %s): Unable to find element. This probably means the DOM was unexpectedly mutated (e.g., by the browser), usually due to forgetting a <tbody> when using tables, nesting <p> or <a> tags, or using non-SVG elements in an <svg> parent. Try inspecting the child nodes of the element with React ID `%s`.
 Thanks, that helps!
 Confirmed. If you enable "pause on exception" you can view the error in the "scope variables" tab under `local > format`. It also returns the missing tag under `local > a`, which is pretty neat.
  Yeah, sorry about this ‚Äì dupe of #1398.
 No problem! Yup, that's okay. (P.S. Warnings aren't logged in the prod build of React, which has extra performance optimizations too.)
  I'm not sure what you're asking for, if you want shorter names then you should probably just repackage them into another class/object. While they're a bit wordy, they're also very informative which I find preferable. cc @zpao 
 If you have a reason besides that you don't want to type so many letters, please share and we'll reopen. If that's your only reason, then no.
  Another quirk: if you type X, set it to empty string, then to undefined, X comes back in the field. Same for without ReactLink.

Generally, what should be the correct behavior of `<input value={null} />` or `<input value={undefined} />`? Should it become an uncontrolled component (current behavior), or a controlled component with `value=''`?

@sebmarkbage @spicyj 
 Reading this again I'm pretty sure the technically "correct" behavior is for it to keep the value (like it does). If `value` (or `valueLink` by association) is not set then input is uncontrolled and it simply should not mutate the value, regardless of what it was.

```
1. <input type="text" value="forced" defaultValue="initial1" />
2. <input type="text" defaultValue="initial2" />
3. <input type="text" />
```

If you consider those as a sequence 1 -> 2 -> 3, it makes sense (technically) to me that the value would be `forced` from start to finish. When a component goes from controlled to uncontrolled, it stops being controlled, it does not reset/remount. Intuitively it could make sense that it should become `initial2` for 2 and 3, but it would mean that an input would figuratively reset/remount when transitioning from controlled to uncontrolled.

PS. But I think mixed controlled and uncontrolled is probably a flaw by its own, you should use one or the other. Or at the least never transition between them (kind of related #2255).
 As per https://github.com/facebook/react/issues/2302 the current plan is to pull linking out of controlled components, but as discussed in https://github.com/facebook/react/issues/2302 it's easy to create wrappers that expose any behavior (including the undefined/null reset behavior described in this issue).  If you find this behavior useful, I would encourage you to publish a npm module or git repository that provides this functionality as a wrapper component so other people can use it. Since this is not something we plan on supporting in the core, I'm going to go ahead and close out the issue.
  This is autogenerated; please send a PR to docs/ on master (can be part of your other PR).
  Can you update the list in vendor/fbtransform/transforms/xjs.js too?
 So it is!
 Should be good. I reran the build and it passed this time:

https://travis-ci.org/facebook/react/jobs/27331192
 Thanks Brandon!
  I think this creates something this when they're on multiple lines, right?

``` javascript
  x: 1
  , y: 2
```

We had an internal unit test that failed when I tried that. It makes it a little ugly.
 Actually the thing I tried was slightly different. Yours is better. I'll try it out tomorrow. Should be fine.
 I hit another issue that can't be solved in the same way. The spread attribute (https://github.com/facebook/esprima/pull/22) can have whitespace between `{` and `...`, as well as arbitrary parenthesis/whitespace before the expression.

``` js
<Foo {  ...  (expr) } />
```

The range of the spread attribute includes the distance between `{` and `}`. The expression excludes the parenthesis. So there's no way for me to tell how far I need to skip to by pass the `...` while keeping the parenthesis.

It's not valid to skip the parenthesis since they may have sequence in them. `(expr1, expr2)`

My solution to this problem was to simply skip the user provided parenthesis and then over parenthesize all the time. :/
 (Or maybe to switch to recast, which presumably handles this properly?)
 I can do a catch up of whitespace+parenthesis. Whatever. It's just a hack util recast is done.
  This unit test fails. 

``` javascript
  it('should handle parenthesis in expressions', function() {
    var code = [
      '/**',
      ' * @jsx React.DOM',
      ' */',
      '<Component x={(a)} {...(b)} y={1} />;'
    ].join('\n');
    var result = [
      '/**',
      ' * @jsx React.DOM',
      ' */',
      'Component({x: (a), ...(b), y: 1});'
    ].join('\n');

    expect(transform(code).code).toBe(result);
  });
```

Because this only steps past the inner expression: https://github.com/facebook/react/blob/master/vendor/fbtransform/transforms/xjs.js#L226-L227

The parenthesis is not it's own expression and therefore doesn't have a range. It's not possible to skip past the `)` to insert the `,` after it.
 The new syntax is this thing: https://github.com/facebook/esprima/pull/22
 @sebmarkbage ~~You fixed this quite some time ago right?~~ Nope, this is definitely not fixed in React master at least.
  @spicyj etc. Perhaps I'm misunderstanding the issue, but as far as React is concerned, this seems "by design" to me (not to say there aren't ways to work around it in user-land though).
 Maybe. I know @vjeux and @jordwalke have done more thinking around this than I have.
  This seems good. :+1:
 @gasi It needs to get landed internally at FB too, so some FB employee (maybe @chenglou) will pull it in and then merge it here as well.
 Thanks!
  This already works correctly in React 0.10.
  There's a lot of stuff in our left nav of the docs. It would be great if someone could clean this up and make it a little easier to digest.
 I sort of have a plan to rewrite and reorganize the docs‚Ä¶ we'll see if I get the energy to execute on it.
 Take a look at the [framer docs](http://framerjs.com/), what they've done with vertical breakpoints for the sidebar is remarkable.
 :+1: 
 Should have a revamp soon.
 @AnSavvides If you ask me the doc is really confusing and cluttered :)
 I remember there was a planned revamp being worked on though... not sure what happened to that.
  @sebmarkbage 
 If you start passing undefined values in to a renderable slot you can no longer have default values for that same slot. This is a potential refactoring hazard.

It's also easy to accidentally return undefined by missing a return case in a function.

``` javascript
function render() {
  if (x) return <Foo />;
  if (y) return <Bar />;
  // undefined
}
```

Failing this type check helps prevent such errors.

I can see that it's a pain to check for the existence of a value. :(

``` javascript
<Foo component={this.props.component || null} />
```

This does forces you to make the choice if you want to use the default prop or explicitly null.

You can always make a renderable prop optional which is suppose to be the same as undefined.
 @sebmarkbage We should at least make `[<a />, <b />, undefined]` pass the renderable check, no?
 Ideally it would be the same behavior for top-level and nested.

You can implement default props as ES6 destructuring which could introduce similar issues at the array level.

There's also a problem if you don't have defaults and don't have explicit prop types in intermediate components. This could warn you about undefined values even without explicit propTypes:

``` javascript
<Wrapper>{this.props.left}{this.props.right}</Wrapper>
```

It's disturbing that it's relaxing the type check when it's nested.

Reopening for proper discussion.

@mathieumg An optional boolean can have an explicit default prop. Makes it a little bit easier to reason about the actual value if it's only true/false.
 @sebmarkbage Isn't this a reasonable piece of code to write in render?

```
var left;
if (showLeft) {
  left = <Left />;
}

return (
  <div>
    {left}
    <Right />
  </div>
);
```

I guess that's not 100% the same as what we're talking about here, but it's close.
 @spicyj Not really, no. It looks like an accidental missing `else` statement. I'd probably lint against that. `var left = null;` on the top line would be reasonable.

But even then, that's a mutable structure. I'd probably prefer the `const` form.
 I think the most convincing use case for me is the case where you have an optional property.

`<Foo child={this.props.childOrUndefined} />`

This might be reason enough to allow this.

However the main issue is that this resolves differently for `undefined` and `null`:

``` javascript
var { childOrUndefined = <Foo /> } = this.props;
```

Therefore passing undefined may actually change behavior of underlying classes in confusing ways. Seems like a little bit of boilerplate to ensure which one you mean seems like a decent way to resolve this issue and ensure that refactoring doesn't cause unforeseen bugs.
 Closing this out again because I think that making it optional is enough. Will follow the lead from Flow here and align with Flow once it settles. I still think undefined needs to be treated differently from null here.
  If you compile this JSX:

```
<CalEvent href="/events?fields=(id,summary)&key=YOUR_KEY" />
```

it turns into:

```
CalEvent( {href:"/events?fields=(id,summary)undefinedEY"} )
```

which seems subpar. I'd expect this to throw an error.
 Sorry ‚Äì to be clear, that's not a workaround; you should have to write `&amp;`. I opened this issue so we can provide a better error message.
 Autoclosing is fun‚Ä¶ reopening here until we update our esprima copy (via jstransform).
 @zpao Landed in 0.12RC, close?
  Whenever I run renderComponentToString() on my backend it returns components with different `data-reactid`'s on each run. How can I change my backend to render `data-reactid`'s + checksums?

[This is my `index.js` template.](https://gist.github.com/yoshuawuyts/65c798e241d63b45aaec)
 Currently the generated ids on the server are random. The checksum is something else that's always there. 
 Ah okay, I thought something like that.. The reason I opened this issue is because I'm getting a warning that my server and client rendering are not the same. How does this get computed? Can this be influenced by certain variables being being handled differently on the server as displayed in my `index.js` file?
 Clear! thanks.
 Yeah, I was injecting a livereload snippet based on `NODE_ENV`. Guess I'll just have to make any production / development differences a function of `state` now. Thanks again dude!
 It appears the checksum is random too. Reopening.

```
‚ùØ versity start
Environment: development
Port: 1337
  <-- GET /
<html class="no-js" data-reactid=".1ss78q1dam8" data-react-checksum="-1230109032"><head data-reactid=".1ss78q1dam8.0"><meta charset="utf-8" data-reactid=".1ss78q1dam8.0.0"><meta httpequiv="X-UA-Compatible" content="IE=edge" data-reactid=".1ss78q1dam8.0.1"><title data-reactid=".1ss78q1dam8.0.2">Versity</title><meta name="viewport" content="width=device-width, initial-scale=1" data-reactid=".1ss78q1dam8.0.3"><script src="http:&#x2f;&#x2f;fb.me&#x2f;react-0.10.0.js" data-reactid=".1ss78q1dam8.0.4"></script><base href="http:&#x2f;&#x2f;assets.site.dev:1337" data-reactid=".1ss78q1dam8.0.5"><link rel="stylesheet" href="&#x2f;build.css" data-reactid=".1ss78q1dam8.0.5.0"><script src="&#x2f;build.js" data-reactid=".1ss78q1dam8.0.5.1"></script><link rel="shortcut icon" href="&#x2f;favicon.ico" data-reactid=".1ss78q1dam8.0.5.2"></head></html>
  --> GET / 200 39ms -
  <-- GET /build.css
  <-- GET /build.js
  --> GET /build.css 200 36ms 3.33kb
  --> GET /build.js 200 149ms 304.12kb
  <-- GET /
<html class="no-js" data-reactid=".fvv61syl8g" data-react-checksum="-1888548894"><head data-reactid=".fvv61syl8g.0"><meta charset="utf-8" data-reactid=".fvv61syl8g.0.0"><meta httpequiv="X-UA-Compatible" content="IE=edge" data-reactid=".fvv61syl8g.0.1"><title data-reactid=".fvv61syl8g.0.2">Versity</title><meta name="viewport" content="width=device-width, initial-scale=1" data-reactid=".fvv61syl8g.0.3"><script src="http:&#x2f;&#x2f;fb.me&#x2f;react-0.10.0.js" data-reactid=".fvv61syl8g.0.4"></script><base href="http:&#x2f;&#x2f;assets.site.dev:1337" data-reactid=".fvv61syl8g.0.5"><link rel="stylesheet" href="&#x2f;build.css" data-reactid=".fvv61syl8g.0.5.0"><script src="&#x2f;build.js" data-reactid=".fvv61syl8g.0.5.1"></script><link rel="shortcut icon" href="&#x2f;favicon.ico" data-reactid=".fvv61syl8g.0.5.2"></head></html>
  --> GET / 200 14ms -
  <-- GET /build.css
  <-- GET /build.js
  --> GET /build.css 200 16ms 3.33kb
  --> GET /build.js 200 109ms 304.12kb
  <-- GET /
<html class="no-js" data-reactid=".1p5gdhwv56o" data-react-checksum="808192322"><head data-reactid=".1p5gdhwv56o.0"><meta charset="utf-8" data-reactid=".1p5gdhwv56o.0.0"><meta httpequiv="X-UA-Compatible" content="IE=edge" data-reactid=".1p5gdhwv56o.0.1"><title data-reactid=".1p5gdhwv56o.0.2">Versity</title><meta name="viewport" content="width=device-width, initial-scale=1" data-reactid=".1p5gdhwv56o.0.3"><script src="http:&#x2f;&#x2f;fb.me&#x2f;react-0.10.0.js" data-reactid=".1p5gdhwv56o.0.4"></script><base href="http:&#x2f;&#x2f;assets.site.dev:1337" data-reactid=".1p5gdhwv56o.0.5"><link rel="stylesheet" href="&#x2f;build.css" data-reactid=".1p5gdhwv56o.0.5.0"><script src="&#x2f;build.js" data-reactid=".1p5gdhwv56o.0.5.1"></script><link rel="shortcut icon" href="&#x2f;favicon.ico" data-reactid=".1p5gdhwv56o.0.5.2"></head></html>
  --> GET / 200 8ms -
  <-- GET /build.css
  <-- GET /build.js
  --> GET /build.css 200 11ms 3.33kb
  --> GET /build.js 200 106ms 304.12kb
```

Edit: Just to clarify, I'm trying to squash this error:

> React attempted to use reuse markup in a container but the checksum was invalid. This generally means that you are using server rendering and the markup generated on the server was not what the client was expecting. React injectednew markup to compensate which works but you have lost many of the benefits of server rendering. Instead, figure out why the markup being generated is different on the client or server. 
 To be clear: the root ID and checksum differ each time, but the same root ID is used on the client when generating the markup, so the checksums generated on the client should match if nothing else is wrong, even though the server produces a different checksum each time.
 > but rather copies it from the target DOM node.

I didn't know that. thanks!
 I'm having the hardest time getting this right though, could you give me maybe a pointer on what I might be doing wrong here?

**index.js** - code to be rendered

``` js
module.exports = react.createClass({
  displayName: 'Index',
  render: function() {  
    return react.DOM.html({className: 'no-js'},
      react.DOM.head(null, 
        react.DOM.meta({charSet: 'utf-8'}),
        react.DOM.meta({httpEquiv: 'X-UA-Compatible', content: 'IE=edge'}),
        react.DOM.title(null, 'Versity'),
        react.DOM.meta({
          name: 'viewport', 
          content: 'width=device-width, initial-scale=1'
        }),
        react.DOM.script({src: 'http://fb.me/react-0.10.0.js'}),
        react.DOM.base({href: 'http://assets.' + 'site.dev:1337'},
          react.DOM.script({src:'/build.js'})
        )
      )
    );
  }
});
```

**build.js** - client side `renderComponent()` call

``` js
module.exports = react.renderComponent(
  index({
    path: '/',
    env: 'development'
  }), 
  document.getElementsByTagName('html')[0]
);
```

**render.js** - server side `renderComponentToString()` call

``` js
app.get('/', function* (next) {
  this.body = react.renderComponentToString(index({
    path: '/',
    env: 'development'
  }));
});
```
 If you add a breakpoint at the console.warn call (in ReactComponentBrowserEnvironment.js), you can inspect `markup` and compare it to the server-rendered version.
 Apart from the tags and id's they are identical:

``` html
<!DOCTYPE html>

<html class="no-js" data-react-checksum="-712920419" data-reactid=".0">
<head data-reactid=".0.0">
    <meta charset="utf-8" data-reactid=".0.0.0">
    <meta content="IE=edge" data-reactid=".0.0.1">

    <title data-reactid=".0.0.2">Versity</title>
    <meta content="width=device-width, initial-scale=1" data-reactid=".0.0.3"
    name="viewport">
    <script data-reactid=".0.0.4" src="http://fb.me/react-0.10.0.js"></script>
    <base data-reactid=".0.0.5" href="http://assets.site.dev:1337">
    <script data-reactid=".0.0.5.0" src="/build.js"></script>
</head>

<body>
</body>
</html>
```

``` html
<!DOCTYPE html>

<html class="no-js" data-react-checksum="1512167114" data-reactid=
".vtzzi7pgqo">
<head data-reactid=".vtzzi7pgqo.0">
    <meta charset="utf-8" data-reactid=".vtzzi7pgqo.0.0">
    <meta content="IE=edge" data-reactid=".vtzzi7pgqo.0.1">

    <title data-reactid=".vtzzi7pgqo.0.2">Versity</title>
    <meta content="width=device-width, initial-scale=1" data-reactid=
    ".vtzzi7pgqo.0.3" name="viewport">
    <script data-reactid=".vtzzi7pgqo.0.4" src="http://fb.me/react-0.10.0.js"></script>
    <base data-reactid=".vtzzi7pgqo.0.5" href="http://assets.site.dev:1337">
    <script data-reactid=".vtzzi7pgqo.0.5.0" src="/build.js"></script>
</head>

<body>
</body>
</html>
```
 I'm confused; you shouldn't see data-react-checksum in the client-side generated markup ‚Äì addChecksumToMarkup is called only from renderComponentToString.
 That's on me, I logged to a string from the callback. Will do the method you suggested. Woops, haha :sparkles: 
 This time through the correct method. They still appear to be identical.
**client**

``` html
<!DOCTYPE html>

<html class="no-js" data-reactid=".1v4ncdwtkao">
<head data-reactid=".1v4ncdwtkao.0">
    <meta charset="utf-8" data-reactid=".1v4ncdwtkao.0.0">
    <meta content="IE=edge" data-reactid=".1v4ncdwtkao.0.1">

    <title data-reactid=".1v4ncdwtkao.0.2">Versity</title>
    <meta content="width=device-width, initial-scale=1" data-reactid=
    ".1v4ncdwtkao.0.3" name="viewport">
    <base data-reactid=".1v4ncdwtkao.0.4" href="http://assets.site.dev:1337">
    <script data-reactid=".1v4ncdwtkao.0.4.0" src="/react.js"></script>
    <script data-reactid=".1v4ncdwtkao.0.4.1" src="/build.js"></script>
</head>

<body>
</body>
</html>
```

**server**

``` html
<!DOCTYPE html>

<html class="no-js" data-react-checksum="1179963132" data-reactid=
".1v4ncdwtkao">
<head data-reactid=".1v4ncdwtkao.0">
    <meta charset="utf-8" data-reactid=".1v4ncdwtkao.0.0">
    <meta content="IE=edge" data-reactid=".1v4ncdwtkao.0.1">

    <title data-reactid=".1v4ncdwtkao.0.2">Versity</title>
    <meta content="width=device-width, initial-scale=1" data-reactid=
    ".1v4ncdwtkao.0.3" name="viewport">
    <base data-reactid=".1v4ncdwtkao.0.4" href="http://assets.site.dev:1337">
    <script data-reactid=".1v4ncdwtkao.0.4.0" src="/react.js"></script>
    <script data-reactid=".1v4ncdwtkao.0.4.1" src="/build.js"></script>
</head>

<body>
</body>
</html>
```

edit: They seem to share the same `reactid`. No idea why I'm still getting the error though.
 Instead of adding whitespace, can you paste the two versions exactly?
 **client**

``` html
<html class="no-js" data-reactid=".1q1p8x1ojy8"><head data-reactid=".1q1p8x1ojy8.0"><meta charset="utf-8" data-reactid=".1q1p8x1ojy8.0.0"><meta httpequiv="X-UA-Compatible" content="IE=edge" data-reactid=".1q1p8x1ojy8.0.1"><title data-reactid=".1q1p8x1ojy8.0.2">Versity</title><meta name="viewport" content="width=device-width, initial-scale=1" data-reactid=".1q1p8x1ojy8.0.3"><base href="http:&#x2f;&#x2f;assets.site.dev:1337" data-reactid=".1q1p8x1ojy8.0.4"><script src="&#x2f;react.js" data-reactid=".1q1p8x1ojy8.0.4.0"></script><script src="&#x2f;build.js" data-reactid=".1q1p8x1ojy8.0.4.1"></script></head></html> 
```

**server**

``` html
<html class="no-js" data-reactid=".1q1p8x1ojy8" data-react-checksum="720685620"><head data-reactid=".1q1p8x1ojy8.0"><meta charset="utf-8" data-reactid=".1q1p8x1ojy8.0.0"><meta httpequiv="X-UA-Compatible" content="IE=edge" data-reactid=".1q1p8x1ojy8.0.1"><title data-reactid=".1q1p8x1ojy8.0.2">Versity</title><meta name="viewport" content="width=device-width, initial-scale=1" data-reactid=".1q1p8x1ojy8.0.3"><base href="http:&#x2f;&#x2f;assets.site.dev:1337" data-reactid=".1q1p8x1ojy8.0.4"><script src="&#x2f;react.js" data-reactid=".1q1p8x1ojy8.0.4.0"></script><script src="&#x2f;build.js" data-reactid=".1q1p8x1ojy8.0.4.1"></script></head></html>
```
 Odd, I'm not sure. You could also try adding debugging to ReactMarkupChecksum.addChecksumToMarkup on the server to see what `markup` looks like and compare what you get from running adler32 on it. Your guess is as good as mine now though.
 Yeah, even when setting the `client` string as a fixed server response things break. I have no idea why this happens, will try `0.11-alpha` tomorrow to see if anything changes.
 @syranide What version of react were you using? Also: what string were you using? I want to see if I can make your version run here.
 Let's see if I can make it work then :)
 It correctly computes the new checksum, so both files are identical. But when reading the previously set checksum it returns `null`. Investigating why this is.
 `getReactRootElementInContainer(container)` returns `head`, not `html` thus it incorrectly reads the checksum as being `null`.
 Yep, that was the fix! :sparkles: :sparkles: 
 Maybe we should add a check for `null` in `ReactMarkupCheckSum.canReuseMarkup()`. It provides a little more information of what's going wrong when the checksum doesn't align.
 Yeah, I'll PR it if @spicyj gives the green light.
 Aye, will do.
 @sillero FYI, what's actually happening is `checksum(renderedHtml)` on both server and client, the server stores that checksum as `data-react-checksum`, the client uses that to ensure that both server and client rendered identical DOM. Whitespace around the inserted server-rendered HTML does NOT affect the checksum, however, if there is a leading node of any kind (including just whitespace) then React will (currently) look at that and determine that it can't be reused, see #1912.
 @klimashkin The XXX-part is the key as provided by You, it seems you have an inconsistency on your side (`.$` indicates a key).
  You should see the full error message, and I do when going to that page:

![image](https://cloud.githubusercontent.com/assets/6820/3213486/8f80bdc2-ef90-11e3-9924-c5726d7bf594.png)

I recall a Chrome bug that causes the error message not to be shown, though I thought it was fixed in the current builds. We'll do a better job of warning you exactly what the problem is when #101 gets properly implemented.
 Chrome bug here: https://code.google.com/p/chromium/issues/detail?id=331971
 This was fixed in Chrome. Also I added a better warning for this particular problem.
  Hopefully this will make fewer people confused at all of the null properties. The string won't wrap nicely so I tried to keep it pithy:

![](https://s3.amazonaws.com/uploads.hipchat.com/6574/26709/v8vzKAC784QMkX2/upload.png)

Better suggestions appreciated.
 You could highjack the class's `toString` and log a message there, but this changes the behaviour between dev and prod.
 @syranide It's only set in the destructor which isn't called if .persist() is. I've intentionally created the property even in prod; we try hard to avoid any observable behavioral differences between dev and prod and you could perhaps loop through the properties of an event and somehow get confused.
 :thumbsup: Anything you want to change about it @yungsters?
 This is pretty cool, looks good to me.
 Of course @sebmarkbage wanted some changes right after I merged. (something about deopting hidden classes)
 Well... for what it's worth, we only de-optimize the pooled objects once until the pool gets warm.
 Tips for reducing the hidden class impact here? I made an attempt to set it as soon as possible ‚Äì does it need to be in the constructor instead?
 It might be possible to add it somewhere else.

The problem is that I want to get rid of this pattern of adding additional properties to instances because it becomes incredibly difficult to reason about statically and around performance. It doesn't matter if we can find a case where it wouldn't deopt because it's still difficult to reason about and it still adds memory overhead in PROD.

You could potentially use something like `displayName` or `valueOf` on the prototype to name Objects. It's already called SyntheticEvent. You can probably get that to be `"SynthenticEvent - Pooled class whatever..."`
 Reverted in 92d2dcc.
 @sebmarkbage A curious question, do we really need pooled classes for events, can there ever be more than one of the same event type in flight at any one time?
 I vaguely remember us having this discussion some where else, but I think the reasoning is that events get created a lot. If we create new SyntheticEvents all the time, I think we're going to hit GC much more frequently.
 I think what @syranide is asking is if it can just be a single global instead of pooled. Possibly. They may have different signatures though.

> On Jul 12, 2014, at 5:24 PM, Paul O‚ÄôShannessy notifications@github.com wrote:
> 
> I vaguely remember us having this discussion some where else, but I think the reasoning is that events get created a lot. If we create new SyntheticEvents all the time, I think we're going to hit GC much more frequently.
> 
> ‚Äî
> Reply to this email directly or view it on GitHub.
 @sebmarkbage Indeed. Practically, could we replace the use of PooledClass for Synthetic*Event with say ReusedClass, that instead only holds a single reference (rather than an array). Rather off-topic, but it just came to mind when I saw this issue.
 If you call `node.focus()` then focus handlers are triggered immediately, so I believe you can have two focus events in flight at the same time.
 @spicyj Imagineable (and interesting!) and I'm not arguing for there being a lot of practical merit to my idea, but I imagine that for your scenario, spawning an additional "non-pooled" event is a non-issue, unless that is true for other events too.
  This is intended; see #1484. Because the user could have an option after the initial render, React won't blow away their selection when updating.
  Looks pretty good to me. After getting `camelize` synced out let's do `camelizeStyleName` instead of `unhyphenateStyleName`.
 `camelize` does exist already. I can sync it out. It's _very_ similar to what you have here :)
 What do you think about also warning if someone writes `Ms` instead of `ms` (and possibly wrong casing of the other vendor prefixes as well)?
 Seems reasonable, but let's do that in a second PR
 Sorry this took so long to get in!
  **Note from maintainers:** Starting with React 15, we should have a complete support of the subset of SVG specifications that is actually implemented by browsers.

If you find a missing attribute, or if a tag does not work correctly, please write a comment below. Note that `React.DOM.*` factory functions might not provide all tags, but you should be able to use `React.createFactory` or `React.createElement()` directly for the missing ones. Or you can just use JSX which translates to `React.createElement()` and supports all tags inherently.
 This "add a random element and attribute here and there as 1 person needs it" approach has gotten out of hand. So we either need to support everything or nothing (or alternatively add a reasonable set of things now and then freeze there).

I scraped http://www.w3.org/TR/2003/REC-SVG11-20030114/attindex.html for _almost_ everything (not counting namespaced attributes) and came up with this: https://github.com/zpao/react/compare/fuck-svg.

However that adds ~2kb to our minified build (though it would crush well with closure compiler) and I don't want to take that size increase right now. We've talked about doing a separate SVG build. Or shipping that separately as an addon.
 #2069 requests support for image.
 Perhaps someone has the will-power to trawl through http://www.w3.org/TR/SVG/Overview.html and get all the attributes and properties? (There might be a better URL for this purpose, not sure...)
 @syranide I did that (mostly automated because that would be madness to do manually) - https://github.com/zpao/react/compare/fuck-svg. See my previous comment about why that's not just merged in already.

@ThomasDeutsch See most any of the previous SVG related pull requests. That said, I'd rather figure out a plan than add them one by one (I'll direct you to my previous comment too).
 @jeffkole Be careful when doing that ‚Äì React will still call setAttribute (not setAttributeNS) if the attribute changes, and the update probably won't work properly.
 We haven't figured out how namespaced attributes will work and don't support it right now, sorry.
 Sorry, no.
 cc @xymostech @MichelleTodd
 Not on this specifically, but #3718, #3763 are both SVG things being worked on and #3067 is also related to this attributes change.
 @spicyj has a plan to eliminate the need for a separate config we need to keep updating. Hopefully that will be complete soon. In the mean time, please hold tight.
 Like @zpao said, we're going to fix this for good soon so any attributes can be used.

Locking this issue until then.
 This was fixed in https://github.com/facebook/react/pull/5714.
 #5714 was reverted in #6243, and thus we still require an attribute whitelist. The good news, however, is that **#6243 contains attributes scraped for MDN so we expect it to cover 95% of the use cases**. I read through this whole issue and linked issues and PRs and manually added two missing properties (`focusable` and `vector-effect`) in #6267. I expect these changes to land in v15.

Interestingly, I‚Äôm not sure whether the _tag_ whitelist is relevant anymore. So far I have been able to use `<marker>`, `<textPath>`, `<feGaussianBlur>` and other tags requested in this issue and in linked PRs without trouble on master. I see that [`fbjs` still maintains an SVG tag whitelist](https://github.com/facebook/fbjs/blob/89ffda59d923183dd34efb2622da0176ccb04d41/src/core/getMarkupWrap.js#L61-L83) and I don‚Äôt know the codebase well enough to say why tags missing from it worked for me today, so hopefully @zpao or @spicyj can clarify this, and whether we need to also add the missing tags there, to complement #6243.

I am unlocking this issue because the attribute whitelist is still relevant, but hopefully we will see a lot less requests now that most of the attributes that are both in the spec and are implemented by the browsers, are supported. If something still isn‚Äôt supported in the final v15, please let us know here.

**This note does not apply to v15 RC1 which passes all SVG attributes through. We reverted this behavior in #6243 so please use the upcoming RC2, the master, or the final v15 to tell whether the attributes you are interested in are currently supported.**
 I noticed that there seems to be quite a lot of confusion about the `xlink:href` attribute. It _is_ currently supported but you would need to write it in a different way:

``` js
<use xlinkHref="#shape" x="50" y="50" />
```

React will correctly turn that into `xlink:href`, even in 0.14.x. See [this fiddle](https://jsfiddle.net/j825fmtw/) for an example.
 While this works it‚Äôs not an officially exposed API and may break in any minor or patch release. You can use it but on your own risk. If something is still missing please work with us so we add it. I‚Äôm glad to hear you don‚Äôt have issues with 15 RC2. 
 > and not document.createElementNS.

The blog post is a little too simplified, but `createElementNS` is used when we‚Äôre under an `<svg>` tag. If this doesn‚Äôt happen can you please file a separate issue describing the problem, with a JSFiddle that reproduces it? Thanks!
 Yea, `xmlns` and `xmlns:Xlink` are missing.  https://github.com/facebook/react/pull/6471 has some in progress work to add it.
 @shilpan 

All tags are supported now. [The list](https://facebook.github.io/react/docs/tags-and-attributes.html) only tells which tags are supported as `React.DOM.*` factory functions:

> The following SVG elements are supported **in React.DOM.*:**

(emphasis mine)

If you use JSX, you don‚Äôt need to worry about this at all‚Äîwriting `<animate>` and `<animateTransform>` will just work because JSX does not rely on `React.DOM.*` factories.

Even if you don‚Äôt use JSX, you can use `React.createElement('animate', ...)` which will work just fine, or create your own factory function: `var animate = React.createFactory('animate")`.
  It's impractical for us to add JSX support to every editor out there; you may have more luck making a feature request for NetBeans. We use issues on this repository are used for keeping track of bugs in React itself.
 @ram-you I'm sure it wasn't Ben's intent to suggest that NetBeans was unimportant.  It is a very important IDE that provides substantial value to the community.  But we are not the team who maintains NetBeans, and we are not familiar with the NetBeans codebase.  It is not practical for us to learn the code for every IDE and modify the IDEs to support the features we like.  We need to rely on each IDE development team to add the features that their users are requesting, so the correct route is to contact the developers responsible for your preferred IDE and ask them to prioritize the feature.
  Not that I know of. This isn't really the right forum for a question like this; you might have better luck on the mailing list but I can't promise anything.
  Yes; the last couple of releases have had transitional code to warn if you're relying on the mutation of the descriptor that we did in previous versions; in master (and the next release) we don't mutate descriptors and it's safe to reuse them.
 @matthewwithanm I might be misunderstanding what you're saying, but React will reuse the component instance (doing an update instead of unmount/remount) as long as the props match, regardless of if the actual descriptor object is reused.
  @petehunt 
 Oh, so it does. Closing this issue ‚Äì @drscre let me know if I'm missing something.
  This happens when an image loads that React has unmounted from the DOM. This should be fixed in master ‚Äì sorry for the trouble.
 @bradens Planning on 0.11 sometime soonish. I want to say sometime in the next 2 weeks.
  You should have seen a warning in your console about this if you're using the dev build of React.
  You could do something like this:

``` javascript
var realDiv = React.DOM.div;
React.DOM.div = React.createClass({
  displayName: 'div',
  render: function() {
    var style = {
      display: this.props.hidden ? 'none' : null
    };
    return this.transferPropsTo(<realDiv style={style}>{this.props.children]</realDiv>);
  }
});
```
 It would be nice to be able to wrap attributes in general though to do things like autoprefixing.
 > Phantom bump, but I've been trying to do a lot of SVG work with react, and there are a lot of issues like "Please support this SVG attribute."

This has mostly been solved in v15 RC2. We should support all of the spec implemented by browsers now. Please give it a try.

> This would allow semantic attributes to be declared that would be applied to modify some other attributes on the element.

It sounds like you really want a custom `<Div>` (or `<View>`) component that acts this way, rather than override a native component. This doesn‚Äôt require changes in the core and lets you deviate as much as you like, and potentially change the tag you render to later. Because this use case is covered by React well, I don‚Äôt think it‚Äôs worth adding something as invasive as the original suggestion.

> It would be nice to be able to wrap attributes in general though to do things like autoprefixing.

Yeah, but even in this case it‚Äôs best that we take care of this, rather than let the user override arbitrary attributes in arbitrary ways. So autoprefixing could be a part of an integrated style solution, but I don‚Äôt see the use case for this particular proposal, so I‚Äôm inclined to close.

Please let me know if I‚Äôm wrong and we should reopen this. Thanks!
  I am pretty sure this is an oversight in src/core/ReactPropTypes.js. Want to submit a pull request to fix?
 `null` is technically renderable because you can return it from the render.
 Strings, numbers, and arrays are already considered renderable even though you can't render them standalone.
 String and numbers are supposed to be at one point. Array is, but not when directly returned by render. So yeah, a bit inconsistent.
 Closing this bug.  Looks like we consider null and undefined to have different meanings, as per the discussion here: https://github.com/facebook/react/pull/1668
  Closing in favor of #1657.
  This won't work for updates; the code will need to use setAttributeNS.
  You can already use `map` and return `null` or `undefined` for the elements you don't want to display.
  This is an intentional deviation from HTML because usually you don't want extra whitespace between tags. See here for a summary of the current rules:

http://facebook.github.io/react/blog/2014/02/20/react-v0.9.html#jsx-whitespace
  (I'd personally prefer that we go the other way and not add `px` to strings that look like numbers, as I mentioned in #1357.)
 **re: hyphenated styles**
I agree that we should only support 1 way. And currently that's camelCase. We should stick with that and warn (#1662).

**re: trimming**
If we stick with our current behavior of appending `px`, then what we have right now is a bug and we should trim. Short term we can take this part. Long term I think we should reconsider our `+ 'px'` behavior entirely.
 @syranide I'm not sure what value that would give over just writing the strings verbatim?
 sugar for things that are already simple is usually overkill IMO. And at that point you're in what we think is JS already, so it's a bit awkward.
 Thanks!
  We have some code that looks something like this:

http://jsbin.com/xipeduxu/1/edit

The root component shows which of a changing list of items is currently being hovered. Note that if you mouse over the last component and it disappears, your selection is "stuck" with that component and doesn't reset to null. If you uncomment the line in componentWillUnmount then we attempt to tell the parent to unset the active property, but it then throws an error when unmounting the active item because the parent is currently in the middle of reconciling its children which is not currently a place we allow state updates.

It seems like maybe the best solution is to have the parent be smarter and realize when it's removing the active child and have it unset the `active` state property, though I don't see a super clean way to do so. Right now `tick` doesn't need to know anything about what makes an item active or not‚Äîit seems nicer to keep it that way if possible.

@sebmarkbage Do you have thoughts here?

cc @zgotsch
 Isn't it in the spec? http://www.w3.org/TR/DOM-Level-3-Events/

IE and jQuery have both supported it for many years.
 This is a similar issue as the cursor/hover problem. If you hover over a moving box, the cursor doesn't update because the scene isn't reevaluated every frame.

http://jsbin.com/roparato/1/
http://sebmarkbage.github.io/art/demos/opacity/
(move the cursor over the moving box and then let it rest until the box moves out of the way)

As you can see, firing the mouseleave event only on destruction isn't enough. We could take it upon ourselves to change the browser behavior by reevaluating mouse target for every rerender. E.g. using `elementFromPoint`. If the target has changed, we simply refire synthetic mouseover/out events which would then trigger the enter/leave events. I used to do this in ART but changed it to be consistent with the browser.

In an immediate mode framework you could reference something like "current mouse target" in render. E.g. something like `var activeIndex = currentMouseTarget.getAttribute('data-index');` Something like that might be possible too.
  You can already achieve a similar effect using transferPropsTo:

``` js
var PostLineItem = React.createClass({
  getDefaultProps: function() {
    return {
        typeImage: '/imgs/post-default.jpg'
    };
  },
  render: function(){
    return (
      <li>
        <img src={this.props.typeImage} />
        {this.props.title}
      </li>
    );
  }
});

var NewsPostLI = React.createClass({
  render: function() {
    return this.transferPropsTo(
      <PostLineItem typeImage="/imgs/posts-news.jpg" />
    );
  }
});
var MemePostLI = React.createClass({
  render: function() {
    return this.transferPropsTo(
      <PostLineItem typeImage="/imgs/posts-meme.jpg" />
    );
  }
});
```
 If you want to take the passed-in prop value, you can do something like this:

```
var EmailLoginBox = React.createClass({
    render: function() {
        return this.transferPropsTo(
            <LoginBox usernameLabel={this.props.usernameLabel || "Email"} />
        );
    }
});
```

You can also do more complex things like combining the passed-in label with your default if you want to.

Because this is the recommended way to write this code, I'm going to close this out but let me know if I'm missing something else.
  We want to do this, but versioning will be an interesting problem which is why we haven't done it yet (these are common core modules which may need to be versioned separately from React for e.g. jest). Stay tuned...
 @ToucheSir The main purpose of keyMirror is to deal with the fact that Closure Compiler advanced mode crushes keys, which allows you to write code like

```
keyMirror({monkey: null, gorilla: null})
```

and have it become something like

```
k({m:null,g:null})
```

which evaluates to

```
{m:"m",g:"g"}
```

at runtime. If it was specified as a list of strings, they wouldn't get crushed matching the property names.
 @jordwalke and what happens when they do? what if we release a component that depends on a version of `merge()` that conflicts with another component used in the app? Even worse, what if the module were stateful?

BTW, we were talking about changing `merge()` on some thread yesterday, so this is not a super long shot. Versioning react, its dependencies and dependents is a difficult problem, especially with FB's internal development process and our desire to dogfood everything in open source.
 Random usage of `fbjs` isn't really supported but we moved `keyMirror` out of React to there (`require('fbjs/lib/keyMirror')`. Closing out.
 You can't.
  Thanks!
  Want to send in a pull request? I don't think any of us are very familiar with [component](https://github.com/component/component) but we'd be willing to consider a PR if it doesn't add much complexity.
 Our browser builds have a UMD wrapper so should set module.exports when appropriate, but we don't store prebuilt versions in the repo and right now we need a build step to run the files. I don't see how to instruct `component` to run any sort of build script or to use a pre-built version that doesn't get committed so it might be hard to make this work with our current setup.
 For npm we can (and do) run the build script before packaging. I don't see a way to do the same thing with component.
 Oh, perhaps we can even use the same repo.
 There was discussion about this before where it was ultimately decided it wasn't doable because of component's insistence of a single export (https://github.com/reactjs/react-bower/issues/1). Our dev/prod builds make this really annoying.

As for shipping individual addons as standalone modules, that's something we want to do here too, we just need to figure out some more API things first.
 +1 on what @akre54 said. I need to bypass the CDN by serving a local copy while in dev, and having to manually copy / paste the raw CDN file doesn't seem like the best solution. It would be nice to have a prebuilt binary available through npm.
 @akre54 Can you be more specific about what doesn't work with webpack?
 Can you explain the error you get or what specifically doesn't work? An exact configuration (and command line arguments) to reproduce the problem would be helpful too so I don't have to guess.
 No problem, thanks.
 Installing it from npm works well

Sent from my iPhone

On Jun 17, 2014, at 3:45 PM, "Adam Krebs" <notifications@github.com<mailto:notifications@github.com>> wrote:

Install react from bower. Require into a js file. Try to compile with
webpack. Profit?

https://github.com/akre54/es6-react-webpack-bower-backbone (try the coffee
branch)
On Jun 17, 2014 6:42 PM, "Ben Alpert" <notifications@github.com<mailto:notifications@github.com>> wrote:

> @akre54 https://github.com/akre54 Can you be more specific about what
> doesn't work with webpack?
> 
> ‚Äî
> Reply to this email directly or view it on GitHub
> https://github.com/facebook/react/issues/1635#issuecomment-46375373.

‚Äî
Reply to this email directly or view it on GitHubhttps://urldefense.proofpoint.com/v1/url?u=https://github.com/facebook/react/issues/1635%23issuecomment-46375671&k=ZVNjlDMF0FElm4dQtryO4A%3D%3D%0A&r=qYx6qLphxKhA5vHBqr9vuw%3D%3D%0A&m=xxSVSgKUa9geYv8%2F8LolpsoiLSHdy4X49RKoAxcdsKs%3D%0A&s=f9b6f2d9694cae305e67e71000be90f567237a6d4470255d04cebb7ff23e8392.
 I am not sure what you mean by compile it yourself. The version in npm is already compiled out of our repo.

Sent from my iPhone

On Jun 17, 2014, at 4:16 PM, "Adam Krebs" <notifications@github.com<mailto:notifications@github.com>> wrote:

Right, but it forces me to a) compile it myself, b) keep react separate
from the rest of my frontend deps, all of which work with no problems from
bower.

‚Äî
Reply to this email directly or view it on GitHubhttps://urldefense.proofpoint.com/v1/url?u=https://github.com/facebook/react/issues/1635%23issuecomment-46378137&k=ZVNjlDMF0FElm4dQtryO4A%3D%3D%0A&r=qYx6qLphxKhA5vHBqr9vuw%3D%3D%0A&m=L7kfBobOzjDSTkhHIX6HaljaWJwD8A6X0fUSwMXrrE8%3D%0A&s=4a3a5904e63846f8750e0ec6c47f6b6f73f8d0504b9c4eea2be6aefefd9812e1.
 Also without having investigated this at all, the thing in bower is just the output of browserify with umd turned on (I do remember seeing some issues with browserify umd in the past but I think they have been fixed) so it's possible the issue is in webpack or browserify or umd (which were updated today I believe)

Sent from my iPhone

On Jun 17, 2014, at 4:16 PM, "Adam Krebs" <notifications@github.com<mailto:notifications@github.com>> wrote:

Right, but it forces me to a) compile it myself, b) keep react separate
from the rest of my frontend deps, all of which work with no problems from
bower.

‚Äî
Reply to this email directly or view it on GitHubhttps://urldefense.proofpoint.com/v1/url?u=https://github.com/facebook/react/issues/1635%23issuecomment-46378137&k=ZVNjlDMF0FElm4dQtryO4A%3D%3D%0A&r=qYx6qLphxKhA5vHBqr9vuw%3D%3D%0A&m=L7kfBobOzjDSTkhHIX6HaljaWJwD8A6X0fUSwMXrrE8%3D%0A&s=4a3a5904e63846f8750e0ec6c47f6b6f73f8d0504b9c4eea2be6aefefd9812e1.
 @jasonkuhrt I tend to agree with you on that. I was thinking more about CommonJS as the lingua franca than npm as the canonical repo/namespace.
 @akre54 The UMD wrapper is provided by browserify; we don't do anything special there.
  This is intentional; context is determined by where a component is _created_ (in your `mount()` function), not where it is rendered (in your `App` component). Also note that context is experimental and likely to change in future versions.
  Closing in favor of #1657.
  Do you mind signing [the CLA](https://code.facebook.com/cla)? Thanks!
  Thanks! This is actually autogenerated from the source in docs/ on the master branch:

https://github.com/facebook/react/blob/master/docs/_posts/2013-06-05-why-react.md

Mind making a new PR to master?
  You can't do setState in conjunction with server rendering; your `componentInstance` variable merely _describes_ what component instance to mount; it is not an instance itself so setState doesn't work on it. There isn't any way to get a component instance when using server rendering.

If you want to "change the state" and get a new HTML string, you should probably instead refactor your logic so that props determine what the component shows (rather than state). Then you can pass a new "descriptor" to renderComponentToString.
  Thanks!
  I think @andreypopp has reported this before, not sure if we have another issue open.
 No, that made it in; this is a slightly different issue.
 This is fixed in master, I believe it shipped with 0.11.x.
  What's the behaviour when you have the first one uncommented and the second one commented out? Still the same error?
  Edit: the docs are generated once in a while by some committers. You don't have to manually change the output html. I'll close this since you already made the necessary changes in #1623.
  Let's add an inline comment about why we're using `cache: false` to help educate the copy+pasters.
 Also note that this appears 5 times in the tutorial and the line highlights are messed up by adding a line.
 @brigand, are you still interested in doing this?
 I'm asking if you're interested in following through with this PR - there are unresolved issues in the comments from me and @spicyj. I still think we should add a short comment on the first use.
 Last couple weeks have been busy, I apologize for the really sporadic pings here :/

Can we get the line highlights fixed like @spicyj mentioned above? We use a syntax for codeblocks which results in specific lines being highlighted and just inserting new lines without adjusting offsets results in bad highlighting.

If you're not up for it, I understand, just let me know!

Before:
![screen shot 2014-07-30 at 10 33 17 am](https://cloud.githubusercontent.com/assets/8445/3753173/cf7fd88e-180f-11e4-82d0-8290dda6846f.png)
After:
![screen shot 2014-07-30 at 10 33 29 am](https://cloud.githubusercontent.com/assets/8445/3753178/d43e7a60-180f-11e4-906a-4237bc321c19.png)
 With using real servers now in https://github.com/reactjs/react-tutorial, I think we can just skip this.
  Sorry for the delay. This sounds reasonable to me, though I want @fisherwebdev to take a look because I'm not familiar enough with the intentions.
 Thanks :)
  (After #1254 is fixed we shouldn't need initializeTouchEvents at all‚Ä¶)
  TapEventPlugin has:

```
var dependencies = [
  topLevelTypes.topMouseDown,
  topLevelTypes.topMouseMove,
  topLevelTypes.topMouseUp
];

if (EventPluginUtils.useTouchEvents) {
  dependencies.push(
    topLevelTypes.topTouchCancel,
    topLevelTypes.topTouchEnd,
    topLevelTypes.topTouchStart,
    topLevelTypes.topTouchMove
  );
}
```

at the top level. Since useTouchEvents won't have been set to true at require time (even if it will be set to true before any user code runs), the touch events are never bound.

Not super high priority because we don't actually support/advertise TapEventPlugin yet, but it would be nice if this worked before merging #1170.

(Thanks @ryanseddon for reporting.)
 fixedit
  #1511 fixes this.
 Fix landed some time ago, closing.
  This is part of a future proposal https://github.com/reactjs/react-future/blob/master/01%20-%20Core/02%20-%20Mixins.js

We highly discourage the use of inheritance as a way to provide extensions. Composition is a more powerful pattern of code reuse.
  We're not planning to add more utils like this to TestUtils. You can always implement this locally in your project as a helper if you want to, but we're planning to move towards shallow testing (i.e., TestUtils. createRenderer) in the future.
  My first instinct would be to say that you can use exactly one directive or do nested updates, not both.
 Since we're deprecating Update in favour of [immutable-js](https://github.com/facebook/immutable-js), I think, beside existing bug fixes + some low hanging feature requests, we won't be adding a whole new syntax for updating nested collections like json paths. 

_(FYI, immutable-js and Clojure uses `['path', 'to', 'child']`, which is imo a way saner way of approaching this.)_

That being said, I agree with @spicyj. Yes, the ordering is arbitrary right now, but you probably shouldn't rely on it the same way you can't do `{$push: [1], $push: [2]}`, if you know what I mean.

If that makes sense, can we close this? (@petehunt)
 > (FYI, immutable-js and Clojure uses  ['path', 'to', 'child'] , which is imo a way saner way of approaching this.)

@chenglou It is not GCC ADVANCED_MODE-compatible though I think?
 We are handing over `update()` to the community so I‚Äôm closing this.
Please see my note in https://github.com/facebook/react/pull/6353#issuecomment-204219214.
  > The jsx precompiler expects a `React` namespace, so `define` and `require` must import the React build as `React`.  This is a little ugly, but it's mentioned in the example's page.

You could also use `@jsx react.dom` and it wouldn't need `React` but that would be pretty inconsistent with all other uses.

> I personally prefer CurlJS, which has no jsx plugin, and I'm not sufficiently interested to implement my own.  Looking at `require-jsx`, I don't see sufficient quality to warrant inclusion (after a quick look, I see that `package.json` defines `main : jmx.js`, not the `jsx.js` that actually exists; I see a bunch of workarounds without tests; and I feel that the necessary configuration is too verbose).  I don't think that official examples should reference this software in its current form, and I'm not interested in fixing it.

We actually think using JSXTransformer in anything except prototypes is a bad idea, so that's fine

> I've `/* global define */` qualified AMD modules to appease JSHint.  Should this stuff be somewhere else?

We probably should just not lint examples. Or put a separate `.jshint` file in there if we care.

> The example page mentions the image of a precompile step.  This image is not under version control, but an earlier step generates it.  Should the image(s) be under version control too?  Should the reference get removed from the page itself?  Is it okay as is?

Not sure what you mean here. What image?
 Sorry for the extreme delay on this. We haven't heard much confusion around RequireJS, it feels anecdotally to me that people are moving away from it in favor of Browserify and Webpack, and this is a little outdated (our fault, not yours) and inconsistent with the other examples (file extension, actual example contents) so I'm going to close this out, but thanks for sending this in!
  I would counter-argue and say anything we can do to reduce GC is a win. While I agree that this isn't the worst place for allocations, I don't see any really compelling reason to take a step backwards. There's a tradeoff, but I wouldn't call it a "great cost", I can count on 1 hand the number of times it's come up in the past year. Logging events is annoying but as you found out easily solved so I think we should leave this as is (and document better).

@yungsters @petehunt @sebmarkbage 
 IIRC we added or fixed event pooling after seeing a lot of GC thrash for mouse move events which have very high frequency (we originally didn't support these). Even when nothing is acting on these.

Pooled descriptors is indeed something we want to introduce to avoid thrash in extreme cases where updates happen on every mouse or
touch move. We need to be able to operate well in edge cases too.

They're generally easy to predict when they can be reused because you're not expected to hold on to anything created in the render function of a component. Expect possibly for animation which would need to tie into the pooling system.

DOM events are also reused in a similar way. I'm not saying it's right. Ideally we should encourage more immutable behavior but there is existing precedence for this behavior.

Mutating React objects is already considered bad practice but we could do a Object.preventExtension call to explicitly ensure that nobody adds additional properties to the object.

> On May 28, 2014, at 2:44 AM, Andreas Svensson notifications@github.com wrote:
> 
> I understand your point, but from my perspective I've seen a handful of people get confused by it on IRC (which indicates that it's at least unintuitive behavior):
> 
> If reducing GC is an overriding goal, then does it really make sense to promote immutability which creates long-lived objects which are harder on the GC? Transient non-cyclic event objects should be near trivial for a GC. Shouldn't pooled descriptors be of outmost importance otherwise?
> 
> "We want to keep the API as simple as possible and help developers fall into the pit of success. Enabling bad patterns with bad APIs is not success." is a clearly stated goal of React it seems. On the surface, pooled events contradict that (imho, it's not necessarily wrong though).
> 
> There is a huge non-obvious issue today. Consider someone relaying events (like a custom button) and do event.targetComponent = this to relay additional information, perhaps not good practice, but it's not far-fetched. Significant and indefinite memory leaks ensue, this is fixable, but adds more overhead.
> 
> My intuition (which may be completely off) is that the overhead of dealing with pooled events, would take away the minimal cost it would incur the GC (which would probably occur during an idle frame anyway). Even if that isn't that case, I just can't imagine pooling events to actually have a measurable impact in non-synthetic tests. If your information suggests otherwise then by all means, shoot me down, but it fees like "premature optimization" to me.
> 
> ‚Äî
> Reply to this email directly or view it on GitHub.
 @syranide Descriptors can be reused in the same owner subtree which created it. E.g.

``` javascript
render() {
  var a = <div />;
  return <div>{a}{a}</div>;
}
```

If this render method is reexecuted, we can reuse the same object because all subtrees would rerender with the new object and they shouldn't hold a reference to the old one. (Every other render so that the old value can be used in shouldComponentUpdate.)

We lazily attach listeners. Lazily attaching listeners doesn't really help much since these events are often used to determine whether you should do something rather than not listening at all.

It does seem odd that it would have a significant effect. Perhaps it was only in benchmarks.

Someone actually hit this issue yesterday and asked about it. Another hazard is that people defensively clone in each component, leading to more memory thrash than if they could all share the same copy.

It might be worth revisiting. As you said, it makes more sense if more React features adopt pooling as a strategy.
 btw @jordwalke: cloning objects is necessary because of this existing pattern: https://github.com/facebook/react/blob/master/src/browser/ui/__tests__/ReactDOMComponent-test.js#L72
  Interestingly enough, we just had somebody work on almost exactly this on Friday internally (hi @dschafer!). I wasn't sure if we really wanted to support it in core since it's a bit specialized, but perhaps I was wrong...
 We also wanted this at KA two weeks ago.

For naming, I was thinking perhaps `map` or `dict`. Using `map` is nice in that it matches the ES6 Map, but perhaps also confusing for the same reason.
 :+1: 
One day ReactPropTypes will reach feature-parity with Haskell's type system (jk).
 The version we had internally used the name `dictOf` but I actually think `objectOf` is the best fit. It follows `arrayOf` and says `object` which matches the type we already have.

I don't have any code comments, so I'm going to go ahead and pull this in.
 IMO, using objects as dictionaries should be highly discouraged. You should be using an ES6 Map and we could add an mapOf function.
 @sebmarkbage no one is going to be able to use ES6 Map in a long time. I think that it's worth supporting objectOf in the meantime.
 @vjeux We'll require a shim of ES6 Map in React core soon anyway. So everyone will be able to use it.
 Internally merged. We can have both!
  For the MOVE_EXISTING update type, it would be nice if DOMChildrenOperations checked `data-reactid` and warned if the child it finds isn't the expected node.
 Well, perhaps we could still check against React's node cache. I've seen a few people get confused when trying to integrate React with an external sortable plugin because the plugin moves the nodes around and then React can't find the right ones.
  Fixes #579.

Useful for dropdowns and the like. Perhaps the "best" way to support this use case is to support a cohesive layers API, but this is a fairly common request and I think a reasonable way to support it.
 cc @yungsters 
 Yes, this can make sense for most events, which is why I'm a little bit reluctant. setCapture isn't really the same thing but I suppose I see the parallel.
 I feel like this is a special case of a more general "top level" event problem.
 Yeah, I don't have real ideas here so I'll just close this out.
  Last time I checked, `addons` is still a place for experimental features that might get rolled into the core. I think we should pull out `TestUtils` into `reactjs/ReactTestUtils`.
 @zpao has the autorisation to create a repo on github/reactjs. Otherwise, feel free to submit a PR.
 TestUtils currently has tight integration with React and can't quite be pulled out in sane way. We're moving towards that, but we're not there yet.

ReactWithAddons (separate build of React with `.addons`) is distributed with `bower install react` so it is accessible there.

Going to close this out until we have a better overall story about pulling addons out.
  This was a bug fixed in #1363 so a docs update shouldn't be necessary.
  This is a known bug; a few PRs are open with possible fixes, like #1590.
  I haven't heard anything like this, and I can't really help you debug without more information. Things to consider are: When the clicks fail to register, do other events on the page work? Do the clicks fail to work for an entire page load or do they work intermittently for a single page load?

Closing as this isn't really actionable. The email group or Stack Overflow would probably be a better place to get help unless you can make a small, reproducible test case showing a bug in React.
  As the underscore in front of its name suggests, `_lifeCycleState` is private to React and you should not use it in your own code.

There's no current way to get a reference to the mounted children instance, but you can use a ref if you wrap them in another div:

``` javascript
var Wrapper = React.createClass({
  showPopup: function() { alert(this.refs.childWrapper.getDOMNode()); },
  render: function() {
    return <div>
      <div ref="childWrapper">
        {this.props.children}
      </div>
      <button onClick={this.props.onUpdate}>update</button>
      <button onClick={this.showPopup}>show popup</button>
    </div>;
  }
});
```

Hope that helps.
 Sorry, there's no way right now to get a ref to children that are passed in. After #1373 it may be possible to do so using cloneWithProps.
 Ah yes, you're right on both counts.
  I would have said it's clearer to take it out of RESERVED_SPEC_KEYS but then you still need to special-case skipping it in the loop, so I think it's fine as you have it.

Yeah, unfortunately lint is a little too picky on some things and doesn't pass right now.
 Yup! This looks good to me now. :+1: 
 I'm not going to be around to bring this in and a bunch of the team is at JSConf or on vacation so we might not get this in for a couple days. I think it looks good though, thanks for jumping on it :)
 cc @yungsters. This got done the way you wanted :) @gaearon, we have a change around some of this code from @sebmarkbage that I'll sync out ASAP. So there will be a little bit of rebase work coming. Hope you're still up for it :)
 Yay! This l
 Dang it, GitHub on mobile is hard.

Yay! Looks good. Thanks for fixing this.
 @sebmarkbage can you take a look at this? It would be good to have deterministic behavior but I know there's still a bunch of changes happening around component creation‚Ä¶
 cc @leebyron too :)
 This is good. Let's get this in.
 LGTM
 @leebyron I think you merged this incorrectly. https://github.com/facebook/react/pull/1601/files#diff-2ee62d642502ef4bdc3a6b3d18cd4f99R464 specifically (should be `Constructor`). The internal version's fine. Not sure what happened here.

The `if (!spec)` code also didn't get checked in.
 @chenglou feel free to fix :wink: 
  @thaggie Oops -- can you sign the CLA at https://code.facebook.com/cla?
  There's no way to write arbitrary HTML (well, you can with the dangerouslySetInnerHTML property but then you're on your own); React builds all the HTML itself. Source code looks something like

```
render: function() {
  return <a href="hello">click me</a>;
}
```

which is statically transformed into

```
render: function() {
  return React.DOM.a({href: "hello"}, "click me");
}
```

which React then produces markup for using [this code](https://github.com/facebook/react/blob/00037b3/src/browser/ui/dom/DOMPropertyOperations.js#L82-L91), so there's never an opportunity for an unquoted attribute value to be made.
 I think stripping quotes can be something we look into after we nail text escaping first. I'm not too against "dirty" stuff if it's handled by a framework and done correctly.  (I would also want to profile the impact of an additional check or pattern match for every attribute.)

A lot of the discussion here has been ensuring that we generate **correct** HTML (where **correct** is the specifications listed above plus existing browser behavior). I think as a framework that makes it easy to set attribute values or text content using user input, we have an obligation to also ensure that the generated HTML is safe and secure ‚Äî not vulnerable to XSS.
 @zpao @yungsters If you agree with the refactoring/corrections done by this PR, a stopgap solution is that I reintroduce all the current rules and you can merge it as-is. If/when your security team clears the reduced set of rules, then we just reduce the rules in the escapers. Thoughts?
 @zpao @yungsters As I "discussed" in my previous comment, I have reverted this PR to use the current escaping rules instead. It now only removes the invalid escaping of attribute names and introduces a new `quoteAttributeValueForBrowser` (also still renames `escapeTextForBrowser`).

So it seems to me that there should be nothing controversial about this PR. It enables us to easily enable narrower escaping (or omitting quotes for simple values) in the future and improves the code in general.

Attaching the narrower, now reverted, escaping functions (for posterity):

```
var ESCAPE_LOOKUP = {
  '&': '&amp;',
  '>': '&gt;',
  '<': '&lt;'
};

var ESCAPE_REGEX = /[&><]/g;

function escaper(match) {
  return ESCAPE_LOOKUP[match];
}

/**
 * Escapes text content to prevent scripting attacks.
 *
 * @param {*} text Text value to escape.
 * @return {string} An escaped string.
 */
function escapeTextContentForBrowser(text) {
  return ('' + text).replace(ESCAPE_REGEX, escaper);
}
```

```
var ESCAPE_LOOKUP = {
  '&': '&amp;',
  '"': '&quot;'
};

var ESCAPE_REGEX = /[&"]/g;

function escaper(match) {
  return ESCAPE_LOOKUP[match];
}

/**
 * Escapes attribute value to prevent scripting attacks.
 *
 * @param {*} text Text value to escape.
 * @return {string} An escaped string.
 */
function quoteAttributeValueForBrowser(text) {
  return '"' + ('' + text).replace(ESCAPE_REGEX, escaper) + '"';
}
```
 @yungsters for review (though he's out so I might need to reping him in 2 weeks)
 ping @yungsters, this PR is currently limited to only "splitting escapeTextForBrowser into escapeTextContentForBrowser and quoteAttributeValueForBrowser" for making the code arguably neater and also fixing some related "mistakes" (like escaping attribute names). Any objections?
 Sorry for missing this. The changes look straightforward and reasonable to me. There are some extraneous changes included in the pull request. Can you remove those?

Otherwise, this looks good to me.
 @yungsters Sorry about the indentation, was caused by the rebase and I missed it, fixed. Which extraneous changes are you referring to, removal of `processAttributeNameAndPrefix`? I agree that it might make sense to put it in its own PR (but I kind of also think it makes sense to include it as it's affected, w/e :)), but are there any others?

**EDIT:** Ah, perhaps you're referring to the removal of (incorrectly) escaped attribute names too? It's kind of weird to do `escapeTextContentForBrowser(name) + '=' + quoteAttributeValueForBrowser(value)` as it's obviously incorrect from the naming of the functions... do you prefer to do it in a separate PR anyway? (It makes sense from a commit/history perspective)
 @yungsters I removed all "extraneous changes" that I could find, give me thumbs up and I'll merge this in and put up a separate PR for those changes/fixes.
 Note to self, need to rebase and update another added `escapeTextForBrowser`.
 My bad, I've rebased, fixed the require and license.
 Looks good to me.
  @jwalke @sebmarkbage 
 Yea that seems right. No rush since you can't get a handle on this anyway, right?
 Anything more need to be done here besides rebase? We apparently took that "no rush" to heart‚Ä¶
 Doubt it, but I'll run some tests and verify that nothing breaks.
 Rebased.
Test plan: `grunt test` and manually interacting with our application

**EDIT:** Might be worth sticking this in the changelog too, if someone for some reason was calling `getDOMNode()` on text instances in their tests. I don't see why they would and it would break in the future regardless (when the text node span is gone / spicyj's PR to change it from wrapping to prepending).
  If you haven't already, can you sign the CLA at https://code.facebook.com/cla? Thanks!
 Thanks!
  Note that after my change was made, @sebmarkbage made a change to cache the result of getDefaultProps across instances so now you can't refer to the current instance as `this` there. The proper solution is to do:

``` js
<p onMouseOver={this.handleMouseOver}>...</p>

handleMouseOver: function(e) {
  if (this.props.onMouseOver) {
    return this.props.onMouseOver(e);
  }
  // default behavior here
}
```
 In getDefaultProps you can't access `this` any more; it is called only once and refers to the class instead of the new instance being created. That is, if you have

```
var A = React.createClass({
  getDefaultProps: function() {
    console.log("getting default props!");
    return {width: 120};
  }
});
React.renderComponent(<A />, node1);
React.renderComponent(<A />, node2);
```

then the default props will be looked up only once and shared, instead of twice as they were before. There's no way to do what your original example is aiming for using only transferPropsTo. You have to specify the handler explicitly when rendering.
 It is a breaking change. That's why I'm telling you here and why it'll be mentioned prominently in the release notes. Mixins are generally not the preferred way to share functionality. I don't know you exact use case but you might be able to do something similar with composition like this:

``` js
var Highlight = React.createClass({
  highlight: function() {
  },
  unhighlight: function() {
  },
  render: function() {
    return (
      <div onMouseOver={this.highlight} onMouseOut={this.unhighlight}>
        {this.props.children}
      </div>
    );
  }
});

var Paragraph = React.createClass({
  render: function() {
    return (
      <Highlight>
        <p>Hello</p>
      </Highlight>
    );
  }
});
```
  For range inputs, we need to listen to both the input event and change event because as your research in #554 showed, not all browsers fire `change`. (We should not fire two events for a single change though even if we get both native events.)
 This patch isn't quite what we want ‚Äì we'd instead like onChange to fire whenever the value changes (which probably means listening to both native events). If you want to take this on feel free to open a new PR ‚Äì it'll probably take a bit of refactoring to ChangeEventPlugin.
  ReactMultiChild doesn't properly handle errors that are thrown when rendering children; if one child throws then the other children being updated at the same time can have inconsistent values stored in _renderedChildren which can cause problems with future updates. It's unclear the best way to solve this.
 It would be nice if one misbehaving component doesn't break the whole page. My guess is if we're careful about it we can make it happen. Not sure if any added try/finally calls would be a significant cost ‚Äì hopefully not!

(Though in the general case where DOM manipulation can throw and can throw asynchronously (think web workers!), error recovery might not always be possible.)
 Dupe of #2461.
  Several people came on the #jestjs irc asking why this.getDOMNode() returned null. The reason is that it was mounted by ReactTestUtils. Maybe we can add a warning in this case?
 Why does it return null if mounted by ReactTestUtils? That doesn't make sense to me.
 I think it's because the component got mocked, so they got an `undefined` return, and React treats that as an indication for placing an EmptyComponent. `getDOMNode` returns `null` in this case.
  Not sure what the deal with that is -- if you run into more problems, please report back.
  This strategy avoids a runtime check for every set (as opposed to using a mutation method).

Test Plan: Verify that changing className works on a div and a rect in latest Chrome, latest Firefox, IE9. Verify that the div works in IE8.
 cc @zpao @yungsters @sebmarkbage @syranide
  Right now we don't do this consistently, so you could have behavior that varies depending on where you put the `mixins` key in your class spec. That's not great.

Here's an example: http://jsfiddle.net/zpao/9sW7n/ (using master)

``` js
var Mixin = {
  componentDidMount: function() {
    console.log('Mixin');
  }
};

var CompA = React.createClass({
  mixins: [Mixin],
  componentDidMount: function() {
    console.log('CompA');
  },
  render: function() {
    return <span>A</span>;
  }
})

var CompB = React.createClass({
  componentDidMount: function() {
    console.log('CompB');
  },
  mixins: [Mixin],
  render: function() {
    return <span>B</span>;
  }
})
```

This outputs:

```
"Mixin"
"CompA"
"CompB"
"Mixin"
```

I think we should consistently behave like CompB (component, then mixin methods) but @yungsters disagrees. Any other opinions. @petehunt @sebmarkbage @jordwalke 

Potentially interested @gaearon (once we figure out which way we go)? This is relatively contained and testable but it does take you right into core.
 Doing mixins first is more intuitive to me because that's normally how people write the specs (in my experience, at least).
 @gaearon Go for it! Let me know if you have any questions; I'm happy to help.
  I believe this already happens; let me know if it doesn't.
 We do this already :) http://jsfiddle.net/zpao/2hRBc/
  We want this too :) @sebmarkbage has some plans here. One idea recently was this: https://github.com/reactjs/react-future/blob/master/01%20-%20Core/08%20-%20Transferring%20Props.js

It's a bit tricky because of transferPropsTo (or whatever we do instead) where you might have props that need to be passed on even if you don't consume them.

Eg `<FancyButton className="foo" color="blue" />` which renders `this.transferPropsTo(<button value={this.props.text} style={something with this.props.color} />`). You want the `className` to make it through even though you didn't explicitly say that `FancyButton` uses that.
 @syranide that's a tangential discussion but ultimately we skip propType checks in prod (they are slow to perform on every update). So we can't use invariant and have different runtime behavior in dev vs prod.
 I'm not 100% convinced that we can't use invariant() for prop types in dev only, especially given that the implementation here of warning() is not very aggressive.
 @slorber Since the set of props aren't necessarily very static at all it can't be resolved at compile-time, especially not if you consider that it must also verify the type of each prop.
 @slorber If you can't guarantee something at compile-time then you still have to pay the full cost at run-time (for DEV). I agree though that there may be some potential in doing the most basic checks of static types at compile-time, but I'm also doubtful that it would really be worth it... if you didn't even bother testing it once in DEV (which would throw an error in your face) before going PROD then you have bigger issues to deal with on your end.
  94c2f961fdcea18b318d6179f0022c1bf3656551 fixed this but unfortunately missed the 0.10 release.
  Because you're applying a function? I can see how `$map` would make sense though.

(Closing since this now exists!)
  Cool, looks great!
  I think having the ability to do a merge or set with the Immutability Helpers if the target is undefined would be a nice addition.  I can open a PR if this sounds reasonable.
 Sorry, how does this differ from merge? A code example would be helpful.
 Heyo, it's not.  Misread the invariant.  Thanks!
 Oh man, what a day.  I did not misread the invariant, I just need more caffeine.  Here's an example of what I'm talking about.

``` javascript
var coolObj = {idToObjMap: {1: {someVal: true}}};
// This works
React.addons.update(coolObj, {idToObjMap: {1: {$merge: {someVal: false}}}});
// This doesn't, but I want it to work like $set
React.addons.update(coolObj, {idToObjMap: {2: {$merge: {someVal: false}}}});
```

I was thinking of adding a `$mergeSet` directive.  Thoughts?
 If I understand correctly, you want something like:

``` javascript
React.addons.update(coolObj, {idToObjMap: $mergeDeep: {1: {someVal: false}}});
```

Is that right?
 Yes, that would be one way to get the same behavior.  I was thinking more simply like:

``` javascript
var coolObj = {idToObjMap: {1: {someVal: true}}};
if (coolObj.idToObjMap[2]) {
  // Update the existing object with these properties
  React.addons.update(coolObj, {idToObjMap: {2: {$merge: {someVal: false}}}});
else {
  // Object doesn't exist, so set it
  React.addons.update(coolObj, {idToObjMap: {2: {$set: {someVal: false}}}});
}
```

Replaced as:

``` javascript
var coolObj = {idToObjMap: {1: {someVal: true}}};
// Update or set the object with these properties
React.addons.update(coolObj, {idToObjMap: {2: {$mergeSet: {someVal: false}}}});
```

But `$mergeDeep` would handle the use case as well and might be a bit more flexible.
 ^ related: https://github.com/facebook/react/issues/984#issuecomment-33865767
 Edit: here's Clojure's [`merge-with`](https://clojuredocs.org/clojure.core/merge-with). Deep merging two structurally dissimilar collections is weird to begin with, but otherwise it can work fine.

@petehunt 
 At this point `React.addons.update` is in maintenance mode and unlikely to receive future feature updates. It‚Äôs best to use a dedicated third-party NPM module for this, e.g. Lodash, https://github.com/rtfeldman/seamless-immutable, https://github.com/substantial/updeep, and/or others.
  #1363 fixes this.
 It was merged! This should work now in master.
  The spacing here looks a little wonky.

![image](https://cloud.githubusercontent.com/assets/6820/3044955/7e1b3918-e117-11e3-890e-9d4b6bcb6e7a.png)
 Thanks!
  Wouldn't `existingChecksum` be `"0"` and thus be truthy? I don't know that there's any advantage to removing the attribute.
 I like the initiative :) But meh. Let's come back to it if we go with that clean DOM thing.
  No idea what you're saying but I trust ya! :)
  @fisherwebdev Can you review?
 Before #1480, it looks like `waitFor([7, 3])` would return `[_promises[0], _promises[1]]`. With the current committed code it returns `[_promises[3], _promises[7]]` and with my change here it should just return `[_promises[7], _promises[3]]`.
 I'll take that as approval and just merge it myself. :)
  promiseIndexes is a list of indexes into _promises, so I believe this is correct as-is.
 I think @spicyj is right but since that code isn't actually used, I'm not sure... @fisherwebdev?
 I think #1575 makes this logic clearer.
  `dx` and `dy` were added in #1306.
 It's available on npm:

https://www.npmjs.org/package/jsx_whitespace_transformer
  Oh man =D
For 1: possibility of removing `renderToStaticMarkup`, which is only there because of dangling checksum and react-id from `renderComponentToString`. By removing react-id I think there's enough benefit to remove the `renderToStaticMarkup` API altogether.
 > `string renderComponentToString(ReactComponent component, boolean noChecksum)`

That was actually the initial API for `renderToStaticMarkup`, but boolean args wasn't encouraged so I changed it. I was more interested in killing the API altogether.
 I'm pretty sure I want to solve this higher up. At any rate, it should be a separate diff.
 Pushed another commit that uses `Map` when available instead of adding a property to the DOM nodes. Measurably faster for IE11, couldn't measure any difference for Chrome (with ES6).
 Interesting stuff. I do like the simplicity of this. I wonder if there's a way we can bail out quickly (sort of a shouldComponentUpdate thing) for subtrees we know that we won't need to touch.

We should also evaluate just using document.createElement instead of batch generation, or a mix depending on heuristics/browser.
 @sebmarkbage I believe @petehunt experimented a bit with cloning bare subtrees and reusing them. I think he managed to get some positive/interesting results (lists of similar/identical components are ideal and common).

I'm not sure what you mean about "bail out quickly", the latest commit in this PR currently implements the same lazy approach that React already uses (some earlier commit implements the non-lazy approach). There's only one practical disadvantage and it's that events originating on non-React nodes must always traverse up to the nearest React component or the document element (for the lazy approach). However as I mention/detail in the OP, the non-lazy approach is perhaps only 1-3% slower in the practical worst-case and brings a lot of other potentially interesting benefits, so that is worth considering as well IMHO (I haven't really done extensive benchmarking, but I really don't think I'm far off).

While I got you on the hook, #1569 is that something you may have fixed in your "rumored" refactor?
 It's a pain to rebase these things and risky to make the switch immediately. I think we need feature flags for stuff like this. Probably build flags that can be stripped out.

Flagging as needing revision so that we can add build flags in a different PR and then this can go in under a new build flag.
 @sebmarkbage I'm not expecting this to be merged any time soon, however, when `_parentInstance` makes its official appearance... It should then be quite simple to implement the full range of alternatives between today and no react ID (even behind flags I'm quite confident), some of which are far "less controversial" than this. But until there's a `_parentInstance` (one way or another) this is a no-go.
 Hmm, pondering this some more, I'm sure I can make this happen without `_parentInstance` quite easily by simply relying on `ReactInstanceHandles` instead. It won't be as superficially neat, but it should allow us to test the full range of alternatives in relative isolation; `data-react` and no React ID, including lazy and non-lazy traversal.

@sebmarkbage How does that sound to you?
 I went ahead and implemented it using `ReactInstanceHandles` for fun, it worked out really quite well, but the current core architecture is not conducive keeping it lazy (VDOM/DOM are inconsistent when ReactDOMIDOperations calls getNode).

But immediat traversal is possible as-is and easy and I'm quite sure is better than what we have today (as evidenced by previous perf tests), returning to lazy traversal is possible down the line... but I'm personally quite convinced that the benefits of immediate traversal outweigh the supposedly minor traverse overhead (which is also easier to hide than stuttering animation).

The implementation is actually quite isolated but I imagine you guys don't want to go ahead with until you can test performance with confidence (including lazy traversal).
 Most of the useful stuff in this PR has already been dissected into other PRs and what's left isn't very useful.
 @gaearon There's a PR (can't find it) for adding internal parent references which is necessary for the event system to work without `data-reactid` and there is one or two bugs in React which conflicts (but they can be workaround if they are willing). There is one alternative method that can be implemented without parent references, but... they expressed a desire to extensively benchmark and compare the various approaches before moving ahead.

As for server-side rendering without `data-reactid`, reconstructing `data-reactid` client-side is doable today and shouldn't come at a significant cost (and certainly favorable if you can drop `data-reactid` from the server-side generated markup). I've brought this up before but no one really seemed to care much so I never moved ahead with it.
 @callmevlad Curious: Why do you care?
 Cool, thanks for the context. Webflow looks sweet. :)
 @callmevlad What can be done somewhat non-invasively (i.e. an easy to maintain fork) at the moment is the "immediate traversal" version of this PR. There are two alternatives:
1. The very simplest being to simply immediately traverse any rendered nodes, copy `data-reactid` into `node.reactid`, remove `data-reactid` and update `internalGetID` to read from `node.reactid` instead (more or less). You still have to ship `data-reactid` with server-side markup though.
2. Again, immediately traverse any rendered nodes but reconstruct `data-reactid` (quite easy too) instead and store it in `node.reactid`. The rest is same as above, but this doesn't require you to ship `data-reactid` with the server-side markup.

I can't imagine the devs being OK with having this "hack" in the release version so it would have to be in a separate fork. But as I said earlier I could imagine the server-side part of alternative 2 being shipped though (but not my call) which would make the client-side fork near trivial. I don't imagine the performance impact of this being significant.

For reference, most of the changes in this PR is because of the lazy traversal and updated tests. It's possible I overlooked something minor above, but this PR was functional so it's definitely doable.
 @natew Good news #5190 #5205
 It will be a part of 0.15
  Yeah, I rewrote all of this.
  Looks good to me.
 Or perhaps add it to ReactBrowserComponentMixin? Not sure.
 react-art also uses it: https://github.com/facebook/react-art/blob/c719f03/src/ReactART.js#L184-L189.
 Btw, rebased this too.

Test plan: `grunt test` and manually interacting with our application
 @sebmarkbage Rewrote to fix conflicts, it's still the same basically, but... I chose to use `ReactComponentBrowserEnvironment.unmountIDFromEnvironment` because that's what `ReactDOMTextComponent` is using, is that correct or should both be using `ReactMount.purgeID` directly?

**EDIT:** I've also ran this PR against our app and I have witnessed no stale nodes in the nodeCache, except for #2988 which is not caused by this PR.

~~**Warning**, it seems React's focus/selection restoration it repopulating the cache with the last focused nodes after being purged (when unmounted). I'm not sure if it's happening in stable as well, but it's happening when this PR is applied. Will have to look into that before this can be merged.~~ It's happening in stable as well.
  Can you log the this.type.displayName too and something to distinguish the two renderComponent calls?
  @syranide
 "A custom data attribute is an attribute in no namespace whose name starts with the string "data-", has at least one character after the hyphen, is XML-compatible, and contains no uppercase ASCII letters."

http://www.w3.org/html/wg/drafts/html/master/dom.html#custom-data-attribute
 I wasn't contradicting this PR.
 Browsers seem to understand it. But... what's the use case? (and that may be legal on a technicality, there is 1 character after the hyphen).

Firefox and Chrome at least even parse `<div data-foo="1" data--="2">test</div>`.dataset to be `{-: '2', foo: '1'}`
 I think the `:` in there isn't legal though

> Attribute names are said to be XML-compatible if they match the Name production defined in XML and they contain no ":" (U+003A) characters.
 How do old IEs behave?
 Going to close this since I don't think there's a great use case here. If there is disagreement please comment and I'll reopen.
  I believe this is intended; context follows the "owner" hierarchy, meaning that B does not get A's context because A didn't create B.
  cc @paulshen @yungsters 
 I believe this breaks the onChange event on `<input type="text">`. Did you test it?
 The `change` event only fires on text inputs on blur (if the value has changed): http://jsfiddle.net/yungsters/FYBM2/
 @eddhannay It's intentional that onChange fires on every change; this is one place React intentionally deviates from the DOM spec.
 @eddhannay (That is, it's basically a polyfilled onInput that works for non-text inputs as well like checkboxes. See http://benalpert.com/2013/06/18/a-near-perfect-oninput-shim-for-ie-8-and-9.html for some more info about the implementation.)
 Going to close this out for now, but if you could change the plugin to listen to both input and change on range inputs (but leave events for other inputs the same), please do open a new pull request!
  We now forbid calling setState or forceUpdate if any component's render function is higher in the stack, not just the component you're trying to update. (We do this already now for React.renderComponent and React.unmountComponentAtNode.)

This also has the advantage that we can now remove CompositeLifeCycle.RECEIVING_STATE, making _compositeLifeCycleState easier to reason about (not to mention that RECEIVING_STATE was a confusing name) and making it possible to remove a try/finally from the render path which might help with perf.
  cf. #1376.

This is useful for SVG. Dynamically adding and removing `<title>` elements in SVG still won't work properly because of getMarkupWrap but this at least lets you include it in initial render and then unmount the entire `<svg>` without problems.
  There aren't any tests for this, no. It would be cool to load the scripts in parallel but run them in order, but this is fine too.
 @syranide `tick` is executed in the onreadystatechange callback.
 @nhunzaker Thanks!
 @nhunzaker Looks pretty reasonable at a first glance. It might be nice to run scripts as soon as they're loaded if all the scripts before them have also loaded (but not if it'd add a lot of code complexity). Either way, could you open a PR with this when you're ready so I remember to look at it?

Thanks!
 You shouldn't really use JSXTransformer for anythimg serious at all. Use ./jsx --watch (super simple) or browserify/webpack instead.
 @fleaflicker Not currently, though it's possible we could add something for that if you open a separate issue, but if you load your second (pure-JS) file with JSXTransformer as well (using `type="text/jsx"`) then it'll be run after the first one loads.
  Do all of these style attributes really add a lot? I ask this because we moved away from these things in HTML years ago and stuck them in `style`. `font-family` is pretty crazy being an element, an attribute, and on style. I don't work with SVG so I'm in the dark here.
 Thanks!
  I'm not sure this works correctly with chained dependencies. See my test case in #1540 -- I wrote an implementation similar to this and it didn't pass.
 cc @fisherwebdev
  Depends on/includes #1758.

cf. #1373

This particular implementation doesn't attempt to do anything smart about async resolution -- `.then` always runs one of its arguments immediately. It can be used in any situation that refs can currently be used (and can also be used without an owner, which is a plus).

We can enhance this later to do something more intelligent when using refs during updates.

cc @jordwalke @sebmarkbage
 I think so. You also wanted some test cases around cloneWithProps and transferPropsTo. Do you want to support having more than one ref? Right now cloneWithProps just warns you if you clone a component with a (string) ref.
 This doesn't work on initial render because of how the batching currently works and also doesn't work if you access it outside of a lifecycle method, like in an event handler. Not sure how serious a problem that is for you @jordwalke.
 Let's call `setImmediate` something else (such as `asap`). `setImmediate` doesn't do exactly what we want here and probably won't be standardized. Something else will be standardized with a different name, so the upgrade path to a real polyfill is confusing.

Also, I think that we should make `_owner` + string an API of `createElement` that creates a first-class ref behind the scene that updates `this.refs`. That way we can deprecate the old style in the core.

I still hate this API (even though I originally came up with it) but I don't have a better idea for now.
  Thanks :)
  Thanks!
  With this, tags that start with a lowercase letter are assumed to be built-in and have React.DOM prepended; uppercase tags are assumed to be user-defined and are left as-is.

Not sure if we want to do this but perhaps we do!
 I'm a big fan of this idea.
 I personally am not a big fan of this idea. It's not entirely uncommon to pass a component type around and then construct it later. (`var comp = this.props.component; do something with <comp ...>`)
 I like this. I think that it's the only sane way to do this. I think that @jeffmo is the only one against it at this point. Not sure how to unblock.

Web components are unrelated since they're not ambiguous (requires a dash).
 @sebmarkbage Here you go :hammer: hehe. On a more serious note, I generally agree with @jeffmo on this, but it's a _very_ neat solution to a very tricky problem unless we're going a different route (i.e. explicitly "wrap" each web-component as a react-component).
 We agreed today that we'll do this; I'll rebase when I get a chance.
 :+1: 
 Are we going to do this before 0.12?

Edit: ah, saw the milestone.
 Yes
 @sebmarkbage did this in c4658c1728b39c452a86f371ecb1c51874456107.
 Removing "accepted" so my bookmarked search for things I need to merge internally works right. (and just found out I can add `is:merged` and that would have worked too... I'm learning)
  Couple things:
1. `patternUnits` is SVG so should go in https://github.com/facebook/react/blob/master/src/browser/ui/dom/SVGDOMPropertyConfig.js
2. Since it's camelCased we'll need the extra map in DOMAttributeNames as well.
3. Please test when you've done that to ensure it works. Run `grunt build` and get a build of React that you can use (then make sure a change in value gets reflected).
 We don't actually have unit tests for these properties (one day...), so nothing to worry about there. I'm pulling in this and several other SVG related PRs today, so I'll merge this soon.
 Thanks!
  Yeah, quoting as a plain JS string is the way to do it. Let us know if this poses a problem for you somehow.
 Related facebook/jsx#28
  You can use JavaScript comments if you wrap the comment itself in curly braces:

```
<div>
   {/* In JSX you can escape with the { and } characters. */}
   {this.state.value}
</div>
```
  .push() can take multiple arguments, which might be faster.
 @jordwalke What do you think of this?
 Note to self, assigning to an index is considerably faster than push.
 I had a diff that did this previously. It's tricky because if you use the optimizations right, then string concatenation can actually be faster.

I haven't looked at this closely enough to know but I suspect you might have some problems coordinating this with React ART.

I definitely think that we'll probably do something like this but I think we need a bigger refactoring around the contract of the reconciler for things like React ART to plug into. Might not be worth while just doing this on it's own.
 @sebmarkbage Definitely, as the tests shows (not that I really trust them) there's probably nothing here worth bending backwards over either. If you overdo it just a little it actually becomes slower. This was just an FYI really, feel free to close.
  Closing as a dupe of #1326.
 No problem, thanks for reporting!
  I believe this should pass with a bug-free dispatcher, though the async behavior is a little unclear to me.

cc @fisherwebdev
  This really only adds support for tags in our knownTags list. If we want
to support SVG fully we'll need to do that OR we do like we do for
styles and force camelCase.

Tested with `<font-face/>` which produces `React.DOM["font-face"]`. See #938 for even more.
  If you upgrade npm, this error should go away.
  Fixes #1169, fixes #238.

This is a more robust way of fixing what MobileSafariClickPlugin previously tried to. Now even if you don't want anything to do with touch events, click events still work properly.

Test Plan: Added a click handler to an `<img />` element and triggered it in the iOS simulator -- it didn't execute before.

cc @yungsters
 Very nice... I like this a lot more.
 Didn't your analysis conclude that walking the tree is already fast and so this should be fine as is?
 Yeah, we should merge this for now -- if we decide to change how event handlers are done in general later then we can do that.
 I believe that the reason this is required is simply so that Safari can show the active style on the right element; you want each "distinct" clickable element to highlight separately, but you don't want subelements to get highlighted by themselves if they go to the same place as their siblings.

I can only assume that `cursor: pointer` would have the same overhead and I prefer this solution as it doesn't require browser sniffing or otherwise messing with CSS.
 No, you only want to add `onclick=""` to the element that has the handler.
  Closing in favor of #1657.
  Thanks -- closing as a dupe of #1376.
 No problem, thanks for reporting.
  This happens because React.DOM.input is secretly a composite component instead of a pure DOM component like div and span is. I'm unsure what the correct behavior here is.

@benjamn @sebmarkbage opinions?
 We need to unify the testing toolchain to not consider composite and native components differently. With fragment support they would essentially become the same.

I'm not sure if we'll actually have React.DOM.input as a way to compare function equality. I think that they will probably become strings instead and then the composite version would be hidden behind the string representation.

This becomes tricky for these cases where the internals are exposed and it automatically drills down. It might drill through the string base descriptor into the composite. We will likely try to avoid this style of deep testing and move towards shallow testing of the output of a single level.
 I think this bug is no longer applicable (I suppose we can re-open if it is).  `input` is not secretly a composite component anymore, and we now have shallow rendering of the output at a single level.
  It's expected that this doesn't work currently; closing as a dupe of #1445.
 Good idea, done in c913c95.
  If we don't error here, we end up with a confusing error later on in this.getDOMNode() where ReactMount doesn't have the proper container registered in its object.
 @sebmarkbage Let me know if this is crazy. Currently if you have two copies of React and do:

```
var descriptor = React1.DOM.div();
var component = React2.renderComponent(descriptor, el);
component.getDOMNode();
```

then `component` believes it's in the React1 universe, so `component.getDOMNode()` calls `ReactMount1.findReactNodeByID`, which can't find the element because `ReactMount2` is the one keeping track of the container.

I know you're planning to make descriptors not depend on React itself but in the current system, this seems to be a problem. I assume some methods other than getDOMNode have the same problem.
 (Someone ran into this today when trying out Jest and I've seen it a couple times in the past with tests too.)
 @sebmarkbage Can you review? Adding [?w=1](https://github.com/facebook/react/pull/1531/files?w=1) to ignore whitespace may help.
 :thumbsup: 
 What if the two versions of React are different and incompatible? In general it's unsafe to rely on globals like that. It should be safe to load multiple copies of React on a page, provided you don't mix components between them (imagine an ad or other embedded widget using React). 
 A coworker just ran into a similar problem when mixing React versions with the error:

> Uncaught TypeError: Can't add property _mountIndex, object is not extensible
 Note to @zpao: reverted internally. Back to waiting for acceptance.

Edit: re-merged. 
  We were lazy before and just used sync XHR to make sure multiple scripts were still executed in the right order. However I'm not getting a warning in my console (Firefox Nightly) that says sync XHR is deprecated.

> Synchronous XMLHttpRequest on the main thread is deprecated because of its detrimental effects to the end user's experience. For more help http://xhr.spec.whatwg.org/

Let's be preemptive and just build in the minimal work here to switch to async xhr and ensure we still process scripts in order.
 With the JSX transformer, scripts are already not loaded at `onload` I think. We were using setTimeout 0 in a few places in our code at KA because of this (now integrated properly with our build process so it's not necessary).
 Yea, it's already broken and there's nothing we could do about it really so we're no worse off.
 Fixes by #1558.
  Yea, that's labeled weirdly, you should be pasting HTML into the left.

But we should probably leave case intact for unrecognized attributes (cc @Daniel15)
 Moving this issue to https://github.com/reactjs/react-magic since the HTMLToJSX converter now lives entirely in that project.
  Can be run with `node_modules/.bin/jest` for now; didn't want to disturb the grunt setup.

Right now one test fails with:

```
FAIL  browser/ui/__tests__/ReactDOMComponent-test.js (1.423s)
‚óè ReactDOMComponent ‚Ä∫ updateDOM ‚Ä∫ it should update styles when mutating style object
  - Expected: '0' toEqual: '0.5'
        at Spec.<anonymous> (src/browser/ui/__tests__/ReactDOMComponent-test.js:99:33)
```

which I can only assume is a jsdom problem -- no other asserts fail.
 @jeffmo @benjamn this doesn't fail internally so any idea what's up? different jsdom versions?
 :thumbsup: do it. and we'll figure out grunt integration later
  Does it fail?

cc @azich
 Addressed by #1820
  Pushed with the rebase & small tweak. Thanks a lot and sorry again for the delay!
  I'm going to shoot down `text/jsxharmony` - I would like to stick to a single fake mimetype and add options in some other way. I agree that adding a `data-options` attr is verbose, but really, the use case we're solving here is for toys/mockups, not production code, so I don't feel strongly about how verbose we make this.

`text/jsx+harmony` seems like a bad route - as @syranide mentioned it's for combined types (or really additional underlying datatype).

`text/jsx;harmony` seems ok, though it's not clear if parameters can have naked values or if they need an explicit value, so `text/jsx;harmony=true` seems like the safest bet.
 Nah, let's do `text/jsx;harmony=true`
 Could you rebase? #1558 made some other changes in there so this doesn't apply cleanly anymore.
 Merged! Thanks @remixz and apologies for the delay.

And yes @syranide, _technically_ we should have been `text/x-jsx` but ugh :)
  In cases where you need the container, I think it makes the most sense to just use createElement as now; we can use renderIntoDocument for the cases where the container isn't needed. If you end up needing another step to get the node you don't gain any benefit from renderIntoDocument and we definitely shouldn't use _rootNodeID in all the tests for this.
 What @spicyj said :) Thanks for taking this on @danielschonfeld!
 @danielschonfeld Any chance you can make these updates? No problem if you don't have time but if not I'll close this out.
 @danielschonfeld No problem. I'll close this out for now so it's not sitting around but if you do have time please push an update and let me know; I'm happy to reopen it.
  Closing as context will likely solve this problem once it's done.
  cc @salier 
 Nope, we can't guard against this directly.

A contentEditable may have React children, but it's the owner component's responsibility to maintain them rather than allowing purely native DOM manipulation. This is valid in React and possible to do without basing state purely on the DOM, though it is difficult.

It may make sense to have a custom attribute, separate from `contentEditable`, that indicates whether a rendered node is a React-controlled contentEditable. But we can't do a blanket guard against it.
 Yeah, I think it's probably fine to leave it alone. Alternatively, it might be good to have a more specific warning for contentEditables, as the existing error could be considered pretty cryptic and confusing if native contentEditable behavior isn't clear.
 Yep, that sounds good to me.
 @salier can you make sure the wording is good and we can get this finished up :)
  react-page is not supported because no one has time to maintain it ‚Äì it adds a decent bit of live reloading tech, etc. which is not built into React which you either shouldn't need or can build yourself (it's not even that hard to do with webpack).

React.renderComponentToString is supported for server rendering and we have no plans to deprecate it. Server rendering is an important feature for React.
 There's a handful of flux projects with examples, several of which work on the server. We're probably not going to add anything into the React website itself.
  I've also encountered this in the past and added a setTimeout to fix:

https://github.com/Khan/khan-exercises/blob/f73bb42c01d105937b149073893bedfdb4674c91/khan-exercise.js#L1206-L1213

I don't have repro steps handy though.
 cc @salier & @joshduck who might have some more insight into focus.
 @bmeck If I'm reading the code correctly, that is a different issue and one that we can't solve as there is no DOM event to signal when an element has become visible.
 The problem remains but I'm adding the needs-revision label because this can't go in as-is.
 Not exactly sure what @sebmarkbage is referring to, but I imagine we would want to use `requestAnimationFrame` (or vendor prefixed) when available to make it instantaneous.
 I'll go ahead and :+1: this, it is has started occurring consistently across our entire app in Chrome (I'm confident I've made no related change). I use this PR as a workaround for now and it seems to work well.
 @kramerc Thinking about it briefly, I imagine we want to guarantee that only one `setTimeout` is active at any one time. I haven't actually battle tested it, but my idea of using:

`node.focus(); if (node.ownerDocument.activeElement !== node) { ... defer ... }`

...is.also a possibility where we might get the best of both worlds (although consistent behavior/timing across browsers might be preferable).
 I don't think this plugin even exists anymore.  Regardless, merge conflicts and no comments in six months, closing.
  Yea, would definitely need to make this configurable before we could take it.
 I know @andreypopp has a fork of eslint that works with JSX; if it can be packaged up maybe it's worth just suggesting people use that so we don't need to worry about the quoting debate:

https://github.com/andreypopp/eslint/tree/jsx
 We aren't going to merge this in its current form at least, so I'm closing this out for now.
  :+1: 
 I was going to say you might check `console` too but I guess you won't be able to make much of a warning if it's absent.
 Seems legit, gonna pull this in
  Instead of checking `innerHTML.__html === undefined`, maybe it makes sense to check `typeof innerHTML === "string"`?
 I think if we're going to do this we should just break it now rather than continue to support `__html`. This fix is pretty easy to automatically update as well so I don't think we need to do a deprecation and then removal. @zpao?
 +1 for dropping `__html` if it's feasible from Facebook's end.
 I'm down. Will be a bit of work to update internally but it's worth it. I think we should probably support both for a release though.
 `__html` does provide another safe-guard. It allows you to have whitelisted functions that passed a blessed response through indirections.

``` javascript
function frameworkLevelBlessedFunction(name) {
  return { __html: 'I\'m sure this is safe, ' + encode(name) + '!' };
}
```

Now you can lint every other caller...

``` javascript
function indirection(data) {
  return frameworkLevelBlessedFunction(data.name);
}
```

and components...

``` javascript
render() {
  return <div dangerouslySetInnerHTML={indirection(this.props.data)} />;
}
```

to make sure that none of them declare `__html` but it's still safe for everyone to use `dangerouslySetInnerHTML` which doesn't have to be lint:ed against. It's really not dangerous. The dangerous part is actually the `__html` property.

However, you ALWAYS have to lint against people setting `innerHTML` on anything.

I would be fine with allowing `innerHTML` accepting a string and we will just forbid the use of any `innerHTML` identifier at FB.
 That logic makes sense to me. I'm in favor of keeping the current situation because it's too hard for most people to set up lint rules to forbid innerHTML and people will end up just writing insecure code instead.
 @sebmarkbage Interesting perspective, but if `__html` is the "safe-guard" (I'm inclined to agree that it's a good thing now), then `dangerouslySetInnerHTML` is quite redundant no? Anyway, it has always bugged me that it's called dangerously_Set_InnerHTML, no other property is named like that. I would assume that proper naming should be `dangerousInnerHTML`, `unsafeInnerHTML` or w/e.
 @syranide agreed. It's misnamed. It always bothered me as well. I'd be happy to change the name. What do you think @zpao ?
 Is there a pattern for this in other frameworks / libraries / languages to indicate it's unsafe?

"dangerous" is slightly more annoying to type than "unsafe", so let's do that.

`dangerousInnerHTML={__html: ""}`

(We should probably also deprecate nicely with a warning and letting both work for a release)
 @zpao I personally prefer the sound of `dangerous` myself, unsafe sounds relatively kind of safe, whereas `innerHTML` really is bite-your-face-off dangerous. As for other frameworks, I believe .NET uses "unsafe" for C++ calls.

PS. We should also document the purpose of `{__html: ''}`, when explained correctly it makes a ton of sense. Writing `dangerousInnerHTML={{__html: ''}}` doesn't make as much sense, but `dangerousInnerHTML={wrappedSafeString}` does.
 Follow-up; perhaps there should be a `dangerousDefaultInnerHTML` or such too (`default` as that's what we use elsewhere).
 I split the naming discussion into #2134

So this PR should probably be closed. I'm leaving it open for now until another issue/PR is opened to address the "lack of documented justification" for `{__html: ...}`. Feel free to close it otherwise.

 **EDIT:** I meant "lack of documented justification", not "lack of justification" :).
 Not sure what you mean about a new issue/PR. Are there still concerns about it's justification?
 @sebmarkbage Not in my opinion, but AFAIK the justification is not documented anywhere.
 Good point. Let's add an explanation to the docs before closing this.

> On Sep 4, 2014, at 1:06 AM, Andreas Svensson notifications@github.com wrote:
> 
> @sebmarkbage Not in my opinion, but AFAIK the justification is not documented anywhere.
> 
> ‚Äî
> Reply to this email directly or view it on GitHub.
 Opened #2256 for tracking documentation of justification and #2257 for renaming of `dangerouslySetInnerHTML`, closing this.
  @RReverser Hmm? Not sure if I understand, parsing XHTMLEntities in esprima is an issue as information is lost for React/JSX. Sure, esprima could _still_ parse XHTMLEntities, but we wouldn't use them anyway for React/JSX so it makes no sense for esprima to keep doing it. Or?
 @RReverser Ah perhaps, I don't disagree, but AFAIK React/JSX would never want to use the decoded value (it also seems like a bad idea to mix use of "decode raw" and "value as-is"), so what use is it there in keeping it? Are there other projects that depend on it? That's where I'm confused :)
 @RReverser Right, it currently uses the decoded value everywhere, but I see no reason to keep doing it if we have to do _some_ of the decoding in JSX anyway, there will be no benefit to reading the decoded value instead of always decoding the raw value. So we would have to maintain two separate decoding implementations in separate projects for no actual benefit?
 @RReverser Sure, we can count/cut/etc, but that seems super fragile and just decoding in JSX seems like the logical choice.

Quite a while since I last looked/touched that code, but IIRC there's quite a number of things about attributes that are kind of weird. But no, attributes values definitely shouldn't be trimmed, perhaps it's a multi-line thing? (JSX attribute strings can be multiline I think ... which is really weird)
 > I'll still disagree since any string decoding feels like parser's task that should not be moved out from it. In the worst case, I'd rather expose method for entity decoding from parser and reuse it in React, but definitely not remove it from parser itself.

I'm inclined to agree, but I think there's a slight subtlety to decoding XHTMLEntities vs strings in the parser. Perhaps what should be done is to move some of the JSX inline text trimming to esprima... then esprima becomes a "true" XHTML parser and it suddenly makes sense, currently it's only a JS parser IMO (it expects JSX to process the values) and as such decoding XHTMLEntities doesn't make sense to me (because information is lost).

Not sure if I'm making any sense, but I think decoding should move from esprima to JSX **or** trimming should move from JSX to esprima (so that JSX doesn't doesn't do any "interpretation/processing" of the value). The latter probably makes a lot more sense the more I think about it, as that's how attributes are handled.

> Yeah, I think we should better figure out reasons for existing of this feature before arguing about solutions for bug introduced by it.

The trimming I'm referring to applies to inline text, not attribute values. Or did I misunderstand?
 > Personally I like this idea.

Awesome, I think it makes a lot more sense than this PR the more I think about, and it seems like we both agree :+1:

> Maybe it's desired behavior, but anyway I don't see benefits from it.

Ah yes, that rings a bell. IIRC most of the attribute code uses non-attribute specific helpers, which kind of works, but for attributes has many small weird edge-cases. So unless @jeffmo thinks otherwise, it seems to me that attributes really should use their own logic where it makes sense.
 @RReverser Yep, :+1: for facebook/esprima#32 and it seems there's a pretty straight-forward goal, closing :)
 Hmm, quickly thinking about this again, I'm not sure how one would go about doing this. It's straight-forward enough to move the trimming to the parser, but React/JSX should preserve line-numbers and necessary information is again lost in translation... or?

...or, perhaps we simply don't care about 1:1 mapping with inline text and just replicate the number of newlines. Practically everything is the same, but lose a bit of familiarity when looking at the JSX output.
 @RReverser but `loc` only gives the starting line, not where each individual newline is in the "value". Unless we generate an `XJSText` for every line I suppose... hmm.
 @RReverser Yeah, that's an intended feature today AFAIK.
  Yeah I think only checking for undefined makes the most sense here.
 Looks pretty good, a few inline comments -- thanks for working on this. :) 
 No, console.warn isn't stripped in `__DEV__` currently (see vendor/constants.js). Let's leave the check dev-only (and we don't have dev-only invariants because we want the dev and prod behavior to match exactly).
 No, leave it as is. `console.warn` isn't stripped. We'll do it like this for now, and maybe be more aggressive if we see it become a larger issue.
 Thanks and sorry for the delay!
  That's cool! I really hate having that whitelisted list.
 Proper implementation #2141, closing.
  Can we just cast both to strings? This more obviously mirrors the way we set things and avoids running into problems with `0 == false`.
 Right, not everything is stringy. I guess it's hard to know how things get cast unless we pay special attention when writing it initially, which sounds like a pain.
 We know the ones that have boolean/numeric values and I think those come out of the DOM correctly so I would guess that we should be able to take advantage of that knowledge.
 :+1:
 Fixed comments.
 Interestingly the fiddle works just fine in Firefox :wink: 
 Of course it does.
 @zpao Interesting, I'm assuming FF just internally checks prev===next.
  @syranide, can you rebase? Based on @sebmarkbage adding that tag, I guess he's ready for this.
 @zpao Will do, tomorrow.
 @zpao Rebased. **However!**

`scrollTop` and `scrollLeft` does not have associated attributes #2140 (are there other property-only names we support?), I'm not 100% sure why they're exposed. I could add a `HAS_NO_ATTRIBUTE` flag to take care of it, but what is the expected behavior? Set them to null or leave them as-is?
 Sorry, what's wrong with DOMAttributeNames as it is now?
 @spicyj Nothing, I had missed that it's automatically filled with lower-cased names. :)
 "Kind of waiting" for #2202
 @zpao Apart from breaking (the already broken) `scrollLeft` and `scrollTop` (#2202) and triggering broken `select`-behavior (#2241) this PR should be good to go. But we probably want to wait for #2241 as a test otherwise fails.

```
document.body.innerHTML = '<form enctype="multipart/form-data">';
document.body.firstChild.removeAttribute('enctype');
console.log(document.body.firstChild.enctype);
> "application/x-www-form-urlencoded" 
```

Correctly restores the property value in all browsers I have my hands on, as you would expect.
 #2202 merged. Waiting for #2241 (or similar) to prevent test error, unless you want to go ahead without that test (it's testing that selected values remain for an uncontrolled `select` when toggling `multiple`, which is half-broken right now anyway but passing the test).
 Accepted but only once the dependency is resolved.
 Dependency landed, I'll rebase and retest this PR.
 We're the worst at merging‚Ä¶ This is still passing all tests in a real browser and Phantom, but it's failing with jest, which is a bit of a bummer. It's actually an issue with the outdated jsdom we have in jest (which I'm going to fix... https://github.com/facebook/jest/pull/221). In the mean time we might have to `xit` those tests and add TODO comments.
 @zpao This is on me actually, I got the go-ahead for merging my accepted ones some time (too long) ago after rebasing and testing... it's just been one thing after another on my end. But I'm trying to get some time over to go through my accepted PRs and get them rebased/tested soon.
 @sebmarkbage @zpao I've verified that there aren't any other properties that should have `MUST_DELETE_PROPERTY` with a script that iterates through all elements supported by React and all configured properties (found #3000).

I've changed it to _always_ set boolean properties to `false` instead of `removeAttribute`, this also neatly avoids the `select.multiple`-bug. However, I have left `MUST_DELETE_PROPERTY` on the affected properties even though it does nothing right now (but may in the future, like `MUST_USE_PROPERTY`).

There's an unsolvable edge-case for now; `button.value` will never lose the attribute due to sharing configuration with `input.value`, but it will still work as intended. But this is a minor nitpick considering we currently have significantly worse flaws without this PR.

So unless there's any red flags for you guys, this should be OK to merge from my POV.

**EDIT:** (jest) JSDOM was failing my new prop/attr tests, I commented out the affected rows in hopes that JSDOM will correct it in the future (or if we drop JSDOM). Ok? Or should I just remove the affected tests, they have _some_ value they way they are now at least...
 ping (no rush)

PS. I'm not quite sure why travis is failing this PR because of existing lint errors but not others?
 Ping. I fixed the lint issue and I feel confident that everything is in order and that only the [above mentioned caveats](https://github.com/facebook/react/pull/1510#issuecomment-72341431) apply (which are far better than the current caveats), also note the issue with JSDOM tests.
 Sorry, what's this MUST_DELETE_PROPERTY for?
 Based on the usage with `value`‚Ä¶ it ensures that we actually reset the visible value (though is setting to an empty string right?). The value attribute is different from the value property (just actually was looking at this for `checked` as well) so removing the attribute doesn't actually change the value the use sees.

<img width="354" alt="screen shot 2015-08-19 at 5 36 38 pm" src="https://cloud.githubusercontent.com/assets/8445/9372902/fe823fec-4698-11e5-8ce7-0c2c405098b2.png">
 I see. It doesn't make sense to me to use removeAttribute for MUST_USE_PROPERTY ones; shouldn't we only use removeAttribute if we set it with an attribute?
 `id` is the only one that is `MUST_USE_PROPERTY` but without `MUST_DELETE_PROPERTY`. Why? Does `id` really need to use property? I don't remember if there are browser quirks here (my bet would be on IE8 doing something weird like the comment for `className`)

I agree with (I think) what Ben is getting at - this adds another dimension of complexity that would be great if we could avoid. Having `MUST_USE_PROPERTY` mean that it must also be deleted makes a lot of sense.
 Yes, thanks @zpao. That is approximately the comment I would have written after getting a chance to inspect the list more carefully. Maybe in MUST_USE_PROPERTY cases we can set it to the original value (getDefaultValueForProperty) and then also call removeAttribute?
 @syranide updated the pull request.
 Uh what? :O
 You didn't? cc @vjeux ‚Äì not sure what happened here.
 @spicyj 1-2 months ago or something perhaps, certainly not today.
 Haha, I think I know what happened there.  @vjeux I think your script is not checking to see if the event source was a new commit/push.  I think I accidentally added a tag, then immediately removed the tag, which triggered your github hook.

I was looking at this commit because I'd like to get this merged for 0.15.  Sounds like this is something we want to take.  I think Ben wants to take a look at whether/why MUST_DELETE_PROPERTY needs to be a separate flag.
 @syranide Do you want to rebase and we can start preparing this diff to hopefully get it into 0.15?
 @jimfb [Can do!](https://www.youtube.com/watch?v=y9IcGZZnC1k) I'll get to it in the weekend.

Also, when you have time; decide how you want to deal with `MUST_DELETE_PROPERTY` and I'll get it fixed, but the current implementation makes the most sense to me all things considered. You decide.
 Sorry for stalling here, I'm in the middle of a move right now. But I'll try to get it done ASAP.
 Ping @syranide; would love to get this in!
 @syranide updated the pull request.
 @jimfb Rebased and tests pass, but it needs to be tested thoroughly in the browser again. ~~I also removed the logic that removes boolean attributes via the property (because it's obviously flawed~~) **EDIT:** reading comprehension fail, not flawed.
 @syranide updated the pull request.
 @spicyj Are you good with this.  Is the only remaining step to do a couple browser tests and merge?  Or are you still investigating?
 @syranide updated the pull request.
 Rebased for conflict. Sorry for stalling this, I'm pretty confident this is safe (from previous tests), I want to get around to testing this but it's hard to find the time right now.
 @syranide updated the pull request.
 Marking as accepted.  I'll give everyone another 24h to interject, otherwise I think we can do a browser test or two and merge.
 Would it be correct to always unset the property for MUST_USE_PROPERTY, then also call .removeAttribute for those? With what you have, we have the added complexity of a new dimension, plus it means that if you render

```
<input value="hello" />
```

then

```
<input />
```

then the `value` attribute still sticks in the DOM. It sucks that we don't have a separate interface for the attribute (sorta related to #4618) but it still seems like rendering A then rendering B should be equivalent to just rendering B whenever possible.

Perhaps the cases which you've written MUST_DELETE_PROPERTY for are the only ones which really require the use of properties, and all others can be use plain attributes? (Excepting className on IE8, I guess.) My fixes in 6269ef62cfdbcb768f2294a26145fa3ac1085520 lead me to believe that we should be using attributes whenever possible and properties are just too much trouble.
 > Marking as accepted. I'll give everyone another 24h to interject

@jimfb Please don't do this. If you actually want my input then please wait for it; if you're confident that the code is fine then just merge it yourself.
 @spicyj I did/do actually want your input on this diff (wasn't going to merge until we chatted about it again), but also had pinged a couple times (your last comment was a month ago, and the diff was a year old).  I was "relatively" confident, and willing to merge if there weren't any objections.  But I promised Paul that I would try to give everyone ample notice before merging any diff that could be in any way controversial.
 > Would it be correct to always unset the property for MUST_USE_PROPERTY, then also call .removeAttribute for those?

No, answer below.

> then the value attribute still sticks in the DOM. It sucks that we don't have a separate interface for the attribute (sorta related to #4618) but it still seems like rendering A then rendering B should be equivalent to just rendering B whenever possible.

But that's how it _should_ be (according to the spec and regular browser behavior), the `value` attribute and the other such special attributes reflect the initial value. So _if_ we want to break with the spec (in a sense) and remove the attribute, then the same logic should apply when updating too.

> Perhaps the cases which you've written MUST_DELETE_PROPERTY for are the only ones which really require the use of properties, and all others can be use plain attributes?

`MUST_DELETE_PROPERTY` is really about properties with side-effects (aka attributes that only reflect the initial value), so really `HAS_SIDE_EFFECTS` should theoretically be used instead, but technically it's not a good idea at the moment. So yeah, those are the only ones that should need to be mutated as properties and all others should work as properties (barring any browser bugs).
 > the `value` attribute and the other such special attributes reflect the initial value

I guess that's reasonable; we can leave it like this and see if anyone notices/complains about the difference.

> `MUST_DELETE_PROPERTY` is really about properties with side-effects (aka attributes that only reflect the initial value)

I understand that. Currently, `controls id readOnly srcDoc` (and `className` in IE8) are marked as `MUST_USE_PROPERTY` but not `MUST_DELETE_PROPERTY`. I just tested the first four in Chrome and none seem to require the use of properties; they all work as intended when set as properties. Even testing `.setAttribute('class', ...)` in IE8 seems to work just fine so I'm not sure what the original issue was. Can we just use attributes for all of those?
 > I guess that's reasonable; we can leave it like this and see if anyone notices/complains about the difference.

Native/uncontrolled components behave like that, so I'm not sure if any complaint could really be considered legitimate anyway?
 If you set it with a property, but not if you set it with an attribute.
 > But that's how it should be (according to the spec and regular browser behavior),
> 
> Native/uncontrolled components behave like that,

This is a great way to get me to read a GitHub thread thoroughly, because more often than not, that's the opposite of what we want. :) 
 My mental model is that React updates should work as if you reloaded the page, or did another innerHTML. I think the browser authors would've made the DOM work like this if they had realized how to do it. We ended up with a weird attribute/property divergence because nobody knew how to build this.

The only exception is `defaultX` which should have no effect after the initial render.

Now, all I really care about is user facing behavioral effects. If there are extra attributes hanging around that doesn't do anything other than screw up your debugging, or calls to `getAttribute()` or CSS attribute selectors, I don't really care. That's out of scope for the Reacty way of doing things.

As you can tell, I still don't quite understand what's going on here but it's open source so I'll just write something random in a PR.
 I think it's fair to support CSS attribute selectors, and this enables that.
 eehm... "screwing up your debugging" is unfortunate and should be avoided to the extent possible/practical, all things being equal.
 I think @spicyj made a particularly strong statement here:

> but it still seems like rendering A then rendering B should be equivalent to just rendering B whenever possible.

I'm inclined to agree with @spicyj on this point; seems like we should update attributes wherever it makes sense.
 >  "screwing up your debugging" is unfortunate

In this context, it means the "Elements" tab. You still have the React DevTools.

I'd like to make that "React" strict mode and see how much faster it gets. Then people can choose between speed and DOM interop. I don't think the answer is obvious.

> but it still seems like rendering A then rendering B should be equivalent to just rendering B whenever possible.

Except for the `defaultValue` case.
 > Except for the defaultValue case.

Haha, yes, well, that's a whole different can of worms.  But yes, except for things that are functions of internal component state.
 > except for things that are functions of component internal state.

I think part of the issue is that in the "standard" DOM everything is component internal state. We have to explicitly decide when that makes sense and when it doesn't. That's part of our design prerogative.
 Yes, it is our design prerogative (thus `defaultValue` and friends), but in general we should avoid keeping internal state when it's unnecessary.
 > If you set it with a property, but not if you set it with an attribute.

What I mean is, that's the behavior you get if you manually type into it.

...

As far as I can tell, doing what you guys are suggesting is a no-go anyway, updating the value resets the selection, controlled components normally rely on _not_ updating the value for proper selection behavior. This is probably fixable by restoring the selection but IMHO it doesn't seem like a complexity/risk worth taking considering the debatable benefit.
 Okay, forget the bit about controlled components. My current thinking is to take your PR but rename MUST_DELETE_PROPERTY to MUST_USE_PROPERTY and get rid of the existing props with the MUST_USE flag. You don't seem too excited about this idea?
 > You don't seem too excited about this idea?

I may have misunderstood your intentions, removing the concept of property vs attribute seems just fine to me (but I can't speak for any cons, many of pros though!).

However, merging `MUST_DELETE_PROPERTY` into `MUST_USE_PROPERTY` doesn't make sense to me naming-wise, they are not regular properties (`value`, `checked`, etc). But if you called the flag `USER_MUTABLE_PROPERTY` (maybe poor name) or w/e then I have no objections.

PS. `HAS_SIDE_EFFECTS` should then theoretically be redundant too, but there may be internal reasons why it's still a good idea. **EDIT:** actually, unless I'm sorely mistaken we can merge `HAS_SIDE_EFFECTS` into the new flag too, no problems.
 It seems easier to use the same MUSE_USE name since that's what it will mean and already exists but if you feel strongly about changing it go ahead. I think the naming is about as confusing either way, as user-mutated props are the only time you do need to use properties instead of attributes.
 > It seems easier to use the same MUSE_USE name since that's what it will mean and already exists but if you feel strongly about changing it go ahead. I think the naming is about as confusing either way, as user-mutated props are the only time you do need to use properties instead of attributes.

The way I see it, regular values can be managed in two ways:
1. Set the attribute, remove the attribute
2. Set the property, remove the attribute
3. Set the property, clear the property (leaves an empty attribute which is bad, sigh)

Whereas "user mutable properties" should only be managed as:
1. Set the property, clear the property

Putting it like that I see what you're getting at and I kind of agree with you. It's kind of confusing from a practical perspective (a regular property must not be marked as `MUST_USE_PROPERTY`???), but from a technical perspective it makes sense (they are the only true properties). So yeah, "confusing either way" is probably right.

The only objective counter-argument I have is if we want to get rid of `HAS_SIDE_EFFECTS` too, then the name may be too generic (but still not _wrong_, so meh).

tl;dr, let's just go with `MUST_USE_PROPERTY` after all, how do you want to proceed? (Should I update the PR?)
 Please do! 
 Updated for feedback, only tested via `npm test` so far (DOMPropertyOperations-test probably needs to be cleaned up, will get to it).

PS. Is there are a way to run the eslint locally without getting tons and tons unrelated warnings?

PS2. Sorry for the spam, some errors due to not having rebased.
 @syranide updated the pull request.
 @syranide PS1 You should be able to do "npm run lint", let me know if that doesn't work for you.
 @syranide Looks like there is a merge conflict.

Once we're rebased, who's court is the ball in?  @syranide anything remaining on your end?  @spicyj?
 @jimfb Merge conflict should be a trivial update to HTMLDOMPropertyConfig. I've been sick the last week too (everything at the same time :)).

Anyway, I think some tests needs to be cleaned up and the last change was a pretty "big" one so I don't feel confident the way it is now without having more time to test it.
 @syranide Ok, cool, I just wanted to make sure the ball wasn't in our court.  Just let us know when you're ready/comfortable with it :).  Hope you get well soon!
 @syranide The sooner we get this PR into a mergable state, the fewer conflicts/etc.  :)
 I mean @jimfb, you could also test it to verify that changing attributes are reflected in the property value (in all browsers, ideally for all kinds of elements) for all the props that changed config. Once that's done I can feel good about merging this.
 Ok, I wrote a jsfiddle to help identify attributes that might warrant manual investigation.  I ran it on chrome, next step is to run it on other browsers.  Fiddle is located here: http://jsfiddle.net/gLd3hfrn/

On chrome, it flagged: radiogroup mediaGroup ~~httpEquiv~~ icon.  ~~The most interesting of which is `httpEquiv` (it didn't appear to work using attributes, though I'm not sure if chrome would honor the change if it were set using properties, so maybe it doesn't matter).~~  Anyway, fwiw.

cc @syranide 
 Looks like http-equiv works fine if you spell it as http-equiv not html-equiv.
 Ah, ok, that's good :).  `http` comes right after `html` in the list of attributes, plays tricks on your mind.
 Again really sorry for dragging my feet on this. Personally I'm mostly concerned about input controls and the various mutations of them (e.g. toggling `multiple` on `select` doesn't update `value` in some browsers when specifically removing the attribute (I think), etc) and them visually responding as they should (`video`/`audio` attributes/properties?). Also, this PR was initially intended to fix `progress` which previously wouldn't work as it required the absence of the attribute to correctly reset.
 Simple test: http://jsfiddle.net/670u7ure/8/

However as you can see `<progress />` _still_ doesn't work properly because it should set `value` as an attribute, but it conflicts with `<input>` which requires it to be set as a property. We can hack around it by ignoring the property-flag if the node isn't `<input>`, `<select>`, etc, but that's really really ugly. A better alternative that's short of per-element-whitelist is to have a per-element-override, so `value` would be attribute by default but would be overridden to be a property for `<input>`, not sure about the perf implications of this. Anyway, this bug is already present so it's not a show-stopper, but it's worth figuring out.

@jimfb Do you feel like the transition from properties to attributes is safe from your tests?

**Unrelated;** Also, I noticed that React has acquired some weird behavior (in master) where it doesn't set `value`, `checked`, etc as attributes on first creation when rendering client-side, but if you render to a string and render on-top of that it behaves as "expected".

**Unrelated 2;** https://github.com/facebook/react/blob/master/src/renderers/dom/shared/DOMPropertyOperations.js#L176 that seems broken, NS-attributes don't obey by the property flags correctly.
 @syranide updated the pull request.
 PS. Another thing to consider, we could get rid of `MUST_USE_PROPERTY` too and leave it up to the wrappers to manage these properties instead. It would simplify the shared logic in DOMPropertyOperations.
 Yes, we can move the .value logic to the wrappers. I wanted to make it use attributes at the low level anyway as part of a fix for #4618.
 @spicyj Make that change first, then remove `MUST_USE_PROPERTY` from this PR and merge? Or how do we proceed?
 Ping
 I don't think they need to be intertwined. Will leave merging this to @jimfb since he's already done most of the testing.
 Ok, I ran a whole suite of tests on a wide variety of browsers (firefox, chrome, ie, edge, safari, etc).  I also cherrypicked this over to my devserver and ran through the whole react test flow.  I think we've done our due diligence here.  Worst case, we revert/fix, but I think the risk is low.  Let's do this.
  I can't repro this:

http://jsbin.com/ditulapo/1/edit
  This is actually how it used to work before. The purpose of the variable arguments is to be able to differentiate a dynamic array created by the user and a static set that is expected to be the same every time.

``` javascript
var items = data.map(...);
return <div>{items}</div>; // this should warn you that you need to provide keys

return <div>{item1}{item2}</div>; // as a convenience, this doesn't require keys
```

The size of the code is not really a problem. It's more about a convenient way to provide helpful warnings to help preserve correctness. In theory, the variable arguments shouldn't allocate memory on the heap but we'll probably introduce some kind of optimized JSX transform if we need the perf.

Closing out but let's keep the dialog open. Is there a particular reason you need this?
  +1 andreypopp
 Nothing planned; I'll close.
  Please don't call setState from outside your component. While it's currently possible, that really should be a private method. state is internal, props are external.

In this case height is controlled by state, which gets its initial value from props. The more correct solution would be to just use props, but specify getDefaultProps which returns height=20.
  Can you be more specific and post the exact error message you encountered?
  @jamesgpearce Not sure if you were serious here? https://news.ycombinator.com/item?id=7721261
  Thanks!
  This is actually autogenerated from markdown in the `master` branch (docs folder) -- can you sign the CLA and reopen as a separate PR there?
  #1363 should fix.
 Guessing that #1363 fixed this.
  Yes, this is intended -- if you want more control you can use ReactTransitionGroup directly.
  that's neat lol, :+1: 
 @chenglou can you get the right people looking at this and get it reviewed and landed?
 @syranide diff created, although I can't repro this. I also vaguely remember being able to repro it, weird...
 Reproed! Merged internally.
  I can't immediately repro this. You can see from the source of traverseAllChildren.js that the _intent_ is certainly to treat a single child as the same as an array:

https://github.com/facebook/react/blob/master/src/utils/traverseAllChildren.js#L121-L124

If you could post a jsfiddle or jsbin that would be helpful. In either case, it shouldn't be hard to use 0.10.0 or a nightly from http://react.zpao.com/builds/master/latest/.
 Closing, but @gaearon if you can repro let me know.
 This is actually avoidable after-all #2378
  See http://stackoverflow.com/q/23510413/49485.

Test Plan: grunt fasttest
 lgtm
  Looks good! Tested and pulled in for stamp review internally.
  Thanks!
  In addition to the CLA, the gh-pages branch is auto-generated -- do you mind creating a new PR to master changing the markdown in the docs folder?
  Can you provide a jsfiddle/jsbin example of what you mean?
  2 things.
1. Let's maintain ABC order
2. Can you make sure you also update vendor/fbtransform/transforms/xjs.js?
 Since @petehunt forgot his manners... thanks!
  Edit: oops, sorry, wanted to edit your comment because the formatting screwed up.
 Your problem is that you were also animating the width at the same time as -webkit-transform, so the last `<li>` would wrap to the next line until the width reached its final value (which would happen as the transition ends). If I change the CSS to:

```
-webkit-transition: -webkit-transform 300ms;
-webkit-transition-timing-function: ease-in-out;
```

then it works properly. Here's an example:

http://jsfiddle.net/9RrAN/2/

(This is not related to React in any way.)
  If you want more control over an input's value, you probably want to use a controlled component (with `value=` instead of `defaultValue=`) as described in this page:

http://facebook.github.io/react/docs/forms.html

You'll need to set an onChange handler and handle changes appropriately.
 If you're using an uncontrolled component, you can also put a `ref` on the input and manipulate its value directly. React just gives you a base `<input>` component which you can build higher-level abstractions over if you need them, but controlled components are applicable as-is to many scenarios. See also:

http://facebook.github.io/react/docs/two-way-binding-helpers.html
 defaultValue is read only on initial render, not afterwards. This is because the desired behavior is unclear if the user has changed the field -- do you want to blow away their changes? Usually not.
 What if someone types into the input field before your ajax call returns? It's unclear to me why you seem to claim that neither controlled components nor manual DOM manipulation work for your use case.
  Fixes #1482.

It doesn't seem like this is actually doing anything and it's causing problems
for people, so remove it.

@petehunt
 Well, it should be doing something, and does if you set the environment variable. However it's not set by default :o - I don't think we should remove this capability though.

But if you run `NODE_ENV=production envify test-file` it works (which is presumably the close enough to what happens in real life with browserify). So we're really depending on non-standard behavior and a pattern made popular by express.
 Ahh you're right. Any objection to moving it from peerDependencies to dependencies then? Seems to still work in my testing.
 :thumbsup: that seems reasonable. It's a lot of stupid overhead for many cases, but let's do it for now. I'd love a better solution eventually though if anybody has ideas.
 Okay, will do. I don't think it's any different from what we have now except that it won't share a preexisting envify dependency. (That is, people who don't want envify get it now already.)
 @pluma. It's needed when other modules browserify themselves. While not `required` itself, that would technically fall under peer dependency.

Eg `my-react-component`

``` js
var R = require('react');
var MyApp = R.createClass({ ... });
module.exports = MyApp;
```

`NODE_ENV=production browserify my-react-component.js` should do the right thing and package React for production. That's not a devDep for React, it's actually a peerDep. However peerDeps are _often_ missed (including with browserify-cdn, see 486b3c0bc5fc104d3b106b4ab58136b392753150), so we made it an actual dep so we'll do the right thing always.
  I think we can move it to dependencies, though it's a little silly in either case to require people who might not be using browserify to install it. @petehunt Any objections?
 It's used as a browserify transform when building a bundle so needs to be required then. It's not used before npm so doesn't belong in devDependencies.
 No, that's for the non-npm (browser) builds. envify is referenced in the browserify `transform` array here:

https://github.com/facebook/react/blob/master/npm-react/package.json
 I see `process.env.NODE_ENV` many times in the resulting file, but presumably this means envify is indeed not working properly.
  This is intentional: https://github.com/facebook/react/blob/master/src/browser/ReactWithAddons.js#L50-L52

Since the minified build is solely for production and includes as less as possible for perf. Still, what's your use-case?
 @jasonslyvia TestUtils is intended for internal testing, and is therefore internal API.  We recommend that you do not call into internal APIs (especially in production) as they are not supported/stable/optimized/etc.  We are not going to publish builds that expose internal API, but nothing stops you from checking out the code and building it yourself with any changes/modules.

I'm not super familiar with the browser's event system, but I think you can achieve your goal by temporarily disabling the watermark and emitting a click event:

```
disableWatermark();
document.elementFromPoint(x, y).click();
enableWatermark();
```

If people need a public API for interfacing with the React event system, you might consider creating a task for that API and see if you can rally support, but my guess is that simulating click events is something better left to the browser's existing APIs.

On a side note: It is absolutely trivial to open the chrome tools (or firefox/whatever) and remove the watermark from the DOM (this is trivial, even without the disable/enable functions I proposed).  Anyone who is capable enough to take a capture webpage is almost certainly capable enough to just remove the watermark before capturing.  I'm a little worried that your attempt at 'security' is a bit miss-guided, but that's a different discussion.
 Once you have the element at a point (via jquery), I feel like there is something you can do with it.  For IE, maybe use `fireEvent` instead of jquery click.  Or find another way to trigger the appropriate event on the dom element.  I haven't looked into it too deeply, but I strongly suspect that if you poke around, you should be able to do what you want with the native apis.
  cc @fisherwebdev
  Thanks, this was awesome.
  See also #1326.
 Partially fixed by #2549; the rest sounds like #1326.
  Thanks!
  I am pretty psyched about this. I'll stack a commit on top that does the backticks -- but it would be pretty great if you could expand a bit on how stores can depend on one another sometime :D
  Curious -- what's the use case for a generator that never yields?
 Updating esprima: https://github.com/facebook/esprima/pull/17, which will make it's way back here eventually
 I tested that your koa example is transformed with an `npm link`ed fb-esprima
  ping @zpao, want to take this?
  :+1:

cc @sebmarkbage @zpao @yungsters
 We're trying to move away from both deep testing of resolved components (a unit is a single component) and also change the refs API.

I'm curious about the use case. Are you using the ref-feature as a way to enable deep testing? I.e. adding something you don't necessarily need at runtime. Or are you testing the resolution of the ref itself? An example would be great.
 This needs a more general solution like #1651 so I'm closing this out. However, #1651 no longer works for refs so it should be changed to take a callback.
 We're moving away from string refs so this probably won't work in the future.
  This happens because jsfiddle doesn't support HTTPS.
 Neither does jsbin, so it's not as simple as just switching providers here. Luckily Chrome and Firefox (desktop) both allow you to opt out, and it's a sticky pref so it seems to persist.

The real problem is that you're using github pages sites over https, which they aren't by default and none of our links are either. I'm guessing you either went to the wrong page or have an extension (I used [https everywhere](https://www.eff.org/https-everywhere) for a long time, so that's my prime suspect).

There's not much we can do here (though we'll likely move off github pages eventually), so I'm going to close this out with 2 suggestions then:
1. Don't use https
2. Disable on load in your browser.
  I believe it's intentional that it doesn't fire for true->false (because you really only want one event) but the true->true should not be counted. Essentially you're getting a change event for the radio group rather than for the individual radio button.
 Agree. If someone wants to tackle this, it would be nice if "changing" from checked to checked didn't trigger an onChange event. I'm also happy to accept a docs PR to make the expected behavior clearer.
 @gaearon Interested in taking a look at this one?

Right now ChangeEventPlugin fires an onChange event for every `click` that it receives from the browser (for both checkboxes and radio buttons). My guess is it's necessary to track the current value when the `focus` event is triggered, sort of like we do for `activeElementValue` in old IE. Not sure how tricky it will be to solve. (http://benalpert.com/2013/06/18/a-near-perfect-oninput-shim-for-ie-8-and-9.html explains approximately how the onChange event currently works for text inputs.)
 Sure, no rush.
 @itrelease No ‚Äì at the point that handleChange is called, the `checked` value has already changed and we do want to fire the onChange event if a radio button becomes checked.
 @EtaiG Sorry for the delay. If the change is simple, we can take it without tests and if it's complex, maybe I can write some. Do you want to post a PR with your code as it is now?
  Thanks!
 Not often enough - we've been slacking a bit there. I'll go through and do that now.
 And done - http://facebook.github.io/react/docs/videos.html is up. Thanks again!
  sweet! can you make the changes in `master`? we build `gh-pages` from the markdown files in `docs/` in `master`.

great video!
 Superseded by #1470.
  @petehunt might own the other fiddles and be able to update them from his end, but this is good for now. Thanks!
  Works fine here for Chrome on Mac. Probably a problem with jsfiddle.
 http://facebook.github.io/react/docs/thinking-in-react.html works fine for me as well. What happens if you go to http://jsfiddle.net/6wQMG/embedded/ directly?

Going to close this out unless we find it's a more systemic problem.
  I dunno, it seems like we might reasonably support this. @salier what would you suggest?
 @syranide is correct, though unfortunately, even if you use `dangerouslySetInnerHTML`, you'll pretty much need to cede control of the contenteditable to the browser. Even flushing an updated markup string back through would surely break the selection state, which would make the contenteditable unusable anyway.

As far as I can tell, there is no simple middle ground with React + contenteditables. You've either got to permit full browser control or you have to maintain complete ownership of everything, including selection state.

@spicyj what do you have in mind for support? There may be some approaches I haven't thought of.
 I didn't have any solution in mind; I merely meant that it seems odd that rendering a simple contenteditable component and then letting the user interact with it causes React to throw errors. One thing I considered was using `React.renderToStaticMarkup` to render the children, though I'm unsure if that prevents real use cases that work better now. Maybe we should just warn and call it a day.
 We now have an informative warning for this case, closing.
  Do you have two nested `<form>` elements? (HTML disallows that.) If not, please post a minimal example showing the problem.
 Please post a working example on jsbin or jsfiddle that reproduces the problem.
 Going to close this out then. :) Let me know if you can make an example that has the problem.
 (If you need Bootstrap in order to repro the problem, it's okay to include that as well.)
  Previously we were escaping both in createMarkupForStyles and then in
createMarkupForProperty; now we escape only in the latter (otherwise the
hypothetical style name `b&ckground` would become `b&amp;amp;ckground`).

Test Plan: grunt fasttest
 No, only style names were double-escaped (not values).
  Fixes #1444.

Test Plan: grunt fasttest
 cc @yungsters - I think this is a fine move but wouldn't mind another set of eyes from somebody who has seen a few crazy things.
 Thanks for doing all the legwork, @syranide. This change alone should be harmless. It would be great to get a second pull request to get ourselves at parity with browsers (`&`+`"` for attribute values, `&`+`<`+`>` for text content). I would want to get that second pull request reviewed by our internal security team.
 @yungsters That's already made in #1599.
 (We don't support unquoted attribute values; we build all the HTML ourselves and always quote it.)
  Fixes #1457.

Test Plan: grunt fasttest
 Sorry about that, just opened #1460 with a fix. (Actually tested it on your code this time. :))
  If you use `zIndex` it'll work correctly (and you won't have to quote it!). That really should warn you -- we have #932 open for adding a warning.
  Test plan: `grunt perf:webdriver:phamtonjs`. See it finishes.
 Maybe appDescriptor or just app?
 Yeah it was appDescriptor at the beginning but that sounded too technical lol, alright I'll change it.
 Thank you Facebook! I will do my best to contribute to this repo. Can you auto merge this please?
 SEEMS LEGIT
  Fixed by #2316
 Well, it's not really fixed until we update the devtools.
 @zpao facebook/react-devtools#23, but perhaps you're referring to not having been updated in the store yet perhaps?
  Looks a little sharper :thumbsup: Thanks!
  Oh man, just discovered this issue. Want.
 Are there ever cases where we need different attr configs based on some other attribute of a node? (Like the `type` of an input?) I hope not.
 @tomocchino and I have talked about doing something like this ever since `SyntheticEvent` was introduced.
 @yungsters @zpao How do you feel about this?

I'm thinking about doing a makeover of `HTMLDOMPropertyConfig`. It seems as if there are many "names" that are flagged `MUST_USE_ATTRIBUTE` despite working equally well as properties.

Additionally I can pretty confidently say that it's not `MUST_USE_PROPERTY` vs `MUST_USE_ATTRIBUTE`, but whether or not the property exists and can be used (for performance purposes @sebmarkbage). I.e. it should be `NEVER_HAS_PROPERTY` (only non-standard attributes?), `SOMETIMES_HAS_PROPERTY` (HTML5 and non-standard attributes) and `ALWAYS_HAS_PROPERTY` (most, if not all, standard attributes). Possibly also `MUST_USE_PROPERTY` (or similar) for `value`... possibly.

`SOMETIMES_HAS_PROPERTY` would be implemented as #2141, but only used for a handful of "names" (so performance shouldn't be a concern). If we in the future agree that cost of detection is negligible, then we can simply apply the behavior of `SOMETIMES_HAS_PROPERTY` wholesale and remove the flags.
  What is the consequence of leaving the DOM attribute there? Is it messing with your CSS rules? What is the end problem caused by leaving them in?
 I think it might make sense to have several different code paths based on browser and/or the attribute used. Before committing to this as a permanent supported solution, I'd like to clarify that this is a common enough problem.

There is another reason I'd like to treat React props as properties rather than attributes in general. HTML/SVG and Web Components doesn't allow complex types as attributes. To support complex types like style, class lists, custom user data, we prefer to model these as properties rather than attributes.

If a property is inherently broken in the DOM (missing functionality) we can fix those on a case-by-case basis. Ideally the behavior of React props should correspond to DOM properties instead of DOM attributes. But in the end, we'll do whatever makes sense.
 @sebmarkbage `<a />` is different from `<a href="" />`
 I decided to swap out the `a` element for a `span` because just toggling the presence of the `href` attribute isn't possible atm. 
 I have PR #1510 for this which seems rather safe (perhaps need to add a test for "property-only" properties), nag on @sebmarkbage a bit more and he might consider it. ;) 
 @ezequiel Ah good to know.
  Addons I'd say!
 Perhaps we drop `LinkStateMixin` from addons and add `React.addons.LinkState` (and put the mixin there?)
 :+1: 
 Should we remove the default value of the argument and require users to pass the type of the link's value in? @jgebhardt ?
 Yeah I'm thinking that may be a saner default.

Sent from my iPhone

On Jul 7, 2014, at 9:55 AM, "Jonas Gebhardt" <notifications@github.com<mailto:notifications@github.com>> wrote:

@petehunthttps://urldefense.proofpoint.com/v1/url?u=https://github.com/petehunt&k=ZVNjlDMF0FElm4dQtryO4A%3D%3D%0A&r=qYx6qLphxKhA5vHBqr9vuw%3D%3D%0A&m=eHxV3sf5jASI1mbqbM52IzkLlMekR67gjA7iYHxMUT4%3D%0A&s=52765ee95f792b5189715c1a7ebbc7dde6a0bb28dce2918ca213b453e10c1a74 People could still pass in React.PropTypes.any‚Äì is the goal just to make that explicit by forcing it to be specified?

‚Äî
Reply to this email directly or view it on GitHubhttps://urldefense.proofpoint.com/v1/url?u=https://github.com/facebook/react/issues/1447%23issuecomment-48205624&k=ZVNjlDMF0FElm4dQtryO4A%3D%3D%0A&r=qYx6qLphxKhA5vHBqr9vuw%3D%3D%0A&m=eHxV3sf5jASI1mbqbM52IzkLlMekR67gjA7iYHxMUT4%3D%0A&s=dfd506ace44272b50d0e8049a87e56332f745c31f3e02a1ec775782671a31cd3.
 ReactLink is getting deprecated as per https://github.com/facebook/react/issues/2302.  Also, proptypes are on their way out in favor of flow.

If this is something you would find useful, I would recommend creating a custom proptype validator and publishing it to npm so other people can use it.  Since this is not something we plan on supporting in the core, I'm going to go ahead and close out the issue.
  Fixes #1259.

aria-\* and data-\* should be deprecated soon. Right now it's a warning.
`<div data-foo="a" dataSet={{foo: 'b'}} />` <- gives the same warning
Under the hood ariaSet and dataSet are spread on props as aria-\* and data-\* (hyphenated), so the logic largely stays the same.
Tested on ie8.

RFC because this touches one of the hottest code paths and I feel bad about it. @petehunt @kmeht
 The other approach is to use the same logic for setting `style`, aka you diff between keys and call, say, DataPropertyOperations.setValueForData(node, diffObj)`. It's less clever, but it doesn't modify lastProps. I'm thinking of consolidating the logic for style, dataSet and ariaSet.

btw, we might also be able to avoid the allocation for the style here: https://github.com/chenglou/react/commit/f26e27d6aabbda5f4cd635a61326429da5646eae#diff-b30330d5009dc149a7f6a262a80eb7a1L281
 I think @sebmarkbage was saying we shouldn't do the easy way - cloning props gets expensive. Let's do the style-like approach.
 We already defensively clone props: https://github.com/facebook/react/blob/master/src/browser/ui/ReactDOMComponent.js#L155
to make this possible: https://github.com/facebook/react/blob/master/src/browser/ui/__tests__/ReactDOMComponent-test.js#L72
dataSet and ariaSet will make it worse by taking the same approach so I'm not sure if I understand the argument. But yes, that method seems more correct.
 @zpao @sebmarkbage clone will be necessary like I said above. We'll have to defensively clone `ariaSet` and `dataSet` anyways in the future.

For this PR's alternative suggested by @zpao, looping through data-\* and adding them to `dataSet` is weird because you'd have to take `data-foo-bar`, turn it back into `fooBar`, and merge it into `dataSet` (which is already defensively copied btw) if it's not already defined (`dataSet.fooBar` takes precedence over `data-foo-bar`) during the diffing step in `_updateDOMProperties` (equivalent for style: https://github.com/facebook/react/blob/master/src/browser/ui/ReactDOMComponent.js#L342).

So I'm wondering if we should just go with this for now. We'll be ignoring (and warning) `data-*` in a close future anyways.
 lol
 Sounds like we're going to do this in a simpler way after #1543; closing for now.
  [@sebmarkbage suggested we do this](https://github.com/facebook/react/pull/877#issuecomment-40534852) to avoid the silly tagName requirement. Anything that can resolve to a node (getDOMNode) should work.
 Exactly that is coming, called shallow testing. It's not 100% supported but you'll be able to start using it in 0.13 (you can try 0.13 beta today). See #2963 for some details (documentation and links to impl).
  Why?
 Perhaps we shouldn't escape slashes; see https://github.com/jashkenas/underscore/issues/1189.
 Seems to be a good story to back that decision up there...
  Agree that fixing DOMPropertyConfig is preferable to a wrapper.

@syranide Not quite sure what you mean about shouldIgnoreValue, sorry?
 After talking on IRC, keeping this declarative in some way sounds like the best option (maybe making https://gist.github.com/zpao/11268735 or similar work). But in the short term this might be acceptable.
 I don't think we're going to do it this way, so I'm closing this out. Hopefully one of the other solutions will make it in soon.
  Would be nice to fix this and make sure we're using lcov format so we can report back to [CodeClimate](https://codeclimate.com/github/facebook/react).
 (Does jest help here?)
 We got rid of this so closing
  Thanks for starting the discussion @nathansobo. There is a mapping somewhere but before we go down that road, let's make sure we want to do it that way.

cc @salier @joshduck @yungsters - I think we probably just shouldn't be attempting to restore selection in `type="hidden"` elements. What do you think?
 @zpao we should probably try to solve this so @nathansobo doesn't need to fork. I wonder if we can create a customized `React.DOM.textarea` that blacklists itself from `ReactInputSelection` (I don't understand this stuff that well so I may be off base here).
 We might be able to do a variant of @syranide's #870 to prevent detaching inputs from the DOM unnecessarily, which I believe alleviates the need for this transaction wrapper.
 Hmm, maybe the best way would be to get rid of this transaction wrapper and instead only do the selection restoration when we detect that a text input node will be moved? I wonder if we can efficiently detect that with ChildrenUpdates?
 Adding a revision needed flag since this is probably not the exact solution we'll land, but this seems like it still needs a fix.
  We should be able to make `value` work always without making a new `progressValue` prop.

The two important things is that we don't set value to the current value if it matches (that causes weird things with the cursor sometimes) and that null turns into an empty input box, not the string "null" (which I think it does in old IE if you do `.value = null`). If just doing MUST_USE_ATTRIBUTE doesn't work cross-browser, then we can probably make a custom mutation method -- perhaps checking `node.tagName` but perhaps we could do something craftier like checking if `defaultValue` is present (and using the property accessor if it is, the attribute otherwise).
 Thanks for taking the time to start looking into this. I definitely don't want to do what you did here. @syranide is right - introducing a new property just to fit into our existing set of constraints is bad. We can change our implementation as we find new constraints though.

In this case it _might_ be as simple as saying `value` should be an attribute now. However, I think there must be a reason we didn't do that earlier. @yungsters - do you remember?

We may also be able to special case properties when they are on certain nodes, maybe for the default values or for the way we handle the setting (attribute vs property).
 While we're here, 2 spaces for indentation, not tabs. (we have an .editorconfig file with that, though I know not many actually use those... yet)
  Want to submit a PR? Will close this in favor of #1400.
  Using this branch to sync internally with FB, still needs polish and to be split up into multiple diffs.
 Going to close this out since it's being split up and applied more piecemeal.
  Interesting, I've never heard of this before. The spec looks quite new. There's probably nothing to do about this for another year?

I do have two questions though, not sure how much you're familiar with it:

1.1 Use cases:

> To support this scenario not only are the animated effects of fading and shifting required, but so is synchronization, both between the animations, and between animations and scripted actions (removing the table row from the DOM after the animations have completed).

Does this mean the animation somehow magically animates DOM elements out _after_ we've removed them? This could be huge.

Also, does this spec allow us to define physics-based animation? And in general, arbitrary animations in JS.
 Awesome, I've asked two questions on the discussion group. This might or might not be a game-changer for React, as currently the hard things to do is animation during unmounting and physics-based animation. If these two can be supported then cool.

As for the issue itself: the draft won't be stable for perhaps another two years? From a brief look this seems easily fittable into React's lifecycle events, as it's the case with third-party integration. When time comes, this should be naturally feasible in React. If some changes are necessarily it might be worth it. I'll let @zpao decide whether we should temporarily close this issue or not.

Edit: thanks for the heads-up!

Edit 2:
Some update on this based on the replies I've received:
There won't be built-in facilities to ease physics-based animation (which isn't surprising, but hey I hoped). As for animation on unmounting:

> The planned API won't support animation after removal. However, player events allow removal to be deferred until after the removal has completed.

So too bad.

If the API makes sense, there's no reason why React can't defer whatever animation wrapper we end up using to that API, like how we offload CSS animation to CSS.
 @Aetet check out https://github.com/chenglou/react-tween-state

I'll close this for now because that animation draft is still a long work in progress, and even if it lands in the far future, react will probably naturally support it, just like it supports e.g. jQuery right now. Thanks for the heads up!
  I don't think input validation will ever be in core react. Simply speaking, this is something vanilla JS handles, and there's no need to impose a react-specific API for it.
`LinkedStateMixin` is a convenience mixin. It's actually not that encouraged because makes things less obvious.
 @novabyte like you saw in the SO mixin: just vanilla JS. And let it be this way, because vanilla JS is reusable JS =). Input validation isn't in a special category, at least not in React; there's no need to special case them. Facebook runs fine without the special handling!
 @novabyte Maybe I miscommunicated it, but I didn't mean that we necessarily extract those into a mixin. If you have a `isInputNumeric()` JS method, there's no reason not to use it in your `onChange` handler directly. If you've got, say, a Backbone app on the side, then you can also reuse the same, wrapper-less `isInputNumeric` because once again, it's vanilla JS. Your Backbone app wouldn't be able to reuse the code if it was a react-specific `isInputNumericMixin`.
 React is much more of a better jQuery than it is a full-stack system.

Unfortunately we don't have the time to build, support and/or endorse a full-stack solution at this time. We're relying on the community for this; see this wiki page: https://github.com/facebook/react/wiki/Complementary-Tools

In the future we'll probably build some tooling to better enable community efforts. To solve your specific problem check this out: https://github.com/wingspan/wingspan-forms
  It's possible to have a composite component that returns an `<option>`, in which case this solution unfortunately won't work. I believe @sebmarkbage is working on refactoring the core in a way that will make things like this more feasible.
 Going to close this out for now as it won't work in the case I described and it's not easy to fix currently -- we can revisit after the upcoming refactors. Thanks for sending this in!
  Hi guys, 

I created this issue in stack overflow:
http://stackoverflow.com/questions/23194175/react-tools-app-jsx-changed-rebuilding-never-ends
 The linked SO question has an accepted answer, so closing.
  And then when you get a chance, we'll need the CLA signed before we can pull this in (https://code.facebook.com/cla)
 I'm going to close this, it's been sitting here a while without updates and I'm less sure we want this. Perhaps we can revisit later.
  Reporting value `''` of `type="number"` as `0` is not a good idea and it's probably not a good idea to report it as `NaN` either, but that could make sense though... but probably not.
  There is a componentWillMount method and it's called when doing server rendering. Let me know if I'm missing something here.
  Yeah, this is unfortunately the case right now. We could look at finding the actual minimal set of mutations for reordering a list; I think it reduces to [longest increasing subsequence](http://en.wikipedia.org/wiki/Longest_increasing_subsequence).
 For every policy that causes a node to not be removed from the DOM, it is making the decision to actually _remove_ some other node. It's impossible to know which ones the developer intends on being removed from the DOM and it's unfortunate that the DOM's API doesn't provide a better way to perform reordering without side effects. But maybe we can create a way to mark a node as the "pivot" point, where all reorderings occur "around" it.
  The `updatedChildren[j].parentNode.removeChild(updatedChildren[j]);` line below can fail if (1) we're moving/moving the same node twice or (2) the node we're looking for is gone completely. This makes it easier to distinguish between the two cases.

Perf shouldn't be a concern here because this is DOM code and invariants are fast in comparison.

Test Plan: grunt test
 (cc @joelburget @jacktoole1)
  I'm guessing this is a dupe of #1169 -- can you try adding `React.initializeTouchEvents(true);` before rendering anything to confirm that this is the case?
 Ahh, I believe this is because the touchstart listener in our [MobileSafariClickEventPlugin](https://github.com/facebook/react/blob/master/src/browser/eventPlugins/MobileSafariClickEventPlugin.js) doesn't ever get attached. I'll add a note on that issue and close this one though -- as a workaround you can set the CSS style `cursor: pointer;` on the element and iOS Safari will trigger the click event.
  @jkimbo's right. For before props change, see [componentWillReceiveProps](http://facebook.github.io/react/docs/component-specs.html#updating-componentwillreceiveprops). Closing this! =)
  Thanks for taking the time to hunt this down. That said‚Ä¶

Can you be more specific about your issue? Why is the document different in your use? We're pretty unlikely to take a change to a core module just to make jsdom work (especially since we don't currently have this problem using jsdom). This is pretty performance sensitive - we cache the node very intentionally (we would otherwise be creating a new empty node for a lot of React updates).
 I would believe that we are supposed to use the right document when creating nodes.
  @jenil27 Here you go #2252, now bug zpao if you want it faster :)
 #2252 was merged, will be in 0.12
  Good catch. If #1358 and #1363 don't fix this (guessing they won't) then I'll fix this afterwards.
 Fixed by #1363.
  Ops, thanks!
  Just fixed by #1410. :)
 I like that you're living on the edge @steadicat :thumbsup: 
 lol
  I think this probably makes sense; you could imagine a different factory that took key and ref separately from the props.

ReactPropTransferer/cloneWithProps still knows about `key` and `ref` but otherwise, React core doesn't look inside props now.

Test Plan: grunt test
 @sebmarkbage 
 Had this idea in the shower half an hour ago, let me know if I'm crazy.
 I've wanted to do this for a while. In fact, the first key implementation was on the component. We have some code to update that reuses or assigns keys to props though. The key should probably get a membrane warning so that if someone tried to mutate it, we catch it.

The key definitely makes sense since it conceptually lives outside of the component itself. I'm not sure if the ref should actually be a prop. When it's tied to the owner it definitely makes sense, but if refs are first class, maybe not...?

This goes in the opposite direction of another idea which is to unify the descriptor and props objects. They could be one and the same to avoid one object allocation.

The idea of unifying them might clash with a static type system which expects the props object exactly match the explicit type annotation of that props object. As long as the type annotation is allowed to be a subset of props on the actual object, it should work.
 I'm pulling this in but as part of a larger descriptor diff. I based it off this PR though.
 I think 5aab0bddaa9dd2684049194a2488d57517d89cae is what @sebmarkbage was referring to.
  Sorry, not quite sure what you mean. Could you elaborate a little bit?
  Do you have a repro? I don't think invalid nesting should cause this error.
 I don't believe browsers will do that for `<a>` (though they will if there are nested links). But I'm confused because I don't believe the newly-created elements will have data-reactid attributes at all.
 Here's a demo showing that data-reactid shouldn't end up duplicated in that case:

http://jsbin.com/racecimo/1/edit

Let me know if you see otherwise.
 Curious, thank you.
 Another possible cause of this error (just writing here for posterity):

React receiving events on elements that have been removed from the DOM. This shouldn't happen unless there is a bug in React; it happens in 0.9 and 0.10 due to a React bug. The issue has been fixed in master (in c62c2c59bb49c735cafd8f8d78b81bb449e3948e and 3e34739cb9148c76f0a338ab694f8963d84b1c56) and will be in the next release.
 See also #101.
 I just ran into this issue, it was indeed caused by invalid nesting, e.g. 

``` html
<a>
  <div>
    <a></a>
  </div>
</a>
```
 Some love for #1987 perhaps :)
 @macqm Are you pre-rendering and perhaps rendering the same static markup to two different places?
 @macqm Find the reactID mentioned, it's most likely due to invalid nesting `<p><p /></p>` and things like that.
 @macqm Do you have any repro I could look at? I'm assuming it's the external library that is mucking with the DOM. PS. Nesting divs is fine, p is not, same with div inside p, etc.
 @macqm That's a common issue on non-linux environments, case-insensitive filesystems and a bundler which doesn't warn. :)
 @cmwelsh #3467 should help with that in the next release.
 This error message can be caused by a number of things, which are mentioned in these comments. Many are due to invalid nesting which we now have a warning for in master.

@petilon The specific issue you mention is the same as #3790, where we're tracking it.

I'm going to close this issue; if anyone encounters this error with a new cause, please open more specific issues.
  Right now the way the file are sent via the fb.me link is a bit hacky. We have a plan of action to make it better by supporting http/https, do not redirect, use a domain that's less likely to be blocked ... Just haven't gotten around to do it yet. In the meantime, you can use CDNJS.
  Unfortunately, this is hard to fix right now but it should be easier after some upcoming refactors that @sebmarkbage is planning.
  Your code works fine for me in this example:

http://jsbin.com/javekise/1/edit
  Right now if you write

``` js
var editor = React.renderComponent(<Editor />, el, function() {
  // ...
});
```

then `editor` isn't defined when the callback is called, because callback is (currently) called synchronously. The component instance is available as `this`, but that's not obvious. Perhaps we should always call the callback asynchronously here.

cc @jacktoole1
 In the context of a setState, `this` makes more sense:

``` js
this.setState({monkeys: true}, function() {
  // maybe I didn't actually want the monkeys...
  this.setState({monkeys: false});
});
```

I agree it isn't intuitive for renderComponent.
 (See also #1187.)
 Not super actionable so I'll close this out. Maybe we'll rethink the API if we add async rendering support or do other changes to batching.
  Closing in favor of #1657.
  Fixes #1392.

I think this makes sense; it's useful to be able to reorder components without rerendering them while having refs that correspond to the current indices.

Test Plan: grunt test
 Yes; the test here failed before with static0's text still `A` and static1's text still `B` because the refs weren't updated.
 Internal diff uncreated, lol.
 Just wrote #1560 which should make it easier to refactor this to make more sense.
 @sebmarkbage Can you close this out if we're not going to move forward?
 This probably still makes sense to fix if we can do it non-hacky.
 Yeah, planning on it.
  Do you want to add the appropriate pointer events to TapEventPlugin's dependencies? Otherwise I think this looks pretty reasonable. Haven't tested it.
 @steida does this solve your use case?
 React's source is already modular (and will stay that way), but there's no easy way to pull out certain parts in a build right now. Hopefully we can get React to a point where it's easier to do custom builds and to choose whether to include or not include certain polyfills, like this hypothetical pointer one. Ideally we could have a cross-browser pointer events shim that works in all browsers React supports while allowing you to bring your own polyfill if you want to use Polymer's or to save bytes if you just don't care about pointer events.
 @zoomclub We all want something more than just this division between mouse and touch. But as is evident in the latest discussion in #499, the problem is that _no one_ seems decided on what the real solution is.

The current design of React AFAIK is to stay as close as possible to HTML5, if PointerEvents become a standard then React will surely have it, but comitting to it without PointEvents becoming a standard is far from a simple decision. So for now I think we'll just have to wait and see what happens to PointerEvents.

An idea is to allow any non-standard event-handler specified on a ReactDOM-node to actually be listened to, not just standard events. That would allow people to plug in whatever polyfills/sugars they need, but it may hurt third-party components that would rarely be able to take advantage of it.
 @zoomclub You can always attach listeners yourself using `addEventListener` inside `componentDidMount`. The synthetic event system does not understand non-standard events unless you maintain your own branch with a custom event plugin.
 I'm putting a needs revision label on this until we have more discussion.
 Btw Chrome is not adopting it: https://code.google.com/p/chromium/issues/detail?id=162757#c64
 @iamdustan Interesting.
 Chrome is onboard now https://code.google.com/p/chromium/issues/detail?id=162757#c146

https://groups.google.com/a/chromium.org/forum/#!topic/blink-dev/ODWmcKNQl0I
 @sebmarkbage Now that PointerEvents seem to be gaining traction, should we go ahead and add support to React core?
 I think we need to make a major design choice soon about what we want our event system to be. The browser's naive model is clearly not enough for a lot of use cases (sliding gestures, touch responder negotation, custom bubbling rules such as through abstraction layers instead of DOM layers, etc.). Building our own event system is fundamentally incompatible with other frameworks since the delegation/ownership model doesn't interact well between subtrees. Even if we did it, other frameworks might not and we remain incompatible anyway. Maybe we need two different optional event systems. Yet, we want the out-of-the-box experience to also be nice. We're also backporting some of the event systems from React Native back to the DOM.

Essentially it boils down to the fact that the componentization of events is still an unsolved problem since there is still global negotiation needed.

Maybe we should support it for the DOM regardless, but I think there is a much bigger discussion to be had about our event strategy.
 > Maybe we should support it for the DOM regardless, but I think there is a much bigger discussion to be had about our event strategy.

@sebmarkbage Definitely, but it seems to me that you'll always have to expose the (almost) raw underlying event APIs, either directly or indirectly. There are millions of targets and none are 100% capable or even agree on the keyboard and mouse interface, so a forced standardized interface seems wholly unrealistic.

If users could componentize custom event APIs on-top of that it would be fantastic, but I imagine it's two-fold. Custom event subsystems on a per-subtree/root basis (requires some level of coordination) and event callbacks on a per-node/component basis (totally independent) that depend on either native or custom event subsystems.

So one way or another it seems to me that React won't be harmed by exposing PointerEvents the same way all other HTML events are currently exposed, it's just more of the same.
 I‚Äôm closing this PR because there doesn‚Äôt seem to be enough momentum behind it. I think we should get better at closing PRs that are low on `momentum / support_cost` number, so that is what I‚Äôm trying to do here.

Like anything, it‚Äôs a matter of prioritization. I think that a good time to revisit this would be when Chrome supports Pointer events (at the moment it doesn‚Äôt). Let‚Äôs track any future work on this in #499. I do hope we‚Äôll get this in eventually.

Thank you for your work on this!
  The problem is in your `setState` call. `setState` doesn't swap out the state completely, it creates a copy of the state with the given changes merged in. This means, if you don't give a new url property, it will keep the old one.

Could you see if adding `url: foo` into the `setState` call fixes it?
 It looks like you're mutating the this.state.twitter directly. React doesn't deep-copy state so if you want to be able to compare old and new state, you should treat everything in state as immutable and copy the object before updating it. Something like:

```
var twitter = _.clone(this.state.twitter);
twitter.url = ...;
this.setState({twitter: twitter});
```

using underscore's [clone](http://underscorejs.org/#clone). (You could also use jQuery's `$.extend({}, this.state.twitter)` or any similar helper.)
  This comes from my discussion with several people around animation, but I feel like it's important enough to warrant its own issue.

We already insist that `render` should be a pure function of `this.props` and `this.state`. How about taking this further and pass those in CompositeComponent? This way we can write:

``` html
render: function(props, state) {
  return <div>{props.something}</div>;
}
```

While most of the time we'll still call `render(this.props, this.state)` internally, with this we will be able to do `render(somePrevProps, someTestState)` from React or even from the user. Being able to "test the water" would be very valuable in the future. For example:

``` js
componentWillReceiveProps: function(nextProps) {
  var result1 = this.render(this.props, this.state);
  var result2 = this.render(nextProps, this.state);
  // Collection of changed stuff. Good for preparing mounting/unmounting animations or such logic.
  React.reconciler.getDiff(result1, result2);
  this.setState({...});
}
```

I've heard this can also solve some problems with pendingState? Not too familiar with the issue.
@jordwalke @sebmarkbage @petehunt 
 As you mentioned in the end. This API change shouldn't be considered in isolation, but with all other life cycle events and how this correspond to prev/current/next at every stage.
 cf.

#122 Pending state updates may be confusing
#629 Store pending state updates directly in this.state
 Note that there's a potential hazard here if `this.state` were the pending state. Callbacks that refer to `this` can be updated with new references locally, but closures cannot. Closures cannot get access to pending state. Likewise this issue can occur if we had partial reconciliation.

``` javascript
render() {
  return <div onClick={() => doSideEffect(this.state.x)} />;
}
// is not equivalent to
render() {
  var x = this.state.x;
  return <div onClick={() => doSideEffect(x)} />;
}
// or
render() {
  var state = this.state;
  return <div onClick={() => doSideEffect(state.x)} />;
}
// or
render(state) {
  return <div onClick={() => doSideEffect(state.x)} />;
}
```

I think that it's possible to have the same issue with this.props and this.refs but don't have a case off the top of my head.
 Is this still alive? @sebmarkbage you can just pass a state reference to the callback and tell them to use that instead right? That's what tween-state does. Breaks a lot of code though.
 @yaycmyk Yeah, let's call that "data management".  The term "referential equality" implies something very specific, and this is not that.
  This looks great, thanks for updating!
  (React assumes that you don't modify Object.prototype and I'm not sure why you would pass something other than a plain object here‚Ä¶)
 Note that jQuery doesn't support modifying Object.prototype:

http://contribute.jquery.org/wont-fix/#object-prototype-issues

I'm inclined to do the same.
 JS as a language and built-in power features are going more and more towards hasOwnProperty checks to be defensive. (Like Object.keys) so I think we should do the same. In this case it doesn't have a cost.
 Can we get a rebase of this PR and make sure that the Travis CI build passes the build. Thanks.
 Closing due to inactivity, but happy to take this if it gets rebased with passing tests.
  To be fair, this entire page is more or less designed to run arbitrary JavaScript for testing purposes and there's no way to change the value of that text box via query string. In addition, most implementations of Markdown are designed to accept arbitrary HTML, so I'm going to call this a "won't fix".
 (Note that you don't need the `">`; typing `<img src=x onerror=alert(1)>` is enough.)
  We've had some discussions internally about this, and the consensus is that people should assume that `shouldComponentUpdate` is a hint that the reconciler is permitted to ignore the hint.

Related to https://github.com/facebook/react/issues/2517#issuecomment-169838716
  Do you mind signing [the CLA](http://code.facebook.com/cla)?
 Thanks!
  Currently React's mixins allow multiple mixins to implement the same method in multiple mixin, if it's a whitelist. We would like to decouple the mixin system from React and therefore we need a way to solve it without a whitelist.

The idea is to have every mixin call super() to allow predictable chaining.

The mixin(...mixins) function would essentially create a new prototype chain with each mixin's set of functions stacked on top of each other in order. An object is treated as a prototype. A function is treated as a class/constructor and gets all their static methods + their prototype merged.

``` javascript
var A = {

  componentDidMount() {
    super(); // This will end up calling an empty function, placed by mixin()
    console.log('A');
  }

};

class B {

  static getQueries() {
    super(); // This will end up calling an empty function, placed by mixin()
    console.log('B')
  }

  componentDidMount() {
    console.log('B');
    super();
  }

}

class C extends mixin(A, B) {

  static getQueries() {
    super();
    console.log('C');
  }

  componentDidMount() {
    super();
    console.log('C');
  }

}

C.getQueries(); // B, C
new C().componentDidMount(); // B, A, C
```

We can issue warnings when the mixin function is called and some of the overlapping methods are missing super calls.

Solvable but confusing/complex issues:

``` javascript
class C extends mixin(A, B) {

  // This state intializer overrides the state initializer in the base class.
  // The current React class system merges the two. This is also not valid ES6
  // since we don't have property initializers yet. This is based on the
  // TypeScript syntax.
  state = {
    b: true
  }

  componentDidMount() {
    // You forgot to put a super call here but there's no warning since
    // the mixin logic happens before this class is created.
  }

}
```

To be clear, mixins is an escape hatch to work around reusability limitations in the system. It's not idiomatic React.

Idiomatic React reusable code should primarily be implemented in terms of composition and not inheritance.
 That's a good point. I don't think there is a way to create composable interfaces in this way in TypeScript. Do you see any alternatives?
 Luckily mixins are completely optional and you can use whatever system you want. Presumably TypeScript would have to build in similar features and you can just use that.

They're even frowned upon when they're overused so they're completely optional.

_handwave_, _punt_
 @theporchrat The code in OP is based on ECMAScript proposals (although changing from day to day it seems).
 @theporchrat The `mixin()` showed by sebmarkbage would probably not be exposed by React and if it was, it would be very simple and not in any way tied to React core. But it's likely that React won't go the way of classes, https://github.com/reactjs/react-future/blob/master/06%20-%20Returning%20State/02%20-%20Module%20Pattern.js
 React Core itself is not opinionated about how you build your classes. Generally we prefer composition. This is already possible using components.

This proposal is about providing feature parity with current React classes. It's not an encouraged pattern.

Native trait features in the ECMAScript language will likely have similar feature sets.

> On Jul 20, 2014, at 2:11 PM, theporchrat notifications@github.com wrote:
> 
> ooo that is interesting thanks for the link
> 
> ‚Äî
> Reply to this email directly or view it on GitHub.
 @pspeter3 0.12 doesn't support classes in this way yet, but once we support ES6 classes then `type` will be the class, not the factory.
 @pspeter3, no you will not need to do that. `type` will be the ES6 class.
 Yes, they are scheduled for 0.13. In the 0.13 release, we will not ship this mixin helper. It requires `toMethod()` support which is unusual in current ES6 transpilers. You will need to roll your own or use `createClass`.
 @rtorr We are moving towards native ES6 classes as the "modern" way of doing things.  That said, many people (including a large portion of Facebook) will continue to use React.createClass for some time, so both options will be supported in the near term.
 Even without toMethod it could be built like this: https://gist.github.com/sebmarkbage/fac0830dbb13ccbff596

However, I think that making composition easier is a higher priority than making arbitrary mixins work.
 @jedwards1211 Unlikely. We'll probably recommend using a ES-future syntax feature when it lands: https://facebook.github.io/react/blog/2015/01/27/react-v0.13.0-beta-1.html#autobinding.
  We actually had a discussion about this in an internal group @ FB yesterday with other people who were confused by this behavior. It is intentional for the reason @syranide mentioned, to allow a way to override the default value. While `null` and `undefined` are quite similar, they really do have discernibly different meanings - `null` is an intentional value while `undefined` is not specified.

So I'm going to wontfix this, but if we backtrack on this, I'll let you know! Thanks for jumping in with a patch though :)
  Either of these can work.
 I'm don't think that'll completely work; React will still assume that you won't remove its root element. If you add another `<div>` wrapper around `div.g-page` there it should be fine.
  Ah, this is because React doesn't let you unmount the HTML `<title>` element. I don't believe there's a workaround right now, sorry.

cc @petehunt 
 Fixed by #1559.
  Does #499 cover this? (also cc @joshduck who I think did something here at some point)
 Can we close this issue and keep going in #499 ? We should just go ahead and adding these. A lower-level polyfill might be able to take over if we just allow the events to be added.
  HTML entities are interpreted within JSX attribute values. You can use `&amp;` or enclose the string in curly braces to use ordinary JS string parsing:

```
<Hello name="Jhon &amp; Mary" />
<Hello name={"Jhon & Mary"} />
```
  The ref API is broken is several aspects.
- You have to refer to this.refs['myname'] as strings to be Closure Compiler Advanced Mode compatible.
- It doesn't allow the notion of multiple owners of a single instance.
- Magical dynamic strings potentially break optimizations in VMs.
- It needs to be always consistent, because it's synchronously resolved. This means that asynchronous batching of rendering introduces potential bugs.
- We currently have a hook to get sibling refs so that you can have one component refer to it's sibling as a context reference. This only works one level. This breaks the ability to wrap one of those in an encapsulation.
- It can't be statically typed. You have to cast it at any use in languages like TypeScript.
- There's no way to attach the ref to the correct "owner" in a callback invoked by a child. `<Child renderer={index => <div ref="test">{index}</div>} />` -- this ref will be attached where the callback is issued, not in the current owner.

I think that the solution must ultimately be some kind of first class ref that can be passed around. These refs can be chained to create multi-owner refs very efficiently. By creating this object for the ref, we can also get rid of keeping track of owners on descriptors. Saving perf for the common idiomatic case of not using refs.
A secondary goal, which may or may not be as important is the idea of making the resolution of refs asynchronous so that you can respond after a batched flush/reconciliation.

The concept of a first class ref is basically a reference to an object that doesn't exist yet. Luckily there's a first class notion of this in the language already... It's called a Promise.
You create a new Ref instance which is just Promise object that will eventually resolve to the actual instance.

``` javascript
class Foo {

  myDivRef = React.createRef();

  handleTick() {
    this.myDivRef.then(myDivNode => {
      this.setState({ width: myDivNode.offsetWidth });
    });
  }

  render() {
    return (
      <C tick={this.handleTick}>
        <div ref={this.myDivRef} />
        <CustomComponent context={this.myDivRef} />
      </C>
    );
  }

}
```

Since this builds on top of Promises we would be able to get async/await language features that allow us to do something like this:

``` javascript
  async handleTick() {
    this.setState({ width: (await this.myDivRef).offsetWidth });
  }
```

This solves all those use cases AFAIK. The asynchronous API is a little difficult to deal with. But it makes it less weird than the alternative when batching is involved.

An unsolved problem is that refs can update to point to a different instance. In that case the Promise would need to be re-resolved. This is why Promises are not good enough and we ultimately need something like an Observable that can handle multiple values. We can't wait for that spec though. Maybe we just allow our promises to be reset and if you call then(...) again, you get a new value?
 On top of this we could build a dynamic RefMap that lazily creates ref promises. This allows easy creation of refs for sets of data. It also makes a nicer upgrade path for existing code that assumes that these are just strings:

``` javascript
class Foo {
  refs = new React.RefMap();

  handleTick() {
    this.refs.get('myDiv').then(myDivNode => {
      this.setState({ width: myDivNode.offsetWidth });
    });
  }

  render() {
    return (
      <C tick={this.handleTick}>
        <div ref={this.refs.get('myDiv')} />
        <CustomComponent context={this.refs.get('myDiv')} />
      </C>
    );
  }
}
```

We also probably need to provide a synchronous API as an upgrade path:

``` javascript
  handleTick() {
    var myDivNode = this.myDivRef.doExpensiveWorkRightNowAndLetMeHaveMyNodeNow();
    this.setState({ width: myDivNode.offsetWidth });
  }
```

Similarly we need this for ref maps.
 This makes a lot of sense to me, though I guess I'm not totally convinced of the need for it to be async. I'd expect most uses to be in mount-ready handlers though I suppose it's possible for a DOM event handler to be called when an update is pending.
 Do you have a plan for what to do with descriptors that are mounted in more than one place?
 Descriptors that are mounted in more than one place should not have refs I guess. Warning maybe?

Not only DOM events but we want to batch timers and data fetching events too. The goal being that flush only happens on rAF. Therefore any callback could have the refs pending.

Additionally the behavior of didMount and didUpdate handlers are currently undefined in regards to when they fire in relation to their children and therefore refs. For example componentDidUpdate is not guaranteed to fire after the children has fully mounted.
 Actually in the current state, since they're queued on the DOM generation queue, I guess they're guaranteed right now. We may be able to preserve this behavior. Not sure.

An alternative API would be to force refs to be extracted in just those two lifecycle hooks. Then you can store them where ever. That might lead to memory leaks.
 On a second thought, didMount/didUpdate is not enough to keep ref handles up-to-date. Since a child can choose to unmount/remount that descriptor at any point. Then those events are not enough. Potentially the ref life-cycle callback could be connected to the owner instance but that's not as flexible as a first class ref I guess.

However, if you want something like a resize handle when a child is actually mounted/remounted it might be troublesome to set up a component-level subscription on the child. I.e. you have to call .then at some point before that. However, maybe that should be handled with a more explicit callback?
 Does this mean that if a child never mounts its argument, the ref will "hang" and never resolve? That sounds odd to me.
 Yea...
 I suppose the promise should be rejected if the next flush doesn't lead the ref to be resolved.

``` javascript
  handleTick() {
    this.refs.get('myDiv').then(myDivNode => {
      this.setState({ width: myDivNode.offsetWidth });
    }, error => {
      this.setState({ width: 0 });
    });
  }
```
 Presumably the same thing should happen if a ref isn't used at all? I guess that would make a reasonable API, but unless I'm missing something, each ref object won't know which component it belongs to (alternatively, a component won't have a list of all of its refs) and thus can't know when to mark itself as rejected.
 Every ref object can go from resolved to unresolved and back. We track that in the same way as attach/detach ref. E.g. `props.ref.attach(this);` or if it's unmounted: `props.ref.detach(this);`

The act of calling `ref.then(...)` can register that ref as "pending". After the next flush is done, all the pending refs gets their callback invokes.

``` javascript
for (let ref of pendingRefs) {
  if (ref.hasAttachedInstance) ref.resolve(); else ref.reject();
}
```
 With this API you wrote out, there's no way to get a component instance, only a DOM node; this means you can't call methods, etc. on child components. Intentional?
 Actually I had imagine that a component instance of a ReactDOMComponent could become the DOM node. This is still controversial though. The alternative is just an empty object with a getDOMNode method on it.
 Well sometimes you want a ref to a composite, right? I haven't thought about it much but that sounds like an odd plan to me. The uniform `.getDOMNode()` across all types of browser components right now is pretty nice.
 Yes, a ref to a composite would be a still be the composite instance, unless it's a stateless component which would not be allowed to have a ref or resolve to null.

`.getDOMNode()` is a problematic API since it leaks internals of a component and drills down through multiple levels of abstractions without them explicitly allowing that.

It is expected to return a single node but what if your composite is returning a fragment of multiple nodes?

It also needs to go on the base class of every composite, even ART composites, render tree composites, MarkDown composites or whatever. Unless every component that wants it is required to opt-in to a special DOM base class. That doesn't guarantee that your ref has the method though.

I think a much better API would be `React.getDOMNodeFrom(instance)` which would work even if the instance is a real DOM node (it would just return itself).
 In any case, we need to figure out what to do with these wrapper components -- if DOM node instances diverge from composites, it's going to be odd when you write `<input ref={this.myInput} />` expecting a DOM node and you get a composite in return.
 Yea. I wonder if it can be a pass-through? So that ReactDOMInput does `<RealInput ref={this.props.ref} />`. That doesn't really make sense but something like that would be cool.
 An alternative idea... Make descriptors into ref-promises.

``` javascript
  render() {
    var foo = <Foo />;
    return <div onClick={() => foo.then(inst => inst.doX())}>{foo}</div>;
  }
```

This also provides a nice reset functionality if the ref is ever swapped out.

``` javascript
  handleClick() {
    this.foo.then(inst => inst.doX());
  }

  render() {
    this.foo = <Foo />; // ugh side-effect in render (puke)
    return <div onClick={this.handleClick}>{this.foo}</div>;
  }
```

This also works nice with multiple owners.
 What differences in particular are you concerned about?
 I've thought about first class refs. I don't think they make sense as Promises since they're stream-like (observable). I just suggested that to shoehorn them in since there was no standard for observables. However, now that I thought about it.

I realized that observable support in React needs to be implemented as subjects for callbacks. Just like the Rx proposal.

``` javascript
class Component {
  onClick = new Rx.Subject();
  render() {
    return <div onClick={this.onClick} />;
  }
}
```

This is essentially what first class refs would be if they were Observables.

However, passing subjects instead of callbacks is just a special case of callbacks which allows composability.

We have a much simpler mechanisms than Subjects in-place right now: callbacks.

Therefore I think that we should switch our first-class refs to simply be callbacks that gets passed a reference as the first argument and null when they're detached.

Which would make this:

``` javascript
return <div ref="foo" />;
```

Roughly equivalent to:

``` javascript
return <div ref={node => this.refs.foo = node} />;
```

Which makes the model much simpler and the upgrade path much simpler.

It doesn't allow siblings to communicate without a middle man, however, I think that's a feature. Not having siblings communicate is a feature of React.

This function is also easily statically typable.

In the future we can make all callback APIs also accept Subjects but that's a secondary upgrade path.

What do you think @sophiebits
 I updated react-future to include this proposal. https://github.com/reactjs/react-future/blob/master/01%20-%20Core/06%20-%20Refs.js
 I think I like it. It looks a little mutative because of the explicit assignment, but I guess it's not actually any worse than the other APIs we've written out.
 This is also inherently an imperative API because it exposes an imperative handle. Even if it's just an ID or handle. We also already effective allow people to store ephemeral state on classes.

An author should be prepared that a component class can be destroyed and restored at any given point. E.g. if we want to "hibernate" state and through away the class instance. This still allows it.
 @sebmarkbage When updating, do refs get called on every rerender? (Or maybe even if shouldComponentUpdate returns false?)
 no, just if it changes.
 So if I render `<Foo />` then render `<Foo ref={(f) => this.foo = c} />` on top of it, the ref is never called?
 No that would be a change in the ref. Just like if you change the ref name. So it should be called.
 In conventional usage though it'll be a different function each time, yeah?
 Good point. Didn't think about that. Maybe just fire if it goes from null to function?
  Thanks!
  Sorry, can you clarify what the behavior is before and after this change? The usual way to get rid of the warning is to assign array indices as keys in cases where using them is reasonable.
 Going to wontfix this as I don't think there's a real use case, let me know if you disagree.
  It's happened a few times resulting in confusion. Let's either warn or maybe allow a string (cc @syranide)
 It's a noble thought, but it does not play well with 3rd party components.

Sent from IPhone
 In addition, the point of the cumbersome name is to make you think each time you use it. Setting a global config option once won't have that effect.
 This is an old issue btw, I'm not sure where we stand on this right now. Nobody seemed opposed to #1515. I guess if we really want to enlighten people we could put a warning in the console for the first use of `dangerouslySetInnerHTML` that details all the dangers and pitfalls, that way people would be unlikely to miss it, but perhaps it would just add to the console spam.
 @sebmarkbage expressed some concern making it easier. We came to an arrangement, if only I could remember what it was...
 By wrapping it in an object you can pass the result from blessed interfaces to unblessed interfaces.

We could however also introduce innerHTML that takes a string. That would be linted against at Facebook because we wouldn't allow anyone to do manual string manipulation without going through the appropriate security channels.
 ah right, leave current interface, but also add innerHTML=string.
 I don't see any advantage to adding innerHTML; people will invariably use it to introduce XSS holes. 
 `unsafeInnerHTML` or `dangerousInnerHTML` perhaps?
 What's wrong with `dangerouslySetInnerHTML`? It sounds scary and it is.
 Sounded like they wanted a different name, also naming-wise it uses `Set` which is quite weird as it is implied for all other props.
  I believe those lifecycle methods aren't available for `<ReactCSSTransitionGroup>`. cc @petehunt to confirm.
 ReactCSSTransitionGroup is a higher-level API; if you want to do something more complicated then you can do something using the lower-level ReactTransitionGroup API. It's more or less an implementation detail of ReactCSSTransitionGroup that it uses ReactTransitionGroup under the hood.
  Fixes #1297.

onMouseEnter and onMouseLeave shouldn't _actually_ use direct dispatch, but doing so is more useful than doing nothing (and I don't think it precludes adding proper enter/leave dispatching later, either).

Test Plan: grunt test
 Did you see how enter/leave actually has its own dispatch path?
Standard bubbling to target `t` goes from root to `t` back to root.

A leave/enter from `tstart` to `tend`, dispatches `leaves` from `tstart` to the `firstCommonAncestor` but stops just one short of that common ancestor. `enters` are dispatched similarly, from the `firstCommonAncestor` to `tend`, but starting just one _after_ the first common ancestor on the path to `tend . I think I completely pulled this behavior out of thin air. But it made sense to me and we're at liberty to reimagine mouse events since this is not a standard DOM event :D
 Yeah, I saw. Enter/leave are now in the spec and I think they work the same way you did?

I didn't have great ideas for a simulation API for that though -- see #1297. I figured direct dispatch is simple and is 99% of the time what you need in a test.
 Yay or nay?
 @ryanzec Thanks for the nudge ‚Äì we had some concern over whether this is the exact final API that we want, but this is an improvement so I agree we should probably merge it.

@zpao r?
 @ryanzec Thanks for the nudge. :)
 Yes.
  Thanks! I'll get this out with the next update of the docs
  With this, multiple setState calls triggered by a componentDidUpdate handler (or similar) will be batched together, regardless of if the original setState call was in a batching context.

I also cleaned up some inconsistencies with the order of component updates and callbacks in situations where one component's update directly causes another to update.

Fixes #1147 and #983. Helps with #1353 and #1245 as well, though doesn't completely fix them yet.

Test Plan:
grunt test

Depends on #1362 and #1358.
  No. The "component" you pass to renderComponent is a _descriptor_ containing little more than a JSON object specifying the type and props of the component you want to render. renderComponent will simply update the props (and run React's entire diffing algorithm to only update the DOM with necessary changes). You'll see that the componentWillUnmount/componentWillMount methods are not called (at least at the top level) when you change the props in this way.

In fact, React.renderComponent just ends up calling `replaceProps` (in [ReactMount.js#L251](https://github.com/facebook/react/blob/master/src/browser/ui/ReactMount.js#L251)), but this is an implementation detail. Using renderComponent instead of setProps is generally preferred because declarative APIs make your app easier to reason about.
  I think I'd be okay with this. Want to send a PR?
  It's weird that `style={{margin: '42'}}` gets turned into `margin: 42px;`. I think we should only add `px` if the value is an actual number.
 Note: this isn't actually fixed, just have a warning in place.
 Yep, was autoclosed by the PR.
   :thumbsup: 
  If you have

```
{this.state.show &&
  <div onTouchStart={this.hideTheDiv} onTouchMove={...} />}
```

such that the onTouchStart handler removes the div (and maybe replaces it with another one in the same place, useful in certain draggable interactions), the onTouchMove handler doesn't fire because the events of a detached element no longer bubble to document. We should probably bind the touchmove handler when the element receives touchstart instead of delegating to document.

Sort of related to #1254.

cc @merbs @eater
 Is this in the DOM spec? It's kind of strange.
 Sorry, what's strange? Unlike mousemove, touchmove always fires on the element that received touchstart. In my limited testing, browsers happily send events to that removed element.
 You can test http://jsbin.com/gocuhifa/1 on device or in Chrome/Firefox with touch events enabled (touch down on "monkey"; it'll disappear; move your finger and you'll get an alert).
 Hmmmm maybe this isn't supposed to work:

https://docs.google.com/document/d/12-HPlSIF7-ISY8TQHtuQ3IqDi-isZVI0Yzv5zwl90VU/edit#heading=h.q2zqz8v0mja7

I sort of feel like it should still work in React just as well as it does in the browser though.
 See also the [W3C public-webevents list](http://lists.w3.org/Archives/Public/public-webevents/2014AprJun/0006.html) where I asked about this behavior.
 This question is likely related: http://stackoverflow.com/q/24537000/49485.
 https://plus.google.com/+RickByers/posts/GHwpqnAFATf also.
  Interesting. Summary: When mounting something like:

```
<div>
  <A />
  <B />
</div>
```

If B calls setState on A in B's componentWillMount, then the DOM won't be populated with A's HTML yet. I suppose the setState call should be queued until A's componentDidMount is called.

cc @sebmarkbage 
 #1363 fixed this.
  Is this supposed to be faster? My guess is it makes no difference.
 I don't think this adds much so I'm going to close it out -- let me know if I'm missing something.
  Is that not two keystrokes? I'm not sure off the top of my head why it would be called twice‚Ä¶
 Well, you can see that Mixin.initializeAll appears separately below the two "get selectionStart" calls so there are two separate updates occurring; I'm not sure exactly how you're triggering updates but perhaps you can combine them into one, which should make things faster.

It sounds like we used to maintain selection state by avoiding moving the `<input>` during reconciliation -- @jordwalke @vjeux do you know about this?
 Right -- the problem is that we don't know to save the selection until we're removing the element (or something along those lines), so we're currently proactive about it.

If you're in a React event handler, things should be magically batched for you already. If you're not, try requiring `react/lib/ReactUpdates` and then doing like

```
ReactUpdates = require 'react/lib/ReactUpdates'
x.onkeydown = ->
  ReactUpdates.batchedUpdates ->
    # all your handling inside this callback
```

and React should combine all setState calls into one.
 That's great to hear. Sorry it's not a part of the public/documented/supported API yet; we're working on making automatic rAF batching work well and I also have #1060 open to expose the batchedUpdates function.
 (I'll also remind you that if you run with NODE_ENV === "production" your code will be faster. :))
 Also, it still looks like you're running two updates? Are you triggering an update from componentDidUpdate or similar?
  It's likely that in the future we'll have this case not crash at all, but just give a warning; see #566. We'd also like to be able to show problems like this in context in the dev tools.
 @spicyj @zpao This should probably be closed now?
 :thumbsup: thanks for triaging!
  I believe this can be an automated conversion of the TextMate grammar?
 Meh, we have https://github.com/reactjs/sublime-react (which the atom one is based off of).

@orktes Thanks for taking this on! This will be helpful for many people.

For anybody stumbling on this later, the repo is at https://github.com/orktes/atom-react if you have bug reports or fixes.
  This would be really useful, thanks!
 I've left this open with the intention of coming back to it eventually. Now that I've been mucking around with Jekyll it seems like the right time‚Ä¶

How much value does this add over a Google `site:facebook.github.io/react` search? (or even a custom engine which just wraps that up (eg [this one I just made](https://www.google.com/cse/publicurl?cx=003024293540688841040:vjm4iycivi8))
 @DveMac btw, if you're on mac, React for [Dash](http://kapeli.com/dash) is available. 
 I think I'm just going to close this out. I do really appreciate the effort but I think letting other search engines handle this is the best thing for now.
  What's the issue with devtools? That's a separate release and can be used with different versions of React. I don't think we added Om specific changes in the core?

As for this change... The canonical way would be to create a unique function for each type and assign it to .type. The function doesn't have to be a React component (there are some prototype checks right now but they're going away). It just needs to be a function that can return a React class instance.

Would you be able to assign such a function instead?
 Right but you still have the concept of multiple types. Can you create a unique function that returns the same React component every time?

``` javascript
var GenericOmComponent = React.createClass(...);
...
function tag(descriptor, type) {
  var fn = type.fn || (type.fn = function(descriptor) { return new GenericOmComponent.type(descriptor); });
  descriptor.type = fn;
}
```

Btw, you should get on `master` since we'll jump to `0.11` soon.

`shouldComponentUnmount` doesn't conceptually make sense since gives and instance the power to destroy itself. It should be destroyed when the reference is destroyed. That can be implemented as a wrapper though.

``` javascript
var OmLowLevel = React.createClass({ ... });
var OmWrapper = React.createClass({
  render: function() {
    return OmLowLevel(merge(this.props, { key: this.props.__type__ }));
  }
});
```

You can also just prepend all your keys with the type.
 If you have a separator, prepending should be fine. That's how we already collapse key strings.

``` javascript
// Assumes uid never returns a string containing '|'
key = uid(type) + '|' + userKey;
```

A descriptor is what is new in master and coming 0.10. A simple object representing what will be mounted but is not yet a real stateful instance.

The type argument would be whatever you use to identify a type you're providing. If it's not an object, perhaps you can store a reference in a map.
 Yea, we'll kill that check though. It'll be `descriptor instanceof ReactDescriptor` in the next release.
  Are you sure you're on 0.10? #1193 should've fixed that and appears to be in the release for me.
 Make sure you're using 0.10.0 of JSX as well, whether that's JSXTransformer.js or react-tools.
  I understand where you're coming from, but please don't ever do what you have there. We made this mistake in one of our examples for a while and it's just really bad. By doing this, you'll actually end up recreating all of your nodes on every render because the key will be different. While it might not hurt you today, it will one day.

A couple other points:
- key is not really about performance, it's more about identity (which in turn leads to better performance). randomly assigned and changing values are not identity
- We can't realistically provide keys without knowing how your data is modeled. I would suggest maybe using some sort of hashing function if you don't have ids
- We already have internal keys when we use arrays, but they are the index in the array. When you insert a new element, those keys are wrong.

Now that said, they key warning can be pretty annoying. If it's driving people to end up with solutions like you have here, then we should probably spend some time thinking of a better way to do this.

tl;dr: "no"
 > I agree a random key is the worst key one can use, but it's still better than no key at all.

If no keys are provided, React uses the index in the array which is almost always better than a random key.
  This throws an error in IE8 because the `<noscript />` tag doesn't exist once rendered into the DOM:

``` js
/** @jsx React.DOM */

var Hello = React.createClass({
  render: function() {
    return (
      <div>
        {this.props.x ? <noscript /> : null}
      </div>
    );
  }
});

React.renderComponent(<Hello x={true} />, document.body);
React.renderComponent(<Hello x={false} />, document.body);
```

Thanks @matthewwithanm for pointing out a version of this.
 Hmm, this is going to ruin some best laid plans for #888.
 (I assume you mean #1058.)
 Fixed internally to use `script`.
 @matthewwithanm ugh sorry, I meant for what spicyj was referring to
 @spicyj @zpao Fix for this landed some time ago.
  I don't love the name CAN_BE_MINIMIZED. I'm leaning towards either HAS_OPTIONAL_BOOLEAN_VALUE or CAN_HAVE_BOOLEAN_VALUE, though both of those are longer‚Ä¶
 I agree about the naming. I could also be down for `HAS_BOOLEANISH_VALUE`? `HAS_COMPLEX_BOOLEAN_VALUE`?

All of our uses of "boolean" here are kind of misnomers, but at least what we already have explains how they are used.

What if we stepped back and maybe we can not create a new flag for booleanish, but we make it `HAS_BOOLEAN_VALUE | SOMETHING`? I'm not sure that makes sense, but wanted to know what you guys thought. Does it end up opening up for more possibilities? It it more complicated & confusing?
 Also, we'll need CLA signed before we can end up merging (once it's all good to go). If you could do that at some point, we won't have to block on that later. https://code.facebook.com/cla
 Sorry that wasn't me saying you _should_ do it that way, I just wasn't sure if you had considered that route and if it might result in more options in the future. We can always change code though if we need to, so let's pretend I didn't say anything.

If you could address @spicyj's comment, and then I'd like a couple more tests here because it's such a weird case. I just want to make sure our other falsey behavior stays correct. undefined & null both result in empty string and 0 should be stringified.
 Oh and I talked with @spicyj and we both begrudgingly like `HAS_BOOLEANISH_VALUE`. Let's juse that.
 Thanks!
 Sorry for the delay. Would you mind rebasing? We just added another new flag in 5c9d616735c4c5c31fb68b789c8c6f3afeae9592 (sorry we didn't get yours in first!)
 Thanks!
 Good point. I don't think we can really guard against it and I'd rather not add non-standard attributes. `download` is new to HTML so let's see what happens as usage picks up.
  Well, I'm not sure we'd block on lack of browser support for parts of a spec. IE also doesn't support things like `<video>`. At that point it'd be up to the product to decide their own level of browser support. What does support look like for other browsers?
 You have a couple PRs up so let's get a CLA. Can you go through this - https://code.facebook.com/cla?
 This has gotten stale (sorry for the long delay). You can now use any tag names, and we'll hopefully be rid of the attribute whitelist soon.
  Makes sense. I didn't realize there were attributes like this.
 Totally makes sense. Want to give it a go?
  No problem; it's easy to see that only the immutable tests are failing. Also we'll try to keep the tree green. :)
 @irae can you sign the [CLA](https://code.facebook.com/cla) please?
 Sorry nvm, got it
 Thanks!
  I think this looks good, though I'd probably call it ReactDOMNoScript.
 Yeah... maybe you could argue that textarea is one word though. I don't feel strongly.
 Going to close this out for now because there's not much improvement we can make here immediately. Thanks for sending this in though! I think we may be able to make this really work in the future after some upcoming refactors of the core.
 As a workaround, you can write

```
<div dangerouslySetInnerHTML={{__html: '<noscript>...</noscript>'}} />
```

and React shouldn't get confused even if the noscript disappears.
  Closing as a duplicate of #669.
 Oops, not a dupe of #669.
 From the small amount of research I've done, it's not trivial to detect the end reliably. Perhaps just waiting the length of the transition duration is the best approach here ‚Äì though I'm unsure if you run into lots of problems with that being out of sync with the actual animation.
 Yeah, this is unfortunate and something we don't have a great solution for. Khan Academy's TimeoutTransitionGroup has worked for several people in the linked issue #1707:

http://khan.github.io/react-components/#timeout-transition-group
 TimeoutTransitionGroup, like CSSTransitionGroup, uses TransitionGroup to do CSS animations. If you're triggering them by hand there's no reason to use TimeoutTransitionGroup.
 Tracking @ccorcos request as https://github.com/facebook/react/issues/4465 (obviously he already knows that; I'm just linking the threads for future reference)
 Going to go with #4561 I think.
 @oozaa That was a separate issue which should also be fixed.
 In 0.14 RC you're asked to specify durations, so this is fixed.
 ReactTransitionGroup itself shouldn't have any issues since it doesn't have anything to do with transition events.
  Based on that bug, this will likely not be fixed in blink for a couple years :/

`MUST_USE_PROPERTY` and `MUST_USE_ATTRIBUTE` effect how changes are applied. For properties, we just do `node.scrolling = value`, for attributes we use `node.setAttribute('scrolling', value). When unspecified it means both should work (because the DOM is super consistent, lol) and we'll use whichever we think is faster. Currently that's property access. We don't have automated tests for these yet, so the best thing to do is actually use the component and property (I usually modify an example), and make sure when you change the value in render, the DOM is correctly changed.
 Also, can you sign the CLA? https://code.facebook.com/cla
 Pulling in now. I confirmed that both `node.scrolling = value` and `node.setAttribute('scrolling', value)` work so there's no need to specify.
 Thanks!
  Hey, thanks for submitting this. I looked into it and though this error is confusing, it's actually due to your use of `tr` elements nested directly in `table` elements -- the browser adds a `tbody` which confuses React and eventually results in this error. If you add a `<tbody>` around the rows, the error goes away. (In addition, you shouldn't be nesting a `<span>` directly within a `<table>`.) I expect we'll be able to fix this error eventually but it won't happen immediately since there's an easy workaround.

I'm going to close this out because your proposed fix still isn't quite what we want but I just filed #1323 to keep track of this bug.
  Thanks!
  Chromium (and I think historically webkit) actually deviate from spec here and add the hyphenated versions in the style object.
 We're planning to add a warning for this (#932).
  Filed in the devtools repo - https://github.com/facebook/react-devtools/issues/32, let's move any further discussion there.
  I'm not quite sure what you mean. Could you provide a code sample?
 I see, you want to traverse the _output_ of the render function, which is quite different from `this.props.children`, which is an input that you could do anything with (it's no different from other props except for the little bit of sugar when creating components).

It's hard to say for sure without a more specific example, but you may want to use [refs](http://facebook.github.io/react/docs/working-with-the-browser.html#refs-and-getdomnode) which allow you to grab a reference to a mounted child component if you need it. This mailing list thread might also be interesting to you: https://groups.google.com/forum/#!topic/reactjs/z7xzqcIwOUg.
  This has come up a bunch, it might be time to just do it.
 Might make sense to wait to do this until after @sebmarkbage's inverted-control stuff.
 Closing in favor of #1711 which solves this problem and actually has a concrete API proposal attached.
  Thanks!
  @sebmarkbage - do we want to enable this?
 It's valid to have strings as props (that's how we do ReactTextComponent now). Ideally it should also be valid to have non-components/strings as children. This also makes static type systems more difficult to support.

I feel your pain though. I want to find a nice solution to this but this will break stuff.
 I'm confused. Disregarding the static typing argument, this shouldn't break any existing code and only interacts badly with object maps as children, where you still need to pass `null`. (And I'm assuming from the monitorCodeUse that you're looking at getting rid of that?) Individual props can be strings, but the `props` object shouldn't be a string. String children will still work here.
 props is basically what gets passed through to the constructor. It can be of any type. It's currently used by ReactTextComponent for strings. I guess we could put a limitation on that but it removes an option value for later.

Children can be any object. They don't have to be ReactDescriptors. One reason we're considering getting rid of object maps as children is because then you can use the ReactChildren helpers with any arbitrary object. In that case, even ReactDescriptors would be arbitrary objects instead of inheriting a flag.

Regardless if we keep object maps or make ReactDescriptors arbitrary objects, the first argument is ambiguous. This makes for a bad API since it can subtly vary depending on what type of components you pass:

``` javascript
div(this.props.set[0], this.props.set[1])
```

It could also mess with the perf if the hidden types aren't stable and we rely on dynamic checks (which themselves has a perf cost). I'm very hesitant to introduce method overloading in a dynamic type system. In fact, a lot of the working being done is to tighten up the type system to make it more predictable.
 Makes sense. (Sorry, I misunderstood what you said about ReactTextComponent.)
 Sometimes I wish functions allowed undefined arguments just like arrays: `[, childA, childB]`

``` javascript
div(, div(), div())
```

That's probably still not very nice. :)
  Thanks!
  Should have said this before too, but can you rebase? Things have changed a bit so this doesn't apply
 Still trying to figure out what to do with this one. Jest mocks functions so `mixins: [bla()]` fails unless you `dontMock` it. Sometimes there are too many things to `dontMock`. Can't always call `autoMockOff()` either because yeah, existing tests. We'll see.
 We need to clean that up in our tests. This is a problem with jest and silently failing seems like a terrible testing strategy.
 @sebmarkbage Anything we can do here? #2687 is another request for this.
 Meh. Let's just pull it in. FB's existing tests failing isn't a reason to block this. We'll have to fix our shit.
 @andreypopp Mind rebasing? This has since moved to src/class/ReactClass.js.
 Closing due to lack of activity, and mixins are now a legacy feature that we'd like to avoid changing unnecessarily.
  Is there a reason you can't perform your animation on componentDidMount?
 You can already use ReactTransitionGroup for a single child, correct?
 Can you give an example of something that doesn't work? You can transition from 0 children to 1 child and vice versa; the animation hooks will be executed at the proper time.
 Closing -- let me know if you're still having problems.
  I believe this should be fixed at a higher level; we're passing operations to DOMChildrenOperations in a way that isn't expected.

My #1157 fixes one of these causes. Can you try applying it to see if your problem is fixed? You might also be running into #1232 which I haven't had a chance to fix yet.
 Well I'd be interested in seeing a repro if you can produce one. Ideally an isolated one but if you can't reduce it I'd be interested in looking at a live app showing the problem if you'd be able to send me the link. (You can see that the reduced repro case in #1147 was fairly complicated!)
  > could be a result of a typo
> ...
> (by a mistakte)

_slow clap_
 We had a PR to fix this (https://github.com/facebook/react/pull/1305), but decided to abandon it as per https://github.com/facebook/react/pull/1305#issuecomment-99318251.  Mixins are mostly legacy and we aren't really adding things to them.

Recommended reading: https://medium.com/@dan_abramov/mixins-are-dead-long-live-higher-order-components-94a0d2f9e750#.nyku5vbmg
  This agrees with what @ide suggested in #699 (edit: #669). 
 @markijbema Can you add the missing `e` argument and make sure the code works as intended? Guessing this didn't get tested properly because it should have thrown a ReferenceError as it is now.
 @chenglou - you've been looking at this transition stuff, can you tell if this is still needed?
 I believe this is still correct.
 And I'm finally coming back around to this, sorry!

@markijbema Could you sign the CLA? https://code.facebook.com/cla. Then this should be good to go.
 Oy, that took too long, but it's in. Thanks for your infinite patience!
  ViewportMetrics is used to normalize pageX and pageY on mouse events: [SyntheticMouseEvent.js#L63-L73](https://github.com/facebook/react/blob/9ef6156d5cdb8006d193eceac2f6b4fae80e7dcd/src/browser/syntheticEvents/SyntheticMouseEvent.js#L63-L73). Perhaps ironically, it was created to prevent synchronous layouts during mouse event handlers.
 Well, `ViewportMetrics` is only used for IE8 and possibly other _very old_ browsers (http://www.quirksmode.org/mobile/tableViewport_desktop.html), so we should be able to just disable it for all other browsers and everyone is happy right? (Could still be optimized slightly for IE8... if anyone cares)

Also,
https://github.com/facebook/react/blob/master/src/browser/ui/ReactEventListener.js#L65
https://github.com/facebook/react/blob/master/src/browser/ui/ReactEventListener.js#L165

That makes no sense at all to me, `refresh` does not take an argument, yet we get the scroll position and provide it as an argument. Instead, `refresh` gets the scroll position internally and uses that? So we call `getUnboundedScrollPosition` twice, but only use the result once (also, this should be broken for events inside iframes, for IE8).

Also2,
https://github.com/facebook/react/blob/master/src/browser/eventPlugins/TapEventPlugin.js#L54
I'm pretty sure any browsers that supports touch, also supports `pageX`.

cc @spicyj
 I agree that we shouldn't be tracking it in other browsers if we don't need it. I don't know if there's a way to predict whether we'll have .pageX and .pageY before mouse events actually come in.
 @spicyj `document.createEvent && 'pageX' in document.createEvent('MouseEvent')` :)
 Another idea being just let resize/scroll set a flag, when a mouse event is created, if the flag is set, update viewport metrics. That way we only update it when needed, but could potentially cause a reflow if there are other events before it (very unlikely though I imagine).
 @lo1tuma Is that your site? If so, you can try commenting out the logic in refreshScrollValues to see if it makes a difference. If it does, I'm happy to prioritize @syranide's #2271 and try to get it in.
  We're going to replace that page with the wiki; feel free to edit it directly:

https://github.com/facebook/react/wiki/Complementary-Tools
  Closing in favor of #1657.
  Yeah, unfortunately mouseEnter/mouseLeave don't get simulated properly at the moment due to their unique bubbling situation. The biggest blocker here is picking a good API, I think.

Maybe just `Simulate.mouseEnterLeave(from, to)`?
 Yes, it's due to bubbling. If you have the DOM structure

```
<A>
  <B><C /></B>
  <D />
</A>
```

and your mouse moves from C to D, then C and B receive mouseleave events, D receives a mouseenter event, and A receives nothing. All other events bubble up to the root.

Perhaps it's good enough to just make simulated mouseEnter and mouseLeave events not bubble at all.
 (As a workaround for now, you can use SimulateNative.mouseOver and SimulateNative.mouseOut (making sure to specify relatedTarget appropriately on each) and together they will cause React to fire onMouseEnter and onMouseLeave events.)
 No update so far? Maybe some workarounds?
 @Kureev This was fixed in #1366 in April as you can see a few messages up; it'll be in the 0.14 release. If you search "workaround" on this page you'll see that I also posted a workaround over a year ago.
 Sorry, really missed it. Thanks for it!
  http://facebook.github.io/react/docs/top-level-api.html#react.rendercomponenttostaticmarkup
It's only useful if you want to use React to render static websites, aka you don't want React on the client side. Which means we can drop data-reactid on every tag and the checksum. This can be a huge saving in bytes. So yes, naturally React will not mount.
 @Shadowfaxenator you are correct in saying that React will not mount these components. If you try to, React will blow away the DOM and not reuse nodes. React uses the checksum and ids to mount and intelligently reuse nodes.
  You could also just copy the prototype temporarily as a hack.

fn.prototype = GenericOmComponent.type.prototype;
 Is this resolved/no longer relevant?
  @zpao @chenglou can you guys take a look at this? I'm pretty swamped...
 Looks good! I'll let @zpao check and merge.
 It seems that you might instead want a function that gets called on the next tick regardless, in which you could check whether or not the component has updated. I'm not sure which is more useful.
 This makes me wish components were `EventEmitter`s and anyone could subscribe to e.g. the `"update"` event: `component.once("update", function onNextUpdate(event) { ... })`.
 Sorry for lagging. @spicyj, @benjamn - if this is fine by you then I'm fine with it. Doesn't actually change core and just makes testing easier for some people, which is cool.
 I'm not actually sure this makes sense. I think we want something that resolves immediately if no state updates are pending. I might have a slightly better handle on this after #1373.
 @spicyj, batching is your arena. Would setImmediate be of use?
 Currently, updates are only batched inside a React event handler so when writing tests you shouldn't have any problem with asynchronicity. That is, this test should consistently pass:

``` js
it('updates the value of input.foo with the current state.value', function(done) {
  expect(1);

  setTimeout(function() {
    component.setState({value: expected});
    expect(component.getDOMNode().querySelector('input.foo').value).to.be(expected);
    done();  // (mocha-style async callback)
  }, 10);
});
```

Maybe I'm missing something but I am having trouble imagining cases where this helper would be necessary and thus find it hard to reason about potential APIs.
 Going to close this out for now until we hear more concrete use cases ‚Äì let me know if that's a problem for anyone.
  @benjamn - can you take a look?
 What about changing it to

``` js
var child = spawn({
  cmd: "node",
  args: [path.join("bin", "jsx-internal")].concat(args)
}, function(error, result, code) {
```
 Cool, I can put up a PR for that (unless you have the time, @jbrantly).
  I'm sorry that this slipped through the cracks! I think this is really cool, and thank you for taking the time to write this, but I think I'll keep it out of the example for now. I strongly encourage you to write up an blog post or publish your own repo, and then link to it in the wiki: https://github.com/facebook/react/wiki/Articles-and-Videos
  There's already something here: http://facebook.github.io/react/docs/jsx-in-depth.html#comments
Can you modify that one instead? Maybe the gotcha part can go into a tip... dunno.
Also, can you sign the CLA please?
 Going to close this out for now, but if you get a chance to update it, let us know!
  You need to put {} around comments. http://jsfiddle.net/vjeux/6GdB9/
  Here's the jsfiddle that I used to make sure it is correct: http://jsfiddle.net/vjeux/QeCB5/
  If you require React after defining `window` and `document` (i.e., in your `beforeEach` function) I believe the error will go away. Can you confirm?
 Can you confirm you put this line in the beforeEach as well?

```
var utils = React.addons.TestUtils;
```

React doesn't use any variables called `utils` in its source, so I assume missing that is the problem.
 Sorry, can you make sure:
- global.navigator is defined
- the `React` and `utils` variables are declared (but not set to any value) in the top-level scope
- React is required in beforeEach
- utils is set in beforeEach based on the result of the React require

With all of those, does it work? If not, what error do you get?
 If they're declared in the beforeEach block, then the variables are scoped to that function and no one else can access them. This way, the variables are shared across the file but they're initialized at the start of each test.
 @bkonkle What if you also require CastawayApp in the beforeEach section? Since it depends on React you want to require it at the same time. This test https://gist.github.com/spicyj/8b1bb6485321be906370 passes for me when run with mocha.
 If you're requiring all of your code at the top of your file instead of in a beforeEach, it's fine to require React there too, but the `window` and `document` globals should be present at the time React is required.
 No, you shouldn't have any problem using renderComponentToString.
 You can also re-require all the libraries in a `beforeEach` call in your tests, to make sure that each test is completely separate. See this example of how to do it in jest:

http://facebook.github.io/jest/docs/tutorial-react.html#content
  Looks good to me, thanks.
 I've fixed this internally and added your test. The PropTypes are rewritten and no `weak` is needed anymore.
Will wait for @zpao to sync out, along with your tests.
 @justinj can you rebase this? We've changed PropType a bit. `.weak` is no longer needed, but the tests are good.
 Thanks @justinj!
  @jmingov, @fxbois, @lilyj - let me know if you'd like real names in here. I'm going to push this but feel free to comment and I'll push a followup.
 Hey zpao!

My real name is: Jaime Mingo

Thanks in advance.

Jaime
  woot! @zpao I'll let you decide if you want to cherrypick and roll out
 Plan is to ship 0.10 today, so will cut a new branch from master with this and any other updates we missed.
  @sorribas version, how are you running it, any details to help repro?

cc @benjamn - this is in commoner.
 Thanks a lot for the report. Looks like @benjamn has updated commoner and I'm sure he'll update our dependency here as soon as he pushes that to npm.
 Just in case you still have an old version of the `commoner` dependency installed, you can do `rm -rf node_modules/commoner; npm install .`
  No, simply that those attributes won't appear in your markup. It also means Resxt can't mount those nodes. I'll clarify a bit.
  Thanks for updating so quickly. My comments are everything that @plievone already said :) (thanks @plievone!)
  @frikille Is TransitionEvent defined or undefined on that browser? When the unprefixed version exists it's better to use that in general because it's more forwards-compatible.
  I'm mostly certain this is intentional but I forget exactly why. @petehunt?
  Thanks!
  Thanks! We actually build the gh-pages branch so we'll overwrite these changes next time we build. Could you update this to be against master branch with edits to https://github.com/facebook/react/blob/master/docs/docs/videos.md
  This docs page will soon be replaced by the wiki; feel free to add it here:

https://github.com/facebook/react/wiki/Complementary-Tools
  Not quite sure what you mean. If you don't attach any events to your elements then there shouldn't be any overhead from the events system.
 @jaredly, are you seeing issues? The Synthetic event system may actually _help_ you get responsiveness out of underpowered machines. Attaching event listeners to actual DOM nodes is expensive.
 @jaredly You're seeing lag that goes away when you use native event handling? I'd be interested in seeing a test case that shows that.
 Is this just an input related problem? Or do you see issues with click handlers (I suspect you don't)?
 No plans to do this.
  Tests are failing only because of the recent immutableObject changes. I also left those files be.
 @magalhas: If you use `jsx --harmony` you get a couple for free:
- arrow functions
- class
- short object notation: {val} -> {val: val}
- rest params: function(...args) {}
- template: `string ${interpolation}`

You can see the entire list here. We're slowly working on more of them as we use them at fb
https://github.com/facebook/jstransform/tree/master/visitors
 :thumbsup: bring it in
 Going to close this out here and let you land it internally and sync out.
  Sorry for letting it hang. I may still come back to it, it's just been lower pri. I know @vjeux is still interested.

I was actually thinking about this again the other day when I was thinking of some other transform stuff. I'd be curious if we could use recast instead of escodegen (I vaguely remember you did at one point). That would result in leaving comments and such intact...
  Your concern is specifically about `data`? In that case I'll close this out.
  @petehunt?
 @stephenhandley that's what the non-addons React build is
 Bit late on this ;), but if you still have this merged in, can you show a screen shot?
 That text looks kinda long
 Maybe link the "virtual DOM" text to some documentation with a more complete explanation? From a quick look at the docs, I don't think we actually have an article explaining why the virtual DOM is so important.
 Going to close this out. I think we'll probably do a website refresh in the new few months and change some content then. Sorry this dragged out!
  Thanks! Do you think you could add a couple tests and comments explaining the purpose and to make sure this works?
 You should be able to render an SVG node then set its className and verify that the class was changed properly. See DOMPropertyOperations-test.js for our existing tests.
 Did you run the tests? I would think `expect(svgNode.className).toBe('foo');` would fail because .className should be an object, not a string -- right?
 I understand. I guess it's not practical to test this in phantomjs, so I'm fine landing without tests.
 I think that's best unless you have a better idea.
 phantomjs is actually using a really old version of webkit so I'm not that hopeful. We do have a way to run tests in real browsers via saucelabs but right now all the tests are meant to pass in phantom.
 I think we might be best just leaving off the tests here.
 Looks good to me, thanks.
 Ok, so after some more thoughts, I think what we have here is not going to be great. It touches the DOM on every update before actually doing the update. I ran a bunch of perf tests and using the attribute seems to be marginally slower for setting, faster for deleting. I think that's probably the best option, however that doesn't work in IE8, so we need to do something different there. Perhaps we can default to `MUST_USE_ATTRIBUTE` and if we're in IE8 change it? @yungsters, what do you think?
 I pretty much agree with @syranide. Whatever solution we come up with ‚Äî as long as it is not horrible ‚Äî will probably be good enough to tie us over until we have per-node configurations. Then we can do whatever needs to be done for SVG (or any other unique) elements without impacting the 90% use case.
 Just put up #1590 which is an alternative approach.
 Closing in favor of #1590. Thanks for taking a stab at this @fforw and I'm sorry we stalled on it!
  **TL;DR fix** [Load `polymer.js first](https://github.com/facebook/react/issues/1263#issuecomment-38501176)

---

Probably related to #1107

When a `select` or `input[type="checkbox"]` is rendered inside an unwrapped Polymer element's child node, the following error is thrown:

```
Error: Invariant Violation: ReactMount: Two valid but unequal nodes with the same `data-reactid`
```

I would imagine that radio buttons, etc. would also throw.

I am not sure if this is an actual bug or a limitation of React and the ShadowDOM/Polymer. But the error message is... not exactly helpful in determining what to do.

I wrote a simple JSBin that demonstrates the problem: http://jsbin.com/pinijoho/2
 After some additional toying with Polymer + React, I ran into the same bug with a more straightforward example: http://jsbin.com/xoxip/2/

In this JSBin, the React component simply toggles a CSS class when the state changes due to a mouse click.

The CSS class is added properly on the first click, but when toggled off, removing the CSS class throws the same `Two valid but unequal` error.
 There's definitely something weird going on here. The error message is as accurate as it can be, though it's generally difficult to guess (at the framework level) what the root source of the problem was.

When we've seen errors like this in the past, it was typically because `.cloneNode()` was being used by client code to make copies of React-generated nodes, also copying the `data-reactid` attribute (which is supposed to be unique), but my brief investigation doesn't point there this time.
 I actually get a different error in Firefox as it's trying to get the node for an event. Can repro in Chrome though.

```
TypeError: Argument 1 of Node.contains does not implement interface Node.
Stack trace:
containsNode@http://fb.me/react-0.9.0.js:14157:5
...
```
 Let me rephrase, I am sure that the error is as explicit as it can be. But for someone that is not intimately familiar with what React is trying to do, its like running into a brick wall. :smile:

But that is besides the point, the issue isn't with the error messaging. 

It sounds like this may be an issue with [Polymer's ShadowDOM polyfill](http://www.polymer-project.org/platform/shadow-dom.html#wrap-and-unwrap). I tried playing with it a bit more and I believe I was able to get it to work by not `unwrap`-ing the Light DOM node that the React component is rendered into:

http://jsbin.com/xoxip/3/

It sounds like Polymer's `wrap` function wraps the DOM Api with its own methods for interacting with the Shadow- and LightDOM. Since React is using `appendChild` somewhere, and I was `unwrap`-ing the root element, it sounds like Polymer and React disagreed about what the tree should look like. Removing the explicit `unwrap` exposes Polymer's version of `appendChild` to React and then it starts playing nicely again.

The curious thing is why I felt it necessary to add the `unwrap` in the first place... I am pretty sure that React was complaining about the Light DOM node not being of the right NODE_TYPE, but I made a couple changes to my rendering loop in the meantime which may have eliminated that issue...

Thank you to both of you for looking into this. Since the JSBin seems to be working now as well as my application, I am going to go ahead and close this and hope that we've all learned something new.
 That story is consistent with my findings: the `invariant` in `ReactMount.getID` was failing because `cached !== node`, where `cached` was a `<span>` and `node` was something like `{ impl: cached, ...}`, so it sounds like the `node` was one of the ShadowDOM wrappers you're talking about.
 @arv React creates most of its nodes by setting `.innerHTML`, so unless Polymer is hooking that setter, that might be one way raw DOM nodes get exposed?
 @arv I was indeed getting wrapped nodes, but I ran into an issue when rendering a React component inside one of them. My solution at the time was to unwrap the polyfilled node reference and use that with React. That seemed to fix the problem initially, but then I ran into this issue.

Turns out that passing the unwrapped node to React was a bad idea and it works fine without doing that. I think the root cause of my initial issue was due to a misuse of the React rendering API. I believe I was calling `renderComponent` for each upstream update instead of using `setProps`. 

So all in all, everything actually works just fine :smile:

Now if I can only figure out if its possible to use React to render Polymer elements...
 I hate to do this, but I just ran into the reason I had added `unwrap` to my rendering loop.

When rendering a React component inside a Polymer element, using a Light DOM node as the root node for the React component works fine until you need to conditionally render a child node (An `Error: Assertion failed` error is thrown)

You can get around this by passing React an unwrapped node with `unwrap`. But by doing so, you lose the ability to toggle CSS classes or interact with form elements (An `Invariant Violation: ReactMount: Two valid but unequal nodes with the same 'data-reactid'` error is thrown)

Unfortunately, I am having trouble reproducing the exact behavior in JSBin.

Before I spend too much more time, does anyone think that this is a losing battle? Is there any reason to assume that React is compatible with Polymer and vice versa?
 Ok, I've created the mother of all test cases: http://jsbin.com/qoquv/1/

This creates four React components:
- Regular form
- CSS class toggler
- Table row append/remove-er
- List item append/remove-er

It then renders each of those components in the following ways:
- Inside a Polymer element with an unwrapped Light DOM node
- Inside a Polymer element with a wrapped Light DOM node
- Inside a plain DOM element

Each variety seems to exhibit different behavior.

Items of note:
- The class toggler that fails to respond when passed a wrapped DOM node. Maybe its because the Polymer polyfill does things with events? Not sure, but oddly enough, I don't seem to see this in my own non-trivial application...
- The pure React + DOM renderings fail to work properly when the Polymer polyfill is included on the page. Commenting out the Polymer polyfill, framework, and custom element definitions allow the pure React components to work as expected. I imagine this is due to the polyfill wrapping all DOM nodes, whether you want them too or not. Using `unwrap` in this instance causes React to throw the `Two valid but unequal` error.

I'm not sure where to go from here. As I mentioned before, it is unclear to me if React should work more to be compatible with Polymer, if Polymer should work more to be compatible with React, if this is just a really bad idea that I should just drop, or wait for Polymer to mature.

It would also be interesting to see if Mozilla's XTag polyfill exhibits the same behavior, but I'm already months late on a project and do not have the time to investigate that path. Perhaps @vjeux has some insight based on [his blog post](http://blog.vjeux.com/2013/javascript/custom-components-react-x-tags.html)
 @arv That is fantastic, thanks so much. Should I reopen this issue at [Polymer/polymer](https://github.com/Polymer/polymer)?
 I just prototyped using x-tag during an afternoon and it seemed to work but I didn't thoroughly test it.

In any case, to your question if React/Polymer should inter-operate, definitively yes. We should make it as easy as possible to embed React component inside of Polymer components and vis-versa.

I don't have enough context on this actual bug, but if we can make the internals of React more polymer friendly we'd generally be happy to do so.
 @vjeux I think the problem is actually with Polymer. After creating the JSFiddle mentioned [earlier](https://github.com/facebook/react/issues/1263#issuecomment-37899504), it looks like the mere presence of the Polymer polyfill prevents React from working on _any_ element.

@arv mentioned that the issue "...is all in Polymer's court" so I will assume he will take the lead on further investigation. So I guess you guys can just stand by until the Polymer team has a chance to look into it further.

Thanks for taking a look :beers:
 @arv :sparkling_heart: This is fantastic.

Is it worth documenting this order dependency in either of the two projects? Is there additional work that can be added to either project to remove the dependency?
 Are there other polyfills that would cause this problem or just Polymer? I'm not aware of any others but maybe they're out there.

If there are others I'd say we should update the error message to include a note about polyfills. If there aren't I think that it's probably Polymer's job to message this.
 @arv Since the errors caused by not including `platform.js` first can be dramatic and confusing, could you make the note in the Polymer docs a bit more assertive?

Since this is no longer an issue, I'm closing this issue.
  :+1:
  I really want this to work: http://jsfiddle.net/RxRK8/
 Context is going to be parent-based, so this request is obsolete.  Closing.
  The DOM already exposes `data-*` as `dataset` but it's doing transformation from hyphenated to camelCase. [From MDN](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement.dataset):

```
<div id="user" data-id="1234567890" data-user="johndoe" data-date-of-birth>John Doe
</div>

var el = document.querySelector('#user');

// el.id == 'user'
// el.dataset.id === '1234567890'
// el.dataset.user === 'johndoe'
// el.dataset.dateOfBirth === ''

el.dataset.dateOfBirth = '1960-10-03'; // set the DOB.

// 'someDataAttr' in el.dataset === false

el.dataset.someDataAttr = 'mydata';
// 'someDataAttr' in el.dataset === true
```

We should just start supporting `dataSet` (because camelCase). This will allow a couple things:
- easier reasoning about data attributes (`Object.keys(this.props.dataSet)`)
- easier merging (`<div dataSet={merge(this.props.dataSet, {extra: 'value', override: 'value'})} />`)
- easier (potentially faster?) updates (just modify `node.dataset`)

We'll want to do the reverse of what the DOM is doing. eg `<div dataSet={{dateOfBirth: 'val', foo: 'bar'}} />` becomes `<div data-date-of-birth="val" data-foo="bar"></div>`.

To the best of my knowledge, `aria-*` doesn't have a corresponding API, but we should make it work the same way. I think `ariaSet` makes sense.
 Cool, I'll take a look at this this week.
 Last point, assuming you mean `dataset = {...}`, wouldn't work. `dataset` is a [`DOMStringMap`](https://developer.mozilla.org/en/docs/Web/API/DOMStringMap) and setting it an obj doesn't do anything. So if we decide to do this it'll likely be sharing the logic with style. #1543.
 Still on the radar but pretty low priority. I'd be interested to see if it could be revived - @chenglou has the most context on why we didn't quite follow through (I think there were memory tradeoffs)
 Yeah, pretty low-priority I think:
- Some allocation were necessary, on one of the hottest code paths of React. I'm not sure how relevant that still is.
- It's a bit bothersome because of all the intricacies of camelCasing data-*: https://github.com/facebook/react/pull/1446#issuecomment-43452003
- Not sure whether `ariaSet` makes sense. aria-\* is a fixed list of attributes and it seems weird to start grouping them now.
- People rarely use `data-*` in react now, maybe?
 Regardless of whether or not it is rarely used I think `data` taking an object like `style` is the correct approach (that's the representation in JS too). But `aria` are really just prefixed attributes and it seems like it would be detrimental to have them be part of an object.
 @jackdcrawford `<button {...{'data-track-action': ...}} />` should work just fine.
 @syranide  :+1: 
  Should this be in TodoMVC or in the React example folder? Because we just removed those 2 todos.
 Talked about where this should go offline, we're putting it here for now.
  This docs page will soon be replaced by the wiki; feel free to add it here:

https://github.com/facebook/react/wiki/Complementary-Tools
  See #1255.
  I'm afraid this behavior is intentional so that you can write things like onChange={isEnabled && this.handleChange}, and I don't think we're going to change this.
 Similarly, you could write `onChange={isEnabled ? this.handleChange : null}` or something along those lines. We've felt like that is the most helpful behavior; it's convenient to have falsey handlers be ignored, just like `null` and `false` don't render anything when included in an element's children.
 I personally find it much weirder that `false` is ignored; it doesn't surprise me that null is. With props, we consistently assume that `undefined` is equivalent to not specifying the prop at all (like when merging in the result of getDefaultProps) so it would definitely be a change to treat `undefined` as invalid here. 
  This would also definitely fix our initializeTouchEvents problem. I don't know the perf impacts of not bubbling to document though.
 ![make-it-so-captain](https://f.cloud.github.com/assets/8445/2404667/46017000-aa40-11e3-9472-c11a06da1ce1.jpg)
 Anyone picking this one up? Otherwise, I would like to give it a go :-).
 @SanderSpies you're exactly who I had in mind for this! :)
 petehunt: great :)

Potential scenario's I'm seeing:
- elements with listeners at the same level. 

So for these event types there will be more then one event listener
- child element listens to same event as parent element.

I guess we always want to use the parent element
- during lifetime the dom changes, and therefore also the element which needs to listen.

Which would imply we would also need to remove/add event listeners on the fly, not sure if we already do that

I'm thinking of adding something like 'bindLocally' at the event plugins level like:

onTouchMove: {
    bindLocally: true,
    phasedRegistrationNames: {
      bubbled: keyOf({onDragOver: true}),
      captured: keyOf({onDragOverCapture: true})
    }
  }

Good idea? Bad idea? Missing stuff here?
 It's really a function of the topLevelType `topTouchMove`, not the event that you wrote there. For naming, `delegate: false` might be clearer.

Right now I don't believe we ever remove listeners.
 @spicyj I wrote that code a bit too hastily I guess. Should have been touchMove, also notice the onDragOver + onDragOverCapture that I forgot to correct... 
 Are you sure it's before the DOM nodes are created? Regardless, probably you want to tie it to the transaction -- you can see how ReactReconcileTransaction stores a queue of componentDidMount callbacks (ON_DOM_READY_QUEUEING/ReactMountReady) and a queue of listeners to put (PUT_LISTENER_QUEUEING/ReactPutListenerQueue). If the put listener queue can't easily be modified to do what you want (though I'm guessing it can), you can make a new transaction wrapper and add it to the list there.
  @matthewwithanm I'm guessing the IE8 problems you saw in #1327 won't be a problem here -- want to try the same renderToStaticMarkup approach?
 Correct me if I'm wrong, but the contents will be used only if the browser doesn't support iframes, which basically all browsers that support JS should?
 React shouldn't look inside the iframe unless you change the contents later.
  We should just make noscript do this automatically, sort of like our existing wrappers for input, select, and textarea. Want to take a crack at it?
 Related #1905 ... should we even set the content of `<noscript>` client-side? (Or technically even render it when React is able to) It's a perf hit and I can't think of a reason you would ever care about the contents of the `<noscript>` when client-side?

**PS.** I feel like there's something dirty about `renderToStaticMarkup` happening behind the scenes. Wouldn't it make more sense to just disallow children and if people want the implicit behavior it should be wrapped up in a custom component?
 @matthewwithanm Oh right, yeah, reusing client-side would require a special flag internally which would use server-rendering rules when constructing the initial markup.
 @Jpunt @benkeen

`ReactDOMServer.renderToStaticMarkup()` is available on the client side if you include `<script src="https://fb.me/react-dom-server-0.14.7.js"></script>`
  cc @benjamn to sync (turns out this does exist)
 Thanks @davidxi! Sorry for the delay getting this in.
  We have a ton of places that do

``` js
var container = document.createElement('div');
var component = <Something />;
var instance = React.renderComponent(component, container);
```

We should just be doing

``` js
var component = <Something />;
var instance = ReactTestUtils.renderIntoDocument(component);
```

This isn't an exciting task, but gets you exposed to lots of tests which can help with understanding react core better. cc @kmeht
 @sebmarkbage has a codmod coming that touches a bunch of these, so don't jump in _quite_ yet.
 Okay, keep me posted. I'll manually fix any callsites that slip through the codemod.
 Codemod in. He wasn't actually fixing them, just touching code around them so would have been merge hell.
 It should be. Feel free to take it on. Let me know if you have any questions!
  (Tangentially related to #1240.)
 Going to close this in favor of #1539, which is a little cleaner. Thanks for sending this in!
  Thanks!
  Doesn't setState throw too on an unmounted instance?
 This is exactly the reason I left this in. Having a data layer that accumulates potentially long running request is death by a thousand cuts. You need a way to handle canceling.

Many data layers set up infinite subscriptions for data updates. Not having a clean up mechanism is clearly a memory leak which can bring the entire React subtree with it.

Streams or Observables are good primitives that have cleanup semantics. I consider a purely Promise based data layer inherently flawed for this reason. If you want the output to always be promise based, you can pass some kind of handler down your data layer with a cancelability hook.

Ultimately I think the solution is Stream/Observable based. As soon as we have a proposal for it, we would build in native support for cancelation but for now you can do it in a mixin.
 The invariant has been replaced with a warning in #4091.
Still, it‚Äôs best to avoid the warning. To do that, you can:
1. When possible, use a cancelable async primitive (e.g. an Observable) so you can clean up on unmounting.
2. If for some reason you can‚Äôt do this, set a flag (e.g. `this.unmounted = true`) in your `componentWillUnmount` and check for that flag in the callback. It‚Äôs not pretty but it makes the problem with the lack of cancellation more apparent and visible.

I‚Äôm closing but please let me know if there is something I missed.
  Sorry to hear that!
  @syranide Was this fixed?
 Was clearing up old some old issues and it seemed like this was fixed, but apparently not.
 AFAIK `isMounted` no longer exists as of React 0.13, so this issue should be irrelevant now.
  This is awesome! I don't know the best way to present translated content, so I'll need to do a bit of work to expose this. So far the ideas in http://www.sp4ce.net/site/2011/01/15/how-to-have-a-multilingual-website-with-jekyll.html seem the most relevant (there are l10n plugins but focused around strings, not documents).

A couple questions:
- are you interested in translating more of the documentation?
- what would be the best way to ensure changes in the english version are flagged for updated translations?
 I'm going to merge these in so we at least have them, then we can figure out how to manage these later. Sorry for the delay, this just hasn't been a huge priority for us yet.
 @jiyinyiyong My concern is that we don't have a process for making sure translations stay up to date. I would be interested in having more translated content but since it's so easy to fall out of sync, I don't want to get stuck in a situation where we're spreading misinformation or outdated information to a group of people.
 The website/docs are generated by Jekyll (for now) from the [`docs/`](https://github.com/facebook/react/tree/master/docs) directory. We have a readme in there briefly explaining how it works.

Some things not mentioned there:
- Docs changes should land on `master` branch
- Relevant commits about docs (but not all) are cherry-picked to the stable branch (currently `0.11-stable`)
  - This allows us to make docs changes for upcoming API changes without publishing incorrect documentation for the current release
- We generate the site from the stable branch into the `gh-pages` branch and check in the generated html/etc. We generally have several changes globbed together here. The commits here are noisy, especially for changes that have wide effects (eg blog posts, which affect paginated results and the sidebar so _every_ blog post html needs some change)
  Thanks!
  Thanks!
    Would be nice to share logic with quoteAttrName in xjs.js.
 Looks pretty reasonable. I'll let @jeffmo review and merge.
 Closing in favor of #1539 which does the same thing and is a little cleaner -- thanks for sending this in though!
  Go to: http://facebook.github.io/react/docs/tutorial.html.
Click on: Thinking in React.
Feel sad.
 Tnx :-)
Op 10 mrt. 2014 16:51 schreef "Andreas Svensson" notifications@github.com:

> http://facebook.github.io/react/blog/2013/11/05/thinking-in-react.html
> 
> Here's the real link for now (if you wanted to read it).
> 
> ‚Äî
> Reply to this email directly or view it on GitHubhttps://github.com/facebook/react/issues/1238#issuecomment-37197707
> .
  @sebmarkbage looks like we missed this one
 Think so... figuring it out now :)
 I think this diverged upstream. I'll let @zpao figure this one out.
 @syranide if you pass a component descriptor as props, then the thing you pass it to may rerenders without you rerendering.

I'm not sure what you mean by the unmount scenario but I think this won't be a problem once we stop mounting the same instance and have true descriptors.
 Remounting the same descriptor again only breaks if you switch back and forth between two of them and we're fixing that with the 0.11 release anyway.

The typical pattern for mutable objects in state is that you rerender the component which expects updates. If you rerender the component that pass props, then you should be recreating the descriptor.

``` javascript

var Outer = React.createClass({

  render: function() {
    var child = <div style={{ color: 'black' }} />;
    return <Inner child={child} />;
  }

});

var Inner = React.createClass({

  getInitialState: function() {
    return { clicked: false };
  },

  handeClick: function() {
    this.setState({ clicked: true });
  },

  render: function() {
    return <div onClick={this.handleClick}>{this.props.child}</div>;
  }

});

```

You could modify the props of the outer component for this to break:

``` javascript
  handleClick: function() {
    this.props.child.style.color = 'white';
    this.setState({ clicked: true });
  }
```

This is already a terrible pattern that is broken for many other cases. If you mutate objects, it should at least be your own. transferPropsTo already explicitly isn't allowed on components owned by someone else for this reason.

Another way to break it would be by creating the instance outside the render flow.

``` javascript

var child = <div style={{ color: 'white '}} />;

var Outer = React.createClass({

  handleSomething: function() {
    child.props.style.color = 'black';
  },

  render: function() {
    return <Inner child={child} />;
  }

});

```

The original proposal was to do this optimization using the owner level as a reference. That would solve the last case where the child doesn't have an owner and therefore isn't recreated.

Enforcing strict recreation also allow us to reason better about pooling since we know for sure that old instances are no longer needed.

So in short. I think that we can still allow mutation of state objects in most cases but you need to recreate component descriptors in the thing that is rerendering.
 oh this is not in ReactCompositeComponent. Then this PR makes sense as is.
  fwiw, putting `{"bar"}` onto a new line gets parsed how you would expect. It's an awkward balance and svg definitely makes this trickier :( - check http://jsfiddle.net/wVQr3/
 Should be better now due to #5753.
  Oh man, I am going to start using this!
  I didn't really get to give this a close look last time around so a couple things:
- Minification step (`grunt build:min`) takes forever and a day. Any idea why? To the point where `grunt build` is unusable for actual work.
- We should really rename these files from `browserify` if we aren't using it (you mentioned last time it wasn't the interesting part, but once we get this ready 2nd commit to move them would be nice).
- What do we need `deamdify` for? I don't think we have anything with the AMD prelude.
- Will this have stable sorting? One problem with browserify early on was that require path building was async and resulting in the build file being nondeterministic, which was a non-trivial pain.
- Your UMD is slightly different from the one browserify uses (https://github.com/ForbesLindesay/umd/blob/master/template.js), namely the part where yours doesn't check for other globals, only window. Any foreseeable problems?
- All of the intermediate license headers are getting stripped out. That should be fine but we'll want to stop using `simpleBannerify` But I ask because I wanted to know the reasoning.

And to bring in the table you had last time:

| orig | orig.gz | diff | diff.gz | filename | diff % | diff.gz % |
| --- | --- | --- | --- | --- | --- | --- |
| 392755 | 78327 | -26789 | -20464 | JSXTransformer.js | -7% | -26% |
| 602322 | 123001 | -4635 | -1843 | react-with-addons.js | -1% | -1% |
| 121441 | 33430 | -17999 | -3576 | react-with-addons.min.js | -15% | -11% |
| 549027 | 112014 | -2098 | -1096 | react.js | -4% | -1% |
| 112340 | 31015 | -16826 | -3389 | react.min.js | -15% | -11% |
 > we'll want to stop using `simpleBannerify`

This never happened. I'll fix it.

I'm going to live with this for a bit. I'm shipping 0.10 very soon so this will go out there. The file size wins are nice, but I'm actually not happy with the code that's generated. Stripping out comments from the dev build might actually be a deal breaker (especially as we encourage people to use their debugger and step through code).
 Oh and the license header says "undefined" :/
 That solves part of the problem. We can't ship a file without a license header and the non-min builds don't include the apache stuff. I will fix this.

BUT The other _big_ concern and is actually a dealbreaker - `grunt build` run twice in a row creates different files. The size compare shows random +/- (not consistently the same files). I can't have this in releases. If I checkout a release branch with the same versions of all files, I should be able to generate the exact same build.

That's what I meant when I said this:

> One problem with browserify early on was that require path building was async and resulting in the build file being nondeterministic
 Ah, well when you removed the license header from all of the parts, we need to add it to the whole.

I'm reproducing with master right now. This is a diff between 2 runs. https://gist.github.com/zpao/9625952
 > If I checkout a release branch with the same versions of all files, I should be able to generate the exact same build.
 I'm backing this out until the problem can be resolved. Sorry
 Because I want my life to be simple. When I build in a branch and get a different version of a file, is it because a change was introduced? Or did my build system change the way it worked? I don't want to diff and figure that out.

The other part of this (but building on simple) is ensuring that all files we distribute are identical. The file that ends up on bower, on the cdn, on cdnjs, in our starter kit, etc. If I build once and generate most of that and then happen to run the build again, I've just made a bunch of work for myself.

If somebody else checks out the branch and builds him/herself, and needs to track down a line number from an error but it's different from other people's, that's annoying.

So maybe that sounds silly to you but deterministic builds are currently a requirement for me.
 I'm shipping 0.10rc today so no. But you can do a fancy unrevert and we'll see what we can do for 0.11
  I think I'm going to end up deprecating the tools section of the site and just use the wiki. I'm not 100% sure of that yet, but I added this there - https://github.com/facebook/react/wiki/Complementary-Tools
 (#1280 got rid of the tools page on the site.)
  Thanks for reporting. I verified that #1157 doesn't fix this (even though it fixes another bug that produces the same error message).
 This happens because we enqueue a removal of the children, then set the HTML before the queued removal happens. When the queue is processed, the element is missing which confuses React. If we queue the innerHTML set as well then this will be fixed.

@kcarnold As a workaround for this bug, you can assign a different `key` prop to each div and React will create a new element instead of reusing the existing one.
 @spicyj Do you know if this is fixed in master? I think it is...
 No, it's still broken (but it throws a slightly different error).
 @juztinlazaro If you believe you've found a bug in the React core, please open a new issue and provide a jsfiddle (simplified testcase/example) that demonstrates the bug.
 @juztinlazaro It doesn't decode the entities.  It puts them into the markup, directly (that's what `dangerouslySetInnerHTML` does).  The browser sees the entities and renders them as text (that's what browsers do).  This is not a bug.  I modified your fiddle to do what I believe you wanted: https://jsfiddle.net/b5Lt87kb/
 @juztinlazaro Ok, for future reference, usage questions are better answered on StackOverflow, as we try to keep github issues for tracking bugs in the React core.
  Definitely. Want to open a PR for it? (You'll need to end up signing the [CLA](https://developers.facebook.com/opensource/cla) before we can merge, so feel free to preemptively do that!)
 Fixed in 9ffd70c6.
  Right now, ReactUpdates.batchedUpdates is called in ReactEventEmitterMixin.js but should probably be higher up in ReactTopLevelEventCallback.js so that with nested roots, updates are queued into the same batch.
 Yeah, we're going to do that once we figure out how pending state works. I believe we still want to flush any updates within the same event loop though, so this change will still be helpful.
  I wonder if we should just have a separate page talking about debugging and the dev tools. We could talk more about the prod vs. dev builds there too.
 I'll let you two figure out the best place for this, but can you sign the CLA @LilyJ? https://developers.facebook.com/opensource/cla
 Thanks! @spicyj - want to get this in as is and add a new page later?
 Yeah, this is definitely better than what's there.

@LilyJ Thanks for sending this in!
  React fixes inconsistencies in the DOM and avoids being held back by older browsers (to the extent possible). The only reason that the DOM authors chose `className` and `htmlFor` was because the JS engines of the time didn't support using `class` and `for` as unquoted property names.

Changing React to use `class` and `for` agrees with our principles of improving the DOM and using modern JS, and is what most people expect when first starting with React.
 That sure is a valid argument
 @akre54 that's what #1224 is for
 Unfortunately this won't work with object destructuring, like

``` js
var {class, color} = this.props;
```
  @petehunt 
 Thanks for taking a stab at this. We're going to nail down our stance on namespacing in JSX and the strategy we want to follow ASAP.
  Feel free to reopen/tweak this issue if it would help on top of the recent no-rethrowing improvements.
  Awesome. We _really_ need to get our transform tests out in the open so tests can be added for stuff like this (cc @zpao)
 Oops, I found a bug after patching this locally:

This:

```
/**
 * @jsx React.DOM
 */
<div>
  {/* A comment! */}
</div>;
```

Now seems to transform to this:

```
/**
 * @jsx React.DOM
 */
React.DOM.div(null
  {/* A comment! */}
);
```

(note the braces around the comment now)
  This should already work fine on master.
  To be clear: custom elements do work correctly (as intended) in the release candidate.  The custom element specification allows for arbitrary attributes to be specified on a custom element, which is why the design decision to use the `class` attribute instead of `className` was chosen (the custom elements spec requires us to preserve the full case-sensitive namespace).  We will continue the discussion of that topic in the issue you linked.

We have another issue tracking upcoming DOM technology, so I'm going to close this issue out in favor of https://github.com/facebook/react/issues/2836
  :thumbsup: 
 This got done. :)
  Sounds like you got react-tools by mistake. By the way, 0.9.0 final is out so you can drop the -rc1.
  Eh, I'd rather not write code that tests if `Object.freeze` is there before running it. My stance has been use language features and polyfill as needed (even if the polyfill just "silently fails" in this case). DOM-related things we generally can't polyfill so we need to feature detect there. We're probably going to end up using this method some more anyway.
  Thanks!
  I don't know exactly what @petehunt's intentions were here except something related to mongodb, and this exists there (from what I could see), so this seems fine. I'll let him handle this.

Could you also update the documentation at https://github.com/facebook/react/blob/master/docs/docs/09.6-update.md?
 https://github.com/facebook/react/commit/c5bf2ada4b91ddf8dbed38944d80d64e61554f3d changed DIRECTIVE_\* to COMMAND_*. Can you rebase and change to that too?
 That works, thanks!
  After a component is unmounted, it's possible its instance will still be accessible if a reference was saved to it, in which case isMounted() will return false.
  Looks good, can you sign our CLA at https://developers.facebook.com/opensource/cla and comment here when you're done? Then I can merge.
  @hllau: this should be an easy fix, do you want to try to fix it and submit a pull request?
 8855d6153e252c735de0e6cc373787d22c1a467b fixed this, I believe.
  Keys often use dynamic data that are out of the control of the person creating the React component so key-collisions might happen in user code. While it is still important to avoid that from happening, we can still keep rendering with limited user impact (only impacts perf). This change makes it so that key collisions are logged the same as missing key warnings and it assigns fallback IDs for collisions.

Not sure if this is the best solution and whether it might break something - everything seemed to work fine from my testing. 

Fixes #566.

cc @spicyj
 @syranide The collision case should be treated just like missing keys, in which we continue rendering just fine. There is no reason the whole app has to break (assuming your whole app is built using react).
 Needs some @sebmarkbage up in here
 Duplicate keys is always incorrect. This is just trying to avoid a hard crash and try to keep going as long as possible. However, this can always lead to incorrect state. The solution should be whatever is fastest in the default case with no collisions. Perf in the broken case doesn't really matter.

Can't we just prefix all collisions with a counter format in flattenChildren?

```
if (collision) {
  result[(collisionCounter[name]++) + 'collision:' + name] = ...;
}
```

It doesn't resolve conflicts for you in map etc. and other helpers but you may not want to.
 We could potentially also ignore everything after the first child with a given key, so

```
<div>
  <div key={1}>A</div>
  <div key={1}>B</div>
  <div key={3}>C</div>
</div>
```

renders `A C` only.
 @syranide Putting it in traverseAllChildren would require a lookup map within traverseAllChildren which is otherwise not necessary.

@spicyj Ignoring would work too. Simpler to implement. As long as we have warning hook.
 @balpert implemented ignoring the keys in #1364
  Hell yes!
  `componentWillEnter()` is only called when items are added to an existing TransitionGroup (see http://facebook.github.io/react/docs/animation.html#componentwillentercallback).

I think you can accomplish what you want with `componentDidMount()`. If you have any ideas for documenting this in a better way, runtime warnings, new features or if this doesn't fit your use case, please reopen. Thanks!
  FIxes #1179.
`className={['a', null, 'b']}` becomes 'a b'.
This allows you to do `className={['a'].concat(this.props.className)}`.
Note that nested arrays are currently forbidden.
 @cpojer 
Edit: nvm.
 Is this the return of `classSet`? How about we just have injectable magic props?
 The fact that `['a'].concat(this.props.className)` works with both `this.props.className` as a string and as an array, and is joined correctly, feels not right lol. Interesting, but not right.
I think @sebmarkbage has legit arguments for it though.
 It should be called classList since this corresponds to the classList DOM property. That also allows an incremental upgrade path.

This should use the same type check as concat, namely it should not do an Array.isArray check but rather allow array like objects, and later iterators.

``` javascript
if (typeof n === 'string' || typeof n === 'number' || typeof n === 'boolean') {
  // string
} else if (n == null) {
  // empty
} else {
  // array like
}
```

Otherwise it has different semantics than the proposed combinator syntax:

```
<div classList={['a'].concat(this.props.classList)} />
```

This also excludes the object notation of classSet but that has other issues (objects as map is bad, mkay) and is difficult to statically type. We do use similar features in a helper but this has it's own static analysis. You can't use something like closure compiler to minify classnames. That would be dangerous without having the same logic applied to your CSS files.

I'd like properties to be compatible with generic deep merging functions so that we can use or add language features for this.

It's not clear whether we should even allow both strings/arrays or just arrays because we're not sure we can express this union type well in common type systems. Recursive union types are even less common which is why we'd like to wait on nested arrays. Additionally when this is used with a plain deep merge, it's not clear how you merge a string and an array unless we assume that such values are concatenated in a merge. You also can't merge two strings. That would suddenly mean that two strings are not equivalent to two arrays.

The only valid data structure here is an ES6 Set. Anything else is just sugar which has to pull it's weight.
 Are we _replacing_ className with classList? If not, transferring props manually gets hairy because you don't know which property actually holds the classes (and what if you specify both?).

Honestly, these don't feel that different to me:

```
<div classList={['a'].concat(this.props.classList)} />
<div classList={['a', this.props.classList]} />
<div className={'a ' + this.props.className} />
```

so I'm in favor of leaving things as-is.
 The idea is to replace it, yes.
 @zpao @sebmarkbage What's happening here?
 tl; dr version is that transforming all these to array is too expensive internally
 Let's have this discussion in react-future so that it's consistent with other plans.
We can leave it open though. https://github.com/reactjs/react-future/pull/11
 We're not planning to do this for now so I'm going to close it out ‚Äì we can always reopen later if we do want it.
  Take a look at https://github.com/facebook/react/blob/master/src/addons/transitions/ReactTransitionEvents.js which is currently listening for the right events.
 The support for them was merged into master in https://github.com/facebook/react/pull/6005 a few days ago.
It should be included in v15 RC that‚Äôs going to be released very soon.

Stay tuned!
  Does not add it to addons yet since I have some pending PRs that will conflict (merging them now)
 :thumbsup: Sure. Merge at will when it's actually in addons.
 pingity ping ping pong. Let's do what we need here and for adding RAF or abandon.
 Closing. We can revisit if we do end up adding it.
  Chrome beta supports this now: http://blog.chromium.org/2014/02/chrome-34-responsive-images-and_9316.html.
 like-stamp
  Have you tested this against master/RC1? I think it might be fixed there, if it's not fixed, then I believe the idea is for setState to become always async, "soon" AFAIK.
 I believe this is fine now. cc @spicyj 
 No, I don't think this has changed. setState is sync normally, async in a batched updates context (including any event handler).
 Take a look at the console in http://jsfiddle.net/zpao/nbyjp9Lc/1/, it seems we're logging in the right (async always) order.
 componentWillReceiveProps is special, sorry. An outer setState like this shows the sync behavior: http://jsfiddle.net/nbyjp9Lc/2/.
 Ah, gotcha. Thanks for clarifying!
  Related, perhaps: http://stackoverflow.com/questions/22062663/how-to-use-react-test-utilities
 Interesting; it should work on the DOM component.
 @brigand Thanks, that's a huge help. @syranide's #877 should fix this.
 I'm going to close this and wrap it up under #1445. Thanks a lot for all of the hunting. If anybody is interested in taking on that issue, it sounds like it would help quite a few people :)
  lgtm
 @lrowe Do you mind rebasing this?
 Thanks! I'm really sorry this slipped by unnoticed for so long :(
  Looks good to me. I had the same change in #735.
 Thanks!
  cc @yungsters 
 Seems reasonable. Though it also sounds like Sarissa should polyfill `Node` slightly more correctly (maybe throw or warn intentionally when used as a function). Have you filed a bug with them?
 Thanks Evan!
  I believe this works correctly in 0.9 -- can you confirm? You can also try at http://facebook.github.io/react/jsx-compiler.html.
 No problem, glad you figured it out!
  a6c1b91
  Squashed to 5049fc6b059e25ebad4dc4fe9a2d3c0dd4794ea3
  Can you sign the CLA? https://developers.facebook.com/opensource/cla
  Closing in favor of #1657.
  I did this in the most API-constrained way possible. Will write docs.
 Aw, we lost ABC order
 Anything else need to be done here @petehunt?
 Try adding React.initializeTouchEvents(true) before any of your app code, if you don't have it already.
 Nah. Let's hold off because supporting this is going to suck. We should figure _something_ out for 1.0, so we can come back around to it then.
 Please don't add any more "+1" comments. If you don't have anything constructive, don't comment at all.
 No, not that I know of.
 Let's go with #436.
  Yes, we have https://github.com/facebook/react/blob/master/src/browser/eventPlugins/MobileSafariClickEventPlugin.js to fix this exact problem but it sounds like perhaps it's not working.
 Ever since on-demand event listening was added, [MobileSafariClickEventPlugin](https://github.com/facebook/react/blob/master/src/browser/eventPlugins/MobileSafariClickEventPlugin.js) has been broken because touchstart isn't always listened to. `cursor: pointer;` is an okay workaround but we'll have to fix this for real somehow, probably by having onclick handlers turn into `onclick=""` markup.
 This was reverted in 431155d2e231cfb65e236f9289fddf8cea291185.
 My original PR #1536 should have fixed this but it was reverted because it was causing some problems internally at FB. I'll look into bringing it back so we can fix this for good.
 Yes, it landed in master and will be in 0.14.

This diff adds an empty onclick listener so that Mobile Safari knows your div is clickable. This mirrors what would happen if you wrote `onclick="..."` directly in your HTML or called `addEventListener` without using React. I'm not sure how this interacts with hover.

We could probably do this only on iOS but I don't know if other browsers use similar heuristics. Hopefully this has minimal performance impact but we're planning to do some benchmarking soon and if this is significant we'll figure out a way to speed it up.
 It's fixed in 0.14 beta and will be in the final 0.14 as well.
 As my earlier comment in this thread already says.
 @ustun Not on this specifically, but we have no evidence that it's a hotspot.
 I don't know of any changes in 15.0 that would have affected this.
  The exception is wrapped in a try/catch block so the exception shouldn't be bubbling up. If this is causing you trouble, please file an issue on the [browserify `buffer` module](https://github.com/feross/buffer) which this code comes from.
 FWIW, this works just fine for me in Firefox 27
  Does this work correctly with event handling?
 I'm (irrationally) scared of these enum modules because I'm never sure if they'll get inlined or not. If they're not inlined, then they might not minify well and might also be a perf cost. It's probably irrational but let's just keep it as constants in the individual modules for now. The reason for having it separate is usually because it might change, but these won't. :)

I'm not quite sure what the expected behavior is for the events. Can we add a test that asserts the expected behavior? If it's not possible to test in JSDOM at the moment, it's fine to have a disabled test for now.
 This looks stale.
  React doesn't actually look at `.outerHTML` but instead compares the checksum of the server-generated markup (computed before it's sent to the browser) to the client-generated markup.

You could try running `React.renderComponentToString` on server and client to compare the outputs -- make sure you're passing the same props in both cases and that each render function looks only at props and state (no Date, Math.random, etc).
  @brigand Thanks!
  @flockonus If you're using the development (unminified) version of React, you should have seen a warning in your console specifically about this.
 We want as many things to be warnings as possible so we can compile them out in prod
 @flockonus I'm going to close this out as I don't think we're going to support `selected` instead of `value`, but feel free to open a PR to the docs to make this clearer.
  (@visionscaper tip: press "Subscribe" on the right column.)
  Unfortunately we don't hide the error even if you have the devtools installed right now. See #953.
  Fixes #1147.

This now forces all DOM operations for a subtree to be applied when the calling `setState` or `React.renderComponent` call returns (when updates aren't being batched). This means that we can't batch innerHTML setting across different component hierarchies, but our strategy for doing so before seems flawed. It could be possible to make the old way work but it would require making setState always async even when batching isn't in play and refactoring DOMChildrenOperations to not be confused by multiple updates to the same node.

Still need to add tests. Not sure this is exactly what we want to do but I think it agrees more with what we've been doing.
 Opinions here @jordwalke @yungsters @sebmarkbage?
 I don't yet fully understand the consequences of this change on nested operations and loops such as componentDidUpdate retriggering updates at higher levels.

We do want to move to a fully async setState by making all operations batched.

For systems which only partially uses React, batching of innerHTML across roots is really important but you may be right that it's already flawed.
 > For systems which only partially uses React, batching of innerHTML across roots is really important

I think it's a cool feature, but there is significant complexity in maintaining it. People who use many react roots won't benefit from a nice perf bump, but I'm not sure how likely it is to be the case that an event will cause several roots to simultaneously need child updates (within the same event loop).
 @syranide @jordwalke Batching innerHTML setting across multiple trees like we do now could be useful for things like petehunt's sortable component (https://gist.github.com/petehunt/7882164) where each child makes a separate component root. We're only running into trouble right now when combining that with multiple updates to the same component at one time. I agree though that there is code complexity and this might not be super common.
 After an initial look at the diff, either way, this structure seems much cleaner. Whether or not we batch markup generation across multiple parents/roots, queueing mutations is helpful for animations in the future (and sets us up to be more testable). Queueing of mutations in general isn't the main cause of code-complexity - batching markup across multiple parents/roots is. This diff doesn't remove the later, but makes the former more elegant/correct. Note how @spicyj eliminated this `updateDepth` tracking in the old code. Any time we are executing code only on the first depth of the tree, it's a good sign that we should be using the existing `Transaction` - that's what it's there for. So this diff seems like win to me (but haven't looked carefully enough to see if there's any bugs). Thanks for doing this, @spicyj!
 Unrelated to this diff: I would like it if the core were architected more like this - where mutations are queued. That allows us to clearly separate the reconciliation process into two separate, testable stages:
1. Determine the set of mutations that occur (they would be queued up).
2. Apply those mutations.

Right now, before and after this diff, child creation mutations are queued up, but other types of mutations are not (things like setting properties etc). If we make sure that _every_ mutation is queued (assuming that it doesn't hurt performance in practice, not that I'm concerned) - then we can compute the diff, and then easily implement various strategies of carrying out the mutations over time. We could throttle across `requestAnimationFrame` at an even more granular level than was possible before. We could record the stream of mutations, log them and replay them very easily, and analyze where timing jank comes from in the DOM for a mutation stream representing a real world application. Also, it just seems cleaner, consistent, and more functional ;)

This diff nudges us in that direction by making queueing easier to reason about in general by tying it to the `Transaction`.
 @sebmarkbage Currently, when the reconcile transaction is closed, the mount-ready callbacks are executed, meaning that all DOM operations should have been flushed by that point. Like you suggest, perhaps we should change setState so that the transaction is executed later, but the current behavior is wrong.
 @sebmarkbage, can you take another look at this before I pull it in
 Can we get a unit tests for the observable change in behavior? (There is one in the referenced issue.)

This will increase memory usage for large updates. :/

Could another solution be to keep mounts in a hash map based on IDs so that you can clear them or replace them when there is a subsequent remove or update respectively?

Is this even a valid behavior? componentWillUpdate shouldn't cause setState. Can we just forbid it?
 Sorry, the description here is a bit out of date. The referenced issue was actually fixed by #1363 and I already [added a test case](https://github.com/facebook/react/blob/e17086e5df626d915be122f9c319cee2e184e9eb/src/core/__tests__/ReactUpdates-test.js#L640-L687) for it.

I believe that this PR should actually cause no observable differences; it just cleans up the code.

When does this increase memory usage?

We can probably forbid componentWillUpdate from calling setState. It's already disallowed when calling setState on the component whose componentWillUpdate is running. I can do that as a separate diff.
 The underlying memory used by the multi-child queue can be reused by other updates in the same transaction. Difficult to predict real world behavior since it can depend on GC implementation and memory load. On a memory constrained device (like low-end Android) this could potentially crash the browser instead of GC:ing.
 It seems unlikely to me that the list of queued updates would be significant in comparison to the cost of the actual DOM nodes and component instances. Do you disagree that the queueing that ReactMultiChild does is odd and belongs in ReactReconcileTransaction?
 I agree this is cleaner.

From what I can see, this would only increase the number of object allocations by ~3 per simultaneous component tree rendered. I don't think that is a concern.

The reason I originally batched child mutation for the entire component tree (instead of only among siblings) was because I found that generating a bunch of nodes using a single `innerHTML` roundtrip was cheaper than many small ones. This will still be markedly better than where we were at before, but is definitely worse in the case where there are **many** separate component hierarchy.

As a follow-up, could we consider batching cross-hierarchy between transactions?
 @yungsters Not sure if you saw #1358 and #1363; now I believe we share a reconcile transaction in at least every case where MultiChild batched before, so we're still batching `innerHTML` after this diff.
 This goes in direct opposite direction of the live reconciler that @jordwalke and I started. That's something we should re-explore.

I was concerned that every update would be batched (which is something I considered for better error handling). This only batches moves (which are rare) and deletions. A large set of deletions are common but the signature is pretty small.

I think this is fine to pull in if we want to get it in. Not sure if there's a huge win since it's potentially slower and comes with a risk.

@yungsters Do you think it would be worth while pulling this in to see if it fixes that weird reconciling bug we've seen?
 Interesting‚Ä¶ that bug escapes me, but I can see how debugging across hierarchies might have been making it really hard for me to trace the root cause. Yes! Let's get this in.
 Assuming by "live reconciler" you mean not pre-flattening children (cf. #942), I don't believe this makes that any harder.

I think this is the first I've heard of "that weird reconciling bug"; if it's still happening let me know how to repro and I'll take a look.
 @spicyj That's the trouble, no one can consistently reproduce the issue.

The symptom is that the Facebook comment user interface (e.g. below each post), the row containing the `<textarea>` will render in place of a comment above it instead of at the bottom where it is supposed to be. We suspect it occurs when new stories are sent down asynchronously.

I traced it to `ReactMultiChild`, but I ran through the logic several times and could not figure out what would have caused the new child nodes to be inserted or moved incorrectly.
 @yungsters Today @sebmarkbage concluded it might be #1593.
 Is it valuable to keep this open? Do we have plans to move forward or is this going to end up just being an experiment that influences further designs?
 I still think this should be merged. Last I remember, @sebmarkbage thought it was probably fine but didn't want to merge it while you were all out on vacation.
 We should bring this in but it requires a lot of testing to make sure that we don't have functionality or performance regressions. This doesn't actually change any behavior. We can pull this in as part of something larger, such as error boundaries or something related like that, that actually fixes something.
 @spicyj looks like this needs an update before we can try to merge this.
 @yaycmyk Might happen as part of some other upcoming work. Any reason it's important to you?
 This is just an internal refactoring, should have no user-facing changes.
 Superseded by #5547.

Do I get a prize for closing an old PR?
 :gift_heart: 
 üéÅ
   committed internally. needs to sync
 ab2d59f8b02dfe65d2fe11960389671816904a06
  See https://github.com/facebook/react/commit/7eb33ef176a458679b032f40540ae466a8a03efe#commitcomment-5447724.
  Correct, this mirrors how events are fired outside of React and is expected. Having value changes trigger a `change` event is a good way to make an infinite loop -- if you want to call the change handler you should do so manually, as you mentioned.
  My uninformed instinct would be to include neither but I don't have a great handle of when these are used.
 @jordwalke - you wrote this code, can you take a look. AFAICT we don't actually use any of these metrics, so I'm not sure what use they're serving.
 I talked with @jordwalke and it turns out he didn't mean to leave this code in there. Is anybody using it? I'd prefer to get rid of it. I'm inclined to get rid of it even if people are using it.
 Let's kill it.
 :thumbsup: 
  Looks like you forgot to save the fiddle.
 @eelkeh I believe this was fixed by 5545887a48468ccc8b16c88713a8eb870ba209e6 earlier today. Can you check if the build you were using was after that? (You can also use the builds from http://react.zpao.com/builds/master/latest/ if that's easier.)
  This throws `TypeError: Cannot call method 'removeChild' of null`.

http://jsbin.com/caxipewo/1/edit

``` js
/** @jsx React.DOM */

var X = React.createClass({
  getInitialState: function() {
    return {s: 0};
  },
  render: function() {
    if (this.state.s === 0) {
      return <div>
        <span></span>
      </div>;
    } else if (this.state.s === 1) {
      return <div></div>;
    } else {
      return <span></span>;
    }
  },
  go: function() {
    this.setState({s: 1});
    this.setState({s: 2});
    this.setState({s: 0});
    this.setState({s: 1});
  }
});

var Y = React.createClass({
  render: function() {
    return <div>
      <Z />
    </div>;
  }
});

var Z = React.createClass({
  render: function() { return <div />; },
  componentWillUpdate: function() {
    x.go()
  }
});

var xNode = document.getElementById("x");
var yNode = document.getElementById("y");

var x = React.renderComponent(<X />, xNode);

React.renderComponent(<Y />, yNode);
React.renderComponent(<Y />, yNode);
```

Maybe this can be simplified some more but this was the simplest repro I could make.

Thanks @fforw for sending a repro case over.
  http://stackoverflow.com/questions/21920546/react-jsx-watch-changes-compilation-directory-for-react-js

I can't reproduce it making files in public/ instead of public/js/ but I can repro it making AutoFocusMixin.js.
 @benjamn sounds like commoner trying to do too many things :/
 @michael-jarosik Sorry, @zpao meant https://github.com/benjamn/commoner which is a library that the `jsx` executable uses.
 The `react.js` file (which is un-minified) probably contains `@providesModule` directives that are confusing Commoner. @michael-jarosik Does the problem persist if you remove the `react.js` file from `dev/js/`?
 @michael-jarosik: regarding the reason for the autoFocus mixin: it's there because > IE9 doesn't support the attribute, so we polyfilled it for you. It's used by React's form elements.
#700.
 @benjamn `@providesModule` stuff should not be default of commoner OR if that's the primary purpose (it was a long time ago), we should reconsider it's use for the `jsx` executable.
  I'm not 100% sure if this falls into the same class of things that will start warning in 0.9, but we're aware of the problems this reuse pattern has led to and are moving towards a solution. cc @sebmarkbage 

Closing for now though since this is currently user error (even if we've done a bad job of communicating that, sorry!).
  Hmm, the way you worded this is confusing, it made me think you meant that `<Component context="foo" />` was no longer allowed, not that you couldn't use context as `this.context`. @spicyj - suggestions?
 Maybe just "`this.context` is now overridden on component instances"? @shauntrennery can you add this to the final blog post too (which is in the repo, just not pushed to the site yet)?
 Or maybe "`this.context` on components is now reserved for internal use by React"? @zpao also suggested maybe using the word "reserved".
 @shauntrennery Looks like you only updated the wording on one of the files -- can you make sure to get both?
 Thanks! I squashed into a single commit to make it easier to cherry-pick into the branch.
  I can't remember why we don't already have this, maybe somebody else remembers?

Also, before we can merge this, you'll need to sign the [CLA](https://developers.facebook.com/opensource/cla).
 I think we didn't want the bytes.
 @syranide No, it won't be included in the build without the `require` here.
 I would prefer to put the plugin and injector on addons so we don't set a precedent for unnecessary bytes.
 Let's do the injection @petehunt has in #1170.
  Thanks for the report. We're tracking this in #1072.
  As per https://github.com/facebook/react/pull/1305#issuecomment-99318251, mixins are a legacy feature and we're not really adding things to them at this point.  This issue has been untouched for over a year, closing due to inactivity.
  @syranide `_rootNodeID` can be shared by multiple composite components, correct?

This seems like something that's fragile -- for cases where you only need a unique ID on one client but don't need it to be consistent across clients, you can make your own autoincrementing counter. For cases where you want the IDs to be consistent across clients, I don't think you can rely on `this._rootNodeID` because rendering components in a different order (or with server rendering, on different servers) will cause the node IDs to be different -- when you need this I think you really just want to force the person using a mixin to specify a unique key.
 @syranide I mean if you have two composite components nested with no DOM node in between then they share a rootNodeID:

https://github.com/facebook/react/blob/95edc396dfd07ed064240b5e2e1a1d5528d2d747/src/core/ReactCompositeComponent.js#L839-L843
 @laser IIRC simply that it was there were better ways to approach the problem that doesn't rely on internals. I have a faint memory of him simply generating a unique ID for each component on mount and using that instead, but I could be way off.
 @laser Yeah, if all you need is a unique ID for each component then you can make a counter yourself and increment it for each new component. (We try to avoid adding functionality to React if it can be easily replicated in component code.)
 @davidgilbertson Server-rendering, it will work in some trivial setups but for everything beyond that will cause `count` to become out-of-sync between client and server and cause markup mismatch.
 You could use a WeakMap and store an ID for each instance. `_rootNodeID` was never public API and we no longer needed a unique ID on composite components so we got rid of it. Depending on your use case, perhaps you can refactor your API so that the third-party components are wrapped and your wrapper can generate an ID.
 @ricardosoeiro The approach you describe is very fragile and not really supported. Have you looked into using something like Flux or Redux instead? They support exactly this use case, but in a different and more explicit way.
 @omerts No, they are meant as external state containers. Is there any reason you can‚Äôt convert your components to use external state rather than try to inject local state into them?
 @omerts Usually you don‚Äôt want to depend on third-party components that don‚Äôt offer a ‚Äúcontrolled‚Äù API like `value` + `onChange` props. Is this definitely not the case for components you rely on?
 > I'm not saying this should be supported out of the box, but I've seen this use case pop up several times, so it deserves at least a fair discussion :)

I agree, and this is being discussed here: #4595.

I‚Äôm just saying that, until something like this is supported, it is better to rely on proven solutions that work well (even if they require components to be controlled) rather than on internals that break with every release, and are likely to break completely after some work on incremental reconciler (#6170) or bundling React as a flat file (#6351).
  Related #1259, I believe there's a PR somewhere too.
 We're not going to do this, it's too magical. The solution will eventually be #1259.
  Hey, do you mind signing [the CLA](https://developers.facebook.com/opensource/cla/)? Thanks!
 Great, thank you!
  See also #1079.
 Should be fixed by 5545887a48468ccc8b16c88713a8eb870ba209e6.
  Fixes #1124.

I didn't add `volume` because it requires more complicated logic to control properly and I didn't add `paused` because to set it we need to call play() or pause() -- perhaps a mutation method is appropriate.
 I don't recall what I had in mind when I wrote that, sorry.
  Fixes #1058.
This allows `render` to return `null` and `undefined`. Under the hood,
this renders a `noscript` tag.
Note that this way, `getDOMNode` will still return something all the
time.
 @petehunt 
 Yup, switched to script.
@zpao lol
  Fixed by #1491.
  In the future we should probably run our test suite, but for now this is a good start.

Is it OK to check in the externs and GCC jar?
 We should do a more comprehensive version of this in the future, but I think that this isn't a very high leverage PR.
  I think https://github.com/petehunt/react-touch-lib/pull/1 should fix this for your use case. Perhaps we should also make the code work if there are no dependencies listed -- but probably all event plugins will have dependencies so maybe best to leave required as-is.
  @Evernight Can you post a simple example of what your code looks like? I wasn't under the impression that listening to keydown/keyup will work with controlled components. (By the way, how would you want to react if someone were to paste in text or move it around using the mouse, etc., in a way that doesn't cause key events?)
 @Evernight What do you mean, it ignores the mouse events? This is a strange case and you can write `onChange={function() {}}` to suppress the warning.
 @Evernight Yes, this is because you're not handling onChange. It sounds like you might want an uncontrolled component. See http://facebook.github.io/react/docs/forms.html.
 This seems like a "wontfix" as it's only meant as a helpful warning, not an error.
  Fixes #1115.
 Might as well fit it into 0.9. Have I said lately that we should do a proper pass through DOM attributes again?
 @syranide I'm concerned that would result in subtly broken updates for many of the attributes.
 Is it a problem if I specify `rowSpan` on an input?
 Agree that HTML and SVG attributes should be separate.
  This has been replaced by `require('react')`; see http://facebook.github.io/react/blog/#jsx-compiler-and-react-tools-package
  Docs page is a bit ugly but we should revisit how we do our reference pages sometime anyway.
 ```
   raw     gz Compared to last run
     =      = build/JSXTransformer-previous.js
     =      = build/JSXTransformer.js
     =      = build/closure-react.js
     =      = build/react-previous.min.js
     =      = build/react-test.js
+11832  +2706 build/react-with-addons.js
     =      = build/react-with-addons.min.js
     =      = build/react.js
     =      = build/react.min.js
```
 (I would personally prefer we merge #939 before adding this‚Ä¶)
 So... do it for 0.9 or no?
 Yes

Sent from my iPhone

On Feb 18, 2014, at 10:23 PM, "Paul O‚ÄôShannessy" <notifications@github.com<mailto:notifications@github.com>> wrote:

So... do it for 0.9 or no?

‚Äî
Reply to this email directly or view it on GitHubhttps://urldefense.proofpoint.com/v1/url?u=https://github.com/facebook/react/pull/1112%23issuecomment-35469859&k=ZVNjlDMF0FElm4dQtryO4A%3D%3D%0A&r=qYx6qLphxKhA5vHBqr9vuw%3D%3D%0A&m=se2TB7Uo%2B3DeaevTkj3CBJUvdqS%2BExBf1VYP%2FVEe4V8%3D%0A&s=1c71f76f170e68777d8858c1b1b54ea6e2ce85680612cb6c17ead426690cf96a.
 @EtienneLem Try http://react.zpao.com/builds/master/latest/react-with-addons.js.
  I'm pretty sure they don't. Can you try again?
 Can't repro. Closing; feel free to reopen if you have a repro!
  What command are you running, and in what directory? I'm having trouble reproducing the slow-down with just `browserify -r react`.
  Yeah. Definitely a launch blocker.
 Dupe of #1105. It breaks only with input because ReactMount's node cache doesn't get populated if you just render a span without ever calling getDOMNode().
 I am still seeing this error even on 0.9 with `select` and `checkbox` inputs. The catch is that the component is rendered inside an unwrapped Polymer element (`unwrap(el)`)

I am not sure if this is a bug with React or not, but it is entirely unclear to me how to resolve the problem.

Can anyone help nudge me in the right direction?
 @dlindahl Can you post a minimal jsbin or jsfiddle showing the problem in a new issue?
 @spicyj Done: #1263
  Text child is a string so `isValidComponent` fails. Would it make sense for it to accept a string? Frankly I'm confused by this API...
 @slorber http://facebook.github.io/react/docs/top-level-api.html#react.children.only
 @spicyj @sebmarkbage is this still the case now that we wrapped this?
 Nothing here has changed. If you call `onlyChild(this.props.children)` on a (string) text node, it still isn't a valid ReactElement.
 It's not an element. It's a ReactNode. Might be possible to have an isValidNode but I thought we have a propType for that already.
   @petehunt I don't think you have enough docs to write :wink: Want this too or does somebody else want to grab it?
 I'll do it now
 #1132 
  man, `map` returns an object?
 Thanks! If there's more we want to change in the docs, let's open another PR.
  reduced to a single commit: 78ac842b4ab90651652e02d900d49c37d123286b
  Do what you need to do @petehunt. cc @joshduck

Not going to block 0.9 because I don't think people are using the perf stuff, but we should fix asap.

<!---
@huboard:{"order":1091.0,"custom_state":""}
-->
 I'm going to go ahead and declare the 6 months of inactivity means we're just not going to do this. It's getting worked on for native support and we don't appear to care much. https://bugzilla.mozilla.org/show_bug.cgi?id=899753
  This should have been fixed by 7a9e5443b7184986e08e411d9e9ad2d7228c7827. If you're still having trouble on master, let me know.
 That guard immediately precedes the only call to `getSelection`. In the debugger, can you see what `node` is?
  On re-render, we [sometimes](https://github.com/facebook/react/commit/f9551d709ef0d168c2f7adc21814bdd74068163c) [use](https://github.com/facebook/react/commit/23ab30f) innerText. This causes inconsistencies in rendering whitespace. See demo:

http://jsfiddle.net/nbA2M/

We should make sure this doesn't happen.
 We switched to use `textContent` but it broke some contentEditable stuff internal to FB. @zpao knows more.
 I'm switching it back (D1174395), but regardless, this is an innerText issue. Browsers that don't have textcontent (ie8) suffer
 looks like this was brought up in #923
 Right, we should also do the right thing in IE8.
 jQuery empties then adds a text node. Relevant commits:

https://github.com/jquery/jquery/commit/866187fff66ef50b9c4b4c47f332f742c7546cc5
https://github.com/jquery/jquery/commit/74a132d944886379456d562990c8fb217ab332e3 (http://bugs.jquery.com/ticket/1264)
 okay interesting. I'll do this for ie8
 @jbonta I have a patch almost ready.
 hmm interesting. We definitely want to preserve whitespace though. (because of `<pre >` and `white-space:pre` and `<textarea>`)
  This fails:

http://jsfiddle.net/E8gCL/5/

Might be fixed by #994, haven't tried.

Related to #860 and swannodette/om#47.
 I'm not even sure we should run componentWillMount.
 Is this changed from 0.8? Or not a new problem?
 Not a new problem.
 The internal diff fixes this.
  Was talking with Adam Wolff today about rxjs and there are a ton of common bugs with these functions. You're gonna have a bad time if you use these in React `render()` methods too -- if we monkeypatched these to warn in `__DEV__` we could prevent some bugs. @jordwalke seemed to like the idea too.
 Can you give an example of such bug?
 I will respectfully say "meh" and that I generally don't agree with overriding builtins. Would love to hear more about the bugs encountered.
 Anytime you call anything in render() that uses these you may break server rendering or make some interactions behave strangely. This is a bug we had at Instagram -- you should not read from the rng or clock in a reactive system since your code may be rerun at any time.
 ^ Agreed. I think these are far more common.
(You guys want at least a tip entry? lol)
 @steveluscher That sounds kind of fragile to me, I think time is ubiquitous enough that `Date.now()` should be exported by React as `React.now()`. So that when _any_ rendering inside React takes place, time is frozen and all subsequent calls to `React.now()` returns that same time.

For `React.renderComponentToString` the frozen time would also be added to the root element next to the checksum, which would be used for the initial rendering on the client when reusing the DOM.

Aside from just fixing mismatches between client and server rendering, it would also prevent edge-case inconsistencies in rendering. Two identical timer components can currently show slightly varying times, or say an item could show as expired in one place and not expired in another if the timing is just right. This would prevent that entirely.

@petehunt Any spontaneous reaction?
 This sounds like it'll be super confusing when one component uses React.now() and another one messes up and uses Date.now().

Would prefer if we monkeypatched Date.now(), Math.random() and friends to log a friendly warning if called while in a reconcile
 @petehunt I see your point and unless I'm mistaken it would only be confusing/broken for the component that uses `Date.now()`.

I'm not sure if I understand your intention about monkey-patching Date.now() and Math.random() to warn the user, I agree with that part. But isn't time ubiquitous enough that we should provide a utility for it, rather than have everyone invent their own? Especially since, as far as I know, there is no way for the user to know when to freeze and thaw the time appropriately for React.
 @samwgoldman Propagating the time through the hierarchy does not make sense. Theoretically, every component instance should update every microsecond. Time is ubiqutious. If your UI goes back in time, time would still continue forward, it simply does not belong in props IMHO.
 > I also don't agree that component instances should update every microsecond. When would you want that? I could see a component that needed to update each second, but rendering should be sub-second (at worst), so it shouldn't be a problem to re-render with a new "moment" in props each second.

If I'm making a precision timer or animations then I would want to update once for every screen refresh (which would be 60-120Hz and up), I would consider it unacceptable for the entire app to have to rerender or to settle for significantly less than optimal timer precision.

A full rerender of a reasonably large app can take significantly long time, it is simply unacceptable to re-render the entire app. I also object to the idea of chosing an inferior implementation only to accommodate an interpretation of someone's subjective recommendation. To me, the very fact that you have to have make significant sacrifices to the fidelity of the value/time, to accommodate propagating it through the hierarchy, means that it is flawed.

While I see the merits of sending all props up through the root, I'm not at all convinced that it is the end-all be-all. Treating components as isolated instances that only has access to circumstancially _relevant data_ is fantastic for many reasons. But, it does not entail that being a transport for _irrelevant data_ (from the perspective of the component) is inherently fantastic too.

Food for thought, when you want to show an image, which of the following do you put in the prop:
A. URL (resource identifier), which is "impure".
B. The raw image data, which is "pure".
 I have something like that already, including precise timeouts and dynamic units for elapsed/until. I should polish that up and NPM it perhaps.
 Too controversial to be a good first bug, so let's get rid of that label.
 This has been inactive for over a year, and it doesn‚Äôt appear like there any plans to do this. With the explosion of JavaScript build tools and polyfills, we have been trying to be careful to not add surprises or touch the built-ins, and I think it has been the right call. React Native is actually running into some issues right now because of conflicting polyfills, and it‚Äôs great we‚Äôve been able to avoid those so far by not touching the built-ins.

I‚Äôm closing this but please let me know if I‚Äôm making a mistake and we should reopen. Thanks!
  Also reverted forEach back into vanilla for loop, as it seems more used in the codebase.
 Good find.
 Can you add a comment saying why we need to use Object.keys?
 Yeah. I put it back.
 @chenglou please add Object.keys to http://facebook.github.io/react/docs/working-with-the-browser.html since we are requiring other parts of the ES5-shim, this should be totally fine to use.
 @cpojer right, done #1087.
 123ed1f4425230aa336a7ea616064e8cdbd9dfd9
  If we're going to use the attribute, perhaps we can just mark it MUST_USE_ATTRIBUTE and get rid of the custom mutation method; DOMPropertyOperations.setValueForProperty will call removeAttribute for a null value.
 Hmm, looks like this will break things in IE actually:

http://stackoverflow.com/questions/2490627/how-can-i-reliably-set-the-class-attr-w-javascript-on-ie-ff-chrome-etc
 My idea was:

```
if (typeof node.className === "string") {
  node.className = value;
} else {
  node.setAttribute('className', value);
}
```
 Any updates on what we're going to do here?
 Closing in favor of #1264.
  Fixes #867.
 Can you rebase? 5c953a7bdd606337ce6d93b157a78117a8c6148f happened.
 Done.
 Err, wait.
 Actually done.
 Going to hold off on this and get some closure experts in here.

```
13:04 <poshannessy> why would that break them?
13:04 <poshannessy> just keys in an object
13:05 <poshannessy> ohhh if they use closure?
13:06 <phunt> yea
13:07 <poshannessy> i have no idea
13:07 <poshannessy> uhhh, for the most part, these shouldn't have been getting crushed
13:07 <poshannessy> if they were, then shit would be subltly broken for them
13:08 <poshannessy> (eg, we would set style.asdawe instead of style.backgroundPosition
13:09 <phunt> i thought that closure knew about all symbols in dom api
13:09 <phunt> which would render this unnecessary
13:09 <phunt> (the one time i added quotes to "fix something in closure" i ended up *breaking* closure, which is why i am pushing back)
13:10 <phunt> i wonder: should we run our test suite in closure advanced mode? what would it take?
13:12 <poshannessy> https://code.google.com/p/closure-compiler/source/browse/externs/w3c_css.js
13:12 <poshannessy> i bet our test suite doesn't test all of the things it would need to
13:13 <poshannessy> lineClamp isn't there
13:13 <poshannessy> because its nonstandard
13:14 <phunt> poshannessy: is there a way to do it without quoting
13:14 <phunt> like some sort of config people could inject in
13:14 <phunt> remembering which ones we need to quote and which ones we don't might suck
13:14 <poshannessy> externs?
13:14 <phunt> is that what those do
13:15 <poshannessy> i believe so (but i've also never actually used closure)
13:15 <poshannessy> we could start maintaining a react extern
13:15 <poshannessy> somebody else is already doing that i think (dustingetz maybe)
13:17 <poshannessy> i'm also pretty curious what happens with our dom property list if our camelCasing doesn't match the casing in externs
13:17 <poshannessy> let's just hold off on this and start a discussion on GH?
```
 Closing for now.
  Objects don't have a `map` function. You can iterate through an object like so:

``` js
var mapped = {};
for (var key in obj) {
  if (!obj.hasOwnProperty(key)) {
    continue;
  }
  var val = obj[key];
  mapped[key] = ...;
}
```
 React doesn't provide a .map function; it's part of the JavaScript standard and is provided by the browser.
  Fixes #1058.
 Yea, I think making `<null/>` work might end up being a mistake, for IE8 and also because I think it's too magical. Let's do something a little less drastic and not piggyback on `React.DOM`. `React.NullComponent` (need that namespacing @jeffmo so we can do `<React.NullComponent/>`).
 Empty?

Sent from my iPhone
 Are we sure that this is worth the extra API surface area?
 Not sure. How much work is the returning `null` from render?
 Yeah screw this! Will find a better solution soon.
 Consensus from a few people is to make `null` a bit magical and make core understand it, but still render out to a DOM node. We'll see if it messes with people's assumptions.
  TLDR: Let's allow `style={msTransform: '...', webkitTransition: '...'}`

for stylenames, we [recommend](http://facebook.github.io/react/tips/inline-styles.html) that JavaScript keys start with a capital letter for vendor prefixes, presumably because [hyphenation](https://github.com/facebook/react/blob/63d6cc013e3dfffdc7c924f9d0309c73e471aa74/src/vendor/core/hyphenate.js#L32) is then trivial (so they start with a single leading hyphen). This forces a user to put a vendor-specific key that isn't even valid, or it produces css that [doesn't](http://jsfiddle.net/wkLBM/) really [work](http://jsfiddle.net/n7gxp/).

We probably need to re-work this, or build awareness of vendor-specific prefixes into the core of react's style building. This comes up [here](https://github.com/facebook/react/commit/5abcce534382d85887f3d33475e8e54e3b5d8457#diff-c524cc735426e792db75807b0d78e742R59) too.
 I believe the vendor prefixes `Webkit`, `Moz`, `ms`, `O` are now supported consistently with that capitalization.
  `encType` should work. See the list of supported attributes here:

http://facebook.github.io/react/docs/tags-and-attributes.html
  Like `state`, contexts are explicitly designed to be used with plain JS objects that get merged ‚Äì contextTypes and childContextTypes are similarly expected to be plain objects. I'm inclined to wontfix this, but I'll leave it to others who've used contexts more than me. (Of course, you can use whatever objects you want as values within the context object.)

Also note that the API for contexts is experimental and may change any any time.
 @sebmarkbage with the move of `merge` to just being `Object.assign` and even further away from prototypes, do you think we'll ever do this? I'm also inclined to wontfix (he says 6 months later)
 Unfortunately React may need to work in environments where Object.prototype might be mutated. This means that all of your objects would get that extra property. Built-ins in the language like `Object.assign` move towards using hasOwnProperty checks on everything. Also, classes in ES6 provide enumerable methods that also otherwise be picked up by this. It's all designed around hasOwnProperty checks.

I wish that wasn't the case. I wish that prototype chains could work well in JS but once you introduce Object.prototype and explicitly expose reflective APIs over prototype chains like hasOwnProperty, Object.keys, Object.getPrototypeOf etc. Then the battle is lost.

I believe the kind of optimizations that prototype chains provide is possible at the VM engine. Much larger issue than withContext so unfortunately we can't support it.

Btw, the withContext API is almost certainly going away. Use getChildContext instead.
  Fixes #906.
 @zpao takes this one, but I do think that name is better.
 I"m going to say, let's shelve for 0.10. I want to make sure we expose things meaningfully and not just because.
 You made some changes around batchedUpdates recently... how much do we still want this and should we stick it on addons for a bit to try it out first?
 It's still useful to have unless we're planning on moving to rAF batching everywhere soon (which we're not, afaik). I don't really care if we put it in addons or in React.betaFeaturesThatArentReallySupported or what but I think we should have it somewhere, otherwise it's impossible to do things like batch within a Flux dispatch like you do at FB.
 k, let's put it in addons and get it out then see how we feel.
   They are not called on the initial render of the transition group, only when they are added to an already mounted transition group
 ...which should probably be documented
 @plievone yeah that's right. I think the rationale is that animations are not desired during the first render, as you might want to directly display all the items. This way is more flexible as you can just manually call whatever animation api if you want on mount.
 Can you update the transitions example too?
 I stole the code change because I wanted to try to get a final build together. I'll let you wrap up docs :)
 Ping? I'm going to cut tomorrow at some point and would like to not have to double land docs.
  People have some varying hacks to allow a component to render "nothing". We should add a stopgap standard solution until we support components returning `null`.

So I'll propose something like in the title. Or maybe `<null>` (aka `React.DOM.null`).

It can probably render to `<noscript/>`, which is one thing people are doing. `<span/>` is another thing. Ideally something that doesn't break flow.
 Might want an invariant that this has no children.
 Ok, here's a solution:
return `null` will work, but renders to something like `<noscript />`.
This way, `this.getDOMNode()` will always return a node. Even if it's `<noscript />`.
What do you guys think?
 Return null and render to script.
  Want to add them? We're going to cut 0.9 very soon, so if you'd like them in before 0.9.1 whenever that happens, now is the time (also backportable to 0.8.x if we do one)
 @thechriswalker So sorry, wasn't sure if you were planning to!
  I appreciate the effort, but let's revert the changes to `src/` I don't actually care and I think I'm going to remove the maxlen rule entirely (with a soft enforce).
 Thanks for sending this in! I pulled out fixes to 42e20a1, hope you don't mind.
  With block-level elements, it's obvious that we could ignore whitespace text nodes without much problem. For an inline element though, spacing could change the appearance. I'm tempted to just warn but still require not having whitespace‚Ä¶
 cc @petehunt 
 We just need to change our use of `firstChild` in https://github.com/facebook/react/blob/b9cd2f0d3d83ee9652b230fecc4bc2dfe8e110f8/src/browser/getReactRootElementInContainer.js to be `children[0]`.
 Ah yes; closing this one.
  See #1046.
 That's the only guard function I know of and it's the one you linked to in your SO question.
 @totty90 In React 0.9 you shouldn't have any problem with the guard in either version. You should do development with unminified react.js and production with react.min.js; the former has helpful warnings while the latter has extra performance optimizations.
  Property names are case-sensitive; attribute names are not.
 Good point. We have #1008 open to remind us.
  Seems like you misunderstood how `unmountComponentAtNode` works. First, `this._rootNodeID` is an internal identifier used for `data-reactid`. `unmountComponentAtNode` asks for a DOM element so giving it a string doesn't do anything. Second, just as the docs stated, you pass the **container** node on which you mounted the React component. So if I did

```
React.renderComponent(<App />, document.getElementById('abc'));
```

then I'd do, on the **container**

```
React.unmountComponentAtNode(document.getElementById('abc'));
```

So really simple (and don't play with `this._rootNodeID`). Either re-select that element or keep a reference to it.
 `this.getDOMNode()` gives you the DOM node that is the component, but like I said, you need to call unmount on the wrapper, not on the element component itself.

That aside, like plievone said, generally you shouldn't be unmounting stuff this way. Here's an example that might be better suited for your situation:

```
/**
 * @jsx React.DOM
 */
var App = React.createClass({
  getInitialState: function() {
    return {displayMessage: true};
  },

  handleClick: function () {
    this.setState({displayMessage: false});
  },

  render: function() {
    var message;
    if (this.state.displayMessage) {
      message = <span>Hi</span>;
    }
    return <div onClick={this.handleClick}>{message}</div>;
  }
});

React.renderComponent(<App />, whateverWrapper);
```

Use `unmountComponentAtNode` sparingly. The "React way" of doing this is to render whatever you have based on a component's props and state at each render, and not arbitrary modify them, since everything's harder to track otherwise.
 Make the parent hide you, instead of trying to hide yourself. `this.getDOMNode()` gives you the DOM object.
 Specifically, it's important for maintainability to be able to have some component in the hierarchy clearly define what's visible on screen. If I have a parent component that displays:

```
<div>
  <Child1 />
  <Child2 />
</div>
```

then it's confusing if `Child2` can remove itself from the DOM because when looking at the parent's render method I'll expect that `Child2` will exist. On the other hand, if I have

```
<div>
  <Child1 />
  {this.state.showChild2 && <Child2 onHide={this.handleChild2Hide} />
</div>
```

then I can clearly see that `Child2` will be included only if `this.state.showChild2` is `true`, and presumably I can also see when `handleChild2Hide` will change the `showChild2` -- in certain cases, the parent might want to show a confirmation box or have some other reason for not honoring the child's request.

@gassorr Does that make sense?
 @gsantome Thanks for letting us know. It's likely we'll change unmounting to be batched, just as state updates currently are, which should fix your problem in another way.
 @amit-jamwal The node you passed there must be the same one that you previously passed to `ReactDOM.render()`. That‚Äôs what the warning says: you want to be unmounting the container node you renderered _into_, not a node managed by React that is defined in some component‚Äôs `render()` method. To unmount an inner node managed by React, use `setState` as described above. 
 @JashonWang Usage questions should be asked on StackOverflow, as we use github issues for tracking bugs in the React core.
 @JashonWang This comment covers exactly that scenario: https://github.com/facebook/react/issues/1044#issuecomment-34588968.
  Currently, React requires a tbody to work properly, as you found. I have a pull request open (#735) to warn about this common error.
  Thanks!
  Fixes #1015.
 Looks good to me.
 @syranide ah, true. Updated. Thanks!
 6203e53d16be80db5661f5bd51947fec0dc083fb
  - will add `react-tools.tgz` to http://react.zpao.com/builds/master/latest/
- removes `exports.React` from `react-tools`, stops shipping build files
  - still shipping `src/` for `react-page`

cc @petehunt, @spicyj, @andreypopp, @syranide, anybody else using React in the real world who might want to argue against removing React from react-tools
 Eh, here's a use case for `require("react-tools").React`: https://github.com/benjamn/react-meteor/blob/master/src/require-react.js
 @benjamn That's the easiest to fix: `React = Npm.require('react')`. I was more concerned with cases where people were accessing something like `require('react-tools/build/modules/*')`
  Thanks! If you haven't already, could you sign [the CLA](https://developers.facebook.com/opensource/cla/)?
  While this is true it sucks for people who want to do full-page server rendering. I think if we claim to support full-page server rendering we should at least support doctype.
 I'm not sure if html comments are a deal breaking use case -- are conditional comments the only solution to these problems? -- and doctype can be prepended by your web server request handler or static build system. 
 @jeffmo 
 BTW: rendering on the server doesn't necessarily mean that we need to be able to render full pages, especially since browser support for updating `<html>` and `<head>` is so sketchy. We've gone back and forth as to whether we want to actually support this or not for this reason.

We could probably get comments into core with a little work (mostly just cloning ReactTextComponent to work with comments and figuring out how to look it up by ID), not sure about the jsx transform. Not sure if we can prioritize this relative to other things (especially since this can be worked around), but I think a PR would definitely be considered.
 Sometime between Tuesday and Friday
 @balanceiskey React can't mount higher than `body` client-side, so I doubt there is much pressure to get it done. And I'm not sure if I understand the issue, can't you just prepend a fixed doctype before the React output?
 @zackify That's unrelated, please file a new issue with steps to repro
 No update.
 @baygeldin Specifically, can you define "go crazy"?  Which browsers, changing which nodes?
  Thanks! Could you please sign [the CLA](https://developers.facebook.com/opensource/cla/)?
  Thanks!
  As @plievone mentioned, there are several more places to make changes to before this can be accepted. #868 is a good model.
 Sorry for the delay! I just noticed that you had pushed new commits. Can you rebase though, we've already added dx and dy. We also need a change to the transform to make sure `<tspan>` gets transformed to `React.DOM.tspan`. You can do that here: https://github.com/facebook/react/blob/master/vendor/fbtransform/transforms/xjs.js
 This looks great, thanks a lot! I just split HTML and SVG properties into separate files so unfortunately you have a little bit of work to rebase there, sorry about that timing. But I made the internal diff, so as soon as you're ready, we should be good to go.
 Thanks! Sorry that took so long :/
  Make sure you're using the polyfills described here:

http://facebook.github.io/react/docs/working-with-the-browser.html#browser-support-and-polyfills
 It's possible that JSXTransformer doesn't work on old Android but React itself does. Does this version work any better? https://gist.github.com/spicyj/8838019
 fwiw, I would strongly suggest precompiling your jsx to js before sending to a browser.
  tl;dr: In IE8,

```
React.renderComponent(React.DOM.section(null, 'hi!'), document.body);
```

doesn't work:

![image](https://f.cloud.github.com/assets/6820/2095055/da7f81b8-8ed9-11e3-958f-cc46b659348d.png)

---

Background: To make HTML5 tags such as `<section>` work in IE8, one needs to do something along the lines of:

``` js
<script>
(function() {
var html5elements = ["header", "footer", "nav", "article", "section", "menu"];
for (var i = 0; i < html5elements.length; i++) {
    document.createElement(html5elements[i]);
}
})();
</script>
```

as well as create a CSS rule for them with `display: block;` (which [html5shiv](https://github.com/aFarkas/html5shiv) will do for you). After running this code, IE8 will behave sanely with all of these elements when manipulating `innerHTML` on document nodes.

However, if the nodes aren't attached to the document, it decides to be sad and not work, and we specifically detach nodes from the document whenever we set `innerHTML` on them: [ReactComponentBrowserEnvironment.js#L131-L145](https://github.com/facebook/react/blob/master/src/browser/ReactComponentBrowserEnvironment.js#L131-L145).

jQuery gets around this by creating the HTML5 elements again in a document fragment before inserting them into the document: https://github.com/jquery/jquery/blob/1.x-master/src/manipulation.js#L18-L30. We should probably do something similar.
 Fixed by 7eb33ef176a458679b032f40540ae466a8a03efe.

(cc @jnetterf)
  Recently we came across the following:

``` js
/** @jsx React.DOM */

var CountdownView = React.createClass({
    componentDidMount: function() {
        this.timeout = setInterval(this.forceUpdate.bind(this), 1000);
    },

    componentWillUnmount: function() {
        clearTimeout(this.timeout);
    },

    render: function() {
        return <div onClick={rerender}>{Date.now()}</div>;
    }
});

function rerender() {
  document.body.innerHTML = '<div id="container"></div>';

  React.renderComponent(
    <CountdownView />,
    document.getElementById('container')
  );
}

rerender();
```

Live demo: http://jsfiddle.net/spicyj/EGmvT/

Note that I'm manually removing the component element from the DOM here (when I should be using `unmountComponentAtNode` instead). In IE10, clicking the timestamp once will thereafter cause a JS error from findComponentRoot every second, but in Chrome and Firefox no errors are thrown. Why?

(In addition, it would be nice if we could give some useful message here. If you instead clear `document.body` completely and render into `document.body`, you get a somewhat-helpful warning: "ReactMount: Root element has been removed from its original container.".)
 Yeah, it queries the DOM each time.
 Wontfixing this.
  I'm not sure. Technically `onChange="{func}"` is an acceptable use case, as in, as a child I might actually want the (misleadingly named) `onChange` string to display some text, and it'll have nothing to do with an event that's coincidentally called `onChange`. You can detect them if you put `PropTypes` though.
 Well, we can certainly complain for `<input>` and for all DOM events on DOM elements. You get a similar `string is not a function` error for other tags.
  Also added tests for PooledClass.
 =D
  Let's try to keep GitHub about issues with React, not a support forum. [Google Groups](https://groups.google.com/forum/#!forum/reactjs) and [Stack Overflow](http://stackoverflow.com/questions/tagged/reactjs) are better suited for that.

To answer your question though... yes. I would pull the call to `this.props.handle` into another function because binding on each render adds up:

``` js
React.createClass({
  handleClick: function() {
    this.props.handle(this.state)
  },
  render: function() {
    return <button onClick={this.handleClick} />
  }
})
```
  Thanks for reporting -- this is a dupe of #916.
 (Also turns out there was an unintentional update to the website making it use code from master instead of the release -- just fixed in 5af1ac1 so the website should work again now.)
  React.PropTypes.arrayOf can be super useful to describe a propType that should be an arrayOf(Thing).

I modified some of the PropTypes code to make it a little easier to understand and all validators now return a value.
  Sounds like a bug to me.
 Fixed in master now.
  Could you expand a bit on the rationale for why you don't consider key synonymous with identity? As I see it, key encapsulates the identity of the child. However, since you could have multiple instances of the same user, it may also encapsulate some positional information in addition to that.

I rarely, if ever, see a use case where the identity should not be part of the child. Could you expand on a use case for this?

Note that the key hack can also be used at the top level. So this feature can be hacked by simply wrapping once.

I'm concerned about having two ways of doing this, and in the general future direction we're moving even more responsibility of updates to the parent. E.g. the parent needs to reason about how an update to a child gets handled, where it gets placed and how it may affect other siblings.

You also bring up an interesting point. Should the state of the inner child be able to cause the child itself to unmount? I don't think it should be able to. That may break the assumptions of the parent. I'd love to see a real use case for this.
 For a set (unique values) the identity of each value should be favored as the key, since that clearly identifies reorders.

For a map (e.g. a dictionary) the key of the map should be used as the key of the list item. Often though, that list item is a generic item wrapper around a value. The value is represented by a different component and therefore gets it's own key based on the identity of the value.

`ComponentA === ComponentA` and `ComponentA(car) === ComponentA(airplane)` are both checks that are currently available, except that they're based on keys and they live in the parent. This makes the strong contract that a parent decides if something gets places, where something gets placed (even if a component travels though multiple intermediates) and when it's removed.

It would for example be very strange to have a child allowed to unmount itself. Therefore I think the concept of unmount/remount is the wrong abstraction here.

I see the problem that you have though. It's true that you wouldn't want to leak details about the internals of a value to the parent. That possibly breaks encapsulation.

Currently a component should be able to handle any change. Major changes to the props can also affect state through componentWillReceiveProps, allowing the internal state of a component to reset. Albeit, not necessarily the entire component tree. However, ideally the entire tree should be resilient, but if it's not, you can use a key where you wish to reset part of your tree.

I would be much more comfortable with an API that helps you reset your internal state and flush all your children, rather than telling your parent to remount you. The child should never be responsible for it's own life-cycle, but can be responsible for it's children's life-cycle.

Something like `shouldRetainChildState` or something would be nicer but affords less control than keys since it can't be applied to a subtree. This could be accompanied with an easier way to handle operations that you want to do on both mounts and updates. For example: `componentWillMountOrUpdate`.
 As a side-note, I really wish Components didn't have so much boilerplate and stigma associated with them. If Components felt more lightweight, this wouldn't be as much of a problem, since you would just wrap it in a function call.

``` javascript
return <ul>{items.map((value, key) => <Component key={key} value={value} />)}</ul>;
```

``` javascript
let Component = props => <InnerComponent key={props.value.id} value={props.value} />;
```
 @sebmarkbage What would you suggest for this use case? https://groups.google.com/d/msg/reactjs/7XCeBSlO4nM/5M-LdjSm9kkJ
  Thanks, can you also add them to ReactMultiChild-test and Danger-test? Dunno if there are others.
 Thanks!
  This should already work properly on master ‚Äì `__owner__` was moved off of props -- in addition, props are always copied so React should now never mutate what's passed in.
 Before, but 0.8.0 didn't include all changes in master at the time. The two changes you'd be interested in are 61abc645e50314187850d4e04ed6d257652f1a59 and 657602135ce8a661aa1d60b338b3483d3ab505ff.
 0.9 will be out _soon_ with that.
  Thanks! If you haven't already, can you sign [the CLA](https://developers.facebook.com/opensource/cla/)?
 Thanks!
  wowzers.

Can you send me a link to the `react.js` output file so I can take a look at what it looks like?
 This is great!
 So it looks like the name `require()` never appears in the output bundles, right? This would fix https://github.com/ForbesLindesay/umd/issues/10 for us
 We probably want to change the file names so they don't imply the use of browserify. Maybe something more generic, like `grunt/config/bundle.js` etc.?
 Just talked with @benjamn a second too late, but we're going to revert and ship 0.9 with the knowns (browserify) instead of introducing this right now. I want to cut that branch this week so hopefully we'll reland this in master right after that.
 Ping, 0.9 is now live :)
  We should really try to hit this milestone
 nm, fixed.
 Lol
 ![keen-clapping-after-loss](https://f.cloud.github.com/assets/8445/2046599/93f38e0e-8a08-11e3-8175-393537ae2a4b.gif)
  So the problem here is that when you do `<p class="parent"><p class="child"></p></p>` browsers are like "aw helllllll no" and they change the DOM to `<p class="parent"></p><p class="child"></p>` This mutation happens _after_ React has done it's thing.

This is completely true if you were doing this in straight HTML too, so it's not a new problem. It's just that you don't try to move elements in HTML. You can see this with some simple styles. On top of that, there are several ways in which this can happen. Another example is nested `<a>` tags.

Here's an example of the problem in HTML+CSS: http://jsfiddle.net/zpao/fgth2/ (and in fact it looks like the DOM gets super crazy and adds an entirely new `<p>`. :shit:

And since React isn't doing anything wrong, I'm going to close this out. Use the `<div>` to wrap `<p>` and you'll be fine. Thanks for the detailed report though! I
 We'll hopefully have an explicit warning for this soon.
 @kulicuu could be different browsers handling incorrect markup differently. Without any other information that's the best I can say.
  My inclination would be to ignore only text nodes comprised solely of whitespace.
 @syranide I thought your PR only modified jsx -- this is about adopting server-rendered markup.
 ([petehunt says](https://github.com/facebook/react/issues/1050#issuecomment-34902147): "We just need to change our use of `firstChild` in [src/browser/getReactRootElementInContainer.js](https://github.com/facebook/react/blob/b9cd2f0d3d83ee9652b230fecc4bc2dfe8e110f8/src/browser/getReactRootElementInContainer.js) to be `children[0]`.")
 I experimented with a possible fix a little bit. As @spicyj said in #1050 it might be worth it to not ignore prepended non-whitespace text.

[This gist](https://gist.github.com/JannesMeyer/7db5fc0dff1fdfe465d6) would be the necessary code if you want to make sure you only ignore text nodes that consist purely of whitespace. But this would get rather more complex if you wanted to make sure you account for the edge case of alternating comment nodes and text nodes until you actually find an element node or a text node with non-whitespace content.

Therefore I think it would be much easier to implement @petehunt's proposal and just use `container.children[0]`.

In my opinion it makes no sense to do this non-whitespace check, because React doesn't actually make sure there is no appended non-whitespace text neither when re-using DOM nodes that came from the server.
  thanks!
  @syranide I think that's from a rebase or something, we checked that in already. Though something funky is going on.

@jjt can you rebase so we only see your changes here?
  Took a quick glance at your diff. I couldn't tell, but it looks like it preserves the original `'x.y'` ID scheme inside of rootNodeID. When implementing the current ID scheme, it seemed like the easiest way to guarantee a fairly deterministic ID assignment such that errors are easily spotted and programmatically detected - especially in the context of server rendering. What I mean by this, is if you traverse the ID path generated on the server on some event, you could easily tell when your local version of nodes is different than what the server generated. If we chose rootNodeIDs of 1, 2, 3, it seemed more difficult to detect the non-determinism. Luckily, @petehunt implemented markup validation for server rendered markup! So that means some of the reasoning behind the `x.y` style IDs may no longer apply. So `_rootNodeID` could itself take the form of monotonically (and deterministically) increasing integers.

The main change would be in event handling, where we can no longer parse the ID string to bubble/capture. I've actually found that (at least on a non-JIT VM) considerable time can be spent parsing these string `x.y` IDs during event propagation and I'm hoping numeric ids provide an opportunity to increase the performance here. Also, there would be far fewer string concats, though I don't think that's our bottleneck. Implementing this means you'd likely need a global lookup map of child to parent ID. Thoughts?
 Incremental refactors like that are almost always better, so I'm glad you've thought about it that way. But it might be nice to get them all staged up stacked on top of each other just to prove that the final outcome actually does what we want, and so we can get a sense of the performance improvements/harms. There could be something we're overlooking in the implementation as well.
 @johnthethird Even though the generated markup changes each time, I don't think you should have any problem from caching it.
 Are we still considering this? (pinging @sebmarkbage @petehunt @jordwalke)
  This should have been fixed in master by https://github.com/facebook/react/commit/f0fdabae7bbeadde9245d00893b194e0310c8d9b.
  So I kinda think that example is too contrived and hopefully not representative of what people will actually do for object as a child (converting an ordered array to an object!). For the case you have here we would say use the `key` prop, not prefix keys.
 @syranide - this came up yesterday internally and there's a diff coming which adds a warning if you use an object with numeric keys as `children`. That's still allowed and the details of object iteration order and not well known to all programmers, so we want to help. Other parts of the code that depend on implicit object iteration order are ok (I'm not sure where else we have that dependency but I wouldn't be surprised).
 I'll change the example and get this in.
  :thumbsup: There are actually still a non-trivial number of attributes that aren't currently supported (mostly as an oversight).
  We should still allow `for` (since you can have non-dom components, same with `class`, etc), but I'm not completely sure if we should be stringifying those keys or if we should add a mode. cc @jeffmo 
 Ideally this wouldn't have anything to do with jsx since jsx only promises es5 (off the top of my head I'm not sure if there are other things that would need to change to make it es3 compat) -- but it does seem reasonable that we have a transform that shims this particular es3-ism for ie8 since that's an issue that seems to pop up often
  You know people want it‚Ä¶
 I think we ship our helper utilities `mergeDeep` and `mergeDeepInto` which are non-mutative and mutative merges respectively. Merging deep usually requires that you have the caller specify how to handle arrays, as it's not usually clear. The one reason why I haven't used deep merging as much is that it can usually be accomplished by several shallow merges:

```
var newObj = mergeDeep(oldObj, {something: {deep: 'hi'}});

var newObj = merge(oldObj, {something: merge(oldObj.something, {deep:'hi'})});
```

though, I know it's much uglier.

I like deep merge, but I haven't received any feedback on the implementations I worked on in a while so it's hard to judge if it's decent. I'm sure it doesn't do the right thing in //some// edge cases somewhere.

https://github.com/jordwalke/npm-react-core/blob/master/modules/mergeDeepInto.js

Have you seen any really great implementations that allow resolving arrays arbitrarily?
 No, I suppose I assumed it would treat arrays as terminals. Underscore doesn't implement a deep `_.extend` because of hard decisions like this.
 One issue with our `mergeDeep` utility is that it requires that you specify the array resolution up front - which will apply to all arrays in the graph. You may want to resolve different array conflicts differently. It's tough to think of an API for this that makes sense - but if you do, you can use `mergeDeep/mergeDeepInto` as a starting point - it's pretty comprehensible and we have a very thorough test case for it.
 I have an add-on coming to help with this. Stay tuned!
 I believe `setState()` + https://github.com/facebook/react/blob/master/docs/docs/09.6-update.md will cover this use case. Please reopen if you disagree.
 @nuragic We're not planning to add this, sorry.
  What if we just committed to a sync API? Do we think this is likely to **realistically** change in the near term @sebmarkbage @jordwalke ? I know we've talked about async rendering but it seems pretty far off.
 woops, sorry, don't ask me what happened there.
 @petehunt I'd be fine with that. A short term async rendering would likely be of the continuation style or allow certain components to render a partial result and then update themselves. Longterm, however, we could do parallelized rendering with PJS. All could be opt-in.
 I think that data fetching is workable even in a sync world. You can just move the asynchronicity outside of React. You can even put the code for data fetching alongside your React component, just don't call render() until all the data is fetched and pass the data in as a top-level prop.

I think making this method synchronous would be better.
 @bripkens if you want to make the API synchronous that would be awesome!
 It's not available at this point, sorry :/
  Adds a new CLI tool that will shim whitespace for a JSX file written for React 0.8 (or before) so that it is roughly functionally the same with the changes to the JSX whitespace rules made in React 0.9.

There are a few minor caveats to the way this works that you should be mindful of when using it:
- Whitespace shims are added by inserting a `{' '}` where there was implicit whitespace before.
- Adding a `{' '}` to a JSX expression means a new `<span> </span>` will be rendered to compensate for that whitespace.
- Adding a `{' '`} in to a JSX expression that previously only had a single text node child will make `this.props.children` for that component switch to an array of strings rather than a single string representing the text node as it was before
 Hmm, I know I said put it anywhere. but now that I'm looking at this I think I'll take it back.

How is this supposed to get published? If it's going to be a part of react-tools (ok by me), then we should just combine the dependencies. As is, this isn't going to be a part of the react-tools package, even though it's in the `bin/` folder.

If we're going to ship is separately, let's just put the folder at the top level as `npm-jsx_whitespace_transformer` for consistency with `npm-react`
 I don't really care where it goes.

As-is, it's set up like any standard node JS package would be setup (a dir with some source files and a package.json that you can `npm install`). Other than that, I don't care where we put the dir. I really don't think it matters that much as long as its next to other tools somewhere.

It's true that it's a one-time tool, so including it with the 0.9, and removing it in the 0.10 tag might be appropriate. Or leaving it there forever. Or putting it into npm. I don't think any of these will actually affect any users in any meaningful way, so I don't care.
 Going to merge and move around a bit. I talked with @jeffmo and I think the consensus was that we would just publish this to npm on its own.
 Yap, I hadn't had a chance to update. Updating now
  I believe if you add `.done()` at the end of your promise chain then Q will re-throw the exception that it previously caught (and recorded as a promise failure). Closing as I don't believe there's anything actionable for React here.
  First because why not =). Second, it'll be good for tools like [Dash](http://kapeli.com/dash) to display the documentation in a smaller window.
 Flowtype.org is responsive. We should steal that.
 We'll revisit this when we next redesign the website.
  This seems weirdly asymmetric -- is it intended?
  @thomasboyt is this still happening for you?
  Apparently the docs aren't too clear on this: https://plus.google.com/+IanBicking/posts/D1W2yqRh3BB

We need to have a section in the docs that talks about how to integrate with third party plugins in more detail, and stress the difference between mounting and updating.
 Mention the Reconciliation page to understand when an element is removed/added vs updated: http://facebook.github.io/react/docs/reconciliation.html
 Hey @ianb -

I think that this is because the tooltip component doesn't change its behavior when the underlying DOM is manipulated. What happens if you do this instead?

``` javascript
Widget = React.createClass({
  render: function () {
    var open = null;
    if (this.props.showOpen) {
      open = <a data-toggle="tooltip" title="do it">!</a>;
    }
    return (
      <div class="widget"> ...
        {open}
      </div>
    );
  },
  componentDidMount: function () {
    this.runTooltipPlugin();
  },
  componentDidUpdate: function(prevProps) {
    // You can remove this condition if you don't care how often the
    // plugin is called
    if (prevProps.showOpen !== this.props.showOpen) {
      this.runTooltipPlugin();
    }
  },
  runTooltipPlugin: function() {
    $(this.getDOMNode()).find("*[data-toggle=tooltip]").tooltip();
  }
});
```
 Still plans on doing this anytime soon? I think we probably want to do a more complete revamp and reconsider some of our docs, maybe in the 1.0 timeframe.
  Now that our transforms are all synced, want to rebase this? I assume @jeffmo has no qualms with it.
 Can you rebase this on top of your other two commits that just landed?
  I think we could probably get away with not calling `componentWillMount()` when server rendering. Thoughts anyone? @zpao @jordwalke @sebmarkbage @spicyj ?
 One possible solution is to actually replace componentWillMount with the constructor. Since the descriptor change, the constructor and componentWillMount is called at the same time. It also clarifies why there is no componentDidUnmount.
 The idea is to replace getInitialState with a property initializer, which doesn't currently exist in ES6 but we're proposing it for ES7 (similar to TypeScript). The idea is to follow the future idiomatic way to handle initialization.

``` javascript
class Foo {
  state = { counter: 0 };
  constructor() {
    this.state.counter; // === 0
  }
}
```

If a destruction primitive like .NET's `dispose()` were ever introduced, that would correspond to a `componentDidUnmount`.

The mental model is that you just follow the normal initialization process of a class. We just add the notion of mount/unmount.

``` javascript
class Foo {
  state = { counter: 0 };
  constructor() {
    this.state.counter; // === 0
  }
  didMount() {
  }
  willUpdate() {
  }
  didUpdate() {
  }
  willUnmount() {
  }
}
```

Since there's no distinction between did and will in this model, we might be able to just shorten it to mount/unmount but that probably creates other problems such as what to do with will/didUpdate.
 We do want to support async server rendering, but I'm going to close this issue out as the original docs it asked for are done now and I think we have other issues open to track async server rendering.
  @yungsters @tomocchino ?
  What version of node and npm are you on?
 Interesting... that branch definitely exists in substack's repo. Not much for us to do at this point except switch to using envify.next (already doing that in trunk).
 Work around is to publish a new React package with an update to envify. (or modify your installed react package to use a different version).
 I guess `semver` parsing changed. It's being parsed fine now as `3001.1.0-dev-harmony-fb`. fwiw, npm 1.2.18 is ~1 year old, so I would suggest updating. I guess we could actually publish our version numbers there differently too.
 Closing this out as every instance of this that I've seen has been fixed by upgrading npm.
  Hey, have you signed the [CLA](https://developers.facebook.com/opensource/cla)? Sorry can't check right now.
 (The lifecycle methods are actually documented on the "Working with the Browser" page, but perhaps the reference page is a better place to link to.)
 @bobeagan Let's do what you suggested and point it to the right anchor on "Working with the Browser". I think that documentation is a bit more conversational and fits into the flow there better.
 Thanks!
  @bobeagan can you sign the CLA at https://developers.facebook.com/opensource/cla? Then we can merge.
  This isn't the best code I ever wrote but it's better than what's there. This rewrites `ReactDefaultPerf` to be actionable and is structured so we can integrate it into the devtools later. Still needs more testing but putting this out for initial feedback.

I did a video demo here: http://www.youtube.com/watch?v=Xc53eUYDt6I&feature=youtu.be

We could strip out the measure() calls with a build step similar to invariant() if we want to get rid of the size increase:

```
   raw     gz Compared to last run
     =      = build/JSXTransformer-previous.js
     =      = build/JSXTransformer.js
     =      = build/react-previous.min.js
     =      = build/react-test.js
 -4415  -1208 build/react-with-addons.js
  +606   +122 build/react-with-addons.min.js
-13478  -3216 build/react.js
  +606   +123 build/react.min.js
```
 it's in
  Agree that we should go with disabled="disabled" or just disabled. The former is XHTML-compatible, which may be desirable. Want to take a crack at a PR for this? :)
 I'm for the bare attributes! Although I don't think we should have configurations over this... it's a bit too granular imo. 
 @syranide Bare attributes were the standard way to do things before XHTML came along and told everyone to do `disabled="disabled"`, so it should be supported everywhere (except in XHTML documents, of course).
 I think so.
 cc @yungsters  - I vaguely remember doing this for a reason. But if bare attributes work, then cool.
 I think this is a good idea, and the only reason it hasn't already been done is probably due to oversight.

You'll have to update `DOMPropertyOperations.createMarkupForProperty` and `DOMPropertyOperations.setValueForProperty`. Also, does this make sense for all attributes in `DefaultDOMPropertyConfig` that are configured with `HAS_BOOLEAN_VALUE`?
 Yeah. If you find that there are some that should not be "valueless", may we need a `HAS_NO_VALUE` configuration.
 Closed with #1005 
  Hey @glenn-murray-bse --

Super sorry about not making this clear but I actually just landed a fix for this internally which will be synced soon. I ended up doing the diff a little differently -- I added a new type of queue to ReactReconcileTransaction that would call putListener() after the DOM flush so we wouldn't need to pass around a flag like this.

I want to highlight that this was a great PR -- it's awesome to see you jump headfirst into the event system _and_ write tests. Though we don't need this particular PR, we'd certainly love more contributions from you in the future :)

Thanks again, and my apologies,

Pete
  If you haven't already, can you sign [the CLA](https://developers.facebook.com/opensource/cla)? Thanks!
 Thanks a lot! Glad to hear React is helpful.
  Does it work again if you remove the .lock.pid file?
 It seems like there are two ways of fixing this. We can either
1. figure out why [this code](https://github.com/benjamn/commoner/blob/0a982ed645a9fd175231548f91d3f11919cbae77/lib/util.js#L102-L104) is not cleaning up the `.lock.pid` file when the process exits, or
2. remove the `.lock.pid` functionality and just hope people don't accidentally have multiple `jsx --watch` processes targeting the same output directory.

I'm pretty comfortable with option 2, honestly. Thoughts, @zpao, @spicyj, @petehunt, @syranide, @mtgred?
 I'm fine with no locking. I didn't even know that existed. Do what works!
  Your problem is that you're not rerendering with the new value. If you have React rerender with the new input value, then it'll know not to revert the value. (As it is, it will revert to the old value until it gets the new value after 50 ms. Changing 50 to a larger number like 1000 will make this much more apparent.) The following code should work:

``` js
var ExampleApplication = React.createClass({
  render: function() {
    var model = this.props.model;
    return <input onChange={this.nameChange} value={model.name} />;
  },
  nameChange: function(evt) {
    this.props.model.name = evt.target.value;
    rerender();
  }
});
var myModel = {
  name: 'Input is funky'
};
function rerender() {
  React.renderComponent(
    <ExampleApplication model={myModel} />,
    document.getElementById('container')
  );
}
setInterval(rerender, 50);
```

(The normal way to do this when making a reusable component is to pass down a callback in `props` to ask the parent component to rerender.)
 Great -- that should work too.
 @tsheaff @mikeljames The problem is that React doesn't have enough information to do something intelligent. Assuming `^` represents the cursor, suppose the input looks like

```
401^8 8888 8881 881
```

(that is, between "1" and "8" in "4018"). Then I type a "2". Momentarily, the input looks like

```
4012^8 8888 8881 881
```

but immediately, `creditcard.parse(*).formatted` returns

```
4012 8888 8888 1881
```

Where should the cursor go? Even as a human looking at this, it's unclear: it could go before or after the space:

```
4012^ 8888 8888 1881
4012 ^8888 8888 1881
```

Figuring this out programmatically seems **impossible** to me in the general case. Even if we were content to return either of those, it's hard for me to imagine an algorithm that might work reliably. Let me know if I'm missing something.

Because this is impossible and requires more knowledge about the specific problem space, React doesn't attempt to do anything intelligent with the cursor; you can set .selectionStart/.selectionEnd manually as appropriate for your domain. In the case of filtering out some characters it would be possible to write a more general solution but I think that may still be better left to a third-party component.
 Actually: Stripe's [jQuery.payment library](https://github.com/stripe/jquery.payment) preserves cursor position except if your cursor is already at the end, in which case it keeps your cursor at the end of the input. This generally feels pretty reasonable; try:

http://stripe.github.io/jquery.payment/example/

That example flickers but that's not inherent to the strategy so we could do better. This might be more predictable in the common case, at the expense of introducing edge-case bugs because you now don't need to think about what _should_ happen. For example, this strategy does feel broken in the case that you're typing before a space. If you have:

```
4018^ 8888 8881 881
```

and type a 7 you have

```
40187^ 8888 8881 881
```

which gets changed to

```
4018 ^7888 8888 1881
```

which feels wrong because your cursor should be after the 7, not before. But maybe this behavior is still better.

cc @zpao for a second opinion.
 That is: I'm entertaining the idea of React's `<input>` doing this by default.
 Wait: this wouldn't work at all for filtering out chars because your cursor would move over whenever you type an invalid character. Maintaining the distance from the end might work though?
 Here you can try it:

http://jsbin.com/dunutajuqo/edit?js,output

The numbers input works great. For the CC input: If you type "1234 5678" and then try to type a character after the space, your cursor is in the wrong place. Similarly, typing "1234 567" and then typing a character _before_ the space does the wrong thing.
 @tsheaff That's a good opportunity for a third-party plugin but we won't put it in the core. Maybe a "React mask component". :)
 @tsheaff If you ask me, having an `input` that also accepts a `selection` (and reports it on change), but browsers being the way they are and events in React being reported as-is, this seems kind of fragile and quirky for core behavior... and the same thing can be implemented as a third-party component, so that seems preferable at least given the circumstances.
 My last example posted on Nov 30 keeps the cursor in the same place if you reject a change, at least.
 @Guria Thanks for pointing that out.
  @glenn-murray-bse thanks! would love to find a way to automate the workflow you're using and put it on CI.
 Cool I'll take a look. I'm experimenting with automated tooling around this kind of stuff (https://github.com/facebook/react/pull/620) so if anyone comes up with any ideas be sure to let me know :)
  Depends on facebook/react-devtools#23 to be useful.
 We're going to do this a different way.
 Logging is actually really helpful for "just in time" advertising - people open the devtools to debug something and see the message. It should go away if installed but it's not too terribly annoying right now so it hasn't been a priority.
 For those not following along in master, this should be fixed now. Latest devtools + React v0.12 will be quiet if you already have the tools installed.
  Nice catch. Could you sign the CLA? https://developers.facebook.com/opensource/cla
 Thanks!
  @azich drew a lifecycle diagram before.
 "merging" into #2184 
  :exclamation: :exclamation: DO NOT MERGE :exclamation: :exclamation:

Still a little time before we ship 0.9, but I wanted to get this change lined up.

For the most part this is nothing to worry about, but I'd like to give people a chance to make sure they have the right name/email address in there.

@jhiswin, @Cartas - you don't have names on your commits except for you github usernames, would you like real names?

@mcsheffrey - you have multiple email addresses, so I changed the one we use. Is that the preferred one?

@rtfeldman - multiple emails for you too, I picked the one that seemed better, but let me know if you'd like that changed.
 Thanks all, updated with the changes requested.

@jhiswin nope, no need to sign a new CLA. It's not necessary to use real info, I just like to give credit where due, and an AUTHORS file typically has real names. Though @vjeux prefers to go by "Vjeux" so that's what we use. If you'd prefer a different name or email address, or to be excluded, just let me know.
 The date on the commit is whack because rebasing, but 32e1d76612a3a55fecb12a85f656e6922015063d
  Where does the `done` function come from? Presumably it's passed to the `nextUpdate(component, function(done) {...` callback function?
  One of the things holding us back right now is that we don't have a stable public API. I'd really like to cut Instagram over to the npm version of React but unfortunately it doesn't include some of the addons that we need because of this issue. I'd like to propose the following changes:
## Consistent, iterable `this.props.children`

`this.props.children` gets wrapped in a new `ReactChildIterator` object -- basically a thin wrapper around `ReactChildren.map()`. This means that people can actually introspect `this.props.children` without assuming it's an array or a nested object or something.

I don't think memory utilization is a big problem today so I think this change would be OK, especially if it is implemented lazily. I know that @dnolen wants something like this too if he can plug in his own lazy child data structure.

I do think it's important we solve this. Another option I was thinking of was putting `mapChildren()` on `ReactCompositeComponent` -- but that begs the question of adding `onlyChild()` as well and I think the API would become confusing.
## `cloneWithProps()` on `ReactComponent`

I think this function is very helpful and hard to use externally right now. Adding it to the public API of `ReactComponent` makes sense to me. Does anyone think that there is potential for overuse here?
## Public `injection` APIs

I think we should centralize all injection points for React in a `ReactInjection` module and make it public as `React.injection`. There's no reason why you should need to check out the repo to configure a custom React.
## Rename `lib/` to `internal/` in the `react` npm module

For many addons we'll need to do stuff like `require('react/lib/ReactUpdates')` for the foreseeable future. Let's just embrace it for now and rename `lib/` to `internal_do_not_use_or_you_will_be_fired/` so non-core projects don't depend on this.
## Put each add-on into its own npm module

Everything in https://github.com/facebook/react/pull/745/files
## Add new `react-svg` npm package

This will export the `DOMPropertyConfig` which can be injected with the new public `ReactInjection` APIs.
## Use `wzrd.in` for package builds

We can put our own cache in front of it so we are good citizens. This way people can build their own `react-whatever.min.js` without us having to provide a million builds or a config tool.
 @brainkim - `cx`/`classSet` doesn't need React at all. I could see us putting that into a standalone npm/bower/whatever module with no real association with React.
 @brainkim `wzrd.in` won't package them unless they are `require()`d somewhere. So we'd either be unable to get the addons or force all users to include all of the addons, which sucks too.
 You say that, but npm is all for shipping your 10 line function as a module.
 I‚Äôm not sure a lot of this is still actionable now, and if it is, it‚Äôs best if we re-raise the relevant parts as separate issues.

For the reference, here‚Äôs what we have right now:

> Consistent, iterable this.props.children

`React.Children` should cover that.

> cloneWithProps() on ReactComponent

`React.cloneElement()` should be good.

> Put each add-on into its own npm module

Technically done, and we‚Äôll be separating some of them out of the main repo after 15.

> Public injection APIs
> Rename lib/ to internal/ in the react npm module
> Use wzrd.in for package builds

Maybe we‚Äôll come back to these but not a priority right now.

> Add new react-svg npm package

Something we‚Äôve been considering but we decided to delay this as well.
  We use phantomjs for the React unit tests and polyfill .bind here:

https://github.com/facebook/react/blob/0.13-stable/src/test/phantomjs-shims.js

Closing this out; let me know if anything else is unclear.
  Wow, you and jsx need to get a room. :)

The way I think about it, JSX is essentially named arguments and give us a static way to reason about those arguments. However, I also see JSX as an object initializer as much as a function call.

It could desugar into descriptions of the call rather than the execution.

```
{ type: MyComp, props: { foo: exp, children: [child] }, context: this }
```

None of this is really incompatible with your idea. Just providing context of different ways we think about it.

Out of curiosity. What kind of patterns are you using that make this syntax common?

A common one is building up props externally and then pass it to the component. Although it's more common to mutate props on the statements following instantiation. Another is passing props from one component into another unchanged `MyComp(this.props)` or merging `MyComp(merge(this.props, { more: 'stuff' }))`. Each one has their own issues.
 ```
>    <MyComp {{name: object.name, size: 5}}></MyComp>
>    <MyComp {merge(moreFields, {name: object.name, size: 5})}></MyComp>
```

@syranide I believe that was even part of the E4X spec that JSX was modeled after.
 @jordwalke sure? I don't think so.

I like this proposal because it discourages mutation after initialization as a way to build up props. That should ideally be disallowed so that prop warnings can be issued earlier.

The only downside is that it prevents us from moving towards a named arguments or exploded arguments model instead of passing a props object.
 Going to close this for this proposal: https://github.com/reactjs/react-future/blob/master/01%20-%20Core/08%20-%20Transferring%20Props.js#L30

The reason for this is that we're currently cloning props objects so you're not actually passing those instances anyway. This syntax clarifies that this gets merged in. It allows for sugar for merging in additional properties.

This also preserves the option of using a single object for descriptors (merging descriptor and props object). It also allow us to switch the semantics to be an object initialization rather than an arbitrary function call.

It's not quite on parity with plain function calls and if you're using it outside React that might be interesting. But this allow us to change the implementation of JSX if we need to.

This new syntax allows these to be used for spreading named arguments if that every became a thing.
  @ehd @zpao @sebmarkbage what if we added a **DEV** and browser-only global always? We could mangle it so it's unlikely to conflict with another variable in the global scope. We could also use this to detect multiple versions of React running on the same page...
 We could also make it non-enumerable since this is browser specific. How bad would it be to make it always on in prod too? If you have a conflict it would be there in DEV too.
 I wonder if some people don't want their stuff inspectable in prod.
 The dev tools doesn't give you the ability to do anything you can't do (clumsily) by hand already.
 @ehd Don't worry. It won't impact performance unless you have the inspector with the React tab open.

I could see this being a problem if you have some environment that validates that you're only running in your sandbox. Such as Caja.

To create a new global, we'd either have to assume that window is the global or create a non-strict function that returns "this". The former is probably the safest bet.
 Closing in favor of facebook/react-devtools#28.
  This seems to improve performance on the spinning balls test by around 5% on Chrome. jsperf says this is faster on both Firefox and Chrome desktop: http://jsperf.com/hasownproperty-vs-in-vs-undefined2

I think that this is the direction we want to go in the future because we may want to actually look on the prototype for keys, depending on how we want to implement immutable objects
 Shouldn't this be testing `y in x` instead, to account for the case where `x` is something like `{ y: undefined }`?
 Oh, I see, in most of these cases checking `y in x` would be pointless because the code is iterating over keys that are guaranteed to be in the object.

I have to say I don't agree that a 5% performance improvement in a micro-benchmark is worth a change in semantics that is arguably less correct. And I suspect you'll see a loss of performance if you actually start checking for keys that aren't defined on the base object, as @plievone pointed out.
 So what I would actually support is removing the `hasOwnProperty` check entirely, and relying on `for`-`in` to visit all the keys, inherited or otherwise. There's no need to check something that is already guaranteed by the loop semantics.
 @benjamn We don't care about people adding things to Object.prototype?
 @spicyj well, @petehunt's patch exposes us to that risk, so we should just keep `hasOwnProperty` if we're concerned about that
 low leverage
  Wow thanks!

We hold off on adding all of them in the past because it's a lot of bytes. Do you mind telling us what's the gzipped size of react.min.js before and after your change?
 @syranide - I like the idea of injection. We need to make the transform step injectible though too to make this really viable. `jsx --with-svg src dest` or something like that. I don't know that it'll happen right now though...

I guess we should probably do this as-is for the time being, even though I'm not wild about the noise. So a couple things I'd like to see:
- tests for the nsAttr setting
- see if we can get the post-gzip size down (a 10% increase isn't trivial)
- some indication that these changes are compatible with closure compiler advanced
 In addition to everything I mentioned above, I would like you to actually build and use this. It's apparent that you haven't.

```
TypeError: DOMProperty.mustUseNamespacedAttribute is undefined
TypeError: DOMProperty.getAttributeNamespace is undefined
```
 #1009 isn't going to add anything, just reorganize some code.
 Won't really make it easier, just slightly more clear where they go.
 Ping, what's the status here?
 Going to close this out as it's broken in its current form. Happy to look at new PRs, though we'll need a good answer to what to do with namespaced attributes.
  Mostly seems sane to me. I'm going to defer to @sebmarkbage for the `ConvenienceConstructor` related things as he's spent a lot of time there and may have some reason for wanting to keep the `in` check (may be relevant looking at ES6 classes)
 What are we basing these benchmarks on? It doesn't make sense that `in` would be slower. Seems like a VM bug.

Likewise, typeof x === 'undefined' should be easily optimizable where as x === undefined needs to make sure that undefined has not changed in the scope. We still need typeof checks for variables that may not be on the global scope, for feature detection. So we would end up being inconsistent anyway.
 As I understand it, modern browsers ignore assignments to undefined.
 Only on the global scope. You can still introduce it in any intermediate scope. Even lazily if there's a non-strict eval. I'm not worried about it being clobbered but by the possibility of being clobbered.

Microbenchmarks aren't really reliable. By messing with the VM a bit I can make the opposite true. http://jsperf.com/invsundefined22/2
 I'd accept it for style reasons if we prefer it but I don't think the perf argument is valid here. It's way too flaky and nothing inherently faster about it.
 Benchmark that test our code paths are still valid since that tests actual usage. If that's significantly faster, that's good basis for this decision.

I was just pointing out that it's not necessarily faster. Even if you remove the eval, the perf difference is much smaller. It's not really giving us any major boosts overall and it might even change with other optimizations in the VM.

You mentioned that you find `in` more descriptive and I would think that should weigh higher than the perf win since it's not clear that it's a major win. It's your call though. I'm fine with either one. We'll do whatever you feel is right.
 1. How do we handle typeof window !== 'undefined', typeof Int8Array !== 'undefined' or typeof require !== 'undefined'? These would throw if you turn them into === undefined.
2. That's fine. The exception is == null which is very convenient to test both undefined and null. Those are pretty much the same.
3. I think that's probably fine for most cases. Even a truthiness check could be fine if you expect an object or a function.
 For the record: Dead code elimination appears to account for the majority of your margins in your original jsperf for `in`

http://jsperf.com/invsundefined22/3

I didn't look into what's causing the rest of the margin -- but VM's are pretty smart. DCE is one of the most common mistakes made in micro-opts, but there are many many others too (I won't claim to remember them all off the top of my head -- point being they're hard to get right)
  http://facebook.github.io/react/tips/maximum-number-of-jsx-root-nodes.html
 Fixed by e60a893d2fe9df1181ca76f98b7e93225d2a69d2.
  Cool, would love to see benchmarks.
 "I did a torture test of it". Can you also put that code somewhere? It would be really useful to track it over time and for the next time we want to modify the ids
 kk, pulling this in
 Sweet. If concatenation and string allocation is a major perf impact. How about we get rid of them completely?

We could stop creating global IDs using massive strings and use incremental numbers (UID) instead. Or find a cool DOM traversal algorithm that doesn't require IDs. There's a proposal for a live reconciler that doesn't need a flat list of children. The event bubbling could be much faster if we stored a parent reference on the virtual nodes (components) instead of walking the ID structure.

Dare to dream big, guys. :)
 We'll just update the devtools to fix it if that's the case.

Currently server-rendering starts with a shared rootID and multiple roots can be rendered individually and sharded. The UID could be on a per rootID basis. E.g. the first component in the root is 0, the first child 1 and so on. That way the initial count will always generate idempotent results. If the hash fails, it just remounts anyway.

I don't think we have a solution for hit testing and event tracking without IDs. We can get rid of IDs for getDOMNode and event bubbling. But identifying the first target of an event is difficult without IDs. Any ideas?
 I don't think monotonic IDs will break server rendering as long as separate counters are maintained per root. Since the apps initialize identically on server and client they will map the same IDs.
 I was thinking about 2 recently. If building the IDs is really a significant cost then I think it should help significantly.
 subjective :+1: to option 1 over option 2
 @syranide For option 2, what's your solution for operations that currently go from node reference to instance reference? E.g. event propagation and the second argument to renderComponent.

For option 1, I care about allowing the ability to generate these nodes in parallel. At the very least, different roots should be able to spread to different web servers for server-side rendering.

Ideally I'd like to be able to spread the whole tree reconciliation using parallelization but could probably live with just the root requirement since there are other concerns for parallelization.
  Like `<LeftRight left=<a /> right=<b /> />`. facebook/esprima#9 makes this possible.

This should be merged with an esprima-fb version bump. However, facebook/esprima@8ca1599a1b3599fb3666f1094d9a0c226cf5ef5b necessitates a change to this transform to look at `object.openingElement` in most cases so I'll wait for an updated version to be synced out before this can be merged.
 I'm going to say no to this.

For others who find this, the idea was to allow shorthand for passing in components. `<LeftRight left=<A /> right=<B /> />`
  We happen to "support" hyphenated keys to the style object on initial render (because we attempt to hyphenate camelcased keys) but those styles will never be updated on subsequent renders because we never attempt to unhyphenate.

So we should warn when we see a hyphenated style.
 Some browsers support assigning with hyphenated keys, but probably not all do.
 AFAIK only Webkit does. (And I guess by association, Blink)
 @gaearon Perhaps another one for you!
 No problem, whenever you have time.
 Yes, this matches our existing practice of requiring camel-cased attributes in general, which makes it easier to make warpper components that modify props in some way because you only need to look in one place to find the original value. In addition, you don't need to worry about what happens if someone were to specify both `marginLeft` and `margin-left` in the same style block. (One last advantage: if the warnings happen only in the dev version, then there's no runtime cost in the production build.)
  Fixed by 4764585.
  This might render the compiler and the js front page example obsolete.
Will open another PR.
 71b585325ce7abc149fe848bb3fe119488ad8c3e
 Probably also want to change the homepage to not say that the second example uses JSX?
  Just rediscovering this and I'm going to say maybe... and hopefully come back to this again in less than 3 months.
 It's less than 3 months! I'm going to say no, but I wouldn't be opposed to use splitting the new HTMLDOMPropertyConfig and having a deprecated file that we also inject but can keep them separate so it's easy to do.
  Thanks for opening an issue, this is very useful to get confusing error messages with examples. cc @jeffmo 
 @slorber If you paste your code into http://facebook.github.io/react/jsx-compiler.html, do you still get that error? I seem to get 'Unexpected token app' which is better though obviously not great.
 Okay. I'm getting the unexpected token message using the jsx binary on my machine too and I changed the error in esprima to say "Unexpected string", so I'll close this out.
  Should those comment sections exist? I'd rather people come to IRC. Their questions are often neglected at the bottom of a doc page.
 +1
  I'm curious, why do you want them?
 "align" is deprecated and React's policy is not to support deprecated attributes. Not sure about bgColor though
 I've actually made a pretty concerted effort to not support things that were marked deprecated in HTML4 (that means it was deprecated ~15 years ago). This is why React doesn't support the `<font>` or `<center>` tags. For this reason I feel pretty strongly that we should be encouraging best practices in React and _not_ support things like `bgColor` (next we'll need to support `background`).

Honestly, I wouldn't mind getting rid of other obsoleted things as well (including `cellSpacing` and `cellPadding`).

You'll notice from its use that this is a "default" property config. While there is a barrier to shipping your own configs, this has been our plan for a while. At that point, perhaps there's an HTML4 config that somebody could build.

_But_, I'm open to discussion.

(And per the point about working with ancient Dreamweaver output... if you're switching to using React, it sounds like the perfect time to update from these no longer supported attributes. Perhaps the html->jsx tool could catch these and convert to inline styles.)
 I'm just going to go ahead and wontfix this now. Sorry for leaving you hanging for so long.
  This changes it so that PropTypes logs to the console via `console.warn` instead of throwing through an invariant. This means that PropType-validation can be stripped out in production to potentially speed up React apps. Since the code only logs to the console from now on, the logic that is followed is the same in prod and dev and actual errors will come up the same way.

Currently this is gated by **DEV** but we might want to add another magical constant.

90 % of the time making this was to fix all the unit tests to expect `console.warn` calls instead of expecting the functions to throw.
 I really like this change!

cc @yungsters @jordwalke @petehunt @sebmarkbage 
 Just realized ReactErrorUtils is not a good place for this, how about an 'error' module that lives next to invariant?
 This should use console.warn and probably be called something like warn. I spent a day once trying to figure out why an error wasn't interrupting code flow because it looks like it's thrown.

A rename to a short stand-alone name would be good. It's really nice to be able to statically analyze these.
 I had this as 'warn' before but decided error is better. Warnings in the console don't really cry for much attention and if something goes wrong with your PropTypes I think it is better to tell you about it in RED.
 Changed to an `error` module.
 Since the console methods already support string formatting, why do we have to re-implement it?
 @yungsters we wan't to be able to analyze this module and maybe strip it out in prod.

`if (condition) console.warn(‚Ä¶);` is harder to analyze than `warning(condition, ‚Ä¶)`
 discussed with @sebmarkbage in person, we decided to call this module `warning`.
 @cpojer we don't need to do the string parsing since console.warn supports %s in the same way.

console.warn(format, ...args);
 Hah, I never knew about this.
 Even in old IE?
 shim it :)

It's cool because it uses toString so we get custom formatting. But the inspector could turn that part of the string into a link to an object that can be inspected.
 yessssss
 Wait, what? Why was this merged?
 @sebmarkbage, @jeffmo and I only came up with softInvariant which we didn't like. I really like weakInvariant! @sebmarkbage what do you say?
 Please don't call something an invariant if you're not treating it as such.

> [...] an invariant is a condition that can be relied upon to be true during execution of a program, or during some portion of it. It is a logical assertion that is held to always be true during a certain phase of execution. ‚Äì [Wikipedia](http://en.wikipedia.org/wiki/Invariant_%28computer_science%29)
  @anru Can you elaborate on what you mean?
 Yeah, dupe of #353.
  Awesome. Could we get the same thing in JSXTransformer?

cc @benjamn
 Do you mind rebasing? Sorry for the delay on this.
 Cool, this looks great. Thanks a lot!
  I think it would be great to expand on the docs here. It might even make sense to make a whole page detailing browser support.
  I actually think we stopped supporting rendering into the document recently. cc @petehunt 
 Indeed we did, unless the original markup was generated by React (and has an unchanged `<head>`). See https://groups.google.com/d/msg/reactjs/4jI5xe7TXzQ/3sjSBbpDpEwJ.
 As long as
1. you're passing the exact same props on server and client
2. your render methods read only from this.props and this.state (for example, it shouldn't include the current time)
3. getInitialState reads only from this.props (if anything)

then the checksums should always match. If you find a case where this isn't true, please file an issue.
 Closing due to lack of activity; let me know if I can help more. @lrowe's post on the mailing list here may also be helpful:

https://groups.google.com/forum/#!topic/reactjs/acnCodaJUHI
  Ember has a similar Ember.run -- perhaps we should do something to mirror it? They also have helpers like Ember.run.later which is a replacement for setTimeout with better batching: 

http://emberjs.com/api/classes/Ember.run.html
 When is this going to be released?
  In that case it should also be best practice for higher level components to do the same. .getValue() has some benefit since it's purely reflective.

.setValue() and .focus() is much more problematic since now state is controlled by multiple callers which can diverge. The controlled funnel is one of the major benefits of React. We should opt for a simpler syntax to do controlled inputs.
 Having a canonical method for reading an input's value that doesn't touch the DOM directly would also be convenient for shimming events like `onBeforeInput` where we might want people to see a different `value` than what's currently in the DOM.
 I think we ended up going in a different direction here, right?  We no longer have wrappers (we just return the DOM nodes), and I don't think we want to expando DOM nodes.
 Yeah.
  Someone was confused, might as well fix the tutorial to be more precise:

http://stackoverflow.com/questions/21130374/jsx-watch-converts-jsx-syntax-to-lowercase-react-instead-of-uppercase-react#comment31817165_21130830
 We had this crazy idea where the snippets would be autogenerated. But then more important things needed to happen. While I don't think we need to do that here, it would be helpful to do a pass through the tutorial. We'll need to do it again anytime the transformer changes (the code there now is from an earlier version of the transformer, thus `{}` instead of `null`)
  What's the use case?

We could indeed make ChangeEventPlugin also fire onInput but I'm not sure I see the utility.
 @petehunt - any objections?
 I don't really care about this but if there's still interest in pushing this through, fine. Anybody else care?
 I don't feel very strongly about this, I imagine _the place_ to put the logic would be in `componentWillMount` (perhaps?), however, you're not allowed to call `setState` from there. So you need to wrap the `ReactLink` with another `ReactLink` that has your generic `change`-handler (which is not necessarily wrong!).

However, pondering the issue some more, I imagine that while my intention with this PR is good, it's actually stepping in the wrong direction. `value` and `onChange` is what ReactLink replaces, I would not expect other components that implement ReactLink to call both the ReactLink change-handler and the regular change-handler, it's one or the other.

I guess what complicates the matter is that `onChange` is perhaps intuitively seen as an HTML-event and it's not immediately obvious that ReactLink replaces that, rather than some other synthetic event (you still expect `onKeyDown` to work despite using ReactLink).

So unless you have an explicit opinion on that it's probably better to leave it as-is.
  I feel guilty. 
  This isn't strictly a React issue but it would be nice to add JSX support to jsbin. Here's the small amount of code they have for coffeescript support:

https://github.com/remy/jsbin/blob/master/public/js/processors/processor.js#L122-L141

Shouldn't be too hard to make a PR to them with the same for JSX.
 :+1: 
 Oh nice, I didn't know they had a way to plugin new languages. When I tried, jsfiddle was the only one where I could hack into it and make JSX work-ish.
 This happened.
  It looks like we're doing some current position moving incorrectly. @jeffmo, @syranide - do you know if this is something that's getting fixed with the whitespace PR or is this a separate problem?

```
<Component something="       a bug        " />
```

becomes

```
Component( {something:       " a bug "        } )
```
 Play around with different amount of whitespace padding, as well as a whitespace only string. Looks like there are a few edge cases to handle here.
 I feel that for attributes we should maintain the original spacing exactly. Line breaks are a small pain but otherwise there's no issue.
 Sorry, I just meant that the text within the quotes should stay the same.

But I agree that it would be nice if this happened:

```
<Child.value="5"./>
Child({value:."5"})
```

Because that's surely the most common way of writing the JSX and corresponding JS by hand.
 This is mostly fixed, though there seems to be some extraneous whitespace in the surrounding JS:

```
<Component something="       a bug        " />
Component( {something:       "       a bug        "        } )
```

@syranide do you know if #970 fixes this?
 This is now fixed.
  This is an alternative, less-invasive, fix for #891.

Test Plan:
On http://jsbin.com/OqOJidIQ/2/edit, got timings like

[75, 56, 30, 36, 27, 27, 28, 32, 27, 27, 28, 31]

instead of the old

[75, 729, 46, 32, 28, 34, 26, 27, 27, 30, 26, 26].

I also added a counter to getID and saw it was called 3014 times instead of
the old 636264. (3014 is the number of nodes (3000) plus 3 calls that happen
for the initial render and 1 for each of the 11 renders after that.)
 :+1: :+1: :+1: :+1: :+1: :+1:
 @syranide which presentation was this?
 Cool. @steveluscher can you see if this commit helps your demo at all?
 This has also been noticed in this blog post: http://davidandsuzi.com/ngreact-react-components-in-angular/
 @steveluscher Really glad to hear it.
  This is on the horizon and there are some things I want to make sure don't get forgotten.
- [x] Updated esprima/jstransform with https://github.com/facebook/esprima/pull/8
 We did this.
  I think this should be safe, cross browser at this point, but we should make sure. We shouldn't ever be running this code path server side, so I don't think we have to worry about that

``` js
// this
aNode.nodeType === Node.ELEMENT_NODE;

// instead of
var ELEMENT_NODE_TYPE = 1;
aNode.nodeType === ELEMENT_NODE_TYPE;
```
 Not sure I really see the motivation. Our current solution compresses better. :)
 fiiiiiiiiine
  Do you know if things have changed in es5-shim recently? Last I checked `Object.create` was the only thing needed that was in es5-sham, and we actually call that out separately immediately below.
 Thanks a lot for doing this. Here's a suggestion.

> Generic sentence saying to use both shim and sham
> 
> shim provides the following that React needs:
> - ...
> 
> sham provides the following that React needs:
> - ...
 I'm not attached to what we have there now since it's obviously a problem (hope I didn't come off that way). What @vjeux proposed sounds great. Let's follow the same pattern for the `console` polyfill.

Could you also sign [the CLA](https://developers.facebook.com/opensource/cla)? Then we can merge away when it's ready.
 Awesome thanks, it'll be live next time we push an update of the website :)
  More and more we've seen issues with the logging messages, so in addition to changing the message (#769 or however that ends up being revived), I think we might want to make it clear that we don't simply have a minified version of a build, but we actually have improved debugging.

Not sure if doing this would mean we should have a new React.js which an unminified prod build.

Thoughts?
 I wouldn't know to use a `.debug.js` version. Ember names the prod one `.prod.js` which might be a little more obvious. I added https://github.com/facebook/react/commit/c877451887d1fc531e7c2637681f47cf50d6a5de to the download page but it looks like it never got cherry-picked to the stable branch.
 Bah, I'll push out a docs update in a little bit. I think there are a couple other things that need to go out too.
 The diff that renames "Invariant Violation" to "Minified exception occured, use the non-minified dev environment for the full error message and additional helpful warnings." has landed internally FYI
 Since the change in invariant error message and some tweaks I did to the website I haven't heard much confusion around this so I'm going to close this out.
  Regardless of what W3 specifies, does this work in IE8?
 Can you rebase?
  This generally makes sense to me, though some people have complained when doing unit testing that React relies on `document` being available at require time.
  I was wondering about exactly this just the other day.
  Right now it's accepted to return `null` from `getInitialState`, but if a mixin also defines a `getInitialState`, and if one of the two returns `null` then the merge throws an error when trying to merge an object with `null`. What should be the correct behavior here?

@cpojer 
  There are a few things that we've fixed which should be safe to put into a 0.8.1, mostly related to `ReactTransitionGroup`.

I wish there were a better tool for this, but here are all the commits to consider (I think):
https://github.com/facebook/react/compare/39037ee...7a9e544 and https://github.com/facebook/react/compare/7a9e544...master

Let's collect commits/PRs we want to take
 Here's a spreadsheet:

https://docs.google.com/spreadsheet/ccc?key=0AiiHBePwQn13dHBYSVBVT0VlNFhqN3JUOHFxdlBpMEE
 Doesn't sound like we're doing this, so closing.
  Nothing jumps out as terrible on a quick read, so I'm going to let @petehunt take on the real review.

Can you also sign [the CLA](https://developers.facebook.com/opensource/cla)? We'll need that before we can merge.
 Thanks for fixing this. We definitely needed it. Everything else looks great!
 `value` is the form value sent to the server when checked so we can't overwrite it.
 The tests pass on a fresh clone for me, though in my usual directory I get:

```
>> not ok 258 - core/__tests__/ReactRenderDocument-test rendering React components at document should be able to get root component id for document node.
# Expected 'Hello world ' to be ' Hello world '.
>> not ok 259 - core/__tests__/ReactRenderDocument-test rendering React components at document should not be able to unmount component from document node.
# Expected 'Hello world ' to be ' Hello world '.
# Expected 'Hello world ' to be ' Hello world '.
>> not ok 260 - core/__tests__/ReactRenderDocument-test rendering React components at document should not be able to switch root constructors.
# Expected 'Hello world ' to be ' Hello world '.
# Expected 'Hello world ' to be ' Hello world '.
```

and I haven't taken the time to figure out why.
 Can you rebase this? Then we'll merge it in!
 OK pulling this in
  cc @sebmarkbage @yungsters 
 Apparently my cc'ing people didn't work...

@syranide I think this seems reasonable... apart from the double detaching, what does this do for us? Is it faster?

Also, can you add a test case that would have thrown before?
 do it live.

cc @petehunt for collection of royalties on said phrase.
 Can you rebase?
   Do you know why github diff is completely broken?
 Line endings change maybe?
 Nice, I like this diff
 @syranide Can you rebase this and also add `tagName` to createFullPageComponent? It'll fix #1185.
 Looks like this won't work if you rebase to a commit after descriptors. We can either do like `tagName: button.type.prototype.tagName` to copy the tag name over or we can add in ReactDOM.js:

``` diff
diff --git a/src/browser/ReactDOM.js b/src/browser/ReactDOM.js
index 5cd3b35..2d6d9b7 100644
--- a/src/browser/ReactDOM.js
+++ b/src/browser/ReactDOM.js
@@ -47,6 +47,7 @@ function createDOMComponentClass(omitClose, tag) {
   Constructor.prototype = new ReactDOMComponent(tag, omitClose);
   Constructor.prototype.constructor = Constructor;
   Constructor.displayName = tag;
+  Constructor.tagName = tag;

   var ConvenienceConstructor = ReactDescriptor.createFactory(Constructor);
```

and then do `button.type.tagName`. 

@sebmarkbage Do you have a preference between these?
 This will mess with the debugger that lists these twice. This seems wrong since these are not real DOM nodes it can mess with all kind of feature detection.

The internal tests that used this are fixed by now. It uses a `descriptor.type === React.DOM.img.type` which is the preferred dynamic type testing strategy. tagName should be considered internal and renamed to _tagName.

Let's just make ReactTestUtils.Simulate.x more permissive and let it be called on anything that can resolve getDOMNode.
 Let's do what @sebmarkbage said. I filed 1445.
  I don't see how this makes the `onError` situation any better.

It would be nice to be able to transfer a className onto a DOM component going through a few layers of composite components -- ReactTransitionableChild would certainly use it.
 See https://github.com/reactjs/react-future/blob/master/01%20-%20Core/08%20-%20Transferring%20Props.js for the current proposal here.
 I'm going to close this out for the react-future proposal mentioned above. Let's open up issues on react-future if you don't think the current proposal is a viable replacement.
  @vjeux said it needs to be there for some internal FB tests. I'd think those should be changed too; otherwise we should add tagName to all the wrappers for consistency.
 ReactTestUtils are assuming that tagName is defined on all the DOM properties.

https://github.com/facebook/react/blob/1b67ac90f2bdca189a61a3e873af157198cdf7a5/src/test/ReactTestUtils.js#L58
https://github.com/facebook/react/blob/1b67ac90f2bdca189a61a3e873af157198cdf7a5/src/test/ReactTestUtils.js#L144
https://github.com/facebook/react/blob/1b67ac90f2bdca189a61a3e873af157198cdf7a5/src/test/ReactTestUtils.js#L157

I feel like we should add tagName to all the DOM tags instead of removing them
 Well, isDOMComponent should probably be false if it's a composite component.
 We use those test util methods in a handful of places internally and they rely on the fact that tagName is defined. I don't see any downside of defining tagName for React.DOM components.
 @spicyj ^^
 I mean, they behave essentially like the composite component wrappers that they are, so that sounds sketchy to me. I can look a little more in depth later.
  Thanks, looks like this is a bug. It should be `callback.call(component);` like it is earlier in that file:

https://github.com/facebook/react/blob/master/src/core/ReactUpdates.js#L67
 Fixed in #876.
  Cool! Have you signed out CLA yet? It's in the contributing.md file in the repo. Comment here when you have (or that you have already!) and we can merge this. Thank you!
  This would be really great to have! Can you add some tests?
 You could have the `<iframe>` load a page that increments a `data-reload-count` attribute of `window.frameElement` every time the frame reloads, then assert stuff about that attribute.
 Yeah, `renderIntoDocument` was changed to not attach things to the document any more to make cleanup easier.
 I don't think so, just remove it when you're done. See ce95c3d042309d8aced894cc6be43d7e4cf96455.
 There are more immovables. The currently focused text field, the current mouse target (avoids an issue with `mousedown`+`mouseup` not triggering `click` if it's moved).

This is generally good but I'm not sure about the strategy around hasImmovableDescendants. I think we can do better. E.g. record keeping inside of React (not including dangerousInnerHTML).
 > This is generally good but I'm not sure about the strategy around hasImmovableDescendants. I think we can do better. E.g. record keeping inside of React (not including dangerousInnerHTML).

We can, but it was rather non-trivial as it only applies to ReactDOMComponent (and also adds a potentially depth-linear cost for each tree mutation)... the biggest reason why I chose to go with `getElementsByTag` is because it also extends the courtesy to non-React markup. Is that preferable? Perhaps not if we want "focused field"/etc to piggyback on the same "feature".

But I agree it does feel a bit dirty to use `getElementsByTag`, but then again it's also a fix for HTML-weirdness and not intrinsically useful to React. If you feel keeping a record is better then I'm game.
 > There are more immovables. The currently focused text field, the current mouse target (avoids an issue with mousedown+mouseup not triggering click if it's moved).

That's also rather tricky, which is more important if immovables cross paths? I would say:

iframe/video/audio/etc > focused text field <> current mouse target

Which means we should probably still have a decent fix for the last two.
 There hasn't been much interest in it and it makes the core more complicated. Do you need it?
 Thank you for your work on this.

Technically it‚Äôs a problem we don‚Äôt have a good solution for, but it significantly complicates the logic for what seems to be a relatively low-priority use case.

This is why I‚Äôm closing this pull request and adding a new ‚ÄúResolution: Unsolved‚Äù label. We can revisit it later if there is enough interest in seeing this implemented and later supporting that implementation.
  @radebrecht Can you test whether changing the `href` (without unmounting the component) works properly? My guess is it won't.
 Going to close this out due to lack of activity, but let me know if you get a chance to test the changing `href`.
  ~~‚Üê will hook that fb.me url up~~ done!
 Awesome. Thanks a lot!
  The title is epic :)
 i'm the best
  I agree that line-height should be counted as unitless (as it is now). Most of the time you don't want `px`.
 Thanks a lot @andrewdavey!

We do copy jQuery semantics here... here's their block: https://github.com/jquery/jquery/blob/master/src/css.js#L221-L233

We'll have a few more than them after this PR (though maybe we should add `columnCount` and perhaps not add `pitchRange`, is that even supported by browsers)
 (richness, stress, volume too -- all properties described here: http://www.w3.org/TR/CSS2/aural.html.)
 thanks!
 `lineHeight` supports unit-less values so you need to provide `px` yourself.
 @appsforartists `<Comp fontSize="13" />` vs `<Comp fontSize={13} />` though. Personally I think the auto suffixing is nice, but it's kind of arbitrary and makes things less obvious with unit-less styles (but which support `px`). It seems to me that just dropping it from core is the right way to go.
 I think he meant if `Comp` has a render that does `style={{fontSize: this.props.fontSize}}`. Then it matters how you write `<Comp fontSize=... />`, or `Comp` has to handle different types and do what it intends.
 > Is there a list of properties that aren't being treated as pixels because they might be unitless? The only one I've encountered so far is `lineHeight`.

I can't speak for react-native but there is a non-trivial list when you have to support all of CSS: https://github.com/facebook/react/blob/master/src/browser/ui/dom/CSSProperty.js#L14-L37
 Oh I guess I misunderstood. Yea, I think you're right.
  JSFiddle: http://jsfiddle.net/vjeux/E8gCL/
 Reduced to 

``` javascript
var Hello = React.createClass({
    render: function() {
        return this.props.children;
    }
});

React.renderComponentToString(
    Hello(null, React.DOM.div(null, "Hello")), 
    function(s) { console.log(s); }
);
```

http://jsfiddle.net/vjeux/E8gCL/1/
 @vjeux Your last fiddle doesn't repro the problem for me; the componentDidMount is significant.
 @spicyj : Woops you are right, I rushed the comment :( http://jsfiddle.net/vjeux/E8gCL/2/
 I have a fix for this
 The fix is for the somewhat related putListener() memory leak
 I believe this was fixed by e73900dad48438c2e613c320220f495f27e99c53.
 Well, http://jsfiddle.net/E8gCL/4/ works for me now.
 (Filed #1079 which is probably the underlying cause even though the symptoms here changed.)
 @swannodette This works for you?

```
(.renderComponentToString js/React (dom/input nil))
```
  Now that shadow DOM is shipping in Chrome I think we should take this. @wereHamster have you run into any other issues with shadowdom + react?
 @wereHamster I know you said you weren't using Polymer anymore, but if you have a simple example that should work but was broken, that would be helpful for somebody who might be interested in picking it up.

In the meantime, I think I'll close this out since we dropped the ball (sorry!). If you're interested in picking it back up, just reopen!
  I can't see anything wrong with your code from a 2 min inspection. You are properly using key and the reconciliation should work fine. cc @jordwalke
 Curious. I'll take a look later.
 `<iframe>`s reload whenever they are reattached to the DOM. So it might not be reasonable to expect this to work. Consider two frames that need to trade places. One has to get removed from the DOM and reattached, no matter what you do. Hoping to get away with lucky re-renderings is a recipe for fragile code.
 You might think that you could just call `insertBefore` or `appendChild` without ever removing the elements from the DOM but at least in Chrome, that still makes one of the iframes reload. Maybe that means we can't fix this.
 This is one of the most regrettable misfeatures of `<iframe>`s, in my opinion. And, yes, it makes them pretty much useless in situations where DOM manipulations are abstracted out of your control, as they are in React.
  This is super useful for components that wrap a single child, see the test that defines 'children: Props.component'.
 :+1: This could probably replace over most usages of  `onlyChild` :)
 I'll follow up once this is committed.
 Alright, changed it to not be required by default.
  seems legit
 For FB people going to take this kind of code. When pulling in, make sure that you check for existing code that uses the same name using `onError=`. For onLoad it broke two call sites that accidentally transferred it to DOM nodes using this.transferPropsTo.
 pulling in
  When using dangerouslySetInnerHTML, you are using the HTML5 parser which is not an XML parser. It has a lot of weird rules in order to parse any HTML you throw at it in backwards compatible ways.

JSX is a proper XML parser though and should handle your code properly.
 When you use dangerouslySetInnerHTML, React simply passes the HTML to the browser untouched and you don't get any benefit from using React. Why do you need to use dangerouslySetInnerHTML here?
  Thanks for the report. That's definitely a bug in the example code.

The problem is that we're using the index in the array for key, which isn't consistent for items across passes when you don't remove the last time. You can instead use the text of each item as the key, at least for the small demo. If you ever have 2 items in the array that have the same text, you'll run into a different set of issues.

See http://jsfiddle.net/zpao/U6u4K/ where I have it working correctly.
  Fixes #851.
 Got benchmarks? :)
 I don't know how this could be slower but let me figure out how to run the benchmarks we just added‚Ä¶
 Looks about the same:

![image](https://f.cloud.github.com/assets/6820/1875642/5cec2ae6-78fc-11e3-95de-6ce1ac6d64ad.png)

In this run it looks a little faster for some of them; I ran it again and it was the other way around for the first couple. Not a significant difference.

(That's react-bench; I couldn't get `grunt perf` to work. @subtleGradient I'm getting:

```
Running "webdriver-perf:local" (webdriver-perf) task
>> Error: Condition wasn't satisfied!
Fatal error: Condition wasn't satisfied!
```

Any ideas?)
 Follow up pull request for react-art? (I think that's the reason)
  :+1: I like this.
 How about we make warning tool just like invariant that takes multiple arguments?

Then we make toString of Components output "ComponentName [OwnerName]".

That way you can just pass a component to warnings:

```
warn("This component is screwing up: %s", component);
```

and you always have the context in a consistent way.
 Isn't that how invariant works already? We can just define toString.
 invariant throws. this should just warn but it looks like it's coming here: https://github.com/facebook/react/pull/912
 So... I don't know why this is still open. Can you rebase and we can move on with our lives? We don't need to worry about this warn thing now since we use errors in proptypes.
 @zpao Rebased, sorry for the delay.
 I believe 40b522c498a138d3ee5e7729e8e9f330feef88aa fixes this.
 Oh yea, didn't even mean to have that happen :)
  @SubtleGradient proposed the following:

```
<Card>
  <Title insertAsProps="title" ... />
  <Body insertAsProps="body" ... />
</Card>
```

That would be the equivalent of doing

```
<Card
  title={<Title ... />}
  body={<Body ... />}
/>
```

EDIT: `insertAsProps` prop isn't needed when passed as a prop value.
 A React component can be seen a function. It's arguments are props and local variables is state. If you think as it this way, it actually make sense to pass the title as a prop. What's inside of the tag has a special meaning which is children. It feels like a hack to manipulate and modify the children to split them into different groups.
  This isn't super actionable so I'm going to close it out. Thanks for your thoughts though! CSS transitions seem to be surprisingly tricky.
  I know it's lame but can you sign the CLA so I can take this in? https://developers.facebook.com/opensource/cla

Thanks!
 Awesome, it'll be live the next time I do a batch of updates on the website :)
  :thumbsup: Nice catch. Thanks!
  Does React.isValidClass or React.isValidComponent do what you want?
 I would _really_ like to avoid adding anything to `__internals` and I would encourage you not to depend on that. That's basically there only to make the devtools work and I would like to kill it ASAP.

If @spicyj's suggestion doesn't work for you and you're doing this in node-land, you could `require('react/lib/ReactCompositeComponent')` directly. No guarantees on those APIs right now but it's there.
  What if we just made `React.PropTypes.isRequired` work? Adding `any` in there feels like writing code just to write code. Though it does conform to the same pattern, so nobody would accidentally write `isRequired.string`. Any thoughts @yungsters?
 `React.PropTypes.isRequired` doesn't read properly to me. I'm okay with `.any.isRequired`.
 d14ce00dc30889e5e9ecf3b28187101510647664
  I don't have much experience with document fragments so I'm going to guess:
1. it was never a use case we tested
2. there might be some other part that falls over if we render into a fragment

Not sure if either is actually true though. If you're interested, it sounds like you have a the experience that would help us figure out if it was intentional or if we can make it work. Let me know and we can help you out.
 We currently record an ID on the container to enable updates when a component is rerendered. Presumably you want to place the document fragment somewhere and that means it will switch container anyway. We think of the parent as updating the child so for updates to happen there needs to be container.

That makes this use case a little more complicated. In theory we could support it. I'm curious about the use case. How are you inserting this into the document?
 This is a regression of React 0.4.0. It was working in React 0.3.2.

React 0.3.2 (works): http://jsfiddle.net/vjeux/t6qL9/
React 0.4.0 (throws): http://jsfiddle.net/vjeux/Yh95C/
  In React, we currently warn in `__DEV__` for unknown properties when we think there's something you meant to use. In your case `maxlength` should have warned that it was expecting `maxLength` (https://github.com/facebook/react/blob/master/src/dom/DOMPropertyOperations.js#L58-L64). We don't warn for the others because it has potential to become very noisy (and would be unacceptably so at FB).

Otherwise, I agree that we should make some improvements to the HTML-JSX converter for accuracy. The tool is meant to still be in beta :)

cc @Daniel15
 Thanks, I can work on this. It might be worth utilising DefaultDOMPropertyConfig.js in html-jsx-lib so that its checks are consistent with React itself. I'm actually surprised how well the HTML to JSX converter is working at the moment, it seems like the only issues are little ones that should have easy fixes.

`-t-e-x-t-a-l-i-g-n` is pretty amusing. :P
 Moving HTMLToJSX issues to the https://github.com/reactjs/react-magic repository.
  Firs, it's unitless. I've seen a hack where the value is being specified as `'1;'` to make it pass the `isNaN` check and skip our adding of 'px'.

Further, `flex` is actually a shorthand property, so we should support the expansion into the right properties.
 I don't think we need to do anything special for shorthand properties except for the list `shorthandPropertyExpansions` needed only for IE8.
 related: there are also some obscure css properties that can be unitless: http://stackoverflow.com/a/2130116
Edit: + widow, - counter-*
 While we're at it, `widows` is also unitless. The `counter` properties mentioned in the above link don't actually take a single number.
 line-height 'px' is used 15x-50x more times than unitless, em or percentage on fb codebase. I feel like this should be the default and we should provide a more verbose way to use it in an unitless way.
 My view on this is that the CSS standard is only using strings. So if you say '1.5', React is just going to output '1.5'. Now if you say 23 (the number), then React is going to be able to add any convenience it wants, such as adding 'px' as it's the most common use case.
 It doesn't conflict _today_ (probably never will but still). Also, do we now want to add `lineHeightEm`, `lineHeightEx`, `lineHeightRem` (and so on for each numeric unit)?

I think I'm more likely to go for forcing a unit if you want one. (eg, `height: 12` doesn't get converted to `height: 12px`, you have to put the `px` in yourself).
 Fixed by #861 -- we can discuss units more on a separate issue if needed.
  I've wanted this before when we've talked about generating static sites with react-page, but it's come up again.

Let's make it possible for `renderComponentToString` to accept options(?) to not generate `data-reactid` and `data-react-checksum`. We'll need to cascade that down into the HTML generation.
  I bet @benjamn can add something to commoner to make this easier so you don't have to hack it.
 Have an issue filed to support this better: https://github.com/benjamn/commoner/issues/49
 To be clear, I'd like to hold off on merging this pull request until Commoner has better support for writing multiple files per source module.

I would be willing to accept a version of this pull request that only appended the encoded source map to the end of the module (without writing a separate file), however.
 I think starting with embedded sourcemaps is a good idea. Any idea how something like browserify handles them? (interested for our own purposes...)
 Well, browserify can presumably write one source map for the entire bundle, which is somewhat easier than writing individual source maps for each module. It also has an option for embedding the map in the bundle file.
 I was wondering what if you knew what it would do if each of the files it was putting into the bundle had an embedded map. No worries if you don't know!
 Ah, I see. That definitely is relevant to our interests‚Ä¶
 Ping. Also, do we want to support `--source-map-inline` if `--source-map-files` is available? Can Browserify understand/combine non-inline source map files?
 We probably want the same logic for `bin/jsx-internal`, too.
 What's happening here? I would love source maps, especially since we're doing it in the browser transform.
 ![bueller](https://cloud.githubusercontent.com/assets/8445/2884526/9382e7d2-d4ac-11e3-9732-17a7088ddfdb.gif)
 I actually would say that you can ignore `bin/jsx-internal` - that's just used for our internal module building. I don't really care about sourcemaps for those and if we need them later, we can revisit that.
 I bet you could reuse some of the code from #910 now that it's merged. We also have some similar inline sourcemap code in https://github.com/facebook/react/blob/master/vendor/browser-transforms.js as well. We could probably start to share a bit (not super high-pri for me, but good form anyway)
 Hey @andrewdavey, I appreciate you taking a stab at this, but I'm going to close it out and bring in #1825 which gets us part of the way there. I would still love to see external soucemaps so if you get a chance to come back to this, let me know!

PS, the work you did here definitely made it easier for me to write mine, so I appreciate it :)
  This is probably reasonable, though it'll break some people's current expectations. I do like that it would leave `.js` files alone by default. @benjamn?
 +1, we can then get rid of the docblock.
 I really wish we'd done this from the beginning. My only concern is for backwards compatibility. Maybe target this for the next minor version bump and make a big deal of it in the release notes?
 We're deprecating react-tools so closing out.
    Looks like this PR is stale. @joeyyang if you're interested in making @spicyj 's changes comment here and we can reopen it. Thanks!
  It should be relatively easy to autogenerate that. Want to take a stab at it and put the script in `/scripts`?
  fixes #820
 ok, just updated it `setState` so that it warns on undefined/null/empty object passed. How's that?
   Yes. I plan to add some memory profiling stuff soon. That'll be a bit tricky though since it requires passing command line flags to chrome. I'm not sure if sauce labs supports that yet.
 Current output example: https://travis-ci.org/facebook/react/jobs/16476932

SauceLabs example: https://saucelabs.com/tests/3161fd82969e422a9e05c6f0bd2dd9ee
 The unit tests are currently failing on master, this diff contains no changes to any React source.
 i tested it and it printed json to stdout. and running regular `grunt` still works
  #175 
  I think we also need to add these to this list: https://github.com/facebook/react/blob/master/src/vendor/core/getMarkupWrap.js#L35
  I had the same issue with this:

``` html
<p><a href="first.php">First</a> ¬∑ Second</p>
```

We actually have an internal task tracking this at Facebook but I don't think it's been looked in to yet. Here's a comment explaining why it happens:

> Looks like this is happening because https://github.com/facebook/esprima/blob/fb-harmony/esprima.js#L5446 is putting the parser in JS mode for the closing tag and when expect('>'); is called, lex() is preparing the lookahead token in JS mode which ends up being "¬∑" which is not a valid JS token. You get lucky using "&middot" because "&" is a valid JS token.
> 
> This happens any time an invalid JavaScript token appears right after a closing tag. Another repro is: &lt;div>&lt;div>&lt;/div> \ &lt;/div>
 @vjeux I'm actually going to leave this open for now so we remember to do the version update.
  I think this is outside the scope of React core. When we have a community components page we would be down to officially "bless" a router to reduce analysis paralysis, but I don't think it should live in the core.

I would also be open to a React official blog post that describes how to build an app from the ground up with a router.
 Why can't it be a React component with the route as a prop?
  Doesn't this work already? In my testing, it seems to.
 I don't think this is the proper fix. Instead, we should change ReactTransitionKeySet.getChildMapping to not return null children.
 Superseded by #829.
 Yep, Superseded by #829. Thanks @spicyj and @xixixao!
  My first attempt was to just add `var __DEV__ = process.env.NODE_ENV !== 'production';` to the top of every file, but unfortunately uglify isn't smart enough to do dead code removal then. I wonder if we should have vendor/constants.js essentially make two copies of the code -- one for dev, one for prod, so

``` js
function x() { return __DEV__; }
module.exports = x();
```

transforms into

``` js
if (process.env.NODE_ENV !== 'production') {
  var x = function x() { return true; };
  module.exports = x();
} else {
  var x = function x() { return false; };
  module.exports = x();
}
```

so we only pay the getter cost once (per module) at require time.

@benjamn Is doing this easy with recast? It's not obvious to me if `this.replace` interacts well with cloning the AST.
 I think eventually we will want people to do a build step for server rendering, i.e. webpack's `--target node` mode. Especially if people start expressing static asset dependencies as `require()` statements.
 That's not _too_ crazy. It's a bit annoying from a build process though. I'd love to know what's happening at a larger scale in the node community. It seems like we shouldn't be the first people to encounter this in a larger scale.

A couple other ideas‚Ä¶

What if we set `global.__DEV__ = process.env.NODE_ENV` in our main module and leave `__DEV__` in our code everywhere else. There's some obvious bad behavior there (setting globals). So we could do variants. Only set it when it's not already set. Change `__DEV__` to something more unique at build time (`__REACT__DEV__`) and then set that. If we switch to webpack for building the browser bundles, then the `DefinePlugin` solution is super easy, and I'm sure there's a way to do this in browserify too.

Another idea: Have a `RuntimeEnvironment` modules which memoizes `process.env.NODE_ENV`. This is sounding like something node should do itself, but the code @plievone linked to uses ObjectTemplate (which if I'm understand a bit of V8 right doesn't do any caching because values can change). There would still be a lookup cost, but it would just be a property access, not a getter and not a call out to get current environment variables (`getenv`). This one is trickier because it would mean more code and we won't do this internally. I'd prefer a different solution, even if it's more hacky.

If all you're using is React and nothing from `react/lib/*`, then you could do something like @plievone mentioned above. We started shipping the browerified bundles in the npm package, so `require('react/dist/react')` and `require('react/dist/react.min')` will end up giving you the bundles which don't access `process.env`.
 I don't think we're going to do anything specifically for server rendering other than bundling the builds in `dist` like @zpao mentioned, but we might change the npm package eventually to be prebuilt using closure or similar.
 It was just an example. If that was the actual code I'd do the direct assignment like you suggested.
 No movement, though you can already require the builds from react/dist as @zpao mentioned above.
 Because then `require('react/lib/whatever')` results in a different copy of code, which will have issues. As long as that is remotely supported (and it's currently how `react-dom` and our addons packages work), we can't do that. we might do something like that in the future though.
 @STRML The catch here is that people use envify to do dead-code elimination to remove non-`__DEV__` blocks so changing our pattern here will force downstream changes.
 ```
var React = require('react/dist/react.min.js');
var ReactDOM = require('react-dom/dist/react.min.js');
```

should work, no?
 Oh wait, you're right that react-dom does require react directly‚Ä¶
 @mhart I would be happy to do that, but it is important that we have a way to eliminate dev-only code in prod builds and that users of React from npm have a way to do the same. Obviously we can use whatever tools we want for our stack easily but for npm currently we suggest envify/webpack.DefinePlugin. Not inherently opposed to changing that but we'd need a good proposal and reason.
 I mean: if you use webpack or browserify in conjunction with react from npm, you should be able to eliminate React dev-only code from your prod builds. envify lets us do that easily in browserify as it copies the NODE_ENV from when you make your build, and webpack.DefinePlugin lets you configure your build to replace `production.env.NODE_ENV` with a constant which then can get constant-folded and minified out. This use case is important.

> If there were a way such that `__DEV__` was required, or declared, per module ‚Äì and code elimination still worked as it does now for the `dist` builds ‚Äì would you be amenable to a PR along those lines?

Yes, if it works for the case of React devs using browserify/webpack too, not just our premade builds.
 @STRML We'd still need everyone using React to upgrade to that version of UglifyJS so I can't promise that we'll take it‚Ä¶
 2 and 3 are the most natural for many people. If you are using browserify then envify gets used automatically because of our config in package.json. Almost everyone minifies their code in prod.

It is true that we could recommend #4 instead for many cases, but it does fall apart in the case of requiring submodules. We don't support this for external users because we consider the modules private but the addons packages use this pattern. Various third-party projects (unsupported by us) also make use of this.
 > I guess it's just a pity that users are encouraged to "reach in" to `react/lib/` for various addons.

To clarify: we recommend users require `react-addons-transition-group` or similar, which (currently) reaches into react but that's an implementation detail.

> So it's those doing 3 who are expecting their current UglifyJS setup to eliminate any code using `__DEV__` that you're concerned about?

Yes.
  I'm working on a rewrite of the website using react-page. But as any rewrite it takes time to finish it :)
 @xixixao sorry for the pain, especially with Jekyll. I take full responsibility on that one, I knew it when we were getting the site started and I could move fast. `wintersmith` looks a lot better than I remember (pre 2.0?) and I might give that a try if our react-page project doesn't work out.

Any suggestions on devDependencies? I'm guessing that was phantomjs? Or maybe one of them now has a binary build so downloads node source? Either way, we have to balance here and I'd like to make it easy for all and not waste everybody's bandwidth.
  Sorry for being misleading. All UI events support the detail property, but it should be 0 for all non-mouse events. You can see the W3C event docs here which indicate that `.detail` should be 0 for a scroll event:

http://www.w3.org/TR/DOM-Level-3-Events/#event-type-scroll
 (this isn't actually fixed yet is it @vjeux, @spicyj?)
 My PR isn't merged in, but the original bug of "detail isn't useful on scroll events" was invalid.
 Sorry, just in that `detail` isn't supposed to be a useful value on scroll events, per the W3C spec. If anything, your issue indicates a necessary docs change but not really a code change as seemed to be initially suggested.
  Hey, can you please sign the CLA? https://developers.facebook.com/opensource/cla I'll take this in afterwards :) Thanks!
  Fixes #807.

Haven't tested extensively.
  I played around in jsbin and found this answer suggesting that innerHTML won't work for SVG nodes: http://stackoverflow.com/questions/4282108/how-to-change-svg-text-tag-using-javascript-innerhtml
 The original issue has been fixed (#808 was relanded).

@gregorym - you are likely experiencing a different issue, perhaps #3972.
  Fixes #788.
 Does this fix #788?
 Yes, sorry.
  Can't we just mark a note to say that jQuery's not mandatory? I think people are used to seeing `$.ajax()`
 Yeah, I'm really not a fan of this change. The XMLHttpRequest API is very ugly.
 @joeyyang thanks for taking the time to do this, but I think _if_ we remove jQuery from the tutorial we should implement @Daniel15's idea of hard coding the data instead of doing any XHR.
 The XMLHttpRequest API may be ugly, but web developers should be familiar with it.

In any case, I think the data retrieval should be in a separate object that can be swapped out, rather than directly in the `componentWillMount` method.
  Ah, this is because onMouseOver and onMouseOut aren't supported by React right now. React does support onMouseEnter and onMouseLeave which is usually what you want and works for your fiddle. #754 makes over and out work too.
  Do you mind signing the CLA and I can take your change :) https://developers.facebook.com/opensource/cla
  I made this change because I think CallbackRegistry is an unnecessary level of indirection. I am not super happy that I added `getInstanceHandle` to the injection of EventPluginHub and I'd understand if this is not something we want - so consider this change an RFC. I had to move the injection code to avoid a circular dependency.

Personally I think it makes React a bit easier to follow (follow as in "where is this function defined") and if we'd need to switch out the put/get/deleteListener functions with a different type of registry it should be easy to revert part of this diff.
 Yes that makes sense - I'll wait until we agree if we want to pull this or not though.

Another upside of this change is that the isEventSupported check and warning for onScroll are now part of EventPluginHub - I don't think either of those things fit into something called CallbackRegistry.
  That would be very nice indeed. If you want to take a stab at it, the docs are in the repo in the markdown format. Would love to have you on the contributor list :)

https://github.com/facebook/react/tree/master/docs/docs
  `joinClasses` is used a lot in FB codebase and not only with two arguments. I'm not sure that it's really worth it to make a 2 argument variant of joinClasses just to save 30 bytes.

For the perf, if it's really a bottleneck it would be nice to have a fast path for the 2 arguments variant.
  Fixes #781.
 @plievone Just changed it to spy on ReactMount.purgeID which should be a little more resilient.
  See #772. :)
  https://github.com/facebook/react-art is another project we have that bridges React and ART (https://github.com/sebmarkbage/art/), which uses SVG or even canvas to render. It should be possible to use D3, though I'm not sure anybody has attempted yet. If you're interested in giving it a shot, react-art should be a good reference.
 Closing as this is not actionable :)
 This is pretty much a worst case for React because you're mutating the entire DOM on every tick so you don't gain anything from the diffing. I personally find the React example easier to reason about even in a simple example like this, but with hundreds of nodes updating on each frame you may find that it's better to do the dom manipulations by hand.
  (I took the liberty to edit your comment to add syntax highlighting)
 I can't reproduce this. With this diff https://gist.github.com/spicyj/747c79473b86bbefae0c applied, I loaded http://127.0.0.1:8000/examples/ballmer-peak/ in the console and checked `React.__internals.Mount._nodeCache` -- it was empty.

Am I misunderstanding?
 Thanks, fixed in #786.
 Thanks for the find/fix!
  Mind editing the docs to include getModifierState?
 > As `getEventKey` is now external there might not be as much of a point in having `getEventCharCode`, `getEventKeyCode`, etc as functions rather than inline in the interface, your opinion?

Hah, I was thinking the same thing. Most of the other events have these functions inline. In my personal opinion, seeing a line reading `var KeyboardEventInterface = {` gives context about where those functions will be used. Maybe this is being nitty, but once again, my personal opinion.

> PS. FYI when getEventKey was moved out require('invariant') apparently went missing, not that it really matters in practice, but good to know, it's fixed in my PR.

I think your PR adds the only caller to `invariant` to the `getEventKey` module.
 @yungsters how do you feel about this?
 I'm going to target 0.10 for this since it doesn't seem likely this is going in in the super immediate future.
   Kill the console.log :)
 Fixed, thanks.
 lgtm
 @caseywebdev Mind posting a jsfiddle showing the problem you're having?
 No, for img `load` events we specifically listen on the img element itself. Your example should work.
  `__DEV__` is compiled into `'production' === process.env.NODE_ENV` during the build process: https://github.com/facebook/react/blob/master/vendor/constants.js#L58-L60. The latter syntax is used by hand in the npm-react directory which doesn't go through the build process right now.
 Nothing actionable here right now, so going to close out. If you're interested in profiling, @plievone, I won't stop you :)
  Related: https://github.com/facebook/react/pull/764 Source maps on the in-browser transform
 #334
 :+1:
 #833 is still open, hasn't been merged yet.
 Probably not, sorry. Looks like there are still several unaddressed comments.
 That one has an option to produce source map files which is a bit more complicated because it needs to integrate properly with the file watching system which currently doesn't expect multiple outputs for a single input. fc5bb9c9b254e3646b90f6b6ce37bfaf64f1129f only added support for returning the source map when `react-tools` is used as a node library; it didn't change the command line tool.
 I'm not familiar with gulp-react in particular but it should be possible for it to support source maps in this new version.
 That would probably make sense as a separate PR because we probably don't want the `react-tools` transform API to do the actual file writing ‚Äì instead it'll need to return the source map somehow, perhaps in an object containing the transformed source and the source map since it wouldn't be able to return a single string any more.
 I think we were hoping for external `.map` file support too.
 react-tools is deprecated so closing out
  Don't we want to do this only when `__DEV__` is true?
 We only have one build of the transformer since it's not recommended for use in production.
  Related to #719.
 (@simenbrekken Your workaround is the best I know of.)
  @jenso: Why not doing b) and having a component per file? We do that internally and it's worked very well for us.
 Though I agree that one component per file is probably better, I don't think it's React's job to force a particular way of organizing files.
 Namespacing would be a very useful tool and I believe those who have expressed desire for it on this thread would benefit from some form of namespacing, but I'm not sure this is the best way to deal with that need in a general sense. Specifically, I am opposed to this particular approach because it conflates "namespacing" with code organization. 

If the only way to namespace your components is to put them together in a module (or nest them together within an object), then namespacing of components can quickly become at odds with the way one organizes their code -- which is a pretty unfortunate trade-off to have to make.

Consider, for example, if someone wanted to create a "common component library" (let's call it CCL for short) where it is desired that all of the components should be namspaced with "CCL". So `<ccl:checkbox />` and `<ccl:textinput />` (etc).

The only way the library author would be able to achieve this are:

1) Put all of the libraries' components into one huge module that exports them all:

#### ccl.js

```
var checkbox = React.createClass({
  render: function() { ... }
});

var textinput = React.createClass({
  render: function() { ... }
});

export {
  checkbox,
  textinput
};
```

Obviously for a large library, this is pretty unacceptable as it doesn't allow the library author to break their code into smaller more manageable (testable/isolated) pieces. It might be reasonable for smaller libraries and codebases, but it's not a scalable way to write a component library.

2) Place each component in its own module, then create an aggregation module that imports all of the components and exports them nested in some object:

#### checkbox.js

```
export default React.createClass({
  render: function() { ... }
});
```

#### textinput.js

```
export default React.createClass({
  render: function() { ... }
});
```

#### ccl.js

```
import checkbox from "checkbox.js";
import textinput from "textinput.js";

export default {
  checkbox: checkbox,
  textinput: textinput
};
```

This is MUCH more reasonable from the library author's perspective, but it pushes some issues off to the users of the library. The users can now choose how they will consume the lib, but their choice comes with trade-offs:

a) Users can import only the components they want to use in their local file, but forgo namespacing to do so:

#### thing-that-uses-ccl.js

```
import checkbox from "ccl/checkbox.js"

export default React.createClass({
  render: function() {
    return (
      <div><checkbox /></div>
    );
  }
});

```

b) Users can import from an aggregator module -- which includes _all_ of the components in the namespace -- to achieve namespacing in their local file:

#### thing-that-uses-ccl.js

```
import ccl from "ccl/ccl.js";

export default React.createClass({
  render: function() {
    return (
      <div><ccl:checkbox /></div>
    );
  }
});
```

This second solution is still pretty unfortunate for a few reasons:
1. It forces users of the library to make a potentially significant trade-off between namespacing and byte-size/packaging. It's practically impossible for any packaging system to identify and eliminate dead-code in this scenario (i.e. unused components) without some pretty sophisticated type tracking system.
2. It gives users of the library two different ways to access the components...but at a cost. You can always pick a style-guide rule for your codebase, but in this case if you choose "always use namespacing" you may need to allow awkward exceptions to the rule to support perf/size-critical areas of your codebase. This isn't _always_ the worst thing in the world (especially for codebases with a smaller team behind them -- where everyone can remember when/why the style-guide exception applies), but it is still pretty unfortunate for code-styling as a whole (and for larger codebases).
3. It makes it a little too easy to do the wrong thing: Write all your components in a single module and export them. Why not just this one time? I only have 3 stupid-simple components in my library... Of course, if you only ever have 3 tiny components in your library, you may encounter no issues here -- but if you have more, or if you ever change your mind and decide to add more, or those 3 "tiny" modules grow to be not so tiny anymore: You're likely going to run into problems pretty quickly. Of course best practice might be to use the aggregator-module pattern even if you only have very few simple components to start with -- and I whole-heartedly agree that it's not our job to tell people which best practices they should maintain -- but it is definitely our job to consider the kinds of ways people will use our the React library and structure it to encourage better patterns where and when possible [pit of success](http://www.codinghorror.com/blog/2007/08/falling-into-the-pit-of-success.html), and all that jazz)

Another note: I would like to defer the `.` vs `:` separator syntax discussion until we have a better understanding of what we want the semantic meaning for namespacing to be. Syntax is important, but its significantly less important than what it means to "namespace" a React component from a semantic perspective.
 In summary at a higher level: If we went with this means of namespacing, it would mean namespacing is really only a feature usable by smaller teams and/or codebases. I'd really like to see us try to come up with a more scalable solution so that everyone can benefit and use them.
 For what it's worth, including only some of the tags from React.DOM wouldn't give an appreciable size savings.
 What if namespacing a component didn't mean "nested in an object", but instead it meant "this component claims to be a member of this namespace"?

I'm totally riffing here -- and I don't claim these ideas are well thought-out -- but just as a thought experiment:

#### checkbox.jsx

```
export default React.createClass({
  namespace: 'MyLibrary',
  render: function() { ... }
});
```

#### thing-that-uses-MyLibrary.jsx

```
import checkbox from "checkbox.js";

export default React.createClass({
  render: function() {
    return (
      <div><MyLibrary:checkbox /></div>
    );
  }
});
```

(which desugars to)

#### thing-that-uses-MyLibrary.desugared.js

```
import checkbox from "checkbox.js"

export default React.createClass({
  render: function() {
    return (
      React.DOM.div(
        null, // namespace
        null, // props
        checkbox(
          'MyLibrary', // namespace
          null // namespace
        )
      )
    );
  }
});
```

I think this would address the issue of "true namespacing" where the components dictate what namespace they belong to (not the location of the code), and it would mean that namespacing could probably still be enforced statically with some tooling and a module system that supports statically-analyzable imports/exports.

It would not necessarily make life easier for those who use nested objects as a means of namespacing -- though I would imagine we could make some simple tweaks and utilities to make that not horribly complicated:

#### MyLibrary.not-a-module.js

```
var MyLibrary = ReactUtils.namespacify('MyLibrary', {
  checkbox: React.createClass({
    render: function() { ... }
  }),

  textinput: React.createClass({
    render: function() { ... }
  })
};
```

#### ReactUtils.js

```
function namespaceify(namespace, object) {
  for (var key in object) {
    var nestedThing = object[key];
    if (isAReactComponentDescriptor(nestedThing)) {
      nestedThing.namespace = namespace;
    } else if (typeof nestedThing === 'object' && nestedThing !== null) {
      namespaceify(namespace + ':' + key, nestedThing);
    }
  }
}
```
 The namespace could be verified at runtime (or even statically without types if you have the right setup -- a statically analyzable module system + tooling that supports it + string literals for the namespace entry in the `createClass()` call) to guarantee that what you're calling for is correct.

It also serves as documentation for the reader of the code.

And it leaves the door open to any module system rather than just a particular style

Thoughts here?
 It would also not solve the issue of having to extract items from a nested object into a local binding:

```
var checkbox = MyLibrary.checkbox;

React.createClass({
  render: function() { 
    return (
      <div><MyLibrary:checkbox /></div>
    );
  }
});
```

But this is necessary in just about any module system anyway (you have to put `require()` or `import` at the top somewhere) -- which doesn't seem to be a deal-breaker for people who use those things... I am inclined to suggest a perhaps controversial opinion of my own though and say that using a module system is truly the best practice; and so while we should totally support non-best-practices, I'm not so sure that we should add feature-sets that make trade-offs in their favor.

That said, as I mentioned to @spicyj on IRC, if we want to talk about opening up JSX to accept more than just an `Identifier` for a tag name -- I might feel a little better about going full-monty and opening it up to accept full `AssignmentExpression`s rather than just special-casing `Identifier` and `MemeberExpression` somewhat arbitrarily.

I think if we do that though, we should have a "more endorsed" means of namespacing first so that it's clear that we discourage the use of object-nesting for namespacing purposes. People could still do `<MyLibrary.checkbox />` if they want to disregard best-practice -- but for people who agree with and wish to conform to something a little more flexible, they'll have a better more robust option to start with (rather than having to settle with the nested-object form until we get namespaces set up -- and then go refactor).
 @Jenso: You mentioned you're using require.js and it sounds like your option (b) (one component per module) doesn't sound appealing to you. I'm curious if you could expand on that? To me it seems like a great option and, as @vjeux mentioned, it's what we do internally and it's worked really well for us -- but I wonder if I'm missing something?

@jessep / @martynsmith / @chikamichi: Are you guys using nested objects as a means for module emulation? Or are you using a module system of some kind (requirejs/amd/etc) and just expressing interest similar to @Jenso? More info and context would be good on what you'd like out of this kind of feature and why.
 Ok, after sleeping on this for a while I'm going to backpedal a bit here and say that if we open tag names up to allow any assignment expression (rather than special-casing member expressions and identifiers), I feel less strongly against `<Thing.Component />`. If you accept the notion of using member expressions for a tag name, you could make the same arguments for using function calls (or other types of evaluated expressions). Additionally a whitelist of expression types would only be a thing to maintain each time someone comes up with a reason why another kind of expression should be allowed

I still wholeheartedly disagree with the use of object nesting as a means of namespacing, but my alternative proposal doesn't actually address what people are looking for here. I also still think the proposal for cross-cutting component-owned namespaces could be an interesting feature, but it's not mutually exclusive to this.

So if we switch to allowing any AssignmentExpression, then all of the following (and more) become valid:

```
<MyComponent attr1={"one"} />
<Something.MyComponent attr1={"one"} />
<getMyComponent() attr1={"one"} />
<someCondition?component1:component2 attr1={"one"} />
```

That last example makes me want to vomit...but I guess one man's vomit is another man's treasure‚Ñ¢

Does anyone have any thoughts or objections on this? I'd still like to talk this through a bit with some more people before we go full-steam-ahead on it, but at the moment it's making sense to me
 I proposed this to @jeffmo today and he seemed cautiously optimistic.

Today, the `/** @jsx React.DOM */` docblock says: "for every HTML tag in some whitelist in the parser, access it as a key on `React.DOM`. Otherwise treat it like a local variable."

What if we slightly tweaked it to say: "for every _unprefixed_ tag that is in the HTML tag whitelist, access it as a key on `React.DOM`. Otherwise treat it like a local variable." Then we could provide custom prefixes that do the same behavior except ignore the whitelist.

The beauty of this is that we have precedent for accessing components in this way (`React.DOM.xyz`) and it doesn't tie us to implementation specifics so if we want to change it later on it won't be hard (and is statically analyzable!)

Here are a few examples.

## Prefix and no-prefix example

```
/**
 * @jsx React.DOM
 * @jsx XUI:XUIDom
 */

<span />;
<XUI:Typeahead />;
```

desugars to:

```
/**
 * @jsx React.DOM
 * @jsx XUI:XUIDom
 */

React.DOM.span(null);
XUIDom.Typeahead(null);
```

## Prefixed example

```
/**
 * @jsx html:React.DOM
 * @jsx XUI:XUIDom
 */
<span />;
<html:span />;
<XUI:Typeahead />;
```

Desugars to:

```
/**
 * @jsx html:React.DOM
 * @jsx XUI:XUIDom
 */

span(null);
React.DOM.span(null);
XUIDom.Typeahead(null);
```

## Future-proofing example

Let's say that in the future we decide we want to look up components using a function call or something. The previous example could be desugared like this instead:

```
/**
 * @jsx html:React.DOM
 * @jsx XUI:XUIDom
 */

span(null);
React.DOM.getComponentByName('span')(null);
XUIDom.getComponentByName('Typeahead')(null);
```

Thoughts?
 I am in favor of the idea of this new proposal, but I am a little unsure on the details. If `/** @jsx React.DOM */` behaves the same way as it does now, then we again need a whitelist of HTML tags that it recognizes, and if we keep the whitelist then it seems less generalizable than would be ideal.
 Yes, we will still need a whitelist. But that's only because we have no way of disambiguating between which tags you want namespaced by `React.DOM` and which ones you want to override. This is basically something that you accept by using the no-namespace option; if you want a completely general option then you should never use an unprefixed `@jsx` directive.
 So no-namespace is good only for HTML or is will there be a configurable list somewhere?

(My original impression from reading the docs on JSX many months ago was that it would transform `<x>` to `React.DOM.x` iff there was no variable in scope called `x`, which seemed very sensible to me. Someone mentioned that this mostly gets you into trouble around `<i>`, but it's perhaps something to consider.)
 Hey, my suggestion could be deterministically helpful.

I just want to make sure that if we try to make it environment-agnostic, then we actually do so, which isn't possible if we keep the hardcoded HTML tag list.
 A little bit. I'm in favor of @petehunt's proposal but I think it solves a slightly different problem, not the original issue of #74. (For example, I don't think I could in good conscience award John's money here https://www.bountysource.com/issues/645981-allow-namespacing-in-component-names-in-jsx to someone who implemented this idea.)
 I'm slowly caving on my opinionated thoughts on people using object nesting for namespacing. I still think this approach is wrong though (in spite of the fact that we're doing this with `React.DOM`...I think we set a bad example there) -- and I think the utility of this will decrease once es6 modules become more widespread. I agree with the point that allowing full expressions as tag names becomes prohibitively cumbersome when you consider that you must have matching opening/closing tags.

So that said, if we must just accept the notion of object-nesting as a means of namespacing, I guess I like @petehunt's proposal the most since it also helps solve the built-in whitelist issue we've had for ages. It would be nice to use `=` in the docblock instead of `:` though...seems like `=` would be a little less cryptic:

```
/**
 * @jsx HTML = React.DOM
 * @jsx MyStuff = MyComponentLibrary
 */
```

On the built-in whitelists, one option is to just move existence checks to runtime rather than having a whitelist in the compiler that should really be specific to a particular "magic" namespace:

```
/**
 * @jsx React.DOM // default
 * @jsx MyStuff = MyComponentLibrary // explicit
 */
<div />
<Foo />
<MyStuff:MyComponent />
```

desugars to

```
/**
 * @jsx React.DOM // default
 * @jsx MyStuff = MyComponentLibrary // explicit
 */
(React.DOM.div || div)(null);
(React.DOM.Foo || Foo)(null);
MyComponentLibrary.MyComponent(null);
```

On the other hand I would even be ok with dropping any kind of default namespacing altogether and just requiring namespaces for every directive. Then we don't need a whitelist OR an existence check.

```
/**
* @jsx HTML = React.DOM 
 */
<HTML:div />;
<div />;
```

desugars to

```
/** 
 * @jsx HTML = React.DOM
 */
React.DOM.div(null);
div(null);
```
 @spicyj : In what way does @petehunt 's proposal not solve the original issue?
 Yea, I used `html:`, but I imagine most people would probably knock it down to something short like `h:` as you suggest.

I have no problem with supporting a default namespace + runtime disambiguation though
 Ok, we're going to do member expressions. I think we're going to start with supporting `<Foo.Bar.Baz />` - not entirely sure what to do about `<Foo["Bar"].Baz />` (@jeffmo?)

If you're still interested in picking this back up @syranide, I think you're best situated to get back into it.
 Supporting arbitrary JS expression may be tricky. What happens if you write

```
<Foo[myVar()]>
  ...
</Foo[myVar()]>
```

Are the two expressions executed? What if they don't match? Lots of corner cases
 @syranide, let's make it so it's only possible to have dot format. Forget I said anything about `<Foo["Bar"].Baz />`.
 IIRC I think we agreed to go with non-computed member expressions -- so no more colon.
so:

```
// success
<MyStuff.MyThing>
</MyStuff.MyThing>

// error, because open/closing tags don't match statically
var myThing = MyStuff.MyThing;
<MyStuff.MyThing>
</myThing>
```
 Ah -- In this case we should update the parser to parse either Identifier or MemberExpression
 welp.
  Contrived example:

```
<input value={this.props.text + "}"} />
```

The value shouldn't end at the first `}`; you need at least some JS parsing logic to understand that.
 Technically you don't need a parser but you need a tokenizer.

Sweet.js macros operate on the token stream before it hits the parser. JSX almost works with Sweet.js except there are special rules for regular expressions. Closing tags doesn't work with the / token depending on context. The regexp resolution rules are hardcoded into the tokenizer. Sweet.js probably can't support our whitespace rules neither.

However, if we treat JSX as strictly part of a custom tokenization stream, we can do the transformation purely on the token level, just like Sweet.js. That should leave it compatible with any other language extension that doesn't need special tokenization rules. The resulting code would even be compatible with Sweet.js macros.

What do you think @jeffmo ?
 Even if it was true that we can't get good enough error messages using a token-transform alone you can still have the parser provide context to the tokenizer.

If your parser can provide a compatible context , that's great, you get better error messages for free.

If it can't and you have to pipe the raw transformed strings, you still have the option to do that. If you want to use TypeScript or HipsterScript you can.

We can't add a convenient extension to the language and expect that nobody else will add other extensions. People will want them both. If you have to choose between TypeScript or JSX then JSX will certainly be seen as the toy.

Unless there is an ambiguity problem ofc. TypeScript may not be compatible for other reasons. That's why I like macros because they can be contextual extensions. An identifier can be treated differently depending on if it's a known React/JSX component or a Type/Class/Interface.
 Apologies for just chiming in without reading the discussion. I just thought I'd let you know the result of a previous discussion I had with someone who started adding JSX support into TypeScript. We found it was difficult to distinguish type parameters `Array<Things>` from JSX. My suggestion was to require that all JSX be wrapped in parens like `(<Typeahead />)`. This makes it easier to parse, and most of the time we end up wrapping our JSX in parens anyways to guard against Automatic Semicolon Insertion, so people are used to it. 
 I was worried about maintaining two versions. In theory you could make a tokenizer that can be a drop in replacement in an esprima based typescript parser. But that's certainly more difficult. 

This could be a nice quick fix. You can always add special look ahead/behind rules. It doesn't have to be pure.

On Jan 2, 2014, at 7:14 AM, Andreas Svensson notifications@github.com wrote:

> @thorn0 @jordwalke It seems like Array<Things> shouldn't be an issue to solve if you're extending the actual parser (but perhaps you're not), as the parser should not be in a state where it would consider JSX to be valid. However, <A>1</A> seems intuitively harder to solve as we cannot know if <A> is JSX or a type-cast until we've found the closing </A> but does not seem reasonable.
> 
> It seems to me that your suggestion has the same issue unless you're explicitly disallowing type-casts as the first instruction inside parens, which isn't perfect, but should very rarely be an issue. So it's a surprisingly neat distinction/solution to a major ambiguity.
> 
> ‚Äî
> Reply to this email directly or view it on GitHub.
 This is already a problem in JavaScript with regular expressions. You can still implement JS highlighting without a proper parser because you can use look behind to disambiguate. It's not easy to enumerate all the potential cases you'll have to look for though. Hopefully they're bounded.

Sweet.js has a pretty good write up on this for regular expressions. Since those are allowed in similar places as JSX I figure the solution would be similar. https://github.com/mozilla/sweet.js/wiki/design
 Of course the extended language could add features that you can't account for. So it may not always work. That's why it would be great to have at least a little bit of feedback from the parser. E.g. if a regular expression is allowed, then can we also assume that < is the start of a tag.
 Note: typescript also uses <tag> for generics

```
var greeter = new Greeter<string>("Hello, world");
```

http://www.typescriptlang.org/Playground/#src=class%20Greeter%3CT%3E%20%7B%0D%0A%20%20%20%20greeting%3A%20T%3B%0D%0A%20%20%20%20constructor(message%3A%20T)%20%7B%0D%0A%20%20%20%20%20%20%20%20this.greeting%20%3D%20message%3B%0D%0A%20%20%20%20%7D%0D%0A%20%20%20%20greet()%20%7B%0D%0A%20%20%20%20%20%20%20%20return%20this.greeting%3B%0D%0A%20%20%20%20%7D%0D%0A%7D%0D%0A%0D%0Avar%20greeter%20%3D%20new%20Greeter%3Cstring%3E(%22Hello%2C%20world%22)%3B%0D%0A%0D%0Avar%20button%20%3D%20document.createElement('button')%3B%0D%0Abutton.textContent%20%3D%20%22Say%20Hello%22%3B%0D%0Abutton.onclick%20%3D%20function%20()%20%7B%0D%0A%20%20%20%20alert(greeter.greet())%3B%0D%0A%7D%0D%0A%0D%0Adocument.body.appendChild(button)%3B%0D%0A
 @vjeux I can't think of any case where generics are ambiguous with JSX. Because they're always preceded by an identifier which is not valid JSX. They're ambiguous with JavaScript though!

Type casting is a big issue though. The parenthesis doesn't help.

Most cases are actually not ambiguous:

```
(<foo>x) // cast
(<foo />x) // error, x is invalid after a component
(<foo />) // jsx
(<foo attr="">x) // error, missing closing tag
(<foo attr="">x</foo>) // jsx can be early determined by the attributes
```

The parsing code and error messages becomes really weird when you have an opening tag without attributes. You have to optimistically parse ahead a long way to find the matching closing tag which breaks the ambiguity.

```
(<foo>x + (y) + </foo>)
```

Even then it's ambiguous with regexps.

```
(<foo>x</foo>/+5)
// could mean:
(<foo>(x < new RegExp('foo>') + 5))
// or
(foo(null, x) / 5)
```

So, yea. The type cast syntax screws us up. I really want to make this work though.
 Note that `(<foo>x)</foo>)` is valid JSX.
 @spicyj It's not valid TypeScript though. Need to make it into a RegExp to make it ambiguous I think. Maybe you can think of another case?
 Sorry, I thought you were implying that you could stop parsing at the close paren. You may be right that regexes are the only tricky part; perhaps we can solve that by requiring people to wrap regex literals in parens? I think JSLint might already warn about that. Still, it does sound like we may need arbitrary lookahead to disambiguate which sounds like a recipe for confusion.

(One other idea I mentioned to @syranide in IRC was requiring people to wrap each JSX expression in backticks, sort of like how we recommend JSX in CoffeeScript now. Obviously that's a bit of a pain but it easily removes any ambiguity.)
 Ideally we would use

```
jsx`<foo>${x}</foo>`
```

To make it fully executable ES6. I think that JSX is always close to being more of a pain than it's worth. Compared to just invoking functions. Back ticks, as small as they seem, might be the final straw.
 I guess back ticks would actually remove an ES6 feature unless we prefix with something. So it doesn't work without a prefix anyway.
 Yes. I agree that infinite lookahead is not an ok solution. It's more of a thought experiment to see where it leads us.

I think that you're right that an alternative syntax for cast is the right way to go here. Particularly since this syntax is not really intuitive or common for the current use in TypeScript anyway. It would seem that making that change is possible.

Some ideas without really thinking it through... The simplest most intuitive to me is that you type the expression:

```
var x = { } : foo;
```

Another alternative would be to add a contextual keyword somehow:

```
var x = cast<foo> { };
var x = cast { } as foo;
...
```
 @syranide There can always be conflicts and we have to solve them on a case by case basis. Namespaces could easily conflict with another language too.

You can also just use an external function if we kill the type assertion operator.

```
class Parent {}
class Child extends Parent {}

function cast<T>(obj : any) {
    return <T>obj;
}

var x : Parent = new Child();
var y = cast<Child>(x);
```
 @fdecampredon Mixins is just a handy tool, it's not a fundamental part of React, you're free to substitute with anything you like (or nothing) if it isn't a good fit for TypeScript. Ofc that could potentially conflict with some third-party helpers you choose to use, but I'm assuming those wouldn't work out of the box regardless.
 @sebmarkbage This a task for the community (and I know some are experimenting) and not the responsibility of React-JSX, or?
 Unfortunately I think that we need to leave this to the TypeScript team to make the decision if they want to support JSX since they have other syntax that conflicts with JSX.

Using TypeScript without JSX will still be possible but it's expected that it won't work quite as well as Flow. http://flowtype.org/ At least not as quickly. Since Flow is being developed with the intent to support React concepts.
 @basarat yea, just _type assertions_ conflicts. Flow doesn't support type assertions since it attempts to be more sound than TypeScript.

@brigand that's not quite correct. Flow works well without type annotations, but it definitely intents to use type annotations too. For three reasons:
- Documentation of intent and as a way to catch mistakes that would pass type inference but isn't intended to work.
- As a way to intentionally limit the API surface area even if it would currently work with a wider set of inputs. I.e. defining a contract.
- As a way to speed up type analysis of large code bases by enabling parallelized analysis.

Flow aims to unify with TypeScript where it makes sense but it doesn't attempt to support all the syntax/concepts and does diverge in some areas.
 @QuantumInformation Probably a better question for the reflux folks.
 TypeScript may start supporting JSX per https://github.com/Microsoft/TypeScript/issues/3203. We don't have plans to develop JSX support separately from that, so I'm going to close out this issue ‚Äì but feel free to continue discussing here or on https://discuss.reactjs.org/ if helpful.
 See http://www.jbrantly.com/typescript-and-jsx/ for an update from @jbrantly on the current state of affairs.
  Do you know what was the reason for having it global in the first place?
 This goes back through many file moves and I'm certain it's unintentional.
 Can you remove the `require('ExecutionEnvironment')` call since that's not used anymore.
 Done, sorry.
  That's an awesome pull request. Thanks a lot! I don't have a lot of context here but made small comments on the style so this looks more like the rest of the files. I'll let @petehunt do a more thorough review.
 I don't know if I'll get a chance to look at this until next week. My cursory glance of this makes me think this won't be hard to get in though. In the meantime @vjeux's comments are helpful and signing the CLA could get us a head start! http://developers.facebook.com/opensource/cla
 Ping @petehunt 
 I don't think we're going to merge this, at least not in its current form. I also think the current ReactTransitionGroup API makes it easy enough to implement this outside of React itself if necessary.
 https://github.com/chenglou/react-motion supports staggering and that's likely what I'd recommend right now, even though my name isn't @spicyj 
  So easy
  I think @jordwalke originally left these out due to concerns about performance. However, now that we have on-demand event listening, maybe this is not a concern?
 EnterLeaveEventPlugin already uses the over/out events underneath, and onMouseMove is fired way more frequently so I don't think it's a concern.
  FYI: Internally there's
- flattenChildren but that returns a map: https://github.com/facebook/react/blob/bdf2a9bb124b8fc34120949b322202497741f239/src/utils/flattenChildren.js
- mapAllChildren that iterates but doesn't create an array: https://github.com/facebook/react/blob/bdf2a9bb124b8fc34120949b322202497741f239/src/utils/mapAllChildren.js
 I think we should expose `mapChildren()` more obviously and document it
 Yes, `mapChildren()` is an accessor similar to how Om works. It just iterates over all immediate children and ensures that any React components returned are keyed correctly.

Most of the time you don't need any other functionality. However, I think that we need to expose this method in the API -- perhaps on `ReactCompositeComponent`.

`this.props.children` has always been intended to be an opaque object. There are two main reasons for this:
- Performance: treating this as insignificant may lead to a death-by-papercuts effect, where every minor memory optimization we forego will add up and we'll wake up one morning and be hanging large apps on lower-end phones. It's far easier to code with this in mind from the beginning rather than track it down later, especially since we don't have to fundamentally change the coupling between components. Also, I have a dream of zero-allocation render() methods to avoid the GC and this would be a step in the wrong direction.
- Implementation flexibility: the way reconciliation works should always be an implementation detail. And in order for us to improve it we may need to change the data structure backing `this.props.children` (i.e. there is a linked list impl of React that is rumored to be 10-15% faster). If you assume `this.props.children` to be of a specific type then we'll either need to break apps in the future or build a compatibility layer.

So I think an optional accessor function is the right way to go, and it's already in the repo: `ReactChildren.map()`. Does this solve your use case?
 @sebmarkbage definitely needs to be on this thread since we used to flatten children to an array (and therefore `this.props.children` was always an array) and we eventually reverted it.

@swannodette I don't think something like `shouldChildrenUpdate()` would be controversial. We used to have a magic prop called `isStatic` which would do exactly what you're talking about. I think the challenge here is just to make the API nice and constrained. @jordwalke what do you think?
 @andreaferretti can you describe your use case in a little more detail?
 @swannodette We already consider immutable objects to be a critical part of React. Our future design will continue to revolve around optimizing the reconciler for the immutability. In fact, we're just about to land another optimization that breaks certain mutability use cases. The shouldComponentUpdate hook is currently not doing this by default but it's a critical feature that doesn't work well with mutability. Supporting a mutable JS paradigm for certain components doesn't limit our ability to optimize for immutability for larger sections.

In our next release we won't reconcile children that have the same instance as before, by default. We can assume that they haven't changed. The rationale is that if you mutate something on a prop, you also tend to recreate that child. That means that subtree updates that receive children from higher in the tree won't reconcile all the way down. This will work for free if you do subtree updates.

Is your issue that you're reconciling from the top and want to avoid rerendering the parents?

I'm not sure if I interpret your proposed shouldChildrenUpdate() API correctly. I can think of a few issues. Children are not the only way to pass components. Often you should be passing them through named properties which indicates the intension more clearly. Especially if there are multiple sets of children. There is no special case for children in composite components. You also need to be able to nest children so how do you specify this for a nested set? It also needs to make sense for fragments, i.e. returning multiple components at the top level of a single render function.

One of the important ways to do perf optimization is to create smaller components. I.e. if your children tend to update separately from the rest of your component, you should be breaking them apart anyway. Sometimes this means passing them in from above. Sometimes it means wrapping them in another Component. That other component will have shouldComponentUpdate on it so it should never needed to recreate the large list of children. Similarly, if the children are passed through above, and state updates in the current component, they won't reconcile by default.

The reason children goes on props is because there's nothing special about the children property. That's just how we express the children property in terms of the XML like syntax in JSX. Since another component can take an opaque set in named property.

```
var Foo = React.createClass({
    render: function() {
        return <Bar><A /><B /><C /></Bar>;
    }
});

var Bar = React.createClass({
    render: function() {
        return <Baz header={this.props.children}><div>sdfg</div></Baz>;
    }
});
```

If you want to pass a function to lazily instantiate children, that's perfectly valid. You will always be able to pass that explicitly.

```
<Baz children={fn} /> or Baz({ children: fn })
```

The additional arguments to the function just happens to create an opaque set.

As for why this set is opaque and why it changes shape... We're aware that this is inconvenient and I tried really really hard to get this addressed before we open-sourced. It turns out to be very tricky to solve the semantics and retain performance.

The fact that it's sometimes a single child and sometimes an array is just a perf optimization. Semantically they're equivalent and we could easily just wrap the single child in an array if that was the only issue.

The real issue has to do with nested fragments.

```
var a = <Foo />;
var b = <Foo />;
var earlierDefinedSet = { a, b };
<Foo>
  <Prefix />
  {this.props.dataList}
  <Infix />
  {this.props.children}
  <Suffix />
  {earlierDefinedSet}
</Foo>
```

We want the ability to conveniently be able to prepend and concatenate sets of components. You can't just flatten one of these to an array, because you would lose the key context. The keys can only be guaranteed to be unique in the set where they were originally passed in. Not in a concatenated set.

The initial proposal added a context to the key of a component as it passed along. To get the implementation details to get that right ended up being fairly complicated because you can extract a component from an array and place it in a new place. Ideally it would still preserve it's identity. That worked with the exception that you couldn't place the same component in two places (which you still can't).

In the end we reverted the whole thing because of the complexity of the implementation.

Another proposal was to make it truly an opaque set where you could never extract values on it. Just operate on it with custom functions. I was against introducing a new set type because we want to be able to interoperate well with a larger JS ecosystem.

With ES6 stablizing there are few alternatives that could be possible.

There was previously a strongly held believe that arrays must be treated just as any other key/value object. I believe that to be incorrect since in ES6 they can equally be treated as iterable types, which could shift the semantic meaning of an array within one of these fragments.

We could potentially expose children as a Map which observably preserves order in ES6. The contextualized keys would be part of the Map's keys. It's also possible to implement this lazily. This is probably good idea to start with.

But it still leaves a lot of unknown questions.

The same question remains about what you do with an instance that you gain access to from one of these Maps. When you place it in a different position from before, does it retain state? The caller would assume that it would. The final position in the tree may be different. You would also be responsible for preserving the key correctly. We'd probably need the ability to move nodes between parents to preserve the state intensions of the caller.

What are you allowed to access on the instance? You shouldn't be calling methods on the instances because they're not stateful and we would even want to prevent that in the future for other reasons. Even if you could call methods on children, you can't rely on a composite having those same methods. That would mean limiting the ability of your parent to wrap parts of it's children into composite. That's a really important design prinicipal.

You could possibly want to have the parent inject properties into your children but those may pass through a composite that isn't aware of those.

I think there's a larger issue about how a parent communicate with children that it didn't create itself. One way to solve this would be to expose an API that lets the parent resolve children down to an abstraction that it can understand and communicate with using a custom API.

We need to figure out what those semantics should be and then we can talk about what the type should look like.
 Eh, I guess... personally I dont feel API like `onlyChild` solve the problem. Sure, now we have an explicit way of retrieving the child, if we know that there's only one. But the point is we often don't.
I'm more or less ok with the API but I'll close this if @swannodette is fine with it. 
 onlyChild should only be used on Components (soon to become Component Descriptors).

You can still set the `children` prop to a function and just assume that it's a function, and call it as a function.

I wouldn't do that with the second argument to the component constructors though (that translates to the children property). I.e. the "children" position in JSX.

@swannodette Do you need to use the second argument or can you use an explicit property named `children`?
 http://facebook.github.io/react/docs/top-level-api.html#react.children.only
 Sorry, to clarify ‚Äì onlyChild is the internal name; React.Children.only is the public one.
  There's a lot of calls of .getValue() which are hard to differentiate between good and bad calls. It'll take a white to get this in.
 I looked into this more and I think that there are no bad callsites to getValue(). Can you rebase so we can try it?
 Thank you. Rebased.
  Nice catch, looks good to me.
  This adds some more addons.

If this is accepted we will update the documentation to have instructions for using addons from `npm` as well as from the premade builds. If using `npm` you should `require('react/lib/ReactTransitionGroup')` rather than using `react/addons` so you don't pull in extra dependencies.

I think we definitely need the event plugins and TestUtils. I wasn't sure about `ImmutableObject` and `StateSetters`, but they seem like good ideas.

I considered adding `ReactUpdates.injection` in there for pluggable batching strategies and `ReactPerf`, but this already works in npm today (`react-raf-batching` and `react-profiler`) and I wanted to keep this as constrained as possible.

If someone signs off on this I'll stack a commit on top with docs (or do it in a new PR, either way).
 Also -- I could land `react-raf-batching` in `addons` so people will know it's there (@sebmarkbage will probably like this). Is this something people are interested in?
 These are pretty safe but I'm still a little bit concerned about supporting these. I know we've said addons is dangerous and we'll change it at anytime, but I'm afraid we're going to see more copypasta of things that aren't supported.

So I'd like us to make sure we harden our APIs before exposing them as much as possible. Again, these are probably fine (then event hub is the one I'm nervous about) so I think it's fine here
 `injectEventPluginsByName()` should be pretty safe, no?
 I'm good with it, letting @zpao do the final accept
 Yea, it's more about the case where a component you include injects an event plugin and that's totally outside your control. We're moving quickly into the world where people are using React and we're not having that close contact we had for the first few months. We're not seeing all the ways the uses are unfolding and I'm just getting a bit nervous is all.

Feel free to go for it.
 I like rAF batching and I like add-ons but I wish we didn't have a React with add-ons build. It seems so final and official. It should be easy to expose these. They're really all candidates to be in the core. It's more of a alpha extensions build.

We should take a page out of the old MooTools playbook and allow custom downloads: http://mootools.net/core/
Want even more? Get some more plugins: http://mootools.net/more/
 I'm regularly sending people towards DOMContainer which has a small yet useful API but we don't provide it. That would be a great addition to addons.
 I wonder if we should add `PureMixin` too? Anything else?
 `ReactLayeredComponentMixin`?
 I don't think it makes sense to expose `ReactLayeredComponentMixin` without `ReactLayer` and a couple of behaviors. I think we should punt on this one until we have a good plan for it
 I think we could open-source Instagram's fake `Layer` implementation, since that architecture is not something that's currently in open-source AFAIK. We can let the community expand on it.

Should we add `cloneWithProps()` too? And `mapChildren()`? Sheesh :/
 This pull request is getting out of hand. Let's open a separate pull request per module. It should export the module AND add a documentation for it. We'll be able to discuss on whether we should export modules on a per module basis instead of everyone at once.
  I think this gets into the realm of creating a DSL for accessing properties, which is something I'd like to avoid. This mixin is really for the usecase of lots of form fields to save typing. If you want to implement your own mixin that does this, it would be very easy and would require no core changes. Sorry abuot that!
 Getting this syntax to be closure compatible is going to be hard. It'll also grow the API and make it polymorphic. 

Additionally I can't really think of a situation when this would be a great idea... if you need this you probably should decompose into another component.
 @fingermark Now that we're going to add an immutable deep-update addon, I'm starting to think that this could be a useful addition if we can get it right.

I think we can do what @syranide suggested if we provide a helper for Google Closure Compiler.

What do you think of: `this.linkState(keyPath({a: {b: {c: true}}}))`?
 Yes, `keyPath({a: {b: {c: true}}})` would be the equivalent of today's `[keyOf({a: null}),keyOf({b: null}),keyOf({c: null})]` which is what you need to do if you want to minify correctly. This would turn into `['a', 'b', 'c']` so the final invocation would be `this.linkState(['a', 'b', 'c'])`
 Ideally `ReactLink` + `update()` (the immutable setter that IG uses and we're open-sourcing as an addon) could be combined to build Om/Cortex-style cursors, which could then be used to implement LinkedState
 I am just wondering if people will WTF over that object literal syntax, since most people don't care about closure compat. I would personally prefer it. I think this kind of API would fly more in npm than as an official addon.
 Courtesy of #2302 this will become slightly less relevant (but not necessarily irrelevant) as ReactLink will no longer be supported by the core components.
 As per #2302 we're probably dropping ReactLink in controlled components. The LinkedState mixin really isn't used much, and even less so now that people are moving towards ES6 classes. Also there have been no replies on this thread, which indicates a lack of interest in this topic. Since LinkedState appears to be on its way out, my guess is that we won't invest a lot of effort in enhancing the mixin and it is mostly legacy at this point. If you find it useful, feel free to create your own LinkedState mixin for your apps and/or publish it for others to use.
 Yes, I think so. It is not hard to build your own component with the same behavior and we'll be sure to explain how to ease the migration.
  If you use ReactChildren it won't coalesce later since it turns them into ReactTextComponent first. It would be nice to keep them as strings until they're mounted I guess.

I'm not sure if it's worth while thrashing on these edge cases until we can get a consistent experience where we're never wrapping with spans and can clean up all the ReactTextComponent weirdness.
 I'll close this out but this is a great idea. If we can do it in multichild, we could get rid of spans completely. I think we can do it. That change would be easier to reason about since it just means that we never wrap things in weird ways.
 Agree, will look at doing that when I have time.
 @thSoft Good catch. I still want to get rid of the spans completely and think that we can do it.
 The solution is to use onMouseEnter. This is why we had onMouseOver disabled before because it gives confusing effects in certain circumstances.
 @spicyj updated the pull request.
 (What @facebook-github-bot? No I didn't.)

@natew I'd like to fix this sometime but it hasn't been a priority.
 @natew @spicyj @facebook-github-bot Pure speculation: if there is some activity (any activity) on an old PR that predates @facebook-github-bot (perhaps a PR that doesn't have a review label), then github bot doesn't know about it and so it claims the PR was updated.
  This is a great idea. I'd love for us to have a more complete set of tooling available.
 This was done when I split html-jsx-lib out into the [React-Magic](https://github.com/reactjs/react-magic) project. You can get the tool from NPM at https://www.npmjs.org/package/htmltojsx (although I haven't done as much testing with the Node.js version compared to the web-based version).
  :thumbsup: Can you sign the CLA? https://developers.facebook.com/opensource/cla
  @sebmarkbage Just updated with a pretty complete validateNodeNesting function.
 Yeah, this will warn when putting a `<tr>` directly in a `<table>`.
 After talking with @sebmarkbage, I'm going to close this out since I think we don't want to do this this way. There's work being done to make this possible without inspecting markup.
  Can you sign our CLA at http://developers.facebook.com/opensource/cla and comment here when you've done it? Thanks!
  Looks like there are merge conflicts, wanna rebase and then we can pull this in?
  I might revert this, but haven't decided. The 80 chars is a strong suggestion, but I mostly trust humans to break the rules where it makes sense. That URL should remain on a single line so it's copy-pastable.

That said, we've come back multiple times with "make this fit in 80" so perhaps it makes sense to have but make it a warning but not fail lint (I'm not sure that's even possible)
  this lgtm, pulling it in
  @cpojer if you want to create an upstream diff I'll stamp it
 You say it can be null but no tests to confirm (also doesn't look like that's true)
 Ok I'm sold, let's do it :)
 TLDR; I agree.

A component that has null or undefined should be treated as a stateless component. Debugging tools may use it to determine whether this is a stateful component or a simple one. We might be able to do optimizations by knowing that a component isn't stateful.

I could see the benefit of being able to determine if a component should be stateful at runtime. That should probably not be determined by props since that always makes it potentially stateful. Class level flags you can probably just make the whole getInitialState function null if you need to.
 Right, but perhaps we should also forbid null while we're at it?
 If you don't need any state, you can `return {};` instead of null
 I don't really care tbh
 @sebmarkbage what do you say?
 Some people use dynamic property keys to add to the object later. Returning an object demonstrates the intension that the component is stateful. An empty object may not have all it's keys yet but will at some point.

I guess we wouldn't want to overload that intension. We should probably just allow null until we can figure out when this is used, if at all.

Don't really care. I'm just thinking out loud. You should get this is in.
 Upstream diff is accepted and ready to land, so I'm merging this.
  What about things like `var style = { margin: [10, 20] }`? This would expand those to `margin:10px;margin:20px`, when the intent was probably to produce `margin:10px 20px;`.
 I feel like those use cases can easily be addressed by a small wrapper that has feature detection.

```
var style = {
  cursor: grabCursorWithPrefix(),
  backgroundColor: rgbaWithFallback(200, 54, 54, 0.5)
};
```

But, if you really need to write them using fallback, you can just make a CSS rule for them and add use a class.
 Regarding vendor prefixing: we talked about doing vendor prefixing in React a while ago but decided it was a lot of bytes and complexity for little payout.
 Given that's a very broad API for a very narrow use case and there work-arounds available, I'm going to close this pull request. Thanks a lot for submitting it, it's always good to stimulate a healthy debate on the API!
 @mccutchen Instead of adding all of them, detect which one is the correct and apply only that. It will be faster too.
  Can you sign our CLA and comment here so we can merge this? Thanks! http://developers.facebook.com/opensource/cla
  Do you know who should review this diff?
 @paulshen wrote fb6381f, but this looks good to me. Thanks for tracking it down.
  Right now camelCasing `data` attributes warns in **DEV**
 welp, the API i'm implementing had them in their docs -- oh well.
  Sorry, no progress on this. It's hard to make this happen automatically with our current architecture.
  This same change was made by @benjamn for `react-tools` package: https://github.com/facebook/react/commit/9da3f92853fe80e4f16f6ff149fd87c43e44256e
 The current version is broken too: http://wzrd.in/bundle/react. @zpao: do you know what needs to be done to take in this change and update npm?
 https://github.com/jesusabdullah/browserify-cdn/issues/59
 What's broken?
 npm react doesn't have any other dependencies so that's weird. Perhaps you were using react and react-tools at the same time? Either way, we want this update so ‚Ä¶ :shipit:
  Thanks a lot @bitshadow, do you mind signing the CLA so we can merge it in? https://developers.facebook.com/opensource/cla Thanks!
  :+1: 
 can't check this in without an accurate comment, sorry :/ you could replace it with a more handwavy one
 just kill the comment. it's wrong
 also let's just get the full 64 bits of entropy.
 Ah right 53 bits. I think a better fix for this would be to make the strategy for generating these IDs injectable so that we can support a safer strategy for server rendering en masse
 I'll take care of it
  This looks pretty good. I'd be curious to see if an indexOf('.') !== -1 check before escaping would help perf in the common case. Since the common case is no dot.

We could also escape to a format that doesn't need re-escaping when it goes into the DOM attribute. Since we already have one escape pass, we can utilize that for both. Might be dangerous though. Easy to open up XSS vulnerabilities.

Finding a solution that gets rid of long concatenated IDs in the markup is probably a much better use of our time than micro-benchmarking though.
 @syranide That benchmark is testing the existence of dots as almost equal likely as not having them. The 99.999% case is that they're not there, since it was broken before and people barely noticed. A more typical benchmark would remove the dots from the test case:

http://jsperf.com/aefsefsefsf/2

That shows a bigger boost.
 Why do have to escape `}` but not `]`?

Another interesting perf test http://jsperf.com/aefsefsefsf/8 (Wouldn't get too hung up on it though.)
 Let's go with the simpler one. It only really made sense to bail out when I thought we could use indexOf.

A smart js engine should implement a fast bailout in it's own replace call if it makes sense.
 We're seeing some bad perf numbers on some internal tests. Will investigate why. We probably need this anyway for correctness.

Do you have any ideas of a completely different way to solve this issue? Even if it's prohibitively difficult to implement. I just want to know we have somewhere to go if we need that perf back.
 I'm suspecting that it causes deopt somewhere in our test because it's the later subsequent updates that are slower. The caching on a component is a neat idea.

Ideally I'd want to get to a point where we don't use long IDs in the markup. It could be counter-based UIDs or we'd just use the index within the parent as an identifier. However, that doesn't solve the issue of the concatenated key itself without the parent ID.

I think that we could solve that by doing updates through traverse children instead of flattening. We're moving towards that model anyway. We should be able to traverse both the previous fragments and the new fragments at the same time and determine if the keys are equal on the spot, instead of generating a string ID for comparison.
 You know what... We're just going to pull this in as is. I don't trust the consistency of that test. We have two other options to go to if we ever need alternatives.
  I think this is good to pull in, but next time adding a unit test would be nice :)
  @sebmarkbage might have some thoughts on this
 @benjamn wanted to add this a while back. I thought the use cases where this would help is very rare. You usually apply refs on static components that you know will be there, where as keys solve the problem of dynamic components in a runtime set.

They also have different semantic meaning. Keys only have to be unique in a fragment set but refs have to be unique within the whole owner component.

In the end I don't think it's worth overloading the two concepts. It makes it confusing to read the code and easy to mix them up.

I'm curious about your use case though. What's your scenario where you are using refs and also have a need for keys on the same components?
  I think that makes sense. cc @yungsters 
 Let's go with @spicyj's PR. Sorry, but thanks for lighting the fire!
  We are removing the argument in the next big release but it is currently working. However there is a big warning saying not to use it.
  For reference, ng-animate stagger documentation: http://docs.angularjs.org/api/ngAnimate#usage_css-defined-animations_css-staggering-animations
 If you want to send a PR that stays true to the original ng-animate API I could take a look!
 See #756 -- I think the ReactTransitionGroup API is flexible enough now that we don't need to do anything here.
  React theoretically supports mounting into iframes but it's not well tested. Specifically we need some tests around event handling (and maybe some bug fixes).
 Semi-related #3146
  #776 makes it so `keypress` isn't triggered in any browser for special keys.
  So Firefox and Chrome have different behaviors on this example: http://jsfiddle.net/hdGTw/

I wonder if we want to use this all the time to normalize them? If we do we should explicitly blacklist Mobile Safari which has autofocus behavior disabled on purpose (or do we want to "fix" this too like we fixed click events?)

Also, can you show what the post min+gzip size delta is?
 Note: doing .focus() on an &lt;input type="text" /> on android mobile's default browser outside of a click event will do absolutely nothing.
 My vote would be to just naively do .focus() on componentDidMount. It's not going to work on android mobile browser but will on ios. If the author doesn't want it on iOS it can do user agent checks.

I feel like this makes it available in more places which is good :)
 can you also add a test case?
  I don't know if this is silly or I miss something but pressing the enter does not trigger an onChange/onInput on text inputs.
 Sorry. I got it using onKeyDown/onKeyPress.
 Ok. Seems like a theres some inconsistencies here. When I used only onKeyDown/onKeyPress, it captures 'enter' key but does not have event.target.value, while onChange/onInput does not capture enter key but provides the event.target.value. Do I really need to specify onChange and onKeyDown at the same time?
 @sydcanem: could you provide a jsfiddle that let us reproduce what you are seeing? Thanks!
 @vjeux http://jsfiddle.net/sydcanem/RhLNy/1/ using onKeyDown. Does not get the inputted text.
 Submit on enter?
 @spicyj I just did.

@syranide So I just read the `event.target.value` in `onChange` ? But `enter` does not trigger an `onChange`.
 @spicyj That's what I did as of the moment. I was hoping there's some other event I could listen that both handles the situation.

@syranide 'valueLink' is using `onChange` so it does not also handle `enter` keys. I think listening on both is the best solution for now.
 @syranide Got it. So it saves me adding and onChange handler.

@spicyj I get what you mean. But isn't onKeyDown suppose to have the inputted key in the `event.target.value`?
 @syranide I see now. Thanks for helping.
@spicyj Thanks.
  Woops, didn't see it. Closed in favor of https://github.com/facebook/react/pull/698
  @luigy hey there, if you can sign our CLA we can merge this right in. thanks! https://developers.facebook.com/opensource/cla
 @luigy: I know it sucks that you have to sign the CLA but we cannot pull it in unless you do. I can also pull it on my own name if you don't want to sign it. Please let me know what works best for you :)
 Thanks @luigy!
 Woops my bad, I'm new to the process and mis-read the tool :(
  @colingourlay I can't reproduce in IE9 on your site. You're still seeing the problem?
  And you already signed the CLA. Awesome :)

Let's get the comment in there and then this is good to go. If you want, feel free to amend the current commit and `push -f`, then the pull request will be updated automatically without multiple commits.
 Thanks a lot Logan! I'm going to be out for most of the next 2 weeks, but if you want to pick up some more issues, we'd appreciate the help :) You might be able to get some more immediate assistance in the IRC channel (#reactjs on freenode).
  @gfdev et al: If statements can not be implemented as a react component for reasons: https://github.com/AlexGilleran/jsx-control-statements/wiki/Why-Transform

Alex has done a great job maintaining a transform that implements various control statements:
https://www.npmjs.com/package/jsx-control-statements
 @ajwhite This suffers from the same problems I just mentioned one post prior.  This can't be solved without at transform, as per https://github.com/AlexGilleran/jsx-control-statements/wiki/Why-Transform

Which is why you need something like https://www.npmjs.com/package/jsx-control-statements
 @milesj That is a LOT of syntax for an `if` statement.  Also, it means your nodes are no longer in the same place (you have to scroll to a different file, or at least a different part of the file) to see what is going to get rendered there if the condition is true.  Also, stateless components can't return a list.  Bottom line: no, it doesn't solve it.
  :thumbsup: Could you sign the CLA? https://developers.facebook.com/opensource/cla

Also, could you sort the properties? `polygon` before `polyline` :)
 I'll do this
  ``` js
var React = require('react/addons');
React.renderComponentToString(React.DOM.div(null, 'hello'), function(content) {
  console.log(content);
});
// <div data-reactid=".r[1uxvw]" data-react-checksum="781127269">hello</div>
```

This works and outputs what I would expect. The export of `react/addons` (and `react` for that matter) is a function for now to enable deprecation warnings for the old `react` package, but the function also has properties set on it that would have been on the React object.

Do you have any more details that might help us track this down? node version, etc.
 Ah, that's an interesting idea that I hadn't thought about. I guess we should make that clearer. We may be able to start killing the addons build.... we'll see :)
  cc @benjamn @yungsters 
  Right now our minified build just uses browserify on the original package + uglify. As a result, there are still `require` calls, which breaks browserify if you then wanted to bundle your own application. We talked about "muffinizing" in #627 (where we would replace all the require calls with a random word), but with envify + browserify, we've worked around that.

Underscore doesn't have that problem as it's all 1 file to begin with with no modules.
 FWIW, just browserifying+minifying react is not quite the same as react.min.js. react.min.js strips out extra logging and error messages. Since we use envify, you'll want to make sure `process.env.NODE_ENV === 'production'` (haven't looked at how that works with `browserify` on it's own, probably just `NODE_ENV=production browserify ...`
 Setting NODE_ENV to production should improve runtime perf too. 

I would prefer to not check in minified code. Let's instead make sure that we can minify with existing tools in a performant way. Sound good?
 To clarify what @petehunt meant, it would improve runtime perf of _React_, not the browserification runtime.

Glad we could help @porterjamesj!
  cc @jeffmo who can help with transform-related code.

Personally, I think we might want to be a bit less naive and forward look to see if we're at the end of a line.

Take this for example:

``` js
<div id="foo">
  Hello
  <span>{this.props.name}</span>
</div>
```

It gets transformed to this before your change:

``` js
React.DOM.div( {id:"foo"}, 
  " Hello ",
  React.DOM.span(null, this.props.name)
)
```

There is a trailing space on line 2 but there‚Äôs also a space after `null,`

With your change we blindly lose that space for inline children, which will probably make somebody else‚Äôs linter complain. If we‚Äôre going to change this at all, I think we should do it completely.
 @STRML, are you still interested in doing this?
 (Nvm, ignore this, not fixed).
 Closing this out in favor of #970. @syranide correct me if that wasn't right!
 @STRML updated the pull request.
  I think we could have a much easier starter kit. I think this is pretty good for apps: https://github.com/petehunt/react-browserify-template

And this for modular components (no browserify, just prebuild step): https://github.com/petehunt/react-boilerplate
 I created a yeoman generator that implements these:

`npm install -g yeoman generator-react-quickstart`

`yo react-quickstart`

`yo react-quickstart --library`

I think that this would be pretty great to make our default just because it's so powerful and easy.
  Can we break out the following into separate npm modules and ditch the addons build? We could use wzrd.in to deliver them.
- ReactTransitionGroup
- classSet
- ReactLink
- TapEventPlugin
- ResponderEventPlugin
- ReactStateSetters
- ReactTestUtils
 like-stamp
 I think this should get high priority since it'll let us expose ReactTestUtils publicly so we can write a doc on testing.
 OK, I just realized that these are already being delivered as part of the `react` npm package -- going to send a simple PR soon.
 shipit
 Addons are being shipped via npm now.
 We haven't dropped the addons build entirely yet though so going to keep this open until we do.
  I think we need a tutorials section. It should have:
- Getting started (current tutorial)
- Thinking in React blog post
- Using server rendering
- Performance optimization walkthrough

I'll write all of these (well we only need two) unless someone else wants to.
 Great idea. We may want to expand and have tutorials for a few more common setups (eg, express + jsx + backbone + mongodb), but we can always add more later. The tips section is great but isn't always hand-holdy enough for people getting started.
 In #1089, @petehunt also lists these as good to have:
- Routing
- Model objects
- Integration with a jQuery plugin (sortable?)
  thanks!
  We've been talking about this for a while, but haven't quite figured out the best way to do it. We have a new module that will be published to npm this week which will hopefully make things easier. Dependencies across AMD, require.js, node is tricky, but the hardest part has been establishing a sane way to package static assets without collisions (really, we need CSS namespacing). Honestly I don't think bower works well for that. Component might work better. @petehunt and others on the team have lots of opinions here :)

Stay tuned! And if you're interested in helping out, come hang out on IRC
 It's like you're reading our minds! We want this. This is probably the most important feature of React - shareability. So we want a standard that works well in most cases, with most tools, and allows total encapsulation of all resources (like Paul said) into a single module.

For style, Hedger built a style generating tool that intends to work perfectly inside of any commonJS module (https://github.com/hedgerwang/react-styles). That means you can package up all your component's style, and source code, completely in JS, and push it to npm as one unit. For react-style, you don't even need bower/component.io (you'd only need browserify or (github.com/facebook/react-page)), but it should be perfectly compatible with bower/component.io.

For CSS/Less/etc, it's not quite as easy, but the thing I like about Hedger's react-style is that it should work everywhere right now. Someone should use it (or another style generator that works everywhere [browserify/react-page/bower]) in order to upload The Worlds Simplest Example Component.

The main challenge remaining is how to include/package images which @petehunt has great ideas/demos there.

For now, if we tried using react-styles, we can just base64 encode the image data which _obviously_ sucks, but we should still try it just to have a _completely modular React component that Just Works everywhere_ - there is incredible value in that.

We don't have a fully complete answer to this, though we're trying many things. Please let us know what you find that works well, and if you think react-style would be a good direction for some people. (Forgive the temporary requirement that you must base64 image data, we're working on it).
 @willdady no consensus yet. I like RCSS and I think I can make it closer to being an acceptable solution for the general population. Still waiting for @petehunt to open source his webpack stuff.
  Hey @squidsoup, could you sign the CLA? Then we can get this in! https://developers.facebook.com/opensource/cla
  Thanks! Definitely looks like a reasonable fix. Can you fix the failing test and also add another making sure we do this right?
 Let's do that separately, will make it easier if we ever go back and do retroactive perf analysis.
 Actually, I take that back. Let's just do it here.
 Thanks!
  This reduces the time taken by `grunt populist:test` from 7s to 550ms, which should make @spicyj especially happy.

Relevant commits from the `populist` and `ast-types` repositories:
https://github.com/benjamn/populist/commit/9863ad16c0753f714fdb83007515637511c346d6
https://github.com/benjamn/ast-types/commit/dabef2a4ac48ebdb5c76baf1fb94f4997b6484ac
 Yeah, it's really too bad `Function.prototype.fast` didn't make it into ES6.
  Let us know if the documentation or error messages could be clearer.
 @sompylasar Good idea, reopening so we remember to add info about this.
 Closing this in favor of a new issue.
  ReactTransitionableChild sets up listeners to detect when animations/transitions are complete so it knows when to remove the transition classes (and DOM elements for a "leave" transition). These listeners get confused when more than one element in the transitionable child tree performs an animation/transition. For example:

```
<div className="outer">
  <div className="inner" />
</div>
```

Say the desired effect is for the outer div to fade in first, followed by the inner div. This is possible with two CSS transitions with the appropriate durations and delays.

React gets confused when this element is removed in the middle of the inner transition (in fact, I think removing the element before the outer transition finishes can also confuse React). Generally, listening to bubbled transition events violates encapsulation in some cases.
 #1301 should have fixed this.
  Hey @nicholasbs, can you sign the CLA at https://developers.facebook.com/opensource/cla? Let me know when you have and we can get this in!
 Thanks for the contribution!
  _very_ useful tool!
 If you want to take the markup converter to the extreme, you could make it so that when you select markup in any page (or Chrome inspector tools), not only can you create a React component out of the markup, but it also captures the set of css rules needed to render it in its exact form, and generates an accompanying style sheet! @sebmarkbage can help you out there as he's gained quite a lot of knowledge of the Chrome inspector and Chrome plugins.
 @Daniel15 That sounds likely. I remember there was already a plugin that helped you do something like that in the Chrome store - not sure if it's open source, but if it were, it would not be hard to fork it to simply run the output through your markup transforming code (and boiler plate generator). I imagine that would be quite an impressive demo.
 This one is open source and should integrate nicely into our React developer tools!
https://github.com/kdzwinel/SnappySnippet
 I am inclined to merge this. @zpao do you have any reservations?
 We should merge to master and cherry-pick to stable branch, otherwise we'll lose this next time we cut a branch. No idea if it's possible to edit a PR, so we can either keep this and pull in the commit manually or you can close this PR and open a new one.
 We normally land on master and merge into the stable branch (0.5-stable right this second but very shortly not). With the 0.8 branch existing now, that's what the next docs will be cut from. We could cherry-pick either way though, just makes it's a bit easier to not push it an effectively done branch.
  Can you confirm master is fixed @Daniel15?
  What's the use case you're looking to support here? In general if people are running into this they're probably using mixins where they should use composition instead
 The problem with that is if the impl of the mixin changes, the public interface of the components that use it may change too.

Instead, what if instead of reading from the prop directly, you called `this.getModelManager()`. Then the users of the mixin could provide an impl of this method that does `return this.props.manager`.
 Sometimes they need `state`, but in general I'd say they should stay away from props.
  If you're getting the warning about keys, take a look at http://facebook.github.io/react/docs/multiple-components.html#dynamic-children

That sort of thing shouldn't result in exceptions. There's not necessarily a problem, but the warning is there to help you since that's a common cause of issues.

Other invariants should be throwing exceptions with stack traces (even if they sometimes suck, like @jaredly's case)
 The problem @npryce is describing is that the warning has no context. With JSX we'd include the `displayName` of the component since we can figure it out with a syntax transform, but if you aren't using JSX this error is pretty cryptic since there's no hint as to which component had the issue.
 @sebmarkbage any ideas for supporting this use case?
 If you add a breakpoint where the warning gets issued you should be able to break and inspect the current stack there. That should lead you back to where your parent was constructed, and you can inspect the data structure at that call frame.

We could add a debugger call there to automatically break for you. Might be a little intrusive. Perhaps that should be an opt-in feature?
 @steida can you specify what's broken?
 Yeah, that's the intended behavior. See [here](http://facebook.github.io/react/docs/multiple-components.html#dynamic-children).
The thing is that the array format is often used in this situation:

```
// in `render`
var items = this.props.items.map(function(item) {return <li>{item}</li>});
return <ul>{items}</ul>;
```

where you often want to pass a `key` to persist `li` across renders.
 It's a heuristic. The typical use case for variable number of arguments is that you always provide the same set with the same number of items. E.g.

``` javascript
return React.DOM.div({}, Foo(), this.state.x ? Bar() : Baz());
```

That doesn't need keys because there will typically be two slots for children and it's predictable where update occur. The keys are inferred.

However, if you're providing a dynamic data set which grows/shrinks. E.g. based on data, then there's no way for React determine how to do updates without keys. It is never legitimate to provide a dynamic set without keys (even if they're always in order):

``` javascript
var list = this.props.data.map(item => item.x ? Foo({ item }) : Bar());
return React.DOM.div({}, list);
```

Instead of waiting for a race condition to screw you over, we issue this warning based on a heuristic. Dynamically we can't tell a dynamic array from a static set that is always the same one.

``` javascript
return React.DOM.div({}, [Foo(), this.state.x ? Bar() : Baz()]); // static or not?
```

It's never legitimate to ignore the warning. You should always provide keys by default. The heuristic is only a helpful way to avoid keys in a common case when we can fairly safely infer it.

``` javascript
var list = [Foo({ key: '0' }), this.state.x ? Bar({ key: '1' }) : Baz({ key: '1'})];
return React.DOM.div({}, list);
```

There is also a convenient way to provide keys based on property names of an object:

``` javascript
var a = Foo();
var b = this.state.x ? Bar() : Baz();
return React.DOM.div({}, { a, b });
```
 Note that even if your dynamic set is always in order, you should still provide the index as the key:

``` javascript
var list = this.props.data.map((item, idx) => Foo({ item: item, key: idx }));
return React.DOM.div({}, list);
```

That explicitly declares that you're fine with the interpretation that state gets preserved based on the order of the list rather than some persistent identity of the item. That keeps you safe if the heuristic would ever need to change. It almost communicates that you've considered the problem of tracking changes in a set.
 Scratch what I said! I meant legit as in "it works".
 I think the key (no pun intended) to debugging warnings is to highlight them in the React Developer Tools. We could add that feature. That way you have enough context to backtrack to the component that ultimately caused the problem. Unfortunately, if you're lacking the displayName property, you'll likely have less context in the React Developer Tools too.

I'd highly recommend manually adding displayName to your components, if you don't use JSX, to help with debugging.
 I don‚Äôt think there is anything actionable in this issue so I‚Äôm closing. If there are specific warnings that are confusing or miss the important information and context, please file an issue with instructions to reproduce. Then we can tag them as ‚Äúgood first bug‚Äù and receive community contributions for those. Cheers!
  Upstream pull request was accepted! https://github.com/hughsk/envify/pull/4
 This needs to go through the same browserify transform that's provided in the `package.json` of the `react` npm module. If we don't then I fear we're going to screw something up when people try to use `envify`.

So if we want to do this we should either release an alternative to `envify` that we can refer to in the `package.json` or try to get a PR accepted on `envify`.
 Submitted a PR to `envify`: https://github.com/hughsk/envify/pull/4
 I think this PR needs to be rebased or something -- has a lot of extra stuff in it. Once you do let's do this!
  See this jsfiddle that illustrates the problem:

http://jsfiddle.net/3ma7a/1/

The reason is because our event handler is attached to the document and we just pass event.currentTarget instead of properly finding the right one.
  #659 
  cc @petehunt 
 How is jam different from bower?
 Meh.
  Facebook's Open Graph integration uses the non-standard `property` attribute. However it is currently stripped out.

``` html
<meta property="og:type" content="website" />
```

Suggested plan of action: add it in the non-standard list

https://github.com/facebook/react/blob/master/src/dom/DefaultDOMPropertyConfig.js#L114
  `&lt;script>` is a bit hard to use right now.
- If you have a `{...}` then it's going to start interpolating. And you are bound to have whenever you use `if`, `function` ... Workaround: you can wrap it inside of an interpolated string `{'if (true) { ... }'}`
- If you have any `'` or `"` it's going to output the html encoded version and Javascript is going to throw a parsing exception.

In order to workaround those two issues the best way I found is to use dangerouslySetInnerHTML and use ES6 backtick in order to have multi-line strings.

``` javascript
<script dangerouslySetInnerHTML={{__html: `
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('send', 'pageview');
`}} />
```

We should probably make it easier, it's quite a pain to use right now.
 Yeah, i'm not really sure that it is really useful in a normal React app but for react-page it's definitively useful. @zpao  suggested that we change the `<script>` tag to behave like in the DOM. It takes a single string child that is not escaped like we do for spans
 @matthewwithanm Can you say a little more about your use case? I think we'd like to do the least surprising thing here but it's hard to know what that is; my guess is any behavior we have would be surprising in some way.
 @marten `dangerouslySetInnerHTML` is just another name for `innerHTML` exposed by browsers, they do not execute `<script>` when using `innerHTML`. I believe jQuery has code that explicitly goes in and evals code inside `<script>`, if that's what you were expecting.
  If you got rid of all state in your application and just referred to `props` I think your app would still work :)
 @jaredly I agree with you. I think a good test is to look at the names of the props and state. Here's a good example that I believe is not an anti-pattern.

```
var Tester = React.createClass({
  getInitialState: function() {
    return {count: this.props.initialCount};
  },
  handleClick: function() {
    this.setState({
      count: this.state.count + 1
    });
  },
  render: function() {
    return (
      <div onClick={this.handleClick}>
        {this.state.count}
      </div>
    );
  }
});

<Tester initialCount={0}>
<Tester initialCount={10}>
```

The `Tester` component's public API states that it accepts that property `initialCount` in order to initialize its state and makes no guarantees about synchronization from that point forward.

The reason why this is not an anti-pattern, is because there is no "denormalization" of information (http://en.wikipedia.org/wiki/Database_normalization#Normal_forms).

What makes this example different than the caching computations case? It's the admission that the prop value `initialCount` is fundamentally different than `count`. The `initial` prefix clearly indicates that no one expects the data to remain in sync, and therefore isn't considered redundant.

If you were to rename the prop `initialCount` to `count` to match `this.state.count`, then most would expect the two to remain in sync, and therefore represents a piece of information that is redundant/denormalized.
 @jaredly But I do believe that what @petehunt and I have most commonly observed is that people do not use initial props in this valid way - they tend to try to use it in order to "cache computations on props". It would be cool to think of a clear way to explain to a new user what is and isn't an anti-pattern.
 +1 for that tip

@chenglou

As far as this PR goes, maybe we should talk about data normalization rather than caching?
 Ahhh, forgot to ask you to sign our CLA...I thought you were already a contributor! Would you mind signing this? https://developers.facebook.com/opensource/cla
 Thanks!
  Thanks! Could you sign the CLA? https://developers.facebook.com/opensource/cla
 So you are :) There are so many of us these days! No need to sign, I can merge it in as is (and it'll be published next time I build the docs, which will happen before the end of the week).
  cc @benjamn @sebmarkbage @jordwalke - we should definitely do something nicer than this.
   Wasn't it deprecated for HTML5?

On Mon, Dec 9, 2013 at 9:40 AM, Christopher Chedeau <
notifications@github.com> wrote:

> ‚Äî
> Reply to this email directly or view it on GitHubhttps://github.com/facebook/react/issues/645
> .
 Correction: already deprecated in HTML4!

http://www.w3.org/wiki/HTML/Elements/center

On Mon, Dec 9, 2013 at 9:43 AM, Sander Spies sandermail@gmail.com wrote:

> Wasn't it deprecated for HTML5?
> 
> On Mon, Dec 9, 2013 at 9:40 AM, Christopher Chedeau <
> notifications@github.com> wrote:
> 
> > ‚Äî
> > Reply to this email directly or view it on GitHubhttps://github.com/facebook/react/issues/645
> > .
 I'm converting a website that uses it :)

But it is easy to workaround:

```
var center = React.createClass({
  render: function() {
    return this.transferPropsTo(
      <span style={{textAlign: 'center'}}>{this.props.children}</span>
    );
  }
});
```
 This is on purpose because like @SanderSpies said, it was deprecated a long long long time ago. I made a conscious decision in fc5f7e0e85e164f6826cf1ddc3f055f6ee4f93cb to exclude certain things.
  It's been a while since I've had context to this particular problem. Here's a couple of thoughts:
1. We try to strive to make dev and production be functionally equivalent - modulo any difference in the amount of information logged. So it's good that you chose to log a warning instead of an error.
2. With this diff, we allocate twice as many objects upon the initial render (and then use pooled instances going forward) (compared to the number of strings we allocate/return from the mounting process). But we only perform the validation on these new objects in DEV. Couldn't we simply use a regex to test the leading few characters of every markup fragment we insert? This would help us avoid having to pay the cost of all the allocations (or getting pooled instances) in production at all. And even if we feel the regex based check is hacky, it's just something that runs in DEV anyways, so we don't have to feel bad about it.
 @spicyj - I hear you on the "cleaner" part. In fact, I _like_ this much better. But for the web, at least, we'll probably always want the "image" to be either a chunk of markup, or a single DOM node (when node creation becomes faster in all browsers).
 What's the status here? Do we want to pursue this diff?
  Who should review this code?
 I think previous versions of WebKit (and Chrome) returned `document.body`. Internally, we use `getDocumentScrollElement` for other reasons besides querying scroll position (e.g. comparing `scrollParent`), so it's still necessary.

I've tested this on Safari, Firefox, Chrome, and IE 8+. Looks good to me, thanks for investigating and fixing.
  cc @petehunt 
 This lgtm, need to do some stuff then I can merge it!
  Who should review this?
  ## But we're at 0.5 right now‚Ä¶

We've been working with @jeffbski and he has graciously allowed us to take over the `react` package on npm. However, that's currently versioned at 0.7.x, so in order for this to work in a reasonable way, we're going to jump to 0.8. This allows users of the current `react` package to continue working. So long as they have reasonable specs in their package.json (`~0.7.1`) then they won't break. In our package we will issue a warning pointing at the new package if you use react as a function (which is the typical use of @jeffbski's package). We'll leave 0.7.x on npm as well.
## Where to cut?

Typically we've cut from the latest stable commit in master. However we don't feel like master is stable enough right now to cut a release we will support, so we're going to go farther back. We have a couple options:
- Some have suggested we just take 0.5 and rebrand it, then pull in a couple other commits for small bugfixes. This is the easy way.
- Pick a commit more recent than 0.5 as the base and cherry-pick some other changes in. There are a lot of good fixes in there that would make this a bit painful but probably has the best result for consumers.
## What about `react-tools`?

Nothing will change here. Except it will probably use the `react` package directly instead.
## How does this affect future releases?

Right now it doesn't. But while we're screwing around with version numbers this gives us a chance to try something new (for us). Currently we follow the typical pattern of "every release is stable", but the result of that is that we sit on things for a while before they're usable. Master is generally usable but there are no checkpoints, just latest.

While it would be great to move towards a time-based release schedule, I'm not sure it makes sense for us that this point. We're still changing APIs pretty frequently and don't have a good pattern for backing out features.

I'd like to move towards the pattern that Node.js uses (and the Linux kernel used to use) where even minor releases are stable and odd are for development. We would publish these releases just like we would our stable ones but make sure they aren't installed with a plain `npm install react` (e.g. if we do `npm publish --tag 0.9.0` that wouldn't be installed unless you do `npm install react@0.9`). We could publish the unstable releases on a regular schedule (once per week) and then publish stable release when they're ready.

Or we can take advantage of the same tagging feature in npm and just use semver pre-release versioning (e.g. 0.9.0-alpha.2013-12-05). Regardless, it's not immediately important but I'm thinking about it.

---

Let's collect thoughts here and then get a list of commits we need to cherry-pick once we figure out the exact plan.
 Yea, we've accepted that lowercase is the only real option here. npm actually even prohibits capitalized package names. That might force us to eventually change internally, but it at least makes it a relatively painless transition.
 Ok, so part of the decision was made. We're going to base 0.8 on 0.5-stable. We're not going to take any API changes, but we'll take bugfixes from master. This makes things way easier and also let's people switch to 0.8 without worrying about breaking changes. This also means we need to do what we did for #439 and list out commits that will need to be cherry-picked/backported and excluded.

Building and testing is going to lack the coverage we have on master, but that's fine. With any luck we'll have vNext cut soon (it's unlikely anything will happen there before 2014).

Please add commits/PRs that you think should be in 0.8 and I'll update the description of this issue with the updated state.
 @spicyj suggested a spreadsheet... here's all the changes in master that should be considered: https://docs.google.com/spreadsheet/ccc?key=0AmorHpAY7s4edEZWQmRXVnU3Y3NZUjlOWTY0MDNVS2c&usp=sharing

Generated with this and imported as a CSV:

```
git log --pretty=format:'%h | %s | https://github.com/facebook/react/commit/%h' --reverse --abbrev-commit --no-merges 48281a1...master src
```

We'll figure out changes outside of `src/` outside of the spreadsheet
 Thanks for all the help! We're all done here :)
  Could you run performance tests on this (especially since the actual use of arguments is out of our control)?
 Yea, that first commit will go away. http://paulshen.github.io/react-bench/ has some benchmarks.

Also, let's turn on the [`esnext`](http://jshint.com/docs/options/#esnext) option for jshint so lint passes
 @jordwalke: This uses arguments under-the-hood anyway, it's mostly just sugar for doing so at this point...
 @jeffmo: I've seen diffs far less concerning than this cause huge performance regressions. This diff touches the single most frequently invoked method in the entire React core (the constructor for all components). No matter how innocuous seeming, I always do a perf test for any diff that touches the critical path.
 Gotcha, fair enough. Question remains about how to do so though, I think?
 (also somewhat surprised that we're using `arguments` in our single most frequently invoked method in the entire React core)
 Believe me the performance of that was well contested when people trusted micro-benchmarks more than real world usage. I'd be very hesitant to mess with that optimization. The next bottleneck is getting the multi-var arguments from the convenience constructor into here. Potentially through another constructor function. Thankfully modern engines will help us there.
 @sebmarkbage: Certain uses of `arguments` are problematic, (not all) but I'm not as much concerned with that here - I'm more concerned about the fact that this is a diff that touches the most critical path. I have no other basis for concern :)
 > it is really just Array.prototype.slice.call(arguments, offsetA, offsetB).

So we create an additional array every time the method is invoked? Regardless of what the benchmarks say, maybe we should hold off on rest args for `ReactComponent`'s constructor. That little function is likely invoked more than any other function in React. Also, a large portion of instances have only one child, and therefore would avoid the array allocation.
 We really need a higher-level metric to shoot for here. Gut-feeling on whether "another allocation" is ok or not is only going to lead to more subjective debate and potential for mis-guided optimization effort. I think perf questions are valid (including here) -- as long as we have a concrete way to answer them. I'm a little worried that we're heading towards a tangential meta-discussion right now.

@cpojer asked earlier what the best way to perf-test this would be -- do we have an answer for this? If not, we're not doing ourselves any favors in speculating here and leaving red-tape around "sensitive" core functions.
 Code looks good -- I'll leave it to @jordwalke to merge in case he has any further concerns
 @cpojer What's the perf results in IE8?

I agree that we don't have enough good tests and tools to do perf testing reliably right now. That means that we're often best suited to use our own intuition atm. That means we shouldn't block on potentially misguided optimization efforts.

However, this code has been through a lot of testing in individual products which have been fine tuned. This was not found to be a bottle neck. Changing this code path may or may not cause a regression in those products. Something we may not discover much later.

IMO, it needs to be a clear win for this refactoring to take the place of the tested code. I.e. a new API surface or clear readability win. IMHO, this is mostly subjective and unnecessary risk.
 If this was new code I wouldn't have a problem with it. Since neither had been tested and we'd just be speculating.

@cpojer that would've been good to have in the initial description. If this is something we imminently need for static analysis. Let's continue that offline.
 We know that this is harmless with equal confidence that we know it's harmful.
We have eyeballs and users and smart engineers that can make changes at any time.
And somehow we're still scared to do something that, for all we know, is a win.

Yay ignorance-induced red tape!
 Perf comparison of this diff to previous master in IE8.
![screen shot 2014-01-06 at 1 06 08 pm](https://f.cloud.github.com/assets/4117/1853559/31a49f48-770e-11e3-906b-821d508f49e8.png)
 IE11 on a Windows Surface Pro 1 running Windows 8.1

![1556311_10151816339281175_448734076_o](https://f.cloud.github.com/assets/4117/1853585/82feeea2-770e-11e3-9423-2cdfdcb1ae17.jpg)
 IE9 running on a crappy Windows 7 Starter Edition netbook.

![886182_10151816336596175_1621545644_o](https://f.cloud.github.com/assets/4117/1853601/a5a1229a-770e-11e3-9da6-a8b4449be498.jpg)
  Nice!
 Awesome.
 Could you throw in the quasi-literals transform if it's not already in here?
 The changes here lgtm. I'll hold off on merging until you guys decide if you want to include quasi-literals.
I'm always in favor of not adding code until you need it...but I guess that's what this is anyway really
 sgtm, but the flag kinda seems unnecessary...just always include the transforms or don't. It's not going to run the es6 visitors unless it sees es6 syntax either way
 +1 for the flag. It's useful but hard to make the argument that JSX is "just function calls" if we add all that.
 If we're going to change the public one, I'm going to shoot down the idea of doing es6 without a flag.

Let's change the public `jsx` separately. We'll also need to do something so commoner knows to bust the cache when the flag changes.
 @spicyj: Wouldn't your linter yell at them (probably by blowing up)? What about people using ES6 syntax when it starts shipping in browsers?
 I'm not strictly opposed to a flag I guess -- but I would just make it opt-out rather than opt-in I guess. ES6 is just javascript. If you have a tooling need to skip over it, that seems legit. But I'd venture to guess that in most cases it either doesn't hurt or only helps to leave it on.

"should/shouldn't" use classes (or any particular feature of javascript) is also a valid concern -- but I just think it's a style concern that doesn't belong in the transformer.

Anyway -- life will probably go on either way. If we do opt-in, I'll probably just grumble about how we've decided that some javascript isn't actually "javascript" and bring it up every so often as a non-sequiter fallacy of some kind :p
  ```
$ grunt --verbose --debug 9 --stack test:webdriver:saucelabs:ios
```

```
Running "webdriver-jasmine:saucelabs_ios6_1" (webdriver-jasmine) task
[D] Task source: /Users/aylott/Projects/Facebook/react/Gruntfile.js
Verifying property webdriver-jasmine.saucelabs_ios6_1 exists in config...OK
File: [no files]
desiredCapabilities {"browserName":"iphone","version":"6.1","platform":"OS X 10.8","build":"dev1386189377095","tunnel-identifier":"my awesome tunnel"}

Driving the web on session: dc8ba24ae6904c33a6e1e25c99bff55c

Starting WebDriver Test. Watch results here: http://saucelabs.com/tests/dc8ba24ae6904c33a6e1e25c99bff55c
 > POST /session/:sessionID/url { url: 'http://127.0.0.1:9999/test/index.html?debug=9' }
[D] 2013-12-04 15:37:48,822 - Request started: GET http://127.0.0.1:9999/test/index.html?debug=9
[D] server GET /test/index.html?debug=9 200 1163 - 4 ms
[Mozilla/5.0 (iPhone; CPU iPhone OS 6_1 like Mac OS X) AppleWebKit/536.26 (KHTML, like Gecko) Mobile/10B141][1386189468842] GET /test/index.html?debug=9
[D] 2013-12-04 15:37:48,857 - GET http://127.0.0.1:9999/test/index.html?debug=9 -> 200 (34ms, 1163 bytes)
[D] 2013-12-04 15:37:49,206 - Request started: GET http://127.0.0.1:9999/vendor/jasmine/jasmine.js?_=hot1f2dm
[D] 2013-12-04 15:37:49,207 - Request started: GET http://127.0.0.1:9999/vendor/jasmine/jasmine-support.js?_=hot1f2dm
[D] server GET /vendor/jasmine/jasmine-support.js?_=hot1f2dm 200 4094 - 2 ms
[Mozilla/5.0 (iPhone; CPU iPhone OS 6_1 like Mac OS X) AppleWebKit/536.26 (KHTML, like Gecko) Mobile/10B141][1386189469213] GET /vendor/jasmine/jasmine-support.js?_=hot1f2dm
[D] 2013-12-04 15:37:49,211 - Request started: GET http://127.0.0.1:9999/node_modules/jasmine-tapreporter/src/tapreporter.js?_=hot1f2dm2013-12-04 15:37:49,211 - Request started: GET http://127.0.0.1:9999/vendor/jasmine-jsreporter/jasmine-jsreporter.js?_=hot1f2dm
[D] server GET /vendor/jasmine/jasmine.js?_=hot1f2dm 200 70892 - 4 ms
[Mozilla/5.0 (iPhone; CPU iPhone OS 6_1 like Mac OS X) AppleWebKit/536.26 (KHTML, like Gecko) Mobile/10B141][1386189469214] GET /vendor/jasmine/jasmine.js?_=hot1f2dm
[D] 2013-12-04 15:37:49,213 - GET http://127.0.0.1:9999/vendor/jasmine/jasmine-support.js?_=hot1f2dm -> 200 (7ms, 4094 bytes)
[D] server GET /node_modules/jasmine-tapreporter/src/tapreporter.js?_=hot1f2dm 200 7616 - 2 ms
[Mozilla/5.0 (iPhone; CPU iPhone OS 6_1 like Mac OS X) AppleWebKit/536.26 (KHTML, like Gecko) Mobile/10B141][1386189469218] GET /node_modules/jasmine-tapreporter/src/tapreporter.js?_=hot1f2dm
[D] 2013-12-04 15:37:49,217 - GET http://127.0.0.1:9999/vendor/jasmine/jasmine.js?_=hot1f2dm -> 200 (10ms, 70892 bytes)
[D] server GET /vendor/jasmine-jsreporter/jasmine-jsreporter.js?_=hot1f2dm 200 6614 - 2 ms
[Mozilla/5.0 (iPhone; CPU iPhone OS 6_1 like Mac OS X) AppleWebKit/536.26 (KHTML, like Gecko) Mobile/10B141][1386189469219] GET /vendor/jasmine-jsreporter/jasmine-jsreporter.js?_=hot1f2dm
[D] 2013-12-04 15:37:49,219 - GET http://127.0.0.1:9999/node_modules/jasmine-tapreporter/src/tapreporter.js?_=hot1f2dm -> 200 (7ms, 7616 bytes)
[D] 2013-12-04 15:37:49,220 - GET http://127.0.0.1:9999/vendor/jasmine-jsreporter/jasmine-jsreporter.js?_=hot1f2dm -> 200 (8ms, 6614 bytes)
[D] 2013-12-04 15:37:49,246 - Request started: GET http://127.0.0.1:9999/vendor/jasmine/jasmine-html.js?_=hot1f2dm
[D] 2013-12-04 15:37:49,246 - Request started: GET http://127.0.0.1:9999/test/lib/reportTestResults.browser.js?_=hot1f2dm
[D] server GET /vendor/jasmine/jasmine-html.js?_=hot1f2dm 200 20765 - 2 ms
[Mozilla/5.0 (iPhone; CPU iPhone OS 6_1 like Mac OS X) AppleWebKit/536.26 (KHTML, like Gecko) Mobile/10B141][1386189469252] GET /vendor/jasmine/jasmine-html.js?_=hot1f2dm
[D] server GET /test/lib/reportTestResults.browser.js?_=hot1f2dm 200 2389 - 1 ms
[Mozilla/5.0 (iPhone; CPU iPhone OS 6_1 like Mac OS X) AppleWebKit/536.26 (KHTML, like Gecko) Mobile/10B141][1386189469252] GET /test/lib/reportTestResults.browser.js?_=hot1f2dm
[D] 2013-12-04 15:37:49,253 - GET http://127.0.0.1:9999/vendor/jasmine/jasmine-html.js?_=hot1f2dm -> 200 (5ms, 20765 bytes)
[D] 2013-12-04 15:37:49,253 - GET http://127.0.0.1:9999/test/lib/reportTestResults.browser.js?_=hot1f2dm -> 200 (6ms, 2389 bytes)
[D] 2013-12-04 15:37:50,362 - Request started: GET http://127.0.0.1:9999/build/react-test.js?_=hot1f2dm
[D] server GET /build/react-test.js?_=hot1f2dm 200 1028528 - 22 ms
[Mozilla/5.0 (iPhone; CPU iPhone OS 6_1 like Mac OS X) AppleWebKit/536.26 (KHTML, like Gecko) Mobile/10B141][1386189470387] GET /build/react-test.js?_=hot1f2dm
[D] 2013-12-04 15:37:50,391 - GET http://127.0.0.1:9999/build/react-test.js?_=hot1f2dm -> 200 (28ms, 1028528 bytes)
[D] 2013-12-04 15:37:51,852 - Request started: GET http://127.0.0.1:9999/build/react.js?_=hot1f2dm
[D] server GET /build/react.js?_=hot1f2dm 200 463169 - 6 ms
[Mozilla/5.0 (iPhone; CPU iPhone OS 6_1 like Mac OS X) AppleWebKit/536.26 (KHTML, like Gecko) Mobile/10B141][1386189471861] GET /build/react.js?_=hot1f2dm
[D] 2013-12-04 15:37:51,865 - GET http://127.0.0.1:9999/build/react.js?_=hot1f2dm -> 200 (13ms, 463169 bytes)
[D] 2013-12-04 15:37:52,114 - Request started: GET http://127.0.0.1:9999/test/lib/jasmine-execute.js?_=hot1f2dm
[D] server GET /test/lib/jasmine-execute.js?_=hot1f2dm 200 587 - 2 ms
[Mozilla/5.0 (iPhone; CPU iPhone OS 6_1 like Mac OS X) AppleWebKit/536.26 (KHTML, like Gecko) Mobile/10B141][1386189472120] GET /test/lib/jasmine-execute.js?_=hot1f2dm
[D] 2013-12-04 15:37:52,121 - GET http://127.0.0.1:9999/test/lib/jasmine-execute.js?_=hot1f2dm -> 200 (7ms, 587 bytes)
[D] 2013-12-04 15:37:52,773 - Request started: GET http://127.0.0.1:9999/test/the-files-to-test.generated.js?_=hot1f2dm
[D] server GET /test/the-files-to-test.generated.js?_=hot1f2dm 200 3961 - 3 ms
[Mozilla/5.0 (iPhone; CPU iPhone OS 6_1 like Mac OS X) AppleWebKit/536.26 (KHTML, like Gecko) Mobile/10B141][1386189472779] GET /test/the-files-to-test.generated.js?_=hot1f2dm
[D] 2013-12-04 15:37:52,779 - GET http://127.0.0.1:9999/test/the-files-to-test.generated.js?_=hot1f2dm -> 200 (6ms, 3961 bytes)
[D] 2013-12-04 15:38:08,339 - Request started: GET http://127.0.0.1:9999/vendor/jasmine/jasmine.css?_=hot1fh71
[D] server GET /vendor/jasmine/jasmine.css?_=hot1fh71 200 6537 - 3 ms
[Mozilla/5.0 (iPhone; CPU iPhone OS 6_1 like Mac OS X) AppleWebKit/536.26 (KHTML, like Gecko) Mobile/10B141][1386189488345] GET /vendor/jasmine/jasmine.css?_=hot1fh71
[D] 2013-12-04 15:38:08,345 - GET http://127.0.0.1:9999/vendor/jasmine/jasmine.css?_=hot1fh71 -> 200 (6ms, 6537 bytes)
[D] 2013-12-04 15:38:08,687 - Request started: POST http://127.0.0.1:9999/reportTestResults
[D] server POST /reportTestResults 200 - - 2 ms
>> [Mozilla/5.0 (iPhone; CPU iPhone OS 6_1 like Mac OS X) AppleWebKit/536.26 (KHTML, like Gecko) Mobile/10B141][1386189488693] ok 1 - addons/link/__tests__/LinkedStateMixin-test LinkedStateMixin should create a ReactLink for state.
[D] 2013-12-04 15:38:08,694 - POST http://127.0.0.1:9999/reportTestResults -> 200 (6ms, 50 bytes)
[D] 2013-12-04 15:38:08,717 - Request started: POST http://127.0.0.1:9999/reportTestResults
[D] server POST /reportTestResults 200 - - - ms
>> [Mozilla/5.0 (iPhone; CPU iPhone OS 6_1 like Mac OS X) AppleWebKit/536.26 (KHTML, like Gecko) Mobile/10B141][1386189488721] ok 2 - addons/transitions/__tests__/ReactTransitionGroup-test ReactTransitionGroup should warn after time with no transitionend.
[D] 2013-12-04 15:38:08,721 - POST http://127.0.0.1:9999/reportTestResults -> 200 (4ms, 50 bytes)
[D] 2013-12-04 15:38:08,773 - Request started: POST http://127.0.0.1:9999/reportTestResults
[D] 2013-12-04 15:38:08,773 - Request started: POST http://127.0.0.1:9999/reportTestResults
[D] server POST /reportTestResults 200 - - - ms
>> [Mozilla/5.0 (iPhone; CPU iPhone OS 6_1 like Mac OS X) AppleWebKit/536.26 (KHTML, like Gecko) Mobile/10B141][1386189488776] ok 3 - addons/transitions/__tests__/ReactTransitionGroup-test ReactTransitionGroup should keep both sets of DOM nodes around.
[D] server POST /reportTestResults 200 - - - ms
>> [Mozilla/5.0 (iPhone; CPU iPhone OS 6_1 like Mac OS X) AppleWebKit/536.26 (KHTML, like Gecko) Mobile/10B141][1386189488777] ok 4 - addons/transitions/__tests__/ReactTransitionGroup-test ReactTransitionGroup with an undefined child should fail silently.
[D] 2013-12-04 15:38:08,776 - POST http://127.0.0.1:9999/reportTestResults -> 200 (4ms, 50 bytes)
[D] 2013-12-04 15:38:08,776 - POST http://127.0.0.1:9999/reportTestResults -> 200 (5ms, 50 bytes)
[D] 2013-12-04 15:38:08,816 - Request started: POST http://127.0.0.1:9999/reportTestResults
[D] 2013-12-04 15:38:08,816 - Request started: POST http://127.0.0.1:9999/reportTestResults
[D] server POST /reportTestResults 200 - - 1 ms
>> [Mozilla/5.0 (iPhone; CPU iPhone OS 6_1 like Mac OS X) AppleWebKit/536.26 (KHTML, like Gecko) Mobile/10B141][1386189488820] ok 6 - addons/transitions/__tests__/ReactTransitionKeySet-test ReactTransitionKeySet should support getKeySet.
[D] server POST /reportTestResults 200 - - - ms
>> [Mozilla/5.0 (iPhone; CPU iPhone OS 6_1 like Mac OS X) AppleWebKit/536.26 (KHTML, like Gecko) Mobile/10B141][1386189488820] ok 5 - addons/transitions/__tests__/ReactTransitionKeySet-test ReactTransitionKeySet should support getChildMapping.
[D] 2013-12-04 15:38:08,819 - POST http://127.0.0.1:9999/reportTestResults -> 200 (3ms, 50 bytes)
[D] 2013-12-04 15:38:08,821 - POST http://127.0.0.1:9999/reportTestResults -> 200 (3ms, 50 bytes)
waitForJsCondition has been deprecated, use waitFor + jsCondition asserter instead.
 > POST /session/:sessionID/execute { script: 'var args = Array.prototype.slice.call(arguments, 0);\nvar code = args[0], fargs = args[1];\n\nvar wrap = function() {\n  return eval(code);\n};\n\nreturn wrap.apply(this, fargs);\n',
  args: [ 'typeof window.jasmine != \'undefined\'', [] ] }
[D] 2013-12-04 15:38:08,950 - Request started: POST http://127.0.0.1:9999/reportTestResults
[D] server POST /reportTestResults 200 - - - ms
>> [Mozilla/5.0 (iPhone; CPU iPhone OS 6_1 like Mac OS X) AppleWebKit/536.26 (KHTML, like Gecko) Mobile/10B141][1386189488955] ok 7 - addons/transitions/__tests__/ReactTransitionKeySet-test ReactTransitionKeySet should support mergeKeySets for adding keys.
[D] 2013-12-04 15:38:08,954 - POST http://127.0.0.1:9999/reportTestResults -> 200 (4ms, 50 bytes)
[D] 2013-12-04 15:38:08,967 - Request started: POST http://127.0.0.1:9999/reportTestResults
[D] server POST /reportTestResults 200 - - 1 ms
>> [Mozilla/5.0 (iPhone; CPU iPhone OS 6_1 like Mac OS X) AppleWebKit/536.26 (KHTML, like Gecko) Mobile/10B141][1386189488972] ok 8 - addons/transitions/__tests__/ReactTransitionKeySet-test ReactTransitionKeySet should support mergeKeySets for removing keys.
[D] 2013-12-04 15:38:08,973 - POST http://127.0.0.1:9999/reportTestResults -> 200 (4ms, 50 bytes)
[D] 2013-12-04 15:38:09,088 - Request started: POST http://127.0.0.1:9999/reportTestResults
[D] 2013-12-04 15:38:09,088 - Request started: POST http://127.0.0.1:9999/reportTestResults
[D] server POST /reportTestResults 200 - - - ms
>> [Mozilla/5.0 (iPhone; CPU iPhone OS 6_1 like Mac OS X) AppleWebKit/536.26 (KHTML, like Gecko) Mobile/10B141][1386189489091] ok 9 - addons/transitions/__tests__/ReactTransitionKeySet-test ReactTransitionKeySet should support mergeKeySets for adding and removing.
[D] server POST /reportTestResults 200 - - 1 ms
>> [Mozilla/5.0 (iPhone; CPU iPhone OS 6_1 like Mac OS X) AppleWebKit/536.26 (KHTML, like Gecko) Mobile/10B141][1386189489092] ok 10 - addons/transitions/__tests__/ReactTransitionKeySet-test ReactTransitionKeySet should reconcile overlapping insertions and deletions.
[D] 2013-12-04 15:38:09,092 - POST http://127.0.0.1:9999/reportTestResults -> 200 (3ms, 50 bytes)
[D] 2013-12-04 15:38:09,092 - POST http://127.0.0.1:9999/reportTestResults -> 200 (4ms, 50 bytes)
[D] 2013-12-04 15:38:09,223 - Request started: POST http://127.0.0.1:9999/reportTestResults
[D] 2013-12-04 15:38:09,223 - Request started: POST http://127.0.0.1:9999/reportTestResults
[D] server POST /reportTestResults 200 - - - ms
>> [Mozilla/5.0 (iPhone; CPU iPhone OS 6_1 like Mac OS X) AppleWebKit/536.26 (KHTML, like Gecko) Mobile/10B141][1386189489225] ok 11 - addons/transitions/__tests__/ReactTransitionKeySet-test ReactTransitionKeySet should support mergeKeySets with undefined input.
[D] server POST /reportTestResults 200 - - - ms
>> [Mozilla/5.0 (iPhone; CPU iPhone OS 6_1 like Mac OS X) AppleWebKit/536.26 (KHTML, like Gecko) Mobile/10B141][1386189489225] ok 12 - addons/transitions/__tests__/ReactTransitionableChild-test ReactTransitionableChild should keep the DOM node around.
[D] 2013-12-04 15:38:09,226 - POST http://127.0.0.1:9999/reportTestResults -> 200 (3ms, 50 bytes)
[D] 2013-12-04 15:38:09,226 - POST http://127.0.0.1:9999/reportTestResults -> 200 (4ms, 50 bytes)
[D] 2013-12-04 15:38:09,364 - Request started: POST http://127.0.0.1:9999/reportTestResults
[D] 2013-12-04 15:38:09,364 - Request started: POST http://127.0.0.1:9999/reportTestResults
[D] server POST /reportTestResults 200 - - - ms
>> [Mozilla/5.0 (iPhone; CPU iPhone OS 6_1 like Mac OS X) AppleWebKit/536.26 (KHTML, like Gecko) Mobile/10B141][1386189489367] ok 13 - addons/transitions/__tests__/ReactTransitionableChild-test ReactTransitionableChild should manage enter css classes correctly.
[D] server POST /reportTestResults 200 - - - ms
>> [Mozilla/5.0 (iPhone; CPU iPhone OS 6_1 like Mac OS X) AppleWebKit/536.26 (KHTML, like Gecko) Mobile/10B141][1386189489367] ok 14 - addons/transitions/__tests__/ReactTransitionableChild-test ReactTransitionableChild should manage leave css classes correctly.
[D] 2013-12-04 15:38:09,368 - POST http://127.0.0.1:9999/reportTestResults -> 200 (3ms, 50 bytes)
[D] 2013-12-04 15:38:09,368 - POST http://127.0.0.1:9999/reportTestResults -> 200 (4ms, 50 bytes)
[D] 2013-12-04 15:38:09,385 - Request started: POST http://127.0.0.1:9999/reportTestResults
[D] server POST /reportTestResults 200 - - - ms
>> [Mozilla/5.0 (iPhone; CPU iPhone OS 6_1 like Mac OS X) AppleWebKit/536.26 (KHTML, like Gecko) Mobile/10B141][1386189489388] ok 15 - core/__tests__/ReactBind-test autobinding Holds reference to instance.
[D] 2013-12-04 15:38:09,388 - POST http://127.0.0.1:9999/reportTestResults -> 200 (4ms, 50 bytes)
[D] 2013-12-04 15:38:09,506 - Request started: POST http://127.0.0.1:9999/reportTestResults
[D] server POST /reportTestResults 200 - - - ms
>> [Mozilla/5.0 (iPhone; CPU iPhone OS 6_1 like Mac OS X) AppleWebKit/536.26 (KHTML, like Gecko) Mobile/10B141][1386189489509] ok 17 - core/__tests__/ReactComponent-test ReactComponent should throw on invalid render targets.
[D] 2013-12-04 15:38:09,509 - POST http://127.0.0.1:9999/reportTestResults -> 200 (4ms, 50 bytes)
[D] 2013-12-04 15:38:09,635 - Request started: POST http://127.0.0.1:9999/reportTestResults
[D] 2013-12-04 15:38:09,637 - Request started: POST http://127.0.0.1:9999/reportTestResults
[D] server POST /reportTestResults 200 - - - ms
>> [Mozilla/5.0 (iPhone; CPU iPhone OS 6_1 like Mac OS X) AppleWebKit/536.26 (KHTML, like Gecko) Mobile/10B141][1386189489640] ok 18 - core/__tests__/ReactComponent-test ReactComponent should throw when supplying a ref outside of render method.
[D] server POST /reportTestResults 200 - - - ms
>> [Mozilla/5.0 (iPhone; CPU iPhone OS 6_1 like Mac OS X) AppleWebKit/536.26 (KHTML, like Gecko) Mobile/10B141][1386189489640] ok 20 - core/__tests__/ReactComponent-test ReactComponent should support refs on owned components.
[D] 2013-12-04 15:38:09,641 - POST http://127.0.0.1:9999/reportTestResults -> 200 (4ms, 50 bytes)
[D] 2013-12-04 15:38:09,641 - POST http://127.0.0.1:9999/reportTestResults -> 200 (5ms, 50 bytes)
[D] 2013-12-04 15:38:09,661 - Request started: POST http://127.0.0.1:9999/reportTestResults
[D] server POST /reportTestResults 200 - - - ms
>> [Mozilla/5.0 (iPhone; CPU iPhone OS 6_1 like Mac OS X) AppleWebKit/536.26 (KHTML, like Gecko) Mobile/10B141][1386189489664] ok 22 - core/__tests__/ReactComponent-test ReactComponent should correctly determine if a component is mounted.
[D] 2013-12-04 15:38:09,664 - POST http://127.0.0.1:9999/reportTestResults -> 200 (3ms, 50 bytes)
 > POST /session/:sessionID/execute { script: 'var args = Array.prototype.slice.call(arguments, 0);\nvar code = args[0], fargs = args[1];\n\nvar wrap = function() {\n  return eval(code);\n};\n\nreturn wrap.apply(this, fargs);\n',
  args: [ 'typeof window.jasmine.getJSReport != \'undefined\'', [] ] }
[D] 2013-12-04 15:38:09,901 - Request started: POST http://127.0.0.1:9999/reportTestResults
[D] 2013-12-04 15:38:09,901 - Request started: POST http://127.0.0.1:9999/reportTestResults
[D] server POST /reportTestResults 200 - - 1 ms
>> [Mozilla/5.0 (iPhone; CPU iPhone OS 6_1 like Mac OS X) AppleWebKit/536.26 (KHTML, like Gecko) Mobile/10B141][1386189489907] ok 24 - core/__tests__/ReactComponent-test ReactComponent should know its (complicated) mount depth.
[D] server POST /reportTestResults 200 - - - ms
>> [Mozilla/5.0 (iPhone; CPU iPhone OS 6_1 like Mac OS X) AppleWebKit/536.26 (KHTML, like Gecko) Mobile/10B141][1386189489907] ok 16 - core/__tests__/ReactBind-test autobinding works with mixins.
[D] 2013-12-04 15:38:09,907 - POST http://127.0.0.1:9999/reportTestResults -> 200 (5ms, 50 bytes)
[D] 2013-12-04 15:38:09,907 - POST http://127.0.0.1:9999/reportTestResults -> 200 (6ms, 50 bytes)
>> Error: Error response status: 13.
 > POST /session/:sessionID/execute { script: 'return document.documentElement.innerText || document.documentElement.textContent;',
  args: [] }
Closing the browser window. To keep it open, pass the --webdriver-keep-open flag to grunt.
 > DELETE /session/:sessionID 

Ending your web drivage..

Fatal error: Error response status: 13. 
Error: Error response status: 13. 
    at webdriver._newError (/Users/aylott/Projects/Facebook/react/node_modules/wd/lib/webdriver.js:80:13)
    at /Users/aylott/Projects/Facebook/react/node_modules/wd/lib/webdriver.js:156:25
    at /Users/aylott/Projects/Facebook/react/node_modules/wd/lib/webdriver.js:388:5
    at Request._callback (/Users/aylott/Projects/Facebook/react/node_modules/wd/lib/webdriver.js:278:7)
    at Request.self.callback (/Users/aylott/Projects/Facebook/react/node_modules/wd/node_modules/request/index.js:148:22)
    at Request.EventEmitter.emit (events.js:98:17)
    at Request.<anonymous> (/Users/aylott/Projects/Facebook/react/node_modules/wd/node_modules/request/index.js:876:14)
    at Request.EventEmitter.emit (events.js:117:20)
    at IncomingMessage.<anonymous> (/Users/aylott/Projects/Facebook/react/node_modules/wd/node_modules/request/index.js:827:12)
    at IncomingMessage.EventEmitter.emit (events.js:117:20)
[D] Trying to kill tunnel

```
 I think this is working now, at least I didn't see anything crazy while running it.
  ```
>> not ok 382 - utils/__tests__/ImmutableObject-test ImmutableObject should tolerate arrays at deeper levels and prevent mutation on them:DEV.
```

https://travis-ci.org/facebook/react/jobs/14942607#L3829

http://saucelabs.com/tests/e516f61322464a97aea25b226103ce0a
 Thanks for catching this. We need to detect if `Object.freeze` is supported. If not, then we shouldn't freeze. Also, the action items to support Arrays are:
1. When "merging" (shallow or deep), simply move the entire array over, do not `for-in` them and do not recurse. Pete had ideas to be able to specify how arrays should be intelligently merged (appended, prepended, index-by-index replace).
2. Probably something else as well.
 We should test for Object.freeze, but we should probably actually just remove this from the repo, we don't use it. Also tests could be updated to use Object.isFrozen instead of depending on throwing (which only happens in strict mode, so IE9 which supports freezing but not strict mode fails).
  Here's an example: (no jsfiddle because that's broken in IE8)

http://playground.zpao.com/react/onscroll.html
 Seems like this isn't so easy. Let's do what @fabiomcosta says and document it.
 +1 on the warning -- would be super helpful.
 reopening so we can add a warning
 Warning was added in f3e774559f5cfbcd45b5f3898eb85c28200cccdb
 That's odd, I wouldn't expect that code to run at all when using server rendering.
  @sebmarkbage @jordwalke 
 I'd like the ability to access both state and pending state. But the question is, which should be the default? The primary benefit to treating `this.state` as the default, authoritative state that you base all of your state transition logic upon, is that it is guaranteed to be consistent with all your subcomponents' props.

For example:

```
var App = React.createClass({
  getInitialState: function() {
    return {name: 'joe'};
  },
  handleClick: function() {
    alert('My name ' + this.state.name + 'should equal ' + this.refs.sayer.sayName());
    this.setState({
      name: this.state.name + Math.random()
    });
  },
  render: function() {
    return (
      <div onClick={this.handleClick}>
        <NameSayer name={this.state.name}>
        </NameSayer>
      </div>
    );
  }
});
```
 @spicyj Thoughts?
 CSS's .style gives you the provided value and not the actually rendered value. You get that from computed style. This seems to be pretty idiomatic. That when you provide a value that will later be flush, the default is to read back the last provided value, not the latest flush.

People have this intuition of setter/getter semantics anyway because of the naming of this.setState.

Inside the render phase, this.state currently changes meaning. It's the rendered state outside of render and then the pending state inside of render because it hasn't flushed yet and it's inconsistent with what has been shown on the screen and inconsistent with the current value of the children.

It's very inconvenient to do counters and anything that relies on sequence of actions without easy access to pending state. It's also a very common use case.

IMO, the case that @jordwalke states is a special case use case. You should avoid refs as much as you can, and do top-down flushes.

For these reasons I feel strongly that this is an awesome change. I'll test it out a bit and see if something breaks.
 > Inside the render phase, this.state currently changes meaning. It's the rendered state outside of render and then the pending state inside of render because it hasn't flushed yet and it's inconsistent with what has been shown on the screen and inconsistent with the current value of the children.

I think that this is a good argument, but the definition of state that I've held to is "the last state to be invoked with render". By that definition, the definition doesn't ever change. However, you may be suggesting that we can chose another definition of state, namely: "the next state that our subcomponents will observe via a transformation from our state to their props". With this proposed definition, it also never changes. I think everyone is 100% on board with having both the pending state and the previously flushed state accessible. We could give this proposal a shot if it doesn't break everyone's apps.

> This is a breaking change in that now componentWillUpdate and shouldComponentUpdate need to look at this.currentState when comparing, not this.state. (Perhaps that's an argument towards including prevProps and prevState as arguments to those lifecycle methods...)

This is definitely concerning. It may justify us "swapping the defaults" so that `pendingState` is the pending state, and `state` is what was observed in the last `render` call. Either way - we should expose the pending state as this diff accomplishes.
 Ugh. OO bites us again.

It's important that pendingState is always an object with at least the current state. It should never be null. Since it's too inconvenient to check for the existence. this.setState({ x: (this.pendingState || this.currentState).x + 1 })

this.state is currentState is way too easy to misinterpret and get wrong. IMO, it's the single thing preventing us from moving to more aggressive batching strategies. Leaving it as is, is not an option.

However, this case that @spicyj bring up in shouldComponentUpdate is also too easy to get wrong. Ideally, I'd take state and props as arguments to all methods (including render).

The first thing I do in shouldComponentUpdate is:

var oldProps = this.props;
var oldState = this.state;

If I could just add those as arguments I could get rid of that boilerplate.
 I do agree that having them passed explicitly to those `should*` methods would be best. I even agree about having them passed as args to render, but we decided not to only because it wouldn't match event handlers (who access state via `this.state` etc.)
 Ping
 @vjeux: Did you encounter another situation where this would be helpful?
 Can someone document the trouble with `shouldComponentUpdate` in this diff with a little example (and how it could be resolved with adding extra args)? It's not a bad idea to take all four variables as arguments to `shouldComponentUpdate` which could help us push this change through.

@spicyj Do you have a good example of where this change would be useful to you?
 One other little suggestion: The world `currentState` may not be clear enough. Some might think of "current" as being the state that was "currently" updated yet not flushed. Maybe `renderedState` is a little more clear?
 componentWillUpdate has the same issue. Although it's rarely ever used with prevState (we only have two cases).
 Note that shouldComponentUpdate also takes a context now. It might make sense to have the signature be:

shouldComponentUpdate(prevProps, nextProps, prevState, nextState, prevContext, nextContext)

That way you can exclude context (and state) if you don't depend on those.
 I had brought this up with @sebmarkbage a while ago -- what if we made the API more monadic? I believe this would fix the dirty write problem:

``` javascript
var Clicker = React.createClass({
  getInitialState: function() { return {count: 0}; },
  handleClick: function() {
    this.stateTransition(function(state) {
      return {count: state.count + 1};
    });
  },
  render: function() { return <div onClick={this.handleClick}>{this.state.count}</div>; }
});
```

I like this API because it's clear that `this.state` isn't being mutated directly; `setState()` does not get this message across as well. It also forbids you from calling `setState()` multiple times which is an antipattern. We'd pass `pendingState` as the parameter to the function.

I don't like this API because it encourages more function allocations (but I think this is solvable by just passing a method) and because people will accidentally reference `this.state`. One option could be: if you're in a `transitionState()` block, we set `this.state` to be `pendingState`.
 It's always possible to build some syntactic sugar on top:

``` javascript
var Clicker = React.createClass({
  getInitialState: function() { return {count: 0}; },
  handleClick: React.stateTransition(function(pendingState, e) {
    // or maybe we don't pass pendingState and instead use this.state
    return {count: pendingState.count + 1};
  }),
  render: function() { return <div onClick={this.handleClick}>{this.state.count}</div>; }
});
```
 I'm not against trying to include a more monadic alternative as a secondary state setter. I think we may be able to make even more powerful so we need to think about how to get it right.

In the short term, I think this will be a political and refactoring nightmare. The write is often separated from the read by multiple mixins and intermediate methods. There can also be side-effects and callbacks intermixed. The only (so called) benefit with the OOP model is that you have easy access to props and state in all your helpers methods without explicitly passing them.

We need a quick fix, if we can, so that we can move forward with more rAF and what not.
 @sebmarkbage @jordwalke @petehunt - it's been a couple months... any plans to take this further?
 Probably not this particular PR but this discussion is valuable and the issue needs to be solved. The refs work will help eliminate one pending issue. Now we just have to figure out what to do with the shouldComponentUpdate API.
 Yeah, I'll close this out.
 It's just an idea.

> On Apr 29, 2014, at 8:42 AM, Pedro Henriques dos Santos Teixeira notifications@github.com wrote:
> 
> Hi there, is there such 'this.pendingState' or is it just an idea? Couldn't find it in the docs. thanks.
> 
> ‚Äî
> Reply to this email directly or view it on GitHub.
 @dhruvbhatia We'll break it one day and won't tell you, just remember that. If you can find another solution, I would suggest that. Bad practices get copied and then before you know it you're stuck on an old version of React.
   Perhaps `unit` should be renamed to `travis:unit` or something then?
Either way the same stuff is happening in the same order.
 The reason I want to change this is so that I can add more `matrix` entries without complicating the travis script.
 Currently I have each version of IE separated out as a separate matrix and they are setup to be allowed to fail. Once we fix all the broken tests for each browser we can remove it from being allowed to fail and move it to the unit phase. That way the we won't regress browser support.
 The problem with travis matrix is that nothing is kept between builds. Ideally we wouldn't go through `npm install` more than once, for example. For now this works though.
 cc @zpao ‚Äî As you wish.
 I'll just leave this here: #633 
 Blargh, flaky tests: #634 
 #635 should help the webdriver tests be less flaky
 Rebased with master
 #635 should be merged before this one
 :thumbsup: otherwise. test test test :)
  This was challenging for three reasons:
- Accessing internals is hard
- `__DEV__`
- You can't `require()` the browserified code via UMD (not a showstopper but annoying)

This solves the first problem by just stealing @zpao's https://github.com/facebook/react/pull/442. Now you can `require('React/lib/EventPluginRegistry')` and inject your own event plugins. I don't think we should document this until we shore up our API. However, I think this is enough to publish `TapEventPlugin` (perhaps as a separate npm module)

The second is solved by using `envify` which will do a syntax transform to substitute the `NODE_ENV` environment variable (see http://www.hacksparrow.com/running-express-js-in-production-mode.html). So this will transparently work and I tested that it stripped invariants and `__DEV__` branches. Additionally I required the transform in `package.json` so they can just transparently use this package and not worry about `__DEV__` at all!

The third is solved by introducing muffinizing! Hell yeah! I just replaced every instance of the word `require` in the browserified code with `muffin`. This is actually pretty much the only way this will work since many packaging systems look for calls to a function named `require()`. cc @epriestley

I suggest we follow this up by deprecating react-addons, moving each addon to its own npm package and having a "react-with-addons" npm package that just depends on the other stuff and can be browserified with `wzrd.in`.
## Test plan
- Standard test plans (grunt, examples etc)
- Look at filesizes, they seem OK
- Manually examine transformed sources, they have the right `"production" === process.env.NODE_ENV`
- Manually examine browserified sources (.min.js and .js) with minification OFF, they have the right `"production" === "a string"` in there.
- Disable simple header and minfication for `.min.js`, `diff -u react.js react.min.js` shows no changes in the files (this is the goal)
- Create test app using `renderComponentToString()`, `npm install ~/Projects/react/build/react-core/`, then `require('React')` and `require('React/lib/React')`, both work in Node
- With same test app, `cp ~/Projects/react/build/react.js ./react-browserified.js`, using `require('./react-browserified.js')` still works
- Try the last two previous steps with browserify: `browserify testapp.js > bundle.js`, browserified bundle works in Node.
- Manually inspect browserified bundle, see that `process` is shimmed
- Try the last two previous steps with production mode browserify **and** minfication: `NODE_ENV=production browserify testapp.js | uglifyjs -cm > bundle.min.js`. File still runs and `invariant()` messages are nowhere to be found. File size is 33kb after gzip (good).
 Solves https://github.com/facebook/react/issues/436 as well
 OK, I'll take out the muffinizer :(
 suggested muffinizing in https://github.com/ForbesLindesay/umd/issues/10
 Few things:
1. please update the version in the core package.json
2. update the version in React.js
3. we'll want to update the `commonerConfig` version in package.json (to force a cachebuster)
4. the browser tests don't run - `ReferenceError: process is not defined` (cc @benjamn, @subtleGradient)
 Will make these changes, but aren't `package.json` and `React.js` automatically updated to the latest version?
 No, only `docs/_config.yml` is auto updated. The rest is manual (but that's why there are tests to make sure they are updated, they were failing :wink:)
 build is green now. i thought tests were broken in master, looks like i was wrong!
 Pulled locally, added a few more things, then screwed up with a fast-forward merge. https://github.com/facebook/react/compare/9270d3d56ea3b196acc099409a38e6c07b191e46...153b75f186a78c876cc11678d1abbdf5e13a3b5b has all the commits.
  :thumbsup: 
  Is it good to be taken in?
  Should be fixed in `master` I think. Reopen if not. cc @benjamn 
  +1 let's just kill it if it's not in use
 Would you like the honors @youngjay?
 @youngjay if you write the PR to remove it, we'll accept that. Otherwise we'll take this and somebody else will do the removal.
 Closing in favor of #630. Thanks a lot for noticing the misuse @youngjay! Definitely don't hesitate if you see anything else wrong.
  This PR is a response to https://github.com/facebook/react/issues/600. I pulled in @paulshen's React benchmarks and built a new runner for them. This runner looks at the `--trace-deopt` output of Node (while running in jsdom) and enforces that certain functions are optimized and not deopted.

Unfortunately the JIT behavior isn't deterministic (or perhaps jsdom isn't deterministic) so sometimes functions are optimized, sometimes they're not, and sometimes they deopt a lot.

This tool tests whether it is _possible_ for a function to remain optimized for an extended period of time by running the tests multiple times and succeeding if the function stays optimized for at least one trial.

This PR is to assess if people think this is a good idea. If it is I can port it to node if people don't want Python in the repo.

This PR also includes a fix or two for @plievone's issues.
 Curious, why is this script in python?
 Cause I like the `subprocess` module mostly, but willing to port to node if people think this is a good idea.
 It would be nice if we could get this data in an automated way on a per-commit basis, but I think Chrome's new deopt tools plus Aylott's benchmarking in CI get the job done well enough that this isn't needed.
  If you see a place where you think we need it, feel free to do it. I think the costliest parts are covered by commoner right now (though presumably `grunt build && grunt build` could be shortened with grunt-newer but I don't know how realistic that is) so I'm not sure how much of a win we'd get. I think there are probably other optimizations we could make in the build process first.
  Yes this is great. Did you sign the cla? Let me know and I'll merge!
 @petehunt is gallivanting around the world so I'll merge this in. Thanks a lot!
  Good point! We use an intermediate tool that does caching and some other smart things. I'm going to pass this off to @benjamn because he's the author of commoner.
  Always copying would fix these issues:

https://groups.google.com/forum/#!topic/reactjs/bo_cdp4Fxgw
http://jsbin.com/oYoFUxa/1/edit

Also another issue I saw today where someone wanted to reuse a header row for a table in multiple places.
 We had a fairly large discussion about this. The challenge is making this compatible with the ES6 class direction. It doesn't seem like anything insurmountable. We'd like `<Typeahead />` to transform into some expression that evaluates to:

```
{ componentConstructor: Typeahead, props: ..., owner: ...}
```

We've been throwing around the words "pure descriptor" to talk about these structures.

That might mean that first `<Typeahead />` transforms into

```
Typeahead.create()
```

Which is the function that returns the JSON style object.

`Typeahead.create` knows how to supply the `owner` field the same way it currently is - by examining the "currently rendering react component". What's convenient, is that when you declare constant components at the top of the file for efficient reuse, it can be shared by many different component instances over time. That means that the owner isn't even a valid notion at definition time. It sound like a problem, but it's actually okay considering the fact that these constant components could be reused by many different renderers and we'd get conflicts if different renderers start clobbering that shared object's `owner` property. So maybe we can punt on supporting owner (and therefore refs) for "constant"/shared object descriptors.

One other benefit to the "pure descriptor" approach, is that no one can retain a reference to it in their render function and treat it like an instance later on. It may or may not be the instance that they're looking for depending on if they retained it on the first render or on subsequent renders!

Whether or not we use "pure descriptors" or actual instances, the fact that we copy/clone into a new instance when we finally mount it means we can employ automatic pooling to auto-generate these pure descriptors/instances. If that's the case then Pete just might get his zero-allocation render after all.
 If I'm understanding everything here correctly, I believe @sebmarkbage is working on this and we're going to have it in for 0.9.
 This is done now.
  Yes! High on my personal wishlist :-).
Op 26 nov. 2013 06:41 schreef "Jordan W" notifications@github.com:

> Let's use ES6 classes to create React component classes. We've accumulated
> some custom concepts that don't lend themselves to using ES6 classes but we
> can still use them in conjunction with React components as ES6 classes, if
> the separation is performed as "enhancers" on top of completely pure ES6
> classes:
> 
> class Typeahead extends ReactComponent {
>    render() {
> 
>    }
>  }
> 
>  // Enhancers
>  ReactComponent
>  ReactComponent.autoBindMethods(Typeahead);
>  ReactComponent.validatePropTypes(Typeahead);
> 
>  module.exports = Typeahead;
> 
>    -
> 
>    Blockers:
>     - Probably want to call the base class ReactComponent even though the
>       base class of our components today is called ReactCompositeComponent.
>       We just need to rename ReactCompositeComponent to ReactComponentand
>       ReactComponent to ReactComponentBase.
>       - Right now React.createClass doesn't return the constructor. It
>       returns the "convenience constructor" which can be invoked without
>       new. We can unify the two concepts and eliminate convenience
>       constructors altogether.
>       - Determine how to support autobinding (likely an "enhancer" as
>       shown above).
>       - Get rid or (or figure out way to abstract out) special
>       proprietary handling of overridden methods like componentWillMount,
>       componentWillReceiveProps - there aren't classical OO equivalents.
>       - Of these proprietary handlers, some are for the purpose of
>       validation (preventing people from overriding base class methods). Others
>       add actual functionality. We can do whatever we have to to ensure
>       validation, but the additional functionality should be factored out of the
>       class hierarchy, into special "enhancers" as I've hinted at at the bottom
>       of the previous example. It should be possible to program with pure,
>       straight up ES6 classes.
>       - The main challenge with our proprietary handlers is how we allow
>       multiple mixins to redefine properties, and ReactCompositeComponentwill attempt to intelligently merge their results. It is okay to factor all
>       of that out into helper utilities, and we can supply a code mod that
>       automatically updates your code that uses mixins.
>     -
> 
>    This is a huge undertaking. Before anyone takes a shot at this -
>    please lock down the API. For ES6 related questions, run ideas by
>    @jeffmo https://github.com/jeffmo and @sebmarkbagehttps://github.com/sebmarkbagewho understand the direction of ES6. I'm happy to chat about the
>    feasibility of potential changes to the React core, and practical ways to
>    get started.
> 
> ‚Äî
> Reply to this email directly or view it on GitHubhttps://github.com/facebook/react/issues/613
> .
 see #1380 

I'll close out this issue since most of the info here is stale.
 @ericelliott Note that classic React factories created through `createClass` are just OOP classes like ES6 classes. They support the same kind of inheritance through mixins. In fact, because it also supports multi-inheritance it opens up even more pitfalls. In fact, mixins is unfortunately seen as the primary way to do abstractions.

ES6 classes in React is not adding anything you couldn't already do. In fact it is constraining it further by encouraging object composition instead of mixins. It is an unfortunate marketing effect that this move is seen as encouraging OOP when it is really not.

My stance on progress in this space is that you can't take things away from developers until you've taught them the alternatives... at scale. (That includes myself.)

The class system provides an optional escape hatch when you need it rather than completely stopping you.

The primary feature that our class system provides is an "instance" handle this has several features.

1) It provides a certain level of familiarity and convenience. You can use `this` as a middle man to refer to a group of arguments. This is a foot-gun but makes it easier to onboard new people.

2) The instance is an ID that you can use to refer to a place in the tree. It allows APIs like `React.findDOMNode(component)` and third-party APIs that can unify around it.

3) It provides single or multiple inheritance features if someone needs to create an abstraction and just can't figure out how to do it using composition. This is unfortunately a very common problem.

If a developer can't figure out a way to do it, we don't want them to get stuck. Therefore, OOP is an escape hatch. At the same time we're trying to teach and encourage composition of components and higher order functions/components instead of OOP. You can still implement that on top of the class systems that we have. Then, when this practice is common enough, we can start deprecating old class systems.

However, we make that progress by teaching and encouragement - not by force.

As a phase two of this, we can start introducing more pure models. See the alternatives that we've been working on to replace "instances" as an abstraction model:

https://github.com/reactjs/react-future/blob/master/01%20-%20Core/03%20-%20Stateless%20Functions.js
https://github.com/reactjs/react-future/tree/master/07%20-%20Returning%20State

As well as a declarative ways of updating state:

https://github.com/reactjs/react-future/tree/master/09%20-%20Reduce%20State
 > Is prop validation needed for stateless components

It's never required for any components, but unless you're already using Flow, we suggest you to put `propTypes` on all components. It's not different for functional components:

``` js
const MenuItem = ({ title }) => <div>{title}</div>;
MenuItem.propTypes = {
  title: React.PropTypes.string
};
```
 > I was wondering that these stateless functions(components) looks simply like functions so how come React treats them as components!! 

Starting from 0.14, React allows components to be declared as functions. This is useful for **simple components that have no lifecycle methods or state**, and in the future React might apply certain optimizations to them (but not today).

Please read [the announcement from 0.14 release notes](https://facebook.github.io/react/blog/2015/10/07/react-v0.14.html#stateless-functional-components).
  What version of IE are you having problems with? We support IE8+ in standards mode right now. IE8 in quirks mode shows the behavior you're seeing. If this is your own page, then just add a doctype and that should force standards mode (which I imagine you want anyway).
  Currently the preview shows an empty div when the editor content fails to eval. If there's no opposition I'll do the one-line change to display the error message (extra: transition the background to red as as a warning).

The downside is that while editing, the the preview often throws. But I don't think this is too much of a trouble (thus the transition to red so that the preview doesn't constantly flashes red while the code's being edited).
 It might be confusing to show it in the same box. Maybe a new error box below? Or the red could be nice. Let's do something though.

It would actually be even cooler to debounce so we don't parse the editor content until after keypresses stop (would avoid the flashes). The 2 combined would make for a much better experience.
 @vjeux any other comment?
  IE8 doesn't support `getAttributeNS`, `setAttributeNS` or  `hasAttributeNS`.
 This method will be killed soon.

Sent from my iPhone

On Nov 25, 2013, at 1:04 PM, "Thomas Aylott" <notifications@github.com<mailto:notifications@github.com>> wrote:

IE8 doesn't support getAttributeNS, setAttributeNS or hasAttributeNS.

‚Äî
Reply to this email directly or view it on GitHubhttps://urldefense.proofpoint.com/v1/url?u=https://github.com/facebook/react/issues/608&k=ZVNjlDMF0FElm4dQtryO4A%3D%3D%0A&r=qYx6qLphxKhA5vHBqr9vuw%3D%3D%0A&m=drgeL8Jt%2B60uOTTtxwfPIFZrkv9nkgXXIwURyD2bQQQ%3D%0A&s=9d8d98abc54dbd9954a1105a1917e7be2f1854b1ea655fa3eebeb39875248483.
 This method doesn't exist any more.
  On my mac book pro, the left command key says "OS" and the right says "ContextMenu"

http://pelegri.files.wordpress.com/2010/12/img-20101225-00014.jpg

Is this a feature or a bug?
  `listenAtTopLevel` accepts a `contentDocument`.
All listeners are added to that `contentDocument` except for the ones registered in `ensureScrollValueMonitoring` which register on `window`.
 I'm not so sure. I think we need ViewportMetrics for each `window` object.
 Related #2271
 Since #6129 we no longer listen to scroll events except in IE8.
We also stop officially supporting IE8 in React 15.
As far as I can see effectively this means that this issue is no longer relevant.

Thank you for reporting, and please let me know if I‚Äôm wrong to close this one.
  I think that would be fine. I would still put the equivalent jQuery call because that will be the inevitable question.
 Agreed. A beginner tutorial isn't the place to debate jquery vs no jquery. The point is familiarity.
 ^ The note about jQuery not being mandatory got merged. I think this is good for now for newcomers. The react users probably already realized they don't actually need jQuery. Closing for now! =)
  #542

Any comment? I don't like the title too much. I prefer describing the situation, e.g. "Parent-Child Communication" rather than just state what the code does. Except there's more to parent-child communication (#478).
 @johnthethird got any idea for a better title? Like what prompted you to look for this? "Passing arguments to callbacks" feels a bit too general.
 Let's just do the first one in this pull request. We can do the second one in a separate one. Can you factor it out? I'll accept it.
  :+1: 
  :+1: 
 wooooo!
  :+1: 
 We could add https://github.com/facebook/react/pull/617 and the sauce labs tests to the matrix also. Good idea!
 I knew it could be done :smiley:. Nice work!
  The current semantics of keys is that they're only used to identify components within an array, as a convenience to avoid creating a keyed object fragment. They're not general purpose state breakers.

It might make sense to change the semantics to general purpose state breakers since it's kind of confusing that this honors the key:

```
var child = <StatefulComponent key="foo" />;
return <div>{child}</div>
```

But this doesn't:

```
return {child}
```

Which makes it a refactoring hazard. In that case it should probably use the key of the component in the position of an object fragment. E.g. this should also respect the key of the object position AND the child's key (the effective resulting key would be {bar}{foo}).

```
return { bar: child };
```

@jordwalke This type of keying convention, of putting values on the props, can completely avoid the deoptimization problem since there is no need for these keys to ever go on a flattened children object, as your linked-list implementation shows.
 @sebmarkbage Can you handle reviewing and syncing this one?
  Thanks!
  #413

Any feedback on the wording?
 I guess I could. None of the two modified page brings new info to the api though
 That's a good idea. I'll do that soon.
 Any update?
 No rush, just checking in. Focus on exams!

On Dec 5, 2013, at 8:36 PM, "Cheng Lou" <notifications@github.com<mailto:notifications@github.com>> wrote:

@zpaohttps://urldefense.proofpoint.com/v1/url?u=https://github.com/zpao&k=ZVNjlDMF0FElm4dQtryO4A%3D%3D%0A&r=laHZhPsrTTGL9mHVyUC%2BICFnZxZCH4LNzfo%2BOgrHdsw%3D%0A&m=LdkvWdkr9U88A6QngkFwaMCMol9O7TuUs%2F1EDSr4zYI%3D%0A&s=6a83bf04a7d76f89f31b8e6b891cbb862ef3f80314e1f084613a5a1e304271ef do you need the docs soon? Exams over next week only.

‚Äî
Reply to this email directly or view it on GitHubhttps://urldefense.proofpoint.com/v1/url?u=https://github.com/facebook/react/pull/588%23issuecomment-29963130&k=ZVNjlDMF0FElm4dQtryO4A%3D%3D%0A&r=laHZhPsrTTGL9mHVyUC%2BICFnZxZCH4LNzfo%2BOgrHdsw%3D%0A&m=LdkvWdkr9U88A6QngkFwaMCMol9O7TuUs%2F1EDSr4zYI%3D%0A&s=3b46c502820ffa2c8a199bec29d6d663e2af8527c4dbd60090537e19b83bc5a6.
  I think the docs here are good enough now; haven't heard much confusion.
  Regrading `require('react-core')`:

There's many reasons why we want to use `require('react')`, but one really important one is that it will make it easy for us to open source any awesome UI components that Facebook builds internally to the world. Since internally, we use `require('React')`.

>  I'd rather just explain all the packaging as "it's just npm".

We can sill say: "It's just npm" - because npm allows pointing to arbitrary git repos/versions. npm has this strange tacked on feature of having a name registry as well - which is a questionable choice IMHO, but I'm grateful that it doesn't lock us into that name registry. But (in parallel) we're working on getting the proper setup on npm's name registry as well. Stay tuned and cross your fingers.
 Feel free to depend on http://petehunt.net/react/react-0.5.1.tar.gz and `require('react')`. The advantage of this package is that if you build with `NODE_ENV='production'` you'll get runtime checks stripped.
 Made some changes which mitigate these problems: https://groups.google.com/forum/#!topic/reactjs/4jI5xe7TXzQ

As such I think we'll keep this capability around, at least for now.
  Love this solution!
  I feel like a really common case is to pass a callback which contains `this.setState()` intended for a common owner component. How do you plan on addressing this without adding an additional bind() per render()?
  Yes. I need to add a project about cleaning up context so we can make sure this is usable.
 @ericwooley They aren't documented, and I think we've been pretty consistent about telling people that it's not a supported feature and should not be used yet.  We try to add warnings when we change context in a breaking way.  But they are undocumented intentionally.  We can't add a global warning because as @gaearon said, it would cause libraries like react-router to start emitting warnings in everyone's projects.
 > it would essentially be impossible

Is that a bad thing? ;)
 We should document this and control the messaging. It's too late to pretend
that React doesn't currently support context. At least this way we can
document the caveats and talk about whatever future plans might be. I'm
tired of linking to a couple issues and fielding questions based on what
people are reading around the Internet.

On Friday, October 2, 2015, Sam notifications@github.com wrote:

> FYI, I totally changed direction on this and stopped using context as it's
> likely to be dropped. Not to mention I hit an infinite loop issue with it -
> so I feel like maybe it's a half-baked solution.
> 
> I'm building in Meteor, so I'm using the meteorflux:dispatcher package
> and it's working great for me.
> 
> ‚Äî
> Reply to this email directly or view it on GitHub
> https://github.com/facebook/react/issues/580#issuecomment-145071883.
  I think the right fix for this is layers. Basically adding a transparent div on top of the entire viewport and capturing clicks on that.

Here's a very simple way to do that: http://jsfiddle.net/LHmwd/
 :-1: I don't think this is the right solution to the problem. There exists much more flexible (but simple) solutions, that would also be applicable to all events, and not just click.
 I'm with @syranide. `onClickOutside` is a really brute-forced approach and it feels really wrong. There should be a general `topOnClick && !clickedOnNode` kind of thing.
 @willdady I don't have (an explanation of) the code right now (it's not at all complex), but I made a (for us) reusable self-contained drop-down component for React, anchored in place too (not dynamically positioned by JS). It's all React, no direct DOM access and it works as intended from anywhere within our app, including popups, and closes if you click outside (+eats the click) the drop-down. Works in all browsers React supports.

So unless there's something we're NOT doing, that you are, that would break our component. It seems that it shouldn't be a problem.
 You can use React.addons.batchedUpdates to get the same functionality.
 Ah, yes. #3570 
 As for this issue generally, see #1608. We're not planning to add this event. For many cases with popups and modals, you can add a backdrop element (either transparent or not) to capture clicks. For others, you can add a top-level listener to the document and catch clicks. #285 tracks adding a more complete solution to that, though for now manually calling addEventListener for that case is probably best.
 @polkovnikov-ph That's not necessarily true ‚Äì it depends when the other listeners are added.
  Thanks for the contribution! Can you sign the CLA at https://developers.facebook.com/opensource/cla ? Then we can merge.
  pulling this in
  Travis installs fresh every run, so that's pretty strange.
 Ah, that was a legit bug in the transform :)

b2507066b610e0316d7a4a4d62685c58b3a34629 fixes it (we should make that fail, but let's address that separately)
  Can we fix this instead by making `require("mock-modules").dumpCache()` reset all `.mock` and `.dontMock` settings between tests?
 @Daniel15 yeah, to be clear, you helped illuminate a problem in the open-source test runner. Thanks!

I'm going to merge this to get tests passing again, and then keep looking into the mocking problems. If I can fix those in another way, I'll reinstate the mocking of `ReactEventEmitter` in a follow-up PR.
  2fe2cd5337f063a0efe74b426ec3987f1e45fb15
  @leifdenby came to IRC as he couldn't get `<select><options>...</select>` working. It wasn't clear to me that we should use `value={...}` on the `<select>` itself rather than `selected={...}` on `<option>`s. We need to make the doc clearer here.

Here's a JSFiddle that gives 3 examples: Controlled, Controller with LinkState and Uncontrolled `<select>`

http://jsfiddle.net/5734W/
 Is this format used because it's easier to work with in React, or is there some other reason?
Also, I could take on this. Without mentioning LinkState right?
Should this also be mentioned in DOM Inconsistencies?
  cc @petehunt 

#439 has the commits that went into 0.5.1. Or https://github.com/facebook/react/compare/ea1ab55...6401681 which is easier to look at. I'm 99.99% sure it's 1b835fb5cf1940785a582c341566912e2918e9cc you want.

I think what might be happening is that by fixing a bug, we triggered behavior you weren't expecting. If you look at the console and end state in your 0.5.0 example, no end event is triggered (because of a bug on our end) and your node still has classes on it that it shouldn't. But if you remove those classes your transition is triggered again. This happens in your 0.5.1 example.
 Having not used TransitionGroup, I'll admit the docs could be clearer. But using those examples, I think you want the `transition` to be set in `.card-enter`. That way when the transform is applied, it happens once, but then `card-enter` and `card-enter-active` are presumably removed at the same time, so there is no transition back. If you leave the transition on `.card`, any changes will result in a transition. See it in action: http://jsfiddle.net/8GAwn/
  The fact that keys are optional has nothing to do with this. React should have the same behavior in dev and prod but it's perfectly reasonable to throw (as now) or warn.
  Like we talked about. cc @benjamn
 As I said in IRC, Jasmine is supposed to respect a URL query parameter to filter by test name, but it has never worked for us. This would be a great feature to have.
   :thumbsup:
 I'll take it. I especially want to explain the new `ReactTestUtils.mockComponent` method:
https://github.com/facebook/react/blob/1ee7f8131c1702e3584bbe51d94b503089b8f3bf/src/test/ReactTestUtils.js#L195-L220
 Relevant: https://github.com/facebook/react/pull/745
 :+1: 
 This was done
  I think it would be better if we just used `this.getDOMNode()`
 thanks
  That makes sense to me, but I haven't enough experience in this part of the code base. cc @yungsters, @petehunt 
 I don't think this is the right fix, but I don't have an alternate suggestion. Hmm...
 Isn't this a bug? I think **owner** isn't getting set correctly (it should be null if created outside of React, right?)
 Thanks for taking the time to explain. This looks reasonable to me.
  cc @yungsters 
 I'm redoing some stuff related to propTypes now. I'll try to get this in
 We have an internal diff in the works.
 d914522ae4111512c7e0a604a6c5027600f5e966
   In Chrome beta and Firefox, 'change' doesn't fire when dragging until mouseup so we should listen to input here too.
 @syranide I think we should attempt to support all the built-in inputs at least mostly-reasonably.
 @dancoates I'm sorry that this is a lower priority for us than for you. Feel free to send a pull request though! `ChangeEventPlugin` is a little hairy but my blog post at http://benalpert.com/2013/06/18/a-near-perfect-oninput-shim-for-ie-8-and-9.html should give you an idea of the general strategy. For range elements, we should listen to both input and change events and fire events when either happens (but only once even if both happen).
  I think it's a neat way of solving https://twitter.com/atomless/status/401288699029094401
Instead of deciding if a snippet should be written in JS or JSX, why not put the JSX compiler to bigger use. There could be a button beside the live editor label that toggles between the two.

This applies not only to Tips but also in general.
 Good idea! Where is the pull request? :)
 lol I might get on it (or someone else) if it's viable. Compile JSX to JS is not a problem of course, but what about the other way around? If I write in the JS view and go back to the JSX tab what'd be the correct behaviour here?
 In!
  Yea, IE11+ would be a deal break. I like the idea though
  Does it indicate where the utf8 characters are?

## 

Christopher "vjeux" Chedeau
Facebook Engineer
http://blog.vjeux.com/

> On Nov 15, 2013, at 2:42 AM, Guido Bouman notifications@github.com wrote:
> 
> Trying to run jekyll to work on docs but can't get it to boot. There's UTF characters in a blog post which jekyll (ruby probably) does not like.
> 
> Tried setting the lang variables already:
> 
> LANG="en_US.UTF-8"
> LC_ALL="en_US.UTF-8"
> No luck yet.
> 
> ‚Äî
> Reply to this email directly or view it on GitHub.
 Quite possibly from my name - `‚Äô` (that's a real apostrophe, not the `'`). I've had that problem in the past.

What version of Ruby are you using? Like I said, I've had the problem in the past, but not recently (using 1.9.3 here). I think you're going to need at least 1.9.2 (see #401) anyway, so hopefully it's not a big problem.

Does it say which post? That would help narrow it down.
  Thanks a lot :)
  ```
>> [Mozilla/5.0 (Linux; U; Android 2.3.6; en-us; GT-S5360L Build/GINGERBREAD) AppleWebKit/533.1 (KHTML, like Gecko) Version/4.0 Mobile Safari/533.1][1384464306738] not ok 362 - ImmutableObject should tolerate arrays at deeper levels and prevent mutation on them:DEV.
[Mozilla/5.0 (Linux; U; Android 2.3.6; en-us; GT-S5360L Build/GINGERBREAD) AppleWebKit/533.1 (KHTML, like Gecko) Version/4.0 Mobile Safari/533.1][1384464306738] # Expected function to throw an exception.
[Mozilla/5.0 (Linux; U; Android 2.3.6; en-us; GT-S5360L Build/GINGERBREAD) AppleWebKit/533.1 (KHTML, like Gecko) Version/4.0 Mobile Safari/533.1][1384464306739] # Expected function to throw an exception.
>> [Mozilla/5.0 (Linux; U; Android 2.3.6; en-us; GT-S5360L Build/GINGERBREAD) AppleWebKit/533.1 (KHTML, like Gecko) Version/4.0 Mobile Safari/533.1][1384464307562] not ok 363 - ImmutableObject should tolerate arrays at deeper levels and prevent mutation on them:PROD.
[Mozilla/5.0 (Linux; U; Android 2.3.6; en-us; GT-S5360L Build/GINGERBREAD) AppleWebKit/533.1 (KHTML, like Gecko) Version/4.0 Mobile Safari/533.1][1384464307563] # Expected function to throw an exception.
[Mozilla/5.0 (Linux; U; Android 2.3.6; en-us; GT-S5360L Build/GINGERBREAD) AppleWebKit/533.1 (KHTML, like Gecko) Version/4.0 Mobile Safari/533.1][1384464307563] # Expected function to throw an exception.
```
  ```
>> [Mozilla/5.0 (Linux; U; Android 2.3.6; en-us; GT-S5360L Build/GINGERBREAD) AppleWebKit/533.1 (KHTML, like Gecko) Version/4.0 Mobile Safari/533.1][1384464300818] not ok 350 - ImmutableObject should prevent shallow field addition when strict.
[Mozilla/5.0 (Linux; U; Android 2.3.6; en-us; GT-S5360L Build/GINGERBREAD) AppleWebKit/533.1 (KHTML, like Gecko) Version/4.0 Mobile Safari/533.1][1384464300826] # Expected function to throw an exception.
>> [Mozilla/5.0 (Linux; U; Android 2.3.6; en-us; GT-S5360L Build/GINGERBREAD) AppleWebKit/533.1 (KHTML, like Gecko) Version/4.0 Mobile Safari/533.1][1384464302027] not ok 351 - ImmutableObject should prevent shallow field mutation when strict.
[Mozilla/5.0 (Linux; U; Android 2.3.6; en-us; GT-S5360L Build/GINGERBREAD) AppleWebKit/533.1 (KHTML, like Gecko) Version/4.0 Mobile Safari/533.1][1384464302028] # Expected function to throw an exception.
>> [Mozilla/5.0 (Linux; U; Android 2.3.6; en-us; GT-S5360L Build/GINGERBREAD) AppleWebKit/533.1 (KHTML, like Gecko) Version/4.0 Mobile Safari/533.1][1384464302847] not ok 352 - ImmutableObject should prevent deep field addition when strict.
[Mozilla/5.0 (Linux; U; Android 2.3.6; en-us; GT-S5360L Build/GINGERBREAD) AppleWebKit/533.1 (KHTML, like Gecko) Version/4.0 Mobile Safari/533.1][1384464302848] # Expected function to throw an exception.
>> [Mozilla/5.0 (Linux; U; Android 2.3.6; en-us; GT-S5360L Build/GINGERBREAD) AppleWebKit/533.1 (KHTML, like Gecko) Version/4.0 Mobile Safari/533.1][1384464303666] not ok 353 - ImmutableObject should prevent deep field mutation when strict.
[Mozilla/5.0 (Linux; U; Android 2.3.6; en-us; GT-S5360L Build/GINGERBREAD) AppleWebKit/533.1 (KHTML, like Gecko) Version/4.0 Mobile Safari/533.1][1384464303667] # Expected function to throw an exception.
```
  ```
[Mozilla/5.0 (Linux; U; Android 2.3.6; en-us; GT-S5360L Build/GINGERBREAD) AppleWebKit/533.1 (KHTML, like Gecko) Version/4.0 Mobile Safari/533.1]

not ok 265 - mutateHTMLNodeWithMarkup should mutate the document html.
# TypeError: Cannot read property 'innerHTML' of null
```
  See https://groups.google.com/forum/#!topic/reactjs/fjprp2qbPNY

``` javascript
handleClick: function(color, e) {
  this.props.addColor(color);
},
render: function() {
  var items = this.props.colors.forEach(function(color, i) {
    return (
      <li key={i} onClick={this.handleClick.bind(this, color)}>
        {color.name}
      </li>
    );
  }.bind(this));

  return (<ul>{items}</ul>);
}
```
 Added to tips' wiki list.
 :ship:ed
  The JSON format is great for Sauce but not so great for running tests manually in the console.
 willfix
 :ping:, this makes it rather hard to scan the test output quickly when tests fail
 Is the new cleaner output good enough? No more raw JSON.
 Going to just close out. I think re-printing could be handy at some point though
  The more of these issues I see with this, the more I wish we'd just gone and made the actual link only show on hover (a la GitHub). That would also let us have links inside headers without breaking things (which is currently happening at http://facebook.github.io/react/downloads.html#react-core-0.5.1-development since we end up with `<a><a>...`). What you have is close to that (puts a separate link) but it still wraps the content in a link too. Maybe we can leave the id with whatever tricks we need to keep it below the navbar, but just have `#` show up to be clickable?
 I really like the # next to the header instead of making the whole header a link.
 Thanks!

@guidobouman I'm happy to see you caring about this :) But this is essentially what I wanted at the beginning so I'm going to take it. If you're interested in doing a bit more with the docs, I think there are a few places to clean up and improvements that could be mad overall. Shoot me an email or find me on IRC and we can chat.
  I'll be merging this this week! Sorry for the delay!
 And by this week I mean today
  Currently if you add a new ReactTransitionGroup with some children during a
render pass, the children are transitioned. This is generally not desirable
(e.g. if adding a transition-enabled list that already has some items, you don't
want to transition all of the initial items when first rendering the list).

This diff makes it so that entry transitions are applied only when the
transition group already exists. This is implemented by applying entry
transitions only when the group has already been mounted.
 Talked on IRC; let's add a `transitionOnMount` prop so we can keep this behavior (but default it to false)
 Added `transitionOnMount` and updated tests (and tested it in a browser).
 OK, I'm going to work on getting this in this week.
 Sadly this is going to have a conflict at the next sync. I think the best thing to do is to wait for @zpao to do it and rebase on top (I'm not sure what will happen if I fix the conflict internally and merge here... will probably "just work" but I'm not 100% sure how that works)
 I think the right thing is for me to update my fork i.e. go ahead and break this.
 We're all synced so do your thang
 pusheen_party
 In ReactCSSTransitionGroup now I believe the transition happens only for new elements, so I'm going to close this out. (And ReactTransitionGroup should be flexible enough to do any custom logic you might want.)
  ```
ImmutableObject should prevent shallow field addition when strict.
Expected function to throw an exception.
ImmutableObject should prevent shallow field mutation when strict.
Expected function to throw an exception.
ImmutableObject should prevent deep field addition when strict.
Expected function to throw an exception.
ImmutableObject should prevent deep field mutation when strict.
Expected function to throw an exception.
ImmutableObject should tolerate arrays at deeper levels and prevent mutation on them:DEV.
Expected function to throw an exception.
Expected function to throw an exception.
ImmutableObject should tolerate arrays at deeper levels and prevent mutation on them:PROD.
Expected function to throw an exception.
Expected function to throw an exception.
```

I haven't looked into what's going on yet, just capturing errors right now.
 See comments about these tests in other issues.
   I'd rather do it [this way](https://github.com/facebook/react/pull/535), if you don't mind.
 I think we should do both. I think a forced clean should force clean all of the build artifacts (of which .module-cache is a part of).
 @zpao can we distinguish between `grunt clean` and `grunt clean --force`?
 I'm actually not aware of any other use cases for `grunt clean` so maybe this is fine. But it still means we need to tell people to do `grunt clean` if they encounter problems that might be fixed by doing so, whereas #535 gives us a way to get the same effect with no verbal communication.
 I'm going to do it. I think we should probably also do #535.
 Closed by 9cb3a3a18229ebe94b033f1bbdb366790832325f.
  Thanks a lot for this! However, @guidobouman beat you to it in #493 :) (which I failed to merge in quickly). If there's anything else you catch in the docs or code, I would appreciate seeing any other contributions!
  cc @yungsters?
 This looks good to me, so I'm going to merge and fix forward if there are any problems.
  Will be fixed once #493 gets put into prod a little later today.
  :thumbsup: I noticed this the other day, so thanks for fixing!
  Want to take a go at fixing this? I think it would be a good opportunity to learn a bit more about a constrained subset of internals.
  ```
ReactDOMInput should not set a value for submit buttons unnecessarily.

Expected true to be false.
```
 Might not be the _easiest_ first bug, but would be interesting to find out why this is failing. Requires some browser knowledge.
 Interesting‚Ä¶ What is the value in this case? Which version of IE? MSDN says the text will default to "Submit Query", so I'm guessing it's that. Maybe we just need to skip this test sometimes?
 Sounds like an encapsulation leak. Perhaps the input component should provide some sort of `value` getter instead of encouraging us to reach in and noodle with its DOM node. cc @sebmarkbage 
 Seems like a problem with the test rather than the implementation.
 Fixed by #1658.
  ```
ReactDOMInput should properly control a value of number `0`.

Expected 'giraffe' to be '0'.
```
 @chenglou - any ideas why this might be failing in IE? Might be a bigger problem with controlled inputs...
  ```
rendering React components at document should be able to get root component id for document node.

Error: Invalid target element for this operation.

rendering React components at document should be able to unmount component from document node.

Error: Invalid target element for this operation.

rendering React components at document should be able to switch root constructors via state.

Error: Invalid target element for this operation.

rendering React components at document should be able to switch root constructors.

Error: Invalid target element for this operation.

rendering React components at document should be able to mount into document.

Error: Invalid target element for this operation.
```
 ```
mutateHTMLNodeWithMarkup should mutate the document html.

Error: Invalid target element for this operation.

mutateHTMLNodeWithMarkup should change attributes.

Error: Invalid target element for this operation.
```
 I'm starting to think that full-page react isn't worth supporting. It's soooo complicated to get right and every browser is different :( Thoughts?
 I guess we should just try to power through this and see how bad it is, eh?
 #oldestBugEvar
This is how MooTools handles the `innerHTML` problem. It also effects Firefox < 4 in some cases.
https://github.com/mootools/mootools-core/blob/master/Source/Element/Element.js#L1021-L1049
 We have something like that already - https://github.com/facebook/react/blob/master/src/vendor/core/getMarkupWrap.js
 How about we remove support and throw if someone tries to do something dangerous?
 I just sent out some new diffs internally that restrict full-page rendering to only supporting a single root that never changes (ie no unmounting) and that it must be used with server rendering. This way we can avoid innerHTMLing scary things like `documentElement` while still supporting (albeit a bit "clunkily") most people's use cases for this.
 https://groups.google.com/forum/#!topic/reactjs/4jI5xe7TXzQ
  Looks like the Android Selenium server is buggy.
It's getting confused by the `waitForCondition` thing.
 `grunt webdriver-jasmine:saucelabs_android` passes routinely on Travis now, so I'm closing this out.
  ```
>> [Mozilla/5.0 (Windows NT 6.3; WOW64; Trident/7.0; rv:11.0) like Gecko][1384206538513] not ok 206 - Instance Types should throw for invalid instances.
[Mozilla/5.0 (Windows NT 6.3; WOW64; Trident/7.0; rv:11.0) like Gecko][1384206538633] # Expected function to throw Invariant Violation: Invalid prop `testProp` supplied to `testComponent`, expected instance of `Person`. , but it threw Invariant Violation: Invalid prop `testProp` supplied to `testComponent`, expected instance of `<<anonymous>>`.
[Mozilla/5.0 (Windows NT 6.3; WOW64; Trident/7.0; rv:11.0) like Gecko][1384206538639] # Expected function to throw Invariant Violation: Invalid prop `testProp` supplied to `testComponent`, expected instance of `Person`. , but it threw Invariant Violation: Invalid prop `testProp` supplied to `testComponent`, expected instance of `<<anonymous>>`.
>> [Mozilla/5.0 (Windows NT 6.3; WOW64; Trident/7.0; rv:11.0) like Gecko][1384206538766] ok 208 - rendering React components at document should be able to get root component id for document node.
>> [Mozilla/5.0 (Windows NT 6.3; WOW64; Trident/7.0; rv:11.0) like Gecko][1384206538767] ok 207 - Instance Types should not throw for valid values.
[Mozilla/5.0 (Windows NT 6.3; WOW64; Trident/7.0; rv:11.0) like Gecko][1384206538767] # Expected function to throw Invariant Violation: Invalid prop `testProp` supplied to `testComponent`, expected instance of `Person`. , but it threw Invariant Violation: Invalid prop `testProp` supplied to `testComponent`, expected instance of `<<anonymous>>`.
```
 `grunt --verbose --debug 9 --stack webdriver-jasmine:saucelabs_ie11`
 http://saucelabs.com/tests/4203eb348bb34849a41b9817bd584f8b
  This seems like a pretty good idea to me! Additionally, if you could add a unit test for this it would be much appreciated :)
 So I think we could take this even farther.

These hooks are likely used to implement some sort of animation, right?

What if `componentDidEnter()` and `componentWillLeave()` took callbacks that indicated when their animation work completed? Then we can just provide default implementations that add or remove the CSS classes and listen to the correct animation events. That way you can use ReactTransitionGroup and have pretty much infinite flexibility.

What do you think?
 For now can you just require that it be called? Checking `arguments.length` may have some sort of perf penalty now or in the future.
 Hey there, sorry for the long reply time on this.

I'm thinking about that callback parameter since maybe we use componentDidEnter() and componentWillLeave() to actually implement the animations themselves rather than rely on ReactTransitionGroup to do it. Since animations take time we'll need a callback to inform the TransitionGroup when the animation is completed (specifically for leave animations so the TransitionGroup knows when to remove the DOM nodes).

Does this make sense?
 FWIW, we just added `onTransitionEnter` and `onTransitionEnd` in c2e48740fc9d2c47eb62d9a1ab4a9372fa749087 (I have no idea if there's overlap there, but wanted to give you a heads up)
 What's the status here?
 @petehunt, what's the status on this now with CSSTransitionGroup?
 This feature is now in ReactTransitionGroup as part of the rewrite. Thanks for the API @pgherveou !
  :ship: - Thanks! Will go out with the next docs update.
  Thanks!
  cc @yungsters or maybe @joshduck
  Did you run `grunt` from the repo root? I'm 99% sure that will solve the issue. If not, reopen and we'll get to the bottom of it!
  Hey there, can you please sign the Facebook CLA so I can merge this? Thanks!

https://developers.facebook.com/opensource/cla
 We know it's annoying to sign the CLA so we tried to make it as painless as possible, the form only takes 2 minutes to fill. You only need to do it once. As a bonus, you can also commit on any facebook open source project with the same CLA :)

> On Nov 14, 2013, at 3:25 AM, plievone notifications@github.com wrote:
> 
> Ah sorry, I haven't signed it yet. Maybe somebody on your team can make that small change, I just spotted it, no need for creds (and V8 might order simple objects alphabetically in any case, I don't know, so it's mostly for consistency with other objects in that file)
> 
> ‚Äî
> Reply to this email directly or view it on GitHub.
 Totally understand if you don't want the hassle (should be painless). Thanks for bringing it up! It looks like you're right that V8 will try to optimize this a bit (according to things I've seen around the web), though it's pretty hard to prove in simple jsperf tests. Either way, nice to have order :)
 060118c7e4a9fded04ec6c254ab44d78efc8fb43
  Well that's embarrassing... Thanks for this! Looking at the spec it's expecting integers (or at least numbers) and a quick test with `data:text/html,<textarea rows="3">` shows that `$0.rows = 'foo'` throws, at least in Firefox (not in Chrome), and then putting that into React... we don't handle that error and we're left in a broken state. So what started as an innocent fix has turned into something more complicated - let me know if you're up for it.

Looking at the [spec](http://www.w3.org/TR/html5/forms.html#attr-textarea-rows) - I think we're going to want to do something like `HAS_BOOLEAN_VALUE` (`HAS_NUMERIC_VALUE`?). The spec says integers, but it has it's own rules for parsing numbers, but then it also doesn't apply it evenly (`maxLength` is also numeric but it turns out you can set it to strings and the DOM doesn't seem to care even though the spec has the same parsing rules :trollface:). Chrome takes a string value and then sets the value to 0 (at least in the inspector) but the rules for 0 say got to 2 (do not pass GO). If I'm reading [the rules](http://www.w3.org/TR/html5/infrastructure.html#rules-for-parsing-non-negative-integers) right, Firefox is actually doing the right thing for `rows` since that says to throw an error.

Going back to what we need to do - I'm thinking we have some `isNaN(+value)` check in DOMPropertyOperations? That will convert strings to numbers if they parse. I don't think we want `parseFloat` here since `7foo` should not be parsed to `7`.
 And here's a gist of some testing (done in examples/basic-jsx with this diff applied) - https://gist.github.com/zpao/227a395cb5821a0fc91b
 @syranide Can you fix or update the failing test? (I think the test is right, so something in your code probably needs to change).
 Sorry that took so long!
  There are issues with listening to touch events always... I forget what they are though. @zpao knows. But we should probably make this work with `SimpleEventPlugin` and `initializeTouchEvents()`
 @thauburger edit: there's an internal diff coming up for making onClick work without the delay.
 @chenglou Doesn't work in IE10 right now though, I believe.
 @steida We don't care about the development of Polymer though and AFAIK PointerEvents are still in the W3 HTML5 TR?
 @zoomclub Shout in #1389 if you want it to happen faster :)
 @iamdustan Very interesting, but it seems very weird if there will be nothing to replace it.
 @iamdustan Just finished reading it through, very interesting stuff. My takeaway though is that most of the discussion isn't primarily about any short-comings of PointerEvents, but whether or not browsers really should provide such "sugar".

So even if they do end up abandoning it, it may still make sense to provide _a way_ to have it in React (because the demand is real), which naturally leads to the idea of plugging in any event sugar. But it could never benefit third-party components and I feel that many (including me) would be afraid to commit to "any one" community event sugar, they tend to be abandoned on a daily basis.

An interesting alternative (perhaps) after reading through that discussion, what if one could specify event emulation modes per DOM-node, i.e, `<div onMouseDown={...} touchEventsAs="mouse" />` and it would emulate mouse-events from touch-events. There are probably flaws I haven't thought of, but it's possible that everyone could benefit and it (hopefully) wouldn't be a big strain on React.

But we'll see where it goes.
 @iamdustan I really have no idea, I have thankfully been able to stay away from touch events so far. But I imagine `event.preventDefault()` in `touchend` would prevent the cascade, but there are definitely big questionmarks as can be seen in some other issues.
  @spicyj Is this still an open bug?  The home page examples are visible without cloning.  If this issue is still valid, can you specify more specifically which examples you're concerned about?
 These examples:

https://github.com/facebook/react/tree/master/examples
 Would probably be part of a site redesign. I don't feel strongly about keeping this open though if you'd like to close it.
 No desire to close it.  I agree, it's nice when framework authors make it easy to run all the examples, and think this is a perfectly valid request.  I just wasn't sure which examples you were talking about and/or if the modern homepage satisfied the issue - sounds like it doesn't.
 The homepage hasn't changed in two years. :)
   Closing in favor of #1555, which I think covers the spirit of this issue.
  This throws a syntax error in IE8.

`build/modules/utils/__tests__/ImmutableObject-test.js:62`

``` javascript
  var testProd = function(message, testFunc) {
    // Temporarily enter production mode
    window.true = false;
    it(message, testFunc);
    window.true = true;
  };
```

I'm not sure which code is doing this transformation, but this is clearly not what should be happening.
 This https://github.com/benjamn/populist/pull/8 made it a lot easier to find this problem.
 Still happening
 Try doing `rm -rf .module-cache/` in `node_modules/react/`?
 That worked.
We should add that to the `grunt clean` task.
  I know it seems silly for such a small change, but can you sign [the CLA](https://developers.facebook.com/opensource/cla)?
 Thanks!
  I am a bit unsure about this fix since it adds an additional case to think about with respect to keying. So I would be slightly inclined to not do this, but I don't feel very strongly.
  See also #433, where this was discussed a bit already.
  Feel free to update the examples to make them more impressive :)
 https://github.com/facebook/react/commit/00adabc20dfcffb379b7f0b06fa2729ae1bff2a0
  Note that https://github.com/benjamn/recast/pull/44 has been closed as invalid for now.
 Cool, once updated versions are up in npm, update our `package.json` to point at that so we pick up those changes here. Then we can get this merged in.
 Thanks a lot!
  ![image](https://f.cloud.github.com/assets/197597/1479799/1ab7dd9a-468f-11e3-84bb-16de5395254d.png)
  doh, this got lost in a rebase
  on `renderXJSLiteral` -- we use it for another transform that we have in-house, so we'll need to leave it for now
 It looks like

```
<div>
  stuff
</div>
```

transforms to

```
React.DOM.div(null,
  " stuff "
)
```

Note the spaces around "stuff". Don't the rules that we've settled on suggest that there shouldn't be spaces here? (At least thats what the conversion tool's output suggests...)
 What's the status here?
 I think we need a solution to span-wrapping of `{' '}` (since the codemod script puts that in place to stub-out where whitespace would have been before...but is no longer after this diff).

Adding spans can break styling and externally-expected DOM structures -- so we need some kind of workaround for the transition (or maybe we bite the bullet). @syranide: Were you planning to talk to @petehunt and @sebmarkbage about fixing the spans issue at a deeper level?
 (other than that, I think this is good to go)
 This is a great summary, thanks.

> one idea is to keep a legacy version of JSX(Transform) in the repository for the time being

That's not a bad idea -- but I'd be a little worried about maintenance and having to support the old + the new transform. I say we just bite the bullet and move forward

> Also, what is your thoughts for the "codemod" tool?

I have a little CLI npm module I've packaged up (not published or checked in anywhere yet) that I've been using to codemod whole directories. We can probably just publish that and reference it in the CHANGELOG (as well as in the announcements for the next major rev cut)

Anyway, you've convinced me it's worth moving forward despite the spans problem, so let's land this damn thing already!
  Either `checkedLink` or change `value` to do the same thing as `checked`?
  Nice catch. `data:text/html,<input type="submit">` is usually "Submit" (though in Firefox it's "Submit Query" which is weird).
 Browser default, since those should account for locales.
  Thanks!
  Somewhat lame fix for #436
 @zpao are you cool with this? I had to hack around it here: https://github.com/petehunt/react-touch/blob/gh-pages/src/thirdparty/TapEventPlugin.js
 I would really like us to prioritize getting this in so we can use this stuff easily.
 I found a better way to do this in https://github.com/facebook/react/pull/627
 More like any CommonJS build system -- I've tested that PR with browserify and webpack, both worked.
 Also -- eventually I'd like to take the approach that we take the CommonJS build of these addons and package it for the browser.
  ![react - community round-up 10](https://f.cloud.github.com/assets/197597/1463039/cc857ec4-4518-11e3-947a-d3e010195e12.png)
 ![image](https://f.cloud.github.com/assets/197597/1475796/f62d9b20-4640-11e3-8cdd-0b0834277372.png)
 Looks good. I know I'm somewhat backpedaling on this but maybe after the fruit machine thing you can mention we've been in production since 2011 :)
 I'm adding this:

> Even though we weren't inspired by FruitMachine (React has been used in production since before FruitMachine was open sourced), it's great to see similar technologies emerging and becoming popular.
 :ship:ped 
  This is expected behaviour. Please use prop={number} instead
of prop=number.

On Monday, November 4, 2013, John Wu wrote:

> <!DOCTYPE html>
> <html>
> <head>
>     <title>Hello React</title>
>     <script src="react-0.5.1/build/react.min.js"></script>
>     <script src="react-0.5.1/build/JSXTransformer.js"></script>
> </head>
> <body>
>     <script type="text/jsx">
>         /*\* @jsx React.DOM */
>         var MyComponent = React.createClass({
>             render: function(){
>                 return (
>                     <div><p>{this.props.firstAdder}+{this.props.secondAdder}={this.props.firstAdder+this.props.secondAdder}</p></div>
>                 );
>             }
>         });
>         var app = <MyComponent firstAdder=1 secondAdder=2/>;
>         React.renderComponent(app, document.body);
>     </script>
> </body>
> </html>
> 
> Two numbers were passed to props, but with exception raised Uncaught
> Error: Parse Error: Line 10: XJS value should be either an expression or a
> quoted XJS text.
> 
> ‚Äî
> Reply to this email directly or view it on GitHubhttps://github.com/facebook/react/issues/468
> .
 @bhargavgunreddy Works for me: http://jsfiddle.net/9CR4n/ 
  @andreypopp is right, this is just extra GC, not a memory leak.

If you do the split/map/filter/map ahead of time (once) it'll save a bunch of allocations. Also adding a `key` prop will probably speed up the transition a bit as well: http://jsfiddle.net/X5Bnb/
 @plievone there's a little trash can icon in the lower left of dev tools. If you click it it should go down.

The GC looks at a ton of different things (like what your app is doing, memory available to the system etc etc) and I believe will optimize for performance at the expense of memory if it is available.
  @mroch did this in 351dcfed01d51dd18016d84ded4f86bddecaa7ba
  :shipit: 
  Fixes #381.

Changes of @spicyj are now in.

Apologies for the overload of commits, had some git issues :-).
 Let's ignore the window resize and whatever other events that React attaches and uses internally for now. If possible, it would be great to end up removing those entirely but that should probably be a separate effort.
 9:41:05 PM  sspi    I removed touchNotMouse, and I want to re-add it
9:41:28 PM  sspi    but I want to add it at the eventPlugin level
9:44:33 PM  sspi    that way you can set dependencies the right way, instead of having dependencies on both mouse and touch
9:48:06 PM  balpert sspi: that makes sense to me
9:48:17 PM  balpert SimpleTouchEventPlugin or something
9:51:12 PM  sspi    balpert: I was thinking more in the direction of having a useTouchEvents available within the eventPlugin
9:51:21 PM  sspi    s
9:53:26 PM  balpert yeah, you could do either
9:56:04 PM  sspi    ok
9:56:09 PM  balpert if it works, I think extracting to a separate plugin makes a lot of sense
10:04:26 PM sspi    balpert: the plugin would basically do what initializeTouchEvents does now?
10:05:35 PM sspi    which is setting useTouchEvents
10:07:09 PM balpert no, I meant that SimpleEventPlugin would never listen to touch events
10:07:18 PM balpert and if you want touch events you need to add a different plugin
10:07:26 PM sspi    so no TapEventPlugin?
10:09:10 PM balpert TapEventPlugin would depend on TouchEventPlugin?
10:09:15 PM balpert if you can do that?
10:09:19 PM balpert I didn't look at your code yet
10:09:51 PM sspi    nah, don't think it can with the current solution :)

11:02:11 PM sspi    balpert: I'm having second thoughts on the eventplugin dependencies
11:02:29 PM sspi    to other eventplugins
11:04:06 PM sspi    even with these dependencies there needs to be some mechanism to decide which events need to be loaded and which not
11:07:01 PM balpert right, it was not 100% clear in my mind when I was thinking about it a month or so ago
11:07:06 PM balpert which is why I never finished my diff
11:07:32 PM balpert :)
 Had a discussion with @spicyj about testing events to ensure that they are happening. This would be really nice to have, however I would prefer to add these types of tests within a separate PR. 
 Added a bunch of comments ‚Äî some are from me, some are from @petehunt. Thanks for tackling this!
 @yungsters  @petehunt - thanks for the review. 
 And :ship:ed! 80d7d2d0f8ec0f4f1f3c2dbe613f36bda572ce11
 Awesome!
  Would you mind rebasing on top of the following commit so it's a little easier for me to patch this and play with it?

https://github.com/facebook/react/commit/a4f8ad1bb0ef6bd7dff3483471fbfb9815538a5d
  Internally, we use [ReactTestUtils](https://github.com/facebook/react/blob/master/src/test/ReactTestUtils.js?source=c) but I'm not sure if it is exposed in the build
 This is an area of active exploration and development because you're totally right, it's not at all obvious (even to us, unfortunately) what the best way to test React components is. As @vjeux mentioned, [ReactTestUtils](https://github.com/facebook/react/blob/master/src/test/ReactTestUtils.js) is the best we have to offer right now.
 TestUtils has been exposed in addons since 0.9.
  Currently the only advantage I can think of, of using uncontrolled components, is for their lightweight syntax. But ReactLink made me wonder if there isn't a better way.

Currently:

``` js
var Uncontrolled = React.createClass({
  render: function() {
    return <input type="text" defaultValue="hello" />;
  }
});
```

``` js
var Controlled = React.createClass({
  getInitialState: function() {
    return {text: 'Hello!'};
  },
  handleChange: function(event) {
    this.setState({text: event.target.value});
  },
  render: function() {
    return <input type="text" value={this.state. text} onChange={this.handleChange} />;
  }
});
```

My proposal:
Keep controlled the same. Controlled with sugar:

``` js
var Controlled = React.createClass({
  render: function() {
    return <input type="text" value="hello" stateLink="text" />;
  }
});
```

I realize this is a bit of magic, but considering that currently we need to:
- Explain what `defaultValue` is and its reason for deviating from DOM.
- Provide an add-on (in another build) to have the benefits of uncontrolled components, which might seem a bit backward.
- Have `value` anyway.

I feel the pros outweigh the cons here. With the new format you still have two options very similar to controlled/uncontrolled, but with all the benefits of a controlled component.
 1. I don't feel too strongly about uncontrolled forms, but I think they're pretty convenient when you want to rely on the browser submit (rather than read from them in JS).
2. Really really really against any additional magic (like `stateLink`). `ReactLink` is too implicit for many of us already. A lot of times when you're looking for a bug in your React app you just need to look at the stateful components which are easily identified by `getInitialState()`. I see a lot of downsides with not a lot of upside :/
 `stateLink` is just a replacement for the current `valueLink` though. And I get the argument for listing states in `getInitialState`, but if we're already linking them with the add-on then doesn't it imply that we don't really bother with it?
 This is way more explicit

``` js
var Controlled = React.createClass({
  mixins: [React.addons.LinkedStateMixin]
  getInitialState: function() {
    return {text: 'hello'};
  },
  render: function() {
    return <input type="text" valueLink={this.linkState('text')} />;
  }
});
```
 Yeah I agree, but I'm saying that maybe dropping `text` in `getInitialState` wouldn't be too much of a problem since probably the only place it's used is in the `input`. The other thing that prompted me to suggest this is because now we have `defaultValue`, `value` and `valueLink`.
 Closing this for now!
  Nice! I did a minimal test to make sure it still works with `<input>`s (where the attribute actually has meaning) - http://jsfiddle.net/zpao/HF4mV/. But we should be making sure we still work with CSS selectors like this (which actually seems like a great way to test this whole module...)
  Let's put the `50px` into a variable so this gets updated automatically if we change the navbar height.
  For large screen sizes the nav is fixed, but for smaller ones it's not. This is obviously intentional and fine, except I noticed that, with the recent implementation of page anchors, the nav on bigger screens can hide the anchor.
  Thanks!
  Yea, making it an option probably wouldn't be terrible, though maybe it would be even better to just respect the original quoting. That way we don't have to deal with quotes... However we use `JSON.stringify` to output which always uses double quotes, so we would need to add additional processing.

cc/ @jeffmo
 Ah, true. I was thinking about prop values, not the child values `<div foo='bar'/>` -> `React.DOM.div({foo: "bar"})`. In the child case... yea there's no original quoting to preserve. I think they both go through the same path though - https://github.com/facebook/react/blob/master/vendor/fbtransform/transforms/xjs.js#L231-L233
 @spicyj it does :) I used http://facebook.github.io/react/jsx-compiler.html
 I think we can just fix the trailing whitespace issue independently. I'd argue that's a big that it ends up in there at all :)
 There's https://github.com/STRML/JSXHint btw. Is this good enough? If yes, this should be a solved issue?
 Bah probably going in in the next release? It's pretty minor.
(wow, 2015 sounds so distant)
 0.12.1 got rushed out with just the things needed to support Flow, not the couple other things I wanted to get in there. I'm thinking we might do a 0.12.2 before 0.13 for a couple small things.
 I think I'll be brutally honest and say we're really unlikely to make this configurable in the short term, especially as we're looking at changing transform pipelines. But we will make it consistent.

I'm going to close this out so we stop sending the wrong message.
  Yea, that single line logging you see there is correct at the time of logging, it's the expanded object that lies.
  Is this something we still want to solve? It seems the fix would be simple enough.
  I think that our 3 bullet points are pretty meaningless right now since they don't differentiate React from alternatives. Even if we are more declarative and more efficient and more flexible it says nothing about **how** we're different.

So I changed these. The goal is for someone to read these and instantly be able to differentiate React from alternatives.
 ping
 @vjeux approved
  Unless 0.6 comes out really quickly, we'll have a 0.5.1.

Since It's likely we'll change master in non-trivial or breaking ways soon, I'm going to use this to track PRs and commits that should be merged into 0.5-stable
- [x] 893fba8373b648fa0a1370bcd3071250136dfad4 (#438)
- [x] 0d2d3360d0cf4eeacc388e625c91c72ccb8c4190
- [x] 0ef1ca00243671a0a969af68a173669fda0783b9
- [x] fbb741febbd14bb287e42f1c802a7538a82b9e9e
- [x] ac9dd922726b5e886cada4788cf43906f18aedf5 (#423)
- [x] 280eff41f351d3c73afd7a26b8b8811eaedde73d (#450)

**Explicitly not taking:**
- 58b3ae3136e959350ece18a753392ab23ab177b6 (changes behavior of default prop usage)
 :ship: 
  I updated the JSFiddle links when we upgraded to 0.5.0, aren't they working / where did you get your fiddle link?

http://facebook.github.io/react/docs/getting-started.html
 @phou87 Thanks a lot for reporting! We'll roll this into the next release.
  **Question:** how do you use touch events with React?

**Answer:**
- Use CommonJS
- git clone
- edit ReactDefaultInjection.js to include TapEventPlugin
- npm install; grunt
- add React.initializeTouchEvents(true) to your code in the right place

This sucks. Instead I think we should just either put TapEventPlugin on addons _or_ create a react-mobile build which does all this by default.
 Tap is not a standard event, so we're probably going to rip it out of the core and let people detect taps in user land.  The current implementation probably needs a bit of cleanup anyway, to detect things like double taps and long holds.

Anyway, it's only 100 lines of code, available here:
https://github.com/facebook/react/blob/bef45b0b1a98ea9b472ba664d955a039cf2f8068/src/renderers/dom/client/eventPlugins/TapEventPlugin.js

If someone wants to fix it up and publish it as an external library/module, that might be useful to people.
 We don't have any supported solution for this. In general we don't support defining custom event types for the same reason we don't have any global configuration: because it makes interoperability difficult (if you develop a component that requires TapEventPlugin, it won't work for someone who doesn't load it).

My best recommendation if you need this is to build a `<Tappable onTap={}>` component or similar completely in user space without depending on React internals. It should also be possible to fix up react-tap-event-plugin for v15, but we don't support that and can't guarantee that it will still work in a future release.
  Turns:

var obj = {x:1, t:function(){ return "2"; }};

&lt;p data={obj}/&gt;

into:

&lt;p data-x="1" data-t="2" /&gt;

Possible improvement areas:
- call function with additional parameters (like propTypes)
- add invariant tests
- add support for attributes besides data
 `data` by itself [already exists](https://github.com/facebook/react/blob/b0455f46709fca94da0b6126b719d6dd07605e65/src/dom/DefaultDOMPropertyConfig.js#L57). Wonder if there's any way to circumvent it because this is a pretty neat idea.
 Does dataset work?
 Then this would actually be consistent with things like `className`. +1 from me!
 Should I also add support for aria={object}?

Edit: seems like a bad idea as aria has a limited set of supported variations. Also no relation to the DOM like dataset has.
 After talking with @yungsters, I'm not convinced yet that this is a good idea. I think it _could_ be useful if `data` is used widely, but it still has a pretty minimal usage across the web. If we do decide we want this, there are a number of things about the implementation we'll want to change (this should ultimately work much more like the `style` prop).
 Close please.

It would be mainly for consistency with the DOM, which we aren't anyway.
Also, most use cases could be solved with normal React code.

On Monday, October 28, 2013, Paul O‚ÄôShannessy wrote:

> After talking with @yungsters https://github.com/yungsters, I'm not
> convinced yet that this is a good idea. I think it _could_ be useful if
> data is used widely, but it still has a pretty minimal usage across the
> web. If we do decide we want this, there are a number of things about the
> implementation we'll want to change (this should ultimately work much more
> like the style prop).
> 
> ‚Äî
> Reply to this email directly or view it on GitHubhttps://github.com/facebook/react/pull/435#issuecomment-27263413
> .
 Cool. I'll close it out for now and if we decide in the future we want it, we have something to start from. Thanks for giving it a shot!
  #487 is now merged and this is no longer needed :) Thanks @tommyh for the work on this!
 This was different than #487. This allowed functions in mixins to be called as part of custom proptype
 (My #849 includes this change.)
  I'm pretty sure we're never going to make this happen. We've moving towards a more static world for proptypes so using `this` doesn't really make sense.
  You can do it so: `this.refs['syntax.' + etc]`
This gets the job done with slight modifications.
 I don't think #221 is being considered now. I was saying you could loop through them and check for the `syntax.` word but this isn't optimal. The thing is, you shouldn't be looping through refs to manipulate the components. What are you trying to do?
 Nothing has happened on #221 recently, but I wouldn't count it out yet.

I'm not convinced we want to make this sort of change to refs. By using a string we don't need to have complicated logic and we don't need to actually parse it, just use it. If somebody want's to use a period in their string, why not let them. Also, we don't really have the guarantee that the period is a _real_ separator, `ref="version.1.0"` might actually be intended to be parsed to `this.refs.version['1.0']` but it's actually parsed to `this.refs.version['1']['0']`. and then there's the problem of `ref="version.1"` which would get parsed to `this.refs.version['1']`, and you can no longer add anything else under that, but it wouldn't be totally obvious. By keeping it simple we keep surprises to a minimum.

The difference between refs and components (#221) is that we don't have any implied semantics for `<Component/>`, in fact simple namespacing there follows naturally from everything we have claimed, namely that if it's not an HTML component, we just assume it's a function in scope, since that what we transform to - `Component(null)`. In fact there's nothing stopping you from writing the transformed JS yourself and using namespaces - `MyApp.Component(null)`. For props, we very much imply that anything between quotes is a string and will stay a string.

So based on that, I'm inclined to wontfix this...

I would actually suggest maybe going in the opposite direction and storing a list of refs in an object (maybe namespace that), then iterating over that object instead of the refs, and seeing if that value exists in `this.refs`. Something like this (with 2 options...):

``` js
var SYNTAX_REFS = [
  'syntax.javascript',
  'syntax.html',
  'syntax.css',
  'syntax.c++'
]

// or maybe
var REFS = {
  syntax: {
    html: 'syntax.html',
    ...
    'c++': 'syntax.c++'
  }
}

var Editor = React.createClass({
  componentDidMount: function() {
    SYNTAX_REFS.forEach(function(ref) {
      if (ref in this.refs) {
        var editor = this.refs[ref];
        editor.prettify().colorize();
      }
    }, this);

    // OR if using REFS

    for (lang in REFS.syntax) {
      var ref = REFS.syntax[lang];
      if (ref in this.refs) {
        var editor = this.refs[ref];
        editor.prettify().colorize();
      }
    }

    this.refs.plain.prettify();
  },
  render: function() {
    return (
      <div id='content'>
        <TextEditor ref='syntax.javascript' />
        <TextEditor ref='syntax.html' />
        <TextEditor ref='syntax.css' />
        <TextEditor ref='plain' />
      </div>
    );
  }
});
```
 @shripadk I'm going to wontfix this based on the above. I appreciate the discussion though and love hearing ideas people have for improving the way React works. Keep them coming :)
  I learned about `gq` in vim and 10 minutes later I realized I'd done all of our docs.

I'm not sure if we should do this - it might end up making it more awkward in the future to edit docs. But I wanted to show it to people before I made that decision myself.
 ![image](https://f.cloud.github.com/assets/197597/1338257/c269a71a-35e3-11e3-9977-05b966c95284.png)
 Yea, I usually break at sentences when I write HTML. That's probably a pretty reasonable middle ground. I know this got out of hand relying on vim here. I don't necessarily agree with all the formatting it did, and I suppose I can't depend on all of you using vim and formatting before committing :)
 Not going to do this but if somebody wants to go crazy and split to sentence-per-line, that might be fine.
  :thumbsup: thanks!
  @Charuru Jade parses strings like most other templating engines. React doesn't, since under the hood the HTML-like tags are [desugared into function calls](http://facebook.github.io/react/docs/jsx-in-depth.html). So I don't think these two work together.
 If you would like to write a parser that allows you to write Jade in JS and desugars to plain JS, be my guest. I think it will likely prove difficult. One advantage we have with JSX right now is that we've added some simple semantics on top of an existing JS parser (esprima) and use that to convert to vanilla JS. You could probably make that work, though I'm not personally convinced it's worth the effort. Regardless, we won't be adding support for that but feel free to explore it yourself!
 Not correct anymore! You can use this to do it: http://facebook.github.io/react/html-jsx.html

However I certainly would not recommend using this at runtime.
 React team has no plans to implement template engine integrations, whether Jade or any other system.

As communicated above, we see plain JS (or in case of JSX, superset of JS) nature of React components as an advantage rather than a downside. If you feel strongly about it you are welcome to create a Jade-to-createElement transform but we will not be working on this.

Adding +1‚Äôs to this issue or asking to reopen it doesn‚Äôt help anyone and has an unfortunate side effect of clobbering everyone‚Äôs notifications. Please don‚Äôt do this.
  Awesome. Thanks a lot!
  Alright, that's unfortunate.

And how about using Google Closure Compiler externs? https://developers.google.com/closure/compiler/docs/api-tutorial3?hl=nl&csw=1#externs <- seems like the best solution at first glance.

Note: not a Google Closure expert here. 
 I'm going to be inclined to say no to anything that forces `React.DOM['a']` though I might be able to get on board if that's optional in the transform for GCC compat.

This doesn't add _that much_ to the build, but if we take it, it would be 10% of the increase over 0.4. I'm inclined to leave this be until after we ship 0.5. I'd like to get @jordwalke to take a look and see if he has any other crazy ideas here.

```
   raw     gz Compared to last run
 +1259   +413 build/react.js
 +1108   +405 build/react.min.js
```
  Paging @sebmarkbage
 Thanks!
  Revisiting #364 #114

(sorry for the extra pull request - used Github wrong the last time)
 Incomplete.
 What's the status here. Do we want to go forward with this change?
 This PR is 3 months old. I'm going to close it out. Feel free to re-open the issue.
  #57
#28
 Is there a way to use React as a defined module instead of as a global? I know we have the UMD wrapper on there so it should be possible. I'm not familiar enough with requirejs though.

If that's possible, then let's update for that. Otherwise this is fine.
 Tnx @ssorallen for helping out here! I will adjust this PR somewhere this
week :-).

On Wednesday, December 11, 2013, Ross Allen wrote:

> You can also include the require-jsxhttps://github.com/seiffert/require-jsxplugin to transform JSX on the fly in the browser. The setup explained in
> the plugin's README works, but it might complicate this example.
> 
> ‚Äî
> Reply to this email directly or view it on GitHubhttps://github.com/facebook/react/pull/417#issuecomment-30350947
> .
 Ping ping ;)
 This PR is 3 months old, I'm going to close it. Feel free to re-open it :)
 @akeelnazir I think the best thing would be for you to create a complete repro case (ideally a clean repo or gist with necessary files) and follow up in a new issue.
  Referring to #276:

I think we should remove the `rootNode` being passed to `componentDidMount` and `componentDidUpdate`. For two reasons:
1. It's unnecessarily touching the DOM. This makes the separation of React and DOM harder, something I've seen being discussed.
2. It's inconsistent with other lifecycle methods such as `componentWillUnmount`. Since we're not adding `rootNode` to it due to reason 1, the only way to stay consistent is to remove it for the other two methods.
3. It makes adding new arguments harder in the future.
 Ops, added.
 Bump, this is about to bite us with the next github sync since we added a param to `componentDidUpdate()`. I think we should remove this in 0.6 @zpao 
 We still need to document it :)
 I'm actually doing it that's why!
  Let's warn on `undefined` (or on anything that's not a function maybe?).
 As mentioned in PR, done!
  :exclamation: **Don't Merge Me** :exclamation: 

I'll keep updating this as new authors come in right up until we release 0.5, but I wanted to open this up to give everybody a chance to specify the name they want to show up in the `AUTHORS` file. It looks like some people had names set up in their `.gitconfig` (or were internal authors), but for others it seems your github username was used. So if your name is on this list, let me know what you'd like to see listed!
- [x] @SanderSpies
- [x] @Samangan
 Sander Spies
  This has been open for a while now. It's briefly mentioned in JSX Gotchas but not in references. Where would this go in references?
 #675 
  We often refer to it but never did actually explain it.

http://fooo.fr:4000/react/docs/diff-algorithm.html
 I wonder if we should include the terms "virtual DOM" or "reconciliation" somewhere in here. Maybe change the title to "How the Virtual DOM works"?
 I don't feel strongly about this and these docs changes aren't going to block 0.5 so we can take this later
 I'm going to update this when I have the time. This doesn't need to block 0.5.0
 @plievone: Sorry for replying a month after :)
- Does the recent change of checking owner too affect this, or is that just an internal change

If the owner is different then the two elements are considered different. This was only added recently though. This is an edge case though, you don't often change the owner in practice.
- How are attributes related to event delegation reconciled

Since those are entirely managed by React they don't really have to be diff'ed. React just use the latest rendered version of the function.
- How are deep prop changes handled, for example if there is a large prop object on the top level with only a simple change that affects a component deep down in the tree, is the whole virtual dom tree rendered first, and only then the diffing starts?

Props do not affect the diff algorithm. React only looks at the component class, if it is the same then the two elements match.
- Do you have some perf numbers or suggestions whether it is ok to update the top props like this many times per second in a gamelike way, even if the changes are small (such as some visible counters somewhere deep in the tree)?

We are building out our perf logging internally right now. Hopefully we'll be able to share some data soon. In order not to re-render the entire tree every time we override `shouldComponentUpdate. It looks at the prev and next props and is able to tell wether it should or shouldn't re-render. If you have immutable structures this check is essentially free (just an object comparison).

By doing that at key places, you can get 10x perf improvements without changing the way your app is structured.
 ![react reconciliation](https://f.cloud.github.com/assets/197597/1796887/049dd0d2-6a93-11e3-99b4-94d89789c728.png)
  @piranha could you post some simple instructions for getting a basic example running with closure? I'd really like to help with this.
 @piranha `resultList` is populated out of order by the line `resultList[resultIndex] = renderNode;`, but should end up being a dense array of the same length as `markupList`. At least that's the idea.
 Thanks!
 Thank you!
Did you resolve all your issues with GCC?
  Good to go. @zpao next week you need to show me how to properly accept pull requests and push them to gh-pages so I don't have to bug you all the time :)
 Thanks @mcsheffrey - I bet this explains why my feed reader showed a broken post the other day.
  Sorry for the delay! I pulled this in internally and it should be a quick review, then we can get this merged.
 Thanks a lot! Welcome to the contributor list :)
  Should be as simple as making sure we include the polyfills we document http://facebook.github.io/react/docs/working-with-the-browser.html#browser-support-and-polyfills
 Eh, not really intentional, just never bothered to do it. Looking back it's a bit silly for us to say that we work in IE8 but not prove it.
 Hmm, it would appear this won't be possible so long as we use JSXTransform on the site. We could fix the NodeList -> array issue, but we won't (and shouldn't try to) make changes to esprima to make it work (I think it's mostly using "reserved" words as keys.

I guess we can turn this bug into "include polyfills, make sure things works as well as possible, provide some warnings if using IE8 about the problem"
 Correct. I just tested this myself with the zip I emailed to you - it's online for now at http://playground.zpao.com/react-tutorial-master/
 0.8 is out with #484, so this should be even easier to jump into.
  If OSX didn't ship with Ruby 1.8.7, this wouldn't be a big deal, but it does and I would rather not make everybody jump through hoops to be able to contribute to documentation (and see what they're contributing).

Right now, even when using 1.8, sanitize has a nokogiri dependency that requires Ruby 1.9.2. I think there's probably something that could be done in those projects to fix this so feel free to take that path.

This dependency was introduced with #360.
 :+1: 
  @sebmarkbage @spicyj is this still relevant after refs changes?
 See https://github.com/reactjs/react-future/issues/19#issuecomment-64921792; after that change it should be easy.
 [React.cloneElement](https://facebook.github.io/react/docs/top-level-api.html#react.cloneelement), so this seems solved now.
 We don't have a solution for adding a ref to an element with a string ref, but otherwise yes.
  See http://jsfiddle.net/nbJVN/

Return a string from `getInitialState()` and call `setState()`. You get this amazing error message:

```
Uncaught Error: Critical assumptions about the merge functions have been violated. This is the fault of the merge functions themselves, not necessarily the callers. 
```
 We should probably add an `invariant` that whatever is returned from `getInitialState` is in fact an object.
 Invariant all the things :)
 This will happen whenever state is anything but an Object (I think there is a check in there for arrays). Since we use merge it needs to be an object, arrays are no good either. 
  If a file has some Windows line endings in it the line numbers in the traceback are incorrect.
 Off by one? Is there a pattern? This is likely something that actually needs to be fixed in `jstransform`.
 It was off by a few -- I think he had a mixed file. "Save with unix line endings" fixed it.
 Can't reproduce with Windows line endings on my OS X machine or in Windows 7, so closing.
 I can't repro with mixed endings either.
  When running `jsx` with no arguments in the Windows shell (react-tools 0.4.1, node v0.10.18), you get:

```
events.js:72
        throw er; // Unhandled 'error' event

Error: spawn ENOENT
  at errnoException (child_process.js:980:11)
  at Process.ChildProcess._handle.onexit (child_process.js:771:34)
```
 cc @benjamn - this is likely commoner
  @jonase reported this issue on IRC. He updates the x and y attributes of a `<rect>` inside of an `<svg>` but it doesn't move the rect around.

Repro: http://jsfiddle.net/vjeux/3X4Xb/1/  ( Both on master and 0.4.0 )
Click anywhere on the screen, it should move the rect but doesn't

cc @sebmarkbage 
 Should be good to go.
  :thumbsup: Can you tell that nobody has actually used `exec`?
  React will re-use the component that was there since it's the same type and at the same position in the tree. This is intentional for many reasons (speed, memory, etc) but since you assumed the opposite, I understand where the confusion is coming from. Since the component is being reused, `getInitialState` won't be called again, so you won't be re-setting `this.state.color` like you do during component initialization. React does provide a hook here for you though - `componentWillReceiveProps`[(docs)](http://facebook.github.io/react/docs/component-specs.html#updating-componentwillreceiveprops).

Now that said, I think you'll want to carefully consider the implications - you're controlling your component from multiple places now which can get messy and make things a bit harder to reuse. I don't know the full scope of what your application is doing so maybe it'll work out great for you. I noticed though that you take an alternative approach for selection, passing a callback and leaving it entirely up the to prop (you set an initial state in `Message` but don't use it).
 A lot of the quirks of React come from our desire for speed. In this case, if we threw the child away just because a property changed, we would also need to remove the DOM node, then create a new one that was virtually identical except for one attribute. All of that is expensive and slow. Part of React's philosophy is that data should be able to flow through your application so if you have top level data changing frequently (maybe a backbone model or something) then you really want to minimize the set of things that change down the line from there.

Hopefully that helps a bit. If you have more questions about it, this is a great question for the newsgroups and could probably be made into an interesting blog post.
 I'd like to add that I used to have the same concern as you, however if the props themselves constituted the "identity" of a component then we'd always throw a component away whenever data changes. Not only is this slow, it also will destroy e.g. form inputs / selection position.

In many cases reading from `this.props` in `getInitialState()` is an antipattern. If you're computing a value from `this.props` in `getInitialState()` when `this.props` changes the state value will be out of date. Additionally this means that the state you're storing on `this.state` is not actually the minimal representation of the component's state.

Instead you should try to avoid reading from `this.props` in `getInitialState()` and instead compute the value inside of `render()` based on `this.props` and `this.state`. That will usually do what you want.

In your particular use case notice that the minimal set of state needed is `selected` in `MessageList`. Your `Content` component should instead take a callback that "asks" the `MessageList` to change its selected state. Does that make sense?

@chenglou is going to document this.
 One other thing: you can override the identity by setting a "key" prop on the component. 
 If you just tweak a style attribute, we'll only mutate the style attribute. We use keys and component class as a heuristic to indicate that we want to blow away a whole subtree and replace it with innerHTML which is faster than dirty checking the rendered markup and doing many individual DOM mutations. This heuristic is actually quite effective in our experience.

@vjeux is working on a blog post about this.

Telling a component to change is indeed not great practice, especially with refs. However, in React data only flows down the tree automatically. In order to flow data back up, you pass a callback to inform the top of the tree that there was a data change (we now have some sugar called `ReactLink` to make this a bit more streamlined). The reason that we do this explicitly is because data fundamentally flows one way in von neumann machines and if you don't make the data flow explicit we've found it becomes very hard to maintain.
 [componentWillReceiveProps](http://facebook.github.io/react/docs/component-specs.html#updating-componentwillreceiveprops) allows you to hook into an update with new props. You can use those to setState.
  Something about "only a ReactOwner can have refs" -- it's not intuitive.
 Would love to add you to the contributors list! :)
 @bitshadow something along the lines of: "Only a ReactOwner can have refs. This usually means that you're trying to add a ref to a component that doesn't have an owner (that is, was not created inside of another component's render() method. Try rendering this component inside of a new top-level component which will hold the ref."
 @desmondhume That makes no sense, there aren't no refs in your example code. The error is originating somewhere else in your case. Invoking `<Comp ref="foo" />` anywhere but as a result of `render()` will cause that error to be thrown.
 @desmondhume NPM has probably installed two separate React's for you, and the module requires it's own.
 > I'm no longer completely new to react, but I still keep running into more and more stupid barriers that have no reason whatsoever to be there, other than someone's idea of "separation" of something

I‚Äôm not sure the problem you have is due to ‚Äúsomeone‚Äôs idea of separation of something‚Äù.
Perhaps it‚Äôs a valid technical limitation that exists for a reason. Or maybe this is something we could fix!

In such cases, rather than write a comment in a tangentially related thread, it would be more productive to create a new issue describing **what you were trying to achieve** and how React gets in the way of that.

Maybe we can help you by finding a simpler way to achieve the same, or maybe your issue will help us find a better API! Unfortunately this thread is not really a good place for this discussion because it‚Äôs not clear what you were trying to do, and your feature request does not correspond to the issue being discussed.

Would you please create an issue describing your use case and the problem with some code snippets? Please believe me that nobody here wants to put barriers in front of you, or to force you to separate anything out of spite :smile: . Thanks!
  It's already documented in the [Dom Differences](http://facebook.github.io/react/docs/dom-differences.html) section.
 If this helps, this is will be an entry to the upcoming cookbook we're making:
https://github.com/mcsheffrey/react/tree/feat-documentation-cookbook/docs/cookbook

Those are small snippets of React tips that you can browse through in a few minutes. Small documentations that might be missed. Roadmap (here)[https://github.com/facebook/react/wiki/Cookbooks].
 I think that it may be helpful to link to the Dom differences page from jsx gotchas, no?
 ^ Done.
Btw, just noticed that Custom HTML Attributes is in JSX gotchas as well. Shouldn't they be in DOM Differences also?
 @yazaddaruvala Thanks for taking a go at this! Definitely keep sending things our way as you find weak points in the docs.

I think for this, we'll go with what @chenglou is doing to link to the document since it's really React, not JSX.
  My convos with the Chrome team indicated that listening for mousewheel kills some optimizations (agh). We should create a mapping of synthetic event -> set of real events to listen for, and attach listeners only when we need them. The initial diff doesn't even need to worry about removing the listeners, but if we did I think we should do a periodic "gc" of the listeners rather than doing it when the last listener is removed since it could lead to thrashing.
 Picking this one up.
 Sweet! I think this will be a big win. Definitely keep us up to date on progress :)
  I really like our `ReactLayersMixin` plugin and we should open source it. It allows us to implement not just the `render` function, but also the `renderLayers` function. The `render` is the same as its always been (describe your structure at _any_ point in time. The `renderLayers` API allows you to describe your modal _layers_ at _any_ point in time. So that means you can open and close layers as a function of `props`/`state` just like your `render()` function can "react" to `props`/`state`.

Assigning to @yungsters who mastered the React/Layers stuff on FB's stack, but @petehunt also has great experience using and building out layers integration with React. So whoever has time/need.
 FB layers has so many internal deps that we don't even use them at IG. Instead I suggest we open source the react layers stuff plus the light IG shim. You don't get the nice behaviors but the value for the community lies mostly in the architecture IMO.

@yungsters if we redid layers today would we do it any differently (ie I think we could do it with composition)? This could be a nice greenfield opportunity. 
 To be honest, I don't know if I would have done anything that differently. The Layer abstraction has held up really well ‚Äî we have been able to extend it and make improvements over time without much code decay.
 @yungsters yeah Layer is awesome -- what I'm wondering is why we use a mixin rather than composition to hook it up to React.
 I guess I'm not sure what you mean by using composition to hook Layers up to React. Are you asking why we use `renderLayers` instead of returning the `<Layer>` components in `render`?
 Yeah
 Layers are not inherently anchored to any position in the DOM. For example:

```
render: function() {
  return <div><button>Show Dialog</button><Dialog /></div>;
}
```

It does not make sense for `<Dialog />` to exist in the returned tree. What we actually want is for `render` to return the subtree as well as a list of Layer components.
 That makes sense, but the return value for renderLayers() is a little confusing (I've never used multiple layers in a component before), and it's not clear at first glance that it follows React's normal data flow.
 When I designed `renderLayers`, I debated whether or not to allow returning a single Layer component. However, I did not want engineers to have to learn something new just because their use case requires more than one Layer component.

Also, I felt like it was not too painful to have to return a map with one key. Keep in mind that at the time, this was the standard way of passing in children with keys into a React component.
 So I think that if we had frags I wouldn't mind putting the <Layer> components in the render() method. While it would be kind of weird that it is not anchored to the DOM, if we had frags we would have precedent for components that don't render to anything in that place in the DOM and it would just be 1 paradigm to learn.
 I would not be strongly opposed to that, but I don't think it makes the code easier to read. It makes the following questions harder to answer:
- Does this component render any Layers?
- Is any given component returned by `render`a Layer component?
- Does this component render into any non-Layer?
 I think it's odd to return things in the `render()` output that don't exist in the physical `render` tree. A component that has layers has the ability to have _multiple_ distinct render tree roots. The `ReactLayermixin` in FB reflects that - but if the return value is too confusing, we can constrain it a bit - that should be very easy to do - we would just require that a single component be returned and modify existing code use. If we did allow them to be returned within frags, it would make sense that they are required to be at the top of the render tree - nothing deeper, and I'd probably be interested in making use of a more general abstraction that solves not only Layers but also other cases when you want a DOM subtree to actually exist on another part of the page, yet be controlled by your component. Think of it as a "Portal" to another part of the page:

But even just something as simple as our current `ReactLayerMixin` would be quite awesome. If released as a separate project, I wouldn't even mind bringing in a ton of extra JS resources. Pete, we could also just open source the Insta one quickly too, but I'd rather make it conform to `ReactLayerMixin` until we get frags, thoughts?
 To be clear we do use ReactLayer and ReactLayeredComponentMixin at IG, just not any of the FB layer behaviors or Layer impl itself (yet), but they are API compatible for FB layers and behaviors by design. I am in favor of bringing all that to open-source, just want to make sure that we think about making any API cleanup before doing it.
 Just spoke with @petehunt. Instead, we will publish a blog post with a rudimentary layer implementation and `ReactLayersMixin` that demonstrates how such a system would be built.
 Closest thing available is http://khan.github.io/react-components/#layered-component
  It may be a bit hacky @brianr but you managed to find your way around core pretty quickly. Let me know if you're interested in some other tasks :)
 @spicyj it looks like you're emptying content and then may put new innerhtml or text into it. This would be 2 dom mutations. Possible to make it one?
  @sbezboro reported the following issue on IRC:

http://jsfiddle.net/vjeux/8vZ57/1/ (Both on master and 4.0)

The repro case is:
1) Render `<div dangerouslySetInnerHTML={{__html: '<b>HTML</b>'}} />`
2) Render `<div>Text</div>`
3) Render the same as 1)

The div has its innerHTML empty instead of `<b>HTML</b>`.

I don't really know what's going on. @jordwalke, @petehunt can you guys look at it?
 What happens if you change step 2 to a `span` instead of a `div`? It works, right?
 I just reduced the test case to 19 lines.
 @petehunt: yeah changing 2) to use a span works as expected
 If anyone wants to look into this, the bug is probably here https://github.com/facebook/react/blob/master/src/core/ReactNativeComponent.js#L280
 @brianr: I cannot reproduce what you are seeing: http://jsfiddle.net/vjeux/FwvMt/ It also bugs if I use a different string
 @adewes @cdujeu @LeZuse If any of you can post a simple repro case showing the broken behavior here, I'd be happy to take a look at fixing it.
 @LeZuse Thanks. This is the same issue as #1232. No fix currently, but using the key as a workaround is fine and I'll see if we can fix this sometime.
 If anyone is still seeing issues on 0.14, please make a new issue with a simple repro case.
 Reading `.innerHTML` out will rarely give you what you put in because the browser does various kinds of normalization on it. If you can repro with a standalone example though I'm happy to take a look.
  :+1: 
 Hey @danielmiladinov! I've pulled this in our internal code review system (I know, it's annoying) and once it's accepted there I will merge. Can you please sign our open-source CLA at https://developers.facebook.com/opensource/cla and comment here when you have? That way I can just press the merge button when it's reviewed. Thanks!
 Thanks!
  Alright, you've got a bunch of different things going on here. Let's make this only about running the tests, then split out the lint & global fix into separate PRs.

And then I'll CC @benjamn to figure out how the testing bits should work. I'm sure we could make that test run only here and not internally. Then we'd at least know sooner when we break things, even if we don't necessarily catch it internally.
 @benjamn - Seems fine to me. Can you handle the rest of bringing this in?
 Will do!
  8f15eea910c097893c7bdc24725cf7ceff93cf32 introduced a couple uses. We need to fix them because
1. `global` isn't actually available (though we need to be careful about using `window` directly as well - 458836abd3e74fce7addfef3749391176cc72085)
2. `document` breaks server rendering - https://github.com/facebook/react-page/issues/28
 84dea7e971adecbc9c5a06f6500fffb84065d943 fixed some of this.
 +1 @spicyj 
 Closing this out - no need to keep the general issue around.
  Ok, so I think you've gone down the wrong path a little bit here. What we want is not to make any change if the attribute is already a string, but ensure that other types are converted to strings.

One important thing to remember is that `attr="whatever"` is _always_ a string. `attr={whatever}` will treat `whatever` as a JS expression and it will get evaluated. `attr="{whatever}"` is likely a user error, but should end up in the DOM exactly like that.

I put together a little fiddle with some examples of cases that work as expected and others that don't - http://jsfiddle.net/zpao/e4fEk/2/
 We're actually going to want to update several tests and maybe write some new ones too. That one failing test is one that needs to be updated.

It might actually help to update and write tests first here to establish behavior before diving too much into core.
 These tests are good. It would also be nice to see a test focused on a non-form based input, but we can always revisit that.
 Wrote some code to check how everything was working, but quickly noticed that we are now missing situations like:
- &lt;button&gt;{object}&lt;/button&gt;
- &lt;button&gt;{true}&lt;/button&gt;

Would be nice to also have this in.

Also: I seem to break the travis build :(
 Yea, we're not going to deal with those now. I would like to avoid the children case entirely here (with the exception of textarea because we have controlled components there.
 Thanks for all the hard work here @SanderSpies!
  Let's package up a separate build that includes `ReactTransitionGroup` (anything else?) as `React.addons.*`. This would displace the current react-transtiongroup.js build.
 `cx()`, `StaticContainer`, `DOMContainer`, `ReactComponentWithPureRenderMixin` were also mentioned.
 Which do we _actually_ want? `StaticContainer` and `DOMContainer` don't exist here.
  Using `<script src="app.js" type="text/jsx"></script>` with a file that has windows line ending (CRLF), the following messages happen:

In Chrome:

```
Uncaught SyntaxError: Unexpected token < JSXTransformer.js:8479
```

In Firefox:

```
SyntaxError: syntax error
```

We should detect CRLF ending and throw a real exception or warning instead of eval'ing the non-transformed file.
 I have a PR open for this, just need to apply it to jstransform

cheers,
Paul

On Sep 22, 2013, at 11:03 AM, "Jonathan Jacobs" <notifications@github.com<mailto:notifications@github.com>> wrote:

This seems to be a problem in the jstransform library, the problem begins with the docblockRe expression. Catering for \r\n in this expression allows the parse to find the JSX docblock and continue with the rest of the parse (which seems to trim strings, presumably removing the trailing \r.)

‚Äî
Reply to this email directly or view it on GitHubhttps://urldefense.proofpoint.com/v1/url?u=https://github.com/facebook/react/issues/366%23issuecomment-24886972&k=ZVNjlDMF0FElm4dQtryO4A%3D%3D%0A&r=laHZhPsrTTGL9mHVyUC%2BICFnZxZCH4LNzfo%2BOgrHdsw%3D%0A&m=CLopvf7s9m65pJyLmahetLyYhw2ijYcbPWdcfG3p7is%3D%0A&s=954f1aa607e1d3be7833b26b0ac2bdabecf1cd9ae3901cde5f5cbaf9d6e22b8c.
 We should get this in the next jstransform update.
  2b7a7599bb06f5cbcf01803fe1ae264b2b07d425 added support for onSelect.
  I'd really like to see this parameter passed in at the transformer level eventually (and not specified in the docblock altogether).

However, this particular transform (transforms/react.js) is very much react-specific though...so I can't think of any issues with it assuming that it needs to use 'React.DOM' as the default case.

Let me patch this locally and play with it to see if I can come up with any edge-cases though before I accept.
 Any further discussion should go in #418.
  I think it might be better to put these under `/cookbooks` instead of putting more under `/docs`. What do you think?
 Hmm, I might have been sleep-talking, or maybe it wasn't me. Either way, let's tackle that problem if/when we get there and keep front matter in and not add any Grunt dependency.
 Ok, I've been slowly digesting this over the past few days and here are my thoughts (some we talked about):
1. Let's rename this "Tips" or something. Since we deviated from the cookbooks format, it feels a bit disingenuous to call them that.
2. We should make sure we keep filename, page title, and sidebar link title in sync, at least for this first push. I think they all started that way but with tweaking they've fallen out of sync. Also, make sure titles are title-cased (I noticed it mostly in the sidebar).
3. Feeding off 2‚Ä¶ if we go with the titles we have in the files, I think some will span multiple lines in the sidebar. We've avoided this so far because it's a pretty bad experience. I'll leave it up to you to make the decision on what happens here.
4. The order of entries is seemingly random. Style is talked about in 2 docs but they're split by several other unrelated docs. Let's bring these together. On that note, if the leading numbers on the filename aren't helpful, feel free to get rid of them.
5. That left nav has gotten really long. I don't think this is a problem for you to solve but it might be time to bring in some JS and get some collapsing going.

I'm going to do a pass through and tweak some grammar (curse my newspaper editor past) and send a PR over (hopefully tomorrow), but I think we're _almost_ ready to merge this in and get it out into the world!
 1. If we settled on calling it "tips" I'm fine with that.
2. Fixed in a new PR!
3. Ehh... ellipsis? Maybe not the greatest idea. Changing the spacing would be fine.
4. The numbers do indeed help us for keeping tips in order, but I'm not sure how much they help beside that.
5. Whatever we do now is a temp solution; collapsing still won't be enough in the future. I'll discuss more with @mcsheffrey.
 I just opened https://github.com/mcsheffrey/react/pull/20 for you with some edits. If you like them, then lets get this in :)
 Thanks for all of the hard work and patience!
  `autoBind` is deprecated (bound b default), what's wrong with the app?
  This gives markdown headers an id so that we can link directly to
sections of our docs. This is better than the alternative of adding them
all ourselves.

I think this is better than what @SanderSpies added in #359 (sorry!) and is more maintainable. I tried switching to a different markdown parser (maraku) but it struggled with some of the things we do and I think this is _pretty close_ to what maraku does. I'm actually going to take a look at what it does and maybe get inspired... with fewer additional dependencies.

Don't merge me yet.
 Accepted :)
  Yeah - can you imagine if people thought it was okay to compile JSX inside of the browser! Awesome. Not sure the markdown anchor belongs in this PR though?
 :boom: Thanks!
  We currently listen for `DOMCharacterDataModified`, I think only so that we can make onChange work with contenteditable. Apparently this can be expensive so we should look into replacing it with a [Mutation Observer](https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver).

Obviously the API will be different (and observers get batched) so we may have to build some abstractions in here to make this work. I think that should be relatively easy with our synthetic events, but haven't looked into it.
 I would test the performance of adding a mutation observers to the top level of the document. I've heard they can be very slow, and I suspect adding them to the top level may be even worse than adding them to specific nodes.
 We're just going to remove this event entirely. We only had 1 caller internally and I can't find any on github. If we need to make use of mutations in the future, we should use observers instead of events.
  We've talked about this for a while and there's too much going on at the moment for this to actually get merged in today. Apart from rebasing, it should be perfectly safe thanks to @providesModule, all I've done is move files around and rename modules.

This was a plane hack but the end goal of this is something we've talked about before, where we can truely separate the core parts from the platform implementation. All of this is a step towards the goal of a minimal public API that works everywhere we need it to.

I obviously didn't "finish" and even where I left off here wasn't done (eg, ReactIDOperations is still very DOM specific), but I wanted to get eyes on this and see if we can start moving in this general direction.
 Crazy suggestion: https://github.com/erichocean/blossom
Page rendering using canvas.
 Going to close this out, but want to come back to it. The branch will live on (and get rebased eventually)
  What if we checked for truthiness first? I know this doesn't fix the `undefined` use case, but it fixes an error if you try to add a random object as an event listener, right?
 CLA is processed, thanks!
 I think we're just going to let this one live as is. We have _a lot_ of invariants now and I think we'd like to move towards having a distinction between warn and throw invariants. cc @petehunt 
  Oh gross, thanks for reporting -- we should definitely fix this.
Let me know if you're already working on a fix otherwise I'll try to look into this tomorrow (after I finally get some sleep)
 This is still an issue today: http://jsfiddle.net/vjeux/WMMLZ/
 It's hard to give good errors here. Best idea I can think of is treating an unbalanced `}` as an error so that you at least catch it at the end of the `render` function. @jeffmo what do you think?
 Going to close this out here because it's really a problem with esprima. We haven't really made any movement on this in 11 months but maybe creating a new issue there will bring some attention.

https://github.com/facebook/esprima/issues/34
 Isn't this generally a very tricky case? As with unclosed multi-line strings, whatever comes next is valid, regardless of how much it looks like code, everything is technically valid up to the point of there not being a closing tag for input... in this case, `{` kicks in and doesn't accept statements, so technically it isn't even the unenclosed input being the issue in this case.

What @spicyj said, or rather, just erroring on orphaned `}` sounds like the best solution.
  I wonder if we should put parens after method names in the headings.

# Core API

I don't really like the word "core", would "top-level" be more descriptive?

In `renderComponentToString()` could you mention search engine optimization?

# Component API

On the docs for `transferPropsTo()` can you mention:
1. It's really useful if you have a component that basically represents an HTML-like component (i.e. more oriented towards pure display). Usually this is indicated by calling it on the return value of `render()`
2. It's really dangerous since it can introduce implicit dependencies between components and you should try not to use it that often.

nextState could use backticks

# Component Specs and Lifecycle

When I hear "spec" in JS land I think Jasmine test. I don't have a better alternative for you though, so not a huge deal.

setTimeout could use backticks

# Tags and Attributes

"to match the DOM" => "to match the DOM API specification"

# Event System

nativeEvent needs backticks

# DOM differences

"We intentionally break with the spec here" has a comma splice

Other than that lgtm
  Using a margin-left and overflow: hidden we can only show the star counts :)

![github-count](https://f.cloud.github.com/assets/197597/1145058/1bcf5a24-1dee-11e3-9b1f-1a67b19e542a.png)

This gives social signal while not being so ugly.
 Pretty cool. I'll let @petehunt /Tom/@zpao merge it - it has to be pushed to the main site anyways once merged. _Really_ wishing that clicking it _actually_ starred it.
 Why are we doing this? I personally find it a little bit distracting...
 This gives a signal that this is an interesting project that should be looked at.

We are already doing this:
- Say that it is made by a well known entity: Facebook, Instagram

But we can also do the following:
- Show the numbers of stars, forks, likes, +1 ...
- Display testimonials by users: Khan Academy, Propeller ... are using it, Dion Almaer tweeted it ...
 imo the white on black there has too much contrast. Also, can we display Facebook/Instagram more prominently? Right now it's in a corner at the bottom.

_Edit:_ forgot Facebook's in the url
 I think if you've made it to this page, the number of stars on github is not a strong signal you should start using it. I honestly see it as noise. If we think we need more signal, testimonials could help as well as just explaining in the best way possible on the home page.
 Yeah, this is not the best thing.
  Thanks for the report, but I don't plan to add support for `nowrap`. It was deprecated in HTML4 and is not a part of HTML5. I strongly suggest using CSS instead.
  I like this!

Couldn't you just do `return /^(data|aria)-[a-z_][a-z\d_.\-]*$/.test(arg);` in the new function?
 We also restrict the version of phantom we use to avoid problems with the latest versions. See package.js.
 Ah yes, that line has changed a bit since 0.4-stable. Here's the latest version specifier: https://github.com/facebook/react/blob/658f41cb30/package.json#L52

It seems likely that, while the react tests passed when 0.4-stable was tagged, with what was then the latest version of phantomjs, running `npm install` on that revision today would fail because more recent versions of the phantomjs package have been released.

@zpao do we need a branch fix? I think this PR should do the trick.
 So here's the thing, we're going to keep using `.bind` if we need to. In fact we still use it in a few other places even with this fix. If we move React in the direction lots of other Facebook code is going, we're going to have other transforms which result in code using `.bind`.

The fact that Phantom doesn't support this is actually pretty concerning, especially for people using it to test UIs. In fact, it looks like Phantom is roughly equivalent to an early version of Safari 5.1, based on the `examples/useragent.js` they ship, it's webkit build 534.34, which is actually lower than Safari 5.1.0 (534.48.3). Assuming it uses the same JSC support as safari (reasonable assumption I think based on my perusal of webkit code), `Function.prototype.bind` [was added in Safari 5.1.4](http://kangax.github.io/es5-compat-table/#safari-bind-note). The best option for the world would be to upgrade Phantom to a version of webkit < 2 years old. Up to Safari 6 would be ideal (7 might be overshooting since it's not even out), but even to the latest in the 5.1.x branch would be better.

So the only other option really at that point for us becomes to build the `Function.prototype.bind` polyfill into the build, which I've said for a while that I really don't want to do. I think if you want to support a browser for your site that doesn't support a part of JS, that is entirely your choice, but for those that don't we shouldn't cram extra code in there. If you want to use phantom and depend on it, you need to make sure you support Safari 5.1.0.

@tomelm I think for your case this means, using es5-shim/sham and shipping it in your assets. Unless you don't want to support the browsers missing it.
 @dillonforrest thanks for digging into this! We have a similar `Function.prototype.bind` polyfill that we shim during `grunt test`: https://github.com/facebook/react/blob/master/src/test/phantomjs-shims.js (required by https://github.com/facebook/react/blob/3dc1074908/src/test/all.js#L5).

If you're testing your own React components in PhantomJS, it's up to you to providing a similar polyfill. This pull request ended up getting closed because we don't want to avoid using `.bind` in the React core or bloat the core with polyfills just because of PhantomJS.

So I think the current recommendation is to pick your own fallback implementation of `Function.prototype.bind` if you need to use PhantomJS. That consistent with your views, @zpao?
 @benjamn - :thumbsup:

@dillonforrest I'm glad you dug into it and understand the problem! My concerns above are still totally valid and have made me reconsider our usage of PhantomJS (updating Phantom would be a big task so switching to SlimerJS is looking pretty attractive). Anyway, glad you're enjoying React!
 I just read https://groups.google.com/forum/#!topic/phantomjs/EiXb4iRU7WA and apparently PhantomJS 2 is on the horizon with an updated webkit, so this might all be temporary problem.
  @cbrake the use of `class` is now deprecated, check #328. There's a discussion on google groups also: https://groups.google.com/forum/#!topic/reactjs/xovHWHGHPCA
  This fixes a silent failure of the test suite after whatever grunt step follows `version-check`. The failure appears to be due to the presence of the call `require('./build/modules/React')` in the `version-check` step, but I am not sure why it fails.

This is also nice because it no longer requires evaluating the entire React dependency tree just to check the version.

cc @zpao @spicyj
 I'm usually more a fan of `String.prototype.match` but whatever works. Thanks!
  The `this.remove()` call was overreaching and removing the entire parent `if` statement. A more conservative approach is just to replace the `if` statement with `null`.

cc @zpao @petehunt @spicyj
 This makes things like https://github.com/facebook/react/pull/325 unnecessary, I think.
 I know I talked about pushing this out into the future, but what if we get rid of the pruning entirely? If we just stick with the constant replacement, uglify strips out the dead code blocks. In theory, _slightly_ faster builds ;)

I just tested with a bunch of different cases (using `__DEV__` standalone, combined with other conditions, in an `else if`, with other `else` conditions after) and it worked really well.
 https://github.com/benjamn/recast/commit/e5fc90bafcae94af59f34ddd13c30a85641b2986 is a worthwhile change within recast, but not strictly necessary to resolve this issue. With that said, here's 0.4.17: https://github.com/benjamn/recast/commit/b438bbdfe7ba131cdf5e1633007c2715c52ced0a.
 :thumbsup: I'll stamp the internal diff too and then let's do it.
  This isn't really ideal, but it makes it so that people managing to
build with @providesModule still get a consistent experience (since this
is what gets packed client-side with react-page-middleware anyway).
  I don't really want to add more work for recast.

Right now I'm leaning towards something like https://gist.github.com/zpao/6526375 because it's dead simple. Thoughts?
 I still want to do it a better way in the future. I much prefer what we already have, but we need something else for the time being. I may look into doing it via a browserify step in the future.
  https://github.com/facebook/react/blob/master/src/eventPlugins/SimpleEventPlugin.js#L153

Someone had the trouble in IRC about it.

_Edit:_ changed the subject from "document it" to "support it", because the documentation issue is already at #171.
 Curious if you've seen the `EnterLeaveEventPlugin.js`. It's automatically injected into React by default, so you can use it today. IMHO it's (much) better than `onMouseOver`. (I suppose we could support `onMouseOver` just for the sake of completeness, but I thought I'd just make sure you guys were aware of `onMouseEnter/onMouseLeave`.)
 Agree - I believe there are a few extra allocations (not-pooled) occuring in the event system already today. I'd love to track those down before adding more mouse-move event allocations. If you open the memory profiler in Chrome and move the mouse around, you'll see memory being allocated (and then properly freed of course) but if we use `PooledClass`es everywhere, we should be flat. That would make me much more comfortable with adding `mouseMove` to `SimpleEventPlugin.js`.

Edit: Just checked out `SimpleEventPlugin.js` - we already have `onMouseMove` which fires _way_ more frequently than `onMouseOver` would so it's probably not such a big deal to add `onMouseOver` - though we really should get rid of all additional allocations in the event path.
 @jordwalke I am pretty sure we have done all we can here -- at least I think we've tracked down every callsite where PooledClass would have helped us. I updated our recast transforms to log every syntax construct that would cause an obvious allocation and couldn't find anything. I was thinking maybe there was an array slice or a bind() in there, but @spicyj's experiment shows that this is not the case.
  This won't work if I want to full page render an iframe. Shouldn't we refer to container instead of document directly?
 I like but can't merge now, @zpao if you're still on the ground I'm good for this to be merged. 
 @spicyj: Did you test on react-page without my latest (hack) react-page commit (in `react-page-middleware`)? That would be the true test.
  @jeffmo, I'm going to leave this all to you. We should be able to figure out testing too now that `jstransform` is open and has tests.
 Eyeballing this, it looks good off the top of my head; However, due to some temporary synchronization issues between the versions of these files we have checked in internally and the versions we have in github at the moment (we're behind a bit internally on react.js), I need to hold off for a day or two before I can patch this internally to run our tests against it. After that I can merge/close

Hoping to be able to do that before the end of the week though
  Browserify sort of allows you to do this, but it puts them inline in the same file, which is _far_ from ideal. We should consider working with the browserify team and make it possible to build the map outside of the bundle or do something else (might be able to extract sourcemap out, might have to stop using browserify)
  OT: HTML5 compatible browsers will allow this, while others require the XML namespacing. I'm not sure if there's any one of those alive anymore. Usually Android is the problem but they don't even support SVG at all in older versions.

Nit: We could reuse a single array for the SVG definitions. That SVG list is going to grow since there are a lot more SVG tags than that.
 @sebmarkbage - Are we doing this?
 Pushed with tiny modification to the comment as requested during internal review - 7909c3e71b299fd100c7af660ab68ae3716b0a25
  Created a .mailmap file with all of the associations, then used
git + perl to create the AUTHORS file. In theory these should all get
picked up by npm.

I used ABC order so it would remain unbiased and automatable. I wish we
could go back and fill out the history or at least fix the commits we
have from CommitSyncScript, but oh well.

git shortlog -se | perl -spe 's/^\s+\d+\s+//' > AUTHORS
 It's been pointed out that leaving `CommitSyncScript` in the authors file is silly. I agree, so will fix.
  Thanks Ben!
  It has been decided.

Going to sync the timing of this with all the internal things we need to fix, but getting it out there.
- [x] update transform
- [x] update examples
- [x] update tests
- [ ] add warning for `class` and `for` to suggest `className` and `htmlFor` 
 I wish github had like buttons...
 @zpao updated the pull request.
  Just going to pull it in without waiting for internal accept. Good catch.
 @spicyj Which minification stage are you referring to?
  It should be possible, though I haven't run into this issue. On it's own, `jsx` doesn't run any other processes, but I'm guessing `commoner` does. Have you seen this @benjamn?

Also, just so we have as much information as possible, can you describe your directory structure and node/npm versions? If you run the command with arguments do you run into this issue?
 I've seen the same problem as well.
@lorefnon: can you please let me know if github.com/facebook/react-page works on windows?
 You can try `npm install jsxc` and using the `jsxc` command instead. Let me know if that works.
 Sorry, does `npm install -g jsxc` work?
  In case it's not obvious, I've been watching Ember a lot lately and I'm pretty jealous of their docs efforts getting to 1.0 and beyond. They've started working on "cookbooks" (https://github.com/emberjs/website/issues/663), which I think is an awesome idea. So I want to steal it :)

This could really help cut down on some of the time we spend answering questions. It would also just be an awesome resource.
 Adding a test gist here, as seen in IRC:
https://gist.github.com/chenglou/6431330

@zpao if you can start one entry in the code I can follow up with others. I'm not too familiar with Jekyll and don't know where you want to put it.

Also, some related nits: it would be nice that the code samples are copy-pastable directly into a live editor, i.e. with the jsx block, `renderComponent`, etc. Or maybe the other extreme, dunno. Just something consistent.

And a question: sometimes lots of things are more like "did you know?" rather than a problem the user had encountered, e.g. "did you know that, since JSX is really just JavaScript, you can use ternary operations for‚Ä¶". Is there room for that?
 Oh man, sorry I missed the questions. Do whatever you guys need and think is right, I'm going to step back and let you go wild and just try to guide. Not being 100% familiar with all of the cookbooks out there, I think it would be great to have working code. And thanks to codeblock highlighting (it'll become a thing one day!), we can do better than most people. If the code needed is long, perhaps we pull the relevant parts out but have a link to a working jsfiddle or something.

@mcsheffrey I'll let you handle the Jekyll parts. I'm thinking all under `/cookbooks` or something. We have sidebar navigation for docs in `_config.yml`, so something like that would work. Eventually we'll rewrite the docs from Jekyll but not today.

Go wild, I'm excited for both of you to work on this! I set up https://github.com/facebook/react/wiki/Cookbooks - feel free to use it, or not. Let me know if you need any help, or some guidance. Thanks!
 Saw people mention wiki in IRC. How valid is it to put cookbook entries in wiki and then parse it into jekyll?
 You could make that work and that might be the best option short term, but ultimately I'd like these checked in. My ideal world is one in which I could clone the React repo before getting on a plane without wifi and I have everything I need to learn about React, even if it means I have to read some Markdown instead of a better looking site.
 The wiki's already in markdown, how about checking in that page?
 I'm not interested in checking the wiki in, though that page could serve as the beginning of an index page. When it's checked in, it should be working with Jekyll, and I'd like to hold off checking anything in until it's at a point where we're happy publishing it (otherwise things get way too complicated for me). Working in a long-running branch in one of your repos is probably the best way to do this - the wiki is an easier way to organize and the effort so that's why I made that.
 Result of discussion on IRC: wiki is a temp place to organize stuff and claim cookbook entries to write. Actual entries are checked in as md for offline reading and such. @mcsheffrey the Jekyll entries can be taken from these mds. 
  @sklobovskaya thanks for pointing this out! I'm going to defer to @sebmarkbage here since he's done most of our SVG-related work.
 That makes sense. We should add some more markupWraps.
  React definitely allows you to specify an element's `id`.
  At FB we use this function https://github.com/facebook/react/blob/master/src/vendor/stubs/cx.js

It can be used like this:

`<div class={cx({myElement: true, isActive: this.state.active})}>...</div>`

We've found that this is a much more declarative and succinct way to build up a CSS class list. GIve it a try and see how you like it. We've been chatting on and off about baking this functionality into React somehow but we hate the `cx` name (what does that even mean!?) and aren't sure where to put useful utility functions yet. If you have any ideas or advice here we'd love to hear it.
 Pre-open source we had a `classSet` prop on everything that did this but it was nixed. @tomocchino @yungsters may know why we did it -- I think we just wanted to simplify things.
 `classSet` is awesome, and we still use it today internally in the form of the `cx` utility helper. It helps you declaratively specify the set of classes in a really readable form.

```
var classes = cx({
     Button: true,
     BigButton: !this.state.userIsPressing,
     RedButton: this.state.accountIsOverdue
});
```

We also have an internal transform step, that turns this into a fast string concatenation, without spending an object allocation: something like:

```
var classes = 'Button' + !this.state.userIsPressing ? 'BigButton` : '' + this.state.accountIsOverdue ? 'RedButton' : '';
```

The elegance in that transform is that it is not required - the runtime version of `cx` returns the exact same result, only not as fast/efficient as `cx`.
 I'm going to say we should stay away from this for now and just use helpers (like the one @spicyj mentioned now exists)
  `<table>`s are a bit of a tricky situation in general - we've had some issues thanks to the way browsers insert markup.

In this case, when you mount the `<tbody>`, that original node doesn't leave the document. That's normal behavior for React. The markup returned from your `render` function is then inserted into the `tbody`, but your markup contains a `tbody`, which browsers don't like. So your `tbody` node is actually dropped (to see this happen, change the `id` in your render function). React uses the node it thinks it created as a reference, but since the browser dropped that node, React is going to be confused. That's why you see that error, we actually pass the DOM node to `componentDidMount` so we try to get that node first and then fail. Getting rid of that method just hides the error but it will still come back to bite you later. Your initial render works BUT I think you'll run into errors if you ever try to do any state updates or anything that tries to re-render.

I think this is probably why you see other cases work just fine. There are some other cases where you'll run into issues as browsers change the DOM. For example, mounting into `<p>` or `<a>` will likely cause problems - see some of these examples in #101.

So my suggestion: render into the wrapper `div` and include the static content inside your component.
  Ah this‚Ä¶ @zpao? I have the completely revamped Todo from TodoMVC (passes all manual inspection), complete with integration with Director router. I suggest to remove the two todos (vanilla and backbone integration) in favor of that one, but removing backbone might be a bit too strong.
 Why don't we start by removing the vanilla one so our checkin and tastejs are in sync.

Sent from my iPhone

On Aug 31, 2013, at 1:32 PM, "Cheng Lou" <notifications@github.com<mailto:notifications@github.com>> wrote:

Ah this‚Ä¶ @zpaohttps://urldefense.proofpoint.com/v1/url?u=https://github.com/zpao&k=ZVNjlDMF0FElm4dQtryO4A%3D%3D%0A&r=qYx6qLphxKhA5vHBqr9vuw%3D%3D%0A&m=bllx%2F4smiFRhmr2253J5p7AypU8G2dS3diartAobvGs%3D%0A&s=59eb10bd55d264de94df91e3f7c44801d3ea93aa2befe5af424f291d78c815b7? I have the completely revamped Todo from TodoMVC (passes all manual inspection), complete with integration with Director router. I suggest to remove the two todos (vanilla and backbone integration) in favor of that one, but removing backbone might be a bit too strong.

‚Äî
Reply to this email directly or view it on GitHubhttps://urldefense.proofpoint.com/v1/url?u=https://github.com/facebook/react/pull/306%23issuecomment-23613421&k=ZVNjlDMF0FElm4dQtryO4A%3D%3D%0A&r=qYx6qLphxKhA5vHBqr9vuw%3D%3D%0A&m=bllx%2F4smiFRhmr2253J5p7AypU8G2dS3diartAobvGs%3D%0A&s=c80917ce603af08cab4a0e03e32a2c8f6bbe8f77aa7b081ab2b462be1ffad8cb.
 Sure. Sorry about that, somehow I completely neglected this after I finished it.
 All good, I should have pulled it in. Thanks for doing it :)
 #307 
 Hey @steveluscher, thanks for poking this and kicking @chenglou's butt into action :) I'm going to close this out BUT if we do a  0.4.2 (#299), I'll come back and grab this too.
  Thanks @brianr!
  This looks great. I think it will definitely be helpful. If you can also sign the CLA (https://developers.facebook.com/opensource/cla), I can merge this in.
 Thanks! In the future, you can always rebase & squash commits. If you `git push -f` into your branch after that then GitHub will detect and update the PR. We'll take PRs however we can get them, just wanted to share some knowledge in case it helps you in the future :)
 :+1: 
  We dropped support for this browser at IG. We have polyfills to make this work internally and we've documented how to use them at https://github.com/facebook/react/wiki/Polyfills.

But the documentation is really sketchy and in a random place and we should explicitly list the browsers that need them; @zpao  what do you want to do?
 Yea, we should probably call out the browsers as much as possible in the docs (basically that wiki page copied to a less sketchy place - http://facebook.github.io/react/docs/working-with-the-browser.html)

According to http://kangax.github.io/es5-compat-table/, `Function.prototype.bind` should be available in the latest Safari 5.1.x branch in (> 5.1.4), so it should work. We should probably include polyfills on our own docs site, but IG has it's own support decisions.

I still feel pretty strongly that we should keep the polyfills (and detection that polyfills are needed) out of React. We could do a better job of calling out the need for them though in the docs.
 No problem at all! Honestly if it's not easy to find, it's our fault. And if it turns out it's still broken with a polyfill, definitely reopen and we'll try to hunt down what's going on.
 I linked to that in the 3rd comment when I closed the issue. GH issues and wikis are not meant to be a final source of information.

From where where would you suggest we link to that page?
 Thanks for the heads up. I linked the docs from there.
  Right now we have some inconsistencies which requires cognitive load.

With the exception of `dangerouslySetInnerHTML`, I don't think there's ever any reason not to allow any sort of type as a prop in the DOM. Otherwise, `{false}` should put "false" in the DOM, `{{foo: 'bar'}}` should put "[object Object]".

We still want to special case `null`/`undefined` as those indicate that we should empty the value. Otherwise, `'' + prop` will ensure that we call `toString()` on the object (so you could have a custom Person object if you want).

This shouldn't be terriblely hard to fix, but we do want to make sure we test the change thoroughly. It will be a breaking change in some specific cases (mostly forms), so we'll also need to communicate this clearly.

Tangentially, we'll be inconsistent with the way types work as children. For example `<div>{false}</div>` doesn't have a child with "false" as text. We need to do something for children due to the fact that we use objects and arrays as special indicators for mapping.
 I had a nice thing typed up and then browser crash :/ I'll try to recreate what I wrote...

That is what I'm proposing. It's not actually much against that practice since it doesn't currently work for props (apart from `value` & `defaultValue` which don't work consistently anyway as you've noticed.)

It is against the practice of doing that with children, and I think maybe that's ok since they are slightly different concepts. I can't remember them right now but I think @tomocchino & @yungsters had some cases where at the end of the day it's ok not to be consistent since we can't solve everything and this allows us to be more flexible.

Objects already have a special meaning for things like `style` and `dangerouslySetInnerHTML`, so we can't always throw an error. I also think it would be pretty cool to allow you to do `data={ /* Object */}` and then have that automatically add all of the separate attributes. Objects also have a special meaning as children, so we can't eliminate that. Booleans have special meaning for `checked` and some other props, so we can't stop supporting them entirely.

FWIW, Objects as props allow a (admittedly poor) way of doing computed properties ;)
  http://jsfiddle.net/chenglou/ZEKbB/1/

Behavior:
- Chrome: nothing at all.
- Safari: works upon menu dismissal (and therefore item selection since that triggers dismissal), although for this reason it's triggered after the fade out animation rather than immediately.
- Firefox: works on both clicking select and clicking on an option, but not on menu dismissal.
- Mobile Safari: works on clicking the select, but not its option.
- Opera: (oh man) works on clicking an option and on menu dismissal, the latter only when the focus on the drop down is lost and regained.
- IE: triggers on every click, in menu and upon opening/dismissing the dropdown

By the way, This is a browser inconsistency. Not React's fault.
 What do you propose we do to make this work?
 Based on the W3C's documentation for [the click event](http://www.w3.org/TR/DOM-Level-3-Events/#event-type-click) and [interactive content](http://www.w3.org/TR/html5/dom.html#interactive-content), my understanding is that the `click` event should fire whenever the cursor is clicked on the `<select>` (which arguably includes the contained menu of `<option>` elements).

Using this interpretation, Firefox has the most correct behavior.
 Firefox doesn't fire it upon clicking the select itself (not the options) to dismiss though.
Just tested on windows and at least IE and chrome have the totally correct behavior. The thing is, select is an OS thing. Firefox got it mostly right because they implemented their own select, while Chrome uses whatever dropdown the OS uses.
I tried `onMouseUp` to patch some behaviors but some stuff just can't be achieved for the reason above.
so @zpao: not sure if this will ever work consistently.
  v0.4.2 will be a correctness release. The biggest changes will be the fixes to controlled forms that @spicyj & @chenglou have been working on. There are also a few DOM props that are missing.

I'll be cherry-picking the following (I'll update the PRs to commits as they land):
- [ ] `autoCapitalize` property - 5cbabdf4c95ec2bf13a40a9912d660601823e01c
- [ ] allow `0` as `defaultValue` - 1b747c526c501bc167a02f4dd7cfc8cee34f870f, d5989a0de470384d33650e99190f53bb51b6d2af, 86c0b69390e684e182728f0051a24f4a58e8a207
- [ ] Fix behavior of `ReactDOMSelect` - 25e2cd0db6673f0ae80534b983b57a8cde1a0be4
- [ ] `rowSpan` property - bcc6b524fb136bdc857e64d380659624193911e1
- [ ] `<meta>` tag properties - 07e20726923f29d2a323779b08583baa4b7fb526
- [ ] fix textarea `value` of number 0 - #274
- [ ] Fix controlled radio button behavior - #281
 Please add fixing tables to this
 In particular - when `<table>` has children added/removed, some browsers auto-insert a `<tbody>` messing up reconciliation.
 We need a fix of some sort before I put it on the list. Please file an issue with your broken fiddle so we can track it. We can always put out 0.4.3 if we need.
 We skipped this and went straight to 0.5
  I think this might be better protected against by inspecting lifecycle state. We do something similar for `replaceState` in composite components...

And now that I'm looking more, we actually protect against this in `receiveProps` but `setProps` doesn't go through that path. I think we could use some consolidation but for the time being, let's put an `invariant` into `replaceProps` that does exactly what `receiveProps` does. Give that a try and see if it fixes your case! (and if you wrote a test to ensure you get that error, that would be cool too :wink:)
 :thumbsup: I'm pulling this in for review internally right now
 It's a soft limit but we try to stick to it as much as possible. It would be great to make it possible to have multiple passes so that we could give a warning but not fail (the `maxlen` option results in errors if we turn it on). Internally we have the tooling set up to warn when linting but not block commits (unlike other lint errors).
 Accepted. Thanks a lot @clayallsopp!
   This one came first though. 
 Fixed with #360 
  Summary: Allows rendering of React into the "document" as opposed to into a
particular node. To recap some basics:

document: One level above the <html> tag - like the browser.
document.documentElement: <body>

To support full-page server side rendering, we need to be able to render
_everything_ including the HTML/BODY tags. This allows that.
 Why the safety guard?
 My thinking is that accidentally rendering over the entire page would be devestating. 
 already landed upstream, so merging.
 I was thinking that someone could try to "find a node to render into" by continually doing `while(something && node.parentNode) node = node.parentNode` and test each node to see if it matches some characteristics. A bad algorithm here would result in the node being the `document`. The probability is very small, but imagine if we got accidentally passed the document for a site like facebook, when someone just wanted to render a react component on a small part of the page. So even though the probability is so small, the expected cost is high unless we add additional checks.
  :thumbsup: I'll do the usual internal diff dance in the AM but this is good to go. Thanks!
 Pushed 364ee1ffaeacee1509ce3b81e111955074863401
  I hate to say it but we have a diff that just went in and added another use... :grimacing: The diff will be worth it though. Merge coming in the AM.
  Awesome! I rebased & pushed it as 3d1cc16a9b143b96b353b7b03c06ca0f7e544304
  Yes, I've wanted this for `resize` as well. We talked once about adding maybe a `onWindowResize` event that fires on every component, but how would it bubble?
 I wanted this for mousemove and mouseup as well. :) We're thinking about a larger declarative event system that could do conflict resolution but we should probably get this in the mean time. Not sure about the API though.
  This is interesting and definitely solves a real problem. I agree that it's awkward to mix event handling systems... I bet @jordwalke has some thoughts about this.

Is your thinking that `add/removeEventListener` would work on the top level component returned from render? Or all events of that type that occur for any component inside this one? You're jQuery code targets specific `<a>`s. Would you want the machinery to do that in React as well?
 I think this is something @jordwalke or @yungsters will be best equipped to answer since they've worked on the whole events system the most. Unfortunately they are both on vacation so not around to comment. Until then, maybe somebody else could comment? @petehunt? @sebmarkbage?
 @tomocchino has been thinking about a declarative way to do component level event listeners. You could imagine declaring your events on the component class or in mixins. Something like:

``` javascript
// warning: Not real API
eventHandlers: {
  root: {
    onClick: function() { ... }
  },
  someRef: {
    onClick: function() { ... }
  }
}
```

That would allow you to separate the event handlers into a mixin and also use more explicit event delegation. It can also avoid allocation during reconciliation. So I think that would solve your use case. This is not currently on the short term road map though.

Personally, I'm looking to get away from using mixins as much as possible. There's a lot of problems composing mixins that you don't get with composable components, which after all is one of the things that makes React great.

For example, to trap clicks on links you could wrap your components instead of using a mixin:

```
render: function() {
  return <LinkTrapper usePushState={true}><div><a /><a /></div><div><a /></div></LinkTrapper>;
}
```

Since the events bubble, link trapper can catch them with it's DOM node. Currently LinkTrapper must define an extra, unnecessary DOM node to attach it's event listeners to. We could potentially create a fake component that can retrieve event listeners without actually rendering to the DOM. Then the implementation of LinkTrapper would look something like this:

```
handleClick: function(e) {
  // check if event's target is an anchor and invoke pushState API
},
render: function() {
  return <FakeDOMNode onClick={this.handleClick}>{this.props.children}</FakeDOMNode>;
}
```

I don't see us exposing a public imperative API since that goes against the declarative/functional approach that gives us a lot of benefits. However, we may expose access to the ReactEventEmitter or something for special low-level components that needs to reach under the hood.
  Nice find, and thanks for the PR!

Let's actually change it so that it points at the first guide. I think pointing at the reference section is a bit awkward.

Also, can you sign the CLA (https://developers.facebook.com/opensource/cla)? We need that done before we can merge in.
 I like it. I'll squash this and commit it in the morning, then get the site updated. Thanks a lot!

(And I'm glad you like the CLA process. I'll pass that on to the people who worked on it!)
 Thanks for pre-squashing :) It helps GitHub close the issue when I push it (without the green button). I'm going to do another pass for 404s and then push this out.
  The argument for this is that this fits well into the way lots of other libraries work (e.g. backbone), and frankly I did make the mistake several time at the beginning of using the above format. the argument (more or less) against this is that we could simply put a check and a warning message.
 I think you saw some of our discussions on IRC about this. I think this is totally reasonable to do, we think we might just want to come up with a more explicit API. cc @jordwalke @sebmarkbage 
 I think the reason we didn't have this is to avoid problems with key mangling. E.g. in closure compiler.

Previously we didn't have batching of setState commands which also meant that you wanted to pack as many props as possible into a single setState.

I think this a reasonable want for dynamic keys. I'm curious about the usage of dynamic keys though. How are you using this right now? Would it make more sense to use something like a Map abstraction that prevents problems with **proto** keys and all the other problems using objects as maps?

setState({ myMap: new Map() });

... later

this.state.myMap.set(key, value);
this.forceUpdate();
 :) also see `ReactStateSetters` (another internal thing we should probably expose).
  Nice!

Do you mind adding a screenshot of what the blog article looks like? It's easier to review than actually looking at the Markdown file.
 ![screen shot 2013-08-19 at 14 37 15](https://f.cloud.github.com/assets/8445/989595/8ba748ca-0917-11e3-95cb-6b352b05ba9e.png)
 Squashed into 91c2a8d90b2095097261c69d78cbf749f4199edb
  Apparently it doesn't, but it would be pretty awesome if it did. We already listen for `DOMCharacterDataModified` so I don't think it should be too terrible. Tangentially it would be great to stop using mutation events and switch over to observers (let's not do that here though unless it dovetails really nicely).

Interested @spicyj?
 Fair enough. Let us know if you do end up working on it.
 @salier did we ever make this work? I know a lot has happened in this area since this time last year.
 For those requesting this, is your objective to have a controlled contentEditable component that makes use of and `onChange` event? Or to use native contentEditable behavior in an uncontrolled component?

If it's the latter, is `onInput` not sufficient for your use case for modern browsers? I'm inclined to agree with @masklinn , though as @joshduck  notes, more work may need to be done to get better legacy browser support.
 Low desire here and a way to make this work so just going to close out.
  Thanks :)
  I'm fine with this, but I noticed that `componentWillUpdate` does not have this, either. I'll let @zpao or @jordwalke make the call here.
 I agree.
 I agree with @spicyj here - by passing the DOM node, we touch the DOM when we don't need to. It kind of contradicts the edict of React itself - touch the DOM the minimal amount of times.

The code mod to remove this support might be tough.
 Even though I opened the issue, I'll chime in here: it was kind short-sighted and it's better if the root isn't passed at all. I haven't done any huge components or projects using this yet, so for me and maybe a bunch of other devs out there it's just a matter of adding one line at the beginning of the lifecycle method to rectify this.
 Nothing has happened here and nobody seems excited for what's needs to happen to make this work, so I'm going to make an executive decision and say we won't do this.
  OMG you're so awesome.
 Can you also do this for `ReactDOMTextarea`? :D
 Waiting for the internal revision to be accepted, then I will merge this.
  previously, setting `value` to number 0 is treated as if `value` wasn't set at all (thus the textarea is cleared from 0 to '' upon `onChange`.
 Actually, I think that `|| ''` is redundant. Maybe. Anyway, thanks for fixing this. I'll merge it when I get to a desktop.
 true, also changed the one in input, although it more or less belong here?
 That code works, but we should have some tests to prove it :wink: 
 here are the tests. I combined two checks into one (checking nothing changes, _and_ checking for the specific bug in this issue). Not sure if it's a good idea.
 Ok, 1 week is too long to let this sit. I pulled it in last week but it failed a test internally which was depending on `value={false}` to work, and then I got distracted by other things. Sorry about that!

Those tests that fail also have tests that are checking that `value={true}` result in `value="true"`, which made me think that it's a bit awkward that 1 bool works while the other doesn't. Worse, other props will still output "false", eg `title={false}` results in `title="false"` in the DOM. That said, I think this is fine and no worse than we are right now, this diff just made me realize the inconsistency.

So I need to do a little bit more fixing of some custom components internally before I can pull this in, but soon!
 I can undo the changes if we decide on a consistent way to display `false`.
 I think this is still the right thing to take _right now_, and then we should revisit the rest of the issues. You aren't making anything worse with these changes, just strictly better. `'' + true || ''` was still === `'true'`
 Everywhere else in React, true and false evaluate to the strings `'true'` and `'false`', respectively.

``` javascript
// <span ... title="true"></span>
React.renderComponent(React.DOM.span({title: true}), container);
// <span ... title="false"></span>
React.renderComponent(React.DOM.span({title: false}), container);
```

Why don't we want to keep this behavior?
 Well, this diff doesn't change anything except making `value={0}` work. `value={false}` is unchanged (in other words, still inserts empty string), as is `value={true}` (inserts `"true"`).

I think we should be consistent (that's always my theme). Do we always allow primitives? Do we only special case `undefined` and `null`, but allow all other primitives? Do we restrict to `number` and `string`? Or maybe we just always `.toString()` whatever you give us? The current mix here is bad and we should change it, totally agree. But let's do it separately and fix some other consistencies while we're at it...

Let's take a look at some crazy shit...

``` js
// It's a String!!!!
<div title={new String('title')}>{true}{false}{null}{undefined}{0}{{lol: 'wat'}}</div>;
// Error: Invariant Violation: escapeTextForBrowser(...): Attempted to escape an object.

// Ok, so {lol: 'wat'} makes sense when you realize that's how keys work... But then we only render string or number literals...
<div>{true}{false}{null}{undefined}{0}</div>;
// <div><span>0</span></div>

// Wait for it...
<div>{true}{false}{null}{undefined}{0}{new String('hi tim')}</div>;
// <div><span>0</span><span>h</span><span>i</span><span></span><span>t</span><span>i</span><span>m</span></div>
```
 This hurts my brain because nullity in JS confuses the hell out of me. Can we instead make a new module that does something like this? 

```
function convertToDOMString(v) {
  if (v === false || v === undefined || v === null) {
    // These special cases should never have their toString() representation rendered into the DOM
    return '';
  }
  // Everything else? toString().
  return '' + v;
}
```

I understand `===`, I don't understand `==`.
 Hey @chenglou, can you rebase? (feel free to squash too if you want). Let's ignore @petehunt's comment since @yungsters accepted and Pete's getting on a plane soon anyway. We'll come back to what he said when we figure out the real consistent behavior here.
  Thanks for the kind words :)

Now about Safari 5.0.6... Based on http://kangax.github.io/es5-compat-table/#Function.prototype.bind it would seem that `Function.prototype.bind` wasn't supported until Safari 5.1.4. If you could try polyfilling it and report back, that would be really helpful. I don't have access to Safari 5.0.6 here.

You may need some other polyfills. Check out the section we have on that @ http://facebook.github.io/react/docs/working-with-the-browser.html
 We polyfill `Function.prototype.bind` in tests, because PhantomJS doesn't support it, either:
https://github.com/facebook/react/blob/0441d4c7f5/src/test/all.js#L9

We could polyfill it all the time (not just in tests), but we seem to have a BYOP (bring your own polyfills) attitude about other built-in methods.
  We've tried to be consistent about documenting the React core using markdown style comments, and JSDoc style annotations, so it would be easy to create a utility that auto-generates documentation pages for the core itself. Ideally this would only rely on node.js/npm and not Java.

Using the "good first bug" label, but we should rename that label to "good first contribution".
 Every once in a while I use http://yui.github.io/yuidoc/ (which is basically javadoc). It's node-based and seems to be the best option.

However we run into a bunch of issues. This would require a pass through the code to make sure we have the right syntax everywhere. This is on my eventually list, but haven't had the time to go through everything. We basically need somebody to step up and do what's being done in https://github.com/emberjs/ember.js/pull/3082

If anybody is interested, let me know!
 Someone tweeted about docsets http://kapeli.com/docsets

https://twitter.com/kapeli/status/401461544468635648
 @Kapeli: We haven't yet agreed on any form of documentation and docsets looks like a good target. So I mentioned it here in case someone wants to try and integrate React with it.
 Happy Dash user here. Love the app. Will be generating React docs for it soon so that we can all have an offline, instantly fuzzy-searchable React documentation =).
 I did a rough version and passed it over to @agirton (hope that's the same one as on #reactjs!).
 @agirton ping on this ^
 Docco doesn't actually generate API docs AFAIK, just an html page with your code and comments all together.
 @3lux I don't think annotated source is the most helpful thing that could be done. We have a pretty good set of comments in the code. Right now our public API is small while we have a lot of other code that makes it all work. Backbone and Underscore have all their code in 1 file, are smaller and expose a lot of their code as public APIs.
 @agirton @mazubieta it's ready. I'll put up something tomorrow.

Edit: React docset is now in dash!
 I was actually just thinking of a Flow-based documentation tool. Unfortunately none exist AFAIK and there's still some need for the JSDoc comment (at least for the description, and other `@class`, etc things JSDoc does).

Side note... 0.12.2 documentation shouldn't be out of date, I updated it myself :) But let me know what's missing and I'll followup.

I think the idea of a react-doc tool is certainly interesting. We actually have something we do internally at FB that does some of what you're talking about, pulling out at least some of the PropTypes and handling inheritance. It's tied to some specific ways we write out components but it would be cool to generalize it so it could be open sourced. That's pretty tangential to this specific issue, but cc @fkling anyway :)
 Eh, after this long using human maintained docs, I think we'll just continue down that path. It's not without problems, but with a small surface area, I don't think we actually need autogenned docs.
  So that one-off doesn't actually fix what it needs to fix. `this` is not the global `this` there. Once it's wrapped up in a module and with strict mode, what you're actually returning there is `undefined`. We need a line of code that works in any environment: server-side, in a worker-thread, or in the browser and gives us the global global. @benjamn - any thoughts on other ways we can go about this?

Honestly we don't have a stance on React+CSP yet. We haven't worried about it yet but as CSP usage rises we don't want to have random breakages. This becomes especially important for people using the CDN hosted version. If you absolutely needed you could stick React on a host you control with `'unsafe-eval'`
 As @spicyj pointed out on IRC, the only uses of `ExecutionEnvironment.global` appear to be in DOM event code, so it may be easier to get rid of than I thought. We'll need to figure out some future plans to make sure we won't end up needing it again (wouldn't want to become compatible and then incompatible again).
  I'm going to leave this open for now for some discussion, but (like we talked about on IRC), I don't think we should do this (and I think we should get rid of `class` as well). Take this:

``` js
var Component = React.createClass({
  render: function() {
    return <div class={this.props.className} />;
  }
});

React.renderComponent(<Component class="foo" />, document.body);
```

You can't actually access `this.props.class` in your component, you can only access `this.props.className`. It's fine and simpler down at your actual DOM nodes, but it means you have to actually think about this and recognize that you don't have access to that specific prop like it might be used in the JSX syntax.

Not everybody agrees with me, so let's start that discussion...
 Totally agree. We should probably make https://github.com/facebook/react/pull/267 know about `class` and `for` and give helpful warnings there.
 I'm a little out of context here, but why is it a problem to have a property name of `for`?
 @jeffmo because you access it in the child using `this.props.htmlFor` rather than `this.props.for`. Might throw people off.
 I see...and the reason these things are renamed is really just because of issues when dealing with old versions of IE right? (because they don't like it when you access object non-computed properties named the same as a keyword)

Under the assumption that's the reasoning for all this, I think we might need a more general solution than just making up case-by-case magically renamed identifiers for all JS keywords. Maybe we come up with a more standardized renaming scheme for keyword attributes? Like `class` -> `classProp` and `for` -> `forProp` (where a legit property called `forProp` would throw an error if there's a collision). At least this way you only need to learn this nuance once and after that you can always remember how to reference the keyword-props... (I'm not tied to this particular renaming scheme...just ad-hoc suggestion)

Also, (still assuming stupid old IE is the only reason for all this) for people who don't care about old IE it would be nice if we set both `class` and `classProp` so that "normal people" can do `this.props.class` and `this.props.for`.

I'm positive this topic has been discussed before -- I just wasn't around for the discussion, so anyone feel free to point out anything I'm missing.
 In fact, I would agree that's not a terrible thing to do if you care about IE7 -- and anyone who thinks it looks ugly should blame IE7, not us :)
 I recall @zpao saying that `this.props.class` would break stuff in ES6?
 I personally would love it if we didn't translate props like this at all though -- I probably should have mentioned that in my previous comment.

ES6 has a `class` keyword, but I don't believe the spec states that its illegal to use a keyword as a property identifier in a non-computed member expression... (I'll double-check that when I can get a chance -- but I'm fairly sure on that one). So these shouldn't be issues for anything except for old IE which sadly does whatever the hell it wants.
 Yea ok -- chatted this over with @zpao and @jordwalke and I think we three agreed that it would be best if there were consistency between attribute names and the property identifiers you access them through.

That could mean one of two things: We either stop converting 'class' -> 'className' and just do `this.props.class` (with a computed property for those who care about IE7) or we start using 'className' as the attribute name and continue doing `this.props.className` -- but we definitely shouldn't continue adding to this conventional magic-prop-translation insanity.
 So `this.props.class` is fine? One vote for `class` then.
 I think that the value of copying and pasting HTML and having a (mostly) working component is huge. So +1 to `class` :)
 We just had a big discussion here. We're going to send out some proposals internally soon and I'll post them on the google group too (with link here in case you aren't signed up).
 As promised: https://groups.google.com/forum/#!topic/reactjs/xovHWHGHPCA
 We're going in the opposite direction and not supporting any prop transforms. The result of that decision and the ensuing discussion resulted in d83fe785c52e3cc43542b035f02d77286944ff14 and the final decision that we will not be supporting `class` or `for` but will opt for keeping our DOM props as close to the JS API as we can.

@piranha, I really appreciate you taking the initiative here which forced us to make a decision.
  Excellent. @sebmarkbage is going to pull this in to grow our group of people who can handle merges.
  @zpao this diff lgtm
  I think our reasoning goes something like this:
- other functions are autobound because they are often used as event handlers and callbacks.
- they are user provided in a weird way - the object you pass to `createClass` isn't really `this`, everything gets copied to a different object
- we originally didn't have autobinding, so you would need to `.bind(this)` all of the place.
- then we made it opt in during class creation (`R.cc({foo: React.autoBind(function() {...}), ...}`)
- then we realized everybody was autobinding everything all the time so we just defaulted that behavior. we actually thought people would complain since it's a bit magical, but not a word...
- `setState` and company aren't autobound because we never intended them to be called outside your component (the usual case for binding). Internally, we never really ran into this being an issue - the common case of data fetching usually involved passing a function which called setState and was bound (eg `getData(function(data) { /*do some data parsing */ this.setState(finalData); }.bind(this))`. If it's complicated you could even just have that callback be defined on your component and then it's autobound :)

Passing `setState` to another component as a callback is something I would discourage. It's not inherently wrong, I think it just makes state ownership less obvious. Now as a callback to some data fetching function (promises, $.ajax callbacks, etc) isn't totally unreasonable (though the fn you pass to `.then` ["must return a promise"](http://promises-aplus.github.io/promises-spec/#point-39) - setState doesn't but that could happen in the future). Again, we haven't heard this internally (and we do a lot of data fetching), so I'm interested to hear how much of a problem this is for people? What specific problems are you solving? Is your data being fetched and normalized and error handled all external to your component?
 In the KA codebase we have two uses of this.forceUpdate.bind and none of setState.bind. Here's one of the uses of forceUpdate:

https://github.com/Khan/react-components/blob/master/js/timeago.jsx

The other is similar.
 At this point I'm just going to close this out. We obviously aren't making any specific effort around this and may end up going back to not autobinding as we move towards "real" classes.
  `<th rowspan="2"></th>` does not set `rowspan` in the DOM.

Component:

``` js
render: function() {
  return (
    <thead>
      <tr>
        {this.props.columns.map(this.renderColumnLabel)}
        <th rowspan="2"></th>
      </tr>
      <tr>
        {this.props.columns.map(this.renderColumnControl)}
      </tr>
    </thead>
  );
}
```

Output:

``` html
...
<th data-reactid=".r[5je1f].[0].[1].[1].[6].[0].[0].[1].[0].[0].[0].[1]"></th>
...
```

Can this be my first PR? :)
 Oh, that's it.  Thanks :)  I'll await #255's resolution for long term, but adjust my code in the short term...
 Sorry @ericclemmons, it could have been :) I tried to do a pass for missing attributes pre-0.4 but if you notice anything missing from https://github.com/facebook/react/blob/master/src/dom/DefaultDOMPropertyConfig.js, feel free to open an issue or PR
 Oh, it totally looks like `rowSpan` (camelCased!) is [missing](https://github.com/facebook/react/blob/master/src/dom/DefaultDOMPropertyConfig.js#L80).  I'll submit a PR...
 @ericclemmons Still interested in fixing this?
 Closing for #291...
  [jsfiddle](http://jsfiddle.net/Flsg/jkNpv/)

First and third child divs won't render the `data-*` and `aria-*` attributes.

While we're at it: why aren't these attributes using camelCase? Seems more consistent. Anecdotal but I actually attempted to use dataFormId first, before trying data-formId, and then find the bug.
 I just did the _exact same thing_. Seems like something we would have done intentionally but I'll check! (might be a DOM quirk (or quirky spec) we're working around.
 Ah, this is actually part of the spec for data attributes - https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes#attr-data-* - so we just (silently) enforce that.
 Hah, didn't know that. Makes sense to keep it this way in React too, as dataSomething would be confusing to interpret.

Do you want me to drop a note in the docs on this in "JSX Gotchas" and "Reference"?

(btw, really think DOM differences should be placed somewhere else, took me a while to find it)
  [jsfiddle](http://jsfiddle.net/chenglou/6ZG4w/)
removing the second row works; removing the first one leaves us with the wrong input field value and checkbox state.

Assigning a key to each form works, but I think the behavior without using key should be at least predictable.

Same with textarea, and select: [fiddle](http://jsfiddle.net/Flsg/pYe5a/2/). Try to select first row option 1, then remove it. The selected 'row' state carries onto the next select. (Edit: fiddle died, sorry...)
 Ah, this looks like a could possibly be with inputs and the fact the `defaultValue` sets `value`. If you add a data attribute `data-formid={this.props.formId}` you'll see that we're actually left with the 2nd input, but it's value got overwritten. I didn't check, but I bet that's the case in the 2nd fiddle too.

Now that said, these edge cases of reconciliation are _why_ we ended up with the `key` prop. Let's get @jordwalke and @sebmarkbage in here to weigh in, but I think we might just throw this into the "use `key` to fix it" bucket.
 (Confirmed for second case)
In my case I'm fine with assigning keys. In fact, that's what I did as a temporary/permanent solution.

But I'm not so sure if we should shove that into fixing with key, conceptually speaking. I think most people's impression (including mine) is that assigning keys fixes that natural problem of keeping components around when it's obvious that a change of children count/order in the next render squashes them (e.g. search results, as mentioned in the docs).

~~In this case, the behavior across similar components on the _same_ render differs, It's unpredictable and leaves the impression that it's a quirk of the framework (that just happens to be solvable elegantly using another concept). Overriding an input text but not an input checkbox can never be an intended behavior.~~ Never mind, let's just say it's nice to have _better_ consistent behavior =).
 > In this case, the behavior across similar components on the same render differs, It's unpredictable and leaves the impression that it's a quirk of the framework (that just happens to be solvable elegantly using another concept). Overriding an input text but not an input checkbox can never be an intended behavior.

I agree that we should have consistent behavior here. Best I can tell from a quick check is that we actually do. Your checkboxes don't change because you're using `checked=` instead of `defaultChecked=`, so you're actually testing 2 different things. If you use `defaultChecked=` you get the same behavior as text inputs.

I also agree that this is unexpected and something we should spend more time figuring out the right answer. This might be something we can just fix in the form components.
 Argh you're right for `defaultChecked`, sorry. I didn't bother looking into it further because (_ahem_ #250) select has a bug that neglects `defaultValue` in the second case.
 I don't think there's much we can improve here so I'm closing this.
  previously treated as empty string when passed to input text/textarea
 Looks good to me! I'll pull this in internally and merge ASAP (probably Sunday or Monday).
 @chenglou We should add a test for this to make sure we don't break it later. Want to add one?
  I'm curious what you mean by "passed over". Could you please construct a very simple JSFiddle which reproduces the confusing behavior? Thanks!
 :)

Yeah, in general React won't do anything you didn't tell it to do. I remember the conversation now - the outcome was "React is practical, not magical".
  Great suggestion. We could just warn in `__DEV__` if any attribute is not recognized. You could imagine how that might lead to a bunch of errors when you do `this.transferPropsTo(<div .. />)`.
  They point to jsfiddles using the old version of React.
 I think @vjeux updated them on jsfiddle this morning
  Good effort, but this isn't quite the right way to do it. As is, if `grunt lint` fails, we'll never continue. So the most important part (tests!) won't actually get checked. Let's try putting it last, though I think that may end up reporting the wrong pass/fail. We may need to actually take advantage of Travis' ability to run different scripts for testing.
 I'm going to declare this still too aggressive. We tend to catch most things in `src/` before they get pulled in (_he says as lint is currently failing_). And I don't care as much about the other parts (though I'll do a pass through every once in a while). So I'm going to close this out. Sorry!

I still think we could do this with some [matrix in travis](http://about.travis-ci.org/docs/user/build-configuration/#The-Build-Matrix) so that we allow lint to fail, but it still runs.
 It runs both, but it fails when lint fails even if tests pass, right? Or did I read it wrong?
 The matrix on its own would, but you can also specify parts of the matrix that can fail (eg, we could test node 0.11 but would allow that to fail... which we probably should do).
  You don't by chance want to write tests for this do you? I know we don't have much coverage for our form components...
 By the way, thanks for fixing this and writing unit tests. Sorry for the delay in review.
 Awesome, this looks great. Thanks!
  :+1:
  Could you give a brief example here?
 Thanks @spicyj.

cc @yungsters
 Although this may be confusing, I think it is relatively straightforward to realize what is going wrong. Changes that allow `keyup` to access the attempted value would cause the text input's value to flicker since `keyup` fires later.

Let's just clarify documentation.
 Yeah, haven't heard any more complaints of this. The form docs aren't clear enough though; we always have people asking why their things are read-only (cf. #825).
 Going to close out then in favor of just adding docs.
  A document fragment will be included in the returned array for any markup that renders as more or less than one node.

This deviation from typical one-to-one rendering previously caused an invariant failure, so no code that previously worked will now be broken, and most code that was previously broken because of unexpected parsing behavior will now just work.  Any code broken as a result of this commit probably just needs to add some logic to handle document fragments.  But hey, we didn't call it `dangerouslyRenderMarkup` for nothing.

cc @yungsters @zpao @sebmarkbage @jordwalke
 (review happening upstream because phabricator > github for reviews)
 Just got accepted but Ben's on PTO so not getting merged today
 Dropped this in favor of #263.
  In the process of merging this upstream, I realized I had another commit that was going to cause conflicts. I synced that and now this doesn't apply cleanly. Can you update again? I think you can just drop the changes to `Danger.js` entirely.
 Gah, submitted a new one without hassles.
  Paging @yungsters.
 For lack of a better place to put this fiddle: http://jsfiddle.net/KfqXH/1/

I spoke with @spicyj on IRC. There will be issues if you have:
- Radios rendered in React with `name="X"`.
- Radios rendered outside of React with `name="X"`.

This is an edge case we don't think needs to be handled (partly because there might not be a way for some browsers to even detect if an arbitrary `<input>`'s `checked` property gets set).

A simple way to deal with this involves maintaining a list of all instantiated React radio inputs. Whenever one radio input's value changes, look for other radio inputs with the same `name` and **scope** and `setState(...)` as appropriate.

By **scope**, I mean inputs within the same form or not inside any form.
  Thanks a lot @gasi! For future reference, you can use `git commit --amend` to overwrite your previous commit and then `git push -f` to overwrite your branch. GitHub picks that up and updates the existing pull request. I don't mind this either, just thought I'd share!
  @andreypopp I do too. The only downside is that we'll re-evaluate that function even if `this.props.firstName` & `this.props.lastName` don't change. If that function is doing something more complex than just string concat, it could get expensive. The upside of computed properties is that you can expire values when you know the dependents change. The downside is observing changes and expiring caches.

Generally we would suggest what @sophiebits is doing, though the fact that there's no _single_ lifecycle method to catch both initial props and update is annoying.
 I'm going to wontfix this for now. We may decide the overhead is worth it here, but you really only get the niceness of Ember's computed properties if you are observing changes to the other properties. Since we aren't doing that and afaik don't have any intention of doing so, I don't think we'll do this anytime in the near future.
 @epeli: Couldn't you use a general purpose memoizer? It doesn't necessarily need to be baked into the framework, right?
  Yea, this is pretty awkward. Since we do pretty dumb string transforms and preserve line numbers, it's not going to be pretty. My long term goal is to get to AST->AST transforms with sourcemaps and pretty code generation with something like escodegen.

We could at least do better with comma style in the short term.
 If somebody wants to tackle the comma part of this, then go for it but otherwise, let's close it out.
  Does it sound like addressing this at the rendering layer is a reasonable approach? Whenever a React instance has an `onClick` handler, we can render its markup as `<div onclick="function(){}" />`.
 @jordwalke Actually, I think an empty `onclick=""` would work in this case.
  Good catch! 2 things:
1. Can you sign the CLA (https://developers.facebook.com/opensource/cla)?
2. Can you also update the other place we reference 8080 (the `basic-jsx-external` example)
  To work well with batching, I suggested:

```
this.props.onEdit(function() {
   var node = this.refs.editField.getDOMNode();
   ...
});
```

Where `onEdit` would have been defined as:

```
onEdit: function(whenDone) {
      this.setState(things, whenDone);
}
```
 (A year ago!)

Pretty sure sync setState is not happening and that we're not going in that direction. The workaround is fine.
  This is freaking fantastic! Will this be rails-specific or work in any sprockets environment?

Also, once this is working I would love to port over some of Insta's internal Django integration stuff to react-rails (including transparent server rendering), if it makes sense!
 Hey @jakubmal, I'm actually working on this _right now_. Going to have a branch in my repo very shortly. Sorry if this is duplicating work, but let's converge on a single solution! I'll post here once mine is up and you can tell me it sucks and we should just use yours - I actually haven't written a proper gem (react-source doesn't count) so I'm probably doing a lot wrong!
 Doing a little bit of cleanup, but it works!

![screen shot 2013-07-24 at 3 22 13 pm](https://f.cloud.github.com/assets/8445/852380/0a35670c-f4b0-11e2-8bb4-5bf8dd7d3783.png)
 @jakubmal I pushed out React (and more important react-source) v0.4.1 yesterday with you changes to JSXTransformer, so now the gem dependency can work without having to build and install react-source locally. I also just synced my branch with what's going to end up in the separate repo (https://github.com/zpao/react/tree/contrib-react-rails/contrib/react-rails). If you wanted to do any work, feel free to start doing PRs against that! I have a list of todos in the readme. The biggest thing will be tests, though if you think some other part of this is higher pri, feel free to hack on whatever. Anything will help! I'll make sure we maintain authorship into the new repo if we get changes in before the standalone repo opens up.
 As I mentioned in #233, we now have https://github.com/facebook/react-rails, so this is a wontfix here. Thanks again for forcing the issue @jakubmal :fireworks: 
  ![notpokemon-like-stamp_copy](https://f.cloud.github.com/assets/197597/845766/86205a4e-f3f1-11e2-82cf-23ac9dbdd104.png)
 Can you rebase this?
 I'm going to do more testing soon, but this appears to be resulting in a pretty tragic lose of click events on facebook via iPad. There might be some other things going on though.
 Going to say we should revisit this (again) for 0.6, but I haven't had a chance to look into it more.
  Ok, I think we can close this based on `React.addons.TransitionGroup`
  Here's a thought: Right now, the when any props of a `div`/`span` have changed, the reconciler creates a "plan" for how to carry out an update. This plan consists of:
- New markup `m` that must be inserted at location `m'`.
- New items `n` that must be inserted at location `i'`.
- Existing items at location `d` that must be deleted.

Right now, the default behavior is to simply carry out this plan in the most efficient way that we can. What if, you could tell these native components that you want to handle the insertions/removals/moves in a very particular way (that may include animation).

Something like:

```
 <div childManager={TheChildManager}>
     {childrenThatEvolveOverTime}
 </div>
```

Where `TheChildManager` might look like:

```
var ChildManager = {
  addChildren: function(childrenMarkup, location) {

  },
  moveChildren: ...
  removeChildren: ...
};
```

What's interesting is that not only are child instances added/moved/removed, but also updated. We need an API that allows controlling when/how these updates occur throughout the process of creating/destroying/moving. You may wish to update before you move existing children/add new ones, or you may wish to update them after all the adding/movement is complete.

It seems like the best strategy is to make sure that the lowest level hooks are exposed, so that no one ever feels completely trapped by not being able to perform their particular animation feature. Then, on top of that, we can build sugar that does some very common things, such as:

```
<div childManager={require('ReactAnimateNewRows')} />
```
 A couple of other features that I've heard requests for (I think this hits on @chenglou's comment):

```
- Being able to block various forms of updates while mid-animation.
-- Being able to block external props updates while you are animating your component.
-- Being able to block all non-animation related updates while animating. Effectively, we would queue up those updates until the animation is complete (sounds like the batching diff that @spicyj built will help here).
```

Another completely different direction to take, which doesn't really address animating child components but focuses more on property values:

Pete Hunt's work on animatable state transitions:

```
  this.tweenState({
      from: {stateFieldOne: this.props.starterOne, stateFieldTwo: this.props.starterTwo},
      to: {stateFieldOne: this.state.starterOne*2,  stateFieldTwo: this.state.starterTwo*2},
      timingFunc: 'ease-in'        
  });
```

Which would just call setState several times, throttling to hit the `16ms` animation frame window.

We've also talked about being able to implement `tweenState` without actually having to call `setState` every `16ms` - we could use the `from` and `to` as "snapshot" points, that we can perform a single reconciliation diff between, calculate the diff and tween those individual values every `16ms`. It may not be possible to compute two parallel `tweenState`s using this method.
 I think `React.addons.TransitionGroup` mostly covers this. If not, let's figure out what else needs to happen to make animations in React as good as possible.
 Oh I guess TransitionGroup handles #227 but not this without restructuring a bit...
 @michaelahlers I have a working wrapper (animation library-agnostic, mostly) [here](https://github.com/chenglou/react-state-stream/tree/master/App4). It's a bit messy right now but once I find some more free time I'll pull it out. See https://github.com/chenglou/react-tween-state/issues/15 as well.

(This sure brings back memories =))
 Eh sorry, state-stream is unrelated. The wrapper _should_ mostly work in conjunction with anything else, including a simple `className` change and node removal.
  Squashed & pushed: 7f8b2885d9f9feb396896f7d9d6086ac7731cf36
 Where was className suggested in the docs?
 Those docs seem incorrect. I'll update them. 
 Both are _fine_. We even use `className` on the homepage examples. We should be consistent though. Also, we don't transform `for` to `htmlFor`, so we should be careful about suggesting things that are transformed (eg, you can't access `this.props.class` in a component)
  I like @andreypopp's solution because siblings shouldn't know about eachother, and children generally shouldn't know anything about their parents (except what the parent supplies as props to the child). @andreypopp's solution maintains the proper separation.
 I'm going to close this out, but feel free to ask more questions here, on IRC, or in the google group!
  We talked about it several times and we agreed that we should support <Namespace.Component> but no one actually wrote the code to support it yet.

In the meantime you can do
var Component = Namespace.Component;
<Component>

Thanks for the report :)
 @jeffmo, this is all you on the esprima side. We'll obviously want to make sure this change is fine internally before we take it.

@jakubmal Feel free to open PRs against facebook/esprima#fb-harmony (that's the branch we use internally and here in React - npm has git dependency issues, that's why we point at a tarball for a rev in our package.json). I think we intentionally lag behind master since we've done some considerable work in our branch, though @jeffmo knows better. We'll almost certainly want some tests :) We didn't add our other tests in `vendor/fbtransform/`, but we have some other React specific ones and we'd want to add some internally before we point React at a new rev.
 I think this is mostly fine, but I would like for us to continue using xml semantics if we want to go down this road. So instead of `<Namespace.Component />` I'd rather see us use `:` a la `<Namespace:Component />`
 @jakubmal: I said that it shouldn't be too hard. But I'm pretty sure it's not a one liner :)
 Going with `:` (as opposed to `.`) would allow us to separate the meaning of the syntax from the output of the compilation pipeline and leave the "what does this mean?" decision to the compiler. This is nice because it would be pretty reasonable to parameterize the compiler (with some reasonable default) in terms of deciding what something like `<MyStuff:MyThing />` should de-sugar to.

i.e. Does it compile to `MyStuff.MyThing`? Or maybe `MyStuff__MyThing`? Or hell maybe even `require("MyStuff/MyThing")`

If we go with `.`, we're making a fairly hard-to-reverse decision that we want JSX namespacing to always be tied to a MemberExpression (because what else would `<MyStuff.MyThing />` mean?)
 With regard to including dot as an allowed character in the tag name: This not the right approach for the parser. If the intent of `<App.Views.Counter />` is to be a javascript member expression, then it should be represented as such in the AST (so that no further parsing must be done when the AST is interpreted). `App.Views.Counter` is not a valid identifier -- nor is that even its intended meaning (the intended meaning is a member expression).

On the `.` vs `:` front: `.` locks us in to "namespacing" meaning "nested objects". This restricts our option value for any future scenarios where we might want to implement namespace resolution in other ways (such as nested modules). So barring any other significantly compelling arguments I'm going to be the bad guy and say that `:` is the correct punctuator to be used here if we want to move forward with this feature.
 (I should note that I also don't feel terribly strongly about the need for this feature -- but if done in a future-friendly way, I'm willing to take the pull request)
 To be clear I wasn't suggesting that we parse colon delimiters into member expressions, but just that we parse them into some kind of "namespace" structure in the syntax tree so they can be interpreted more freely by the compiler.

If we used `<App.View />` and parsed that into a member expression, you've got a member expression to deal with pretty much forever (changing what this means will be rough on backward compatibility). If we parsed it generically and compiled it in to something other than a member expression, it might be non-intuitive for unfamiliar readers of the code because, as a reader, my thought process would go something like: Well it's clearly not valid xml, and it looks like a js member expression...so I'll assume this compiles to a member expression lookup for the component.

Whereas `<App:View />` is less semantically tied to a particular output result in terms of what "namespacing" means, its still valid xml (good for readers of the code who are familiar with xml), and it can be defined however you see fit in your particular application (easily parameterizable in the jsx compiler) with a default of something reasonable like a member expression.
 @lrowe: Its possible to represent an arbitrarily deep number of nested namespaces as such:

```
<App.Views.Counter />
```

```
{
  type: 'XJSElement',
  openingElement: {
    type: 'XJSOpeningElement',
    name: {
      type: 'XJSIdentifier',
      namespace: {
        type: 'XJSIdentifier',
        namespace: {
          type: 'XJSIdentifier',
          namespace: null,
          name: 'App'
        },
        name: 'Views'
      },
      name: 'Counter'
    },
    [...]
  },
  [...]
}
```

This turns out to be true regardless of what the namespacing delimiter is -- my only issue with `.` is just that it would deviate from established xml convention and it would look too closely like a member expression which may not always be what we want namespaced components to compile to.
 @lrowe You can already do what you want using a temporary variable as follows:

```
var View = App.registered_views[obj.item_type];
<View />

var View = obj.item_type == 'special' ? SpecialView : DefaultView;
<View />
```

This also enables you to add children to it:

```
var View = obj.item_type == 'special' ? SpecialView : DefaultView;
<View>
  <SomeChildren>
</View>
```

Otherwise there's an issue where it's unclear what you put in the end tag:

```
<{obj.item_type == 'special' ? SpecialView : DefaultView}>
  <Children>
</{obj.item_type == 'special' ? SpecialView : DefaultView}>
```
  http://fooo.fr:4000/react/blog/2013/07/20/community-roundup-5.html
 @chenglou thanks, fixed :)
 @zpao 
 Changed the date to monday
 Ping :)
 975b5d978f5a560ce0c85457f4979a60e2241334
  See #307 
  Nice! We'll definitely take this. I'm on my phone and can't check right now, but if you haven't already, can you sign the CLA (https://developers.facebook.com/opensource/cla)?

Also, I'm excited to see somebody working on (what I would call react-rails)! I started to after initial launch but got sidetracked. I actually set up  http://rubygems.org/gems/react-source to get started on this (following the same pattern as coffeescript and ember I think - having 2 distinct gems). I got hung up on the non-node thing too but never figured out the best way. We're going to have slight discrepancies between `bin/jsx` and this so we should figure out the best thing to do about that.

If we do react-rails in this repo, we'll need to shuffle some things around. Lets chat and figure out the best way to do this
 By discrepancies I mean that the transform is _slightly_ different. `bin/jsx` gives a little bit more power and options (like stripping `__DEV__`, transforming into common js). I think it's fine for them to differ a bit though, so long as they have the same default behavior.

As for getting react-rails in here, I think we'd need to restructure the repo a little bit (ie `lib/` is set up for react-source, but we'd want a different `lib/` for react-rails, so I'm thinking we would put each under it's own directory, or both under a `gems/` dir). Otherwise, I think the ember-rails route makes sense.

> load and run should not be exported when window/document is not available. If I understand it right here, I'll fix it. Anything beside this?

I think that should do it! Do that and I'll merge this in.
 Yea, no need for tests here. Thanks!
  Thanks!
  Looks like batching broke a couple of our lifecycle methods.
- `componentWillReceiveProps`
- `shouldComponentUpdate`

Both of these get passed in `nextProps` and have access to `this.props` (also, `state`). However, `nextProps` is set to `this.props` before calling these methods, so no comparison can be done.

master/0.4: https://github.com/facebook/react/blob/master/src/core/ReactCompositeComponent.js#L635-L673
0.3: https://github.com/facebook/react/blob/0.3-stable/src/core/ReactCompositeComponent.js#L584-L595

Apparently we need more tests...
 May have jumped the gun on this... trying to get a reduced test case that fails (so far I can only make passing test cases).
 Ok, this isn't related to batching at all. It's actually the age-old objects are passed byref problem.

In the case we were hitting, we have an object storing data coming from the server. Sometimes the server will say "update the number we have stored for this object", so we set object.test++, then re-render with object as a prop.

Here's a test case demonstrating the problem:

```
  it('should pass shouldUpdate the correct values', function() {
    var _propsWereDifferent = [];
    var count = 0;

    var data = { test: 1 };

    var Component = React.createClass({
      shouldComponentUpdate: function(nextProps, nextState) {
        _propsWereDifferent[count++] =
          nextProps.data.test !== this.props.data.test;
      },
      render: function() {
        return <div/>;
      }
    });

    var instance = <Component data={data} />;

    ReactTestUtils.renderIntoDocument(instance);
    data.test++;
    instance.setProps({ data: data });
    instance.setProps({ data: data });
    data.test++;
    instance.setProps({ data: data });

    expect(_propsWereDifferent.length).toBe(3); // pass
    expect(_propsWereDifferent[0]).toBe(true); // pass
    expect(_propsWereDifferent[1]).toBe(false); // fail
    expect(_propsWereDifferent[2]).toBe(true); // fail
  });
```

The best way to work around this is probably to pull as much off of `data` and set each property as props on your component instead.
 FWIW, this isn't a bug in React - this is something to be aware of in all JS. JSX makes this a little less obvious.
  Squashed & pushed 64d72f8c4b1054c97393124d85681f0e168064fa
  This was not necessary when we were running each test in its own `<iframe>`, and it doesn't seem to affect any test behavior currently, but it seems wise for the sake of test isolation and hygiene.
  Writing docs the hour before a launch on very little sleep never works quite right... Thanks!
  @phleet Nice catch! Can you sign the CLA (https://developers.facebook.com/opensource/cla) and then I can merge this in!
 Awesome. Thanks a lot!
  This cuts the running time of `grunt phantom:run` from 4.4s to 3.1s on my machine, because we no longer have to load/execute a separate instance of `react-test.js` in a separate `<iframe>` for each test.

cc @jordwalke @zpao @spicyj @andyperlitch
  Thanks Hugo! Can you sign the CLA (https://developers.facebook.com/opensource/cla) and then we can get this merged in.
 No worries. Thanks a lot!
  :thumbsup:

@benjamn Are you game to remove those config files?
 And that's the sound of the buzzer you hear. Going to do this. We'll just have to keep an eye out for merge conflicts here but I don't think it'll be too much of an issue.

Wishes do come true @tomocchino...
  superseded by #204 
  done in #204 I think. Or maybe #203. Either way, done :)
  :thumbsup: I wanted to get rid of those json files anyway. We'll have some trouble with this internally, so I'm going to say no for 0.4 and we'll get to this right after
 Backed out... I explicitly didn't merge this because I don't want it for 0.4 (I could make branches and everything work but I'd rather keep it simple as long as possible). Also, this will apparently break upstream. Please don't merge anything with changes to `src/` without testing & getting into upstream first.

I have no idea how to make github reopen this PR, so we might need to just recreate it - will figure out later.
 @zpao very sorry; I see that I misread your comment. What will this break upstream?
  It's been a while since we changed these docs. If these issues are still relevant, can you update with details and I'll reopen.
    This has been fixed in the upcoming v0.4 thanks to our improved synthetic events. Thanks for reporting and providing a test case!
  Mentioned the wrong issue‚Ä¶ :hurtrealbad: 
  :thumbsup: Not sure if we'll want it in core necessarily (at least not until we actually use it at FB). We have ways of mixing in events so this seems like a good potential candidate.
  Super like :)
 @spicyj Can you rebase this to trigger the Travis tests again?
 Let's def wait until after 0.4 -- I would want to dogfood this on FB in prod for a week to be sure there isn't anything weird, no? It also doesn't change the public interface so we can issue it as a point release.
  This is something we were talking about just yesterday actually. Copy+paste HTML was one of the use cases that came up.

We want to be careful about making the JSX transformer too magical, and I think fixing capitalization is a bit far in that direction, but it's a good idea. Short term plan is probably to make sure we warn when we see things that are probably meant to be camelCased. We're not completely sure what we'll end up doing longer term though. Chances are with 0.4 right around the corner, we're not going to make any changes just yet.

Thanks for filing! We'll keep this updated as we figure it out.
 @lrowe - thanks for contributing to this discussion but we opted to stick with camelCasing. Our current plan is to warn when we get a prop for a DOM component that we don't recognize. Follow along in #255.
  React needs a list of properties so that it knows whether to use the property accessor or setAttribute when changing the attribute (and also to convert between camel-casing and dash-cased, though that's not as critical). We'd like to make it easy to configure React with custom attributes; sorry this isn't easy right now.
 It seems your other issue #140 addresses this concern already and I don't see React adding this specific attribute to the global whitelist.
  Yea, that's unfortunate. This feels like something we should be able to make work. What do you say @jeffmo?
 `id` was unsupported in v0.3.x since React took over that attribute for its own purposes. You'll be able to use `id` in v0.4.
 I just looked into this a bit more and it seems for some reason `&nbsp;` is broken, but all other entities seem to work just fine. We'll look into this some more!
 We have a fix for `&nbsp;` coming soon! (cc @jeffmo)
 @danvoyce This issue was closed over almost two years ago.  It is also related to fbtransform, which has been deprecated for a long time now.  If you're running into an issue that you believe is a bug in the latest version of React, please open a new issue with a simple jsfiddle that demonstrates your issue.
  Could you give a simple use case where it does not render numbers? There's an interesting reason why you may not want booleans to be rendered as strings.

```
children = something && <div />
```
  Can you include some sample code that you would like to work?
 We have many issues about this now, with some of our latest thoughts here: https://groups.google.com/forum/?fromgroups#!topic/reactjs/xovHWHGHPCA

Whatever we get to, we won't have multiple ways of doing something...
  I think 61b38b9f053a5cf32ff868974357884c1bcb5d3a fixes this, right @sebmarkbage?
  This came up on IRC last night. Somebody was working having trouble testing React while using `$.trigger` to test an event handler & state change. `$.trigger` does use synthetic events (not `SyntheticEvent`s) but they claim to do best effort at matching real DOM events - http://api.jquery.com/trigger/.

The problem in this case was that the code was using `$.trigger('change')` on the checkbox. We either weren't handling the change event OR this is one of those cases where jQuery's events just weren't good enough. Using `$.trigger('click')` worked.

We might have fixed this in 0.4, I just haven't had a chance to test.

doesn't work: http://jsfiddle.net/robert_zaremba/LWXhs/4/
works: http://jsfiddle.net/LWXhs/5/
 So jQuery's 'change' isn't a `change` event (https://developer.mozilla.org/en-US/docs/Web/Reference/Events/change)?

I don't blame Robert for thinking that should work. It's a perfectly reasonable assumption. We will probably end up WONTFIXing this, but I wanted to make sure we had something on file!
 Closing out, hasn't been an issue since
  Are you using the minified React package or unminified?
 Can you try with unminified? You should get a more helpful error message. If not, we have a bug.
 OK so that error message still sucks, but at least you're getting messages in the correct build. Thanks for the report!
 Based on our lack of movement on this and some of the discussion in the associated PR, I'm going to wontfix this. If it comes up again though I'm open for discussing further.
  Seems pretty reasonable to me and should be a really trivial change... not sure if it would break any expectations elsewhere.
 Based on discussion in the PR, let's wontfix this.
  @chenglou if you sign our CLA we can merge this in: https://developers.facebook.com/opensource/cla
  Coming out of https://groups.google.com/forum/?fromgroups#!topic/reactjs/2DVIcjDRVbo, it would be good to talk more about how events are handled and different patterns of use. We do a pretty good job of saying that we attach listeners at the top level and use delegation but it's obviously not clear enough about cleanup. We may also want to mention how to use normal event listeners if you really wanted.
 @BenQuinn we're trying to be good open-source stewards so it should be expected that we document everything rather than relying on contributions :) If we don't get a PR from the community soon I'll just go ahead and update them.
  It would be nice if there were a convenient way to "import" a set of variables into scope.
 You can do
{h1, li, div} = React.DOM

but you've got to enumerate all the tags you are going to use

## 

Christopher "vjeux" Chedeau
Facebook Engineer
http://blog.vjeux.com/

On Sat, Jul 6, 2013 at 11:48 AM, Jordan W notifications@github.com wrote:

> It would be nice if there were a convenient way to "import" a set of
> variables into scope.
> 
> ‚Äî
> Reply to this email directly or view it on GitHubhttps://github.com/facebook/react/issues/170#issuecomment-20558913
> .
 There's something pretty similar here: http://jsfiddle.net/hdrV3/1/
And there was a bunch of discussion here which you may find interesting: https://github.com/facebook/react/issues/47
 I don't think we're going to do this.
  Here's an example of what you usually want to do:

```
    var BigButton = React.createClass({
      childHandleClick: function(e) {
        alert('big button clicked!');
        this.props.onBigButtonClick();
      },
      render: function() {
        return (
          <button onClick={this.childHandleClick}>
              <span />
          </button>
        );
      }
    });

    var Parent = React.createClass({
      parentHandleClick: function() {
          alert('parent clicked');
      },
      render: function() {
        return (
          <BigButton onBigButtonClick={this.parentHandleClick}>
          </BigButton>
        );
      }
    });
```

So in general, with the current React API, components don't do _anything_ you didn't tell them to do. So in `BigButton`'s `render()`, you said that the `<button />`s `onClick` should be `this.childHandleClick`. React will not automatically "forward" `this.props.onBigButtonClick` to the `<button />` and there are many good reasons for that.
- Reason 1: What if you didn't want to forward it at all because you don't want to expose that as part of `BigButton`'s API. You should get to decide everything about the contract you offer to your client code - including whether or not you want to accept an `onBigButtonClick` prop, and what that means.
- Reason 2: What if you wanted to forward it, but not to the `<button />`, rather to the inner `<span />`? Any kind of auto-forwarding would result in that click handler getting placed on two different nodes unintentionally.
- Reason 3: You should be in control of how `this.props.onBigButtonClick` is invoked. You may wish to do it before you `alert('big button clicked!')` or after. With the current API, you're in complete control. 

Regarding having to check for null. I would first ask: Did you intend for `this.props.onBigButtonClick` to be optional? Or is it required? If it's required, I'd say invoke it as if it's present. If it's not required you can do:

```
this.props.onBigButtonClick && this.props.onBigButtonClick()
```

Is there another API you had in mind for this kind of stuff?
 If you want to blindly forward all the properties you can do:

return this.transferPropsTo(<div />);

I don't remember if it is overriding the ones you set or not though.

## 

Christopher "vjeux" Chedeau
Facebook Engineer
http://blog.vjeux.com/

On Jul 5, 2013, at 11:01 PM, Cheng Lou notifications@github.com wrote:

> That makes lots of sense, thanks. I don't have any API in mind, I guess I'm still thinking in terms of the old html.
> 
> Let me get this straight: say I have a BigInput component (just a wrapper around a normal text input, plus some classes), in the traditional DOM manipulation mentality I'd feel free to register to the input's change event from something else and act upon it, but in React's best practices, I need to specify inside BigInput the whole set of events I should accept (e.g. change, keypress, click, etc.)? That's what prompted me to ask this question. Kind of a small paradigm change here.
> 
> ‚Äî
> Reply to this email directly or view it on GitHub.
 Regarding best practices: I usually use `transferPropsTo` if the component is just a dumb wrapper around a DOM node, but also applies its own classnames etc. Other frameworks may decide to automatically forward attributes downward, which has its own initial appeal, but it's the kind of thing that (as a framework default) could cause a lot of confusion (unexpected attributes can end up on low level DOM nodes from ten levels up in the hierarchy).

I would suggest to use `transferPropsTo` but use it conservatively, for very low level UI components, when you intend for the component you're building to accept the complete set of DOM attributes that a `<div />` would have. In other words, we shouldn't use `transferPropsTo` because it was an easy way to forward the only two attributes we wanted our component API to consist of. We should use `transferPropsTo` when we truly want our component to implement the complete API of a DOM component (and possibly more).

I'm a fan of building focused components that expose the smallest possible API. It's like making sure your ~~component~~ software doesn't bite off more than it can chew ;)

Disclaimer: Find what works for you. These are just rules of thumb.
  We need to do it.
 They're included in https://github.com/facebook/react/pull/188 as well as best practices
  This is a really great question. We've discussed and heard several very interesting proposals for new APsI that allow us to express animations. We'll definitely be working on this going forward. My current belief is that it would be best to form an API that is layered on top of the declarative API that is at the heart of React. Currently, some animations are very functional, and those are very well suited to React's current API. Many animations can be elegantly expressed using CSS rules - React's current API is also is very well suited to those. Other types of animations that are more difficult to express functionally, take more effort and may require that you implement `componentDidUpdate` or `componentWillUpdate`. I'd love to see an API that allows us to express what happens in these "less functional" animations in a functional/declarative way. Feel free to send out gists of the simplest cases if you have any ideas.

Here's one proposal that may be worth considering: Imagine if upon transitioning states, all DOM mutations that occur as a result may be passed through a separate declarative animation configuration:

```
this.setState({newState: 'xyz'}).animate(animationConfig);
```

`animationConfig` could instruct the DOM reconciler how to update different classes of DOM attributes/styles. For example, You could do:

```
 var animationConfig = {
     // Any style property effecting dimensions (width/height/padding)
     dimensions: {  function: 'ease-in', durationMS: 500 },
     childAdded: {  function: 'linear', animateType: 'fade-in makeRoom' }
 };
```

Because we have a central place in the framework where we intercept all DOM mutations, we can make this work fairly easily.

One nice thing about this proposed API, is that it might give us the power to pierce through the encapsulation boundary of sub-components, without ever leaking implementation details. We're able to "animate the implementation details" of sub-components, but without ever assuming anything about their nature.

One tradeoff with this API is that I anticipate being able to perform animations very easily, but anticipate difficulty in getting animations to do exactly what we want with millisecond precision.

There's also other types of animation APIs that we can provide for situations where the animated properties don't pierce through the encapsulation boundary:

```
this.animateToState({chartSize: 500}, {durationMS: 900});
```

That would simply invoke state transitions within a `requestAnimationFrame`, and let the reconciler do the rest of the work (what it always does). There may be performance issues with this, but with the proper throttling, it may also be useful.
 I totally agree!
 As far as "animations on unmounting" goes, I usually just toggle a "shown" or "visible" prop on an owner component instead of unmounting directly, since then you can do the transition first and then finally unmount. But YMMV.

As far as "animations in general" goes, I've prepared this example for you: https://github.com/petehunt/react-animations. It's a pretty performant way to tween your state, interpret touch gestures, and animate in a performant way. Let me know if this is helpful!
 @WickyNilliams pete removed it. You can still find the commits [here](https://github.com/chenglou/react-tween-state/commits/master?page=2)
  I was just running into this same issue. One of the react-tools npm pushes did not have the build. I believe @zpao  fixed this now in npm. Someone should update reactify to depend on the latest version of react-tools and I believe it should be fixed. Can you confirm?
 I'm still seeing the same issue that you are. I'd like to get this fixed because I too want to try out reactify as well.
 Interestingly, reactify shouldn't even rely on the build output - it should only need the bin folder to do the transformation. We should have another npm module just for "react.js which is what it's getting out of the build directory.
 Here's what I did for grunt-react; could work for reactify too  https://github.com/ericclemmons/grunt-react/pull/2/files. Maybe I will find time for a pull one of these days on reactify :)

Sent from my iPhone

On Jul 4, 2013, at 3:11 PM, "Peter Conerly" <notifications@github.com<mailto:notifications@github.com>> wrote:

Oh, that's a really good point.

If you want an immediate and hacky fix you can just change /node_modules/reactify/node_modules/react-tools/main.js to be:

'use strict';

//var React = require('./build/modules/React');
var visitors = require('./vendor/fbtransform/visitors').transformVisitors;
var transform = require('./vendor/fbtransform/lib/transform').transform;

module.exports = {
  //React: React,
  transform: function(code) {
    return transform(visitors.react, code).code;
  }
};

and viola.

‚Äî
Reply to this email directly or view it on GitHubhttps://urldefense.proofpoint.com/v1/url?u=https://github.com/facebook/react/issues/159%23issuecomment-20494951&k=ZVNjlDMF0FElm4dQtryO4A%3D%3D%0A&r=qYx6qLphxKhA5vHBqr9vuw%3D%3D%0A&m=kUsZcVcl76jdJjXpzGIx4DI8H8kvdq3L9MIShHM2wLI%3D%0A&s=a18f23f7dc9205c9ca0c24cd45ff1df3493a2b0b0afa657b3fdca9e5bd3e3f7d.
 @jordwalke @pconerly  - `npm cache clean` will also make this work again. (testing without clearing cache worked on my machine because I published it, so it must have cleared the cache in the process). I should probably bump to 0.3.4 :/
  Right now JSX only supports desugaring for value interpolation <Module key={'value'}>. Would be nice to support interpolation for the module name and keys. E4X supports those interpolations.

I would also really like to support interpolation for arbitrary props. This would allow us to get rid of this.transferPropsTo which is a really unfortunate API in my mind.

```
<Module {this.props} overridenProp="vjeux" />
```
 ```
/** @jsx React.DOM */
var module = 'Module';
<{module} />
```

could be rewritten as 

```
var module = 'Module';
(React.DOM[module] || eval(module))()
```

Not sure we want to do it that way but it would work :p
 But I was more thinking about module being a reference to an actual function.

```
var module = React.createClass({});
<{module} />
```

would be rewritten as

```
var module = React.createClass({});
module();
```
 :+1:

We've thrown around a couple ideas for being able to forward several properties:

```
<Component *={entireProps} />
<Component {entireProps} />
```

Either way, a couple of interesting questions come up:

Does the position of props effect the semantics? Does the order that they are specified effect the precedence?

```
<Component {entireProps} overrideProp={something} />
<Component defaultedProp={something} {entireProps} />
```

If so, then would it be transformed into:

```
Component(merge({defaultedProp: something}, entireProps, {overrideProp: something});
```

I like the end result. The only tradeoff to consider is that now our transform is becoming more than a lightweight, line-for-line, non-opinionated one. It might even depend on some runtime library to do the merging.

The `<{expression} prop="hi"/>`  seems a little more straightforward.
 Get rid of the interpolation in that last example and that's exactly what we have today‚Ä¶ if The transform doesn't see something from a hard coded list, it expects a variable in scope.

Also, I will say no to any transform that puts `eval` into code :)

You could always do something like this:

```
var el = condition && React.DOM.div || Rect.DOM.span;
<el prop>{whatever}</el>
```
 **hides** It didn't occur to me that I could just to `<module />`

## 

Christopher "vjeux" Chedeau
Facebook Engineer
http://blog.vjeux.com/

On Jul 4, 2013, at 1:33 PM, Paul O‚ÄôShannessy notifications@github.com wrote:

> Get rid of the interpolation in that last example and that's exactly what we have today‚Ä¶ if The transform doesn't see something from a hard coded list, it expects a variable in scope. 
> 
> Also, I will say no to any transform that puts `eval` into code :) 
> 
> You could always do something like this: 
> 
> ``` js
> var el = condition && React.DOM.div || Rect.DOM.span; 
> <el prop>{whatever}</el> 
> ```
> 
> On Jul 4, 2013, at 1:04 PM, "Christopher Chedeau" <notifications@github.com<mailto:notifications@github.com>> wrote: 
> 
> But I was more thinking about module being a reference to an actual function. 
> 
> var module = React.createClass({}); 
> <{module} /> 
> 
> would be rewritten as 
> 
> var module = React.createClass({}); 
> module(); 
> 
> ‚Äî 
> Reply to this email directly or view it on GitHubhttps://urldefense.proofpoint.com/v1/url?u=https://github.com/facebook/react/issues/158%23issuecomment-20491964&k=ZVNjlDMF0FElm4dQtryO4A%3D%3D%0A&r=laHZhPsrTTGL9mHVyUC%2BICFnZxZCH4LNzfo%2BOgrHdsw%3D%0A&m=KttA727Vz3FtUgsPfrPNaCG0eW8%2BZ%2B%2Fq0%2BbMKE21%2BV0%3D%0A&s=c0ff6edc3252a081018b2bbe89a33b1df3a98154698611e145121ab7db8de7d2.
> ‚Äî
> Reply to this email directly or view it on GitHub.
 @zpao: There may still be value in allowing interpolation for the tag name, but I don't know how we would enforce that the closing tag matches!

```
  <{loggedIn ? LoggedInView ? LoggedOutView}>
     Children Here
  < ...  />  //  (What do we require here!?)
```
 @jordwalke There's definitely value, but it comes at the cost of making JSX harder to understand, and I think that cost is too high.

And that case is so easily re-written to

```
var component = loggedIn ? LoggedInView : LoggedOutView;
<component>...</component>
```

that it hardly seems worth any complexity.
 So I am very concerned about adding complexity to JSX just for the sake of syntax. We need to keep it dead simple, IMO, unless we need to add expressive power.

I think that forwarding multiple properties is a useful use case, and could be desugared as an extra param to React.DOM.*.
 Let's close this out. If we need special keys we can always fall back to non-JSX.
  Awesome! Can you rebase? 32423a83fc9c9c8dc1eac8f769a581e09a2ba74f moved things around so this doesn't apply cleanly anymore.
 Not your fault. We have a bug with some of our testing infra - #155 
  We're using `global.*` increasingly (right now it's only used for checking for `console` like https://github.com/facebook/react/blob/master/src/core/ReactComponent.js#L109).

I don't think any of these points actually work when using the browserified version of React...
 Perhaps `require("global")` should return the global object, and also ensure that `require("global").global === require("global")`, so that after that module is required once, requiring it is no longer strictly necessary.

Proposed contents of the `global` module:

``` js
var global = Function("return this")();
global.global = global;
module.exports = global;
```

The question would then be where to call `require("global")` for the first time. Maybe `React.js`? Or maybe make it an entry point for Browserify?
 Yea, we already have `ExecutionEnvironment.global`, so there's an entry point in there somewhere. I'm less worried now that we're getting rid of these uses (thought I synced that already...)
 We should purge all uses of global in the React codebase since we already polyfill console. I mostly did this, but I think there is one more ref around somewhere...
 The one reservation I have about purging it is that it's tricky to get the
global object reliably in a way that works both in the browser and on the
server. `Function("return this")()` is my go-to technique, but that's far
from obvious (especially because of the strict mode considerations).
 @benjamn: `ExecutionEnvironment.global`
@phunt: https://github.com/facebook/react/blob/master/src/core/ReactInstanceHandles.js#L318 is the last one (there are a couple in tests though and we should probably change those too... we did it once already
  I'll be adding this and a couple other known missing properties. Thanks for the heads up!

FWIW, I only see `autofocus` being valuable for server-side rendering. Browsers are only supposed to look for this property on page load, so adding it with client-side rendering shouldn't do anything.
 I added this and a few others in 203dba271b6128f03c99b1ce2f573a316adb4e4e
  @lrowe if you can sign https://developers.facebook.com/opensource/cla we'll be good to go!
  On IRC today someone was missing a tag in ReactDOM. Should we export createDOMComponent() as an escape hatch?
 :+1: 
 FWIW, this won't help the JSX transformer which maintains it's own list of tags it recognizes and converts to React.DOM.*
 @sverrejoh As somebody who works on React, I'm saying that merely exposing this function doesn't add the tags to the JSX list. So if you want to be able to run `jsx` on your code and have new tags be converted to `React.DOM.newtag` then we need to do more.

React: https://github.com/facebook/react/blob/master/src/core/ReactDOM.js
JSX: https://github.com/facebook/react/blob/master/vendor/fbtransform/transforms/xjs.js
 @zpao @petehunt @sebmarkbage While I imagine 0.12 will make this happen, it does not address the issue of related attributes/properties that wouldn't be whitelisted right?
 Correct, we'll get there for attributes too though.
 At this point I think it's safe to say we'll never do this.
  Thanks!
   Ping :)
  #140 was reported today which was something I was interested in fixing anyway. Turns out this is pretty easy.

During the course of this diff I noticed we didn't expose the id attribute; this is fixed. I use MUST_USE_PROPERTY per http://stackoverflow.com/questions/4851699/setting-the-id-attribute-of-an-input-element-dynamically-in-ie-alternative-for.

I think this internal refactoring is basically pure win. If you guys don't want to expose the API publicly yet to keep the surface area of the API small I can revert the second commit on this.

If accepted into the public API, I will document this. I think this is definitely a rough edge that people will run into. Also in the future we can reduce our byte size by making all the svg props optional.
 2 things that I think would need answers before we can merge:
- What do we do about collisions? `injectDOMPropertyConfig` will overwrite properties (so last wins) but it will append `isCustomAttribute` which will short-circuit. This feels a little inconsistent and will need to be well documented.
- Do we want to be able to uninject (eject?) a config?
 I did this upstream. We decided to not expose the API publicly yet since we have a few unanswered questions. But at least now the core is injectable such that it's easy to build an API for this in the future.
 The upstream commit synced back down: 32423a83fc9c9c8dc1eac8f769a581e09a2ba74f
 @kirbysayshi You should just be able to do `<div data-custom-uri={this.props.uri} />` and it'll work. `data-` attributes are special cased.
  @Swivelgames Not sure if I understand, my intention with `attrs-*` (or rather `attrs=` to align with the coming `data=` and `aria=`) is that it would translate directly to attributes on the node. So `<span attrs={{abc: 123}} />` would yield `<span abc="123" />`.
 @janhancic `this.ref.myInput.getDOMNode().setAttribute('nwdirectory')` in `componentDidMount` is a work-around until there's movement on this.
 We want to move to a model where we render all attributes that you provide. Without a whitelist. There are a few concerns though.

It's a bit dangerous because we might need to change the meaning and signature of those attributes. E.g. as complex properties gets added to HTML, your code might break between versions. We prefer rich data types instead of strings.

We also have the issue of patterns like `transferPropsTo` used to transfer too many properties and people specified invalid HTML properties. These used to be silently ignored. We would need to provide a nice upgrade path for this case.

We could probably do it for web-components but not HTML or we could commit to always supporting string values and try to find an upgrade path for existing code.
 @gaearon Yes, but properties are riskier. You're less likely to rely on a property (unless you patch prototypes) than an attribute. We try to model them as properties when possible.
 For custom elements, we can only really support simple strings since we don't have any rich information about what they will be. For known HTML elements we can use rich data structures for `style`, `classList`, matrices for SVG attributes, etc. Maybe the solution is to simply use `setAttribute` if a string is provided when we also have rich property support. E.g. `style` would accept a string. Although that's a security risk so we might not allow that.

The nested `stringAttrs` property could work, but even then, it might not be great from a security perspective and not very elegant.

I think we can find a way to support all the things. My primary concern is the upgrade path. I have some ideas there.

We could replace existing uses of `<div {...this.props} />` with a wrapper that only propagates the whitelist. E.g. `<ConstrainedLegacyDiv {...this.props} />`
 @sebmarkbage You are definitely the authority on this, but to me it seems natural to otherwise simply add a dedicated prop for "setting attributes/properties with raw values on DOM nodes" (i.e. `attrs={...}`) which also comes with the understanding that whatever you provide it the attr gets set to.

It's probably not a very nice idea at all applied to custom elements, but then again, making the default implementation for all DOM elements non-whitelisted is definitely not nice either IMHO, especially as it conflates two very different behaviors without any hint as to which one you'll get.

Obviously, just custom elements could be "pass-through" and it kind of fits nicely with the fact that they too are uniquely named (apart from handful SVG nodes that conflict, unless they need their own namespace anyway?).

Anyway, just rambling here. :)
 My rationale is that it is unlikely that a DOM property that accepts a string would have different behavior from the attribute. E.g. `.setAttribute('class', str)` has the same semantics as `.className = str`.

Except for the imperative quirks of what time they're mutated. Browsers have bugs or unintuitive behavior for when they update, and at which time you would want to invoke the setter. There's also internal state in the component that might update a property while leaving the attribute the same.

The point is that even if we added the special behavior for `className` later on, the behavior would be unaffected - except to fix unexpected life-cycle quirks. Having an `attrs={...}` escape makes it confusing how those differ from the other properties and they also don't get the bug fixes from the other properties.
 @jstrimpel We want to avoid adding "configs" because they make things more complicated for users (more api surface area, more things that could go wrong / introduce component incompatibilities) and they make it more difficult for us (more permutations of conditions need to be tested).  We know we want to get rid of the attributes whitelist anyway, so it makes no sense to introduce a "config" and then take it away in the subsequent release.
 Oops, didn't mean to close.
 @Aaronius It's something we want to do. Until then, I'm happy to take a PR adding "is".
 @jhicken Currently we skip the whitelisting check if the component name contains a dash.  To enable component inheritance, you would need to also skip the whitelist check if the component contained an `is` attribute; that would allow you to have arbitrary properties on your custom element.
 @jsfb Do we? I know we talked about it but that's not what the code looks like:

https://github.com/facebook/react/blob/0183f70797183ae5371f61a40c1c13991cd7b104/src/browser/ui/ReactDOMComponent.js#L435-L441
 @ljharb For custom elements, I.e. tags with dashes in them, yes. That has landed in master. For other tags, no. What is the use case? Is it an attribute with a dash in it? We might be able to support that.

@jhicken Custom elements uses "attributes" where as HTML nodes uses "properties". That's why they have different names. We don't intend to change that. It is just a consequence of custom elements relying heavily on attributes but the proper way to interact with DOM is through properties.
 @jhicken We don't know what `className` might mean for a custom component. That might be the name of a legit attribute so if we were to convert it, we would now do some weird magic work that breaks that API. Unlike properties, attributes can only be strings so not all APIs can safely be converted. Additionally, you'll notice that event listeners won't work for these. Same for styles.

It is the opinion of the designers of web components and the spec that attributes is a mistake and should not be used directly. It is a serialized form. It shouldn't be used directly for anything other than serialized HTML, and then properties should take over. However, this is not really how most custom elements are consumed. The public APIs right now are mostly attributes. If properties are made available they're typically imperative methods that doesn't translate well to React's declarative API. We're forced to use attributes since it is the only thing that is possible for custom elements.

For consistency, the only solution would be to revert what we do for normal HTML elements and have them apply attributes instead of properties. That is more intuitive but strictly inferior since it doesn't allow us to properly model things like `classList`, `transform`, `defaultValue` vs. `value`, `checked` etc. These are not just attribute strings, they come with richer data structures or richer behavior differences than the serialized form allows for.

More over, it is our opinion (and the opinion of the React, Ember and Angular teams) that custom elements (Web Components) is a flawed model for composition and it won't be treated as first-class in either framework. There are too many compromises to make that work flawlessly.

We don't want to compromise the primary HTML API to support the custom elements edge case. So unfortunately, that's how we end up with this subpar API.

The recommended solution is to wrap your Web Components in a React component that can provide a richer API and use refs to interact with events / properties / methods. As part of that you can always translate the names as you see fit `<my-component class={this.props.className} />`.

@ljharb We would like to support a non-whitelist solution but not quite sure how to tackle it safely right now. As a workaround you can always get a `ref` on an element and call `setAttribute('nopin', '')` on it yourself. Ofc, this is annoying to do many times but best practice is to build small reusable components that you compose, if you do that then you should only need to use this hack once.

Btw, I will address these issues in my React Europe talk on July 2nd.
 Oh, this is for server-side rendering? Yea, that sucks. Maybe Pinterest should be nicer community members and use the `data-` namespace like it was intended. :( 
 Oh, I assumed this was for the browser extension that adds "Pin It" buttons to everything.
 `data-pin-nopin="true"`: https://github.com/pinterest/widgets/issues/29
 Nice @spicyj! Problem solved. I figured I should've checked for alternatives but I'm sick in bed and also lazy.
 @Gozala Yes, we understand. That's why this issue is still open.
 @ajfarkas `xlinkHref={...}` works already in 0.14.
 `<use>` tags (and all SVG tags and attributes) should work in master and will work in v15.

What do you mean about changing your code?
 @tnrich

For not yet supported attributes, you can put `ref` on the element and call `setAttribute()` manually.

For example:

``` js
return <div ref={node => node && node.setAttribute('inert', '')} />
```
 What if there's both `react-angular` and `react-ng` libraries both integrating using the same attributes?
 The server renderer not having an alternative way to fix this particular problem is unfortunate. We should fix that in isolation. Spawned a new issue. https://github.com/facebook/react/issues/6798
  Personally, I would prefer to try to write forward thinking JS and backwards support with shims/shams, rather than inlining those workarounds.

The `SyntheticMouseEvents` change we should definitely take though since that's just pure correctness and not an IE8 issue. Can you pull that out to a separate PR so it can be merged independently?
  Is this only an issue with iOS4 and below? Can we just generate markup for every node with `onclick=""` on the affected browsers?
 Does it only happens for onClick or also for onTouchStart, onDblClick ...?

Does attaching an onClick event listener to the dom node fixes the issue?

## 

Christopher "vjeux" Chedeau
Facebook Engineer
http://blog.vjeux.com/

On Jun 27, 2013, at 10:45 PM, Lee Byron notifications@github.com wrote:

> style="cursor:pointer" also fixes this :)
> 
> ‚Äî
> Reply to this email directly or view it on GitHub.
 Sorry about that -- we have #1169 open now.
 It's fixed in 0.14 beta and will be in the final 0.14 as well.
 As I said, this is fixed in 0.14 which will be released soon.
 @uzarubin Haven't heard of this. I just tested with http://react.jsbin.com/vovuzexiza/edit?html,js (http://react.jsbin.com/vovuzexiza) and it seems to work fine.
 This issue has been fixed. If you're seeing the wrong behavior from React still, please open a new issue with a minimal repro case.
  @syranide Sorry, not sure I understand?
 Doesn't seem so. With ES6 template literals you can do

```
title={`Hello ${name}`}
```

which isn't too bad, so I'll close this out. (Maybe we can drop the outer curlies there someday.)
  @mathieumg Can you sign the CLA (https://developers.facebook.com/opensource/cla), and then we'll get this in!
 Awesome, thanks! That first change isn't actually important but doesn't hurt and keeps things consistent so :thumbsup: 
   Adding a page saying that you can write the following code

```
React.createClass({
  props: {
    someNumber: React.Props.
  }
})

-- 
Christopher "vjeux" Chedeau
Facebook Engineer
http://blog.vjeux.com/

On Jun 30, 2013, at 10:34 PM, Eric Clemmons <notifications@github.com> wrote:

> Granted, this is a placeholder for a todo you already have in mind, but what exactly are you looking for regarding documentation?
> 
> ‚Äî
> Reply to this email directly or view it on GitHub.
```
 It's now in the doc :) http://facebook.github.io/react/docs/reusable-components.html
  You're right!

I've been working on this problem recently, and I'm very close to a solution that will allow `ATTR_NAME` to be changed at will in this file: https://github.com/facebook/react/blob/a9b024330c/src/core/ReactID.js#L24

My plan was to use `data-reactid`, which is almost identical to your suggestion.
 This is in! https://github.com/facebook/react/commit/67cf44e7c18e068e3f39462b7ac7149eee58d3e5
  It might be best to think of `setState` as being `enqueueStateUpdate`. With that understanding, much of that confusion seems to go away. I have been pondering the exact same thing as you - should we let you "read" the state updates immediately after you write them, even if the UI has not been synchronized with it? At first I thought we should let you read the update immediately. But then I realized something: Not allowing reads of state after enqueueing the updates has an interesting effect. It encourage you to aggregate the entire update payload into a single object and execute a single `setState`. Since mutations are the hardest things in the world to understand, it makes sense to encourage squeezing them into small, centralized parts of your code. There's a theory that it's better to have all the crap in one pile, as opposed to spreading it out all over your code. Depending on how you feel about mutations, that stance might apply here. I haven't thought enough about this to feel strongly in either way, but I thought I'd share my recent thoughts - I've gone back and forth on this one.
 Any more concerns about this? I'm guessing this is still an issue, though I'm not sure how often people are hitting it.

I think another option would be to simply restrict you to a single `setState` call at certain points in the lifecycle. We'd count in `__DEV__`, have invariants as needed, and then reset at the right times. Does that make sense?
 One issue with updating this.state, even though you haven't flushed it accordingly, is that your system (React) is not consistent with itself. So for example, if you have a `ref="myThing"`, and it accepts `props` that should be influenced by your `state`, `this.refs.myThing.answerQuestion()` returns an answer that does not take into account your `state`, but `this.answerMyOwnQuestion()` _does_ take into account the change in `this.state`. I think we talked about adding a `setStateSync()` method for the times when you really want it to flush - though you don't get the performance benefit of your diff.
 If you include closures in your render function as callbacks you can have similar problems. Likewise refs can be inconsistent, but also props if your parent doesn't flush down to you before your callback is invoked.

Deferred reconciliation (batching) puts the whole system in an inconsistent state and to do this correctly you really have to reconcile anything that you may have dependencies on during your side-effectful operation.

It turns out that this is a much more complex issue that this.state alone.
 @th0r `forceUpdate` will bypass `shouldComponentUpdate`
 @aldendaniels I think you've mixed two concepts.

You're 100% correct about `PureRenderMixin`'s implementation of `shouldComponentUpdate()`. It is only safe if your props and state use immutable values (including string, number, bool).

However independent of any `shouldComponentUpdate` implementation, `setState` is still perfectly safe to use, even if you're using mutable data in your props and state. 

In fact, you should **never** mutate `this.state` directly, as that _is_ considered immutable.
 There is a difference between `this.state.foo = mutation;` and `this.state.nestedObject.foo = mutation;`. The later is still accepted. The former is a bit of a gray area but is considered an anti-pattern since that object is considered "owned" by React.
 Yes, to clarify:

This is okay:

``` js
this.state.myArray.push(newValue);
this.forceUpdate();
```

This is _not_ okay:

``` js
this.state.myArray = newArrayValue;
this.forceUpdate();
```
 But this is preferable:

``` js
var pushedArray = this.state.myArray;
pushedArray.push(newValue);
this.setState({ myArray: pushedArray });
```
 @markmarijnissen @SystemParadox, `setState` can take a function as of React 0.13 and solves the problem of pending state.
 @azoerb's checkAlarm example can be rewritten as:

``` js
checkAlarm: function() {
  this.setState(state => ({
    alarmSet: state.alarmTime > 0 && state.elapsedTime < state.alarmTime
  }));
}
```

One of the most important performance improvements that React introduced was a way to avoid read/write thrash through batching using a declarative update model that doesn't depend on the order of execution. This solidifies part of the behavior that made React fast enough to begin with.

The mental model should be that state is part of the return value. You can introduce mutable data structures that allow you to mutate things as you go, but non-local mutable state is very difficult to reason about at scale so we would recommend that you use the functional approach.

This scheduling work is also part of what makes React performant and how we can make it even more performant.
 That would only be possible with a synchronous flushing mechanism like @markmarijnissen proposed.

Take the check alarm example. It is safe for me to move elapsedTime to props like this:

``` js
checkAlarm: function() {
  this.setState((state, props) => ({
    alarmSet: state.alarmTime > 0 && props.elapsedTime < state.alarmTime
  }));
}
```

However, it is not safe in the case `state` is synchronously updated, but `props` are not. E.g. this is not safe even if state is up-to-date:

``` js
this.setState({
  alarmSet: this.state.alarmTime > 0 && this.props.elapsedTime < this.state.alarmTime
});
```

You would have to introduce a synchronous `this.flush();` to be able to read from props synchronously.

Now if you have two of these in the same subtree, you will have one unnecessary rerender of the entire tree. If you have 15 of these updates in the same subtree you have 14 unnecessary rerenders.
 @SystemParadox 

```
getData: function (params) {
    var self = this;
    getSomeDataAsynchronously(params, function (data) {
        self.setState({ data: data });
    });
},

handleFooChange: function (value) {
    this.setState({ foo: value });
    var params = {
        foo: value,
        bar: this.state.bar,
    };
    this.getData(params);
},

handleBarChange: function (value) {
    this.setState({ bar: value });
    var params = {
        foo: this.state.foo,
        bar: value,
    };
    this.getData(params);
},
```

Does that do what you want?

I agree it's a slightly ugly hack/workaround, but assuming I'm understanding your question correctly, that should do what you want.
 > What we wanted to do was change the state and fire off the async call in the same turn

Is there a reason this is effectively different from doing them separately?
 Closing this out because we're not going to change anything, at least with our current component syntax. The recommended way to do transactional updates is:

``` js
    this.setState((state) => ({x: state.x + 1}));
    this.setState((state) => ({x: state.x + 1}));
```
  fYou must first pass the source code through the JSX transform. Once that is done, everything should work perfectly. One benefit to how we've proceeded with JSX, is that we preserve line numbers in the transforms so using lint (once transformed) will "just work".

That means that jslint will even catch:

```
var p = <Typeahead />
```

If `Typeahead` is not a variable in scope! (It will complain that `Typeahead` is not defined.) I have a customized version of a vim jslint plugin that highlights lint errors with a red underline. I'm just working on getting Windows support. Would something like that work for you? What's your lint flow?
 You can do this with jsx --watch. The in-place transform may benefit you as well; the tool supports a --extension directive such that you can transform .jsx files to .js files alongside each other.
 No problem @TyroneMichael . I was experimenting with the idea of forking jshint to build jsxhint; if this is something you're interested in please let me know (not saying I can get it done anytime soon, but can try to get it on the roadmap at least.)
 I wonder if you could hack your jshint plugin to run jsx first before passing off to jshint? #dogscience...
 @danielmiladinov: How do they handle things like coffeescript linting? I'd really seriously recommend doing it right, and not avoiding certain regions. The reason is that you're actually missing some seriously awesome linting action by ignoring regions.

```
<Typeahead
    userName={"user:" + theUserName}
/>
```

Is just sugar for

```
Typeahead({
    userName:"user:" + theUserName
});
```

In my Vim linter, it tells me if `Typeahead` is not defined, or if I've mispelled `theUserName` or if `theUserName` variable is not in scope etc. Are there any webstorm linting plugins that you could fork? I'm sure people around here would help you integrate `jsx` + `jshint` into it.
 Do you think jshint would be receptive to a syntax transform patch?
 @petehunt: It's hard to tell. JS+JSX is a superset of JavaScript, and syntactically compliant with E4X, which is another variant of JS - the trouble is that JSHint would need to assume the particular transformation that we apply (simple function calls) in order to extract value from the linting process. Then again, would anyone want to transform JSX into anything other than function calls (or something congruent with respect to linting)? Likely not.
 For those who missed it, https://github.com/Enome/jshintreact may help, at least in the short term.
 Another version from @toddself https://github.com/CondeNast/JSXHint
  Welp, I wasn't expecting anybody to go for it yet, so bravo! We're going to have to do some big changes internally before we can merge this in (since we're still using `content` in a bunch of places). I'll work on getting that changed today so we can move forward with this
 > :) Figured that might be the case. (I'm just creating merge conflicts for myself with my textarea pull request anyway. Ah well.)

Just saw this, haha. Bravo @spicyj.
  @ldhieu Yea, this is expected behavior with JS. One common solution when working with decimals (eg, currency) is to just use whole numbers, then divide by some number when you need to display the number to a use. $1.01 would be stored as 101 and then when displaying that to the user you would do `num / 100`.
  @spicyj if you need some help with this lmk and I can stack a commit on top of this or something :) I'm really excited about landing this!
 This is great. Along the lines of your `TODO`, have you considered queueing mounting, also?
 The revised version makes a ton of sense. I love the direction and agree with the `TODO` comments. :+1: 
 if @yungsters is good, I'm good.
 @spicyj looks like you've got a failing test; can you take a look? I tried the naive approach of surrounding with batchedUpdates() but it didn't work.
  `/** @jsx React.DOM */` is pretty annoying noise. Let's stop requiring it. We can probably keep it simple for now but if we want to make JSX more generic and standalone we might need to do this a bit more carefully.
 :+1:

What are you thinking as a substitute? We should cover in-browser transforms as well as something like require.js (with or without in-browser transforms). Have you thought of using the `Module.react.js` convention? If we went with that, all the editors will not break.
 Well, we need to consider if we want JSX to be general purpose. As we talk about pulling it into it's own project we need to think about how it'll get used. If we want to keep with this idea that it's generic and you can plug in any "namespace", then we need to keep that working. Right now the transform takes `@jsx Namespace` and uses that to turn `<div>` into `Namespace.div`. But then we also have to make sure we support other transforms (e.g. React's displayName) that will be tool specific. Also, if I plug in a pure wrapper that does `document.createElement`, then I don't want to support custom components.

If we didn't have the concern of supporting other targets, then I would just say we'll transform anything that's `type="text/jsx"` and `*.jsx` on the command line (or `*.react.js`).

For the in-browser transform, we talked about doing something like `<script src="file.js" type="text/jsx" data-jsx-namespace="React.DOM"></script>`. Still doesn't quite solve the multiple transform possibilities without a map from namespace to transforms (React.DOM would use react and reactDisplayName).

For `bin/jsx` we could start accepting a list of transforms? If we assume JSX is a separate package, it ships the `jsx` executable. Then React would depend on JSX. React could ship the set of transforms it needs and maybe create a customized `reactjsx` executable that is basically just an alias to `jsx --transform react --transform reactDisplayName $1` or whatever.
 That long docblock should just work right now actually :) We aren't _that_ strict about the format so long as it's in the first docblock in the file. I haven't tested but if that doesn't work, let me know.

And that assumption that anything passed to `bin/jsx` just works is a good one to make. But it doesn't actually work right now :/
 Related to #832.
 https://github.com/facebook/react/commit/c4658c1728b39c452a86f371ecb1c51874456107
 @fyyyyy You can continue to use react-tools 0.11 or make your own custom transformer, like https://github.com/Raynos/mercury-jsx.
  Seems like the right thing to do! :+1:
  @benjamn Should we fix this in commoner?
 Oh, interesting. I dealt with a related problem with Emacs `~` files a while back:
https://github.com/benjamn/commoner/commit/4ed07b31a6ccafe3423f0f52194c12662df16cd2

Definitely a thing that Commoner should handle intelligently.
 What if the tie was broken according to the length of the filename (shortest wins)? Is that too much of a hack?
 What do other things (like `coffee`) do? This can't be a new problem...
 @zpao good call; turns out CoffeeScript doesn't try to be super clever about this: https://github.com/jashkenas/coffee-script/blob/8e90aaefc1/lib/coffee-script/command.js#L33-L35
 Fixed in Commoner 0.8.1: https://github.com/benjamn/commoner/issues/31
  Good catch!
  Browsers do special things on self-closing tags like `<p>`:

http://jsfiddle.net/bbrGq/1/

React should warn or throw if it detects a nested React.DOM.p.
 ‚àö react has no idea though
 Related #1987
 I'm just going to close this out. We left it open a long time but we haven't made any progress apart from improved error messages. It's still a hard problem to solve in a reasonable way, so I'm calling it off.
 @zpao Like I mentioned in my "no data-reactid"-PR, it is possible to catch this immediately as it occurs really quite cheaply (so it's a good fit for DEV at the very least) and it's just a few lines of code as well. Considering that PROD-behavior would stay lenient, the DEV/PROD inconsistency shouldn't be an issue either.
  @spicyj is totally right. I was hoping to have 0.4 out before anybody hit this issue but since we're still working on 0.4, I'll put out 0.3.3 on Monday. Sorry @remixz!
 0.3.3 came out a while ago and we're up at 0.4.2 now. Let me know if you still have any issues!
  Great intuition. Several of us have thought about this opportunity and are thinking about approaches very similar to what you suggest. One of the benefits of defining style rules and css class specifications in JavaScript, is that you can use the full power of JavaScript to define styles, which we already have ways to model dependencies for. We wouldn't need another language like SASS or Less. Also, as you mention, since we also own the rendering/abstraction framework, we can ensure that we don't polute the CSS namespace. We can also ensure that components don't target nodes/class names that should be considered an implementation detail (concern) of a deeper component.
 You can do the following right now:

```
getStyle: function() {
  return {
    fruit: {border: '1px solid black'}
  }
},
render: function() {
  return <div style={this.getStyle()}>Hello</div>;
}
```

Let's close this out until someone comes with a real proposal :)
  :+1: 
 A simple test case here would be great too, since it's unlikely this will have many callsites in prod code for a while it may break and go unnoticed without one.
   without looking at anything but the screenshot, I feel strongly that "pitfalls" should not be the 2nd thing in our reference material
 Thanks @vjeux and good point @zpao!
 ![image](https://f.cloud.github.com/assets/197597/646325/7b991430-d3c6-11e2-93f6-8554d70565cf.png)
 Ping @zpao 
 You could have the nav text be: "JSX: Not HTML". Also you could replace "debated" with "discussed". But does anyone have a strong objection to having this doc in general? If not, we should fix the small nits and get it in. Iterate.

I like the idea of an appendix, in general. A place to put the information for people who are getting serious.
 yolo
 I aggro-committed a few minor edits https://github.com/facebook/react/commit/fad7d58fc9ef8da03acc6f4d1a11a2844f4cd2ce
  Thanks for doing this. Also, small jsfiddles like that are great to demonstrate issues/ideas (much thanks to @vjeux for jsfiddle know-how).

Don't you just love that the DOM uses `innerHTML` to determine the initial value, and the `.value` property to determine updated values? :) Who comes up with this stuff!

Regarding the approach: What if our `DOMProperty` module was smart enough to model the fact that one property name may be aliased to another on updates/mutation, on a per tag name basis?
For example, in this case `children` could be aliased to `value` on updates. However, I'm not opposed to your proposed approach - just wondering if there's a way to model this that can handle a bunch of future DOM inconsistencies that we encounter.
 That sounds fine - especially since there's likely some other things we want to do to text inputs to make their API more reactive - this is probably just the start. Nice stuff.
 Overall I like this very much :)
 Okay, let's update this bad boy and get it in. :+1: 
 Sweet, sorry for the delay in reviewing this (was out sick last week).

My only remaining concern is how we deal with arrays. I think joining arrays will reduce developer friction while still having reasonable behavior in the worse case:

``` javascript
// It would make this work...
<textarea>Hello, {name}</textarea>
// <textarea>Hello, Tim</textarea>

// While still having non-horrible fallback behavior...
<textarea>Hello, <span>{name}</span></textarea>
// <textarea>Hello, [object Object]</textarea>
```

As for supporting `content`, well... I didn't realize you were the author of that one, too... :+1: 
 @spicyj Don't worry about it.

I have a diff that builds on top of this (internally) already. I'm going to make children behave as `defaultValue` and recommend that people use `defaultValue` and `value` instead (which is less ambiguous and less prone to wrong usage).

Would you be comfortable with me merging this as is?
  I can see why that would cause issues‚Ä¶ The way you're thinking about sounds like common sense so I hope that's actually true and that we're just firing these callbacks in the wrong order. So _I_ agree, but that's without looking at the code closely
 I think this makes sense. Here's my reasoning: One of the few valid reasons for wanting to use `componentDidMount(node)` (besides integrating with other frameworks) is to measure something's container. In order to do that accurately, the children might also want to have measured their own containers. For the parent's measurement to be accurate, the child's `componentDidMount` must have already completed.
  cc @yungsters 
 > Does it make sense to pass on the native event? Since it could be one of seven different types, I'm not sure that application code would be able to do anything useful with it.

Yes, keep passing it along. It's up to the end user to do what they will with it, but I have a new set of "synthetic events" that will allow us to normalize the API for both DOM and custom events like the one you're adding.
  :+1: 
 +1
 I'mma jump on the :+1: bandwagon too. Great idea.
  Mostly trivial things that should have been caught upstream + some jshint directives to ignore empty block warnings in those files. We might want to eventually clean those up anway.

I'm trying this thing where I work exclusively in the github repo and try to improve the sync process. To that end, feel free to "accept" here but don't merge it in.
 Yea, we said `grunt lint` should be clean before submitting pull requests but then we didn't stick to that rule :) Sorry for the confusion!
 needs rebase
 Did this upstream instead (more comprehensive linter): 315645804133e190e23be954787f5d64144d33d5
  Hypothesis: The only thing that keeps commoner from exiting in `--watch` mode right now is the `{ persistent: true }` option passed to `fs.watch`. That means the process will stay alive while there are any files left to watch. But some text editors save files by deleting and then re-writing them, which causes fs.watch to un-watch the file (because the original inode that inotify cared about got discarded).

When there's only one file, unwatching it causes Node to think no files need to be watched, so the process exits.

cc @jeffreylin
 Opened a new Commoner issue: https://github.com/benjamn/commoner/issues/18

Even though @akrieger said the Commoner tests pass for him, that's only because `--watch` mode test coverage is‚Ä¶ lacking. :frowning:
 That's another regrettable but known issue: I suspect you're missing the `/** @jsx React.DOM */` comment at the top of the file (which won't be necessary soon, but currently is still important).

cc @zpao
 Just to try something else: `bin/jsx` can take a single file name on the command line: `bin/jsx app/helloworld.js`. Does that also not show any transformations? Or did you try that already?
 The deletion is by design, at least. The files that end up in the output directory are actually hard-linked with master versions that are kept (by default) in `~/.commoner/module-cache/*.js`. Each build unlinks and then relinks the files in the output directory, so if the relink fails it will look like the file was just deleted.

Not sure why the relinking might be failing.

In case `~/.commoner` is on a different device from `node_modules`, you could try relocating the cache:

```
bin/jsx --cache-dir module-cache -w js/ html/js/
```
 Accidental close, sorry. Still need to mitigate that cache dir problem.
 How important is the cache behavior? Could we disable it? I'd trade perf for ease of use with this tool
 :thumbsup: to what @petehunt said. I'd also take defaulting the cachedir to the src/current dir (I think this is how sass does it's cache)
 @petehunt pretty important; the incremental speedup is significant for a codebase the size of `react-tools/src/`

It's a one-line change to switch the default location, and it won't break anything for anyone. Kicking myself now because I actually considered whether ~/.commoner was likely ever to be a different device, and clearly I guessed wrong :(
 I wonder if the requirements that we need for the react codebase are the same as those for end users. I think most people just want a simple syntax transform and watcher ala coffee script.
 Also +1 on just moving the cache dir :)
 @petehunt true, but I don't think we can pretend that `bin/jsx` is a fully-featured source transform tool if it doesn't do any caching (coffeescript and sass clearly suggest that caching is worthwhile for enough people)

The original location of the cache directory was `outputDir/.module-cache`, but I moved it when I added support for printing the transformed code to STDIN, in which case there's no `outputDir`. Definitely okay with skipping the cache logic in that case.
 So I've been looking through various implementations of Dir watchers (gaze, chokidar) in NodeJS and they're all pretty clowny - a pretty easy test case that breaks them is making a new directory and adding files to that directory.

So since someone on the internet was wrong, I wrote another FS watcher last night that I think is way more stable:
https://gist.github.com/jeffreylin/5df1c95b57982720d444

I'll try to merge this new file watcher with the transformer I made a couple days ago (https://github.com/jeffreylin/transformer_fun) and see what happens just as proof of concept.

@akrieger - I'll probably have something for you to play w/ in an hour or two =]
 I had pretty good results with a makefile and running make every 2s :P
 @petehunt now you're trolling me :P
 Not trolling; it's very reliable and easy to reason about. Is comparing file mtimes to determine if they need to be rebuilt bad relative to a module cache?
 @akrieger give https://github.com/jeffreylin/jsx_transformer_fun a shot - still a work-in-progress, but lmk how it goes
 Dear @petehunt,

Your question deserves a careful response. I know this looks long-winded, but if you read it through you'll know everything that I was thinking.

The primary virtue of the module cache is that the cache filenames are hashes of all the relevant input variables: source, module name, build steps, configuration properties, Commoner version, and more. Change any one of those input variables and you get a different hash. If you find a file called `<hash>.js` in the module cache, you can be completely certain that the cached file contains the right contents. I believe that's a useful guarantee.

A secondary benefit is that old versions of a file don't go away just because the file was recently rebuilt. If you revert a file to a version that has ever been built before, you don't have to rebuild it again. In order to make the same promise under the `mtime` strategy, you'd have to find some way of storing all those distinct versions, and I'm confident the method you would come up with would closely resemble my hashing strategy. It's what every sensible version control system does.

The goal of both strategies is to determine whether you can trust the contents of a file that was built some time in the past. This decision is completely reliable under a hashing strategy, and if it ever fails then there must be some additional piece of information that you neglected to incorporate into the hash. None of the bugs that I've fixed in Commoner had anything to do with module cache inconsistency. When's the last time you had to wipe your module cache? And no, `grunt clean` doesn't qualify, because I made sure it left the cache untouched.

With that background, let me answer your orginal question: "Is comparing file `mtime`s to determine if they need to be rebuilt bad relative to a module cache?" Yes, because the only input variables considered by the `mtime` strategy are (name of source file, `mtime` of source file), which allows you to avoid rebuilding the file if
1. the corresponding output file has a later `mtime`, and
2. you know no other input variables have changed in the meantime, such as build steps, configuration properties, new files added/removed whose presence/absence affects the build, independent build processes racing to update files in the output directory, etc.

Requirement 1 is too strong because you don't _necessarily_ have to rebuild source files that appear newer than their output files (see my second paragraph above).

Requirement 2 is too strong because you don't have to "know" any of those things if they can be accounted for automatically, as they are under the hashing strategy.

Is the `mtime` strategy good enough? Maybe it is for you, because you know how to spot signs of inconsistency and you have trained yourself to predict when a `make clean` is finally necessary. I don't think we can expect the same of new users of React. They're much more likely to attribute subtle problems to the library itself instead of guessing that the build tool messed up.

Sometimes we reinvent the wheel just so that we know exactly how the wheel we're using works, quirks and all. I'm guilty of this myself, but in my defense I really am trying to get us to a point where we don't have to make any apologies at all for the way our tools work. I know there are still bugs in Commoner, but I'm committed to squashing all of them.
 I'm not hating on commoner. It's an excellent CommonJS build system and is totally the right choice to build react and any jsx project that uses CommonJS modules with transforms. 

The problem is that users think it is a simple syntax transform (like coffee?) when in reality it doesn't behave that way. Specifically it assumes that everything you're desugaring is a CommonJS module and it assumes specifics of the implementations path resolution methods, which in requirejs, browserify and haste are all different, by relativizing. 

If you aren't using CommonJS and define your own unrelated require() function the arguments will get rewritten, weird missing module warnings will fire and fake modules will be created. It's actually really freaking awesome to have this tooling for CommonJS projects but really confusing if you're not in a CommonJS project or using a different module resolver. Some of the annoyances we've faced with r.js are because it tries to be too clever in this area (we have eval('req'+'uire')(...) somewhere in the insta codebase because of this). 

As a user since I know jsx is willing to rewrite my code I find it hard to predict exactly how it will transform. 

What if instead jsx had a --relativize option that we disabled by default and it just treated everything like a file and transformed it, either with a cache or based on mtime? We'd continue to use the option on react itself and perhaps even advertise commoner+a browser packager (brigade?) as our recommended module system since they'll likely want debranching and other goodies even though they don't know it yet :)
 The original issue still needs fixing, by the way. Still working on that.
  This is the common case - let's make it the default, so you don't need to wrap methods in `React.autoBind`.
 Should have closed this :) thanks!
  @adambrunner yep, that's the only way right now (though I use `{' '}` directly, myself). This is definitely something we want to fix.
 cc @jeffmo 
 I think I'm onboard with this conceptually. I think this set of rules is, at least, the most intuitive we've come up with thus far. Sounds like everyone else is on board too, so lets do it.

(man, whitespace is a bitch...)
 Is this something we could provide a codemod/recast script for?

When we tweaked this.props.children from always being an array to sometimes being an array it was a _huge_ headache for IG since every callsite had to be manually tested. I want to make sure we don't have to test every callsite and look at whitespace to be sure.
 Fixed by #480.
  Fixed with a64faf7bf7edeab22490c617d1c579e6103a5da0 and re-rolled the site, should be up in a few minutes. Thanks for the heads up!
  Continuing the flatter, less drop-shadowy look.

I also made some content changes in a separate diff.
 :thumbsdown: I like the blue logo
 Blue totally clashes with the red. At the very least the saturation should be turned down. 
 Here's the screenshot: IMHO, this looks far cleaner and consistent. I also adjusted a bunch of spacing.
Just search dribble for the word UI: http://dribbble.com/search?q=UI
It seems like this represents a more modern look.

![newscreen](https://f.cloud.github.com/assets/977348/613940/0a561608-ce10-11e2-9386-270e9e6982bd.png)
 I'd be happy to rethink the burnt red as well. It looks much better on white than it does on black.
 Look side by side:

![sidebyside](https://f.cloud.github.com/assets/977348/614033/d2de179a-ce12-11e2-9423-f524545191ed.png)
 I can try adding some dimensionality to the buttons (bottom border) but I feel the color of the buttons were not chosen with the color of the blue in mind so if we keep the blue (or whatever vibrant color we decide on) the buttons need to change IMHO. I think that the shadow under the top bar in the right screenshot makes it difficult to perceive dimensionality in low contrast black on black. It looks "fuzzy".

One thing I'd like to see in the buttons (or everything actually) is dimensionality done tactfully. I like to think that the trick to drop shadows is to make it look like you're not using them.

What about the code boxes below? Now they match the other examples in the documents. Consistency is another thing I'd like to work towards.

Let me play around with the suggestions.
 Here's what it would look like to have a Molokai style color scheme with  a bit of dimensionality added back to the bottom of the buttons:

![electricpink](https://f.cloud.github.com/assets/977348/614832/b26033e0-ce26-11e2-9086-231ee4b24e8b.png)

Talk about popping!
 You can run with the vibrant version into a sort of Molakai theme, including the live editors:
![molakai](https://f.cloud.github.com/assets/977348/614901/229f1896-ce28-11e2-8370-f32873e91da7.png)
 I'll close this out - @leebyron is thinking about overall aesthetics.
  I'm going to let @yungsters chime in here since he's been doing all of the event stuff and I think there's overlap with something he's working on.

I know I promised you our latest upstream changes. I'm still working out the kinks but I got a branch together that will probably get merged in tomorrow. It has everything up until earlier today in it: https://github.com/zpao/react/tree/sync-latest (I still need to pull in #32 and make sure we merge right). Just so you have a better idea of what's coming
 Thanks for tackling this. I actually have a revision that does what you're doing here in a different way. I completely got rid of `NormalizedEventListener` and did it at the top-level module.

I'll try to land the revision ASAP (like later today) and get it synced to GitHub.

BTW, I like your coding style (e.g. splitting arguments onto each line and indenting). I also made similar changes. ;)
  @spicyj, can you rebase this? There are conflicts.
  Are there any `.js` files in `src/` yet?

Also potentially useful: what `node --version` are you running, and what OS?
 Installed 0.8.23 but no luck reproducing. Will try on a Mountain Lion machine tomorrow. Thanks for the report.

Do you see this failure with an empty `.js` file? If using an empty file makes the failure go away, perhaps you can try cutting out different parts of the file to figure out the minimal contents that trigger the failure?

It could be a problem with `fs.watch` on Mountain Lion, though. That's my hunch.
 One more idea: the module cache might have gotten into a bad state somehow. Try clearing it by deleting the directory `~/.commoner/module-cache`?
 I know this is still broken. Still working on a fix.
 @hojberg @hieu - I was having issues w/ vim file writes not being caught so I hacked together https://github.com/jeffreylin/jsx_transformer_fun - Feel free to try it and let me know if it works (Haven't had the time to test on Ubuntu yet...) - We might use the file watcher in that repo in Commoner / JSX in the future.
  Seems sane to me. @jordow?
  The good news is that `build/react.js` works great with RequireJS.

I decided to discourage in-browser transformation, since `JSXTransformer.js` doesn't interoperate nicely with the RequireJS version of `require`, and I'm still struggling to see any benefit in making it do so.

The new `bin/amd` script makes precompilation pretty straightforward, I think.

cc @zpao @petehunt 

Closes #28.
 So this helps, but it doesn't completely solve the problem.

What happens when somebody does `require('react');`?

Does [r.js](https://github.com/jrburke/r.js/) work now? (I know it won't work with react.js, but does this give us a magic solution without a disjoint build step?)
 @zpao I haven't been able to get r.js to work yet (even when I use it generate the `define`-wrapped modules), but I don't see why it shouldn't work.
 @rnd174 Try the tutorial or look at examples we provide in the download (also in the repo). http://facebook.github.io/react/docs/tutorial.html
 @rnd174 I haven't done that but I think that's the sort of question you should ask in the mailing list or on stack overflow, it's not really appropriate for github (and especially on a totally unrelated pull request).
 Glad it's working for you @asbjornenge. I will strongly suggest you have a build step compiling your JSX to JS for production. Using JSXTransformer is really only meant for quick prototyping! In production it will slow down your application considerably and add a lot of extra download size.
 If this is still something we want to do, let's get this updated. Otherwise I'm inclined to just close it out.
 Wrote a quick example which I will fine tune (code documentation mostly) later today, after that I will do a pull request. Basically I'm wrapping the basic-jsx-precompile example with require.js. 
 Going to use #417 instead.
  Good catch, @dschafer is FB so no CLA needed
  We're 2 months into the release, let's close it out :)
  @edc what do you think of this?

```
var HelloMessage = React.createClass({
  render: function() {
    return React.DOM.div(null, 'Hello ' + this.props.name);
  }
});
```

This works out of the box (and is what JSX actually compiles down to).

I fear a solution that parses strings because of performance implications, having to include a parser in the core (which is more bytes down the wire) and that it becomes easier to introduce XSS vulnerabilities.
 Well, that's not really better, it's just writing the JSX transform yourself. Which sucks (otherwise we wouldn't have JSX at all). And if we ever decide to change the output of the transform things are going to fail weirdly.

What @edc is proposing is nice in that since it's _just JS_, things like coffeescript can parse it and not choke.

What we could _maybe_ do is have the JSX transform step look for this `_dom_` method and parse the contents, turning it into Reacty code. The only additional bytes are then in the transformer, which isn't bad.
 Ah, now I get what you meant by `gettext`-style. That sounds like a pretty good idea to me.
 @holmsand you may want to check out what coffeekup does: coffeekup.org

You can pass arrays as children today. We try to avoid them for single-child nodes so we can save an array allocation. I bet we could build a jsx-coffee package that wraps up all the ReactNativeComponents in React.DOM to expose this interface pretty easily. What do you think about that approach?
 One of the common use case of JSX is to embed complex Javascript code within the XML like

``` javascript
<ul>
  {this.props.children.map(function(child) {
    return <li>{child}</li>;
  })}
</ul>
```

How would you write that in Coffeescript with your suggested method? Would the code inside of the {} be written in Javascript? Wouldn't that be weird to mix coffeescript and Javascript?
 I think the following can be made to work:

``` xml
<form onSubmit={this.handleSubmit.bind(this)}>
  <input type="text" ref="textInput" />
  <button>Add</button>
</form>
```

``` coffeescript
(form onSubmit: @handleSubmit,
  (input type: 'Text', ref: 'textInput'),
  (button 'Add')
)
```

I think the best course of action is to make a CoffeeScript dedicated wrapper that has a nicer syntax than the constructor we have now.
 With {}

``` coffeescript
(form {onSubmit: @handleSubmit},
  (input {type: 'Text', ref: 'textInput'}),
  (button {}, 'Add')
)
```

With {} and []: {} means attributes, [] means children

``` coffeescript
(form {onSubmit: @handleSubmit}, [
  (input {type: 'Text', ref: 'textInput'}),
  (button ['Add'])
])
```

Where the general form is (name {attributes}, [children]). Only children is optinal
 If you feel like making JSX work on CoffeeScript, that would be awesome :) I don't think that anyone is working on it right now.

About class extension, we could totally do that. We didn't do it because there's no class support on raw Javascript.
 @edc Yes! Nothing on the books yet but if you have suggestions on particular meetups let me know.
 The CoffeeScript [grammar](https://github.com/jashkenas/coffee-script/blob/master/src/grammar.coffee) appears to be fairly well-defined and extensible. So it might be even easier to write a transformer for XML literals in CoffeeScript than it was to implement JSX using Esprima.
 I'm not sure if we can ever make it work but this is valid CoffeeScript :p 

``` coffeescript
_<script>_
_  _<ul>_
_    _<div id="vjeux" /_>_
_  _<_/ul>_
_<_/script>_
```

If you ignore the _ this is also XML :p
 The following could be made to work but doesn't really look like XML anymore and I prefer the version with () {} [] that I talked about earlier

```
R(
  [ul a:"b", b:"c"]
    @props.map (prop) ->
      R(
        [li]
          R([span], prop, [_span])
        [_li]
      )
  [_ul]
)
```
 So if you wanted, you can just use `React.DOM` directly and forget about JSX. @vjeux has done that - check out http://blog.vjeux.com/2013/javascript/react-coffeescript.html

It's the integration of JSX into coffeescript that's hard. coffeescript probably chokes on `<markup>` and our JSX transform works with a JS AST, so it can't parse coffeescript. In order of this to _just work_, support needs to be added at one end of this. We are not currently in a position where we can spend time adding coffeescript support to our transform. Maybe we could add support for a suggestion like `_markup_`, but that would likely end up in a different esprima fork, and we would only be adding this to work around coffeescript.

As to your last point, I'll reiterate that you don't _have to_ use JSX. You can write the `React.DOM()` or `MyComponent()` calls yourself. We use JSX and we think it makes life easier. We've started thinking about some solutions where you can write your render function separately from your component, so your markup could live separately but we haven't gone far down that path. I'm happy to hear your thoughts!
 @chenglou how about something like this? http://jsfiddle.net/hdrV3/1/

Just a thin wrapper around React.DOM to make it more DSLy in CoffeeScript.
 This conversation may interest you: https://groups.google.com/d/msg/reactjs/dpGem2Yr6do/8VuGYEAzqTcJ
 Ok, I don't think _we_ are going to extend the transformer in ways that have been discussed, so I'm just going to close this out. People have found solutions that are working for them in different languages.
 I just found https://github.com/jsdf/coffee-react-transform which appears to be a JSX transformer for CoffeeScript. I haven't tried it but it looks promising -- if anyone here tries it out, it would be great if you could report back with your results.
  Thanks for doing this and for signing the CLA!
  Indeed. This is deceptive and you got a _really_ bad error message. We need to fix that (amongst other things).

Right now scripts need to be prefixed with a docblock to assist the transformer. The fact that it's missing here is causing it to not recognize that it should be converting to JSX. We very much want to fix this ASAP. Sorry that it's causing you issues!

In the mean time, just prefixing your code with this docblock should fix your problem. Please close this out if it does.

```
/**
 * @jsx React.DOM
 */
```

or the condensed version will work too

```
/** @jsx React.DOM */
```
 Follow up: we've updated to stress this in several places. Hopefully it's okay now. 
 I'd like to change the default file extension to `.jsx` and then transform JSX regardless of if the docblock is present; see #832.
 @NSAKHAN It's not supposed to work (right now), you're trying to return multiple components for the root, you can only return one.

**EDIT:** Oh wait, this was for the docblock, you need to add `/** @jsx React.DOM */` at the top of your files.
  Turns out that `Object.create` in NormalizedEventListener is actually causing some bugs, so we just changed that internally. We're still working out the kinks to our code sync process but that should be making it's way to master soon.

In the meantime, if having es5shim+sham on the site would help, we can make that happen.
 es5-sham might be able to go away (I don't actually know all the polyfills we need and which live in shim vs sham). I know for sure we need something to completely support IE8. Even if we get rid of this `Object.create` we have some `Array.isArray` in there. We should document this better.

Our IE8 testing has been facebook.com :) In general though, if you're making internal changes then you'll need to rebuild to test. `grunt build` builds debug and minified builds - you can skip the minified step by just run `grunt build:basic`, might make that cycle a little faster. You could also run the automated tests in browser with `grunt test --debug` which should start a server which you can hit from any browser. This doesn't help the shim issue though, so probably won't be much use in IE8.

Having a no-build way to test would be smart. I bet we could maybe do it using requirejs or maybe a node server that just builds react.js on demand... but for now building is the only option.
 FWIW `grunt test` builds just enough stuff to run the Jasmine specs, so it takes a lot less time than `grunt build`.
 This can be closed now, right @zpao @spicyj ?
 Yea, we talk about all the polyfills needed in the "Browser Suppport and Polyfills" (oh man clownshoes) section of http://facebook.github.io/react/docs/working-with-the-browser.html
  Change looks fine, if you can just put them in alphabetical order with the rest of the DOM properties I can merge.
 Thanks @camspiers ! This is ready to go in.

I actually want to wait until @zpao is around to merge (he's the one who is working on our internal<->github stuff). src/ gets synced back and forth from our internal repo, so I don't want your pull to go in here and then somehow get overwritten when the sync happens (that way you keep attribution). @zpao knows how this works though. Thanks!
 We're still working out the kinks but let's just merge this in and figure out the rest later. We'll never overwrite history in this repo so there will always be record of it :) Thanks Cam!
  If you go on our site, there's nothing that talks about synthetic events, mock DOM, reconciliation, etc. I think documenting this would have a huge impact.
 Good call.
 @jordow: Ping!
 You can find out a little bit more from Lee's post here:
http://www.quora.com/React-JS-Library/How-is-Facebooks-React-JavaScript-library

We'll get some deeper explanations in the official docs. Thank you for your interest and patience!
 New docs mention it :)
  Ah there's a bug in the tutorial; can you add a "return false" to handleSubmit and document that as well? Thanks.
  BTW, I am super stoked to get rid of all the keyUp's in the examples! You rock, thanks for finding high-leverage fixes.
 @spicyj this is awesome and going to be a huge improvement to the framework. I've been wanting to do this for a while.

The overall structure of this code is great. Thanks for making it a new event plugin.

We don't have a precedent for doing the deferred stuff yet. I'd want @jordow's opinion on how to go about that.

But we may be able to make this work without deferring. I am noticing that the events we need to defer are cut, paste, and keyDown. What if instead we got rid of those and just used keyUp and click and threw out all of the deferred stuff? While it'll be slightly slower (waiting for keyUp to reconcile rather than doing it immediately on keyDown), I think it gets us 90% of the way there without forcing us to introduce this deferred concept.

Remember, since this is React, reconciles are generally considered cheap so if we trigger a few extra input events even though the content hasn't changed our reconciler will figure it out and make it a no-op.

Finally, I'd like to get test coverage on the event plugin. If you feel like tackling it, great, but I'm comfortable taking this pull without one and I can add a test case upstream.

@ide @yungsters @jordow whatcha think?
 @spicyj You keep reading my mind. I'll take a closer look at this tonight.
 Looks fine. I'll let @zpao merge this in just in case he wants to test the repo syncing flow.
 I'm actually going to hold off on landing this just because it changes docs and we need to be able to update the docs with the current API. It's going to involve branches and making sure everybody building docs knows the process... it'll be gross but _you_ don't have to do anything, it'll be on me/us. I will merge it in ASAP though.
  These look good to me - I think this better conveys the idea that modifying `this.state` isn't great. Effectively they're the same since we call `setState` anyway.

It looks like @petehunt actually modified these examples since you pulled, so it's probably worth rebasing to make sure you're working from the latest copy
 Yep this is definitely better. This was a hackathon project and still shows in some places :P
  @jeffreylin can you take this one for CDN stuff?
 This might be OK to do short term, but we should do our best to get JSX to a point where we can ask to add JSX to the language choices.
 Ping
 @zpao where should this file live?

Definitely not docs/js. Maybe docs/_js
 This lgtm - I can just toss it on fb.me if you want - lmk what URI you want. Also fwiw, it doesn't have to be the final version - we can always change where the fb.me URI points.
 Something like: http://fb.me/react-js-fiddle-integration.js

I don't really care about the name as long as you give me the final url
 Thanks!
 @vjeux - cool - uploaded to http://fb.me/react-js-fiddle-integration.js - appears to work! =] http://jsfiddle.net/MmRXB/2/
 @vjeux can you send out a pull to add this to the docs somewhere?
  We run React+RequireJS on Instagram.

Check out the repo and run `grunt`. Then under build/ you'll have a bunch of CommonJS modules that RequireJS can use via its `r.js` tool.

Does that answer your question?
 What @petehunt said should work, though it exposes more than you need and might lead to information overload (just look at React.js if you do this! this is what gets exposed by the shipping file).

I was hoping the UMD wrapper we have around react.js would _just work_ if you decided to `require('React');` (or maybe it's `require('react');` If neither of those work then we should definitely try to make this work out of the box without having to do a custom build.
 Lets reopen this then until we ship something that works with require.

We're using browserify with the standalone option (which wraps with UMD) to build a mostly compatible module. I'd like to keep the process as simple as possible so we might want to try to fix this in one of those tools.
 @zpao you mean we should modify browserify so that it generates something that works as an AMD module?

RequireJS does have the ability to load modules on demand, which is a different sort of philosophy from the monolithic package that browserify produces. Both approaches can be worthwhile, and it should be easy to support both. We've just implicitly preferred the monolithic package approach so far.
 > you mean we should modify browserify so that it generates something that works as an AMD module?

Yea. If what @jriecken said is right, then we can maybe get UMD changed (https://github.com/ForbesLindesay/umd/blob/master/template.js#L12 is what gets used by browserify and it very much does not provide a name to `define`).

Again, I'm not super familiar with RequireJS so maybe we need more. react.js is already React with all the dependencies so I don't think we _need_ to ship a bundle of modules and can stick with the single file so long as it actually works
  Hmm, I'm having a hard time reproing this issue... I made repro.js:

```
/**
 * @jsx React.DOM
 */

var CommentBox = React.createClass({render: function() {}}),

        CommentList = React.createClass({render: function() {}});
```

and when I run `./bin/jsx repro.js` I get this:

```
/**
 * @jsx React.DOM
 */

var CommentBox = React.createClass({displayName: 'CommentBox',render: function() {}}),

        CommentList = React.createClass({displayName: 'CommentList',render: function() {}});
```

Did you include the "@jsx" tag in the docblock at the top? Or maybe I'm missing something?
 Aha you're right! It's because we move past the contents of the object literal in the displayName transform step before the react.js transform has a chance to run on the declaration node.

Ok, do you mind filling out our CLA and then I can merge this in for you:
https://developers.facebook.com/opensource/cla
 This looks good to after we clear up line 39 -- thanks a ton for the fix!
  0.3.1 pushed to npm: https://npmjs.org/package/react-tools
  Thanks Martin! I'll take a look at this soon, we've just been following up with some other issues today. Not forgotten though :)
 Hey @martinbean, I'm sorry we haven't made this work. We're actually working a on sizable redesign and I think it's going to be response from the start there (yea @jordwalke?), so I'm going to close this out and let it just happen there. I really appreciate you taking the time to give this a go though!
  Good call. Updating now.
  @seiffert Thanks! And thanks for already signing the CLA :)

@petehunt I'm going to let you take this since the tutorial is mostly your baby and you would know best if you forgot some code or if this is the best route.
 @seiffert thanks for this! You're totally right. I added it in the committed example but didn't update the docs: https://github.com/petehunt/react-tutorial/blob/master/scripts/example.js
  Also, please don't remove the brackets on the code fences. This is what allows us to do line highlighting and call out specific changes in the tutorial.
 On GitHub it won't be - we customized markdown processing a little bit to enable it on the website. That customization actually breaks the highlighting on Github since it's a custom extension. See it in action: http://facebook.github.io/react/docs/tutorial.html
 @jordow I have a mixin that does this for IG that I want to get into react_contrib.

This is probably a good idea for us to do, however if we use React.autoBind() on the function passed to setInterval() it'll suppress the errors when the component unmounts. I'm pretty sure that killing the setInterval() is better though.

I'm inclined to take this (once rebased) if everyone's OK with it.
 We've redone a lot of the docs (and a lot of React) since this was opened so I'm going to just close it out.
  Good catch!
  @mz121star It's an unfortunate side effect of releasing parts of the FB/Instagram infrastructure. That's how we do it internally and we didn't have enough time to clean up and get rid of it. That's very high on our list of things to do now that we've launched.

@andreypopp Nice! Cool to see that happening :) I'll push out the npm update shortly.
 See #114  :)
  Whoa! First off, thanks for diving into this. And also for already signing the CLA :)

Secondly (and this is totally on us for not communicating it well): we actually have our site being built with Jekyll and keep the raw files in the master branch @ https://github.com/facebook/react/tree/master/docs (there's a readme there for getting set up in case you aren't familiar with Ruby/Jekyll). Since we build from that, it's important that changes to documentation are actually made there, and then we compile that and check it into the gh-pages branch.
 Yea, a separate pull request against `master` is probably best. I don't think GH lets you repurpose a pull request against a different branch.

We'll then update `gh-pages` separately (so far we've rolled up multiple changes into one commit there)
  Man, we did a bad job messaging JSX and component architectures in general. This tries to reposition us a little better.

I may beat the JSX horse a little bit, but I think it's one that needs to be beaten.
 @xcambar they definitely are internally, we should look into moving in that direction externally as well. This should be a good start though.
  Bah, I changed build filenames last minute and didn't properly test the module after :( Thanks for finding this! I guess we should write some tests for the node module too, not just our phantomjs tests.

(Very) Short term, you should be able to change `./build/React` to `./build/react` and that will fix the problem.

@benjamn - I guess it's time to figure out what we want to do with npm versions vs library versions. Should we just bump them both for the time being?
 Nope, that alone won't do it, we're not even packaging. I totally screwed up the node module :( Fix soon!
  Nice catch! This is what happens when we're all on little sleep. For now we need all contributors to have a CLA on file. I didn't find one for you so I just need to make sure that you've done that at https://developers.facebook.com/opensource/cla. Let me know when it's done and I'll merge this in. Thanks a lot!
 Awesome. Thanks again!
