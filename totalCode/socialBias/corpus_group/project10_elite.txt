  Can you try again with `DEBUG=nightmare* node yourscript.js` when you run the script? Much more helpful debugging messages will be sent to your console Ahh, just realized you're running the script under `electron`, not `node`. I have no experience doing that, sorry :/  [`nightmare-download-manager`](https://github.com/rosshinkley/nightmare-download-manager) or [`nightmare-inline-download`](https://github.com/rosshinkley/nightmare-inline-download) might help you solve this.  Two questions: one, why are you using `.use()`, and two, what is `x`?  See #434 and #452.  It has to do with preventing virtual desktop switching.

You can deactivate `alwaysOnTop: false` by passing it in as an option.  I'd leave the default as `true` there as it does fix a known problem.  I'm betting you have a race condition with your `.evaluate()` - since the page is refreshing every 1s (per the `meta` block), your `.evaluate()` call may be executing against elements that don't exist (anymore or yet).

Do you have a `.catch()` block?  If so, what does it say?  The short answer is yes - you could certainly use `.evaluate()` and use `document.querySelector()` to get the DOM element, then you have the entirety of CSS to play with.  Off the cuff:

```js
.evaluate(() => {
  var element = document.querySelector('.some-class-name');
  element['new-property'] = 'new-property-value';
  delete element['custom-property'];
})
```
(What I can't recall off the top of my head is if `delete` will actually delete the inline style.  You might want to have a look at MDN.)

Alternatively, you could also use `.inject()` to pull in, say, jQuery to do the same.  This smells like a captcha.  Have you used `show: true` or `.url()` to verify you're getting redirected to the same place every time?  Can you provide a sample page where you see this issue?  Closing this as it seems resolved.  "Before the page is fully loaded" may be a bit misleading.  Before `dom-ready`? No.  Before client-side scripts have finished rendering the page? Possibly.  What are you trying to do?  Could you supply a repro or a minimum case for what you're trying to do?  You could use multiple Nightmare instances instead.  Using one instance for multiple concurrent operations  is not supported.  Two things: One, you might want to execute with `DEBUG=*`.  That will give you more helpful errors.  Two, the problem here is there _won't_ be a "full stack trace".  The function that does the evaluation is created, serialized, and reconstituted in the Electron instance, and as such, is sort-of-kind-of out of band.

That said, there was a conversation sort of on this topic a while back in #646.  Might be worth a read and +1. :)

Closing this issue for now as the issue seems resolved.  When I type "npm install nightmare", installation is stuck like this and never proceed:

```bash
rico345100ui-MacBook-Pro:jasmine rico345100$ npm install --save-dev nightmare
(node:21564) fs: re-evaluating native module sources is not supported. If you are using the graceful-fs module, please update it to a more recent version.

> electron@1.6.1 postinstall /Users/rico345100/Desktop/learn/jasmine/node_modules/electron
> node install.js
```

I almost wait 20 minutes, but nothing changed. I removed whole node_module and retried, but still same.

I'm using
- node v6.9.2
- npm v3.10.9 Nah, it just working now. Looks like some kind of network issue. Sorry, I just re-run the install, same issues happens again. When I forcely stop install and re-install, it saids:

> Electron failed to install correctly, please delete node_modules/electron and try installing again

So remove node_modules and npm install, same problem continues.

Oh, I forgot to mention it, I'm using MacOS 10.11.3 El Capitan.  thanks!  That's how it should work, and I cannot recreate the behavior you're seeing.  Can you provide a minimum repro?  #1024 is different, for what it's worth: that's talking about a child window.  Popups are, for now, not going to work (unless you create the windows yourself, like with `nightmare-window-manager`).  See #593.

Memory serving, partitioning has never worked particularly reliably, but I _thought_ that in your case @entrptaher that the `browser1` instance had to end to write the session to disk to then consequently get picked up by `browser2`?  Also, what, exactly, would be getting persisted?  The login cookie?  This would introduce an awful lot of lifting that the internal queue currently takes care of - two things that come to mind off the top of my head.  One, starting Electron is a queued action, meaning the instance does not start Electron until the first action is called as a part of the queue, and we get that for (more or less) free.  Wouldn't your approach mean all functions would have to check that?  Two, custom action creation is injected as a part of the queue after the Electron instance is started and the browser window sugar is propped up but before any of the user-queued actions are executed.  How would that work?  I've had similar issues with Chromium (and Chrome for that matter) bleeding memory.  Slack and Gmail have traditionally been my go-to examples of this - leave them open for any extended period of time, and eventually the browser process will gobble up all of the available memory.  I haven't had a real chance to dig into if it's a Chromium bug or a product bug, but I suspect Zapier may have a similar problem. >The same issue doesn't seem to happen in Chrome. 

Mmm, that's troubling.

>I should also note that the bleed is quite fast: the usage seems to grow ~100M every few seconds.

That's even more troubling.  When I've seen memory leaks, I'm talking on the order of megabytes an hour (if that), not an instant gobble.  My knee-jerk would be to say "try Electron's latest," but you've already tried that.

A quick gander through Electron's issues yielded electron/electron#8051 and electron/electron#7350 which seem close-ish?  Are either of those close to your case?

Also, is a minimum repro case possible?  I'm a glutton for punishment and would like to see this myself.

>Thanks for the quick response, by the way.

No problem.  Trying to get better about it, so far so good.

>I really appreciate all the work you've done on this project!

D'aw.  I can't take hardly any credit, but thank you anyway.

  Popups are not directly supported by Nightmare, and while I am certain the `preload` script doesn't get inherited with popup windows, I would not be surprised if other settings such as proxy are also not inherited.  This seems like an issue you should open with the `DefinitelyTyped` project, as we don't have any control over their typedefs. Closing as this is a `DefinitelyTyped` issue.  I haven't had a chance to dig into load testing Nightmare recently, and now you have me curious.  I'll see if I can carve out some time to tinker with this at some point soon.  I suspect you're _probably_ right, that this is a memory issue, but I haven't seen Nightmare start popping up windows unless they're generated from the site, and even then, I can't remember exactly the last time I saw that behavior.

I'd be curious if you set up something like [`nightmare-crash-reporter`](https://github.com/rosshinkley/nightmare-crash-reporter) if that might yield any useful information.  (I kind of doubt it, but hey, can't hurt to look.)

>  Some of the links that are traversed are apparently links for zip downloads. Is there any way to configure Nightmare to ignore these sorts of URLs?

If it would help, [`nightmare-download-manager`](https://github.com/rosshinkley/nightmare-download-manager) has an `ignoreDownloads` option that might help you skirt downloads specifically.  Is that what you're after?

  JPGs are not supported yet, pending #950.

If you want a PNG buffer, don't pass the path parameter.  Something like:

```js
nightmare
  .screenshot()
  .then((buffer) => {
    //buffer is a buffer of the PNG
  })
```

_edit:_ spelling error  I think the documentation is a little misleading here: the Nightmare `.pdf()` function does not take a callback as the second parameter.  In your initial example, Nightmare is treating the options object you're passing in as the path, and the function you're passing in as the internal `done` callback.  In the second, it's treating the options object correctly, but treating the function as the internal `done` callback.  This will almost certainly hang and not continue.

If you want the PDF as a buffer, try something like the following:

```js
.pdf({
  pageSize: 'A4',
  printBackground: true
})
.then((pdfBuffer) => {
  //use the pdf buffer
})
```  i had this same issue on an airplane, worked fine once i was on low-latency ground internet. definitely an electron issue though, not a nightmare issue.  Hm, can you provide more information?  Is the Nightmare script running on a box behind a firewall or anything else that would prevent network requests?  If not, could you provide a minimum repro script? Closing for the moment.  Feel free to reopen/open a new issue if this crops up again.  This is _very_ similar to #625.  Modified from that issue slightly, and probably _way_ oversimplified:

```js
var Nightmare = require('nightmare');
var vo = require('vo');
var nightmare = Nightmare({
  show: true
});

var run = function * () {
  yield nightmare.goto('http://example.tld');

  while(yield nightmare.exists("some-button-selector")) {
    yield nightmare.click("some-button-selector");
  }
  //... logic to do something with the posts ...
  yield nightmare.end();
};

vo(run)(function(err) {
  console.dir(err);
  console.log('done');
});
```

Note this carries the same stipulations:  This is _very_ naive, and if you're not careful, could end up causing a hang.  It looks like you're missing `libxss`?  It looks like Atom also [had this problem](https://github.com/atom/atom/issues/13176), do any of the solutions there work?  Based on the example you posted, you're trying to re-use the same Nightmare instance across multiple requests.  This won't work as if you have multiple requests come in, the actions for the later requests will be added to the currently executing context.  This is further complicated because you're also `.end()`ing the instance, rendering the Nightmare instance unusable after the initial request.

If you move the Nightmare instantiation into the Express `post` method, you will likely have better luck, but be careful: this method will not scale particularly well.

(I'll cross-post this answer on SO.)  Hm, I _think_ the `page` event - specifically with errors - is for on-page javascript errors (I can't remember offhand if it's parsing and uncaught exceptions or just uncaught exceptions).  I don't think it will capture sourcemap parsing issues or websocket connection issues.

For the `WebSocket`, I'm not sure you'll be able to capture the error short of writing a wrapper you can load up with preload, kind of akin to how `console` et al is handled.  Nothing jumps out at me in the Electron docs.  (Someone else out there happen to know?)  The sourcemap errors seem like they _should_ cause something to get called, but again, nothing jumps out at me.

Pondering out loud, have you given the Electron [`debugger`](http://electron.atom.io/docs/api/debugger/) a look?  You might be able to use `debugger.on('message')` to capture those problem events using a custom action.
 @keithkml If you come up with a custom action using the debugger, I'd be _very_ interested in seeing it.

Also, I neglected to mention - if you go this route, you will likely not be able to use the debugger tray (or you'll have to be _very_ judicious about opening and closing it) as Chromium only allows one attachment to the debugger at any given time.  I don't know that you'd hit that, but I thought I'd say it out loud to prevent you from head+desk.

Closing for the moment.  Nice catch, thanks!  Nice, thanks!  You could define a custom action for this.  Try something like...

```js
var Nightmare = require('nightmare');

Nightmare.action('show',
  function(name, options, parent, win, renderer, done) {
    parent.respondTo('show', function(done) {
      win.show();
      done();
    });
    done();
  },
  function(done) {
    this.child.call('show', done);
  });

Nightmare.action('hide',
  function(name, options, parent, win, renderer, done) {
    parent.respondTo('hide', function(done) {
      win.hide();
      done();
    });
    done();
  },
  function(done) {
    this.child.call('hide', done);
  });


var nightmare = Nightmare({
  show: false
});

nightmare.goto('http://example.org')
  .show()
  .wait(3000) //<-- here is where you'd want whatever your actions are, here i'm just using a wait
  .hide()
  .end()
  .then()  This sounds like an error from the javascript on the page - the page errors get bubbled up from Electron through the preload script. 

There is an edge case, though, where I suppose the error could get emitted without an error with a stacktrace.  I _thought_ there was a PR to account for this issue,but it's entirely possible my memory is faulty.  It looks like that may be what you're hitting.  To check that's what the problem is, you could override the preload with a custom event listener on `'error'`.  First things first: go read [Asynchronous Operations and Loops](https://github.com/rosshinkley/nightmare-examples/blob/master/docs/common-pitfalls/async-operations-loops.md).  Your original post is a similar use case.

As for why it freezes: I guess my first question would be, how many containers are there, and second, how are you ending the Nightmare instance?

Finally, your recursion approach _could_ work, and you're already pretty close.  From the hip, I think if you rearrange it a little, like this:

```js
let m = new Nightmare({
    width: 1600,
    height: 900,
    show: true,
    waitTimeout: 12000
});

function Iterate_Containers(count){
    return m
    .goto(`https://www.ttilgb.com/uiArp02Action/searchContainerInformationListByCntrNo.do?srchTpCd=C&cntrNo=${containers[count]}`)
    .wait(500)
    .screenshot(`./Desktop/${containers[count]}${count}.png`)
    .then(() => {
        if (count < containers.length) {
            return Iterate_Containers(count+1);
        }
        if (count === containers.length) {
            return;
        }
    });
}

m
.goto('http://www.ttilgb.com/main/index.do')
.wait(1000)
.wait(`#pUsrPwd`)
.insert("#pUsrId", hanjin_credentials.id)
.insert("#pUsrPwd", hanjin_credentials.pw)
.click(`img[onclick="clickLogIn()"]`)
.then(() => {
  return Iterate_Containers(0);  
})
.then(() => {
    return m.end(() => { console.log(green(`\nSuccessfully grabbed ${chalk.bgRed.white.bold(count)} containers release information from [${chalk.bgCyan.white.bold(`HANJIN`)}] terminal.`)) })
})
```
...you may have better luck.  What you have is fine. You could probably accomplish a close approximation using the [asynchronous form of `.wait()`](https://github.com/segmentio/nightmare#evaluatefn-arg1-arg2).  Waiting for a resource like you have it would be kind of tough without the action as you have it written, though.

Answering your second question: that usually happens when you attach an action to Nightmare multiple times.  That error was put there as a warning in case there were naming collisions for actions, which adding the same action multiple times would certainly cause.  Looks good to me.  Considering this issue closed.  If you have any more qusetions, feel free to reopen/open a new issue.  Wouldn't hurt to keep up on the Electron version, especially if the tests pass. I'd be open to this.  It looks like that site's SSL certificate is not valid.  You can direct Nightmare to ignore bad certs, although it's not recommended.  Try:

```js
var nightmare = Nightmare({
  switches: {
    'ignore-certificate-errors': true
  }
});
```

_edit:_ ctrl-enter is the worst.  Awesome work dude! Thanks!  More bizarre still, I don't think `.userAgent()` has been touched in some time (almost a year!).  I'd say it might be an Electron issue, but there's not a version difference between 2.9.0 and 2.9.1.

Anyone else with a Mac out there that can validate this issue?  Ahh thanks! Sorry to bother, but I'm getting this from the console:

"Not allowed to load local resource: chrome://version/?get-har"

The script runs successfully, but should I worry about this error? I only noticed now, but HAR is not correct.

I have the following entry: 

```
"response": {
				"_transferSize": 947,
				"bodySize": 290,
				"content": {
					"compression": 20,
					"mimeType": "text/html",
					"size": 310
				},
```

Where is the body? It says it's 310 bytes, but no body is present? So for anyone stumbling into this, I have decided to use browsermob to capture my har content:
https://github.com/lightbody/browsermob-proxy

It acts as a proxy, produce reliable HAR and I can still use Nightmare if you loke.  How are your Nightmare instances getting created?  It looks like the instance isn't ever created based on your source.  Also, what version are you using?  Are you getting errors for the instances that are hanging?

  @jekku Babel inserts a function to handle this for us:

```js
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
``` I do not see the benefit in this change. It seems like unnecessary cosmetic stuff, as functionally every example code block will work exactly the same.  TL;DR: don't use `.run()`.  It's a holdover from Nightmare 1.x.  Use `.then()` instead.

For a more protracted conversation with more information/links, see #575.  Also, this [example](https://github.com/rosshinkley/nightmare-examples/blob/master/docs/beginner/callbacks.md) in `nightmare-examples` may be of some use.

Merging with #575.  @ericadamski how are you running async/await?  Node 7 or Babel or...?  Related, yes, but not the same. I think it's closer to #859 - the TL;DR is you shouldn't use `.action()` for defining custom chains.  Use `.use()`.  Presumably, yes?  It depends on what your needs are, but you can certainly set up the viewport and useragent to mimic a mobile device.  Beyond that, Electron is more or less a full Chromium instance, so there may be some storage differences with what you see no the mobile (I can't think of one offhand, but it wouldn't surprise me).  I don't feel like that necessarily answers your question - what are you trying to test/do?  @navossoc the _unload_ bindings are preventing the page from fully loading?  o_O

That particular chunk was added so if you attempt to navigate away from a page, it prevents an unclickable modal dialog from cropping up, which would cause Nightmare to freeze.  (Same goes for `alert`, `confirm`, etc.)

Under Nightmare 2.9.1, I could not recreate the behavior you're seeing.  Out of curiosity, what are you returning from `.evaluate()`?  There are multiple questions here, I think.

> Can Nightmare do multiple requests in parallel?

No.  Think of a Nightmare instance as a single tab on a web browser - it wouldn't make much sense to ask a tab to go to multiple locations at once, for example.

>  Is it ok to make new nightmare instanse with nightmare = Nightmare(); on rest call?

Sure.

>  Do I need to end it somehow, or nightmare.end() will be ok?

Yes, you'll need to end the Nightmare instance.  I doubt you'll want to reuse Nightmare instances across requests.

The one thing you'll need to keep in mind for the last two of the above answers: load.  Nightmare is a _bit_ of a resource hog.  If you expect your load to be fairly low and the Nightmare script is fairly quick, a new instance per request is probably reasonable.  Otherwise, you'll need to put together some sort of resource management.

> Is there any way to have for example pull of 10 redy to render pages and use them while requests are coming?

Not exactly sure what you're asking here - are you asking if Nightmare could prerender pages for a request?  Can you expand on this a bit? > Is it a good practice to reuse nightmare ?

You can, but be mindful of ending the instance and sharing session/partition data.  The way you have it set up, though, you're not reusing the same instance but creating a new instance every time, which is also fine.

> Any problems like memory leaks?

Great question, and the answer is probably.  It largely depends on how careful the site you're hitting is about cleaning up resources in client-side javascript.

I'm going to go ahead and close this issue for now.  Feel free to open a new issue if you have more questions.  This is (kind of) by design - using `highlightRect` as opposed to touching the DOM directly solves a _lot_ more problems than it creates (see #927 and the issues referenced there).

I wonder if the `HIGHLIGHT_STYLE` could be determined at runtime to mimic the top left pixel, or if this is a case where the highlighted pixel isn't fully rendered at screenshot time?  Might be worth some experimentation.

/cc @Mr0grog, as he is way closer to this than I am, and might have more ideas.  @coyotte508 do you have a small example of your problem?  Depends on where you need to make the call from.  Are you trying to make the call from the Electron client (from the loaded page) or from your script?

From your script, you could use `.then()`:
```js
var someApi = require('SomeApiLibrary');
nightmare
  .goto(someUrl)
  .then(()=>{
    return new Promise((resolve, reject) => {
      api.someRestCall('parameter', (err, result) => {
        if(err) return reject(err);
        resolve(result);
      })
    })
  })
  .then((apiResult) => {
    ....
  });
```

Doing so from the client is marginally more complicated, but you could easily inject something that handles HTTP requests for you (like jQuery, for example).  I _think_ that Electron will display XML data rendered with the pretty XML rendering guts built into Chromium, which would explain the "rendered" view you're getting with `document`.

Try selecting out `webkit-xml-viewer-source-xml` - something like:

```js
nightmare
  .goto('https://somesite.com')
  .evaluate(() => document.querySelector('#webkit-xml-viewer-source-xml').innerHTML)
  .then((xml) => {
    fs.writeFileSync('my-data.xml', JSON.stringify(result));
  })
```  Your `clearCache` method takes a `message` parameter, but you're not passing anything to the call in your Nightmare chain.  What happens if you try changing `function(message, done)` to just `function(done)`? @contobob What you have there will almost certainly not work: `win.webContents.session` does not exist until you navigate away from `default:blank`.  (Why would you try to clear a session cache before it exists?)

If you're having problems with those plugins, i would encourage you to open issues there. @ysimonson It _does_ print B and C, just not to `stdout` of the node process.  Instead, those get printed (rightfully) to Electron's `stdout`.  Consider your above script, but instead of running with `node example.js` you run with `DEBUG=electron* node example.js`.  You'll see the following output:

```
  electron:stdout B +0ms
A
  electron:stdout C +358ms
```

... which is precisely what you would expect to see.  `B` when the action is created on the instance, followed by `A` when the action is called, followed by `C` when the action responds to the call. Bah, I realized I didn't answer the question of why it's not calling back: It looks like the clearCache callback isn't getting called.  I'll dig into that. In this particular case, it looks like `webContents.session.clearCache` never calls back, and it's not immediately clear why.  I'm inclined to say this is a bug with Electron: the source for [`clearCache`](https://github.com/electron/electron/blob/7f7df5a6dd083117bfa8175bf3ce1d52771eea6a/atom/renderer/api/atom_api_web_frame.cc#L236-L241) does not have a callback call, at least in my cursory look.  For contrast, compare that to [`clearStorage`](https://github.com/electron/electron/blob/bad130f623d1ed0de1a61bc3e82ae553fbf46364/atom/browser/api/atom_api_session.cc#L505) that does.

If you move the `done` call to the line after `clearCache`, does the cache actually clear?  This may be worth opening with Electron.  Thoughts?

 >Custom actions worked if I used it after a goto, but sometimes you need actions to do before going to any url.

I think I understand what the problem is now after seeing your example.  When `Nightmare.action()` (on the prototype) is called, there's an action put on the prototypal queue to execute action methods on all created instances.  Looking at your gist, it occurs to me there might be a bug when immediately calling a plugin method.  Poking around in the unit tests for Nightmare, I don't think this particular case is tested for and is probably worth adding to at least prove out that's not the problem.

> Exceptions on electron side should be catched and redirected to the client and throwed there again with a note that it happened on electron side. Currently it crashes without infos.

This is a somewhat complicated topic.  See #646.

> ...and the optional value should be at the end - I can imagine the reason was the order, whyever...

This is because `.action()` already existed, and I wanted to have as much backwards compatibility with previous versions as possible.

> The API documentation has following flaws:

You missed a few. ;)  Kidding aside, this has been on my backburner for a long time - it's why [`nightmare-examples`](https://github.com/rosshinkley/nightmare-examples) exists.  I'd _like_ for this to all be wrapped up on github pages, but I haven't made it that far yet.

>I saw that @types/nightmare is currently on version 1.6, older than 2 years.

PR DefinitelyTyped?

> If you create custom actions, almost same kind of error happens no matter the callback.

I don't think that's true as there are a _lot_ of plugin libraries that use this.  That said, I'm _almost positive_ you've hit a bug with either how caching works in Electron and/or with how actions are created on the instance after Electron is started.



  Depending on what your needs are, you _might_ want to have a look at [`onBeforeRequest`](https://github.com/electron/electron/blob/master/docs/api/web-request.md#webrequestonbeforerequestfilter-listener) instead.  You may also want to have a look at [`nightmare-load-filter`](https://github.com/rosshinkley/nightmare-load-filter) as it might get you closer to what you're after.

Are you planning on doing an action with the images downloaded, or are you just trying to log them? Considering this resolved for the moment.  If you have any more problems, feel free to reopen/open a new issue.  That is one way, another is using a CDN instead.  Going to go ahead and close for now.  There isn't a _real_ clean way to pass arguments to the preload, I made a passing attempt at doing something like this in #374 (if I'm reading what you want correctly).

I'm also not real clear on what you're trying to do: why are you using events for sending data from preload to your action?  Did something change on the source site?  Sounds fixed. :)  Closing.  Isn't this because the Nightmare instance is a `.then()`able itself?  If you're resolving nightmare after it's run a chain, it's trying to resolve the now-currently-empty action chain, which will resolve to `undefined`.

Try wrapping the instance in an object literal, like `res({nightmare:nightmare})`.  Would something like that work?
 @entrptaher Isn't that effectively the same thing as using (the admittedly not-well-documented) `.use()`?

Anyway, seems like this issue is resolved for the moment.  Closing.  given that the pdf printing happens under the covers in electron, it's likely an electron issue:
https://github.com/segmentio/nightmare/blob/master/lib/runner.js#L444  @jekku - @urlysses' answer would only work if the HREF attribute contained the text in question, not the text element under the anchor.  In other words, the answer - while useful - didn't address the question.

From here, @pfftdammitchris, I think you have two options off the top of my head.  One: you could use `.evaluate()` and try to issue clicks directly.  Something like:

```js
nightmare.goto('http://www.example.org')
  .evaluate(()=>{
    var elements = Array.from(document.querySelectorAll('a')).filter(a=>/information/.test(a.innerText))
    //you'll probably want to do some validation here
    elements[0].click();
  })
  .end()
  .then()
```

This clicks directly on the first element that matches text in the anchor's text, in this case, `information`.  This approach doesn't _always_ work, it depends on the JS framework you're using - in your case it looks like Angular, so your mileage may vary.

Option two: add a class to the anchor you want to click, then use the existing `.click()` machinery to issue your click.  This may work better in your situation, especially if you decide you'd rather use something like [`nightmare-real-mouse`](https://www.npmjs.com/package/nightmare-real-mouse) instead of the internal click events to Nightmare:

```js
nightmare.goto('http://www.example.org')
  .evaluate(()=>{
    var elements = Array.from(document.querySelectorAll('a')).filter(a=>/information/.test(a.innerText))
    //you'll probably want to do some validation here
    elements[0].className += " my-click-class";
  })
  .click('.my-click-class')
  .end()
  .then()
```  Thanks for the update.  @Dnyg `httpResponse` is not defined because the parameters passed to `.then()` will be from the last action executed in the chain (with the exception of `.end()`) - in your case, `.screenshot()` (which doesn't return anything).  If you need the HTTP response, you can break up your chain with another `.then()` to perform logic.  Something like:

```js
var Nightmare = require('nightmare');
var nightmare = Nightmare();
nightmare.goto("https://google.com")
.then(function(httpResponse) {
  if(httpResponse.code == 200) {
    return nightmare.screenshot('abc.png');
  } 
  else {
    //error condition?
    throw new Error('http response was not ok');
  }
})
.then(function(){ return nightmare.end(); })
.catch(function(){ return nightmare.end(); })
.then(function(){ 
  console.log('done');
})
```

@TheTechy your code suffers from the same issue - the additional problem here is you're trying to access `code` off of `httpResponse` which will cause an exception.  From your trace: ` ERROR: TypeError: Cannot read property 'code' of undefined` @TheTechy Ah, cool. :)  No problem, happy to help.  Do you mean setting the OS in `User-Agent`?  The can be set using [`.userAgent()`](https://github.com/segmentio/nightmare#useragentuseragent).  Note you'll need to set the entire user agent string.  @R0byn as @jekku mentioned, give #224 a read.

So starting from the top, explaining what you're seeing:

> Result: No errors, but also no console output. 

In the future, try running with `DEBUG=nightmare*,electron*` or `DEBUG=*`.  That will yield more verbose, useful output.

> Then tried the example in a shell on the Ubuntu Desktop - voila! Worked! :-)

This is because when you're under an Ubuntu desktop, you're running an X session of some flavor, meaning there's a framebuffer running.  Electron requires a framebuffer to be running to work properly.

> ... and is being pushed to a CI (Which is similarly, a shell ONLY env).

_Most_ (all?) of the CI solutions I've seen have a framebuffer of some flavor running (usually xvfb).

> Is there a way to get nightmare scripts running with this combination

Yes.  Install `Xvfb`, read through #224 and the suggestions there.  You can either have `Xvfb` always running or use `xvfb-run` to manage starting/stopping the service for you.  Your setup under that scenario should work fine.

I'm going to merge this into #224 and close this issue.

  @dfenstermaker in your original post, though, you said it was not clicking on `form button#go-button`.  Is that button the problem, or is `tos-accept-button` the issue?  If it's `form button#go-button`, what happens if you have `.wait('form button#go-button')` prior to the click?

_edit:_ missed a closing apostrophe  thanks!  `.screenshot()` does not take a function callback (at least, not anymore).  What version of Nightmare are you using, @tlshaheen? @jekku I don't think that does what you think it does, and now that you've pointed it out, I think I see the problem.  You _can_ pass a function like that, but it will do exactly what @tlshaheen said - it will prevent downstream execution of the Nightmare chain.  What that is looking for is the internal `done` callback as `.screenshot()` has optional parameters.

To make things clearer, an example might be helpful:

```js
nightmare.goto('http://www.example.org')
  .screenshot((err, buf) => {
    console.log('hello from screenshot callback');
    // do something with the buffer
    return "some value";
  })
  .end()
  .then((something) => console.log(something));
```

This will print `hello from screenshot callback`, but will never advance to the `.end()` because the `done` callback that tells Nightmare to move onto the next step - the one specified in the line you highlighted - is never called.

So while what i said is technically incorrect - `.screenshot()` _does_ take a callback, but it's supposed to be internal to make chaining work - I stand by my original statement.  I don't think `.screenshot()` takes a user-passable function callback as originally posted.

For completeness, if you wanted the buffer, the above example is easily fixed:

```js
nightmare.goto('http://www.example.org')
  .screenshot()
  .end()
  .then((buffer) => {
    // do something with the buffer...
  });
```

I'm still curious what version the original example was written against and/or where the example came from.  Hm, the only way I can think of off the top of my head to do this is with an [accelerator](https://github.com/electron/electron/blob/master/docs/api/accelerator.md).  Accelerators let you send keys like the arrow keys.  Out of the box, I don't think Nightmare supports accelerators, but I think you could write something with `.action()` and [`webview.sendInputEvent()`](https://github.com/electron/electron/blob/master/docs/api/web-contents.md#contentssendinputeventevent) to accomplish what you're after.  @yodfz not sure what you're expecting to happen here: if the `.js-alert` element does not exist, that function will never return, and eventually the wait timeout will be hit.  You probably want an `else` statement to call `done()`, if I had to guess.  thanks!  happy to consider if there's a test case and comments on an updated PR, thanks! yeah a unit test that shows it breaking in the old code, and fixed in the new code :) ðŸ‘   Again: this is a bug with `nightmare-download-manager`.  Moving the conversation [back](https://github.com/rosshinkley/nightmare-download-manager/issues/9).  One question: if you're using the remote debugging protocol, doesn't that mean you can't use the debugger (or have the development tray) open at the same time?  If I'm not mistaken, this is the same issue that [`nightmare-upload`](https://github.com/rosshinkley/nightmare-upload) has.

It's also entirely possible this got fixed in a more recent version of Electron.  I guess what I'm beating around the bush and saying that either this needs to be tested for and/or should be included in the readme.  Otherwise, I'm +1 on this as it solves more problems than it creates, imho.

Thoughts? > :astonished: I was entirely unaware of that as an issue and hadnâ€™t tested it.

No worries.  I just knew this was a stumbling block in the past, thought I'd bring it up.

> Iâ€™ve added another commit that detaches the debugger as soon as weâ€™re done, which seems to resolve that.

I re-read what you had done and tinkered for a bit, I'm going to go ahead and say LGTM and that this should get included.  Thanks!  You can certainly do a conditional injection.  From the hip, something like:

```js
var nightmare = Nightmare();
nightmare
  .evaluate(()=> typeof jQuery == 'undefined')
  .then(jqueryDoesNotExist => {
    if(jqueryDoesNotExist){
      return nightmare.inject('js', 'jquery.min.js');
    }
  })
  .then(() =>{
    nightmare.click(mySelector) ...
  })
```
... should be close.  Is that what you had in mind?  Is your scheduled task running as the same user?  Could he default window size be different for the user that runs the scheduled task, and that the page renders differently result in a different client size?

What are you trying to do that this is an issue? Sounds like this issue is at least tentatively resolved, going to close it for now.  If this crops up again, feel free to reopen.  This is a bug with `nightmare-download-manager` most likely.  I see you've already opened an [issue there](https://github.com/rosshinkley/nightmare-download-manager/issues/9), so let's move this conversation there.  Hm, do you get any output from Electron if you run with `DEBUG=nightmare*,electron*`?

You _should_ be able to run multiple instances, but be wary of load - Nightmare is not cheap with respect to memory.  Memory serving, an instance costs ~30mb without doing anything particularly useful.

That said, I wonder if your script has a possible bug with how it handles session.  Are there any logins or cached credentials in your script?  You _might_ want to try setting up a different partition per request:

```js
nightmare = Nightmare({
  webPreferences: {
    partition: "my-partition-"+Math.random()
  }
});
```  @ewrogers is correct: `session` is not created until after you navigate somewhere.

It might be worth having the discussion: should Nightmare navigate to `about:blank` first?  I can't think of any side effects off the top of my head, but it might be worth sandboxing to see.

Thoughts?  I think this is very, very close to #521.  Is that what you're after? Formatting appears to be a bit weird, but it looks like you're using the error-first callback for `onBeforeSendHeaders` with an error every time.   Try passing `null` as the first parameter.

It also looks like, at least at first blush, the action callback is never called, and the Nightmare-callable function is not defined.  Is there a more complete example you can supply?  More as a reminder to self when I pull this in: A note will need to be added to the release notes as a _possibly_ breaking change.  It's possible some folks out there are depending on this side effect, and it's probably worth mentioning.

Otherwise, looks great.  Thanks!
  Are you running the ecommerce site under Electron?  If not, then no, this is probably not the solution you're really after.

There are tools out there for giving site demonstrations and guidance.  I have used [Hopscotch](http://linkedin.github.io/hopscotch/) with moderate success.  (Others may have suggestions too, and if you do, please feel free to leave them!)  Is that closer to what you have in mind?  DOM elements and DOM element lists are not serializable.  See [#567 (comment)](https://github.com/segmentio/nightmare/issues/567#issuecomment-209533871).  +1 on a PR for this.  You can override the [base timeout](https://github.com/segmentio/nightmare#waittimeout-default-30s) for wait right now.  Are you trying to add a timeout per call?

`done` is always the last argument to an action - the top of the funciton has `var done = args[args.length-1];` - is that what you're asking about?

_edit:_ had a bracket the wrong way.  Price I pay for not previewing before commenting :|  This has to do with the max texture tile size that Chromium can render - the texture tile size is limited (in general) by the hardware you're running.  It's _almost_ always 8k or 16k, and defaults to 16k.  [You can see it here for yourself.](https://cs.chromium.org/chromium/src/cc/resources/resource_provider.cc?rcl=1464366759&l=448-454)

You can also verify that if you're interested with [this gist](https://gist.github.com/rosshinkley/b5fb5061073756e926b791a66d62b24b) I threw together when I hit this same problem a while back.  I considered putting together a plugin for large format screenshots that are bigger than the texture size - something that would take small tiles and stitch them together manually, but I never got around to it.  Sounds like it might be worth doing. @jimmaay To be honest, it never got past a doodle in my notebook.  (Ab)Using the viewport size and moving it around was going to be a first pass, but you're right - a fixed (or anchored) element would definitely throw a wrench in that.  There are other rendering problems that could crop up with any sort of responsive layout, too, which is ultimately why I tabled the idea.  Still, as a science experiment to float out, it might be worth doing to see if anyone has ideas or another approach.  Also - spitballing - I know you can hook into the frame rendering buffer directly (that's how the current incarnation of screenshots work) - I wonder if there's some raw frame buffer magic that could be pulled off? > ...definitely many scenarios that this still doesn't cover.

Hey, if it works for your needs... :)  Beyond a doubt there are probably many we're not thinking of off the cuff.

> Is there a way to get a recompiled chromium with max_texture_size_ set to something larger to work on a virtual frame buffer like xvfb?

Oooh, good question - you'd have to patch the tilesize and get a working build of Chromium _and_ a working build of Electron off of your custom Chromium build, then patch a fork of Nightmare to use that custom Electron build.  Most likely, doing that would introduce other side effects (or break rendering altogether), but if you've got the time to burn and want to give it a shot, I'd love to see it.

> I wonder how phantomJS is able to take screenshots larger then 16384,

Another _great_ question, and full disclosure, I'm not sure.  This might be worth digging into. I'm going to close this issue for now as "not fixable" (at least without substantial effort).  A plugin is _probably_ the way to go here.  If memory serves, I think there are circumstances where `dom-ready` never fires, but `did-finish-load` does.  I remember having a conversation about this at one point but cannot find the issue offhand, so take that with a grain of salt. :)

For what it's worth, if you're not interested in loading assets, you could also use a load filter like [`nightmare-load-filter`](https://github.com/rosshinkley/nightmare-load-filter).  Looks like public access isn't granted for that asset... can you fix it?

How are you trying to open the file?  Can you provide an example?  hey sorry! will do a fresh release tomorrow. thanks for the PR!  Fixes #899. @jekku  This probably should have gotten pulled in with the last release.  I'll see to it that it gets pulled in with the next one.

@justinmchase _mostly_ for previous version support/preventing breaking changes.  In the future, support could be dropped.  (This is _tangentially_ related to a conversation about `.run()` in #575.)

  The `.end(fn)` method calls run, which kicks off the queue.  The subsequent `.then()` is also trying to kick off the queue, but because it was cleared by the prior call to `.end(fn)`, Nightmare will immediately halt execution, causing the instance to effectively be hung.

Curiously, there's no unit tests around handling `.end()` with a callback.

I'll be fixing both problems (at least as a first pass) shortly.
  Good eye.  Thanks!  It depends on how the "reload" is happening.  For all actions, the instance should wait for [`did-stop-loading`](https://github.com/segmentio/nightmare/blob/master/lib/runner.js#L153).  I suspect your redirected-to page is finished loading, but perhaps is doing some continuing work asynchronously?  Or, it could be that the redirect is not instant - you _might_ want to add a short wait between form submission and the next task.  Alternatively, you could wait for an element to appear on the page you're redirected to.
  Depends on what you mean - do you want to load the HTML as a page?  If so, you can save the HTML as a file and have Nightmare `.goto()` that file, eg:

``` js
nightmare
  .goto('file:///some/location/locally/mypage.html')
  .then( ... )
```
  It looks like you've done all of the heavy lifting already to get the data you want out - you don't need Nightmare to save the file for you, you could do it with the Node native [`fs`](https://nodejs.org/api/fs.html#fs_fs_writefile_file_data_options_callback) module.  Something like this for a synchronous call:

``` js
.then(function(data){
  fs.writeFileSync('my-data.json', JSON.stringify(data));
})
```

Or the equivalent asynchronous call:

``` js
.then(function(data){
  return new Promise(function(resolve, reject) {
    fs.writeFile('my-data.json', JSON.stringify(data), function(err){
      if(err) return reject(err);
      resolve();
    });
  });
})
```
  That looks like the Electron process is never starting.  Could you paste the version of the Yahoo example you are using?
  I'd be curious to see how you were trying to accomplish this with a preload.  Also, silly question - did you try setting `webSecurity` to false?
  Is [`.action()`](https://github.com/segmentio/nightmare#nightmareactionname-electronactionelectronnamespace-actionnamespace) what you're after?  That gives you the ability to define custom actions on the Electron instance.
 @zatziky upload dialogs are _very_ tricky, requiring tapping into the debugger API.  There is a plugin for that: [`nightmare-upload`](https://github.com/rosshinkley/nightmare-upload).  Sending keyboard events to Electron for upload dialogs won't work.

@josephrocca Glad you got it figured out, and thank you for documenting your process! Highly appreciated. :)

Considering both of the above issues are covered, I'm going to go ahead and close this issue.  File uploads are not natively supported under Nightmare (or Electron for that matter).  You _can_ do uploads by using the debugger API, which is what [`nightmare-upload`](https://github.com/rosshinkley/nightmare-upload) does.  Does that plugin work for you?
  Nightmare depends on native Promises as well as fat-arrow functions.  Running under 0.12 isn't possible out of the box.  You _might_ be able to use Babel (possibly in tandem with something else) to roll up Nightmare as a dependency, but I personally have not tried it.
 Closing for now.  Let me know if you get that put together, I'd be highly interested to see it!  If what you mean is

> "Can I exclude Electron and have Nightmare still work?"

The answer is no.  Nightmare is a wrapper for Electron, and will not work without it.
  Yes, with `.evaluate()` you can return data up to the calling client.  For example:

``` js
nightmare
  .goto(someUrl)
  .evaluate(() => { return "hello world"; })
  //prints "hello world"
  .then((str) => console.log(str));
```

Is that what you are after?

For completeness, the title of your question talks about events, and if you're wanting to capture events you can use `.on()`.  Any event emitted from Electron can be captured with that.  If you want to define your own events, you might want to check out [`nightmare-custom-event`](https://github.com/rosshinkley/nightmare-custom-event).
 Yeah, that's the intent of `nightmare-custom-event` - did you take a look at that?  I think that might be close to what you're after.  I don't think the Nightmare runner re-emits all events from the Electron context, so I don't think your preload example would work out of the box.  You'd have to patch together an `.action()` to do that, I think.  Can you supply an example of what you're trying to do?
  I suspect this is the same issue as #224.  Merging.  It would seem that downloads are now causing a dialog box to appear (that I don't think was happening before?).  This is preventing Nightmare from moving forward until the dialog box is dealt with.

As a stopgap, you could use [`nightmare-download-manager`](https://github.com/rosshinkley/nightmare-download-manager) or [`nightmare-inline-download`](https://github.com/rosshinkley/nightmare-inline-download) for the moment.  That will handle setting the save path, which prevents the dialog.

As for the timer not firing, that's strange.  It should, but it's possible there's a bug there.  It's also possible (albeit unlikely) that the modal dialog is preventing the timer function from firing.
 @anperez78 Did you take a look at `nightmare-download-manager` or `nightmare-inline-download`?  The short answer is no, not out of the box.  New `BrowserWindow` instances are created under Electron and are not created with all of the Nightmare sugar for interaction.  (It's planned for a future release, see #593.)

In the meantime, you can use [`nightmare-window-manager`](https://github.com/rosshinkley/nightmare-window-manager) to get some _very_ basic functionality.
  I gave this a try with the following script:

``` js
var nightmare = require('nightmare')();

var evaluateFn = () => {
  var localCollection = localCollection = [1,true,"hello",4.5,{some:"thing"}];
  return localCollection;
};
var resultFn = (someCollection) => {
  console.dir(someCollection);
};

nightmare
  .goto('http://example.org')
  .evaluate(evaluateFn)
  .then(resultFn)
  .then(() => nightmare.end().then());
```

... and ran it with `for i in`seq 1 100`; do node script.js; done` to simulate running it 100 times.  I couldn't reproduce this behavior.

Does your function _always_ return `localCollection`?  Is that array actually an array, or can it possibly be something like a DOM list?
  This would _probably_ be best served as a plugin as you've already mentioned.  I'm adding this to the list of v3 nice-to-haves and merging this issue with that.  You cannot return DOM elements or lists of DOM elements.  Any information returned from `.evaluate()` has to be serialized and passed over IPC.

Try extracting information out of the DOM element(s) before passing the information back.
  good idea, thanks :) Yeah I fixed whole merging ;)

On Mon, Jan 2, 2017 at 2:25 AM Rico Sta. Cruz <notifications@github.com>
wrote:

> *@rstacruz* commented on this pull request.
>
>
>
>
> ------------------------------
>
>
>
>
> In Readme.md
> <https://github.com/segmentio/nightmare/pull/865#pullrequestreview-14833628>
> :
>
>
> > @@ -30,16 +30,13 @@ Many thanks to [@matthewmueller](https://github.com/matthewmueller) and [@rosshi
>
>  Let's search on Yahoo:
>
>
>
> oops, haha, this needs to change too
>
>
>
>
> ------------------------------
>
>
>
>
> In Readme.md
> <https://github.com/segmentio/nightmare/pull/865#pullrequestreview-14833628>
> :
>
>
> > @@ -30,16 +30,13 @@ Many thanks to [@matthewmueller](https://github.com/matthewmueller) and [@rosshi
>
>  Let's search on Yahoo:
>
>
>
> but i think someone already edited that
>
>
>
>
> â€”
> You are receiving this because you modified the open/close state.
> Reply to this email directly, view it on GitHub
> <https://github.com/segmentio/nightmare/pull/865#pullrequestreview-14833628>,
> or mute the thread
> <https://github.com/notifications/unsubscribe-auth/AAoMcSpFOqLKtAFCKH5favWMdstoVwpqks5rONC1gaJpZM4Kmveu>
> .
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
  I don't know that this is possible (someone correct me if I'm wrong).  This is tantamount to asking for a promise to come through a promise resolution unresolved itself, which (memory serving) breaks Promise standards.

That said, I'd be open a PR either here or on [`nightmare-examples`](https://github.com/rosshinkley/nightmare-examples) noting it.  Thoughts?  @Mr0grog Would it be worth it to use something like [`json-stringify-safe`](https://www.npmjs.com/package/json-stringify-safe) to handle circular references when serializing data to pass over the IPC boundary?
  Closing for a viable solution, but thank you for bringing it up!  > In sketch, I do the following:

Your `.use()` function calls `.then()`.  That's almost certainly going to lead to unintended side effects with queue management, so I'm not terribly surprised you're seeing strange behavior.

> For example: where is documentation for "use"?

The awful truth about `.use()` is that it's _never_ been particularly well documented.  The idea was to wrap up commonly used Nightmare chains for easy use, but it never really got the attention it deserved.

> Where is documentation for "run"?

`.run()` is in the throws of being deprecated.  See #575.

> What criteria nightmare uses for choosing when it is going to queue or when it is going to run the queued operations?

All operations (except for `.run()` and I think one overload of `.end()`) are queued. Operations are only executed when `.then()` is called, `.end()` is called with a callback, or `.run()` is called.  The TL;DR advice there is to _always_ use `.then()`.  (If you're using generators, this is done automatically for you with `vo` or `co`.)

> ... and the only documentation comes in the form of very restrict examples, where there is no precise definition of function actions and the meaning of the parameters.

This is a very valid criticism.  One of the things on my back burner has been to make a gh-pages branch and take a serious pass at updating/upgrading the documentation.  Nightmare's API surface is getting to be too big for a simple readme.

>  create a custom action that is minimaly general enough to get an dom property on the client, return it, and then storing it in an array server-side. Is that possible?

Yes, although I don't know that you need a "custom action" (or even a `.use()` function) to do so.  Using `.use()`, you could do the following to get all client widths for a given query, for example:

```js
var Nightmare = require('nightmare');

var nightmare = Nightmare();

var functionToUse = function(search){
  return function(nightmare){
    nightmare.evaluate((search) => {
      return Array.from(document.querySelectorAll(search)).map(element => element.clientWidth);
    }, search);
  };
};

var clientWidths = [];

nightmare
  .goto('http://example.org')
  .use(functionToUse('body'))
  .then(function(ws){
    ws.forEach(w => clientWidths.push(w));
  })
  .then(function(){
    return nightmare.use(functionToUse('p'));
  })
  .then(function(ws){
    ws.forEach(w => clientWidths.push(w));
  })
  .then(function(){
    console.log(clientWidths);
  });
```  Documentation has been merged, I'm going to consider this issue closed.  The first `.then()` turns your Nightmare chain into a `Promise`.  With that, you can return another Nightmare chain (which resolves to a Promise) and continue evaluation.  Using your example, something like:

``` js
var nightmare = new Nightmare();
nightmare
  .goto(site)
  .evaluate(function(){
    //run evaluation
  })
  .then(function(result){
    return nightmare.click()
      .evalute(function(){
        //run evaluation
      })
  })
  .then(function(result){
    //confirm result
  })
```
  Looping over Nightmare chains as you have it won't behave as you'd expect, and can cause unexpected problems.  I suggest you read [Asynchronous Operations and Loops](https://github.com/rosshinkley/nightmare-examples/blob/master/docs/common-pitfalls/async-operations-loops.md).  That might not solve all of the problem, but it will eliminate any strange behavior from looping on the same Nightmare instance.
  This is because Nightmare uses the same callback style that Node uses where the first parameter is an (optional) error.  Consider:

``` js
var Nightmare = require('nightmare');
Nightmare()
    .goto('http://google.com')
    .evaluate(function (message, done) {
        done(message);
    }, 'working')
    .end()
    .then(value => {
        console.log(value);
    })
    .catch(err => {
        console.log('ERROR: ' + err);
    });
```

This will produce the output of "ERROR: working".
 I should have been clearer with my example.  You certainly can also pass back an optional value.  Consider:

```js
var Nightmare = require('nightmare');
Nightmare()
    .goto('http://google.com')
    .evaluate(function (message, done) {
        done(null, message);
    }, 'working')
    .end()
    .then(value => {
        console.log(value);
    })
    .catch(err => {
        console.log('ERROR: ' + err);
    });
```
...will log "working".  I think what you'd _probably_ want go the route of gathering the `href`s - the page you're gathering from will probably change, so you're not guaranteed that using `.click()` and `.back()` will be reliable.  Your loop is almost there: you should be able to get the `href`s directly from the anchor DOM elements.  You could also do something like:

``` js
var storyHrefs = Array.from(document.querySelectorAll("a.storylink")).map(a=>a.href);
```

The next issue you'll likely hit is looping over an array and the problems that causes with asynchronous operations.  I'd suggest reading [Asynchronous Loops and Operations](https://github.com/rosshinkley/nightmare-examples/blob/master/docs/common-pitfalls/async-operations-loops.md).  That should at least help you get started.
  There could be, I suppose, but why would you want to `.inject()` something into a page you were going to navigate _away_ from?
  @privilio  is right: start with #224.  Closing this for now, feel free to reopen if you are still having an issue.  A change was made to allow for asynchronous execution when using `.evaluate()`, which `.click()` uses under the covers.  This change parses the arguments to `.evaluate()`, which parses them, and I think that's causing the issue.
 I'm in the throws of fixing this issue now.  Yes, it has to do with how arguments to `evaluate_now` are parsed.  I'll hopefully have something shortly, possibly including a fix for the arbitrary code injection.  (Which, by the by, shouldn't really matter: that's what almost all of the Nightmare commands do.)
  Answering your question, anything >=4.x will work.

I suspect, though, you're hitting the same thing as #839, fixed in #841.
  First and foremost: you don't have to call `.end()` before `.then()`.  Use `.end()` when you want to shut the Electron instance down.  Use `.then()` when you want to perform the actions that have been queued.

Setting that aside, getting results from an asynchronously loaded page seems to come up fairly frequently.  I'd suggest first giving ["Asynchronous Operations and Loops" in `nightmare-examples`](https://github.com/rosshinkley/nightmare-examples/blob/master/docs/common-pitfalls/async-operations-loops.md) a read if you haven't already.  That should get you started on looping.  I'd also recommend reading #625.  It's a different issue (scraping an infinite scroll), but the bones of the issue are similar:  conduct an action, perform some sort of check, iterate if necessary.

Finally, if you have specific source you'd like a hand with, feel free to include a simplified version.  I'd be happy to help you get started.
  Heroku + Nightmare can get a little sketchy having to do with `/dev/shm` being too small, and as far as I know (I remember talking about this on Gitter, but can't dig out the conversation) it can't be adjusted.  This was first mentioned [here in #497](https://github.com/segmentio/nightmare/issues/497#issuecomment-187517613).  I wonder if you're hitting that limit?
 I [found the original conversation](https://gitter.im/rosshinkley/nightmare?at=574b580aa78d5a256e38f3cd), and I _thought_ there was an outline on logs/testing for verifying that was the problem, but it's not jumping out at me.

The dyno sizes don't affect the size of shared memory - that setting is locked by Heroku.  Furthermore, memory serving, you don't have root access to change the shared memory partition.  

Re confirming the issue, you might be able to get away with using something like [`df`](http://man7.org/linux/man-pages/man1/df.1.html) to look at `/dev/shm` usage while your script is running.  (Something like `watch "df | grep /dev/shm"` or `watch "df -h | grep /dev/shm"`, maybe?)  I _think_ that's doable with `heroku run bash` on a one-off dyno, but my experience with Heroku is limited.

/cc @rickmed - any light to shed on this topic?
  I'm not entirely sure I understand the question.  Nightmare can be ended with [`.end()`](https://github.com/segmentio/nightmare#end), and in the future interrupted with `.halt()` (see #788).

The "button" part of your question confuses me: what are you trying to do?
 Yes.  I think in that case you'd want the `.halt()` API, which is as-yet not included.
  I can't think of a reason to not include it off the top of my head, and the change is pretty innocuous.  If you're willing to pull together the PR + tests, I'd say go for it. :)
 Ah, I think I misunderstood the problem you're trying to solve.  You're after something blocking, I take it?  That's trickier, but there are a couple of options.  You could manually block using `.wait()`, which would solve your asynchronicity problem.  Or if you really want to get crazy, you could take a look at implementing a soft-blocking action to wait for your page errors, akin to how [`nightmare-inline-download`](https://github.com/rosshinkley/nightmare-inline-download/) works.
  To be clear: are you trying to pass an actual function to evaluate?  Something like:

``` js
var myfn = function() { ... };
nightmare
  .goto(myUrl)
  .evaluate(fn=>{ fn(); }, myfn)
  .then( ... )
```

_edit:_ I didn't keep my naming conventions straight.  Oops.
 @cagataycali In addition, you're not passing values to `.evaluate()` to print.  From the hip, this should work:
```js
var name = "demo.png";
var url = "https://demoUrl.com"

nightmare
  .downloadManager()
  .goto('https://google.com')
  .evaluate((name, url) => {
    console.log(name, url);
    return 'Done'
  }, "name", "url")
```

You may want to give [variable lifting](https://github.com/rosshinkley/nightmare-examples/blob/master/docs/common-pitfalls/variable-lifting.md) a read.

Going to close this due to age and I think possibly being solved.  I don't _think_ you would need #819 to handle this, but I'm not sure I'm clear on what you're asking.  Do you want the URL of the page that excepted, or are you looking to pull information from the page that excepted?

Taking a stab in the dark, would something like this help?

``` js
nightmare
    .goto('www.dfsdfsdfsdfsdfsgdg.com')
    .click('#buttonThatLoadsSomething') /* page loads something */
    .wait('#not_here') /* this will timeout because it's not on the page*/
    .evaluate(function () {
        /* more code here */
    })
    .end()
    .then(function(html) {
        /* more code here */
    })
    .catch(function (error) {
        /* here I would like to know what the last html page was before the error occurred */
        return nightmare
          .url()
          .then(function(url) {
            console.log(`error happened at ${url}`);
          })
    });
```
 You can still use the same approach, and you've got options, depending on what you want to do: use `.evaluate()` to return the HTML back, or use `.html()` to save the error state off.

Using `.evaluate()`:

``` js
nightmare
    .goto('www.dfsdfsdfsdfsdfsgdg.com')
    .click('#buttonThatLoadsSomething') /* page loads something */
    .wait('#not_here') /* this will timeout because it's not on the page*/
    .evaluate(function () {
        /* more code here */
    })
    .end()
    .then(function(html) {
        /* more code here */
    })
    .catch(function (error) {
        /* here I would like to know what the last html page was before the error occurred */
        return nightmare
          .evaluate(() => document.querySelector('body').innerHTML)
          .then(function(html) {
            // do something with the html retrieved
          })
    });
```

Using `.html()`:

``` js
nightmare
    .goto('www.dfsdfsdfsdfsdfsgdg.com')
    .click('#buttonThatLoadsSomething') /* page loads something */
    .wait('#not_here') /* this will timeout because it's not on the page*/
    .evaluate(function () {
        /* more code here */
    })
    .end()
    .then(function(html) {
        /* more code here */
    })
    .catch(function (error) {
        /* here I would like to know what the last html page was before the error occurred */
        return nightmare
          .html('/path/to/file.html', 'HTMLOnly')
          .then(function() {
            // html is saved off to the path
          })
    });
```
 Poking a head in: Thank you @Mr0grog:

> except you need to make sure not to call end() before your catch runs...

Editing mistake on my part.  Thanks for the second set of eyes.
  I'm not sure what you're asking here - are you asking how to set up a proxy?  Or what proxy to use?  

For the latter, [`node-http-proxy`](https://github.com/nodejitsu/node-http-proxy) is a good place to start.
 Hm, You could probably use a similar approach to #521 to patch request data coming back - does that help, or are you trying to modify data from `.goto()`?  Short answer is yes, it's definitely on the list of things to try, and I'd point you at #593 for more information.

Longer answer: it's very possible to manage multiple `BrowserWindow`s from a single Electron instance, and should be reasonably straightforward to do with Nightmare.  It would solve situations where you're time-bound (like yours, as you noted, launching new Chromium instances takes quite a bit of time) or memory-bound (each Chromium instance is _very_ expensive).  It would also solve problems with managing popup windows and testing with multiple windows.

The downside is that (I think) it would be a breaking change to Nightmare 2.x, which I'm not against, but it would have to be handled ... carefully.
 Merging this conversation into #593.  No, I don't think so.  Memory serving, `webContents` hasn't been created yet, so there's nothing to call `executeJavascript()` on.

What are you trying to do?  There might be another angle.
  This looks like the same issue that alert, confirm, etc poses.  I'll fix the test conflict and pull it in.  For what it's worth, you could instead prop up a custom preload to handle the `confirm` case manually.  By default, the confirm handler returns the default response, which in this case is _probably_ to stay on the page.
 Fixed with #825.  Closing.  This PR is intended to let you run `.evaluate()`d functions that are asynchronous, either with callbacks or with promises.  For callbacks, if the `.evaluate()`d function's arity is one less than the passed in parameters, it'll assume the last argument to the function is the callback.  If the return value is a `then`able, it'll call `then()` to wait for promise fulfillment.  Otherwise, the call will behave synchronously as it does now.

This change is _potentially_ breaking as it does change behavior based on the arguments to `.evaluate()`.  Is this change worth the risk of possibly breaking implementations that already exist?

Related to #573 and closes #552.
 Including.  Thanks for the feedback. :)
  Thanks for the correction!
  I'm guessing based on the output that you're on MacOS, and to that end, there's a known issue with some versions of OSX that limit the maximum file handles to something like 256.  I think that might be what you're hitting?  Try running `ulimit -n` and report back what your limit is.
  Last I saw, the tests for `.visible()` were broken.  I haven't had a chance to really dig into it since.

At first blush, this looks like a reasonable change, and also looks like it adds a check for elements that are floated off into oblivion, which is a welcome addition.  I'll take a closer look when I have a chance, but on the face of it, this looks good.
 On slightly closer inspection: what about elements that are bigger than the viewport?  Doesn't this assume that to be visible, the bottom (and rightmost edge) of the element has to be in view?  I don't think a call to `.visible()` implies the _entire_ element is visible.  In fact, all `.visible()` really implies is that the element is on the page and rendered.  Changing that would be a _substantial_ change and probably a breaking one at that.
 > The definition of visible (at least mine) is that the user can interact with the element in the current viewport. This implies that if the element is bigger than the viewport but some parts of it are present in the viewport it should be visible.

I don't think what you have will work like that.  Specifically:

``` js
 rect.bottom <= (window.innerHeight || document.documentElement.clientHeight) &&
 rect.right <= (window.innerWidth || document.documentElement.clientWidth)
```

... will dictate that the bottom and rightmost edge _must_ be in the viewport to be considered visible, and (correct me if I'm wrong) I don't think that's your intent.

>  Thinking twice about it maybe we should check the left top edge instead. Should I update the PR accordingly?

I don't think relying on an edge (or more than one edge) being in the viewport is a good indicator of visibility, as the element you are checking may extend beyond the viewport in any, a combination, or every direction.  For this to work right, I think you'll want to make sure that a part of the viewport overlaps the client rectangle, edge-inclusive.

>  Isn't this the purpose of .exists()?

In short, no.  `.exists()` ensures the element is a part of the DOM, visible or not.  `.visible()` makes sure the element is actually rendered.  I don't think whether or not the element is in the viewport matters, and I would not be surprised if this quirk (for want of a better word) of implementation is relied upon by users of Nightmare.

Pondering out loud: this _might_ be better served as a plugin.
  It looks like you're trying to call `.action()` on a Nightmare instance instead of the Nightmare prototype.  Is that the case?

Setting that aside, I suspect your custom action does not work the first time, either: the callback `cb` gets called with an error.  (It doesn't serialize nicely from the client code because `Error` isn't easily serializable, but that's left to  #646.)  Poking around in your client function, it turns out that the event being emitted is invalid - while the event name seems to be case-insensitive (documentation has them as `mouseDown` and `mouseUp`), the coordinates _must_ be integers.  If the bouds add to an even number, you'll end up with a float, which Electron will reject.  Try using `Math.floor` to ensure your coordinates are round integers.

_edit:_ poor wording.
  In addition to sending backspace characters as @marcelfalliere said, you can send empty or falsey values to `.type()` and `.insert()` to clear the selector.

I do have a question:

> ...on script re-run are previously inserted input fields prefilled with old values.

Meaning that the values are there between runs to the same site?
  @daniel3d is right: `.end()` queues the ending action, it still needs to be executed with a `.then()`.

Setting that aside, and this is kind of offtopic: I'm not certain Nightmare is the best tool for converting SVGs to PNGs.  Have you considered using something like [ImageMagick](http://imagemagick.org/script/index.php)?  `convert` will give you _much_ more flexibility for image manipulation.
 Considering this fixed with #927.  Closing.  Ah, this must have gotten overlooked.  Thanks!
  Hm, are any of the variables you're testing for defined on the global/window scope _before_ your injection?  I can recreate this behavior if the variables are defined prior to `.inject()`, as then they would already exist on the global scope.

It's worth pointing out that your consideration is not exactly the same thing as the test you've written.  In your test, the `init()` function is injected after the page is loaded, whereas in your consideration example, they are loaded together.  It's a small difference, and I don't _think_ it would be causing this, but it's worth thinking about.
  That depends on what you mean.  If you've got assets - large images, for example - you could tap into `session.webRequest.onBeforeRequest()` to filter content that could slow your load process down.  There's a [plugin that you might find useful](https://github.com/rosshinkley/nightmare-load-filter) that does this.

As for speeding up the actual rendering process, that's internal to Chromium - I don't know of options offhand, but the [`BrowserWindow`](https://github.com/electron/electron/blob/master/docs/api/browser-window.md) documentation and perhaps the [Chromium switch list](http://peter.sh/experiments/chromium-command-line-switches/) (for use with [`switches`](https://github.com/segmentio/nightmare#switches)) might offer some options for you to tinker with.
  Out of the box? no.  Dealing with multiple instances of `BrowserWindow` isn't currently supported in Nightmare.  (Memory serving, it's one of the features talked about for a future version in #593.)

You can _kind_ of skirt this issue now, but it depends largely on what you need.  I'd suggest checking out [`nightmare-window-manager`](https://github.com/rosshinkley/nightmare-window-manager).  It's limited, but might be enough to help you skate by.
 Moving this to nightmare-window-manager.  At some moment, we should _probably_ prop up linting as a part of the build process (see long-standing #364), but I won't hold up this PR for that.  Including.  Thanks!
  Fixed with merged PR, closing.
  I'm not entirely sure what you're asking: do you want to show the alert window?  If so, that would require [overriding the preload script](https://github.com/segmentio/nightmare#custom-preload-script).  Note, though, that `alert`, `confirm`, and `prompt` will cause Nightmare to hang if you actually show the dialog boxes.
 Closing for lack of activity.  If this is still an issue, feel free to reopen/open a new issue.
  All for removing unnecessary dependencies.  Thanks!
  Are you (or anyone else) still having this issue?  Sometimes `.click()` does not do what you might expect.  It may be worth giving #619 a read.

Setting that aside, when and where dose `window.showModalDialog` get added?
 > It's added in that evaluate function I pasted above.

Possible I'm just blind, but `window.showModalDialog` is not added in the code you've posted.  It gets called but not added, which is why I was wondering where it got added.
 Closing for inactivity.  If you're still having this problem, feel free to reopen.  OS: Windows 10
node: 5.10.1
nightmare: 2.7.0
electron: electron-v1.3.6-win32-x64

Navigate to wells fargo and try to do anything.

``` javascript
var Nightmare = require('nightmare');
var nightmare = Nightmare({ show: true })

nightmare
   .goto('https://wellsfargo.com')
   .evaluate(function () {
      return "Made it";
   })
   .end()
   .then(function (result) {
      console.log(result)
   })
   .catch(function (error) {
      console.error('Login failed:', error);
   });
```

The electron window will come up with wellsfargo.com loaded and do nothing.
Open the console and you will see two errors, both saying `__nightmare is not defined`

I tested the yahoo search example and it worked fine. My guess is that it's forgetting the injection that happened.

Further investigation:
If you inspect the `window` object you will notice `__nighmare` no longer exists under `window.__nightmare`, it is now under `window[""].nightmare`
 I changed both of the ipc declarations in javascript.js to:

``` javascript
var ipc = (window.__nightmare ? __nightmare.ipc : window[''].nightmare.ipc);
```

And it works now.
 Making a PR...
 merged PR  Non-200 codes are not treated as errors - pages that respond with non-200 codes might be expected behavior.

[`.goto()`'s return](https://github.com/segmentio/nightmare#gotourl-headers) will include metadata about the page load, including the response code.  A quick off-the-cuff example:

``` js
var nightmare = require('nightmare')();
nightmare.goto('http://example.com/404')
  .then(function(gotoResult) {
    console.dir(gotoResult.code);
    return nightmare.end();
  })
  .then(()=>console.log('done'));
```
 Hm, I think I see what you're saying, @Oted.  The problem here is defining what a "load success" is.  Any page that completes the HTTP request - be it an HTTP success (eg, a 200) or an HTTP failure (eg, a 404) - is considered a successful request.  The documentation should be worded more carefully to make that clearer.

_Edit:_ I take back what I said, and shouldn't have fired totally from the hip: this has come up before, and I had forgotten the documentation had already been updated.  The docs are pretty clear, I think:

> Note that any valid response from a server is considered â€œsuccessful.â€ That means things like 404 â€œnot foundâ€ errors are successful results for goto. Only things that would cause no page to appear in the browser window, such as no server responding at the given address, the server hanging up in the middle of a response, or invalid URLs, are errors.
  This looks great.  Thanks!
  Thanks for the eyes!
  For what it's worth, you could also capture it from preload using something like (from @nickstanish):

```js
  var open = window.XMLHttpRequest.prototype.open;
  window.__responses = [];
  window.XMLHttpRequest.prototype.open = function (method, url, async, user, pass) {
      this.addEventListener("readystatechange", function() {
        console.log('ready state %s is %s', url, this.readyState);
        if (this.readyState === 4) {
          window.__responses.push({
            responseText: this.responseText,
            readyState: this.readyState,
            url: url,
            method: method
          });
        }
      }, false);
    open.apply(this, arguments);
  };
```  `Nightmare.action()` does not work as I would've expected it to, where `done` is always the last argument.

``` js
Nightmare.action('iframeHeight', function(selector, done) {
  this.evaluate_now(function(selector) {
    //const element = document.querySelector(selector);
    //return window.getComputedStyle(element,null).getPropertyValue('height');
    return 100;
  }, selector, done);
});
```

``` js
it('works', function() {
  return browser.iframeHeight('#bigFrame').then(result => console.log(result))
  //return expect(browser.iframeHeight('#bigFrame')).to.eventually.equal(1000);
});
```

results in:

```
Nightmare runner error:

    TypeError: done is not a function
        at EventEmitter.response (/project/node_modules/nightmare/lib/runner.js:323:7)
```

After looking at [actions.js](https://github.com/segmentio/nightmare/blob/2.7.0/lib/actions.js#L55-L62), we can see that the args are backwards in `evaluate_now()`. The correct version would be:

``` js
Nightmare.action('iframeHeight', function(selector, done) {
  this.evaluate_now(function(selector) {
    const element = document.querySelector(selector);
    return window.getComputedStyle(element,null).getPropertyValue('height');
  }, done, selector);
});
```
 Defining multiple arguments is a bit weirder:

``` js
Nightmare.action("broquire", function(id, browserValue, done) {
    this.evaluate_now( function(id, browserValue) {
        return window.broquire(id, browserValue);
    }, done, id, browserValue);
});
```
 Optional arguments are even weirder:

``` js
Nightmare.action("broquire", function(id, browserValue, done) {
    // Avoid weird magic with `nightmare.broquire(id)`
    if (done === undefined) {
        done = browserValue;
        browserValue = undefined;
    }
    if (browserValue !== undefined) {
        this.evaluate_now( function(id, browserValue) {
            return window.broquire(id, browserValue);
        }, done, id, browserValue);
    } else {
        // This avoids `browserValue` being passed as `[null]` (due to serialization?)
        this.evaluate_now( function(id) {
            return window.broquire(id);
        }, done, id);
    }
});
```
  A quick look at this - you're trying to call `cssLookup` from within an `evaluate_now`ed function when the function is defined outside of the evaluated context.  That closed-over scope is not carried to the evaluation as it crosses the IPC boundary.  (See [here](https://github.com/rosshinkley/nightmare-examples/blob/master/docs/common-pitfalls/variable-lifting.md) for a slightly longer explanation.)  You'll probably want to tuck that function into the preload.

That said... I'm not _entirely_ sure this is necessary.  Is there a problem that XPath solves that CSS selectors cannot?  More generally, are there users out there that this feature would be of use to?
 @gjmveloso as @rosshinkley mentioned we've decided to keep css lookup for minimal simplicity. if there's a super clean, tested and ready-to-go PR may reconsider!  Depends on what you mean.  If you're trying to issue a `POST` from the client, you could use `.evaluate()` and `XMLHttpRequest` (or use/`.inject()` your tool of choice) to issue the request.

Could you provide more information about your use case?
  Promises are asynchronous.  `breadcrumb` is equal to the Nightmare instance with the queued actions when you run `expect`.  Also, the way you have your Mocha method set up, it will expect your tests to be synchronous.

With that in mind, let's modify your test case.  Something like:

``` js
var Nightmare = require('nightmare');
var expect = require('expect');

describe('test yahoo search results', function(done) {
  it('should find the nightmare github link first', function() {
    var nightmare = Nightmare()
    var breadcrumb = nightmare
      .goto('http://yahoo.com')
      .type('input[title="Search"]', 'github nightmare')
      .click('.searchsubmit')
      .wait('.url.breadcrumb')
      .evaluate(function () {
        return document.querySelector('.url.breadcrumb').innerText;
      })
      .then(function(result) {
        expect(result).toEqual('github.com');
        done();
      });
  });
});
```

It's also worth pointing out that the test was originally using `mocha-generators`, and in cleaning up the readme to remove the dependencies, the example didn't get modified properly.  There is an open PR (#758) to clean it up.
 Without digging into it too deeply, you may want to consider adding a `.catch()` block.  Something like:

``` js
describe('Login Page', function() {
  it('username and password should log you into the dashboard', function(done) {
    var nightmare = Nightmare()
      .goto(CONST.url)
      .type(CONST.usernameID, CONST.username) // enter user name
      .type(CONST.passID, CONST.password) // enter password
      .click(CONST.loginButtonID) // click log in
      .wait(TESTCONST.IDToCheckAfterLogin) // wait for dashboard to come up
      .evaluate(function () {     // Select dashboard title and return text 
          return document.querySelector(TESTCONST.mainPageDashBoardElementSelector).innerText;
      })
      .then(function(result) {
        // assert
        expect(result).toEqual(TESTCONST.dashboard);
        done();
      })
      .catch((err) => done(err));
  });
});
```

Otherwise, use `DEBUG` and see if that doesn't give you some useful output.
  This is (I'd think) expected behavior.  The documentation could probably be a little clearer, stating that `.type()` and `.insert()` _should_ take strings, but don't necessarily have to (eg, `.type('#someInput', true)` types the string "true" the selected element).  Both functions do their best with what they are given.  To that end, I don't think it's a particularly great idea to enforce only strings.  (I'm open to counterargument, though.)

That said, the documentation _is_ pretty clear about what happens with falsey values, which as you note, `0` is an example.
  Are you trying to bundle Nightmare into an Angular2 application?  I'm not exactly clear on what the problem is.  Could you provide more information?
 Closing for inactivity.  If this is still an issue, feel free to reopen/open a new issue.
  According to the [Command Line API Reference](https://developers.google.com/web/tools/chrome-devtools/debug/command-line/command-line-reference):

> This API is only available from within the console itself. You cannot access the Command Line API from scripts on the page.

In other words, `$x()` isn't available from an evaluation context.

You could use `document.evaluate()`, it takes an XPath expression as an argument.  [MDN](https://developer.mozilla.org/en-US/docs/Introduction_to_using_XPath_in_JavaScript) has a good introduction on this topic.
  `.evaluate()` is intended to be synchronous, at least for now.  I suspect that may be at least part of your problem.

There is a [plugin](https://www.npmjs.com/package/nightmare-evaluate-with-callback) that takes care of this, as well as an in-progess PR (#573) to try to address it.
 #819 should solve this problem.  Closing.
  I was _really_ hoping to get something similar into core with #573.  If you want to pick that up and run with it, great - otherwise, I'm going to try to pick it up and submit a solution as time permits.

In the meantime, though, thank you.  This will help many outstanding problems.
  Yes, this is expected behavior.  Nightmare actions, as you noted, are queued but not run until `.then()` is executed.
  Hm, I can't reproduce the issue with 2.6.1 on my headless setup.

I don't _think_ it's a security problem, and what's truly unfortunate is that the code is the generic networking timeout.  What version are you using on your headless setup, and how are you executing headlessly?
  Nightmare, by default, will wait for the [`did-stop-loading`](https://github.com/electron/electron/blob/master/docs/api/web-contents.md#event-did-stop-loading) event.  This event is typically emitted once the page is "finished" loading (be it from the original 20x completing or `stop` being called).  At that point, the page should already be in a ready state.  (Should.  If it isn't, or you have a a countercase, I'd love to hear about it.)

However, `complete` may not be helpful: you could still have client-side scripts issuing requests for assets to load asynchronously, or already-loaded assets modifying the DOM in flight.  I'm not _entirely_ sure what your use case is, though, and I suspect there may be more to it than I think.
 Thanks!
  This seems like a Windows-specific problem with Electron, but nothing is jumping out at me in the Electron repository (or `electron-prebuilt`, for that matter).  To be clear, the above works for the Google goto, but not the login?  What if you point it to a different version of `electron-prebuilt` with [`electronPath`](https://github.com/segmentio/nightmare#electronpath)?
 Sorry for the delay, @scytalezero - yes, I'd go ahead and report it at Electron, which it looks like you've already done. :)

Would you mind linking to it here?
  Cross-site `.evaluate()` calls aren't going to work: the evaluated function is executed in the current page's context.  In other words, as soon as you `.click()` on one of those links, you'll lose your evaluation context.  Also, `.evaluate()` calls are currently designed to be synchronous, although there has been some work to make `.evaluate()` calls asynchronous (see #573).

Based on your snippet, I'm not clear on what you're trying to do: are you trying to click on each github link?

Also, as a matter of housekeeping, you _might_ want to take a look at [asynchronous operations and loops](https://github.com/rosshinkley/nightmare-examples/blob/master/docs/common-pitfalls/async-operations-loops.md).
  In your `.catch()` block, you're trying to use jQuery from within your script, which isn't going to work.  You have access to the failed URL - you're creating it in `.goto(endpointPsicos + i)`.  Couldn't you push that + the error?
 Closing for inactivity.  If this is still an issue, feel free to reopen/open a new issue.
  `.click()` will blur the currently active element, which I'd _think_ should be the body if nothing has been selected.  From MDN:

> When there is no selection, the active element is the page's &lt;body&gt; or null. 

I know there are some OS differences with how this works, but I'd hope that Electron behaves the same across platforms.  I suppose it's possible AUI modifies this value, although it seems unlikely.  In any case, that's the only [`.blur()` call within `.click()`](https://github.com/segmentio/nightmare/blob/master/lib/actions.js#L88).

If you modify that line to check for the active element's existence first, do you still have this problem?
 I did some digging with Chrome/Electron specifically: if you remove the active element from the DOM, the active element will point to the `body`.  The only way to get the active element to refer to null (at least in my experimentation) is to delete the `body` from the `html` tag.  (I sincerely doubt you're doing that.)

@willclarktech pointed out in [this issue](https://github.com/willclarktech/elm-boilerplate/issues/3) that the element could be removed between `.type()`/`.insert()` and `.blur()`, which would cause a similar problem, but those are getting the specific selectors, not the (somewhat nonspecific) active element.
  FWIW, asynchronous evaluate is now possible with #819.

Between that and #688, I _think_ this is resolved.  Feel free to reopen/open a new issue if not.
  I agree with @Mr0grog.  The examples should probably use plain promises to minimize external dependencies.
  This change seems reasonable to me, and I wonder if it might effect the outstanding issues with orphaned processes?

Anyway, including.  Thanks!
  A couple of explicit tests for this would be nice.  One handling the timeout, one handling the element existing before the timeout should be sufficient.  Thoughts?
 @noahtkeller I think this is probably sufficient for now.  Thanks!
  This should have been fixed with #757, I think.  Closing.
  Reproduction would be nice.  I can't reproduce locally.
  Hm, try upgrading to 2.6.0, I think this may have been fixed by coincidence by fixing how Nightmare reacts to closing the Electron window.

If that doesn't solve it, it's possible a solution to #688 may fix your issue.
  @ivan-kleshnin What version of Nightmare are you using?  When I run your second example with 2.6.0, I get the expected behavior of typing in `#email`.
  I'd be curious to know what operating system and version of Nightmare you're running.  Electron (and Chromium) misbehave beyond the texture size limit (see #616 and possibly #695) - is it possible you're hitting that?
 Perhaps the `.wait(1000)` isn't long enough? Try using a `.then()` instead, or perhaps you need an otherwise unnecessarily long content height algorithm: https://github.com/segmentio/nightmare/issues/726#issuecomment-244961028
  @Mr0grog hm, that's odd.  I'm curious what changed, but in this case, I _imagine_ fixing it first might be simpler.

And yeah, I think a modification to the circle yaml to run `nvm install` for possibly all three versions in the `pre` would work.  Thoughts? 
 > With the events? TBH, I donâ€™t really want to do the dig-through-the-event-and-find-all-the-problems-and-patch-them-then-lobby-electron-for-a-fix-then-see-this-break-later dance again.

Ha, I was referring to the Circle setup, but I'm +1 on this too.  I don't _really_ care all that much about including the event data, because as you said, we're not really using the data to begin with.  (I also have an odd sense of deja vu.  Haven't we had this conversation before?)

 Put me down for "strongly agree." :)

> Yeah, makes sense to me.

Cool.  I see you already made the changes.  Thanks!
 > Dâ€™oh, sorry to unload when you werenâ€™t even asking about that.

Don't worry about it, I wasn't being terrifically clear.

> Yep, way back in #576 :P

Good gravy.  Well, it's good to know my memory isn't totally failing.
  It looks like the `resetChanges` method from    8015fe0 splices the `cookies` namespace out of existence, causing those tests to fail.

Otherwise, +1.  Thanks, @Mr0grog :)
  Short version:  Out of the box, for now, you can't.

Longer version: It's on the docket for v3 (see #593), but for now, depending on your needs, I wrote a [plugin](https://github.com/rosshinkley/nightmare-window-manager) to try to address the most _basic_ of requirements (read: what I needed at the time).
 Closing for lack of activity.  If this is still a problem, feel free to reopen/open a new issue.
  @RichardJECooke Whether or not you have `show: true` when running under Docker does not make it headless or headed.  It makes the rendering on the framebuffer (most likely `Xvfb`) render as though it were visible.

Nightmare isn't _truly_ headless: it requires an Electron instance to work, which in turn requires a framebuffer to render properly (at least, for now).

Setting that aside: if you set `show: true` or `show: false` (the default), it will likely not run out-of-the-box on a Docker instance as Docker instances _are_ intended to be headless, and as such, don't typically have a framebuffer included on the image.  To do that, @voidmonk's suggestion stands: have a look at #224 regarding running with `Xvfb` or `xvfb-run`.  You may also want to have  a look at the test suite for Nightmare as that runs on a headless CircleCI server.
 I think this is resolved.  If not, feel free to reopen/open a new issue.
  Give [asynchronous operations and loops](https://github.com/rosshinkley/nightmare-examples/blob/master/docs/common-pitfalls/async-operations-loops.md) a read - that should help you get started.
  @voidmonk Out of curiosity, what version of nightmare are you using?

@Mr0grog is right, the provisional load failure is causing an exception.  In your last comment, that exception is handled, and should work fine (although your `.then()` that handles the status code will not be called).
 @voidmonk The fix wasn't included as it has a test issue that needs to be addressed. As soon as it's fixed, I'll pull it in and cut another release.
 @geostant I'd suggest opening a new issue with a minimum repro case.
  Nice!  Thanks for the update!
  Silly question: have you tried running with `DEBUG=*` to see if that has any helpful information?
 (Also: Possibly related to #405.)
 Considering this fixed with #927.  If you're still having this problem with that change, feel free to reopen.  @Snake4life The proxy server is set up for every request from Electron.  Are you not seeing that behavior?
  Could you do something like `DEBUG_FD=3 DEBUG=nightmare*,electron* node my-script.js 3>log.txt`?
 (Alternatively, I think you should be able to use `nightmare.on('log', fn)` to capture log messages.)
  Correct me if I'm wrong: isn't the default `<select>` control an OS-level control (or at best, an application control)?  It's not necessarily rendered by the web frame - meaning that I don't think it will show up with `.screenshot()`.
  @Stankye: @vshvydky's answer is on the right track, but unfortunately won't work: `document.querySelectorAll` returns a DOM element collection, which like `arguments` isn't actually an array.  

From the hip, something like:

``` js
nightmare.goto(someUrl)
  .evaluate((selector) => {
    let elements = document.querySelectorAll(selector);
    Array.from(elements).forEach((element) => element.click());
  }, 'input[type=checkbox]')
  .then(()=>console.log('done'));
```

...might work.

If I'm reading the [spec](https://www.w3.org/TR/DOM-Level-2-HTML/html.html#ID-2651361) right, though (and it is _entirely_ possible I'm not), that will only work for `input`s.  If you want to use it on a generic element, you'll want to emit the click event yourself:

``` js
nightmare.goto(someUrl)
  .evaluate((selector) => {
    let elements = document.querySelectorAll(selector);
    Array.from(elements).forEach((element) => {
        var event = document.createEvent('MouseEvent');
        event.initEvent('click', true, true);
        element.dispatchEvent(event);
      });
  }, 'div.click')
  .then(()=>console.log('done'));
```

Do either of those work for you?
 Closing for inactivity.  If this is still an issue, feel free to reopen/submit a new issue.
  happy to consider, but the tests are failing: https://circleci.com/gh/segmentio/nightmare/918  I don't think you can hide the scrollbars with Electron [before DOM ready](https://github.com/electron/electron/issues/3534).

Out of curiosity, could you use `-webkit-scrollbar` set to `display:none` to hide the scrollbar?  It will still be there before `dom-ready`, but I _think_ you can hide it:

``` js
nightmare
  .goto('http://example.com')
  .evaluate(function() {
    var s = document.styleSheets[0];
    s.insertRule('::-webkit-scrollbar { display:none; }');
  })
  .viewport(100, 100)
  .then(function() {
    console.log('done');
  });
```

Would something like that work for you?
 Closing as this seems to be resolved.
 They are not documented in the readme because they are not internal to Nightmare, they're internal to Electron's `BrowserWindow`.

What do you mean "don't appear to do anything"?
 @rosshinkley They did not auto-size the viewport to the content. Instead I had to do all of this:

``` js
function calculateContentHeight() {
  function getNumericalStyle(element, property) {
    return parseFloat( window.getComputedStyle(element,null).getPropertyValue(property) );
  }

  var html = document.documentElement;
  var body = document.body;

  var bodyMarginBottom  = getNumericalStyle(body, "margin-bottom");
  var bodyMarginTop     = getNumericalStyle(body, "margin-top");
  var htmlMarginBottom  = getNumericalStyle(html, "margin-bottom");
  var htmlMarginTop     = getNumericalStyle(html, "margin-top");

  var bodyPaddingBottom = getNumericalStyle(body, "padding-bottom");
  var bodyPaddingTop    = getNumericalStyle(body, "padding-top");
  var htmlPaddingBottom = getNumericalStyle(html, "padding-bottom");
  var htmlPaddingTop    = getNumericalStyle(html, "padding-top");

  var margins  = bodyMarginBottom  + bodyMarginTop  + htmlMarginBottom  + htmlMarginTop;
  var paddings = bodyPaddingBottom + bodyPaddingTop + htmlPaddingBottom + htmlPaddingTop;

  return html.offsetHeight + Math.round(margins + paddings);
}


var browser = new Nightmare();

browser
.goto("etc")
.viewport(1000, 0)  // for getting the actual height of short content
.then(() => browser.evaluate(calculateContentHeight))
.then(contentHeight => browser.viewport(1000, contentHeight))
.then(() => browser.wait(50))  // wait for correct calculations (?) -- Semaphore CI was failing without this, but local Ubuntu and OSX were fine
.then(() => browser.screenshot())
```
  Hi everyone, when i run example.js 

```
var Nightmare = require('nightmare');
var nightmare = Nightmare({
    show: true
});
nightmare
    .goto('http://yahoo.com')
    .type('form[action*="/search"] [name=p]', 'github nightmare')
    .click('form[action*="/search"] [type=submit]')
    .wait('#main')
    .evaluate(function() {
        return document.querySelector('#main .searchCenterMiddle li a').href;
    })
    .end()
    .then(function(result) {
        console.log(result);
    })
    .catch(function(error) {
        console.error('Search failed:', error);
    });
```

I have some error : 

```
/Desktop/nodejs/node_modules/nightmare/lib/nightmare.js:77
    debug(`WARNING:  load timeout of ${options.loadTimeout} is shorter than go
          ^
SyntaxError: Unexpected token ILLEGAL
    at Module._compile (module.js:439:25)
    at Object.Module._extensions..js (module.js:474:10)
    at Module.load (module.js:356:32)
    at Function.Module._load (module.js:312:12)
    at Module.require (module.js:364:17)
    at require (module.js:380:17)
    at Object.<anonymous> (/Desktop/nodejs/night-mare/exmple.js:1:79)
    at Module._compile (module.js:456:26)
    at Object.Module._extensions..js (module.js:474:10)
    at Module.load (module.js:356:32)

```

I appreciate any help you can give!
 Silly question:  what version of Node are you running?
 i upgrade the last version , i fixed  it, Thanks a lot!
 @varsano Upgrade NodeJS.  Nightmare will not work with anything <4.x.
  >  is there any option to get all messages, events, errors with listening only one event so i can see what is happening on the page.

Try running your script with `DEBUG=nightmare*,electron*` if you're not already.  That might have some useful information.

> After some more investigation i detected that it's stopping on .wait(selector) function.

Is it the same one every time?

> I checked and the callback is not working always once it's not working and the wait function is stopping working.

Which callback?  The one for `co`?
  I'm guessing you're trying to return `DOMElement.getBoundingClientRect()` from `.evaluate()`?  I suspect that the properties of DOM object you get back are not enumerable, and as such, aren't getting serialized.  Try explicitly returning an object with the properties you want.
 @xmen4u Could you post an example?  I want to be sure we're on the same page.
 Again, the `DOMRect` that `getBoundingClientRect()` returns won't serialize nicely, and won't cross the IPC boundary between Electron and Nightmare.  You'll lose the properties and be left with an empty object.

The easiest way to fix this is to return an object with the properties off of the `DOMRect` that you want.  Something like:

``` js
var nightmare = require('nightmare')();
nightmare
  .goto('http://example.com')
  .evaluate(() => {
    //get the bounding rect for the `body`
    var rect = document.querySelector('body').getBoundingClientRect();
    //pull out `top` and `width`
    return {
      top: rect.top,
      width: rect.width
    };
  })
  .then(bounds => console.log(bounds))
```

I apologize this wasn't clear before.
 @sebastienbarre Memory serving, they're in pixels... you _might_ want to open a new issue (if you haven't already) with an example.  This is a known quirk, for lack of a better word.  The underlying implementation calls [`BrowserWindow.setSize()`](http://electron.atom.io/docs/api/browser-window/#winsetsizewidth-height-animate).  It's been touched on in [#593](https://github.com/segmentio/nightmare/issues/593#issuecomment-216927915) as a breaking change, and also talked about in [#596](https://github.com/segmentio/nightmare/issues/596#issuecomment-214392429).
 Also worth pointing out: setting `webPreferences.useContentSize` to `true` will force the render area to be the size that `.viewport()` sets.

With that, I think this issue is resolved.  If you're still having problems, feel free to reopen/open a new issue.
  I think you'd be better off defining your custom action (if you need one) and then using [`.use()`](https://github.com/segmentio/nightmare#useplugin).  That will let you queue multiple actions together, which I think is ultimately what you're after.

The problem with defining actions within actions is that the action you define (`something` in your example) will add actions to the queue - but instead of adding them between `something` and the next action in the chain, it will add them at the end as the action function for `something` isn't run immediately.

For a little background, you may want to take a look at rosshinkley/nightmare-examples#3, the [`.action()` example](https://github.com/rosshinkley/nightmare-examples/blob/master/docs/beginner/action.md) and the [`.use()` example](https://github.com/rosshinkley/nightmare-examples/blob/master/docs/beginner/use.md).
 Closing for inactivity.  If this is still a problem, feel free to reopen/open a new issue.
  > But I only triggered nightmare successfully in first time with my api,
> when I call again my api I can't trigger nightmare any more

It looks like you're defining your instances outside of `getScrap()`, then calling `.end()` inside of `getScrap()`, which will end and destroy the Nightmare/Electron instances.  Once they are ended, they can no longer be used.  Try moving the creation of your Nightmare instances inside of the `getScrap()` method.

> another question, in below case, I need to instantiate new Nightmare object individually , so that I can scrap three different site, have any smarter way to achieve that?

Depends on what your use case is.  You could use a single Nightmare instance and iterate over the URLs, but that will take more time as Nightmare execution _must_ be sequential.  If you're curious on how to do such a thing, [this article from `nightmare-examples`](https://github.com/rosshinkley/nightmare-examples/blob/master/docs/common-pitfalls/async-operations-loops.md) might be worth reading.

Finally, it's probably worth pointing out that based on your above code, you don't have to use `cheerio`.  You could use `.evaluate()` and CSS queries to accomplish what you want, I think.
 Performance-wise, you might see a slight improvement.  You would be cutting out the time it takes for the IPC to respond with the HTML and the time it takes `cheerio` to parse the HTML document.

If jQuery is your tool of choice, you could also use [`.inject()`](https://github.com/segmentio/nightmare/#injecttype-file) to add jQuery to the page so it's available when you use `.evaluate()` (if jQuery is not available on the page already).
 Closing for inactivity.  If you're still having issues, feel free to reopen/open a new issue.
  I think the [`did-get-response-details` event](https://github.com/electron/electron/blob/master/docs/api/web-contents.md#event-did-get-response-details) should have what you're after.  Something like:

``` js
nightmare.on('did-get-response-details', 
  (
    sender, 
    status, 
    newURL, 
    originalURL, 
    httpResponseCode, 
    requestMethod, 
    referrer, 
    headers,
    resourceType
  ) => {
  //add your checks for url, request method, etc...
  console.dir(headers);
});
```
 Closing for inactivity.  If this is still a problem, feel free to reopen/open a new issue.
  @AVVS are those files available publicly?  The links you provided all 404.

Maybe you could post the relevant parts here or in a gist?
 At first blush, I suspect the selector you're typing into does not exist.  It may be worth checking with `.exists()` first, and if it does not exist, throwing an exception.  Error handling/reporting could stand some improvement (see #646).
 @AVVS Is this resolved?
 @AVVS No problem, glad you got it sorted.  Instead of using `.inject()` (which is what I'm assuming you're using?), you _might_ want to define a [custom preload](https://github.com/segmentio/nightmare#custom-preload-script) for your test suite.
  @diverse-soles Out of curiosity, what library were you using?
  @goddyZhao This is one of the things that #573 was attempting to address.  Currently, there is no way to allow for asynchronous actions in `.evaluate()` out of the box.
 Merging into #552.
  Thanks for another pair of eyes!
  Two problems afoot here.  

Let's address the immediate problem first: why it's crashing.  You have specified a `pageSize` of `letter`, which [according to the Electron docs](https://github.com/electron/electron/blob/master/docs/api/web-contents.md#webcontentsprinttopdfoptions-callback) should be capital-L `Letter`.  The page size is (evidently) case-sensitive as `letter` crashes on my Ubuntu 16.04 image and `Letter` works fine.

Onto the other problem: why the output was empty.  `.pdf()` tries to happily pass the error argument up the IPC chain, and since `Error` does not have helpful enumerable properties, the information is omitted. This falls under the banner of what #646 was trying to accomplish.
  > also removes "it.only" from unit tests (assuming that was unintentional).

Yes, it was unintentional.  Streams got crossed.  (This was also fixed in #697, fwiw.)

> I admit that I'm not sure what to write for a unit test here. If you can give me some guidance, that would great.

I think the easiest thing to do would be to use a custom `.action()` action to pull the environment variable from Electron's `process`.  You should then be able to create an instance with an environment variable, use the custom action to get that variable, and test accordingly.
 You should be able to pull `env` off of `process` like you might for any ordinary process, I think.  Off the cuff:

``` js
var Nightmare = require('nightmare');

Nightmare.action('envtest',
  function(name, options, parent, win, renderer, done) {
    parent.respondTo('envtest', function(done){
      done(null, process.env);
    });
    done();
  },
  function(done) {
    this.child.call('envtest', done);
  });

var nightmare = Nightmare();

nightmare.goto('http://example.com')
  .envtest()
  .then((r)=> {
    console.log(r);
  });
```

... should be enough to at least make sure you can get the environment variables back.
 No problem! :)

One minor nit: could you remove the `console.log`?
  This should have been fixed with #705.  Closing.
  `.scroll()` [scrolls on the window](https://github.com/segmentio/nightmare/blob/master/lib/actions.js#L494), not on the components contained in them.

That being said, you should be able to use `.evaluate()` and [`Element.scrollTop`](https://developer.mozilla.org/en-US/docs/Web/API/Element/scrollTop) to accomplish what you're trying to do.  If I'm reading your source, you're trying to scroll to the end of all of the code divs, yes?  Something like:

``` js
var Nightmare = require('nightmare');
var vo = require('vo');
var nightmare = Nightmare({
  show: true
});
var run = function*() {
  yield nightmare.goto('http://codepen.io/Yakudoo/pen/YXxmYR');

  var currentHeight;
  var currentHeight = yield nightmare.evaluate(function() {
    var scrolls = document.querySelectorAll('.CodeMirror-scroll');
    return {
      html: scrolls[0].scrollHeight,
      css: scrolls[1].scrollHeight,
      js: scrolls[2].scrollHeight,
    }
  });
  console.dir(currentHeight);

  yield nightmare.evaluate(function(heights){
    var scrolls = document.querySelectorAll('.CodeMirror-scroll');
    scrolls[0].scrollTop = heights.html;
    scrolls[1].scrollTop = heights.css;
    scrolls[2].scrollTop = heights.js
  }, currentHeight);

};
vo(run)(function(err) {
  console.dir(err);
  console.log('done');
});
```

I left both evaluate calls in for illustrative purposes.  You could cut one of the `.evaluate()` calls and determine height and scoll in a single step:

``` js
var Nightmare = require('nightmare');
var vo = require('vo');
var nightmare = Nightmare({
  show: true
});
var run = function*() {
  yield nightmare.goto('http://codepen.io/Yakudoo/pen/YXxmYR');
  yield nightmare.evaluate(function() {
    Array.from(document.querySelectorAll('.CodeMirror-scroll')).forEach(function(el){
      el.scrollTop = el.scrollHeight;
    });
  });
};
vo(run)(function(err) {
  console.dir(err);
  console.log('done');
});
```

These might not be 100% what you need, but it should get you on track.
  At first blush, what you have looks like it should work.  Out of curiosity, if you print the index and directory in the then starting with `.then(info => { ...`, what does that result in?  What download library are you using?
 I did a little digging, and assuming you're using `nightmare-inline-download`, this is a bug in that library.  The download handler never gets removed, meaning the first download handler will always handle the download, assigning it the same path.  Fix for that shortly.
 Merging into rosshinkley/nightmare-inline-download#6.

If that's not the library you're using, feel free to reopen this issue.
  I'm not certain, but I don't think so, at least not directly.  Electron's screen resolution depends on the framebuffer it's rendering to.  You could use something like `xvfb-run` to alter the framebuffer (#224 touches on this, although for an entirely different reason).

What are you trying to accomplish?
 Closing for lack of response from OP.  Feel free to reopen/open a new isuse if this is still a problem and you have more information.
  I'm not exactly sure I understand the problem you're trying to solve.  Are you asking if `.wait()` could accept a timeout per-call?
 I _think_ the intent of this is the same as #742.  Merging.
  Fixes #694, also removes an errant `.only()` in the test suite.
  Looking at the current implementation of `.authentication()` and the documentation for the [`login` event](https://github.com/electron/electron/blob/master/docs/api/web-contents.md#event-login), the actual authentication happens out-of-band with respect to the Nightmare action chain.  There also isn't a login failure event exposed by Electron.  This makes handling error cases tough.

The best solution I can think of is to have Nightmare support an internal event to kill the event chain from an out-of-band event, then creating an out-of-band event after a certain number of retries.

Trying to fix this also uncovered another problem: being able to change authentication after it is set.

All of the above _should_ be addressed in #714.
  Is this possibly the same problem as #596?
 @OleVik Specifically, I was referring to the scrollbar/title et al eating into the pixel count.  I think that might be _part_ of the problem.  The buffer height being incorrect is distressing.

I know there is a problem where you cannot create a window larger than the display size on Windows (see electron/electron#4932 and possibly electron/electron#5053), but resetting the viewport (which calls `BrowserWindow.setSize()` under the covers) _should_ work.

Out of curiosity: can you set the height using `.viewport()` to something big but smaller than the size returned?  Something on the order of `.viewport(dimensions.width, 4000)`?  (I wonder if you're possibly hitting a texture limit and Chromium is misbehaving because of it.)
 @OleVik Out of curiosity, what happens if you try to snap a screenshot of say, `.viewport(4000,4000)`?

A while back, I wrote a quick and dirty [gist](https://gist.github.com/rosshinkley/b5fb5061073756e926b791a66d62b24b) that spit out the max texture size - I wonder if that could be ported to use opengl and freeglut for Windows?
 Hm, that's ... odd.  I would not expect a texture tile to be rectangular.  This makes me wonder if it's something perhaps Windows-specific.

What version of Windows are you running?
  Reopening until Electron dependency is bumped.
 @trompx `XRANDR` being missing is not that big of a deal; unless you're explicitly loading it with `Xvfb` (or whatever X buffer you're using), that line is going to show up, serving as a warning that you will not be able to resize and rotate your buffer.  The original problem with this thread had to do with how Electron was being started, and on certain flavors of Linux, was crashing, which would cause Nightmare to misbehave.
  Hm, out of curiosity, what version of Nightmare are you using?

I thought that if the page was loading, Nightmare would wait for the artificial `did-change-is-ready` event before continuing from a `did-stop-loading` event.  In other words, a race condition while loading shouldn't be possible because the action chain _should_ be blocked.

I'd love to see a minimum case if you could throw one together.  As time permits, I'll see if I can reproduce the problem.
 @LinusU Bumping this thread - did you either get this resolved or put together a test case?
  That's a great idea.  I'll look into it.
  Could you post a small example that reproduces the problem?
 @TimNZ If I'm understanding the problem properly (and it is _thoroughly_ possible I am not), this would mean either that `ChildProcess.kill()` isn't actually killing the child process, meaning Electron isn't honoring `SIGTERM`, or there is some edge case for ending the process that isn't handled properly.  (The latter seems _far_ more likely.)

I am curious to see a reproduction - that would be most informative.
  Keeping the documentation consistent: could you move the `.evaluate()` and `.then()` methods to be inline?
 By the by, the first two commits: +1.  Those are logical changes.
 Awesome.  Thanks! :)
  I'm not sure I follow: when you click `#submit1`, the browser you click in closes?  Have you tried this with `.catch()`?  Also, are you sure the popup does not appear?  (The base Nightmare window is set to be always on top.  Try moving it around to see if the popup is hidden.)

It's worth noting that Nightmare does not work with multiple windows by default.  I wrote a [plugin](https://github.com/rosshinkley/nightmare-window-manager) to address very basic window management needs, but it lacks most of the basic commands that Nightmare has and exists more as a prototype than anything.  See the discussion for making window management native in the next major revision in #593.
 Closing for lack of activity.  If this is still an issue, feel free to reopen/open a new issue.
  Interacting with a Flash application is going to be difficult with Nightmare.  What are you trying to do?
 For what it's worth, you _can_ load [Flash in Electron](https://github.com/electron/electron/blob/master/docs/tutorial/using-pepper-flash-plugin.md).

Something like the following should work:

``` js
var Nightmare = require('nightmare');

var nightmare = Nightmare({
  show: true,
  webPreferences: {
    plugins: true,
  },
  switches: {
    //note: the path on your machine is likely different
    //I'm lifting the player from my local chrome-unstable install
    'ppapi-flash-path': '/opt/google/chrome-unstable/PepperFlash/libpepflashplayer.so'
  }
});

nightmare.goto('http://www.adobe.com/software/flash/about/')
  .then();
```

You should see the Flash intro animation letting you know it is working properly.
 Closing for lack of response from the OP.  If this is still an issue, feel free to reopen/submit a new issue.
  Fixed in #684.  Closing.
  My first gutcheck would be to run the example script with `DEBUG=*` to see if Electron has any useful output.  (My guess is probably not, but it's worth a try.)

Do you have different results running with showing the Electron instance using [`{show: true}`](https://github.com/electron/electron/blob/master/docs/api/browser-window.md#new-browserwindowoptions)?

If you write an example against a simpler site (like http://example.com, say) does it have the same behavior?
  This is related to #682, but I also don't think your source will do what you intend.  Nightmare is asynchronous, queuing actions in a chain until `.then()`, `.run()` or `.end()` is called.  Your `if` statement will always run the `else` condition, and produce undesirable outputs.  From the hip, written to use `.then()`:

``` js
var config = require("./settings.json");
var Nightmare = require("nightmare");
var browser = Nightmare({
    "waitTimeout": config.timeout * 1000
});
var title, exists;
browser.goto(config.url)
    .title()
    .then((t) => title = t)
    .then(() => browser.exists("input.login"))
    .then((e) => exists = e)
    .then(() => {
        if(title === config.loginTitle && exists) {
            doLogin(config.expectedTitle);
        } else if(title === config.loginTitle) {
            console.log("Application Check Passed \u2713");
        } else {
            console.error(`Unknown page was open: ${title}`);
        }
    })
    .then(() => browser.end())
    .then(() => console.log('done'));
```

... of course, this depends on what `doLogin()` does.  It might make sense to return a promise from `doLogin()` and return the result.

You could also use [`vo`](https://github.com/matthewmueller/vo) or [`co`](https://github.com/tj/co) to help with generators and then use `yield` to make your script look a little more synchronous.  Also totally from the hip, written to use `vo`:

``` js
var config = require("./settings.json");
var Nightmare = require("nightmare");
var vo = require('vo');

var browser = Nightmare({
    "waitTimeout": config.timeout * 1000
});

vo(function*() {
    yield browser.goto(config.url);
    if(yield browser.title() === config.loginTitle && yield browser.exists("input.login")) {
        doLogin(config.expectedTitle);
    } else if yield browser.title() === config.loginTitle){
        console.log(`Application Check Passed \u2713`);
    } else {
        console.error(`Unknown page was open: ${yield browser.title()}`);
    }
})(() => {
    console.log('done');
});
```

Same caution as above, this also depends on what `doLogin` does.
  There are two different questions here: one, can the download plugin be applied to other windows; and two, if the target of the click event can be changed.

Answering the first: Nightmare will not handle popup windows by default.  I wrote a prototype [plugin](https://github.com/rosshinkley/nightmare-window-manager) to show how it could be handled, but your example has the added complexity of trying to mix another plugin in with window management.  Under the current incarnation of Nightmare, that would be difficult to accomplish.  Native window management is on the list for the next major revision (see #593).

As for the second: I'm not sure, but I doubt it.  If the input has an `onclick` defined specifically, could you use `.evaluate()` to point the target of the action to `_self`?  Something like: 

``` js
nightmare
  // .... actions setting up your conditions ... 
  .evaluate(() => {
    document.querySelector('input[value=Download CSV]').onclick = 
      () => window.open('/customers/apply/inbox.csv?', '_self');
  })
  .click('input[value=Download CSV]')
  // ... other actions... 
```

... I _suspect_ this won't work, but it might be worth a shot.
 @rluisr Did you get this resolved?
 Thanks, @Siilwyn.  Going to consider this resolved, closing.  Also worth pointing out: there is an API for [clearing data](https://github.com/electron/electron/blob/master/docs/api/session.md#sesclearstoragedataoptions-callback) exposed by Electron, but the method isn't directly exposed in Nightmare.  

You could use `.action()`, but I think `webSession.clearStorageData()` should probably be core.  Thoughts?
  > Observed behavior: the page doesn't refresh (but the logged messages still show).

When the URLs match, you're right - [nothing happens](https://github.com/segmentio/nightmare/blob/master/lib/runner.js#L171-L172).

> I'm aware that refresh() would work in this instance but sometimes it's not known whether the page we want to get the latest data from is already the current page.

I'm not sure I follow - can you elaborate?

> And such information is hard to get as there's no easy way to directly get the current url.

True, there's no `.url()` method or something similar.  Extracting the information should be reasonably straightforward, though:

``` js
nightmare
  .goto('http://example.com')
  .action()
  .anotherAction()
  .evaluate(() => window.location.toString())
  .then((location) => console.log(location))
```

> Doc of goto specifies that nothing happens if the url given is already the current page

That's a good idea.  As mentioned, that's how it's set up.  (I'm sure there was/is a reason, although I can't recall off the top of my head.)
  Yes, provided Electron supports it.  This has been an ongoing discussion at electron/electron#228 as well as the tail end of #224.
  I'm a little confused by your question, and would like to clarify - are you trying to save an image from a page?
 Currently, you cannot open a new browser window from Nightmare.  #593 has it as a possible future improvement.

For now, you could write a plugin to do such a thing - [`nightmare-window-manager`](https://github.com/rosshinkley/nightmare-window-manager) might be a place to start.  It supports window control, but does not support opening a new window (yet).
 Closing for inactivity.  If you still need help with this, feel free to reopen and provide more information about what you've tried.
  Could you include tests, please?  I think that a test verifying the header is set in Express and perhaps another verifying that Electron is returning the correct referrer from `.goto()` would be sufficient.

Somewhat offtopic, I'm not sure how I feel diverging (or diverging more?) from [`webContents.loadURL()`](https://github.com/electron/electron/blob/master/docs/api/web-contents.md#webcontentsloadurlurl-options), but I think I can live with adding `Referer` to the headers in this way.

Also somewhat offtopic, it _might_ be wise to accept both the 3 R (`Referer`) and 4 R (`Referrer`) header names.  Thoughts?
  Could you provide a sample of what you're trying to do?
 Hm, you can end the process with `.end()`, but not until after other actions in the chain have finished.  Are you asking if you can interrupt the chain to kill the process?  That would not be advisable.  You _could_ kill the Electron process manually using `nightmare.proc.kill()`, but that will put the Nightmare instance into a state where the behavior is not well defined.
 Closing for lack of activity/information.  If this is still a problem, feel free to reopen/submit a new issue.
  In versions prior to 2.5.0, this (cryptic) error generally meant that one of your selectors was not finding the specified element.  I think Yahoo runs some form of A/B or has different page characteristics based on the requester.  This problem has cropped up before (#116, #490, and I think there were some others).  The Readme version of the example was patched in 2.4.0, the [runnable example](https://github.com/segmentio/nightmare/blob/2.5.0/example.js) in 2.5.0.

My first suggestion would be to update your example to the 2.5.0 version and try running it again.
 @BerlinaLI I have a suspicion you might be hitting #224.  Thoughts?  You can use an [exclusive test](https://mochajs.org/#exclusive-tests) - eg, `describe.only` or `it.only`.

If you're using `mocha-generators`, there is a [known bug](https://github.com/vdemedes/mocha-generators/issues/2) with `it.only`.  There's a [PR](https://github.com/vdemedes/mocha-generators/pull/4) to fix it that you could pull down and link to, if you were so inclined.  (`describe.only` works fine with `mocha-generators`, for what it's worth.)
 Considering this issue resolved.  If you're still having problems with `.only()`, feel free to reopen/open a new issue.
  Looks like this issue is resolved, closing.
  > I had tried that as well. I tried again and neither of the examples you change anything i.e. I could change the switch (proxy-server) to lkjlkj-weioruweoriu and the code still runs the rest of the program.

Hm, setting `proxy-sever` to a bogus URL (or even a malformed URL) causes provisional load and load failures, at least with 2.5.0.  Out of curiosity, what version of Nightmare are you running?

> I donâ€™t know if you can set the auth info in the URL (e.g. http://user:pass@1.proxy.com:80) or if you would need to use the authentication() action

I would be _very_ curious to know the answer to this.
 With #687 being merged in, I'm going to consider this issue resolved.
  Fixes #663.
  Sure!  The `.then()` function will have as its arguments the results of the previous method:

``` js
nightmare
  .goto('http://example.com')
  .evaluate(() => {
    return document.querySelector('#my_awesome_thing').innerHTML;
  })
  .then((awesomeThingHtml) => {
    //do something with the HTML value
  })
  .then(() => nightmare.end());
```

As another example, you may want to have a look at `nightmare-example`'s ["Running Multiple Steps" example](https://github.com/rosshinkley/nightmare-examples/blob/master/docs/beginner/promises.md#running-multiple-steps).
  > What is the intended use case for .use(fn)?

`.use()` is intended to wrap a group of actions to make adding compound actions to Nightmare a little easier and readable.  Note that it doesn't add callable actions directly to the instance itself.  (In other words, you can't call `nightmare.myAction(...)`, but you can call `nightmare.use(myAction(...))`.)

> I had hoped that it could be used to add actions to nightmare instances, but I haven't gotten that to work since it seems that I can only add actions on the global Nightmare class.

I am guessing you're referring to `.action()`?  This is a very different mechanism - `.action()` adds an action directly to the Nightmare prototype, also adding all of the sugar required to execute a method inside of Electron.

What are you trying to do?
 [In the development of `.action()`](https://github.com/segmentio/nightmare/pull/425#issuecomment-171139723), I had originally thought about adding functionality per instance, but this was abandoned for simplicity's sake.  Is allowing a type to modify it's own prototype bad practice?  (Debatable.)

I think `.action()` is _probably_ better suited to your use-case.  It shouldn't step on other libraries so long as there aren't naming collisions.  Doing what you're asking with `.use()` would probably require calling `.then()`, which might have undesirable effects.

Thinking out loud: would `.exists()` and `.select()` accomplish what you're after?
 For what it's worth: I've thrown together a [`.action()`](https://github.com/rosshinkley/nightmare-examples/blob/master/docs/beginner/action.md) and [`.use()`](https://github.com/rosshinkley/nightmare-examples/blob/master/docs/beginner/use.md) examples over at [`nightmare-examples`](https://github.com/rosshinkley/nightmare-examples).
 That's _really_ what `.action()` was intended for.  You could rewrite your `selectHasOption` and `selectOptionWithText` as `.action()`s.  From the hip:

``` js
Nightmare.action('selectHasOption', (selector, option, done) => {
  return this.evaluate_now((selector, option) => {
    // ...
  }, done, selector, option);
});

Nightmare.action('selectOptionWithText', (selector, option, done) => {
  return this.evaluate_now((selector, option) => {
    // ...
  }, done, selector, option);
});
```

Under the covers, Nightmare amends the prototype with the action you specify.
 First and foremost: I agree.  Modifying the prototype directly for actions has problems.

The idea behind modifying the prototype was, again, done for brevity/cleanliness and so you're not slogging through a ton of boilerplate just to get a Nightmare instance.  Furthermore, patching the prototype is how [internal methods are attached](https://github.com/segmentio/nightmare/blob/master/lib/nightmare.js#L479-L482).  Allowing users to leverage that was a reasonable outgrowth.  Also, patching of Electron behavior was built atop the already-existing patching of Nightmare behavior.

I'm not saying it's correct.  Scope and use of Nightmare has changed.  A lot.

This was sort-of-kind-of touched upon in [this comment](https://github.com/segmentio/nightmare/pull/609#issuecomment-222428497).  I think better plugin/action management should be put on the v3 list in #593.  Thoughts?
 Merging this with #593.  This is what `.then()` is intended to do: execute and then clear the queue.  The `EventEmitter` leak is a long-standing issue (#282, #350, #589, #658 - and I'm sure I've missed many).  While ending the Nightmare instance would "prevent" the leak, I don't think doing what you're asking would solve the underlying issue.
  This looks a _lot_ like electron-userland/electron-prebuilt#108.  The TL:DR version is that you've likely got an ownership discrepancy with your local NPM cache.  Can you give that a look and see if that fixes your problem?
 Closing for lack of activity and information.  If this is still an issue, feel free to reopen/submit a new issue.
  The resolution of [`.goto()`](https://github.com/segmentio/nightmare#gotourl-headers) has that information.  For example:

``` js
var nightmare = require('nightmare')();
nightmare.goto('http://example.com')
  .then((gotoResult) => {
    console.log(gotoResult.code); //prints out the HTTP status for the request
  })
```
 What does not work?  How is it failing?
 @kuyoonjo Be sure you're calling `.then()` after `.end()`.  That will run the queued actions (if any) and end Nightmare gracefully.
 @kuyoonjo also, if you have a more complete example, I'd like to see it.  I might be able to help more that way.
 Awesome.  Closing this as I think it's resolved.  If you have any more problems, reopen/open a new issue.
  With some experimentation, I think Electron dumps the temporary file into `[home]/Downloads` instead of honoring the `paths` download path.  You _can_ override the `home` directory, but I suspect that would have other unintended consequences and isn't really what you're after.  

I'm also kind of surprised that `webContents.savePage()` allows for an undefined path.  I suspect the temporary file is just that - temporary, designed to be removed after the file is moved to the ultimate destination.  Looking at the test spec, there's no explicit cases for an undefined filepath.  Might be worth filing an issue with Electron to see if that's intentional or not.

In the meantime, there are a couple of options:
1. specify the save path every time
2. use `.use()` to wrap the `.html()` action
3. write a plugin to get the behavior you want
 Closing for lack of activity.
  It looks like [you might already have an answer](https://github.com/electron/electron/issues/5635).  I think (someone please correct me if I'm wrong) Chromium uses the HTML from `DOMReady` for fulfilling that action.

As an example, you could write something to fulfill this yourself using `.evaluate()` on the document's HTML.  Something like:

``` js
var nightmare = require('nightmare')(),
  fs = require('fs'),
  path = require('path');

nightmare.goto('http://example.com')
  .evaluate(() => document.documentElement.innerHTML)
  .then((html) => {
    fs.writeFileSync(path.join(__dirname, 'output.html'), html);
    return nightmare.end();
  })
  .then(() => console.log('done'));
```
  fixes #621.
 > Can we also drop the --harmony flags as noted all over the README, then? (I think we can, but honestly not totally sure.)

I'm almost positive we can.

> May also want to add multiple node versions for testing in circle.yml as described here: https://discuss.circleci.com/t/testing-multiple-versions-of-node/542

Ah, that's a good call.  I'll have to look into that a little deeper, what do you think is reasonable?  Latest 4, latest 5, latest 6?  Something like that?
  Looks good.  Thanks!
  @oliviervaillancourt Part one looks great, thanks for fixing that.  Part two I'd _probably_ leave as simply `example.js`.  The example is in the root of the project directory and is (I think) fairly obvious which example we're referring to.  The only remaining thing I can think of is possibly changing the README to say `example.js` instead of `yahoo.js` under the Examples heading on line 55 (which isn't your fault, I think it's been that way for quite a while).

@Mr0grog Thoughts?
 Looks great.  Marking for inclusion.  Thanks for the effort, @oliviervaillancourt!
  This is touched on in #552, and a fix is proposed in #573.  At the time of this comment, it's incomplete.
 Merging into #552.
   > That said, returning something in all the explicit error cases is waaaaaaaay more important. The serialization thing is more of a nicety (but not a free one).

I should have chosen words more carefully.  Freeish?  Cheap?  Close to free?  Free enough?  Free as in mattress?  Take your pick.  My point was you could manage the explicit error data cases internally to the IPC to mimic real capital-E Errors easily enough, so long as the data is consistent.

Anyway, explicit errors are much more important, you're right about that.
  Thank you for this, looks good.

As for the errors, it might be better to move this conversation to #646.  I haven't thought terribly deeply about serializing errors over IPC - my first thought is that all actions would have to consistently handle error cases, which is something we've also touched on in #593.  Once we've got consistent error reporting between the parent and child process, the errors over IPC almost falls out of that for free.  Entirely possible I'm missing something, though.
  I had spotted this when working on stuff for #502, but hadn't gotten around to PRing it.  Thanks!
  @oliviervaillancourt just to +1 what @Mr0grog was saying: _please_, by all means, keep going.  The more contributors, the more people we have involved, the better. :)
  +1 on this.  Including.
  > Iâ€™m not 100% providing both those methods for overriding is bestâ€”maybe it should just follow the example of wait and only support the constructor option?

Hm, I'm inclined to say that it should be a constructor-only option.  I can't think of a case offhand where having differing timeouts by URL would be helpful.  Is there a use case buried here that I'm not thinking of?

> I also wonder if, based on this, certain actions should be exempted from the continue check (e.g. goto, viewport, wait(number)), since itâ€™s not really relevant for everything. I think thatâ€™s definitely out of scope for this PR, though.

Fair point.  I suspect the idea was to have all of the actions use the same events for simplicity, but I can certainly see where a go-ahead timeout would be useful for those handful of actions.  (Adding it to `.wait(number)` might be breaking for users in the wild, though.)
 > I think this came from my personal angst that itâ€™s not an option with wait(selector|function)â€”where I do think there are clear use cases for different timeouts on different calls (bits of this PR have been hanging around in my git stash for a while).

Ah, I understand.  Wholly agree it makes sense for `.wait()`, but for `.goto()` ... I'm leaning toward "no".

> Maybe when loading a local page you might expect it to be fast and want to time out more quickly than when loading something from the web?

Mmm, _maybe_ - this feels a bit out in the weeds, though.  I say let's not complicate the method signature until it's demonstrably useful.  Thoughts?
 @Mr0grog I saw. :)  Doing my best to be thorough.

This looks good.  +1 to you sir.
  related: #593, #645, #646 
 Merging this conversation into #646.
  Looks like this issue is resolved, so I'm going to go ahead and close it.  If this is still a problem, feel free to reopen/submit a new issue.
  @RoryJShevin Can you post a minimum reproduction of this problem?  Also, what version of Nightmare are you using?

I've tried to reproduce this problem with a ~15mb and ~500mb page and cannot.
 Closing due to lack of information.  If this is still a problem, feel free to reopen/submit a new issue with a repro case.
  Related: #646, #593, #645
 Merging into #646, moving discussion for serializing errors/error handling there.
  > Right know it logs something like "Cannot read property 'blur' of null" when there is a not existing selector, would be great for next version to have additional info of the action and what triggered the error, etc :)

This part, however, dovetails with some of the other issues we've been talking about in #645, #646, and #593.  I'm on board for making events have more helpful errors.
 I'm going to merge this with #646.
  #644 needs to be pulled in first at a minimum.
 @LinusU It works fine with 1.0.x and (memory serving) 1.1.x, but some of the tests involving `webSecurity` break with 1.2.x.  I believe it's symptoms of electron/electron#5712, which have been fixed but as yet unreleased (at least with `electron-prebuilt`).  

I'm comfortable upgrading to a non-breaking version in the meantime, barring protest.  Thoughts?
 @albinekb This will get pulled into the next version. :)
  @Muyv Is this resolved?
  Hey Nightmare Team,

I still love the work you've been producing, but I've run into a few snags. With the old generator form, I used to be able to having intermediate steps in my promise or function that would check for specific conditions before failing or continuing. 

With the new promise format, I don't see a way I can do this, or perhaps I'm missing something.

An example might be:
- Go to a login page
- Check for a selector
- Type username and password
- Login fails
- Check for failed message, throw error.
- Take a screenshot to send with the error for debugging purposes

In the case of the new promise-based nightmare, the failure is just a timeout since I have yet to figure out a way to have an intermediary step.

Any advice on how I might be able to achieve this?
 Thanks @Mr0grog. I'll go and give it a try again. Thanks for your help.
 Hey @Mr0grog,

Sorry for opening this up again, but looking at the promise example, I'm not positive generators would work inside of it.

Here's an example based on your suggestion:

``` javascript
const Nightmare = require('nightmare');
const nightmare = Nightmare({
  show: true
});

function getCnn(resolve, reject) {
  return nightmare
      .goto('http://www.cnn.com')
      .wait(400)
      // selector that fails on purpose.
      .exists('.some-random-selector')
      // simple equivalent of what I'm attempting.
      // let c  = () => function* testTwo() { yield *function* test() { yield 1; }(); }().next();
      // this might only be possible with VO.
      .then((failed) => {
        console.log(failed);

        // definitely won't work in promise form
        // const image = yield nightmare.screenshot();

        // only way to get yield to work, sort of in a promise
        // still fails
        // const image = yield *nightmare.screenshot();

        // fun way of trying generators, but doesn't work either.
        // const image = function* getImage() {
        //  yield *nightmare.screenshot();
        // }().next();

        //console.log(image); // never printed.
      });
}

getCnn();
nightmare.end();
```

It's possible for my use-case that using the generator form may be better altogether because I have other actions that need to occur after `.then`, an example building off the original, 
- Login fails, fail and take screenshot
- Login success, go to the next page
  - do a few actions
  - take a screenshot.
  @atomless Is this issue resolved?
 Closing for inactivity, if this issue is still a problem feel free to reopen/open a new issue.
  First, the immediate problem: the way you're using `.evaluate()`, the function that accepts the body and sets `ctx.body` will be passed as an argument to the first function in `.evaluate()`.  Off the cuff, I think you want something like:

``` js
      nightmare
        .evaluate(function() {
          return document.documentElement.outerHTML
        })
        .run(function(err, body) {
          ctx.body = body;
          if (err) return done(err)
          debug('nightmare .run url: %s ; status: %s', ctx.url, ctx.status)
          done(null, ctx)
        })
```

Second, a question for you: have you seen the [Nightmare driver for x-ray](https://github.com/phulas/x-ray-nightmare)?  Would that work for your application?
  Duplicate of #625, closing.
  Another nit: your initial example also will only scroll until the page is 100000 px long, which is _big_, but "infinite" scroll pages could be longer.

> I want it to scroll down until the size of the returned document does not increase anymore. 
> How can I achieve this?

This is a **very** naive method to answer your question:

``` js
var Nightmare = require('nightmare');
var vo = require('vo');
var nightmare = Nightmare({
  show: true
});

var run = function * () {
  yield nightmare.goto('http://someInfiniteScrollPage.tld');

  var previousHeight, currentHeight=0;
  while(previousHeight !== currentHeight) {
    previousHeight = currentHeight;
    var currentHeight = yield nightmare.evaluate(function() {
      return document.body.scrollHeight;
    });
    yield nightmare.scrollTo(currentHeight, 0)
      .wait(3000);
  }
  yield nightmare.end();
};

vo(run)(function(err) {
  console.dir(err);
  console.log('done');
});
```

This approach has problems: when you're going against a page that [actually is an _infinite_ scroll](http://scrollmagic.io/examples/advanced/infinite_scrolling.html), the above will never end.  Also, the `.wait()` call could be replaced with waiting for the scroll element count to change to possibly reduce latency and increase robustness.

> Javascript kills me, in Perl this would have been so easy, but Mechanize::Firefox is outdated and very slow.

If Perl is your language of choice, you _might_ want to check out [Selenium](http://www.seleniumhq.org/).  I haven't personally tried it, but there is a [Perl port of the remote driver](https://github.com/gempesaw/Selenium-Remote-Driver).
  This looks great, adding to next release. :+1: 
  Outgrowth of #620.
 > Should probably document it clearly in the README, too. 

ðŸ‘ 

> To be honest, Iâ€™m not really sure what the compatibility requirement is.

We talked about it (I can't find the reference offhand either), and I believe we came to the consensus that Node 4+ was "official", but I _think_ everything will still work using 0.12.x with `--harmony`.
 > Node 4+ was "official", but I think everything will still work using 0.12.x with --harmony.

Scratch that.  Template strings don't work with <4.
 ... won't calls to [`.call()`](https://github.com/segmentio/nightmare/blob/master/lib/ipc.js#L72) fail, specifically when the emitter [gets a result](https://github.com/segmentio/nightmare/blob/master/lib/ipc.js#L87)?
 Totally fine!  :)  Just making sure my read of things was okay.
 > (Do we need to change ipc.js?)

I don't think so.  My stance is that it's _fairly_ reasonable to say that 4.x is a good minimum requirement.  What do you think?
 I'm almost 100% sure we had this conversation (or a very close approximation), but it's beyond my searching ability.  Now it's official in #653! ;)
  Are you running with `--harmony`?  I _thought_ fat-arrow notation was supported (with some caveats with respect to binding `this`) in Node 0.12.x.  Open to being wrong, though.

Node 4.x+ is recommended for Nightmare, but I see now that it's not listed as the engine in `package.json`.  (I also know that assertion had been made before, but it's not jumping out at me where.)
 I believe this issue has been resolved, closing.  If you continue to have problems, feel free to reopen/open a new issue.
 @dcshapiro What version of node and nightmare?
 @dcshapiro [Nightmare requires 4.x or higher.](https://github.com/segmentio/nightmare#node-versions)  See also #621.

I _think_ you might still be able to get away with using 0.12.x and `--harmony`, but your mileage may vary.
  I suppose you could use `.evaluate()` and use [`document.elementFromPoint()`](https://developer.mozilla.org/en-US/docs/Web/API/Document/elementFromPoint).  An untested from-the-hip example:

``` js
nightmare
  .goto(someUrl)
  .evaluate(function(x, y){
    document.elementFromPoint(x, y).click();
  }, x, y)
 //... other actions
```

... but that might not be granular enough for your application.  You could also initialize your own mouse event with a custom X,Y and issue it against the control at X,Y.  The [`MouseEvent`](https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent) docs may interest you.

If you wanted to get fancy, you could also write a plugin using Electron's [`webContents.sendInputEvent`](https://github.com/electron/electron/blob/master/docs/api/web-contents.md#webcontentssendinputeventevent) to send `mouseDown` and `mouseUp` events.
 According to the [`MouseEvent` constructor docs](https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/MouseEvent), at least in my naive read, `clientX`/`clientY` is relative to the client window, not to the DOM element (like it is for the readonly `clientX`/`clientY` on a caught `MouseEvent`).  What happens if you specify an absolute point?
 Scratch that, I'm wrong, [jsbin](http://jsbin.com/coxekatofe/1/edit?html,js,console,output) to prove it.

Based on that little experiment, what you have ought to work.  Out of curiosity, what happens if you instead issue a `mousedown`?
 > @rosshinkley do you have any idea why the click() (and mouseover/mousedown) action doesnâ€™t use sendInputEvent? Assuming no, since according to git, they pretty much appeared out of whole cloth, but asking just in case.

I _suspect_ it's because `sendInputEvent` wasn't a part of the Electron API when 2.x was initially released.  (The release dates differ by something like 10 days, memory serving.)  I also suspect that it worked Good Enough&trade;, so before now there hasn't been a real reason to change it.

> Seems like upgrading them to use sendInputEvent would be more â€œcorrect,â€ though it would change behavior slightly. (Maybe a good v3 change?)

I'd like to (like you) see more usage before making the change, but I also agree this feels much more in the spirit of "doing things as an actual user would", which is in keeping with the spirit of Nightmare.  Given that it seems to be causing enough problems, I'd be open to moving it into core.  Thoughts?
 Closing for lack of activity (and looks like this is possibly resolved).  If this is still an issue, feel free to reopen/submit a new issue.
  I suspect that DOMElement's parts are non-enumerable, and as such not crossing the IPC boundary.  In other words, it's not going to serialize well.

Fixing it is fairly straightforward: pluck the values you want inside of `.evaluate()`.  Say you wanted the question title and link:

``` js
var Nightmare = require('nightmare');
var startingLink = "http://stackoverflow.com"

var nightmare = Nightmare({
  show: true
});

nightmare
  .goto(startingLink)
  .evaluate(function() {
    var elements = Array.prototype.slice.call(document.getElementsByClassName('question-hyperlink'));
    return elements.map(function(element) {
      return {
        href: element.href,
        title: element.innerText
      }
    });
  })
  .end()
  .then(function(content) {
    console.log(content);
  })
```

Note that the use of `Array.prototype.slice.call` is deliberate: `document.getElementsByClassName()` returns a array-like object known as an [`HTMLCollection`](https://developer.mozilla.org/en-US/docs/Web/API/HTMLCollection).
 @albinekb Ah, true.  Thanks for pointing that out.
  After playing around with this and recreating the behavior, it looks like the [resource provider](https://code.google.com/p/chromium/codesearch#chromium/src/cc/resources/resource_provider.cc&sq=package:chromium&type=cs&l=458&rcl=1464366759) deep in the guts of Chromium uses the device limit (I think it's 8 or 16k in general).  This is important because that defines the maximum size of the rendering canvas, which defines the maximum size of the screenshot.  Anything larger and the texture management/WebGL parts start throwing exceptions.

Anything larger, unfortunately I think you'd have to start stitching parts together yourself.
  With Nightmare? No.  Nightmare is built to be run atop Electron.

If you're looking for a browser automation suite, [Selenium](http://www.seleniumhq.org/) is a fairly popular choice.  It's got webdrivers for most (all?) popular browsers.
  Possibly related: #238 and #405.
 @Mr0grog true.  The reason i roped #405 in as a "maybe" was because it didn't _always_ crash the process, sometimes it would hang with no useful info.  It's possible that was hitting two different problems.
 @JWMarchant For what its worth, you can specify a file descriptor with `DEBUG_FD`.  Something like: `DEBUG_FD=3 DEBUG=nightmare:* node myNightmareScript.js 3>output.txt`.  For completeness, could you also run with `ELECTRON_ENABLE_LOGGING=true` and `ELECTRON_ENABLE_STACK_DUMPING=true`?

Also, if I'm not mistaken, your source will run up to ten URLs together at the same time - the second parameter to `async.queue` is a concurrency parameter.  For log clarity, it might also help to set it to 1 (or remove it as the default is also 1). 
 > Ok, Iâ€™ve only gotten this to reproduce a few times, but it seems like the issue is well below Nightmare or Electronâ€”the HTTP request for the initial HTML content of the page never actually closes...

That... is not great and kind of scary.  That makes me wonder how Treehouse is being served, leading me to ...

> On the Electron side, we get response details for the beginning of the HTML and we get the dom-ready event, but we get no finish or failure events. Inside the browser window, document.readyState never moves from interactive to complete and the windowâ€™s load event never fires. Oddly, though, the DOMContentLoaded event does fire.

... which, also based on your previous comments, I agree that it might be the response not getting ended properly in all circumstances.  I don't know if that would cause the `readyState` to hang (or any of the other... side effects? you describe).  That should be easily testable, and seems worthy of at least a rough pass.  I also have a sneaking suspicion you may have given this a try already.  Thoughts?

If it is a problem with the OS/networking stack (seems unlikely, but certainly possible), I'd be curious to get a quick straw poll on who is using what and try to cover what is missing.

Moving on!

> Soâ€¦ Iâ€™m thinking the best way to address this is [consider `dom-ready` as acceptably complete].

In the spirit of Nightmare behaving as close to a Real Browser&trade; as possible, considering `dom-ready` + an arbitrary timeout (30s default + an options override seems like a good first pass, by the way) as success seems reasonable.  The page is still usable, and (ostensibly) can issue execution requests/interact with it.  However, I would feel much more comfortable if the hang could be reliably reproduced so tests could be propped up against it.
 > However, I would feel much more comfortable if the hang could be reliably reproduced so tests could be propped up against it.

That being said, _not_ a dealbreaker.  Would be nice to have if the hang could be produced reliably (and in a reasonable amount of time).
 This should have been fixed with #640.  Closing.
  As far as I know, you can't, at least not yet.  #235 covers it, and I don't think the `debugger` method has been tried/made into a plugin.
 Thank you @rosshinkley.
 Interesting. Thanks @lukehorvat.
 I wrote a [plugin](https://www.npmjs.com/package/nightmare-upload) that should give you the same ability as 1.x to add files to a file input.  As that should solve this issue, I'm going to go ahead and close this issue.  If this is still a problem, feel free to reopen/open a new issue.
  some quick thoughts:
- the chaining is primarily there to help it so you don't need to compile JS with babel or use co. this is sort of become less and less relevant, i think it's probably fine to just await or yield at each step. you'll probably get better performance when you do want to parallelize this stuff since right now you're stuck with the internal queue regardless of if you call these methods in parallel.
- can't you async/await now? nightmare implements thenables, which are basically lazy promises and should give you all the advantages of promises, without cluttering up your API with promise-specific syntax
- the prototype extension is really clean, but do you get a lot of advantages just using object with functions. if i have some time, i'd like to see nightmare move more towards this: https://github.com/matthewmueller/plumbing/blob/master/test.js, where you get a shared context (this) and can easily add tracers, logging, queueing (any other decorator) in user-land without cluttering up the fundamental actions of nightmare.  

i'm going to leave it up to the others to decide to merge or not, since i haven't been actively working on nightmare lately.
   Fixed in 2.4.0, closing.
  I suspect one of the selectors is causing an error.  What happens if you add a `catch`, like:

``` js
var Nightmare = require('nightmare');
var nightmare = Nightmare({ show: true })

nightmare
  .goto('http://yahoo.com')
  .type('input[title="Search"]', 'github nightmare')
  .click('#uh-search-button')
  .wait('#main')
  .evaluate(function () {
    return document.querySelector('#main .searchCenterMiddle li a').href
  })
  .end()
  .then(function (result) {
    console.log(result)
  })
  .catch(function(err){
    console.dir(err);
  });
```
  You're using `yield` outside of a generator, and I don't think that's legal.

Also, in your case, you don't need `yield` if you are using `.then()`.  At first glance, your source would probably work as expected if `yield` is removed.
  Redo of #600 to fix #599.  This method allows for synchronous version retrieval.

The only thing I'm not _real_ crazy about is the debugging of the version information.  That seems to defeat the purpose of using a lazy getter that props up the cached version values.  Thoughts?
 > Maybe not really necessary at all. 

I was heading in this direction, at least for this incarnation.

> Other note: if engineVersions is only available on a Nightmare instance, maybe no great need for execSync.

I'm kind of 50/50 on this.  I kind of like having the version property be a regular ol' synchronous property.  However, the fact that versions can change by instance makes me think maybe it should be a chainable like it was in #600 (although it would still need some naming and placement touchups).
 ... also to add another possible wrench to the mix, and maybe another point for the original incarnation, this will cause a process to never quit:

``` js
var Nightmare = require('nightmare');
var nightmare = Nightmare();
console.dir(nightmare.engineVersions);
```

... as the child process is started at construction time.
 For completeness, I've gone ahead and finished this PR with suggested changes.  However, in light of Electron versions being instance-dependent and the mere instantiation of Nightmare creating a possible "hang", I think it's best to re-open #600.
  Poking a head in:

> There was some brief discussion not too long ago (#502 (comment)) about whether it would be useful to do this automatically, but I donâ€™t know that itâ€™s gone anywhere.

I've been working on this off and on, but hit a snag with `Xvfb` not reliably stopping when Electron stops.  Still in the works if I can get it working properly.
 The following adapted from the example works on my headless box:

``` js
var Xvfb = require('xvfb');
var Nightmare = require('nightmare');

var xvfb = new Xvfb({
  silent: true
});
xvfb.startSync();

var nightmare = Nightmare({
  show: false,
  webPreferences: {
    partition: 'custom'
  }
});

nightmare
  .goto('https://google.com')
  .evaluate(function() {
    return document.title;
  })
  .end()
  .then(function(title) {
    console.log(title);
    xvfb.stopSync();
  });
```

Is that what your modification looks like/what you're running?

A couple of notes:
- Nightmare construction must come _after_ the Xvfb start.  (It did here, but it's worth pointing out it's a requirement.)  The Nightmare constructor automatically starts Electron and Xvfb should be running prior to that.
- This log line: `electron:stderr Xlib:  extension "RANDR" missing on display ":107"` makes it look like you might have other instances of Xvfb running.  I've had Electron get a little flaky with multiple instances running (_usually_ with regards to problems described in #561).  Might be worth a `killall` or a reboot to have a fresh start.
 That's .... baffling.  @yoz might have been on the right track, but the suggestion there looks like it would work for npm2, not npm3.  If you look at `node_modules/electron-prebuilt/dist`, does `electron` exist there?

I'd also be curious if you explicitly installed `electron-prebuilt` and/or explicitly set [`electronPath`](https://github.com/segmentio/nightmare#electronpath) if that might have any effect.
 @paulintrognon You might want to take a look at #224.  The short version is that Electron requires a framebuffer to render, and when you're running headlessly on Linux, running `Xvfb` satisfies that requirement.
 If you run with `DEBUG=*`, Electron _should_ fail with helpful messages telling you what binary is missing, which should let you figure out what package needs to be installed.  I suspect you're missing libxss or libnotify.

I'm going to go ahead and close this issue.  If it crops up again, feel free to reopen/open a new issue.
  It should.  Are you having a specific problem returning an object or array back from `.evaluate()`?
  Quick attempt to address #599.
 Reopened with suggestions from #604.
  Could the information be captured during the `app.on('ready')` handler and piped up as part of the response there, then attached to the Nightmare instance inside of the instance construction sugar?  That would negate the need for extra calls, and that uses a trip that's already being made, so we get version info for (almost) free.  Thoughts?
 Although... that would mean the version info is not immediately available like you might expect.  It'd only be available after Nightmare has entered a ready state, like it would prior to executing a chain.  I was trying to get away with _not_ having a `.version()` (or similar) method, but now I'm not sure that's particularly feasible.
 I think I still prefer exposing _some_ way of getting the versions programmatically, and I can't think of a good method for doing that without an explicit method that doesn't require side-effect-y stuff.

That said, adding a debug call for the versions on `ready` is probably worth doing and will cover most (probably an overwhelming majority) of cases.
 "Fixed" in 2.4.0, closing.
  For the double size: this has to do with high-resolution display.  Viewport dimensions are in browser pixels, not device pixels (thanks to @Mr0grog for pointing out the difference).  For more information, read  [the bottom of #498](https://github.com/segmentio/nightmare/issues/498#issuecomment-189156529).

For the proportional scaling, I'm not sure.  It might be symptoms of the same quirk.
  https://github.com/electron/electron/blob/master/docs/api/app.md#appcommandlineappendargumentvalue

List of arguments:
http://peter.sh/experiments/chromium-command-line-switches/
 I'm okay with this change.  Would you mind adding to the readme to cover the option and where to find Chromium switches?
 done
 @yotamlaufer Awesome, thank you.
 With please. I love nightmare!
  It will be really useful to set chromium arguments, allowing tweaking of the runtime.

https://github.com/electron/electron/blob/master/docs/api/app.md#appcommandlineappendargumentvalue
 https://github.com/segmentio/nightmare/pull/595
  I'm not sure where to put this, and I'm open to this being moved to a Wiki if that makes more sense.  In the interest of having all of the big (and possibly breaking) features/nice-to-haves for the next big release in one spot:
- Native `iframe` support and management - #203, #496
- Multiple window management support (including popups) - #352, #510 
- ~~IPC safety - #493, #579~~ 
- Queue safety - #493, #239, #522 (and many, _many_ more)
- Actions with selectors waiting on selector prior to executing action - #388
- `.goto()` optionally returning after `DOMContentLoaded`
- Reduce plugin function complexity

There may be a need for:
- An upgrade guide for users
- Splitting up the documentation (akin to how Electron has it)
- A semi-formal statement of ongoing support for 2.x for some period once 3.x is finished

Nice to-haves:
- Manipulating elements with custom predicates - #867 

What have I missed in features, needs, or linked issues?

_edit:_ added element  IPC safety will likely make it into the next release of Nightmare.
 > #596 makes me wonder if changing viewport() to actually set the viewport (as opposed to window) size would be a good breaking change for v3.

Hm, how are you planning on doing that?  Using `window.outerWidth` and `outerHeight` and then adding the difference?  (I don't remember being able to set the viewport directly, but I'm probably wrong.)

> Maybe have goto return as soon as a page is loading so you can execute scripts ASAP during load?

To what end?  Should `preload` be extended (or pluggable) instead?

> Have actions with selectors wait for the selector before doing the action (#388). Capybara (Ruby), for example, does this. It could possibly be configurable (though I think youâ€™d want opt-out rather than opt-in).

Fully on-board for an implementation of #388.
 > I think just calling window.setContentSize() instead of window.setSize()

Of course.  Y'know, I've read the `browser-window` docs a zillion times and forgot about `setContentSize`.  Maybe I need to read it a few more times.

> I think I was thinking so you could get in as early as DOMContentLoaded or maybe before other scripts, but maybe specifying preload stuff somehow would be better. 

I was pondering out loud, and now I'm wondering if plugging preload is a good idea.  I think preload is executed prior to every page load, in so doing losing a bit of control - there are probably situations where you want to run a given script on a given page's load.

I doubt I'm thinking about it the way you are: what would you suggest as API changes?  It seems like you're advocating having a navigation setup method and a navigation method - am I anywhere close to being on the same page?
 I've been tinkering with the idea of changing the Electron part of `.action()` to wrap the ambient `require`.  The function signature is ugly: `function(name, options, parent, win, renderer, done)`.  Changing the `.call` in the `action` handler from:

``` js
.call({require: require, parent: parent})
```

...to something more like....

``` js
.call({
  require: (lib) => {
    if(lib==='nightmare-plugin') {
      return {
        name: name,
        options: options,
        parent: parent,
        win: win
      };
    }
    return require(lib);
  },
  parent: parent
})
```

... which would make the handler signature be `function(done)`.  Also, dropping the `renderer` as I think it could be `require`d.

I realize wrapping `require` is also kind of ugly and probably unadvised, but I thought I'd float it out.  Thoughts?
 > I have had to look it up in the README literally every single time Iâ€™ve needed to use it

Me too.  And I _wrote_ the [expletive redacted] thing.  I'm going to go on a limb and say it's the most unwieldy part of Nightmare, and humbly apologize.

> But why not just make those variables ambiently available in the pluginâ€™s closure instead of wrapping require?

It's certainly easy to do, but makes where those variables came from kind of opaque.  The less it seems like magic, the better.  (Using `require` only makes this marginally better, I realize.)

> Or, barring that, have plugins take two args: an object with all the things ...

The options hash was [frowned upon](https://github.com/segmentio/nightmare/pull/425#issuecomment-169736725) in the orginal incarnation.  I wouldn't be totally against it (provided it has a descriptive name), but `require` seemed to satisfy both the "no options hash" and the "this function signature is _impossible_ to remember" demi-requirements.
 > My use case is basically: â€œI want to click this button and I donâ€™t care whether images have loaded yet.â€

That's what I was guessing, and that would be awkward to cram into preload.  That's why I walked it back.  I'm not sold that plugging preload is a _bad_ thing necessarily (having to redefine all of the machinery for `console` et al is not a great solution, either), but not going to solve what you had in mind.

> BUT the more I think about it, that makes a lot of things more complicated...

This is what I was thinking, but I thought maybe there was an obvious part that I had missed.  (I have a penchant for overcomplication.)

> A possible alternative might just be to add an option to goto asking it to return as soon as the HTML is loaded, but keep the default behavior the same. (e.g. goto('url', {waitForResources: false}))

I'm trying to think of countercases, and while I can think of instances where not waiting is silly, they are still valid use cases and I _think_ would behave properly.  (Eg, `.goto(myUrl, {waitForResources: false}).wait('.mySelector')` where `.mySelector` is added by the client.)  At first blush, this is a reasonable approach.
 > Generally: have every action return something? In a similar vein, be better about errors. 

Can't +1 this enough.

> maybe a subtype, like NightmareError or something

That's something I had not considered, but the idea is certainly appealing.

>  so probably requires an audit of all existing actions first (if it seems like a good idea)

This is probably worth doing.  Added #646.
 @overflowz The main holdup right now is that `preload` is not honored by windows not created by instantiating a new `BrowserWindow` internal to Electron, specifically with `window.open()`.  See electron/electron#2605.

I haven't dug into it, but it _might_ be skirted with some `preload` magic on the main Electron window.  At the time, it felt like an _awful_ lot of work for something that might end up getting fixed.  @trusktr did @Mr0grog's suggestions work for you?
  This is a case I would not have thought of.

> Also worth noting: we donâ€™t handle errors especially well this way. Itâ€™s not any worse than before, but I wonder if calling `goto('javascript:notAnActualFunction()')`  should return error instead of success...

Oh man.  _My eyes._  I hadn't considered this case, either.  I'd be curious to see a proposed implementation for supporting rejection of bad `javascript:` links.
 (At any rate, +1.  This will be included in the next release.)
  Hm.  I've seen similar screwball failures on Circle, even with the `xvfb` patch.  I don't know if that's still the cause, but it may be worth another look.
  This came up in #558, and I'll quote @Mr0grog:

> Soâ€¦ it would be a very bad idea not to exit the process at this point. Electronâ€™s underlying IPC machinery is now in a bad state, so further communication between the your node.js process and the â€œbrowserâ€ is not reliable.

I'm wondering now is if instead of exiting, the Nightmare instance should be put into an error state where any further calls would cause exceptions as the IPC parts are no longer reliable.

All of that being said: uncaught exceptions are bad.  Why not add handling for the exception?
 Fixed with #589.  Closing.
  Fixes #421, at least in part.

Open questions: 
1. Should Nightmare override the environment variable for `ELECTRON_ENABLE_LOGGING`?
2. Should the `nightmare:` namespace be on the debug calls for Electron?
 > It gets pretty verbose if you turn it on. Better to leave that up to a user, I think.

My thoughts too.  Thought I'd float it just to make sure there wasn't something I missed.

> Iâ€™d say nah to this, too, but I donâ€™t really have any good reasoning or a strong case for it.

The best (and possibly only) reason I'd be in favor of leaving it prefixed with `nightmare:` is to maybe simplify `DEBUG`.  However, with your test to catch deprecation warnings, I'm not sure there's a case to be made.
  This looks great.

This went in a different direction than I had thought, though.  Not sure if this is the best place for this conversation, but here goes: something I had been thinking about was wrapping the Electron instance stdout and possibly stderr up with calls to `debug` (rather than piping them straight through to the parent process stdio).  Then I started thinking about possibly having log levels and _maybe_ introducing something slightly more complex than debug like [winston](https://github.com/winstonjs/winston).  Thoughts?
 > I generally like that idea, but the place for it is probably #421.

Good point, I'll move it there.

> As for this PR, I thought it was valuable to programmatically examine stderr for these warnings so we could explicitly cause tests to fail...

I'm realizing now I might have been unclear.  I completely agree, evaluating stderr output for deprecation is a good idea.  I like having them collected and deduped for the end.  And ...

> Since Electronâ€™s stdio are just streams, thereâ€™s no reason we canâ€™t pipe them to multiple places if we want to. Doing this shouldnâ€™t get in the way of piping to debug or some other logging tool.

... was kind of what I was driving at: we can get both, and it might be worthwhile to do so.  I just blanked on #421.
 Totally fine. :)
  Looks good.  Thanks!
  Judging from your example, it looks like you're queuing the `.goto()` action but not executing it.  What happens if you modify your example to something like:

``` js
var nightmare = Nightmare({});
nightmare.goto('http://website.com')
    .evaluate(function () {
        return document.querySelector('#url').href;
    })
    .then(function (url) {
        return nightmare.goto(url);
    })
    .then(function(){
        //nightmare should be at the url from evaluate
    })
```
  > The progress capability is neat, but it incurs a lot of additional complexity and Iâ€™m not sure how much real value it adds. No existing actions use anything like it.  If we keep it, should be a stream instead of a simple emitter?

I'm mixed on this, but I can think of applications where this might be useful.  For example, a similar concept is used in the [download manager](https://github.com/rosshinkley/nightmare-download-manager) to look at download state out-of-band.

> This implementation differs slightly from the initial proposal in #493â€”it is intended to be backwards-compatible (so it doesnâ€™t break plugins). Iâ€™m not sure if that a virtue or unnecessary, since plugins that can run in the Electron process are pretty new.

My first off-the-cuff idea would be to wrap `.on()` and/or `.emit()` to warn of safety concerns when it is used in plugins (although I can think of situations where one might want to manage events themselves).  What change were you planning to propose that would break plugins?

Also, while I have in interest in how plugins are implemented as I have authored a few, [I don't think I'm the _only_ author](https://github.com/segmentio/nightmare/issues/319#issuecomment-208243666).

> You only get to have one responder for a given name. I think thatâ€™s reasonable (what would you do with more??), but not sure if itâ€™s worth adding some logging or throw errors if respondTo is called with the same name more than once.

I'm struggling to come up with a usecase for more than one responder.  I would think responding to a given event twice would constitute a runtime error.

> Thereâ€™s no way to unregister a responder. Iâ€™m not sure we need it, but maybe?

Maybe.  You could be explicit about unregistering a responder before registering a different responder for the same action, eg if you wanted your plugin implementation of `.type()` to override the default.  (Overrides at present have no consequence, at least in my naive reading.)

More as I let this marinate and as others chime in. :)
 > ... but it does make me wonder if thereâ€™s room for some sort of more abstract create-a-ipc-sub-channel mechanism. That would probably have some utility in the single-electron-process model described in #561. Probably out-of-scope here, though?

I figured the single process model would have to have another identifier in `.call()`/`.respondTo()` (or `.on()`/`.emit()`) for which `BrowserWindow` the action was intended for. That could be pretty readily abstracted away for ease of use.  Am I anywhere close to the same page?

That said, it's probably out of scope, but it does feel like process management/window management is going to depend on this change.  (Or at least borrow from it heavily.)

> I feel like on/emit still have a lot of value for sending events or event-like messages. As far as built-in stuff, I think thatâ€™s just event forwarding from the browser window and logging from the Electron process.

Fair, maybe a warning is too heavy-handed.  I don't necessarily disagree, but it does seem like a raw `.on()`/`.emit()` pair is dangerous enough to warrant... something.  Would this be better served as a (eventual) writeup on how to manage events yourself in nightmare-examples?

> I think I mistyped it on the issue thread, but I was originally thinking of replacing emit/on with call/respondTo instead of having differently-named methods.

Ahhh, okay.  I understand.

> So do you think it should throw an exception? Or maybe just log a warning?

I want to say exception, but I'm not sure I can make a case.  In my read of your implementation, I don't _think_ you can cause execution problems as the results are executed with `.once()`, which makes me think warning.  On the other side,  I think that >1 response is errant behavior, shouldn't happen, and as such should be dealt with as an exception (if nothing else to catch silly stuff during testing, which is what's tipping me - but only just - toward exception).  Is there a valid case where a `.call()` will have more than one response?
 @Mr0grog Good.

I'm considering opening a branch off of master for v3 parts.  Would you be willing to complete this PR and put it against that branch?  Thoughts on doing such a thing?
 > Sure? Whatâ€™s â€œcompletingâ€ meanâ€”just wrapping up the rest of the built-in actions?

Yeah, that's what I had in mind - rounding out the rest of the existing methods with the IPC safety is sufficient for now.  (The beauty of source control: we can always change it later.)

> Generally Iâ€™d flip it around and have master be current development (e.g. v3) and have a v2 branch for any additional 2.x releases.

I've seen this done a _lot_ of different ways, and all seem to be about equally as effective.  I had no _real_ reason beyond releases being cut from the master branch and that PRs are probably going to continue to come to the master branch.  There also seems to be artifacts of a historical precedence from the v2 stuff for Electron being done in a separate branch, but my research there is cursory at best.

I don't have a problem with changing that, even if it adds near-term work for existing PRs/merges.  

> But Â¯_(ãƒ„)_/Â¯ all good either way.

100% with you.  I'm not compelled one way or another.  If you've got a good reason, we can do it how you suggested.  Or not.  You know, whichever. :)
 I _think_ we agreed that since this is non-breaking, this should go into 2.4.x.  To that end, I think it should go into this PR => master.
  This is a problem with Electron: electron/electron#5180

Related: #563, #572, and an attempt at fixing in #576.
 Should be fixed with #588.  Closing.
  > Electron has a potential crasher (on OS X, at least) when the devtools are open:

It's happening on my Debian-based Linux boxes too.  I should also mention #578 - I think it's symptoms of the same problem.

> Theyâ€™re still valid, but no longer a good canary for the crash this PR is mainly about preventing. Should I roll them back?

Uh, I guess so.  Is there a reason to keep the changes?
 The crash test isn't causal, making the argument for leaving it as-is kind of weak.  Plus, the speed benefit is nice.  But not having _any_ way of catching the crash also seems silly.  I wish there were a better way of explicitly causing the crash.

I am still on the fence, but tipped toward inclusion.  This problem seems important enough to merit _reasonably_ quick attention from the folks at Electron, so I imagine it will be addressed fairly quickly.  Thoughts?
 That's good.  Great, even.  Faster tests make for happy tests.

As for stripping out the sender, I'd be pretty okay with that.  I've never found it _particularly_ useful outside of having the `browserWindowOptions` barfed out with every event, and those could be sent in a one-time debug message.  And I'm not sure _that_ is even necessary.
  > run is not documented, itâ€™s not the â€œofficialâ€ API, and nothing internal ever calls it except end.

At the possible expense of being "that guy," `.then()` uses [`.run()` internally too](https://github.com/segmentio/nightmare/blob/master/lib/nightmare.js#L357).

> I can see a lot of value in simply canonizing a thing lots of people seem to be using.

Adding some historical context:  I believe the PhantomJS implementation [used `.run()` to execute the Nightmare chain](https://github.com/segmentio/nightmare/tree/1.8.2#runcb).  I would hazard a guess that a fair number of things out there were either developed against 1.x or were developed looking at examples from 1.x.

> ...  so I think I lean towards deprecating run.

Making `.run()` a method that wraps an internal `run()` method with some deprecation warnings would be something I could get behind.  Thoughts?
  Closing as this as like @Mr0grog said, that isn't _really_ what Nightmare is intended for.  There may be a future where this is doable, but not for now.  This change affects `.wait()` as well as they share the same template.  Would it be worth adding a `.wait()` test for promises as well?

As for the failing tests, I issued a rebuild and it appears to have succeeded.  I think your PR was after 2.3.2 was released, so the `xvfb` fix _should_ have been included.  Beyond that, I'm not sure why the tests are failing, might be worth another look if it happens again.
 @lzrski Off the cuff, I'd say have the Nightmare process to wait for the promise to be settled, yes.

If it's rejected, I'd think it should handle it like `.evaluate()`: bubble the rejection all the way up.  A failure is a failure.  Thoughts?

As for the fulfillment value, I think it should work like how `.wait(fn)` works - the waited-for value should resolve to `true` to stop waiting.  Fortunately, you've already written the plumbing to do this.  All you _should_ need to do is write the test.
 > I looked at existing test cases for wait and I think we have a problem here. They are not really testing anything. There are no assertions there. 

What would be asserted?  `.wait()` doesn't have a return/resolution value (what would it return?), so there's nothing really check against.  The existing tests verify that wait eventually returns and doesn't except.  In that regard, they're safeguarding from errant behavior.  The tests _are_ missing expected failure tests, though.  I can add that to my todo if you'd like. 

> Further more following test case executed in current master passes immediately instead of timing out:

Hm, this appears to have something to do with `it.only`, and I suspect it's a problem in `mocha-generators`.  On my local instance leaving it with `it`, the 10s `waitTimeout` default is hit.
 `it.only` problem with mocha genators is confirmed.  See vdemedes/mocha-generators/pull/4.
 I'm not against that sort of test.  I was thinking more on the lines of rejection testing, which would also catch the problem you've outlined.  Off-the-cuff, something like:

``` js
if('should error on timeout', function(){
  var nightmare = Nightmare({waitTimeout:500});
  return nightmare.goto(fixture('navigation'))
    .wait(function(){return false;})
    .should.be.rejected;
})
```
 :) I'd say both are reasonable additions.
 Rereading your submission, I spotted something I'm shocked I haven't (and no one else has) spotted.  Having `.wait()` support asynchronous methods _might_ not work as expected.  Consider something like:

``` js
nightmare
  .goto(someUrl)
  .wait(function(){
    return new Promise(function(resolve){
      //what if promise internals take a while to process?
      setTimeout(resolve, 60000);
    });
  });
```

... would not cause a timeout as the current version of Nightmare to timeout as written.  Wouldn't that cause `waitTimeout`/250 (the tick length) iterations of that promise to run instead of timing out after `.waitTimeout` waiting for the promise?  In fact, now `.wait()` won't time out until (`waitTimeout`/250)*execution time + `waitTimeout`.  This is not good.

Some off-the-top-of-my-head solutions:
- Some sort of watcher method that tracks time elapsed instead of tracking it internal to `.wait()`
- Split the templates for `.wait()` and `.evaluate()`, pass the timeout down to `.wait()`, and have the template source send back an error message if the timeout is hit.
- Leave it as-is.  I'm worrying too much.

Thoughts?
 It occurs to me that this problem exists now.  Consider:

``` js
nightmare
  .goto(url)
  .wait(function(){
    while(true){ }
  })
  ...
```

... or any long-running synchronous loop.  Same problem, slightly different cause.

> Splitting the templates doesn't seem compelling. 

I've thought about this a bit more, and realized that pushing the timeout responsibility to the evaluated client script is not a good idea as then the timeout is at the mercy of the client page.  This could lead unintended behavior if the client page clears timeouts.  (I was shooting from the hip.)

> Shouldn't we have a timeout for .evaluate just as well as for .wait?

An evaluation timeout seems like a reasonable addition, so long as the default behavior is the current behavior.

> Just not sure where this logic would fit.

I'll have to think about it, but I _think_ the most logical spot would be actually the `javascript` listener in `runner.js`.  That buys both `.wait()` and `.evaluate()` timeouts.  I'd have to play with the source to determine feasibility, though.

> Couldn't simple setTimeout be used?

Depends on what you mean.  The `.wait(fn)` and I believe `.wait(selector)` methods poll the client page every 250ms to determine if something has changed (eg, something is added, or a DOM element changes color).  I don't think you're proposing simply waiting `waitTimeout` and checking at the end, but if so, that would not be a good idea.

If you are proposing having a `setTimeout` handle the error case where `waitTimeout` has elapsed (and I believe you are, correct me if I'm wrong), that's a good idea.  That may be the best approach, it's then a matter of where to implement it.
 Reimplented and fixed in #819.
  @lzrski I have also been having problems with Nightmare + devtools options spontaneously flaking.  It looks like a segfault internal to Electron, just like #563.  I'll have to carve out some time to see what the details are.
 @Mr0grog Thank you for putting in the legwork.  Hopefully that electron issue will be resolved soon.
 Should be fixed with #588.  Closing.
  @mxmz- Are you still having this issue?
 Hm, that might be related to #602.
 @mxmz- Did you get this resolved?
  Using a room pointed at my fork as an interim solution until Segment can fix separation of internal/external concerns.  Fixes #272.
 @fritx As I understand it, the internal projects at Segment are all kind of lumped together under the `segmentio` account.  To prevent possible security problems, and to avoid [permission issues](https://gitter.zendesk.com/hc/en-us/articles/200178971-You-want-write-access-on-my-private-repos-Are-you-insane-), we'll be using the room for my fork for the time being.  There is work being done at Segment to get the public and private repositories separated.  When that is complete, I'll have the account owner create the gitter room for this repository and transfer the history.  That way we won't lose anything.

Make sense?
  > From this it looks like I can't just return a DOM element from the page context? If that's the case, can you explain to my why? Does it have to do with the magic of distinguishing the script's runtime from that of the page?

`.evaluate()` executes in the page context, and I believe the return value is stripped down to primitives for transport over an inter-process channel.  If you need properties from the element, you'd be better off returning the property or returning a projection.  For example (snipped for brevity):

``` js
    .evaluate(function () {
      var element =  document.getElementById('hplogo');
      return {
        src: element.src,
        height: element.height
      }
    });
```

It really depends on what you're trying to accomplish, though.  Why do you need the DOM element in the calling process?

> What is that weird object with the __jsaction property?

That's a good question.  Judging from the minified JS on google, it looks like it might be a container for attaching custom actions to the image (like a Doodle, for example) directly added to the DOM element.  That's a wild guess, though.

> Somewhat unrelated question; if I don't call process.exit() in the final callback, the script just hangs. Can you explain why?

The `.end()` call is queued but not run.  Try changing:

``` js
.then(function (_height) {
  height = _height

  n.end();
})
```

to:

``` js
.then(function (_height) {
  height = _height

  return n.end();
})
```

... and I think you'll have better luck.  Returning the Nightmare `then`able ensures the chain is executed.  It also might interest you to go read #546's thread on `.end()`.
  Changes the makefile to run tests under an `xfvb` wrapper called `bb-xvfb` under one or more the following conditions:
- `make test` is executed on CircleCI.
- `make test` is executed on a box where `xvfb` is running.
- `make test` is executed in an environment where the `HEADLESS` variable is set and not equal to `1`.

(Disclaimer: my ability with GNU Make is pitiful, any pointers on how to make the Makefile better would be appreciated.)

The wrapper enforces starting `xvfb`, waiting for an X server to be ready, followed by starting `dbus` for IPC messaging, followed by your command.  In the case of `make test`, the unit tests are executed.

The original problem is explained in [Chromium bug 309093](https://bugs.chromium.org/p/chromium/issues/detail?id=309093), and I found that the [Protractor](http://angular.github.io/protractor/#/) project (an Angular test automation suite that uses a Chrome WebDriver to run tests) already had hit this problem.  The scripts used are ~~plagiarised~~ borrowed from [angular/protractor#2419](https://github.com/angular/protractor/issues/2419#issuecomment-156527809).  (Thanks to @tullmann for providing the fix.)

This PR should fix #561.

Thoughts?
 @Mr0grog Ah, that's no problem.  I pulled it in because I was getting frustrated with documentation-only PRs failing in CircleCI.  Irritation-driven acceptance is a thing, right?

Kidding aside, that's not a bad call.  I'll put it on the list. :)
  At first blush, I'd say it looks like the window and/or web contents have been closed or destroyed before the actions were complete.

Could you provide a minimum test case that reproduces this behavior?
 Hm, I'm not getting the same behavior.  Your script seems to work.

I had missed the interrupt key in your original output: did Nightmare hang?  If so, are you running Nightmare headlessly under `xvfb`?
 @silenceisgolden Can you upgrade to 2.3.4 and see if you're still getting this issue?  I wonder if it has to do with #375 or possibly #553.
 @JWMarchant @misbach @Mr0grog for what it's worth, #640 has been released with 2.5.0.
 #640 is merged, #612 is closed, and it seems like @catblade's issue is resolved, so I'm going to go ahead and close this issue.
  Hm, that's one of mine, and I should have added unit tests for it.  I'll add that to my list.

What bothers me about your particular case is the "exited with code null" bit: The only time that happens (at least that I'm aware of) is when a segmentation fault occurs in Electron.  Could you provide a minimum case that reproduces the issue?
 Suspicion confirmed, this is a segfault internal to Electron that appears to happen with the version of Electron Nightmare is currently on.  It does not happen with the current version of `electron-prebuilt` (0.37.5 at the time of this comment).  Curiously, electron/electron#4103 is the closest problem I can find in the repository.  It's not exactly the same thing, but the symptoms are very similar.

At any rate, I'll put together a PR with the requested tests and a version bump.
 @lunow if that's true, it's likely got a different cause.  Could you open a new issue with a minimal reproduction case?
  Closing for age and it looks like the outstanding questions have been answered.  If you are still having problems or have additional questions, feel free to open a new issue.
  I wasn't sure where to put this - a new issue felt the most logical.

Digging into the test failures that happen intermittently, it looks like the behavior that causes the tests to fail also will present in regular applications (albeit seemingly not as often).  Consider the following (extremely contrived) case:

``` js
var Nightmare = require('nightmare');
//create a fake url payload for serial execution
var urls = [];
for (var i = 0; i < 500; i++) {
    urls.push('http://localhost:7600/navigation');
}
//go to each url, and then end
urls.reduce(function(accumulator, url, ix) {
    return accumulator.then(function(results) {
      console.log(ix);
      return (Nightmare())
        .goto(url)
        .end()
        .then(function() {
          console.log('results');
          results.push(ix);
          return results;
        });
    });
  }, Promise.resolve([]))]
  .then(function(results) {
    console.log('done');
    //console.dir(results);
  }).catch(function(){
    console.dir(arguments);
  });          
```

This example creates a _lot_ of instance churn, causing Electron instances to be spun up and killed, much like how the unit test suite works.  After running many times (I've had it happen in as few as 8 and as many as ~450 iterations, seems to be luck of the draw), Nightmare will hang.  In a test context, this will cause Mocha to timeout, which at least partially explains the behavior with the intermittent test failures.

The hang appears to happen when a new `BrowserWindow` instance is created.  Enabling `ELECTRON_ENABLE_LOGGING` and `ELECTRON_ENABLE_STACK_DUMPING` doesn't yield useful information.  Piping Electron output directly to the parent process `std*` buffers also doesn't yield anything terribly interesting.

What I'd like to try next:
1. Try to get `node-inspector` working with Electron.  So far, my attempts to get a debugger attached have been met with limited success.
2. Create `BrowserWindow` churn natively under Electron to see if the behavior can be recreated internally to Electron.
3. If that doesn't hang, I'll take a look at creating browser churn with a simplified node process -> electron process.  That should help narrow things down.
4.  If all else fails, I'll try to make a custom Electron build to try and figure out what's going on.

I'm open to suggestions and ideas on all points.

---

Some other peculiar (possibly unrelated?) things that cropped up as a result:
1. The event forwarding method _always_ throws an error after the `.kill()` call is made because the window is destroyed.  I'll be pulling together a small bugfix for that as time permits.  (I don't think it has any bearing on how the rest of the project behaves, but it certainly can't hurt to fix.)
2. The `close` event case for a clean exit never happens unless `win.close` or `win.destroy` are manually called.  In other words, you'll never see [`electron child process exited with code 0: success!`](https://github.com/segmentio/nightmare/blob/master/lib/nightmare.js#L70-L76).
 Quick update: I was going through the CircleCI documents to make sure the above wasn't caused by something silly.  Per the [documentation](https://circleci.com/docs/environment/), CircleCI uses `xvfb`, same as the chroot I was using to recreate the issues on.  For grins, I fired up `xfce` on that chroot to run it under a "real" X client, and could not recreate the issue.  It works the same as on my main Ubuntu development box, and it seems to work on pretty much everyone's machine.

To that end, I think this might be `xvfb`-specific.  Anyone else having hanging problems with `xvfb`?
 Now that I know what to look for, if I'm reading this correctly, the Chromium team [has already hit this](https://bugs.chromium.org/p/chromium/issues/detail?id=309093).  It appears to be an issue with forking and a memory allocation deadlock in one of the underlying libraries.

I'm going to take a swing at a workaround.
 Consider the time spent. :)

I've got a fix working locally: I can churn through hundreds of instances and finish without a problem - a huge improvement over the average failure point of a dozen or two.  I also still need to verify CircleCI will use my patch to execute tests.  Once I'm reasonably confident that's working, I'll open a PR for review.

By the by, the fix opens up an avenue of problems having to do with #502.  That's _probably_ a topic best left for that issue or for the eventual PR, and I'll be doing a writeup in one of those spots at some point.

This isn't _necessarily_ a resource problem.  Having more memory or a faster CPU would likely mask the problem, but wouldn't eliminate it entirely.  It has more to do with the underpinnings of `xvfb`, how resources are requested, and how IPC messaging is done internally to `xvfb` and `glib` (at least, that's my tentative understanding).

_(Warning: this thread is about to go offtopic.)_ 

That said, I _completely_ agree with you: spinning up multiple Electron instances gets resource-intensive in a hurry.  I also agree that Nightmare should probably be what amounts to a `BrowserWindow` manager - at least, I think that's the kind of direction you're heading in.  (I also seem to remember you making a similar comment elsewhere, and can't find it offhand now.  It's been something I've wanted to talk to you about since I saw that.)

That approach has a couple of small hurdles:  
- The first `BrowserWindow` Electron opens has a special property where if you close it, the whole process dies.  I don't know if this "master window" property is transferable (nor do I know what it's appropriately called).  The Electron process + first browser window would likely need to be protected until `.end()` is called, so that's easy enough to sidestep.  
- Whatever the approach, I would argue it would need to be compatible with the current test suite.  
- Constructing Nightmare-compatible `BrowserWindow`s would probably need to be broken out into its own class, somewhat similar to how you implemented `FrameManager`, and a similar class in the calling process will probably need to be constructed.  
- I'm betting you had parallel execution in mind as well, which makes the problems in #493 all the worse.

I'd also have a couple of questions:
- Do you think Nightmare should return back Nightmare-side instances of `BrowserWindow` (or `NightmareBrowserWindow`?) to perform tasks?  I'm asking to try to get my head around parallel execution.
- What's an acceptable maximum of `BrowserWindow`s that can be open?  How does that memory footprint differ?

That's all I can think of off the top of my head.  I'm willing to dig into the above and start working through some of the implementation bits as time permits.

Thoughts?
 PS: the comment I couldn't find?  I just found. _Of course_ the second I say I can't find it, I happen to spot it.  It's buried in the [middle of #553](https://github.com/segmentio/nightmare/pull/553#issuecomment-207080667).
 > Iiiinteresting. All :ear::ear::ear:

TL;DR: Make isn't the friendliest thing to Windows.  There's a night sunk into VMs and tinkering that I haven't had time to do yet.

> Oh, totally; didnâ€™t mean to imply it was! Just that our heavy resource use probably exacerbates :grimacing:

It aaaaabsolutely does.  The results I get under chroot on my Chromebook (4gb of ram with a Tegra K1 processor) vs my main development box (16gb/i5) are pretty different. :)

> Interestingly, the default_app installs a handler for the window-all-closed event that shuts down the application!
> Who knew? (Not I.)

Hhhhhuh.  The more you know. :stars: 

I had seen the event before, but I hadn't realized that Electron internally deals with it in that way, and the documentation is ... misleading?  Thanks for the education, and good eye!

> Insofar as the test suite confines itself to public methods/properties on Nightmare and instances (pretty sure it does), I agree.

I think the only time internal methods - and specifically, `evaluate_now` - are used is during the custom action battery.

> Iâ€™m not totally sure we need to make sure things like nightmareInstance.child continues to exist and work the same, though.

Oooh, I'm not sure I agree.  `child` may take on a different meaning (eg, a Nightmare `BrowserWindow` could be attached to an Electron `BrowserWindow`, and I'll get to more on that in a minute).

> However! I think [#493] is largely independent of this one (save that care should be taken not to make it worse).

True.  I have a foul habit of "since we're going to have this down to the studs anyway, why not also do [insert stupidly complex thing]?"  Reorganizing how Nightmare and Electron interact seems like a good time to think about simultaneous calls/multiple runs/handling messaging spaghetti.

> No. I donâ€™t think switching from â€œN electrons, 1 windowâ€ to â€œ1 electron, N windowsâ€ should have any externally visible impact on the API (save for private, non-documented bits). The rule that an instance of Nightmare == a window in Electron, however itâ€™s accomplished, is pretty simple and straightforward. (If Iâ€™m missing what youâ€™re getting at here, let me know.)

Mmmm, don't know that I agree.  The "window manager" would need to expose methods for listing, retrieving, creating, and closing windows.  One of the biggest side perks to doing this is being able to handle pages that open new tabs/windows: when a new window is created from the browser, it could then be created with the Nightmare sugar and registered with the window manager.

I guess my point is that windows are not just created by users, they can also be created by the site, and both cases should probably be handled.

> 10 seems like a maybe reasonable place to start Â¯_(ãƒ„)_/Â¯

Deathly curious what the memory footprint difference is.  I'd like to put together something about that, if nothing else for justifying the change.

> This should probably be a constant/global so itâ€™s easy to adjust in future releases or as the work on this goes on

Strongly agree.

> This should probably be configurable by users at runtime for beefy or light-weight machines (e.g. Nightmare.setPoolSize(1000) if you like to live dangerously)

I _also_ like to live dangerously.

> A fancypants implementation might look at os.totalmem() + os.freemem() + electron.screen and decide for itself, but even then you are likely dealing with some wobbly heuristics.

Not that I'm against a high-fallutin' implementation like this, but I worry that then you're at the whim and mercy of the OS and may introduce cross-platform problems that are hard to debug/track down.  At least for now, I'm in favor of keeping it simple.

> Back in #479 I wrote:
> 
> > For reference, a really simple nightmare session takes 20-30 MB of RAM on my machine, but once a screenshot is taken, that can boost to as high as 360 MB.
> 
> The current screenshot API should be much lighter, but Iâ€™d guesstimate **~50 MB per window** on my machine (13" retina MacBook Pro, 64 bit). That figure will definitely vary across hardware and OS.

(Emphasis mine.)  Per `BrowserWindow` or per Electron instance?
  @djdavidi I'd be open to including a bit about unicode characters.
 @Mr0grog I meant to do that yesterday after 2.3.1 and got sidetracked.  Closing.
  How are you getting these errors?  Are you using custom plugins?

By the time the exception makes it to the `uncaughtException` handler, it's too late.  I don't think you're inside of the Nightmare chain scope anymore, and as such couldn't handle it in such a way to continue execution.
 @yoz electron/electron#4733 was fixed/reclosed in electron/electron#5233, which should be in the release of `electron-prebuilt` Nightmare is on as of 2.3.4.  Can you upgrade and see if this issue still exists?
 Closing due to inactivity.  If this is still an issue, feel free to reopen/open a new issue.
 @GautierT I think this is in reference to rosshinkley/nightmare-download-manager#14, picking up this conversation there.  I suspect you're hitting a device limitation.  Electron is kind of resource-intensive, and even on the best of machines, I suspect that the number of concurrent instances you can run is pretty low.

Judging from your source, it looks like you're using [caolan/async](https://github.com/caolan/async), yes?  Why not use `eachSeries` instead of `each`?  Do your operations need to run in parallel?

If you're looking at trying to throttle to a specified number of instances, would [`async.cargo`](https://github.com/caolan/async#cargo) get you close to what you're after?  An off-the-cuff example:

``` js
var Nightmare = require('nightmare'),
  async = require('async');

var results = [];
var cargo = async.cargo(function(tasks, cb) {
  async.each(tasks, function(url, cb) {
    var nightmare = Nightmare(), result;
    nightmare.goto(url.link)
      .wait('body')
      .title()
      .then(function(title) {
        results.push(title);
        return nightmare.end();
      })
      .then(function() {
        cb();
      })
  }, function(err) {
    cb(err);
  })
}, 3);

cargo.drain = function() {
  console.dir(results);
};

//build a fake cargo load
for (var i = 0; i < 100; i++) {
  cargo.push({
    link: 'http://localhost:7500/' + i
  }, function(err) {
    //done with the specified link
  });
}
```
 @AaronTrazona Are you still having this problem?
  I'd leave it as-is, I like having the history, and this isn't all that noisy.  I don't see a real need for a rebase.  (I also don't _really_ know what would be considered "most correct," but that's the stand I'm taking, at least for now.)

I do have commit rights on github and publish rights on npm.  (Hooray!)  I'll be putting together a milestone + release ... soonish.  At a minimum, I'd like to get this + #553 in.  The underlying Electron PRs (thank you, @Mr0grog) have all been accepted, but I don't think they've all been released (at least at the time of this comment).
 @Mr0grog fair enough.  Can always cut another patch when #553 is done.  Will do as time permits.
  > This is just a work-in-progress at the moment, but filing the PR as there are open questionsâ€¦

I'd like to take a crack at responding considering I +1'd the original issue.  I can't guarantee it'll be _good_ responses; most of this is pondering out loud, coffee in hand.  :)

> For the former, the simplest solution is probably tracking the URL of the failed page and comparing it to the URL of the main frame.

This (at least superficially) seems reasonable, at least until electron/electron#5013 is fixed.

> Need to make sure that works right for redirects, though.

I'd imagine you'd have to look for redirects and set the URL you'd be checking against appropriately.  Child resource redirects should be handled as `did-get-redirect-request` already has `isMainFrame` in the event data.  I don't _think_ you'd end up with a race condition as main frame page loads should not fail _after_ a redirect.  

I have a couple of questions, though.  What if the end user wants to do something custom with redirects - would this effect the ability to handle redirects with a custom action?  Would a (optional) destination assertion or command need to be included?  I'm thinking of cases where you want to explicitly want to check the URL after `.goto()` is executed - you could certainly do it with `.evaluate()`, but it might be nice to include a shorthand.

> A more exacting solution might be to track resource requests on the session object, though doing so requires a bit more rigamarole.

The best thing this would buy you is the filtering mechanism.  However, memory serving, filters aren't terrifically strict.  I don't think you can specify exact URL matches for filters.  Before I take a firm stand on this, though, I think it would be prudent to verify that assertion.  

The bigger problem with using `session.webRequest.onErrorOccurred()` - which admittedly, I'm making the huge assumption that's what you'd use - is I think it gets emitted when there is _any_ problem, not just page load failures.  I'm guessing this is the "rigamarole" you're referring to.  With a cursory look at the documentation, I'm not sure the event data would contain everything you'd need to make the distinction.  It's probably worth carving out time for the experiment, though.  I don't know enough about it to be certain.

> There is also an open question of how this should behave w/r/t error responses (e.g. 404, 500, etc).

I would posit that successfully loaded pages with HTTP error statuses are still successful loads for precisely the reason you cite: it's a legitimate test case.  If you needed to treat non-1xx/2xx/3xx as failures, you could hook into [`did-get-response-details`](https://github.com/electron/electron/blob/master/docs/api/web-contents.md#event-did-get-response-details).  Granted, this doesn't give you the ability to handle those responses directly in the Nightmare chain...

> Maybe thatâ€™s something to wait for as a feature request, though?

... and continuing my line of thought, I'm curious what you would expect usage to look like.  Are you envisioning an optional parameter for `.goto()`?  Something like `.goto(url[, status])`?  Or does this get back to the shorthand I mentioned above with some sort of destination filter/rule?  I don't know this needs to be solved right now, but it might be worth thinking about.

> Also: As you can see in the tests, Iâ€™ve made the assumption here that child frames and sub-resources (images, scripts, stylesheets) failing do not cause goto to fail (i.e. it only fails if the HTML itself fails to load). Iâ€™m pretty sure thatâ€™s the right thing, but happy to take feedback on that.

I'd say this is a valid assumption and agree.  I don't think internal page errors should explicitly cause Nightmare failures.  I would want Nightmare to behave as close to Real Browser&trade; would behave - as fault tolerant as possible, loading and running as much of a page as it can.  You could always add fail-fast behavior yourself, hooking into the failure events and throwing exceptions.

Thoughts?
 @Mr0grog re your previous comment: like I said, my knowledge there was limited.  Thanks for setting me straight.  :)

I _really_ like `.goto()` returning information about the request.  One question about that, and this may be silly: I see in your tests that [valid redirects are okay](https://github.com/segmentio/nightmare/pull/553/files#diff-910eb6f57886ca16c136101fb1699231R233), but it doesn't check the internal information bubbled up from `.goto()`.  Based on the changes you've put in, would that show the 3xx?  At first blush, I don't think it would - wouldn't it show the 2xx (assuming success) for the final destination (after `did-finish-load`)?

To be clear: I'm not sure `.goto()` should track all of the redirect information from a given request, but I do want to clarify what to expect.  Thoughts?

It looks like atom/electron#5029 has been accepted and as such atom/electron#5013 has been fixed.  I don't know what kind of release schedule Electron is on, but they cut releases often enough that I think I'm willing to wait as it reduces the complexity of your solution (seemingly by quite a bit).  What do you think?

Onto the test issues: I can't get the test suite from your fork to run consistently.  The "should fail properly if request handler is present" test fails intermittently.  It looks like once in a while, `did-fail-load` gets emitted after `did-finish-load`.  (That's the difference in debug output anyway.  I'm not clear on the underlying cause yet.)  Coincidentally, that appears to be one of the problems in build 662.  I don't have time to dig into this right this moment, but as time permits today, I'm going to dig into this and the other CircleCI issues.
 > 9cfef7c should mitigate one of the issues I saw repeated on Circle last night: trying to load an unknown protocol seems to hang. It doesnâ€™t do so locally, nor does it if I SSH into the Circle box and manually run the tests from the command line. Not sure whatâ€™s different when Circle does its test run, but Â¯_(ãƒ„)_/Â¯

Hooray for fixing... but [terrified gasp] at Circle internals.  When I'm done spelunking through Electron's guts, I might have a look at `circle.yaml` and related docs to see if it's a setup problem.  My familiarity with CircleCI is _pretty_ pitiful, so it's worth the exercise.

> I noticed that sometimes on Circle, too, but wasnâ€™t able to repro locally and havenâ€™t dug into it yet, so if youâ€™ve got ideas, awesome.

Working on it.  Again, I want to take a look at the CCI docs, make sure it's not something silly.  For the Nightmare side, more on this in a moment, I want to dump out what I've found so far.

> Sigh. Hope this is not whatâ€™s really happening, but that would definitely cause this sort of problem :(

Maybe?  It looks like you were [on to something](https://github.com/electron/electron/issues/5031) with the provisional load failure.  That happens _super_ early in the request cycle,  emitting [`did-fail-load` equally as early](https://github.com/electron/electron/blob/702352804239f58e5abcd0b96dbd748b68ab0278/lib/browser/api/web-contents.js#L150-L156) and omitting that it came from the provisional load.  The handler for the provisional load failure also makes a call to `setImmediate`, which in my understanding (which I will readily admit is probably flawed) could prop up a race condition between `did-fail-load` and the other events.

At any rate, in my sandbox, `did-fail-provisional-load` doesn't get emitted for child parts that fail if I watch it directly. Did you experiment with that event?  If so, why opt against it?

> Oh, thatâ€™s a good question. Iâ€™m pretty sure it would show the 2xx for the final destination...

Curiosity got the best of me, I gave this a scream.  It does.

> ... but havenâ€™t tested that case.

Explicitly tested that case?  No.  Is it worth adding the checks?  Probably.

>  Iâ€™m also not sure Iâ€™ve tested the case of invalid redirects.

[This doesn't cover it?](https://github.com/segmentio/nightmare/pull/553/files#diff-910eb6f57886ca16c136101fb1699231R237)

> I actually hadnâ€™t thought about this case at all! It would be interesting to report on all the redirects involved, but I hadnâ€™t really planned to. So yes, no reason to expect that.

It would be neat and make Nightmare more useful as a testing tool, but I'm okay for the moment putting it down as a future enhancement.  Bigger fish to fry, all that. :)
 > AH! I had seen that earlier, but didnâ€™t remember it when you mentioned the race condition. This could definitely cause it. Hmmmm.

It was a bit of a (pleasant) surprise coming across your name.  I figured you had either forgotten or had a good reason for not pursuing it further.  (Lack of sleep is a legitimate reason.)

> The potential for a race did not occur to me, though. Just hooking did-fail-provisional-load to handleFailure would fix things if the setImmediate call is in fact the real culprit here.

For the sake of completeness, it's probably worth trying, if nothing else than to rule it out.  I'll give it a whirl and report back.

> Side note: I realized while looking at https://circleci.com/gh/Mr0grog/nightmare/13 that I didnâ€™t really do a very good job with the â€œfail if the response dies in flightâ€ test. Going to rewrite it by adding a server endpoint that just kills the socket, which should make the test reliable.

Right on.  Thanks!

> Also, on the onBeforeRequest stuff still being needed for the did-get-response-details eventâ€”Iâ€™m happy letting this PR sit while we wait to see what happens with electron/electron#5074 if you want.

Yeah, let's let it ride for a bit.  The maintainers there are _generally_ pretty quick with responses.
 > > The potential for a race did not occur to me, though. Just hooking did-fail-provisional-load to handleFailure would fix things if the setImmediate call is in fact the real culprit here.
> 
> For the sake of completeness, it's probably worth trying, if nothing else than to rule it out. I'll give it a whirl and report back.

I'm still having failures, but I think it's for an entirely different reason.  I'm not sure if it's a resource issue or what, but somewhere in the neighborhood of 50-60 runs, my sandbox (on my low-powered laptop) will hang when starting an Electron process.  (I feel like there's an open issue for this already - #238, maybe?)

Regardless, that's _way_ better than the ~1 in 5 failure rate I was seeing before, and the symptoms are totally different judging from the debug info.  From that, I think it's increasingly likely this is a race condition, and as such, swapping out for `did-fail-provisional-load` is a decent call.  Thoughts?
 Offtopic, but do you (or anyone else) know why `dom-ready` events are emitted even for provisional load failures?
 Mmmm, I might have jumped the gun in my myopic look at that one test.  Some of the other tests are now failing.  I don't have time right this second to dive into it, but will carve out time tonight.
 > Chromium then loads, as part of the same navigation (so no new request cycle), the error page ...

Ahhh, that makes sense.

> > Some of the other tests are now failing.
> 
> By any chance, is that â€œshould fire an event on page load failure?â€ If so, 52958f2 should fix it.

No, it was one of the `.type()` tests, but that family of tests has been flaky for a _long_ time.  It's spookily similar behavior to this: doesn't fail on decent machines, intermittently fails on modest machines, and seems to almost always fail in CI (at least, the first time).  It's next on my bug hunt docket.

> OH MY GOD THE TESTS PASSED ON CIRCLE

/chuckling
 @Mr0grog Thank you for all of the work you've done for this. :)
 @Mr0grog _Awesome._  I'll put this out as soon as I can carve the time out.
  I'm not clear on what you're asking.  Are you asking if `.evaluate()` could wait on a promise internally?  Or are you asking if Nightmare can somehow pick up document changes via events to make `.wait()` passive?
  I suspect you're having two problems.  One, it looks like your actions are not getting run - `.then()` should be called at the end of your chain.  For example:

``` js
var Nightmare = require('nightmare')
  , nightmare = Nightmare({
    //  show: true
   });

nightmare
.goto('http://host_url/login.aspx')
.screenshot('shot.png')
.end()
.then(function() {
  console.log('done');
});
```

Second, you might be hitting the framebuffer issues first reported in #468 and fixed in #479.  The fix was merged after you asked this question, so it might be worthwhile to upgrade to 2.3.0.
 @khafan246 Are you still having this issue?
 Closing due to lack of activity.  If you're still having this problem, feel free to reopen/open a new issue.
  You might want to consider using [.insert()](https://github.com/segmentio/nightmare#insertselector-text) instead.  That sets the value you send directly.

There's a reason why this doesn't work: `.type()` uses [`webContents.sendInputEvent()`](https://github.com/electron/electron/blob/master/docs/api/web-contents.md#webcontentssendinputeventevent), which restricts input to [accelerator](https://github.com/electron/electron/blob/master/docs/api/accelerator.md) keys.  I'm almost positive you can send unicode characters with `\u` and `webContents.sendInputEvent()`, but at present, Nightmare doesn't support it.  The string you send is simply split, so sending `\u54C8` would result in typing `\u54C8` instead of `å“ˆ`.

I've considered adding accelerator support, but there are cases where accelerators don't work like you might expect, like [sending `Return` or `Enter`](https://github.com/electron/electron/issues/5005).  Would sending unicode-encoded characters be useful to you?
 @suhaotian Turns out I was wrong.

Sending `\u54c8` _will_ send the correct character.  So either using `.insert()` or `.type()` with unicode encodings should work.
  I'm behind this change.  I can't see any downside to adding blur events to both.

I do have a question, and I realize this is how it currently works - when empty string or a falsey value is passed, the selector's value is set to empty string, but no focus or blur actions are taken.  Won't that cause problems if the intent is to clear the selector and the change event is triggered on blur?  Shouldn't clear events also cause blur?

Re the tests, I kicked off another build, and it passed.  The flaky tests might be a result of event conditions like those found in #553.  I'm attempting to get to the bottom of it.
 @yoz Any updates?

By the by, the tests were fixed with a makefile/shell script stopgap in #565.
 @yoz I understand.  Thanks for putting it together!
  Merging with #203, closing.
  Oh boy, I didn't read carefully either.  I apologize.  Good catch, @kuraga.

> P.S. @rosshinkley , Add queue argument to callbacks, maybe? And why result of nightmare.then(cb) isn't chainable?

It is... insofar as `.then()` returns a native promise, and can chain promise methods off of it (eg, another `.then()`).

> Is it good that TypeError: nightmare.goto(...).wait(...).exists(...).then(...).end is not a function?

Promises don't expose `.end()`, Nightmare does.  Once you call `.then()`, you're not dealing with a Nightmare instance anymore, you're dealing with a native promise.  If you wanted `.then()` to execute (and clear the queue) _before_ calling `.end()`, something like:

``` js
nightmare
  .goto(url)
  .click('some-selector')
  .then(function(){
    //current chain has run
    //do some other logic
    return nightmare.end();
  })
  .then(function(){
    //nightmare is now ended
  })
```

... should work.
 @wyqydsyq I'm considering this issue resolved.  If you have any more questions, feel free to reopen/open a new issue.
  Not sure that it matters, but you might want to also override [the Electron path](https://github.com/segmentio/nightmare#electronpath).  I don't _think_ the paths changed from 0.36.x to 0.37.x, so @Mr0grog's directions should work, but it can't hurt to be sure.  You may also want to run your application with `ELECTRON_ENABLE_LOGGING` in tandem with `DEBUG=nightmare:*,electron:*`.  That might give you a little more information.

What bothers me about the original log text is that the error is a page error from `.onClick()`, so I'm not certain it's because of the screenshot.  If I had to guess, I'd guess that there's a problem in PayPal's client code when you click on `#loadLogin`.  If you run the steps by hand in Chrome with the devtools open, do you get the same error?
 @Mr0grog This is about a thousand miles offtopic, but would it be worth implementing a crash report server internal to Nightmare so the child Electron instance submits crash reports directly to the parent process? 
 > Yeah, that would probably be pretty neat to have.

I'll open up a new issue for that so we don't pollute this thread. :)

Throwing it on the todo pile...
 With #598 being done and the recent changes to the screenshot API, I'm going to close this issue.  Feel free to open a new issue if this is still a problem.  Thanks, @justinmchase.  Merging.
  Hm... that sounds like something strange in the input bindings on the site.  It's almost like the changes to the input aren't being picked up by whatever the site mechanism to issue a search is.

Have you tried using the method in 2.0.2?  Something like...

``` js
nightmare
  .goto('http://example.com')
  .evaluate(function(text){
    var elem = document.querySelector('#serach form.form-inline input');
    elem.focus();
    elem.value = text;
    elem.blur();
  }, 'something')
  .click(button)
  // ... the rest of your script
```

Possibly related to #548?
 @xpiqu With #548 included, can you give this another try?
 Closing due to inactivity.  If this is still a problem, feel free to reopen/open a new issue.
  @sanathko I think so.

A little more research (and some later issues, notably #549 and #559) shows that you could also include a unicode character.  Something like `.type('#demobox', 'typing text line 1\u000d')`.
 @sanathko I'm considering this issue closed.  If you have more problems with this, feel free to reopen/open a new issue.
  The application I've built in electron is based on nightmare to fetch and create content.
I have nightmare on dependecies. When I build the application with electron-builder it does not give me errors.
When I start the packaged electron application the console tells me that "there's no electron-prebuilt node modules"
 Anyone?
Maybe I've explained it badly, are any clarification needed?
 I need nightmare to make the app I'm working on to run, as I've not found a better alternative for electron.
Thanks, I really aprreciate!
 This should be merged with #393, closing.
  I believe this is a duplicate of #224, closing.
  I believe this issue is resolved.  If you have more questions about this topic, feel free to reopen/open a new issue.
 @rmoriz There is _some_ of that in [`nightmare-examples`](https://github.com/rosshinkley/nightmare-examples).  The Nightmare documentation is lean, to be sure, but much of that is intentional.
  It seems like setting a cookie always fails. Below is my config object:

`
{
    show: false,
    images: false,
    waitTimeout: 5000,
    paths: {
        userData: path.join('./appData/userData'),
        temp: path.join('./appData/temp'),
        home: path.join(./appData/home')
    }
}
`

What I have done is: 
start a nightmare instance A to url , login to somewhere, extract all cookies as array, close instance A
then start a another instance B, set cookies to extracted ones from instance A

Problem is B.cookies.set(array) always fails...
`
B.cookies.set(array).then(null, function(err) {
  // err is an empty object...
});
`
One of cookie entry has attribute like:
"domain: something.abc.com","hostOnly":true,"path":"/","secure":false,"httpOnly":true,"session":true,"expirationDate":0
It is the one that fails all the time...
Looks like it is because setting cookie to domain 'something.abc.com' when you are not on that page is causing this problem...
Can anyone help please...
 @rosshinkley, problem is even with .something.abc.com, it does not work. What I wanted to do is as simple as set cookies before I start anything, but still can not find out a way
 @rosshinkley, the procedure is like this, I firstly go to google, then try to set cookies of a session I extracted from something.abc.com so that multiple newly opened instances will have the same session when I change those instances to something.abc.com, but it fails all the time no matter if domain is .something.abc.com or something.abc.com.

I tried it with phantomJS, it works with dot prefixed. Maybe it is the implementation of electron preventing it?

As far as I know, cookies without dot as prefix is usually set through set-cookie header section of a server's response, but most modern browsers consider cookies with or without dot at beginning the same now, so I was expecting electron to act the same...

BTW, using persist:somthing does not work for the website I am working on
 > Could you expand on this? What exactly isn't working?

If I get purpose of persist partition correct, the scenario I am having is like this:
1. start an instance with partition set as 'persist:SAHRED_SESSION'
2. open www.example.com
3. type credentials to login
4. page is redirected to something.example.com and cookies for session is set at this point
5. start another instance with partition set as 'persist:SHARED_SESSION'
6. open something.example.com
I was expecting new instance will stay at something.example.com, but the fact is it gets redirected back to www.example.com because session in first instance is not shared with new instance

> @Velissel I understand you want to preload the cookies before navigation, but I don't think Nightmare allows for adding cookies prior to navigation. I still don't think adding cookies across domains like you're doing is permitted.
> With #425, you could probably extend Electron to add a hook to the 'did-start-loading' event to add cookies prior to the page loading. If it interests you, I could pull together an experimental plugin to prove feasibility.

If persist partition works then there is no issue on this at all. I know setting cross-domain cookie using javascript is definitely not permitted for safety reason, but when it comes to testing, having a way to preload cookie to keep session status is resonable I feel
 > start another instance with partition set as 'persist:SHARED_SESSION'

Ah!  I think I see the issue.  I first hit this problem in trying to address #398, and then again in #532 (specifically, [this comment](https://github.com/segmentio/nightmare/issues/532#issuecomment-198070852)).  If you open an instance, log in, and open a second instance with the same persistence data before closing the first, the session information doesn't appear to be shared (or the data from the first session isn't persisted or shareable yet).  I'm _still_ not sure why this is the case.

> ... but when it comes to testing, having a way to preload cookie to keep session status is resonable I feel

I agree, but from the sound of it, you shouldn't have to preload your session cookie to begin with.  That session should persist.
  > If thatâ€™s cool with you, @rosshinkley. The implications are minor and, I think, an improvement.

ðŸ‘ Absolutely.  Please, go ahead.
  This issue seems to be resolved, closing.  If you are still having this issue, feel free to reopen or open a new issue.
  @antpaw Yeah, there are intermittent failures I haven't gotten to the bottom of.  Have you had any luck?
 @antpaw Have you given this a try with later versions?  I wonder if you're hitting the `Xvfb` hang from #561.
 @antpaw Do you have `DEBUG` output?  What version of Node are you running?
 Can you run it again with `DEBUG=*,-mocha*` under 2.5.0?  Also, what operating system/version are you running?
 I just hit this when working on the Circle tests to include multiple NodeJS versions.  I had a sneaking suspicion you were missing libnotify.  If you're on Ubuntu, installing `libnotify-bin` with `apt-get` _should_ solve it for you.
  Looking at this again, it looks like you can use [`webRequest.onBeforeSendHeaders()`](https://github.com/electron/electron/blob/2cf0843f82af4eae283ad759d806360973bbd869/docs/api/session.md#webrequestonbeforesendheadersfilter-listener) to amend the request headers.  You could pretty readily write a plugin with `.action()` to take care of that for you.

With that, I'm going to consider this issue resolved, seeing as how I think we've covered how to do it with a preload and from within Electron.
  ðŸ‘ thanks!  thanks!
  Closing with the closure of #514.  I like this change.  Marking for inclusion in the next release.
  Merging into #593.
  @kokujin #476 has been merged.  Could you upgrade to 2.3.0?
 Closing due to inactivity.  If you're still having this problem, feel free to reopen/submit a new issue.
  The makefile buys automatic installation of dependencies if the package has been touched since the last make.  With the inclusion of #561, the makefile will also allow headless systems to run the unit test suite (specifically, CircleCI) without internal problems to Electron/Chromium.  Mimicking these two behaviors with simple NPM scripts would be difficult to do in a cross-platform friendly way (although not impossible).

I'm in favor of modifying the build process to make it friendlier, and would like to get some feedback on what we should do.  Off the cuff, I'd suggest something like Gulp, but that may be a bit heavy-handed for what we ultimately want to accomplish.

Has anyone had trouble building this on Windows or any other OS where the makefile won't work?  If so, have you been able to work around it?  What does your make process look like?  Do you have suggestions for build tools?
 > If Nightmare just did all of that on its own before launching Electron, that would not only solve the deadlock for Nightmareâ€™s own tests but also for other tests that leverage Nightmare.

I'm going to purposefully totally ignore the NPM automagic make gives and focus on the framebuffer issues for the moment.  I'm tentative on if we should automagically include the "run with `xvfb-runner`" magic.  My main dev box is running both X and Xvfb - what if I want to see the Electron instance?  What should Electron run under?

Implementing your proposed changes has other setup complications, I'd think: I would want to preemptively check for an available framebuffer, but I don't know off the top of my head how to do that, especially in a cross-platform-friendly way.  I'd love to hear your thoughts on that.  Maybe I'm making it _way_ more complicated than it needs to be.

> Doing so would also simplify the test script to the point where we might not need to worry about adding Gulp or some other solution to get things working on Windows.

Gulp is nice insofar as it skirts cross-platform issues.  The runner task could also be exposed/registered.  Introducing the complexity of managing the framebuffer ourselves is unpleasant at first blush, but does also mean avoiding another (large) dependency, and _possibly_ fixing #224 .  Which devil is worse? :P
 @Mr0grog Yeah, this may be a case of me trying to do an awful lot of work to save someone (me, if I can be totally selfish) ten seconds of setup grief.

As time permits, I'll throw together a proposal on running Xvfb internally to Nightmare.  Sound good?
 I have this (at least partially) working:  instead of spinning up an Electron process directly, if the `NIGHTMARE_USE_XVFB` environment variable is set, Nightmare will spawn `xvfb-run`, `dbus`, and finally Electron, akin to how the Makefile runs the test suite now.

The main problem was that sending `child.kill()` would kill the `xvfb` instance and leave the Electron process intact.  Having an action to make the Electron process exit internally causes the process chain to end.  Unfortunately, this breaks the "should kill Electron" test as the `child.kill()` kills the wrong process.  I'm not exactly sure how to make that a valid test.  I'm certainly open to suggestions.
 @Mr0grog Yes, at least for the moment.  I should probably go ahead and create a PR for it, but I know there are still some problematic tests.  Anyway!

> Maybe start xvfb separately

Well, it is.  Kind of.  Right now, each new Nightmare instance creates an Xvfb instance as well as an Electron instance (so Xvfb, Electron and Nightmare instances area all 1:1:1).  They are created together, and in my opinion, should end together.

> Electron starting/ending/overlapping at different times. Iâ€™m not sure if xvfb-run takes care of all that for you or not.

I don't know that handling a single Xvfb instance is going to work very well, at least not without the single-instance stuff getting done.  I also don't think starting an instance and leaving it running is particularly clean.  I'd prefer Nightmare to clean up after itself when it's finished.

I'm going to lump these together:

> Can you get the PID for Electron somehow? 
> Directly killing Electron is sort of a simple expedient; you could re-write it as an IPC call that asks the Electron process to quit.

Yes - from within Nightmare - but not without a bit of patching to how `.action()` works.  (It doesn't have an ambient reference to `process`.)  With that, you can bubble the Electron PID up to the parent process.  It's ugly.

I don't know you can get the PID from the process tree, either.  Maybe?  I had problems with killing the process tree (that was my first attempt), but this might be worth a second look.

The current incarnation adds another action to have Electron exit internally rather than killing the process from the parent.  This works, but again, breaks the kill test.
 > I donâ€™t know what happens if you try to run two xvfb server instances at once, but was assuming (maybe wrongly) that you couldnâ€™t.

This is ripe for science.  I, too am not certain how `xvfb` (or more to the point, `xvfb-run`) works under the covers when there are multiple instances.  From my very rudimentary testing, it looks like you _can_, but it also looks like Electron (or any process that requests a framebuffer) picks up the first available display instead of the `xvfb` instance it is a child process of.  This can cause problems like the Electron instance being mid-execution when the buffer suddenly quits.  This is where I stopped as I knew that how it worked in my mind was not how it was working in reality, and am going to try to circle back.

> Obviously this whole method requires more bookkeeping: whenever an Electron process ends, youâ€™d have to check and see whether any others are running in order to know whether to stop xvfb.

It's not _just_ `xvfb` but also `dbus` that would need to be tracked.  I also wonder if running them independently but started in series if that's going to have any ill effect?  At any rate, I understand what you're getting at.  It's worth a look.

> ... since xvfb-runâ€™s manpage makes it sound like the exit code is not preserved.

I figured as much.  It's being wrapped twice.  The exit code is an almost guaranteed lie. :P

> If Iâ€™m reading right, think thatâ€™s just because youâ€™re changing the API. Youâ€™d have to update test/files/nightmare-unended.js to pass back the right PID. (nightmare.proc is no longer the Electron process with your changes.)

Yes, and I did that locally, but at that moment, I thought it was not in the same spirit without modifying how Nightmare handles interrupts to call the newly-minted Electron self-desctruction mechanism.  With a little distance, having the Electron PID bubbled up and having the signal handler call `ending`, and then using the `exit` message to catch the `xvfb-run` instance being destroyed might work and still be in the spirit of the original test.

That said, it won't catch the other processes being orphaned (if they even can be), which gets at your point of running them independently.

---

With all of that in mind, I think my next steps are to:
1. experiment with one running instance of `xvfb` and `dbus` managed by the Nightmare constructor.
2. write a test to have two overlapping Nightmare instances where the first ends before the second completes, making sure either shared instances are okay or instances are completely independent
3. re-run original Xvfb-churn test for independently managed processes approach
4. make sure that whatever approach is settled on doesn't break the popular suggestions/fixes in #224 
 Update (aka "So what'd we learn?"):

> experiment with one running instance of xvfb and dbus managed by the Nightmare constructor.

You _can_ run the processes independently, but it would appear that Electron picks whatever display is first available when not running as a child process.  Unfortunately, this leads back to the same locking issue.  I can kill off all of the X servers for a build up front, but that feels incorrect.  Also, once in a while - with X started internally to Nightmare - Electron won't "pick up" the framebuffer.  I need to spend some time to see if it can be remedied with using `xdpyinfo` or something to wait for the display to become available.  So far, using plain ol' dumb `setTimeout`s have not been effective, leading me to believe that approach is probably flawed and I've run aground of a different problem.

Again, I need to spend more time with this - it's possible I'm not using Xvfb properly.  Open to suggestions.

Also worth noting: this necessitated moving the Electron process start to the Nightmare queue instead of doing it directly in the constructor.  The constructor starting Electron has been a long-standing bugbear for me, and I may split that part out into it's own PR.  Thoughts?

> write a test to have two overlapping Nightmare instances where the first ends before the second completes, making sure either shared instances are okay or instances are completely independent

Works great, provided the right X instance is picked up.  The Electron instances share the running X instance just fine.

> re-run original Xvfb-churn test for independently managed processes approach

Also works with the same provisions as above.

> make sure that whatever approach is settled on doesn't break the popular suggestions/fixes in #224

This would not break anything as it requires an environment variable to be set to be used.  Currrently, I have it set up to pick up if Nightmare is running under Circle, but I think I may remove that.  I don't want to add new behavior to existing builds that may already account for Nightmare/Electron's special needs.

---

Another thought crossed my mind as I was playing with moving the Electron start to the Nightmare queue: what about a retry?  In the case of a lock, I believe the `browser-initialize` event does not respond.  What if a timeout was propped up around that (say, 5s?) that if hit, would kill the Electron process and restart it?  I think that would sidestep the issue as the hang only seldom happens (1 in ~300 starts on my box) and (almost) never happens back to back (again, on my box).  This would allow for the `npm test` to use `xvfb-maybe` ([as suggested here](https://github.com/segmentio/nightmare/issues/224#issuecomment-219913947)) to run mocha.

I thought I'd at least float the idea for feedback.
 > Did you try setting the display via app.commandLine.appendSwitch('display', 'displaynum')? 

I (embarrassingly) had forgotten about the Chromium command line switches.  No, I have not, and will carve out some time to give that a whirl.

> Alternatively, do the various XVFB displays show up in electron.screen? 

I wasn't trusting anything to come out of Electron.  I didn't know how reliable the information that fell out would be.  I can give this another peek and report back.

> But if this is all proving too crazy and problematic, than letting it lie and taking the timeout/retry approach might be the right thing to do.

I'll do one more round of experiments to see if I can nudge this into a working state.  The Chromium arguments seem promising, though.  Thanks for that!
  I don't know that having a `.run()` call with an internally defined callback makes sense.  Consider:

``` js
nightmare
  .goto(url)
  .evaluate(someFunction)
  .run();
```

... which doesn't actually _do_ anything with the results of `someFunction`.  The only cases I can maybe see this being useful is with `.screenshot()`, `.pdf()` or `.html()`.  Even at that, it's only the most trivial of cases of each.  Is there a usecase I'm not thinking of?

I would advocate for something closer to how #512 works - validating the input and throwing an exception if it's not acceptable.

Thoughts?
 The (apparently deleted?) #516 dealt with this... sort of.  `.run()` is _really_ intended for internal use and usage isn't directly supported.  Should it be?  I feel like that discussion might be a bit off-topic, but I'd like to hear thoughts from you or anyone else.

Back to something more germane:  

> On the one hand, even the most trivial cases should arguably be accompanied by a callbackâ€”you want to handle, or at least be notified of, failures.

Could not agree more, and I guess I was erring on the side of protecting users from themselves, which now I'm realizing _might_ be overstepping a bit.  Consider:

``` js
nightmare
  .goto(url)
  .screenshot('screenshot.png')
  .end()
  .then();
```

This is legitimate, and could certainly cause a "silent" (if run without `DEBUG`) error.  Also, consider something like:

``` js
nightmare
  .goto(url)
  .wait('body')
  .click('a')
  .end()
  .then();
```

... which is also completely legitimate.  Without context, it doesn't make a whole lot of sense, but now that I think about it, it's possible that you just want to click "OK" on a page in a test suite or something.  There are legitimate use cases, I suppose.

> I like allowing no callback to be passed to runâ€”with one tweak: the default callback should probably console.error() when errors occur.

... I have to begrudgingly agree.  I am not sure I can articulate why I'd prefer input validation over this, but because that's almost precisely how `.then()` behaves, it's kind of hard to argue.

> Bottom-line, either solution would be much better than the current situation.

Yes sir.  Something would be better than nothing.
 > ...the intention is still clear and the behavior still has meaning and value.

Your skilled reasoning has convinced me (twice over, in fact).  Coupled with the fact that `.then()` works that way _anyway_, I feel like my original exception position is pretty indefensible.
 @LinusU Are you referring to `*sync` methods and when they except, maybe?
 An important distinction to make: I was originally advocating for input validation, which is too heavy-handed.  (Meaning, option 4 isn't going to work.)  Throwing on errors when no callback is present _after_ execution is probably worth talking about.
  yah, i'm +1 to that idea. and then have `.insert` just clear things out. 
 @the-t-in-rtf Any progress on the PR suggestion?
 I agree with @yoz.  I think #548 fixes this, and as such, I'm closing this issue.
  @mousemke Are you still having this issue?
 @Mr0grog @pci Of course! High device resolution!  That makes sense.

With that last mystery solved, I'm closing this issue as I think it has been fully resolved.
  @tiangolo I think this would be better served as a plugin for Nightmare.  Thoughts?
 @tiangolo I saw the comment, thanks for the pointer.

I'm not entirely convinced it's not possible to turn this into a plugin.  Unlike, say, popups that make a new `BrowserWindow` which won't have _any_ of the Nightmare sugar baked in, the IFrames you're dealing with should still be in the same context.  I can see with modifying preload this might not be possible.  I'd have to play around with this PR to be sure.

Even if it weren't possible, I would be more inclined to modify the current plugin functionality to allow for functions like this.

Thoughts?
 I finally had some time to circle back to this.  The short version is you _can_ do this with a plugin, but  not without overriding the `evaluate_now` method on the prototype.

The `document` (really, `window.top.document`) variable isn't settable (which is I'm guessing why @tiangolo had trouble with the plugin route).  Because of that, you can't set the `document` variable from within a regular plugin method.  This has the consequence of the only place remaining to alias `document` - at least in the current implementation of Nightmare - is in `evaluate_now`.  You _can_ override the Nightmare prototype's `evaluate_now`, and I've thrown together [a (horrifying) sample](https://github.com/rosshinkley/nightmare-iframe-manager).  (Use at your own peril.)

Patching `evaluate_now` to wrap `document` _technically_ works, but suffers from the same issues that implementing frame support directly suffers from.  Off the top of my head:
- `.scrollTo()` only scrolls the window, not the interior selected frame.  Scrolling interior to an `iframe` would have to be written.
- `.screenshot()` will still take a shot of the bounding rectangle if provided, including the parent frame(s).  Not that this is unexpected, but it may catch new users off guard.
- `.html()` and `.pdf()` will still return output for the entire page rather than the selected child frame.  Again, expected behavior, but not what I'd expect as a new user.

There might be other issues with some of the more advanced functions (authentication, for example), but I haven't had a chance to set up testing yet.
 I should have reread the _entire_ thread before posting: [@Mr0grog covers issues](https://github.com/segmentio/nightmare/pull/496#issuecomment-208445167) more comprehensively than I did.  (Price of being in a hurry, apologies.)  I still think there are almost certainly other corner cases, though.  As time permits, I'll set up some test cases to verify what @Mr0grog outlined.

Setting that aside, it frames need to be a first-order citizen in Nightmare (along with `BrowserWindow`s).  I think this should make it onto the list for vNext.
 @tiangolo I'd suggest opening issues at nightmare-iframe-manager.  (Looking at it offhand, I'd bet there's a problem with the Nightmare version.  I put the plugin together more as a proof of concept than anything.)  Time permitting, I'll see if I can fix the glaring problems.  If you could report the issue(s) you had there, that would help tremendously.
 > Do you want to keep it just as a proof of concept or do you want to keep developing it?

I can keep developing it, but remember: it's going to be _very_ fragile.  Using it is probably not a good idea.

> Are you planning on uploading it later to NPM?

I was/am reluctant to do so because it modifies a core part (virtually _everything_ touches `evaluate_now()`) of how Nightmare works.  I don't know that I can make the disclaimer large enough.  I can publish it to NPM if it solves anything, but keeping it confined to Github keeps it in the realm of "you can, but probably shouldn't."
  With the inclusion of #425, I think it's safe to close this PR in favor of it becoming a plugin if needed.

Closing.
  > I think (1) or some flavor of it is essential. 

I agree. Having instances (whatever the final instance implementation is) be independent _including_ the messaging bus is important.

> Given how often people run into problems with loops and how complex explaining the problem and various solutions is, I think (3) above or a variation on it is also a good idea.

I tentatively agree.  The question that immediately jumps to my mind is handling something like:

``` js
nightmare
  .goto(url)
  .someOtherAction()
  .evenMoreAction()
  .then(function(results){
     return nightmare.goto(anotherUrl)
       .yetAnotherAction()
       // etc
   })
```

I'm guessing you'd expect the first three actions to execute prior to the actions in `.then()`, right?  Are you envisioning `.then()` being an action that acts like Underscore's/Lodash's `.tap()`, or would there be a differentiation between the queue being executed and the queue that is accruing tasks?

This could also lead to unintended consequences with memory for sufficiently large sets, but I'm okay (at least for the moment) with assuming that if you're using Nightmare to do an arbitrarily large number of tasks, you already Know What You're Doing&trade;.

> As much as I like the idea of the power-user capability of being able to do multiple operations at once in the same window, Iâ€™m not sure there are a lot of concrete, real-world use cases for it. 

I would be inclined to support something closer to [async's `.parallel()`](https://github.com/caolan/async#parallel).  Something like:

``` js
nightmare
  .goto(someUrl)
  .parallel([
     nightmare.action().anotherAction(),
     nightmare.action().yetAnotherAction(),
     nightmare.anotherActionStill().somethingElse()
   ])
   .then(function(results){
     //results is an array of results.
     //could also support named hashes.
   });
```

Thoughts?
 ### process/execution safety

I agree with just about everything you said, including that this is a safety problem first and foremost.  There are a few (many?) devils in the details, but I don't think they're worth touching until development is underway.

I _really_ like the idea of progress events, especially for debugging.  Implementing something like that would have made sussing out several bugs much easier.  It also adds a new layer of power for actions/plugins.

I do have a question: how do you propose to have callbacks callable child->parent?  I don't think you can call back like that, at least not without writing something reasonably fancy to manage the events for you.  I feel like this is what you were getting at but never explicitly said it.  I'm _also_ feeling like maybe I've missed something important.

### queues

And this is where the brain-bending _really_ gets into full swing.  It might be useful to explain what I was driving at: `.then()` would be an action, (almost) the same as anything else.  It would let you put in custom code between other actions.  

Skipping ahead a bit, that buys having the whole of the Nightmare API hung off of the `.then()` so you can get to your "magical land of fairies and unicorns".  I'd add puppies and sunshine, but that's my two pence.

There are a couple of things with this approach that bother me.  For one, I _think_ the Nightmare instance doing the queueing would arguably need to be a full-on capital-P Promise implementation (whether that's done explicitly or with inheritiance).  That would let it remain compatible with existing tools like the `vo`/`co`/`mocha-generators` family of libraries.

Second, and maybe more importantly, when does execution start if not with `.then()`?  Is it the last `.then()` on a chain?

Moving on (well, backwards really), and borrowing your example here, and trying to clear up how this works in my brain:

``` js
nightmare
  .action1()
  .then(function then1 (results){
     return nightmare.action2();
  });

nightmare
  .action3()
  .then(function then2 (results) {...});
```

The resulting queue would look like:

```
action1
action3
then1
action2
then2
...
```

Which if I'm reading your diagrams properly, should match up with:

```
 â†“    action1
 â†“       â”œâ”€â”€â”€â”€ (schedules) â”€â”€â”€â”€â”
 â†“    action3                then1
 â†“       â””â”€â”€â”€â”€ (schedules) â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”
 â†“    action2 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    then2
```

With respect to actions that return actions, I'd think that it _wouldn't_ add an implicit then and instead alter the queue.  Based on my above fun magical land commentary, and again borrowing your example:

``` js
nightmare
  .action1()
  .then(function then1 (results){
     return nightmare.action2(); // implicit then caused by return
  })
  .action3()
  .then(function then2 (results) {...});

nightmare
  .action4()
  .then(function then3 () {...});
```

(Aside: you're right, this gets nightmarish [har] in a hurry.)

I would expect this to look like:

```
action1
then1
action4
then3
action2
action3
then2
then3
```

... I think.  I'm getting turned around trying to puzzle through this.  Dearth of coffee.

And ultimately, I'm still head-tilting at arranging Nightmare calls in this way.  It would run deterministically (unlike the wild of now), but I still don't think it would Do What You Mean&trade;.  A naive reading of the above makes it look like you're doing two completely independent chains of actions on a single nightmare instance, and based on what we're describing here, that's just not the case.  (Nor should it be.)

With that said, now I'm starting to question what the ultimate goal is with the changes to queueing.  I would advocate for 1) deterministic results and 2) easily usable/intuitive calls from `.then()`.  Is that fair?

Re parallelism, yeah, that gets into a _bit_ of a different bailiwick, but my two previous rules should still apply.  I can think of ways to accomplish this, but I would like to see the queueing problem solved first.  If I'm thinking about _that_ properly, parallelism might fall very well fall out for cheap.  Like you said, the implementation doesn't need to have it day zero, but I wouldn't want to completely close the door on it.

Oooookay.  I've re-read your comments several times now, and my thinking parts are turning into mush.  I know I've only scratched the surface here.  I'll continue to let this marinate and comment again if I have more thoughts.
  thanks @rosshinkley for the fixes â€“ though i'm a bit surprised about the id change since I tested this two days ago. I wonder if yahoo is doing something weird with rendering.

---

@Mr0grog you mentioned a lot here so let me address a few things:

**1. I apologize about the API change**

I changed my mind about returning a promise, mostly because you can now use Promises natively in latest node, so you don't need to include Bluebird or anything big.

I should have mentioned something, but to be honest I'm not sure it broke anyone's code. Let's be clear, the only API change is: _.then() returns a promise and not a nightmare instance_

The goal of this change was to make it more familiar to newcomers and remove the additional dependency that was confusing in the first place.

**2. I strongly disagree that big contributions aren't welcome**

If you go back in the merged PRs, there are some really big PRs that have been merged. It does take time to go through some of the bigger ones though since a lot of people depend on this library and I have other commitments outside of working on Nightmare.

**3. Direction**

The next two things on my TODO list for nightmare is to get @rosshinkley's #425 merged and create better documentation (a quick how-to video) on how to run Docker on linux.
  With #475 merged, this should be fixed.  Closing.
  thanks @Mr0grog !
  thanks!  This causes the .type() to get cut off. My guess is that the page isn't ready before we try focusing, but it needs more investigation.
 Closing this issue for now as I have not seen this issue in quite a while.  If anyone sees this, I'd be happy to reopen.  Certainly. Here's some results from awhile back. This is from an old email.

---

Phantom has been very slow for us, and so I was experimenting around with using Electron as a web driver in instead. It turns out Electron is quite a bit faster. Here's some of the benchmarks for selecting `document.title`:

Nightmare (via Phantom):

```
Google: 2064ms
Yahoo: 4059ms
CNN: 8658ms
```

Nightmare (via Electron):

```
Google: 866ms
Yahoo: 1862ms
CNN: 2729ms
```
  Closing this issue due to inactivity.  If this is still a problem, feel free to reopen/open a new issue.
  Ahh sorry about this, I forgot that we were installing vo from latest. I went ahead and removed vo altogether from the example. We'll be recommending you use `.then()` from here on out. 
  Upon deeper inspection, injected scripts [do not inject to global scope](https://github.com/rosshinkley/nightmare-examples/blob/master/docs/known-issues/globally-defined-variables.md).  That's why your call to `_.map()` is not working.
  thanks!
  #465 has been merged, closing.
  not right now :-) do you want to speed it up or slow it down?

we have a delay in place as a hack to ensure the characters are entered in the correct order.
  awesome! we'd love to see a patch for a more deterministic result!
 #479 has been merged, closing.
  thanks!
  Merging with #235.  Closing.
  cool i like it :-)

what kind of events are available by making this more generic? I can think of click and dblclick. would this also include mousedown, mousemove, etc?

additionally, maybe we can rename it to `.mouse(selector, event)`?
 def open to this abstraction, would be great to see something like `doubleclick` or similar implemented to make the abstraction worthwhile though. maybe re-open with a PR that adds something like that?  it would be a great help if you can close your own issues once the problem is resolved. this repo has a lot of traffic, so it helps us know what issues need our attention and which are resolved.
  it's here: https://github.com/segmentio/nightmare/blob/master/lib/runner.js#L303-L306

`win.session` is a recent change, right now we're using the old reference (that still works).

I'd be interested to see a PR that supports this or when we land #425, it could be a plugin too :-)
 depends on the use case :-) i'd probably prefer a plugin, but i think there could be an argument for providing a high-level way to intercept requests in nightmare.
 #425 has been merged, and [nightmare-load-filter](https://github.com/rosshinkley/nightmare-load-filter) has been released.  Closing.
  Yes, I love this idea! But I think it should be baked into the code itself instead of in the readme. Basically just: 

``` js
var errors = {
  127: "you may not have electron installed correctly"
}
...
debug(errors[code])
```

mind updating this PR to get this started?
  good catch, thanks! :-)
  not at the moment, but adding adapters would be a cool addition :-)
  thanks @the-t-in-rtf !
  this should be fixed in the new release :-)
  thanks for the note, this should be fixed in 2.1.4 :sparkles:
  thanks!

@MiguelOller can you test this in your environment?
 thanks :-)

i'll fix the classname
  Using, say, `will-navigate` and `did-stop-loading` and taking the time difference between the two might be a better approach barring redirects (or other edge cases I'm sure I'm not thinking of).

I could agree that `_timeoutMs` should be an option you can set, but I'm also not sure I understand the utility of doing so.  Is there a use case beyond measuring page load time?
  @adrianparr Are you still having this issue?
 @adrianparr Ah, okay.  Closing and merging with #224.
  @inversion I'm definitely in favor of the change, but it needs to be updated to be current.  Would you mind updating this?
 Thanks, @inversion!
  looks good, thanks!
  hmm, can you give me an example of when you'd want to throw? these are all asynchronous events, so i don't think throwing would actually work as expected.
  thanks!
  okay great, thanks :-)
  Hmm, I'd probably prefer `dock: false` and `dock: true`. Otherwise it looks good!
 thanks :-)
  awesome, thanks!
  I believe this is related to this: https://github.com/segmentio/nightmare/issues/414
 this should be fixed in 2.1.5 :-)
  looks great. thanks @emars !
  Killer. Great fixes. Thanks!
  awesome, thanks @emars !
  hahaha we'll do our best.
  i'm not really sure. don't have access to an IIS box at this time. does anyone have any ideas?
 @rehael I'd be curious if NTLM causes the [`login` event](https://github.com/electron/electron/blob/master/docs/api/web-contents.md#event-login) to be fired.  I suspect the answer is no - which would explain why `.authenticate()` doesn't work - but I'd appreciate it if you (or someone else) would double-check.
 Closing due to age and viable workaround.  awesome, thanks!
  has this been a problem for you? or more just for better UX? i'm just a little apprehensive with hiding it right now just because it's nice to know if you accidentally opened up a ton of processes.

definitely want to merge this, but just not sure if it should be now.
 Okay, yah that makes sense. I'll merge this and I'lll add an option to show the icon in the dock for testing purposes.
  @rosshinkley thanks for putting this together! I really have to think about this one a bit. After I get back from holiday vacation, I will take a closer look. My initial thoughts: 

> This amends the instance, not the prototype. I did this largely because Nightmare does not share Electron instances between Nightmare instances. It didn't seem sensible to force the prototype to have Nightmare actions for which there were no Electron actions. This also allows separate instances of Nightmare to use different plugins.

This could be confusing with how `.action` works, but is sort of inline with `.use`. I'm not crazy about having all these sorta different, but obscure ways to extend nightmare. I think it was discussed a bit in https://github.com/segmentio/nightmare/issues/379. 

I'm not sure the best way to fix this atm but I think where we're headed is going to lead to more confusion. It could just be a documentation thing though.

> Adding Nightmare and Electron actions together makes more sense to me than adding Electron actions alone. Thoughts?

Yah, I think you're right, but maybe actions/use could be nightmare-side only and there's an optional electron side.

> I readily acknowledge this sort-of-kind-of steps on .action() (and to a lesser extent, .use()). I considered updating .use() for plugins, but decided not to introduce breaking changes for this proposal. Suggestions for naming conventions or restructuring welcome.

Need to think on this more. But in general, I agree. It needs to be consolidated a bit more.

> Constructed function scoping works a little differently. This is why the constructed function binds to an object that passes in require (it's slightly cleaner than using eval). This allows require calls to be made in the Electron action. I considered stuffing that object with parent, win, etc - this would make the Electron actions look closer to what is in runner.js, but decided to leave them as explicit parameters for the time being. Thoughts?

Explicit params is probably fine if there's not going to need to be any additional params (or different ordering). If not, we should probably just pass a params object in.
 Some general aestetic thoughts: I'm not crazy about passing an object in with `nightmareAction`, `electronAction`. I think two functions would make more sense since folks are used to `.evaluate(browser_fn, server_fn)` but I'd be open to other solutions too :-)

Thanks again for getting this started though. I think this is going to be a great addition.
 aestetically and complexity-wise, I like this **a lot** more :-). can you explain what you see as a pitfall of adding the electron plugin to all instances?
  closing since this is a dup of #224 
  With the release of #425 in 2.3.0, I've gone ahead and released plugins that will take care of downloads:
- [nightmare-download-manager](https://github.com/rosshinkley/nightmare-download-manager)
- [nightmare-inline-download](https://github.com/rosshinkley/nightmare-inline-download)

I'm considering this issue resolved.  If you have further questions or problems, please open a new issue.
  _Bringing this over from #582._

I had been thinking about was wrapping the Electron instance stdout and possibly stderr up with calls to `debug` (rather than piping them straight through to the parent process stdio).  Then I started thinking about possibly having log levels and _maybe_ introducing something slightly more complex than debug like [winston](https://github.com/winstonjs/winston) or [loglevel](https://www.npmjs.com/package/loglevel).  Thoughts?
 > sending Electronâ€™s stdout/stderr to debug channels like electron:log/election:error

Yep.  I'd agree. :)  Frankly, for now, I think we _should_ keep it simple, routing electron's stdout/stderr through DEBUG.

> Iâ€™m somewhat skeptical that a new, heavier logging tool needs to come along for the ride, but can definitely see ways that doing so might be helpful.

I am too, and I apologize if I didn't make that clear.  I wanted to float the idea to see what everyone thought.  I was tinkering with the idea more seriously after you (@Mr0grog) submitted #579: With the progress events, it might be helpful to add logging there, but would make running Nightmare with DEBUG _wildly_ verbose.  There are probably other events - like any of the events that are simply forwarded - that could be dropped to a lower log level.  My main goal was to help manage verbosity, but that may very well be a misguided early optimization.

winston was at the tip of my brain, and I had to go look up loglevel from a previous project to remember that.  I was throwing out possibilities, they certainly aren't the only two solutions out there.  I'm willing to entertain alternatives.
 @Mr0grog Yeah, it's getting a _bit_ into the weeds. :)

> One simpler thing to do might be just having more granular logging channels, e.g. browser events, script execution, runner actions, queueing, process management, etc. One could potentially manage just as well by message type as by severity.

For sure.  It's a little bit more of a hassle to set up DEBUG rules to get exactly what you want, but I'm on board.

To that end... with an eventual PR, would it be helpful to include common(ish) DEBUG setups over at nightmare-examples, especially as the more complicated parts start coming in?
  what does this fix?
 > I think the page handler should handle variable arguments

+1

then i think we're good to go :-)
 thanks!
  @kanethal Do you have `ELECTRON_ENABLE_LOGGING` set?  It might be worth to check your environment variables against [the Electron environment variable flags](https://github.com/electron/electron/blob/master/docs/api/environment-variables.md).
 @kanethal No problem!

As for them being enabled for 2.0.2, I don't think so.  I don't see the same behavior.  I'd be curious if you'd get the same behavior with a different version.  Could you upgrade to 2.3.0 and run it again?
 @kanethal Did you have any luck with an upgrade?
 Closing due to lack of information/age.  If you're still experiencing this problem, feel free to reopen/open a new issue.
  thanks!
  yikes, thanks for the fix!
  `browser-window` needs to be run by the electron process. it seems it's trying to do: `node runner.js`, which won't work.
 @erch Thanks for the response, sounds like it's resolved.  If this crops up again, feel free to reopen/open a new issue.
  yikes, i had a feeling that API is asynchronous. i don't like adding two methods to do nearly the same thing, but we're definitely going to need to solve this. i'll open an issue on electron to see if they have any advice.
 thanks for this PR, i've added an `.insert()` command based on the feedback here.

`.type()` should be more robust now, but i recommend you use `.insert()` if you don't care about the keyboard events.
  Let's track this issue: https://github.com/atom/electron/issues/3930
 Okay this is turning into a pretty tricky issue. According to atom/electron#3930, there's not a good way to track asynchronous events. Right now I'm considering two options but could use some feedback.

1) Send less events. Programmatically set the value, then trigger the last character's events (like you're just finishing typing something)

2) Keep current functionality. I've tested it manually, and I haven't been able to reproduce this issue on smaller bodies of text (yet), so it at least it seems somewhat rare. Add an point in an FAQ on how to either override or add a custom action like populate to nightmare (via `.action()`)

I'm leaning towards 1), but I could use some feedback :-)
 I'll be adding this once there's a version bump in electron: https://github.com/atom/electron/pull/4080

:-)
 hey guys, sorry for the delay on this, i know this is not in a great state right now.

I tested out `sendInput` and it looks like `sendInput` will not work as I was hoping. it will send `input` events, but not `keydown`, `keyup` and `keypress` events. You can read more about it here: https://github.com/atom/electron/issues/3930#issuecomment-172671004

The goal is to make it as much like pressing keys as we can. Unfortunately, there's no way to send keyboard events serially, so I think the approach I will try next is:

**typing "hi":**

```
focus element
keydown event "h"
keypress event "h"
input event "h"
keyup event "h"
delay 30ms
keydown event "i"
keypress event "i"
input event "i"
keyup event "i"
```

the delay will be used to mimic human typing behavior, but more importantly it should ensure that the events are done in order.

Let me know if you have anything thoughts on this otherwise I plan to fix this over the weekend.

/cc @zcbenz in case he has any other ideas :-D
 this is now in 2.1.5 :-)

i've also added an `.insert()` command to handle entering text when you don't need the keyboard events.
  i believe you can pass something like this to the type function:

https://github.com/atom/electron/issues/2269#issuecomment-147362688

I'm not sure what page down is, but it should be in hex.
  incorporated your changes and tests. thanks!
  yep, dup of #224
  wow awesome, thanks!
  haha woah. really surprised that this hasn't come up before. needs more investigation
  awesome, thanks. we still need to cleanup after our emitters better #282, but at least we won't get that annoying warning all the time.
  generators on their own do not do control flow, you have to pair them with libraries like `vo` or `co`, so your example will never actually run the generators.

To use this library without generators though, you can do:

``` js
Nightmare()
    .goto(url)
    .wait(100)
    .screenshot(savePath)
    .end(fn);
```

or `.run(fn)` if you don't want to stop the electron process after running
  @contra can you try again, this time with `DEBUG=nightmare*`? That may help with debugging this issue. May also be a memory leak.
 Unfortunately, creating a new Nightmare instance for every request seems to also have issues. See #561.
 @contra Are you still experiencing this problem?
 Closing for lack of info/age.  If you come across this problem again, feel free to reopen/submit a new issue.
 @contra I haven't been able to reliably reproduce without a networking issue.  I'll see if I can dig out the test script and try it again against the current version.
 @contra To cut out networking issues, I propped up a server locally to issue requests to (responding with plaintext), then issued 100k sequential requests to that service with a single Nightmare instance.  Nightmare did not hang.  I'm thinking about propping up a minimal HTML payload, then adding javascript and/or HTML and running requests against that to see if it's a caching issue or a memory issue or... something.  If you've got ideas, I'd love to hear them.

@LikeJasper I don't think I've ever seen `debug` behave like that... I wonder if it's interpreting a backspace or non-character escape?  If you could put together a minimum case that reproduces that behavior, I'd love to see that too.
 @contra I'm trying to keep the tests local because I _have_ gotten some aberrant behavior with flaky networks.  (The kind of stuff that is bordering on impossible to reproduce without infrastructure that I just haven't had time to play with yet.)  That's why I was tinkering with the idea of making generated payloads that would simulate multiple assets of varying sizes.  I'd also prefer to keep whatever I'm testing against local as then I'm guaranteed to know what assets are being loaded.  Being able to make assertions about what is being loaded will help narrow what's actually wrong.

It may also be worth introducing an artificial networking bottleneck to simulate poor bandwidth.

At any rate, the biggest problem with these sorts of tests is time: it's going to take some tinkering to figure out a semi-reliable crash condition (if there is one).
 @contra I haven't had time to address this as yet, but I'll post here when I build a working test case. :)
  For those that are running into this, the solution is changing `web-preferences` => `webPreferences`.
  thanks @naturalethic !
  awesome, thanks @rosshinkley!
  @rosshinkley I am new to nightmare, could you please explain how to use partition to share session between multiple instance of nightmare?
 @rosshinkley, In my case, persist does not keep session no matter if I start second instance after or before close of first one
  I believe this issue was fixed in #458, so I'm closing it.  If this is still a problem, feel free to reopen/open a new issue.
  thanks! can you provide a usage example for me? also we'll need tests and an update to the readme.
 closing since #410 landed, thanks guys!
  weirddd. can you give me the code snippet you're using?
 @dingziran Oh, I think it might be electron renaming it's options, try `webPreferences`.
  ahh shoot, hadn't considered that. definitely a bug, if the value is falsey it should probably clear it out.
  interesting, can you explain to me a little more about what the advantage would be? it seems like the module you linked is also a node process that manages electron processes, it can just manage more than one. 

i guess what i'm trying to understand is what the advantage of this approach is over throwing nightmare behind a node cluster (https://nodejs.org/api/cluster.html)
 yah okay thanks, I understand what you mean. I guess the two issues in my mind that i see are:
1. major refactor of the existing codebase (not a huge deal)
2. more importantly, anytime you want to use nightmare, you'd need to run it using the electron executable. this is fine if you're running it standalone, but if you need to integrate it with a node server or something, you're basically rewriting the existing node layer yourself.

i'd be interested in figuring out the proper separation for the electron process to run and be useful standalone if you want to run it on it's own, but for the sake of ease of use, I don't see the node layer going away.
 okay sweet :+1: 
  initial thoughts:
- support adding requires that pass in the window

``` js
electron.plugins.forEach(function (plugin) {
  require(plugin)(win)
})
```

This would happen after the browser window has been initialized
 @rosshinkley i don't see a way you'd be able to pass `parent`, it's transferring over IPC and parent isn't serializable. 

The reason for doing the require is that we could basically tell the electron process to require a file on it's own. I don't like the solution all that much, but I haven't come up with a better one.
 >  I thought the intent was passing paths to require over IPC (or possibly, as command-line arguments akin to paths) and requiring them in the electron process, not vice-versa. No IPC serialization required. Parent should then be passable.

Ahh, sorry I thought you meant `parent` as in the parent process instance. Yep the original intent is passing paths to files and requiring them in the electron process, though I don't necessarily like this approach, so if you think of something better, I'm all ears. Can you clarify what you mean by `parent` because I'm still not fully sure?

> I'll need to take another pass at this when I'm fresh and have coffee. I'll try to carve out some time.

Haha yah me too, answering issues at this hour is ill-advised :-P
 @rosshinkley yah, terrible names haha, should probably change them to `node_process`, `electron_process`, and ... `render_process` (?). yah, I'd like to see what you have in mind. PR or commenting in this issue seem reasonable. Would be nice to see some example code, like how a dev would extend it.
 Implemented in #425, merged in 2.3.0.  Closing.
  yah, i agree that it should wait

is that leading to another page? it should wait for the click to happen if there's a page transition: https://github.com/segmentio/nightmare/blob/master/lib/runner.js#L251-L254 before continuing.

unfortunately, i'm not exactly sure how we'd pull this off if it's just waiting for a click somewhere on the page. we could listen for clicks on the top of the window, but if there's a stopPropagation, somewhere, we won't catch it and we'll wait forever. 

open to ideas.
  awesome, thanks!
  I believe before 2.1.5, the keydown/keypress/keyup events were not getting sent through Nightmare, and I wonder if that's causing you problems.  Could you upgrade and try again?
 Due to lack of attention and issue age, I'm going to close this issue.  If you're still having this problem, feel free to reopen/open a new issue.
  thanks! will change that comment on my end :-)
  thanks!
  thanks!
  thanks for putting this together and i appreciate all the work that was put into this. currently this approach adds too much complexity to the API for solving this issue. 

i've thought about this a little bit and i think a better approach might be:
1. By default ignore all downloads
2. If someone wants to download something, provide `nightmare.download(selector|url)` which returns a buffer. if a buffer is not possible, support `path` in the signature to write to a file.
3. When we are downloading something, wait until that download is complete in order to resume.
4. Potentially support progress events via `nightmare.on('progress', fn)` if that's supported

This reduces the API to just:

``` js
yield nightmare
  .on('progress', fn)
  .download('a[href="/segmentio/nightmare/archive/master.zip"]')
```

One thing we should also consider is... does nightmare even need to support downloads? Or can we get away with:

``` js
var request = require('request')
var fs = require('fs')

var url = yield nightmare
  .evaluate(function() {
    return document.querySelector('a[href="/segmentio/nightmare/archive/master.zip"]').getAttribute('href')
  })

request.get(url).pipe(fs.createWriteStream(__dirname + 'somepath.txt'))
```

Are there any advantages to having this in core?
 @subcontact hmmm.. that's a tough one, have you tried getting it to work with the current PR?
 @rosshinkley thanks for the detailed response!

> I don't understand what you're asking, what should the selector provided do? Click? As for providing a URL, would that be a simple get? And with the buffer, no, I don't think that is possible. Electron supplies the filepath and a method to override the filepath.

Yah, you're right, when I proposed that I was thinking about it in terms of what the click/mouseover/etc methods do, but that's not the same as download. 

> Blocking on each download isn't how browsers work. From a test automation standpoint, I can certainly understand the need, but from a purely automation standpoint, I'm not sure I agree.

I was proposing this to handle `wait('downloads-complete')` piece that you added in this PR. Haven't investigated how that would work internally though.

> Re: getting away with a simple request: no, I don't think you want to do that. If you're making an authenticated request for a resource (thinking of something like a request to a private link in say, Dropbox), you want to do that from within the context of Electron. Copying the resource URI and issuing a plain GET will almost certainly result in failure. This (I think, and I'm sorry if I'm misreading here) gets to what @subcontact's problem - authenticated downloads won't work with simple requests.

From my understanding, a POST request triggers the download, so whether this is a plugin or not, we'd need to at least know how to do that with core.

> Re: keeping at least some form of downloads in core, that's a great question. My answer to that would be a qualified no. How downloads are handled is probably going to be dependent on use case. To that end, I think the blocking .download() and the non-blocking methods in this PR should be broken out into at least one (probably two?) plugins.

Yah, I agree.

> The problem with that is binding to will-download. A new method to hook into will-download with a custom handler could be exposed, or (with modification to pass a child handler) the custom event bindings in #367 could be used. Thoughts?

Yah, I think we should add this regardless, we're already hooking into the other events. Seems like it would be as simple as:

`win.webContents.session.on('will-download', forward('will-download'))`

Then you can hook into it with an action:

``` js
Nightmare.action('download', function () {
  this.child.on('will-download', handler)
})
```

Haven't thought through exactly how this would work, but that would be the approach I would investigate.
  okay this should be fixed now in `2.1.0`, let me know if it's still broken!
  woops, thanks!
  hm, did you try:

``` js
Nightmare.action('evaluValue', function*(value, cb, done) {
  var test = yield this.evaluate(cb);
  assert.strictEqual(test, value, 'evaluValue() ' + errorMessageHelper(value, cb));
  done();
});

yield Nightmare().evaluValue('some value', function cb() { ... } ) 
```

?
 hmm, that looks okay to me. that's just not working at all? 
 yah, i agree with @rosshinkley. `use` let you bundle a set of actions together, while `action` defines a new method. let me know if this is unclear and maybe i can clear it up in the docs
  May add support for this, but it's really easy to support with `.evaluate`:

``` js
yield Nightmare()
  .goto('http://google.com')
  .evaluate(function (selector) {
    return document.querySelector(selector).textContent;
  }, '.selector')
```
  Yah it should probably be hidden by default, right now I just want Nightmare to be more stable before hiding it, because if there's errors you can end up with a ton of open electron processes. There's logic in the code right now to hide it, but it's commented out: https://github.com/segmentio/nightmare/blob/master/lib/runner.js#L34-L38
 The default is now to hide it. This issue will serve as a reminder to add an option to show it.
  can you try again? i just released a new version
 @contra ahh, are you seeing it hang forever if the initial page load fails? right now it's only initialized when you call `.wait()` before a click or something. that should be fixed.
 @contra Depending on the kind of page load failure, #553 _might_ address your issue.

@joychester I wrote two quick test cases:

**nonexistent element**

``` js
var Nightmare = require('nightmare'),
  nightmare = Nightmare();

  nightmare.goto('http://www.example.com')
    .wait('does-not-exist')
    .end()
    .then(function(){
      console.log('done');
    })
    .catch(function(err){
      console.dir(err);
    });
```

**function that never returns true**

``` js
var Nightmare = require('nightmare'),
  nightmare = Nightmare();

  nightmare.goto('http://www.example.com')
    .wait(function(){return false;})
    .end()
    .then(function(){
      console.log('done');
    })
    .catch(function(err){
      console.dir(err);
    });
```

Both error out with the appropriate error message after 30s.  Can you provide a minimal example that causes nightmare to hang?
 @joychester Ah!  Thank you for providing an example.  I can reproduce the behavior you're seeing.  I'll dig into it and see what is going on.
 @joychester A quick look yields that `webBrowser.evaluateJavaScript` is hanging once in a while and not calling back.  Electron doesn't have any errors when it happens.  This problem is not unique to StubHub - it happens with Yahoo and Youtube as well.  I'm not 100% sold that waiting for an element created after DOM content loaded is the cause, or that the site is an SPA.  

(As an aside, I can hack around it by forcing the `javascript` handler to poll if the callback has been called, but that is terrifyingly hacky.) 

Some tinkering shows me that it's not necessarily iframes, slow loads, load failures, or particularly large assets (or any combination).  I'm still hunting for a root cause/minimum reproduction case.
 @Mr0grog set me straight: it does have to do with iframes and timing.  Quote:

> If you call WebContentsâ€™s executeJavaScript() method after the main frame finishes loading, but while a subframe is loading, the JS will never get executed and the call will never complete (unless you navigate the main frame to some new page).

See electron/electron#5183 for details.
 Should be fixed with #588.  Closing.
  Hey thanks for the PR! I think we should actually group these events: https://github.com/segmentio/nightmare/pull/337

I should have considered this before accepting the alert one, but I'm thinking something along the times of: 

`nightmare.on('page', function (type, message[, response])`

---

As far as the preloading stuff, I don't think it's a great idea to completely allow you to overwrite it because as we make changes to the API, those people that overwrite it will be completely out of sync. Are there specific use-cases that we should allow custom hooks into the preload script?
 Beautiful. I like this a lot. I like how you were able to consolidate all these into `page`. I think what you did with the custom preload script is good too. Two things I'd like to explore:
1. Is it possible to maintain the syntax highlighting on the preload script? I've noticed it's pretty error-prone working with functions as strings. Not a huge deal though since we're doing it in other places.
2. Is it possible to have the custom preload script to be a function that passes in the IPC

``` js
function (ipc) {
  window.confirm = function(message) {
      var response = false;
      if(message == 'foo'){
          response = true;
      }
      ipc.send('page', 'confirm', message, response);
      return response;
  };
}
```

That might look be a little nicer way to extend the preload script and also authors don't need to know anything about the internal __nightmare.ipc
 Thanks for this PR! I've incorporated these changes into master!
 One thing I left out was the preload templating stuff (probably due to my suggestion :-/), but I think it's less complicated to just include a path to your own script.
 yah me too :/, but the added complexity wasn't worth it imo
  if you're not able to catch the event as the window via inject, it  can be fixed with a custom preload script outlined here: https://github.com/segmentio/nightmare#custom-preload-script
 let's see if more people need this. there's a million things nightmare _could_ do, it's up to us to make sure the API remains simple, while not being limiting.
 @nquoctuan I'm _almost_ positive that the path for `preload` has to be fully qualified.  What happens if you change that to `preload: require('path').resolve('alertMessage.js')`?  There's some info in this PR: https://github.com/segmentio/nightmare/pull/241/files. Unfornately, it's really out of date at this point. Would love for you to open up a new PR :-)
  With the release of #425 in 2.3.0, I've gone ahead and released plugins that will take care of downloads:
- [nightmare-download-manager](https://github.com/rosshinkley/nightmare-download-manager)
- [nightmare-inline-download](https://github.com/rosshinkley/nightmare-inline-download)

I'm considering this issue resolved.  If you have further questions or problems, please open a new issue.
  thanks!
  thanks!
  thanks @danielstjules! i think the API should be `nightmare.header()` and then support the following:

`header(header, value)`
`header(obj)`

what do you think?

the rest looks good!
 > And any reason for preferring a singular nightmare.header as opposed to the original nightmare.headers

yep and most the APIs that I've seen that have this kind of signature are singular. ex. http://api.jquery.com/attr/
 thanks @danielstjules !
  Sweet! I think the API should be `.bind(...)` though. It's more familiar to folks: 
- http://api.jquery.com/bind/
- https://github.com/component/event
 glad you asked, yep i don't care about the data attribute at all. hmm, what about keeping these separate from `nightmare.on(...)`, where it's like:

``` js
nightmare.bind('some-custom-event', function () {
  // custom event triggered
})
```

that would make unbind more clear-cut:

``` js
nightmare.unbind('some-custom-event', fn) // remove that function
nightmare.unbind('some-custom-event')     // remove all functions
```

what do you think?

---

Otherwise `nightmare.bind('some-custom-event')` could work too, just not sure how to deal with the unbind case.
  sweet! looks great :-D
  Thanks for the PR! Mentioned this in another PR, but I think the API should be:

`nightmare.scrollTo(top, left)`
`nightmare.scrollTo(selector)`

Where scrollTo supports both. What do you think?
 @Kreozot haha, yah i was thinking about that... not sure how it'd look unless we break the API. I guess we could maybe do:

```
.screenshot(path, [selector], [, clip])
```

Almost wondering if it just makes more sense to just use an object, which wouldn't break the API:

``` js
.screenshot({
  path: ...,
  selector: ...,
  x: ...,
  y: ...,
  width: ...,
  height: ...
})
```

---

Also, how does this handle multiple elements on different parts of the page by the way?
 @highvoltag3  I'm still open to this PR, but the source is well out of date and would need to be updated.  Additionally, I don't think @matthewmueller's comments were ever addressed.
  It'd be nice to overload the `.scrollTo` method to support `.scrollTo(selector)`, rather than implement a new method.
  Awesome! So we're planning on making this a little more high-level, so `.click(...)`, `.rightclick(...)`, etc. will use this function internally to execute their events.

Let me know if you want to hack on this, otherwise I'm planning on working on it sometime this week or the next.

Going to close this one, but it's super helpful as a reference. Thanks!
 Wow that's really cool. I'm wondering if that would make more sense as a plugin once we land actions/use.  What do you think?

Thanks for the heads up on the electron warnings!
  the more i think about this, the more i think this makes sense as a plugin. i'll be adding plugin support via `.use(...)` today
 Okay, I've added `Nightmare.action` to support this PR. Here's how you'd do it:

``` js
Nightmare.action('screenshotSelector', function (path, selector, done) {
  debug('.screenshotSelector()');
  if (typeof selector === 'function') {
    done = selector;
    selector = path;
    path = undefined;
  };
  var self = this;

  this.evaluate_now(function (selector) {
    var element = document.querySelector(selector);
    if (element) {
      var rect = element.getBoundingClientRect();
      return {
        x: Math.round(rect.left),
        y: Math.round(rect.top),
        width: Math.round(rect.width),
        height: Math.round(rect.height)
      };
    }
  }, function (a, clip) {
    if (!clip) {
      throw new Error('invalid selector "' + selector + '"');
    }
    self.child.once('screenshot', function (img) {
      var buf = new Buffer(img.data);
      debug('.screenshotSelector() captured with length %s', buf.length);
      path ? fs.writeFile(path, buf, done) : done(null, buf);
    });
    self.child.emit('screenshot', path, clip);
  }, selector);
})

// run
yield Nightmare()
  .goto('http://google.com')
  .screenshotSelector('google.png', 'title')
```

Looking at this closer, you could probably simplify and use `nightmare.screenshot()`, once you have the clipping coords

Does this work for you?
 @felixcrive, sorry i'm not sure what you mean, do you mind showing me what you mean?
 best supported as a plugin  looks good! just a minor documentation tweak and we should be good to go!
 ah thanks good catch!
  thanks! this has been added via `nightmare.cookies.get(name)` in #360 
  I think the way to this would be to use the `ipc.send('customevent', args)` functionality to send your events, which is in scope: https://github.com/segmentio/nightmare/blob/master/lib/javascript.js#L21-L24

There would need to be some addition logic on nightmare to set up the event forwarding in the electron process. Something like: `nightmare.bind('customevent', fn)` in: https://github.com/segmentio/nightmare/blob/master/lib/nightmare.js#L225-L228

Which would tell the child (runner.js) to listen for that custom event and forward onto the node process (nightmare.js): https://github.com/segmentio/nightmare/blob/master/lib/runner.js

Probably won't get around to implementing this myself, but I'd accept a PR that implements this :-)
 @fentas Custom eventing is now a plugin: [nightmare-custom-event](https://github.com/rosshinkley/nightmare-custom-event).  I'm going to go ahead and close this item.  If you have any more questions, feel free to reopen/open another issue.
  Awesome! Just want to figure out how we should document this change.
 sorry for the late response on this, looks good. just need to fix up the typo and we're good to go
 thanks @atonparker !
  It may be worth looking at [this comment](https://github.com/segmentio/nightmare/issues/510#issuecomment-189782115).  I wrote a plugin to at least partially handle this case.

Merging this into #593.
  awesome, thanks!
  @yonatanmn Everything passed from Nightmare to Electron is serialized, and functions do not serialize nicely.  If you find that you need methods in `.evaluate()` commonly, you may want to look into defining a custom preload.
  Closed with `sendInputEvent` and `.action()` being exposed.
  #345 has been fixed, and this issue has not had activity in quite a while, so I'm going to close it.  If you have any more questions, feel free to reopen or file a new issue.
  nothing planned, but we'd like to support proxies at some point, here's a good place to start #241. We'd gladly accept a PR :-) 

Closing since this is a dup of #372 
  @ilabvb did you get this resolved?
 Closing for lack of activity.  If this is still a problem, feel free to reopen or file a new issue.
  @nathan-martinez Are you still experiencing this problem?

If so, you might want to take a look at [`.header()`](https://github.com/segmentio/nightmare/blob/master/lib/nightmare.js#L195-L200).  That allows you to set headers directly.  (There isn't documentation for it, I opened #551 for that.)
 Closing for inactivity.  If this is still a problem feel free to reopen/open a new issue.
  may i ask what the usecase is here? the window should be hidden in nightmare, so i'm not sure why you'd want to move it.
 ahh i see. this definitely seems like something that should be a plugin. let me think about how we can expose this type of functionality

we'll basically need to be able to add functionality to the electron process.
 @lexifdev With the additions to `.action()` with #425, this could be implemented as a plugin.  Feel free to open up an issue or join the gitter room if you have questions.

Closing.
  please fix up the spacing and this should be good to go!
 @inversion yep, good call. planning on adding standard.
 now on master, thanks @inversion !
  Hm, can you explain the use case a little better? I was sort of thinking about it in terms of stdout and stderr. I believe console.warn goes to stdout. 

The downside I can see with this is that you might end up missing events if you don't hook into all the correct events. Also what about for events coming from `console.info` and `console.debug`?
 got it. yep I love it: `nightmare.on('console', function (level, msg, ...) { ... })`

or `page-console` whatever you think makes more sense.
  Haha when I opened that issue, I forgot about `.use(...)`. What do you guys like better `Nightmare.action(action, fn)` or `Nightmare.use(fn)`? Maybe there's a reason to have both, but I can't really think of anything off the top of my head.

Going to rope in the .use people too.
 Just added both `use` and `action`. Here's some more information: #376 
 Thanks for the PR @inversion ! I incorporated these changes in #376 
  you can use `1.x` but otherwise i don't believe so
  With the release of #425 in 2.3.0, I've gone ahead and released plugins that will take care of downloads:
- [nightmare-download-manager](https://github.com/rosshinkley/nightmare-download-manager)
- [nightmare-inline-download](https://github.com/rosshinkley/nightmare-inline-download)

I'm considering this issue resolved.  If you have further questions or problems, please open a new issue.
  yah, i think you'd want to do this outside of nightmare, unless electron provides support for it as an option, i don't think we'll support this in core.
  thanks @rosshinkley for the example :-)
  yep, that's what we're using internally to communicate. do you mind explaining your use case a little better?
 Closing for lack of activity.  If this is still an issue, please feel free to reopen or file a new issue.
  i think this might be an underlying electron issue?
 yah, you should open this up with electron
  definitely interested... language settings and basic auth could maybe be supported now too?
 seems like allowing a sticky `.header()` and then the additional parameter for loading a single url?
  thanks @Zn4rK, that's 100% correct!
  can you narrow down where the error might be occurring?
 @chentsulin @TonyWang031 Depending on the version of jQuery being injected, they could end with sourcemap comments, which would cause the end of the calling function that encapsulates the injected script to be commented out, causing a runtime error.  I would be willing to bet this is what you were hitting, given the unminified version worked but the minified version wouldn't.

The template was fixed in #524, so I am going to go ahead and close this issue.  If you still have problems, feel free to reopen/submit a new one.
  could this be related to #320?
 Upon further investigation, I can't recreate this behavior.  Doing something like:

``` js
var nightmare = require('nightmare')(),
  vo = require('vo');

var run = function * () {
  return yield nightmare.goto('http://example.com')
    .evaluate(() => document.title)
};

vo(run)(function(err, val) {
  console.dir(val);
});
```

@edasque @smallcar88 @davis Are you still experiencing problems with `.evaluate()` and fat-arrow functions?
 @davis Hm, I'd be curious what transpiler you were using - it _should_ have worked.  At any rate, the ES6 features you needed are now supported out of the box with Node 4+, so I'm going to consider this issue closed.  If you continue to have this problem, feel free to reopen/open a new issue.
  Wow. This would explain a lot of the inconsistencies.

I _think_ we should be good on the onload stuff since we're injecting JS at the bottom of the page, but can you think of any case where not waiting for the `onload` event could break things?

/cc @reinpk 
 i'm good with this!
 yeah sorry haven't had time to read over the code yet, soon sorry!
 Okay going to merge this as it seems like it's helping out a lot of folks. Haven't dug into the internals yet, but I'm sure we can make changes if issues crop up.

Great work @fr- !
  hm, i thought we already did this:
- https://github.com/segmentio/nightmare/blob/master/lib/nightmare.js#L210-L215
- https://github.com/segmentio/nightmare/blob/master/lib/runner.js#L333-L347

basically after every action we check to see if the page is navigating, then wait until it stops loading.
 @Zn4rK #425 is in as of 2.3.0.  Are you planning on publishing a `.waitForUrl()` plugin?
 @Zn4rK Awesome!! Thanks!
  good catch!
  sorry i'm not sure, been a long time since i had a pc around :/ stackoverflow is the better source for these path questions!
  the question doesn't make much sense for a web-driver automation library :) closing
  the question doesn't make much sense for a web-driver automation library
  @emgould Everything there looks fine to me.  Are you still having this problem with later versions of Nightmare?
 Due to lack of attention and issue age, I'm going to close this issue.  If you're still having this problem, feel free to reopen/ file a new issue.
  @juliangruber nice!
  check out `did-get-response-details`:
https://github.com/segmentio/nightmare#onevent-callback
 @scarletsky as far as i know you'd need to filter for the resource you are looking for yourself
  not sure tbh, that would depend on the underlying electron implementation, which nightmare just passes through to:
- https://github.com/segmentio/nightmare#pdfpath-options
- http://electron.atom.io/docs/v0.30.0/api/browser-window/#webcontents-printtopdf-options-callback
  nightmare is specifically designed to be used with generators in es6+, so i think that'd kinda defeat the purpose. you can use nightmare `1.x` if you want to avoid generators/es6 though
  @kevinprotoss @fr- Could you use `.header()` to accomplish this?
 Closing as I think this is solvable with the existing implementation.  If this is still an issue, feel free to reopen or open a new issue.
  sorry for the late response. this is on master now. thanks!
  errors bubble up from `.evaluate()` in my testing... try running this modified example from the top of the readme:

``` js
var Nightmare = require('nightmare');
var vo = require('vo');

vo(function* () {
  var nightmare = Nightmare({ show: true });
  var link = yield nightmare
    .goto('http://yahoo.com')
    .type('input[title="Search"]', 'github nightmare')
    .click('.searchsubmit')
    .wait(200)
    .evaluate(function () {
      return document.getElementsByClassName('GARBAGE-CLASS')[0].href;
    });
  yield nightmare.end();
  return link;
})(function (err, result) {
  if (err) return console.log(err);
  console.log(result);
});
```

The output I get is `Cannot read property 'href' of undefined`.
  ah sorry, I just saw this one. the other one has been merged. this looks good too. thanks!

mind resolving the conflicts? then i'll merge this one
 thanks @antpaw !
  @nicolekanderson Did you get this sorted out?  If not, have a look at [Nightmare's test suite](https://github.com/segmentio/nightmare/blob/master/test/index.js).

@miaomi Hm, the errors look like `electron-prebuilt` is either not installed or didn't install properly.  Try wiping `node_modules` and running `npm install` again.

@WMeldon It's best practice to end the Nightmare instance when you're done.  Otherwise, the child process will remain running forever and you will (rightfully) get Mocha timeouts.
 I'm going to go ahead and close this issue due to age, lack of activity, and that I _think_ it's resolved.  If this is still an issue, feel free to reopen/open a new issue.
  leaning -1 on this change, though fairly indifferent. the reason for this is because it's added syntax and i think most people in the node community (also webpack and browserify world) understand commonjs at this point. 

i do agree that `exports` shouldn't have made it into the spec though.
 closing this. i think we're going to stick with `exports` for the time being. thanks!
  whenever i see this change, i always wonder about the benchmarks, since we're wrapping every function in another function, as opposed to just pointing to `this` ref. do you have any benchmarks of this being a negligible perf change? doesn't have to be nightmare specific but just in general?
 @rosshinkley yep this is exactly what i was looking for:

![img](https://cldup.com/LwkeRajv9Q.png)

even though it's a micro optimization, i don't think using `self` is much worse syntactically. 

closing for now, thanks guys!
  Sweet! So I thought about this a bit more. One issue I have with the event name:

1) it's inconsistent with the existing event names: https://github.com/atom/electron/blob/master/docs/api/browser-window.md#events

I think for this reason, it should be something like: `page-error` and `page-log`.

The only other thing that would be good is squashing the commit, so it's more concise in the commit log. 

Otherwise looks good, thanks!
 Thanks @antpaw !
  sorry, what does this do? we've ended up fixing the test bug, so i'm trying to understand what these updates do
 what's the electron bump fix?
 awesome, thanks! i went ahead and bumped these deps
  personally like having the makefile for `make test`, but it's kind of frivolous for this case anyway. thoughts @reinpk ?
 @tejasmanohar yep, i like that more. I think we should keep the makefile, but the other stuff looks good!
 thanks @LarryBattle this is on master now!
  sweet, we should probably namespace this like we did with `options.paths`. `{ chromium: { http-cache: false } }` maybe? 

anyone have any other ideas?
 yep, this can be solved using switches. thanks for the PR!
  You have to wrap it in `co` or `vo`

``` js
vo(function * () {
  var Nightmare = require('nightmare');
  yield Nightmare()
    .goto('http://yahoo.com')
    .type('input[title="Search"]', 'github nightmare')
    .click('.searchsubmit');
})(function (err) {

})
```

@reinpk maybe we should change this to avoid confusion
 thanks! updated here: https://github.com/segmentio/nightmare/blob/master/Readme.md#examples
  yeah, it appears to be an underlying bug in chromium: https://github.com/atom/electron/issues/2797

unfortunately going to close here since it's several layers down :/
  So this would be for page errors, right? Because we already have: https://github.com/segmentio/nightmare/blob/master/lib/javascript.js#L25

Also, I'm not a huge fan of abbreviations and would prefer `javascript error` or `page error` to avoid confusion with your own code causing errors, but if there's previous precedent for this, then we can keep it.
  yikes, just noticed this. thanks!
  thanks! gonna close as a duplicate of #224 as @LarryBattle mentioned
  thanks!
  you're mixing generators in incorrectly... if express supports generators instead of functions with callbacks it'd be something like this:
- function passed to `router.get` is now a generator
- `yield` the `getPrice` function to get the result before sending it along
- no need for `.run()`

``` js
router.get('/', function* (req, res, next) {
    var getPrice = function* () {
       console.log('hello');  // <-- never even logged
        return yield Nightmare()
            .goto(MY_URL)
            .evaluate(function () {
                return document.querySelectorAll('.price-total .animated')[0].innerText;
            });
    };
    var price = yield getPrice();
    res.status(200).json(price);
});
```
  no additional requirements, but added another complete example here: https://github.com/segmentio/nightmare#examples

you can also try the `DEBUG=*` flag to see what's happening:
https://github.com/segmentio/nightmare/blob/master/Readme.md#debugging
  The nice thing about generators is that you can use them inside control flow loops, so you could  do something like:

``` js
while (pages.length) {
  var page = pages.pop()
  var response = yield nightmare
    .goto(page)
    .evaluate(fn)
}
```
  if you're running these things concurrency, it's pretty easy to run into:

```
(node) warning: possible EventEmitter memory leak detected. 11 uncaughtException listeners added. Use emitter.setMaxListeners() to increase limit.
```
  looks good, hopefully this will solve some errors. thanks!
  https://github.com/segmentio/nightmare#end
  sure, if it'll fix some issues, it doesn't really matter to me
  what's the url? 
 @jney Is this still an issue?
  based on my searching, i don't believe this is possible with electron, but happy to reopen if someone finds otherwise! sorry :/ definitely see the utility there...
  awesome, looks good. thanks!
  https://github.com/segmentio/nightmare/blob/master/Readme.md#examples

sorry fellas, just updated the examples to fit with yahoo.com's classname changes
 @nhducit Memory serving, the default Mocha timeout is something like 2s.  The test suite sets this to [10s](https://github.com/segmentio/nightmare/blob/master/test/mocha.opts#L2).

It might be more helpful to put an example mocha command to run with the test options.  Thoughts?
  @fritx Are you thinking of something like [`webContents.paste()`](https://github.com/electron/electron/blob/master/docs/api/web-contents.md#webcontentspaste)?
 Adding edit actions could be accomplished with `.action()`.  

With the ability to do so, I'm considering this issue resolved.  Closing.
  nope! sorry about that
  cool, thanks!
  duplicate of: #224 
  good catch!
  hey all, i'm not able to reproduce this or really understand exactly what the issue is â€” if this is still an issue can you summarize the current state/knowledge of the issue?

from my reading of this, you can get rid of `.run()` as that's a `1.x` syntax that isn't needed in `2.x`... see the readme: https://github.com/segmentio/nightmare/blob/master/Readme.md
  cool thanks!
  looks good, thanks!
  @toppetoppe i modified your example slightly and ran it locally:

``` js
var vo = require('vo');
var Nightmare = require('nightmare');


var url = 'http://www.jm.se/bostader/sok-bostad/#c=stockholm&ts=allapartmenttypes&vacant=true&tab=objects&listmode=box';
var selector = '#hitcountobjects';

vo(run)(function(err, result) {
  if (err) throw err;
});

function *run() {
  var nightmare = Nightmare({ show: true });
  var count = yield nightmare
    .goto(url)
    .wait(5000)
    .evaluate(function (selector) {
      // now we're executing inside the browser scope.
      return document.querySelector(selector).innerText;
    }, selector);

  console.log(count);
  yield nightmare.end();
}
```

with the following output:

```
(114)
```
  thanks!
  I think you'd have to yield on it:

``` js
yield nightmare.end()
```
  check out `did-get-response-details`:
https://github.com/segmentio/nightmare#onevent-callback
  FWIW `.then()` is undocumented and part of the private API. May change this going forward, but right now the only reason we have it in there is so we can yield on any piece of the chain:

``` js
yield Nightmare()
  .title()
```

`.screenshot()` should definitely be yieldable, that's a bug. can you provide a failing case?
 yep it can, among other things. vo is using co internally, and co has: https://github.com/tj/co/blob/master/index.js#L100

I'm down to explore integrating actual promises, I just don't want it to complicate the implementation or add a big dependency for something that could probably be implemented cleaner with generators.
 Guys, I can see why this is confusing but you are thinking about it in terms of how it should work with promises, which is part of the private API and undocumented.

``` js
nightmare
.screenshot('./example.png')
.then(function() {
  debug('Screenshot taken');
})
.end();
```

This looks like it should work but you're not handling the error case so it's tough to say whether it's a bug in nightmare or a bug in your code. The following adjustment will determine this:

``` js
nightmare
.screenshot('./example.png')
.then(function() {
  debug('Screenshot taken');
}, onerror)
.end();
```

Please open up a new issue if you still can't get to the debug statement.

---

Like I mentioned, I'm open to accepting a PR to implement promises, but it should be small and concise.
 Guys, this is where we left off:

> Like I mentioned, I'm open to accepting a PR to implement promises, but it should be small and concise.

No more comments please, just open a PR.
  yeah, you can do that in javascript with the `.evaluate()` method, check out the implementation of `.click()`:
https://github.com/segmentio/nightmare/blob/master/lib/actions.js#L77
  No longer used in 2.x, as your pipeline will return a generator you can `yield` instead. For `.end` documentation see the [readme @1.x](https://github.com/segmentio/nightmare/blob/1.8.2/Readme.md)
 whoa i totally jumped to an early conclusion on this one, confusing `run` with `end` â€” my apologies!
 added brief docs: https://github.com/segmentio/nightmare#end

is there a specific behavior you're looking to see documented? thanks for the find!
 Same API as run, only difference is that it'll shut processes down.

``` js
yield Nightmare()
  .goto('https://github.com')
  .evaluate(fn)
  .end()
```

Or

``` js
Nightmare()
  .goto('https://github.com')
  .evaluate(fn)
  .end(onEnd)
```

or 

``` js
var nightmare Nightmare()
  .goto('https://github.com')
  .evaluate(fn)
  .run(onRun)

nightmare.end(onEnd)
```

you get the point
  generators on their own don't do the control flow, something like `co` or `vo` do this. you can use traditional callbacks for thennables if generators aren't your thing.

created a gist a while back to help me understand raw generators: https://gist.github.com/matthewmueller/9b8b59d552f90425ee41. not sure if this is helpful to anyone
  thanks!
  @FdezRomero @CatTail @kazinov @tjokimie I cannot reproduce this problem.  Has this issue been resolved?
 I'm going to consider this issue resolved.  If this is still a problem, feel free to reopen/submit a new issue.
 @deffwe If you have a minimum repro, post it and I'll reopen this issue to take a look.  Thanks for the PR! Can you explain in a little more detail what this does to fix the problem? Some questions I have:
- Was the missing semicolon causing us to not get the errors?
- What's the purpose of preloading and disabling node-integration?
 thanks buddy, appreciate the research!

i'm fine with changing the tests to point to github to avoid the great firewall. open a pr and i'll accept :+1: 
  hahaha, we've all been there ;-)
  Looks like Electron added support for `sendEvent`. We should replace probably replace our synthetic events with the real ones: https://github.com/atom/electron/issues/2269#issuecomment-142504305
 `.type()` uses `sendInputEvent`.  I believe this can be closed.
  i removed plugins and `.use()` from the initial release of `2.x` but totally open to bringing them back
 This is because we can now do `yield`s right?
 +1. `.use(fn)` is still useful in the context of `yields`. generators just allow you to use regular programming control flow (if, for, while) in addition to chaining.
 hey guys, please weigh in here: https://github.com/segmentio/nightmare/pull/336#issuecomment-161708889
  It really should propagate through. Are listening to the `nightmare.on('error')` event?

Here's the client-side implementation: https://github.com/segmentio/nightmare/blob/master/lib/javascript.js#L21-L26
  Wow awesome! Definitely think both of these features should be in Nightmare.

Two things:
- Would be good if you could open 2 separate PRs since these features are unrelated and it allows us to discuss each feature separately
-  Not too keen on the API for cookies. I think it should look more like the express/koa cookie getters and setters: https://github.com/pillarjs/cookies

The `tl;dr`:

``` js
cookie(name, value) // set a cookie 
cookie({ a: value, b: value }) // set multiple cookies
cookie(name) // get a cookie
cookie(name, null) // delete a cookie
cookie(null) // delete all cookies
```

Looking forward to seeing these features in nightmare!
 Yah if its not too much work, I'd branch off master and cherry pick from
this branch then push new PRs.

I really like this PR except for the API. Not sure that you need to do
anything more (promises/yields) than just do some argument checking with
.cookie(...)

Re: proxy Api. I think you should support whatever mongodb
client/socketio/redis client support. I believe thats a string you parse or
multiple arguments, but it'd be good to have a consistent signature

Thanks again for the hard work!
On Wed, Sep 23, 2015 at 02:18 Georgy Chirkov notifications@github.com
wrote:

> Also i thought that you should set proxy as
> .proxy(host, port, protocol)
> 
> â€”
> Reply to this email directly or view it on GitHub
> https://github.com/segmentio/nightmare/pull/241#issuecomment-142538877.
 Would love to see this fixed up and merged!
 I've added cookie support to master. I'd love to see a new PR for just the proxy support :+1: 
 Closing for now, since this is woefully out of date. Would love to see someone open up a new PR with proxy support though!
  no worries man, we were all new to this stuff at one time

1) vo uses a technique called [currying](https://medium.com/@kbrainwave/currying-in-javascript-ce6da2d324fe). Comes from functional programming, and allows you to progressively build up functions before executing. The reason this is useful is that it allows for you to easily compose pipelines together: `vo(vo(...), [vo(...), vo(...)])(done)` for example.

Truth be told, I wasn't planning on keeping `vo(...)` in here, it's just a library that I like. You can easily use nightmare in other ways, using `co`, `promises` or callback functions. What I'd like to avoid is like what's going on in the react community, where it's just expected you know ES6, JSX, React and Flux to get started on just about any documentation, so let me know if this is preventing you from understanding nightmare better.

2) Nightmare stores cookies across requests, but not across processes. This means that when your node program ends, the cookies are gone. We may add a way to load cookies, but I think it's actually more resilient to go though the login logic each time as opposed to loading temporary cookies each time. Downside of course is that it's slower and might be suspicious that you're logging into the same account many times.
  yep three ways:
1. the debug flag: https://github.com/segmentio/nightmare#debug
2. listen for specific events https://github.com/segmentio/nightmare#onevent-callback
3. pass `{ show: true }` to the nightmare constructor to have it actually create a visible, rendered window that you can watch what's happening: https://github.com/segmentio/nightmare#nightmareoptions
 added docs here: https://github.com/segmentio/nightmare#debugging
  yeah i also had problems running parallel instances of nightmare `2.x` on the same machine (macbook)
 my suspicion is that it's somewhere in the ipc mechanism, but i'm not sure exactly how to pinpoint it off the top of my head. would be surprising if the electron processes/windows had any shared state like that.
 Possibly related to #493?
 @ndamjan Are you still experiencing this problem with more recent versions of Nightmare?
  :dancer: code deletion i love it
  yikes, it shouldn't have. x-ray will be a user of new nightmare very soon though ;-) just trying to work out the details
  not sure off the top of my head. two things to check:
- https://github.com/atom/electron/blob/master/docs/api/browser-window.md
- browser events we can trigger programmatically. i would start here: https://github.com/component/file-picker
 Added as a [plugin](https://www.npmjs.com/package/nightmare-upload).
 As the plugin should solve this issue, I'm closing it.  If you have questions/problems, feel free to reopen/open a new issue.
  <3
 i'll fix this up on master
 released as `2.0.5`, thanks!
  had just noticed this myself haha, awesome thanks! 
  cool, so what would cause this situation to come up?
  hey dan, yep the new usage would look something like this:

``` js
var Nightmare = require('nightmare')
var vo = require('vo');

vo(function* () {
  var url = yield Nightmare()
    .goto('http://google.com')
    .screenshot('goog.png')
    .url();
  console.log(url);
})(console.log);
```
  Looks like a dup of: https://github.com/segmentio/nightmare/issues/224
 closing as dupe of #224
  Hm... that error is usually the result of another error crashing the process. Was there any more errors associated with it? We could use some more error output to diagnose
 added docs here: https://github.com/segmentio/nightmare#debugging
  Hey there! I'm not sure exactly what's going on here just yet â€” what version of nightmare do you have installed? (looks like 1.x, have you checked out 2.x?)

One thing that jumps out at me is I'm not sure if node will be able to interpret the element object passed to the second function in evaluate. Could you try this instead?

```
...
.evaluate(function (){
    return document.querySelector('body').innerHTML;
  }, function(res){
    console.log(res) 
  })
.run(function(err, nightmare){
    if (err) return console.log(err);
    console.log('I'm awesome!');
    })
```
 gotcha, makes sense then! the method signature for evaluate changed in `2.0.0`, it only takes a single callback function now that the IPC works a bit differently: https://github.com/segmentio/nightmare/#evaluatefn-arg1-arg2

looks like you're after something along the lines of:

``` js
var body = yield nightmare()
  .viewport(1000,1000)
  .type(login.idfield , login.id)
  .type(login.pwfield , login.pw)
  .click("input.cartaccountlogin")
  .wait()
  .goto('ANOTHER URL')
  .wait()
  .evaluate(function (){
    return document.querySelector('body').innerHTML;
  })
```
 boom! psyched to hear it. 
  Probably need `node --harmony index.js`
 closing as a dupe of #228 
  Yikes, major issue. 

![img](https://cldup.com/dAy_dE48-X.png)

Seems like the electron linux binding is broken or something. Anyone have any ideas?
 Okay. I'm not exactly sure how to codify this right now (or what layer to support this in), but to get it working on the official node (docker) image, you need to do the following:

``` bash
# Install dependencies
apt-get update &&\
    apt-get install -y libgtk2.0-0 libgconf-2-4 \
    libasound2 libxtst6 libxss1 libnss3 xvfb
npm install segmentio/nightmare

# Start Xvfb
Xvfb -ac -screen scrn 1280x2000x24 :9.0 &
export DISPLAY=:9.0

# Test it
apt-get install vim
vim index.js
# <paste in example>
node index.js
```

More info: https://github.com/atom/electron/issues/228
Dockerfile: https://github.com/aheuermann/docker-electron

---

Could use some help on getting this bug resolved.
 Oh I don't think this is it, but can you try running master? `npm install segmentio/nightmare` ?

I upgraded it to fix: https://github.com/mafintosh/electron-prebuilt/issues/54#issuecomment-140625958
 @richard5mith i'm not very familiar with `xvfb`, by `xvfb-run` do you mean the instructions i provided? or is there a simpler way?

I think it's starting a server (`Xvfb -ac -screen scrn 1280x2000x24 :9.0 &`), which is something I'd like to avoid. or at least have a good way to clean up after we quit.
 Nice! Now just need to figure out the best way to get these dependencies on linux boxes (without using custom buildpacks or anything)
 Thanks man, unless I'm missing something I think this should do it though: https://github.com/segmentio/nightmare/issues/224#issuecomment-141575361. Or are you talking about without node dependencies? 

I think the remaining items to sort out are:
- [ ] When do these installation procedures happen? Is this a `postinstall` script, a node-gyp thing, or is it something that shouldn't even be handled in this library?
- [ ] Verify that we can run `xvfb-run --server-args="-screen 0 1024x768x24"` across multiple processes (in other words, running two of these spawn commands at once on the same machine)
- [ ] Ensure that we're cleaning up the xvfb server after we execute (when the node process exits)

I plan on looking at this sometime this week or weekend, but any time offered sorting this stuff out would help accelerate this fix.
 Would be good if we could get some sort of post install script going so it just worked on heroku. Sorry guys, I haven't had much time to look into this lately, but hopefully we can get this sorted out soon
 One thing I just realized is that nightmare is running fine on Circle CI. Probably missing something, but anyone know how that's working? I doubt they have all this additional setup, but maybe...
 Anyone get this working in a Dockerfile? Build the image just fine and seems to be working inside the container (`docker run -it nightmare /bin/bash`) but once I try passing in the command or entrypoint it just hangs (not at `nightmare queueing action "evaluate" +2ms`, but like it's starting the xvfb server without running the script)

Here's the `Dockerfile`:

``` docker
FROM node:5

# Updating ubuntu packages
RUN apt-get update

# Installing the packages needed to run Nightmare
RUN apt-get install -y \
  xvfb \
  x11-xkb-utils \
  xfonts-100dpi \
  xfonts-75dpi \
  xfonts-scalable \
  xfonts-cyrillic \
  x11-apps \
  clang \
  libdbus-1-dev \
  libgtk2.0-dev \
  libnotify-dev \
  libgnome-keyring-dev \
  libgconf2-dev \
  libasound2-dev \
  libcap-dev \
  libcups2-dev \
  libxtst-dev \
  libxss1 \
  libnss3-dev \
  gcc-multilib \
  g++-multilib

ENV DEBUG="nightmare"

# Add current directory to /app
ADD . /app

# Set current working directory as /app
WORKDIR /app

# Install npm packages
RUN npm install

# Default command. Assumes our file is index.js and our screen size is 1024x768
CMD DEBUG=nightmare xvfb-run --server-args="-screen 0 1024x768x24" node index.js
```

Trying to legitimize this a bit for us all, but major strugglez :-P
 @edasque thanks for the detailed instructions! the command i'm just trying to get working is this:

``` bash
docker run nightmare xvfb-run --server-args="-screen 0 1024x768x24" node index.js
```

or 

```
docker run nightmare node index.js
```

with `xvfb-run --server-args="-screen 0 1024x768x24"` being an `ENTRYPOINT`

---

_edit:_ though come to think of it, the dockerfile you provided is deployable to heroku/dokku on it's own. just looking for a couple ways to make this as easy to use as possible.
 > index.js being the CNN example, right?

Yep!

> Let me know what I can help with.

If you have a chance, do you mind testing this command? `docker run nightmare xvfb-run --server-args="-screen 0 1024x768x24" node cnn.js`

I was able to get it working by keeping everything in the Dockerfile, but it'd be nice to have flexibility in what script you run. For me when I run that command, it doesn't even run the node script, it just hangs, like it started the xvfb server but didn't do anything after. Tested a ton of iterations, but haven't been able to get a version working where you can pass the file in.

> Note however that the ENTRYPOINT will require you to install the application dependencies through nightmare's package.json in this case. Use the exec form of ENTRYPOINT so it could be overriden, maybe?

Yah maybe best to stick with `CMD`, though you can overwrite `ENTRYPOINT` via `docker run --entrypoint`, though i'm not sure that's a great idea. I guess it depends how often you need to change the `--server-args`
 it works using docker. we're working on a better solution for linux. keep in mind this is free software, so please be civil. if you're unhappy with nightmare, you're free to try something else.
 @rickmed I was planning on closing it with the resolution of #502 (where Nightmare would take care of the framebuffer for you, at least until Chromium's headless features trickle into Electron), but the details of that have proven much more difficult than I had anticipated.  It's not even as simple as "just use Xvfb" as [_sometimes_ this causes Chromium to hang](https://github.com/segmentio/nightmare/issues/561).
 ~~I'm not much of a terminal user, and while I tried [Electron's travis-ci recommendations](https://github.com/electron/electron/blob/master/docs/tutorial/testing-on-headless-ci.md), my tests are still timing out; even with 10+ second limits.~~

The only thing that worked for me was to use [xvfb-maybe](https://github.com/paulcbetts/xvfb-maybe) and to use a forced viewport size (via `browser.viewport()`).
 @pelhage well, Electron sure doesn't take _a few seconds_ to open like PhantomJS does.
  looks like the same issue as #224
 Given the age of this issue, I'm going to close it.  If you're still experiencing this issue, feel free to open a new issue.  yah, i was worried about this, it's a much more complicated prospect to get the events working.

I think we'd want to use something like this: https://github.com/DamonOehlman/simkey if we decide to support this.
 I believe this was (eventually) fixed in #548.
  You'll need to wrap it in a generator function using a library like [co](http://github.com/tj/co) or [vo](http://github.com/lapwinglabs/vo):

``` js
var vo = require('vo')
vo(function * () {

  var Nightmare = require('nightmare');
  yield Nightmare()
    .goto('http://yahoo.com')
    .type('input[title="Search"]', 'github nightmare')
    .click('.searchsubmit');

})(fn)
```

This is the recommended approach because it's extremely easy to follow. Alternatively you can use callbacks:

``` js
var Nightmare = require('nightmare');
Nightmare()
  .goto('http://yahoo.com')
  .type('input[title="Search"]', 'github nightmare')
  .click('.searchsubmit')
  .run(function (err) {

  })
```

Or even promises (well, thenables):

``` js
var Nightmare = require('nightmare');
Nightmare()
  .goto('http://yahoo.com')
  .type('input[title="Search"]', 'github nightmare')
  .click('.searchsubmit')
  .then(fulfill, reject)
```

Hope this helps!
  Can you provide a failing example please?
 potentially open to a simple pull request, but closing for now as it looks like your immediate question is resolved! thanks!
  Hm, if I'm understanding this issue correctly, you'd like to be able to programmatically handle open windows, without actually opening the window. Is that correct? If so:
- programmatically manipulate open windows

We probably won't add support for this case directly, but keep in mind most the library just builds on that `.evaluate(...)` function. Taking a look at how the actions are implemented is a good place to start.

There are definitely ways to access popup windows on the page from the host. Here's one way if you have control over the popup: https://github.com/lapwinglabs/oauth-open/blob/master/index.js#L28-L29
- don't actually opening the window when `{ show: false }`

I'm not sure electron is respecting this default for newly spawned windows, we may need to investigate this more or open up an issue on electron to fix. I don't think there's a way for us to intercept that command, but who knows. 

**Edit** I guess we could monkey patch `window.open`, but i'm not sure what that would solve.
 I can confirm the bug and I've opened the issue on electron's side: https://github.com/atom/electron/issues/2771

I don't really see a good way of handling this on our side, so let's track that issue instead.
  got it, yeah that's a dependency of nightmare unfortunately. in v2 (see #200) we've moved away from phantom and i've just verified that the latest build of v2 runs fine on v4:

<img width="661" alt="screen shot 2015-09-12 at 9 01 39 pm" src="https://cloud.githubusercontent.com/assets/658545/9835171/9cf74a5e-5991-11e5-86c0-4f5a1f816db2.png">

looking to release v2 tomorrow, so closing this
  hmmm, no idea! hopefully someone in the community knows gulp :)
 don't think there's any need for a gulp package based on offline chats
  Ahh my bad. Basically I think the two ways you should be able to close the connection are:

Run nightmare one time

``` js
var nightmare = Nightmare()

yield nightmare
  .goto('http://google.com')
  .title()
  .end()
```

 Run it a bunch of times and eventually end:

``` js
var nightmare = Nightmare()

yield nightmare
  .goto('http://google.com')
  .title()

yield nightmare
  .goto('http://yahoo.com')
  .title()

yield nightmare.end()
```

I think maybe it should be a no-op in run instead of conditionally running `this.run()` based on the callback.
 Just tested this out, good call. This is the right solution. Thanks!
  can you share your script? or are you running the tests? the error itself is pretty generic.
 Should be fixed now in latest `v2` sorry for the confusion!
  yes, totally annoying. this is coming in v2 :) see #200 
  With the inclusion of `.action()` being able to patch Electron, I've gone ahead and published a [navigation lock plugin](https://www.npmjs.com/package/nightmare-navigation-lock).  If you have questions, feel free to open an issue in that project's repository or reopen this issue.
  cool, v2 is coming tomorrow hopefully :)
  awesome thanks @danielstjules! we're working on v2 #200 and will try to pull this in there as well to accelerate tests :)
  thanks! sorry i couldn't merge this with all the changes, but i've merged it in manually: https://github.com/segmentio/nightmare#debug
  does this test pass for you? https://github.com/segmentio/nightmare/blob/master/test/index.js#L251 ...trying to isolate the issue
  hey i'm not sure for v1, but this is now fixed in `2.0.0` (just tested it there)
  why would you want to do this from nightmare itself? you'd probably use [superagent]()https://github.com/visionmedia/superagent) outside of nightmare
  in v2 we're moving to electron rather than phantomjs, which should hopefully be more stable and less of these kinds of difficult build errors :/
  Is this possible?

__EDIT__: You should probably just use [Puppeteer](https://github.com/GoogleChrome/puppeteer).
 **EDIT**: This doesn't work anymore on 2.0 and above, scroll all the way down for the new solutions.

I had to create a `withFrame` action function that goes inside the iframe context and a `backToParentFrame` function to go back to the parent frame:

``` js
exports.withFrame = function(frameSelector, fn, done){
  // `frameSelector` is either an index number or the iframe's name
  // no class names or ids unfortunately
  // As you can see, the code is identical to that of the `use` function
  debug('.withFrame():' + frameSelector);
  this.page.switchToFrame(frameSelector);
  var cache = this.queue;
  this.queue = [];
  fn(this);
  var self = this;
  this.queue = this.queue.concat(cache);
  done();
};

exports.backToParentFrame = function(done){
  debug('.backToParentFrame()');
  this.page.switchToParentFrame();
  done();
};
```

I originally tried to make it so that once the actions inside `withFrame` are done, it would automatically go `backtoParentFrame` but I couldn't figure out how to do that, so I made it separate. So essentially you would do:

``` html
<!-- For this given iframe -->
<iframe name="formIframe" src="somelogin.php" />
```

``` js
nightmare
  .withFrame('formIframe', function (nightmare) {
    nightmare
      .wait('form#login')
      .type('#username', 'rclai')
      .type('#password', 'password')
      .click('#submit')
  })
  .backToParentFrame()
  .wait('.for-my-logged-in-indicator')
  .run(...);
```

Don't know if you guys want to include this functionality or not. I've taken the concept from CasperJS [here](https://github.com/n1k0/casperjs/blob/376d85fceb5eca63596e12e2ef6072a72422ed9b/modules/casper.js#L2356-L2381). If you guys like it, I would suggest figuring out how we can automatically go back to the parent frame without explicitly having to do so.
 You should be able to copy and paste the code I typed above and put it into `nightmare/lib/actions.js` before the actions are attached to the Nightmare prototype.
 Cool.
  For what it's worth, here's a sample of clearing the cookies manually:

``` js
var Nightmare = require('nightmare'),
  nightmare = Nightmare();

nightmare.goto('http://yahoo.com')
  //get the cookies
  .cookies.get()
  .then((cookies) => {
    //extract the names
    return cookies.map((cookie) => cookie.name)
      //for each name, clear the cookie and return the promise to be resolved
      .reduce((accumulator, name) => accumulator.then(() =>
        nightmare.cookies.clear(name)), Promise.resolve())
  })
  //get the cookies again
  .then(() => nightmare.cookies.get())
  //display the cookies
  //note they should be an empty array
  .then((cookies) => {
    console.dir(cookies);
    //end the nightmare instance
    return nightmare.end()
  })
  .then(function() {
    console.log('done');
  });
```
 Fixed with #652.  Closing.
  we're starting to consider major improvements that could be made in v2 of nightmare. the proposal is to move from phantomjs to electron, and move the api to use generators.
## speed

some of the most vexing issues with nightmare (e.g. #199 and #192) _seem_ to boil down to underlying issues in phantomjs. @matthewmueller has done some experimentation with [atom/electron](https://github.com/atom/electron) and sees 2-3x speed improvements loading and getting the title of the page:

| Site | Phantom | Electron | Speedup |
| --- | --- | --- | --- |
| Google | 2064ms | 866ms | 2.4x |
| Yahoo | 4059ms | 1862ms | 2.2x |
| CNN | 8658ms | 2729ms | 3.2x |
## generators

one of nightmare's original goals was to eliminate the callback hell of raw phantomjs. with [generators](https://strongloop.com/strongblog/how-to-generators-node-js-yield-use-cases/) now on node stable, it makes sense to take the api one step closer to eliminating callbacks using generators. this should also make the execution more linear, understandable and controllable. ideally this is a solution to requests like #177, #176, #160 and #59.

``` js
var nightmare = new Nightmare();

// generators allow us to get the value back synchronously
var title = yield nightmare
    .goto('http://facebook.com')
    .evaluate(function() {
      return document.title;
    });

// continue with the same instance of nightmare + page state
var titleSearch = yield nightmare
    .click('#search')
    .evaluate(function(){
      return document.title;
    });

// tear down the page state
yield nightmare.close();
```

---

if you have other feedback or frustrations at this deeper level, please let us know!
 Just pushed up a branch for `v2`. I could use some help finishing up some of the remaining tasks:
- [x] port over the remaining actions
- [ ] add some examples
- [x] write some tests

Unfortunately, I cannot create a PR because the commit history is completely different. I could just write on top of all the old files though.

cc/ @reinpk @amillet89 
 awesome @matthewmueller just pushed some updates with a structure for testing based on the old tests, as well as circleci setup, and adding the `.back()` action... will push it a bit further this afternoon
 ported over a bunch more actions (with tests)... remaining ones are things like `pdf`, `screenshot`, some variants of `wait`, the event handlers, and initial options. the readme is mostly updated as well.
 Nice work @reinpk! Can't wait to see this release in the wild.
 todos:
- [x] add support for `.wait(selector)`
- [x] add support for `.wait(fn, val, [delay])`
- [x] add support for `.screenshot(path)`
- [x] add support for `.pdf(path)`
- [x] add support for page events
- [x] add support for initial browser window options
- [x] update readme for page events and initial options
- [x] update landing page description and example at https://nightmarejs.org
- [ ] read through open issues, create test cases and see what we can fix now
 Getting close... will pick this up next week when I'm back from vacation.
 @reinpk Interested to hear your thoughts on this. One thing I'd like to change is the ability to wait for click events to be fulfilled. Unless I'm missing something, right now you need to basically know what's coming (on the next page) and wait for it.

``` js
yield Nightmare()
  .click('a')
  .wait('.some-selector-on-the-next-page')
```

It'd be nice to be able to say something like:

``` js
yield Nightmare()
  .click('a')
```

And detect that the page is transitioning (maybe using `window.beforeunload`) and wait.
 ah, that's a very interesting idea yeah. in v1 you could just call `.wait()` without any arguments... do you think omitting the `.wait()` altogether is the right solution, or just making it so that the complexity of finding a relevant selector is unnecessary?
 Yah, I think it's definitely dependent on the use case. Personally, I think `click()` should handle it because for the case when you actually navigate to another page, it's sort of like the action is "half-complete" (page still in transition) before the next action is triggered. 

Plus the next action is almost never going to be what you expect (unless it's a `wait()`).

We could probably tap into this event: http://electron.atom.io/docs/v0.31.0/api/browser-window/#event-39-will-navigate-39 if we go this route.

**Update:**

Ended up pushing something up for this: https://github.com/segmentio/nightmare/commit/06eb6633478cb1d5e3878401c351fe1db10011a2

Came up with a solution that I think is pretty solid without using timeouts or anything. Personally, I think this makes a lot more sense:

``` js
     var title = yield nightmare
        .goto(fixture('navigation'))
        .click('a')
        .title() // A
        .click('.b')
        .title() // B
        .back()
        .title() // A
```

Than:

``` js
     var title = yield nightmare
        .goto(fixture('navigation'))
        .click('a')
        .wait()
        .title() // A
        .click('.b')
        .wait()
        .title() // B
        .back()
        .wait()
        .title() // A
```

The nice thing is that it won't wait if the click doesn't actually cause navigation.
 :+1: i'm cool with that, thanks @matthewmueller!
 a bit stuck on getting `screenshot` to work, but `pdf` is working and the landing page is ready to go segmentio/nightmarejs.org#1
 alrighty.... this is pretty much ready to go! thanks @matthewmueller!

will take another look in the morning, review issues, fix the commit history and release v2.0.0
 released :)
 @myrubapa gotcha, you can always continue pulling `1.x` or fork from that commit. phantomjs had SO many weird issues upstream that we had constant reliability problems with it. we opted for a smaller feature set that worked reliably in our testing.
 @myrubapa can you give an example of how phantom was better for you?
  thanks @li-xinyang in v2 we're moving to electron and testing so far shows that it's significantly faster, see #200.
  Look into using the .use() function. That will allow you to do what you're doing. 
 @abe-winter @fpinzn in v2 we're moving to using generators and an explicit `.end()` method, which should bring the benefit of stronger flow control.
  errors should now be bubbled up in the new `2.x` implementation with generators
  Can't you just evaluate and return the HTML from it?
  cool, moving to electron in v2 which should fix this keypress issue _and_ the flaky test issue ;)
  Seems to be working okay for me, can you try upping the timeout?
 ack sorry for the trouble here... this kind of unreliable stuff seems to plague phantom and in v2 we're moving to electron which (so far) feels much more stable and speedy.
  sorry can you explain the use case a bit more? what does `yslow.js` do? can reopen if you provide a bit more detail :)
  Like CDNs.
 Huh? Can you elaborate on that?
 Oh! I get it now, I didn't think of that. Thanks!
 Looks like you can't pass complex objects into the browser scope.
 I figured it out by doing this:

``` js
nightmare
  .evaluate(function () {
    $.getScript('https://cdnjs.cloudflare.com/ajax/libs/moment.js/2.10.3/moment.min.js');
  }, function () {
    console.log('Injected moment.js into the page.');
  })
  .wait(function () {
    return typeof moment;
  }, 'function')
  .evaluate(function () {
    return moment(new Date()).format('MM/DD/YYYY');
  }, function (date) {
    console.log('Today is', date);
  })
  .run(function () {});
```
  Sweet! Would you mind adding a test or two?
 awesome, thanks!
  in v2 #200 we're moving to electron, hopefully this resolves some of this complexity!
  Following up on this, electron/electron#1360 links to to electron/electron#3432, which adds the part to use the pragma directive when using [`webContents.loadURL()`](https://github.com/electron/electron/blob/master/docs/api/web-contents.md#webcontentsloadurlurl-options).

I think this issue is resolved.  If you have any more questions, feel free to reopen or open another issue.
  good call thanks guys!
 released with 1.8.2
  Ah there it is. Thanks.
  hmmmm... not sure based on the sample but it shouldn't be called immediately. in v2 we're moving to use generators and this should be substantially easier...

``` js
function*(var1, var2, var3) {
   yield nightmare.someQueuedCalls();
}
```
  in `2.x` you should be good to go! https://github.com/segmentio/nightmare#onevent-callback
  released with 1.8.2
  @lvyachao You could use [`.inject()`](https://github.com/segmentio/nightmare#injecttype-file) to add jQuery to a page and then use `.evaluate()` to execute DOM actions.  There's a [unit test](https://github.com/segmentio/nightmare/blob/master/test/index.js#L231-L247) that injects jQuery to get specific tags, as a reference.

You could even go a step further and use [`.action()`](https://github.com/segmentio/nightmare#extending-nightmare) to add custom commands to wrap the jQuery functionality you want.

I don't think including jQuery out of the box is in scope for Nightmare.  If you have any more questions, feel free to reopen or file a new issue.
  thanks @Zirak! sorry for the delay... this pull request and others like it were influential in the work that @matthewmueller put into v2... which uses generators and an explicit `.end()` method. should solve the same problem in a slightly different way. thanks!
  we decided in v2 #200 to solve this with generators and explicit `.end()` method
  the extra flow control here is a great idea, though we wanted to hold off and implement it using generators. v2 (#200) should get us there with the explicit `.end()` as well
  lgtm thanks!
 released with 1.8.1
  indeed, sorry for the radio silence. this has been fixed in `2.x` as part of the move to electron. here's the test case illustrating how to listen for page load fails:
https://github.com/segmentio/nightmare/commit/2241314e7f5aead3aa03699a314e9427e3245388
  not easily in the current nightmare v1.x, but in v2  see #200 you'll be able to have proper flow control using generators and an explicit `.end()`
  Taking a closer look at this: `.wait(selector)` now will time out after some period of time.

@shri3k's example is problematic, at least with the Electron implementation: a single Nightmare instance wraps one Electron instance, meaning in general you should not try to do parallel operations on the same instance.  Those actions will enter into a race condition and (probably) behave poorly.

Due to the age of this issue and lack of response, and that there is a viable solution baked in, I'm going to close this issue.  If you have any more problems, feel free to reopen or file a new issue.
  thanks!
  just retested this in `2.x` and cookies are saved across `.goto()` calls now

```
var Nightmare = require("nightmare");
var vo = require('vo');

vo(function *() {
  var nightmare = yield Nightmare({ show: true })
    .goto("https://segment.com/login")
    .type("input[name=\"login\"]", "<login>")
    .type("input[type=\"password\"]", "<password>")
    .click("button[type=\"submit\"]")
    .wait(2000)
    .goto("http://www.google.com")
    .goto("https://segment.com/workspaces");
})(function (err) {
  console.log(err);
});
```
  i think daydream is probably where i'd start... becomes pretty obvious what the code is doing :)

i'd probably do:
1. daydream
2. html/css selectors
3. nightmare
4. dive deeper into how javascript is working
  that is very strange, when you debug do you see it hitting this line at all?

https://github.com/segmentio/nightmare/blob/master/lib/actions.js#L313

`setTimeout` would be a bit out of our control haha, but maybe it's missing that clause.
 closing since not enough information to dig into this :/ happy to reopen with more info thanks!
  How can I make the phantom instance to load the website without loading their js files just like NoScript? Thanks for the help :)
  we're addressing these ideas in v2 with generators and an explicit `.end()` method, thanks!
  good news, just tested this on v2 and the rendering looks fixed :) v2 will be out tomorrow see #200
![test](https://cloud.githubusercontent.com/assets/658545/9835218/c529f326-5993-11e5-9123-f4012ba04be4.png)
  in `nightmare@2.x` you can listen for the `did-get-response-details` event, and inspect the arguments for the status code â€” there's enough information in there to pinpoint the html/url requested
  you can now get the http status code with `.on('did-get-response-details`, ...)`...

https://github.com/segmentio/nightmare#onevent-callback

here's an example from loading `yahoo.com`:

```
[
   "https://www.yahoo.com/",
   "http://yahoo.com/",
   200,
   "GET",
   {
      "age":[
         "0"
      ],
      "cache-control":[
         "no-store, no-cache, private, max-age=0"
      ],
      "connection":[
         "keep-alive"
      ],
      "content-encoding":[
         "gzip"
      ],
      "content-type":[
         "text/html; charset=utf-8"
      ],
      "date":[
         "Sun, 25 Oct 2015 20:13:35 GMT"
      ],
      "expires":[
         "-1"
      ],
      "p3p":[
         "policyref=\"http://info.yahoo.com/w3c/p3p.xml\", CP=\"CAO DSP COR CUR ADM DEV TAI PSA PSD IVAi IVDi CONi TELo OTPi OUR DELi SAMi OTRi UNRi PUBi IND PHY ONL UNI PUR FIN COM NAV INT DEM CNT STA POL HEA PRE LOC GOV\""
      ],
      "server":[
         "ATS"
      ],
      "set-cookie":[
         "DNR=deleted; expires=Sat, 25-Oct-2014 20:13:34 GMT; path=/; domain=.www.yahoo.com",
         "DNR=deleted; expires=Sat, 25-Oct-2014 20:13:34 GMT; path=/; domain=.www.yahoo.com",
         "PH=deleted; expires=Sat, 25-Oct-2014 20:13:34 GMT; path=/; domain=.yahoo.com"
      ],
      "strict-transport-security":[
         "max-age=2592000"
      ],
      "transfer-encoding":[
         "chunked"
      ],
      "vary":[
         "Accept-Encoding"
      ],
      "via":[
         "http/1.1 ir32.fp.gq1.yahoo.com (ApacheTrafficServer)"
      ],
      "x-frame-options":[
         "DENY"
      ]
   }
]
```
  yuck, sorry! on v2 we're running all the tests and development on 0.12, and ditching phantomjs for electron, so this should be resolved shortly, see #200
  great idea, can we make the parameter optional with a good default though?
 should be possible now in `2.x`: https://github.com/segmentio/nightmare#pdfpath-options
  thanks @rrrene but the page seems a bit simplistic without restructuring our inline docs to match the way it picks up headers as methods. happy to reconsider down the road, but not a priority right now, sorry!
  yeah, definitely yucky â€” in v2 #200 we're moving to electron replacing phantomjs which should help
  @jfrumar How did you extract the cookie header information?
 @azurelogic how would you do the same thing you did but on a asp.net web form page where there are different submit buttons (and the entire page is a form, that's how asp.net pages are)? One of those submit buttons submits the form and serves you the file. What I'm trying to figure out is how to do the `XMLHttpRequest` but when that specific submit button was clicked.

**Edit**: Figured it out, when you click on a specific submit button, the `POST` body will have that button's `name`s in this format:

```
ctl00$ContentPlaceHolder1$imgBtnReport.x:13
ctl00$ContentPlaceHolder1$imgBtnReport.y:22
```

And the other buttons' names will be excluded from the `POST` body
 With the release of #425 in 2.3.0, I've gone ahead and released plugins that will take care of downloads:
- [nightmare-download-manager](https://github.com/rosshinkley/nightmare-download-manager)
- [nightmare-inline-download](https://github.com/rosshinkley/nightmare-inline-download)

I'm considering this issue resolved.  If you have further questions or problems, please open a new issue.
  hey @serv unfortunately no idea here :/ if you have an example where we could repro that would be awesome though... ideally we can verify that the switch to electron in v2 eliminates the problem.
  sorry fellas, been slammed but will get to this on the coming weekend i hope
 not sure yet, great question though. we'll need to dig into the electron documentation to figure it out
 i don't believe this is possible in electron, so i'm going to close this as not possible unfortunately. if you have an example of a popup script would be great to test it out though
  looks like electron supports something like this now, closing in favor of #244 where we can track progress
  interesting, from my experiments it seems to respect the width parameter https://cloudup.com/cZTInhjYPB0 but not the height. presumably it also needs a scroll offset for the height... using cliprect: https://github.com/ariya/phantomjs/issues/10619

it looks like this can be solved alongside #107 so i'm going to merge this into that issue, thanks kyle!
  i believe xpath is for xml node selection, but the selector here is designed for html pages and gets passed through to `document.querySelector()`, which i don't believe supports xpath, no.
  cool, going to merge this with #107 as i agree it seems helpful!
  thanks for the reports! can you include an example script that's occasionally failing for the hashtag?

for monitoring the ajax events, i'd give `.on('resourceRequested', ...)` or `.on('resourceReceived', ...)` a try: https://github.com/segmentio/nightmare#onevent-callback

i'll close for now, but can reopen with a test case, thanks!
 ah bummer, yeah my workflow is to close and then reopen quite often. it's not a finality :)
  lgtm
  Same kind of error here, just one though:

```
  1) Nightmare multiple should run fine with two instances in parallel:
     Error: timeout of 40000ms exceeded
      at null.<anonymous> (/home/ubuntu/nightmare/node_modules/mocha/lib/runnable.js:175:14)
      at Timer.listOnTimeout [as ontimeout] (timers.js:112:15)
```
 Right, the reason why this test is failing since we are currently relying on real-world sites for testing, which can be inconsistent with timing out as a common error. we're planning to move to local testing with https://github.com/segmentio/nightmare/issues/118.

Other than that, this looks good to me
  This is the error that we're seeing in the build:

```
  1) Nightmare manipulation should emit the timeout event if the check does not pass while waiting for fn==val:
     Error: timeout of 40000ms exceeded
      at null.<anonymous> (/home/ubuntu/nightmare/node_modules/mocha/lib/runnable.js:175:14)
      at Timer.listOnTimeout [as ontimeout] (timers.js:112:15)

  2) Nightmare multiple should run fine with one instance in sequence:
     Uncaught AssertionError: signal killed phantomjs: SIGSEGV
      at Console.assert (console.js:102:23)
      at ChildProcess.<anonymous> (/home/ubuntu/nightmare/node_modules/phantom/phantom.js:142:21)
      at ChildProcess.emit (events.js:98:17)
      at Process.ChildProcess._handle.onexit (child_process.js:810:12)



make: *** [test] Error 2 make test returned exit code 2
```
 Yes, again, the first error above is attributed to testing with real world sites. Not quite sure what the second one is from, will look into it.
 ah good call, thanks! made the changes in parallel on master
  Hey, thanks for using Nightmare and surfacing this issue! Seems reasonable, I'll add it now.
 https://github.com/segmentio/nightmare/pull/135
 was fixed by #135, thanks to you both!
  lgtm! @reinpk @lambtron @stevenmiller888 
  not sure what you mean... can you send over an example?
  I'm looking to make multiple instances of nightmare and running some tests on different websites in same time. I tried using jxcore for multithreading and nightmarejs but i was unsuccessful. Then I tried using synchronize.js (http://alexeypetrushin.github.io/synchronize/docs/index.html) and I was successful but it used the same instance of nightmarejs, I don't know why. Does someone know a good approach on this ? Thank you for your time guys :)
  In the screenshot of the login page, are the un/pw fields filled out? Is the selector in the `click()` method valid? 

Can you run the program with `DEBUG=*` and paste in the output so we can see what's going on under the hood? 

Thanks!
 i tried adding some actions that cause new pages to load, but the screenshots seem to work for me....

``` js
var Nightmare = require('nightmare');

new Nightmare()
  .goto('https://segment.com')
  .click('[href="/docs"]')
  .wait()
  .screenshot('test.png')
  .run();
```

29 seconds for the next page load seems really long?
  Got it, you can combine the node modules `fs` and `nightmare` something like this (untested):

``` js
var fs = require('fs');
var Nightmare = require('nightmare');

new Nightmare()
  .goto('http://yahoo.com')
    .type('input[title="Search"]', 'github nightmare')
    .click('.searchsubmit')
    .evaluate(function () {
          return document.documentElement.innerHTML;
    }, function (html) {
        fs.writeFileSync('./page.html', html);
    })
    .run();
```

http://nodejs.org/api/fs.html#fs_fs_writefilesync_filename_data_options
  hmmmm, yes it looks like onResourceRequested actually has two functions as parameters that execute in different contexts.... https://github.com/sgentle/phantomjs-node#functionality-details and currently the function getting passed is executing in the external context not the phantomjs context.
 i've split it into two events, one that's triggered when on `resourceRequestStarted` that executes in the phantomjs context, and allows you to abort, change url, or adjust headers. `resourceRequested` will remain the same thing, executed in the external context.
  that is super slow. do you have a nightmare script test case for a publicly available site?
 this is somewhat fixed in v2 #200 by switching from phantomjs to electron
  i don't believe electron has this (for `2.x`) but it would be interesting to make a version of `.screenshot()` that just returned the buffer!
  Hey there,

Thanks for checking out Nightmare! Unfortunately the string passed at runtime is going to be evaluated as such, i.e. the `goto(iframeURL)` will tell Nightmare to go to a blank URL.

Is the URL you are getting from the outerHTML of that iframe unique every time? If not, you could hard copy that URL and initiate Nightmare with a `.goto()` to that URL.

Otherwise, you could create two Nightmare instancesâ€”one to retrieve the unique URL and another one that will wait until the first finishes and then go to said retrieved URL. Not the best solution, but one nonetheless (may require `setTimeout` or used in conjunction with the async library, etc.).

Hope that helps. Let me know if you have any additional questions or comments!
  Hi,

Thanks for using Nightmare! We actually built Nightmare with the intention of automating browser tasks, so we want to keep the exposed methods simple and few. However, we noticed that a ton of people are using Nightmare for automating browser tests, so we're considering building out a `nightmare-testing` module that builds on top of Nightmare and provides more testing specific methods. The more data around how we see people use Nightmare will greatly shape its road map.

Feel free to add your comments to this thread:
https://github.com/segmentio/nightmare/issues/117

Or here:
https://github.com/segmentio/nightmare/issues/113

Thanks!
 Another thing to keep in mind is that the `.wait()` function can take a selector, of which the Nightmare instance will wait until it appears.

You can try this:

```
describe('Nightmare', function () {
    this.timeout(60000);

    it('shoud not spend a lot of time', function (done) {
        var nightmare = new Nightmare();
        nightmare.goto('https://github.com')
            .click('a[href="/login"]')
            .wait('div#login')
            .visible('div#login', function (visible) {
                visible.should.be.true;
                console.log('before login');
            })
            .type('input[name=login]', 'myUsername')
            .type('input[name=password]', 'myPassword')
            .click('input.button')
            .wait('span.octicon-inbox')
            .visible('span.octicon-inbox', function (visible) {
                visible.should.be.true;
                console.log('after login');
            })
            .run(done);
    });
});
```

More info:
https://github.com/segmentio/nightmare#waitselector

Can you try that and see what the performance is like? Thanks!
 hey @ybak i just tested your script locally and it executes for me in about 4 seconds... since i have two-factor auth enabled i end up on the two-factor auth code page, but it successfully passes the first step of the login process with my own credentials in about 4 seconds.

could you try running it as `DEBUG=* node test.js` so that we see more internal output? and then also add the timeout handler:

```
new Nightmare()
    .on('timeout', console.log)
...
```

to get more visibility. 
 i've also experienced this, and would love to get a fix in place. will try to look into it this coming weekend.
 in v2 #200 we're moving off phantomjs for electron, which has been significantly faster in testing.
  Seems reasonable and aligned with general automation of browser tasks.. :)

Just curious, how are you using Nightmare?
  interesting, looks like a weird problem related to:
https://github.com/segmentio/nightmare/blob/master/History.md#162--2014-11-09
 thanks for providing such a complete example btw!

from the way the screenshots look, it seems like there's something strange happening with element focus:
![](https://cldup.com/TOxKeRWXJ--3000x3000.jpeg)

unfortunately it's happening a level deeper in phantom
 when i run with nightmare@1.6.1 i see the expected behavior:

![](https://cldup.com/LlW5n0C0F7-3000x3000.jpeg)
 hmmmm, so it seems like there's something funky with optimizely's javascript on that form. i added another step to fill out the name field appropriately:

```
.type('#signup-dialog input[name="name"]', 'Ron Jeremy')
```

and then the most recent nightmare version works fine:

![](https://cldup.com/4NiUPUvSl3-3000x3000.jpeg)

hopefully that solves the immediate issue for you. the underlying problem is that phantomjs isn't maintaining focus on that form, maybe because they're doing some real-time validation...
 yeah, that change seems to have made a lot more issues than it solved... the reason we switched it is because some fancier forms didn't respond well to the value setting method... but it was much simpler and more robust :P see #81, maybe there's a hack that sets value and then does a single `sendEvent` or something.

yeah, i'm definitely open to reverting that change and looking for a better solution.
 yeah makes sense, could you send over a pull request from your fork? happy to merge
 in v2 we're using electron instead of phantomjs, and electron doesn't have a native keypress function, so we're going back to the way it worked here originally, which should fix this issue in v2.0 #200 
  Thanks for the feedback and suggestions!

> Furthermore, it would be nice if you could specify an indefinite wait that polls the page every X milliseconds, but doesn't refresh it. For example, there may be a lengthy operation that is running on the page that a refresh would cancel/reset. Perhaps add a refresh option?

I might not quite be following, but I think that's exactly what the `wait(fn, value)` method does. If you don't pass `delay`, the fn will evaluate over at over at the default interval of 50ms (or whatever you set in your override) until timeout. 

> Also, I cannot see any reason for delay to be an optional parameter. If you don't specify a delay, the wait will be over after the first timeout, making the return value of fn inconsequential...

Adding the refresh delay doesn't actually extend the timeout, it just optionally refreshes the page at [delay] interval in case you're hoping to grab a specific static element value that can change on refresh, [like in the test](https://github.com/segmentio/nightmare/blob/master/test/index.js#L269-L273).

Make sense?
 yeah that's a fair point... here was the original thought process:
1. If something is going to change on the current page via ajax (no delay parameter), wait times will be relatively short. the user is probably expected to sit and wait.
2. if something is going to change on refresh (with delay parameter), wait times will be relatively long. the user isn't expected to sit there and refresh the page.... we're taking on a long-running task for the user so that they can do other stuff rather than refreshing this page.

with that in mind, the first scenario has a fast delay of 50ms, whereas the second scenario is typically for delay times >1 minute.

i agree the page refreshing is unexpected, so maybe that should be split into a separate function somehow.
 in v2 (see #200) we've gone with your original suggestion :) thanks so much! the new function signature is `.wait(fn)` and waits until the function returns true after being evaluated on the page. v2 should be out tomorrow :)
  Total agreement from the folks here at [Segment](http://segment.com). @stevenmiller888 and I are going to dive into this starting this week. 
 yeah totally agree, this is the next major improvement for nightmare i think
 fixed a while ago by the indomitable @dominicbarnes 
  Hey @mickaelandrieu, I'm Andy and I'm helping maintain this library.

We built Nightmare with the intention of automating browser tasks, so we aim to keep the exposed methods simple and few. However, it appears that many people are using Nightmare for browser testing. We're considering building a nightmare-testing library that will do just that, while keeping this library simple and for building APIs and plugins.

Let us know what you think of a nightmare-testing library and if you'd like to contribute to it!
 Hey @mickaelandrieu,

Good points. There are many people using Nightmare for user testing and I think there can be more work done in making it easier for them to do so. Targeting the big testing libraries is a great start. Maybe we can spec out the interface of how users would use Nightmare with Mocha or Jasmine and work from there?

Agree to keep Nightmare simple with many useful middlewares that people can pick and choose. Eventually, I'd also like to see an ecosystem of plugins of automated browser tasks, such as https://github.com/segmentio/nightmare-swiftly
 Found this with a quick Google search, using Nightmare with Mocha, Chai for e2e testing:
http://weblogs.asp.net/mikaelsoderstrom/writing-end-to-end-tests-with-nightmare-js

How did you imagine you want to improve the testing interface?

[edit] i see you commented on its performance :)
 sounds good, we do intend to keep improving nightmare, though we'll keep the API small and push people to develop frameworks around it.
  haven't been able to reproduce, but that makes me suspect it's a localization issue with yahoo's site being different in france than in the us, closing for now but i'm about to generate a bunch more examples of different ways to use nightmare.
  good idea, will merge and see what the issue is
  just retested this in `2.x` based on electron, and the font now renders correctly :)

![font-rendering](https://cloud.githubusercontent.com/assets/658545/9837539/3120051c-59f7-11e5-9eb4-ad615a32769f.png)
  We're seeing a wide variety of use-cases, would love to hear what you've been using it for, thanks!
 @dzignus what are the specific parts of the API you're missing?
 I've been using it to automate to logging in to vendor sites to grab open order reports and it's been quite nice.
 FYI we just released `2.x` which seems to fix a lot of problems by migrating from phantomjs to electron under the hood
  @reinpk :)
 shoot. passing locally. i'll see whats up with the "should type and click" test this evening and see if we can get all those tests passing
 hey i think that was a circleci issue, can you rebase to master to pick up a few circleci updates and then those tests should pass
 rebased but still an issue there :)
 weird! i'll bug you about it tomorrow.

![](https://cldup.com/vMowro9lHB.png)
 sorry for the delay! this looks good and just rebased it, merging now
  ah, the function was failing for non-existent elements, fixed in nightmare@1.6.4 thanks!
 not sure about the code there specifically for the click not scripting correctly... the fix on 1.6.4 should prevent that TypeError uncaught exception. i don't have a yahoo account to test with, sorry!
 added a test just to be sure: https://github.com/segmentio/nightmare/pull/112/files hope that example helps but it seems to work for me
 yeah, that's a different test failing for some weird timeout issue on CI, unrelated
  I tried to add the method myself but i was unsuccessful
.This is the code that I tried to implement in the actions.js file:
exports.viewRect = function(clipRect, done){
  this.page.set('clipRect', clipRect , done);
  console.log(this.page)
};
http://phantomjs.org/api/webpage/property/clip-rect.html as reference .
The object that was passed to the method should look like this:
{
    top: clipRect.top,
    left: clipRect.left,
    width: clipRect.width,
    height: clipRect.height
    };

I'm trying to take a screenshot of a dom element in the page.
I don't know how to access the phantomjs instance so I can add other methods that are available in phantomjs.
 two questions to answer here:
- can we set clipRect just before a `.screenshot()` or does it have to be set at the beginning of a sequence?
- this would be equivalent to cropping the screenshow in post-processing, yeah?
 ok, added in `2.0.2` support for the `clip` parameter: https://github.com/segmentio/nightmare#screenshotpath-clip

open to a pull request for supporting taking a screenshot of a specific dom element
  can you include a few example headers here? thanks
 unfortunately this doesn't appear to be possible upstream in electron https://github.com/atom/electron/blob/master/docs/api/browser-window.md

but if there is a way i'm missing, happy to re-open and implement
  haha, what?
  thanks guys i think it's a weird globals problem, investigating now.
 FWIW you can do `DEBUG=* node test.js` to get full debug output of all the internal logging. that shows a port conflict between the two phantomjs instances, which reveals the two are overwriting each others instances... solution on the way
 fix released with nightmare@1.6.3
 yeah looks like there still needs to be a global port, getting a fix ready now
 fixed that test is passing now :) thanks @pdelanauze shipped with nightmare@1.6.5
  woops, thanks! fixed: https://circleci.com/gh/segmentio/nightmare
  could you include a small example showing how to reproduce this? thanks!
 appears to be fixed when i run the tests as well, let me know if i should reopen.
  prefer bumping the phantom version if that fixes the issue :) thanks so much for investigating. the bumped phantom dep shipped with 1.6.1

let me know if you're still seeing issues here
  nice this is great! thanks john
 released with nightmare@1.6.2
  happy to merge this in if you can include a test as well :) thanks!
 sorry had to make some other improvements to `.visible()` as well to catch non-existent `elem` --- could you rebase?
 potentially interested in pulling this into `2.x` (we have a local testing now), closing but happy to re-open if you want to mirate these changes to local testing + electron!
  filed an issue with sgentle/phantomjs-node since it seems like the callback return value isn't getting passed through to phantomjs
 closing now that we've moved to electron over phantomjs
  no worries glad it's working
  cool idea, makes sense to me, but the PR is incomplete no?
 ah, derp, misread the variable name `args`. yep will test this out soon, thanks!
 released with 1.5.3, thanks!
  can you use the existing `.on()` method? https://github.com/segmentio/nightmare#onevent-callback
 closing for now until we have more info on the use case! seems like `.on()` should work
  This is the code that I used:

code:
var options =  { proxy:'proxyip:proxyport', proxyType:'socks5' };
var Nightmare = require('nightmare');
var nightmare = new Nightmare(options);

nightmare
  .goto('http://www.whatismyip.com/')
  .viewport(500 , 500)
 .screenshot('hasdasda.png')
  .evaluate(function () {
  //  return document;
    return document.getElementsByClassName('the-ip')[0].innerText;
  }, function (res) {
    console.log(res);
  })
  .run(function( err, nightmare){
    console.log("done");
  });

output:
phantom stdout: TypeError: 'undefined' is not an object (evaluating 'document.getElementsByClassName('the-ip')[0].innerText')
null
done
phantom stdout:   phantomjs://webpage.evaluate():3
  phantomjs://webpage.evaluate():6
  phantomjs://webpage.evaluate():6

If I don't use the options object it returns my ip perfectly:
output:
phantom stdout: Error: Cannot find a responsive size for a container of width=0p
x and data-ad-format=auto
phantom stdout:   http://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js:
29
  http://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js:25
  http://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js:34
  http://www.whatismyip.com/:376

my.my.ip.0
done

Another Question that i have is : how can I specify the screenshot path into a folder is it .screenshot('/img/hasdasda.png') ? because it doesn't work :(.

Thank you for your time guys and for this awesome wrapper. 
  thanks all, agree those docs were confusing, updated based on this thread:
https://github.com/segmentio/nightmare/blob/master/Readme.md#evaluatefn-cb-arg1-arg2
  hmmm, i'm not entirely sure without seeing the code and running it myself, but one of the issues i've run into is the difference between (1) a human saying "the page has loaded" and (2) a computer saying "the page has loaded"... i'd make sure you're clicking the submit button after the full page is truly loaded, either with an additional `.wait(ms)` or `.wait(selector)` after `.goto(url)`... it's likely that the page is "done loading" by html onload standards, but that additional javascript needs to load and then override the native onsubmit handler for the form. hope that helps!
 hmmm, one strategy would be to look at the outbound requests:

``` js
var Nightmare = require('nightmare');
goCards = new Nightmare()
    .on('resourceRequested', function (requestData, networkRequest) {
        var url = requestData.url;
        if (
            url.indexOf('cdn-apple') > 0 ||
            url.indexOf('fonts') > 0 ||
            url.indexOf('data:image') === 0 ||
            url.indexOf('securemetrics') > 0) return;
        console.log(requestData.method + ':' + url);
        if (requestData.method === 'POST') console.log(requestData);
    })
    .viewport(800, 1600)
    .goto('https://secure.store.apple.com/us/giftcard/balance')
    ......
```

this produces a nice stream of what requests are being made. based on that it looks like there may be a javascript validation step on the page, and when the pin is invalid it seems to just clear it... could you post your gift card pin obfuscated but still regex-happy so that i can test a request to the server? don't have any apple gift cards lying around...
 could be something funky with ssl as well:

![](https://cldup.com/3J3y64hk-0-3000x3000.png)
 nvm found the client-side regex validator
 ahhhhh, running the nightmare code in the browser directly:
https://github.com/segmentio/nightmare/blob/master/lib/actions.js#L189-L192

you get the same behavior. turns out that the third parameter to `.initEvent(type, bubbles, cancelable)` is preventing Apple from handling the AJAX form as they want to. so it's submitting the url.

i'll ship this fix with 1.5.1 momentarily
 released as 1.5.1, thanks so much for bringing this up!
 https://www.npmjs.org/package/nightmare 5 minutes ago :)
 sorry i didn't read the docs carefully the first time! cheers.
  hmmm, seems like this may be an underlying issue with phantom:
http://stackoverflow.com/questions/13490324/running-phantomjs-node-js-together-on-ubuntu

but i'm seeing the same error with phantomjs 1.9.7.... so maybe this is an issue that just isn't being addressed until 2.0
 leaving similar code on a branch here until we have more info:
https://github.com/segmentio/nightmare/tree/add/debugger
 in `2.x` we've moved from phantomjs to electron, which has fixed a bunch of weird issues. among other things, you can now pass in `{ show: true }` as a constructor argument to just show the window as things are happening.

```
yield Nightmare({ show: true })
        .goto('http://walmart.com/')
        .click(...);
```

hopefully this helps with debugging!
  thanks @Max93! sorry i never got to this with v1... it looks like an interesting abstraction for other events... what events were you interested in? closing for now but may bring the idea into v2 with more info here. thanks!
  @leesei added :)
  released with nightmare@1.6.2
  can we split the uploads file stuff into a separate pull request by itself? it's a good simple fix that we should merge by itself. after that this timeout stuff is also a good direction, but needs some cleanup and merge in a separate pull request.
 cleaned up separately and released as 1.6.0, thanks!
  nice this is really awesome, just a pile of tiny style nits to keep everything consistent and easy to read
  @execmd @fbm-static does this take on the same idea solve the use case as #62? i think it will be easier to abstract engines down the road #60, and hides the specifics of phantomjs for people who find nightmare before they ever try to use phantom :)
 @fbm-static that wouldn't be a good abstraction though, that just reveals all the underlying complexity

@johntitus that sounds reasonable, updated with both of those added
 could you please add `remote-debugger-port` and `remote-debugger-autorun`

http://phantomjs.org/troubleshooting.html
  can read cookies and modify, but can't add new cookies cause I got problem with `this.page.addCookies`

Signed-off-by: TZ atian25@qq.com
 would love to see this in `2.x`: https://github.com/atom/electron/blob/master/docs/api/session.md#methods
 coming through #241 or related
  sweet, excited for when phantomjs 2 merges upstream :)
  thanks!
 released with 1.4.0
  released with 1.4.0
  can we write this in a way to match the way other options are passed?
 yeah phantomjs accepts them differently command line vs. options, but would rather have them as fully-fledged options with defaults so that https://github.com/segmentio/nightmare/issues/60 could work better cross-browser down the road, and so that phantomjs's unique option-passing structure is better abstracted.
 check out #76 to see what i mean as an alternative implementation
 thanks for the concepts here, but going with the implementation in #76, hope it's helpful!
  should be merged soon after the options passing is made to match the existing style!
 released with 1.5.0
  that's an intriguing idea, definitely would be cool for some cross-browser stuff. i assume the use case you've got is around cross-browser testing?
 wrt to #62, all the options appear to have the same names at first glance:
- http://docs.slimerjs.org/current/configuration.html
- https://cloudup.com/c0iFE62qnhx (http://triflejs.org/)
 thanks all, in v2 we decided to go a different direction towards depending on electron. may reconsider down the road.
  Seems like a valid use case. @reinpk Thoughts?
 the underlying problem will be solved in v2.0 shortly by moving to generators + an explicit `.end()` method
  looks good can you squash and rebase?

https://github.com/edx/edx-platform/wiki/How-to-Rebase-a-Pull-Request
  looks good, can you rebase?
  released with 1.4.0
  the variable `page` is not defined in the closure of the second function. if you change it back to `console.log(res);` it should work
 oh woops, sorry about that! fixed in the readme
  as far as i can tell the object is really just `dnode: { weak : true }` right? could we make it a simpler boolean option instead?
 thanks @securingsincity and @fearphage 
  definitely open to a pull request showing how to install phantomjs on another machine. it's just a convenience to help people get started ;)
  rockin test! naming nit and then if you could rebase to master so that i can merge? thanks man, great additions!
 can you rebase to master and squash to a single commit?

https://github.com/edx/edx-platform/wiki/How-to-Rebase-a-Pull-Request
 related to #45
  thanks! i'll touch up the wording locally
  mmm that's cool yeah, can investigate, would be open to a pull request for a `.cookie()` function or something as well
 I will pull this later.
- cookie file should be import by phantom art
- add `cookie(callback)`, then merge callback result to cookie.
 had pull #71 ,  can read cookies and modify, but can't add new cookies cause I got problem with `this.page.addCookies`
 `load  an external file` can use this : #62
 `phantom-node` seems only offer `phantom.addCookie: (name, value, domain, cb=->)` , not `page.addCookie`
1. maybe had to modify `index.js` to set `this.ph=instance`
2. `self.ph.addCookie('test', 'testValue', cookies[0].domain, callback)` seems need `async` to iterator

so wait for @reinpk  ~
  hmmm, boy i dunno. this doesn't seem super promising:
http://stackoverflow.com/questions/22981929/how-to-set-the-browser-language-of-phantomjs

what exactly do you mean by setting the language though?
 mmm, yeah got it. sounds awesome! if there's a good lead on how this could be implemented, can definitely reopen!
  hmmmm, i'm on phantomjs `1.9.7` and don't see this error, could you try updating?
  yep rolling this into #40 for more examples
  ah, yeah i think this is solved by allowing branching through #36, closing here but will consider this use case as well when solving that issue
  should get merged soon after a rebase/squash
 released with 1.4.0!
  ah, phantomjs can be used from the command line, yes. nightmare is used from a javascript program. using nightmare from the command won't work/doesn't make sense.
 it's a javascript library like jquery or angular yep!
  missed this part of the api myself, cool! the resource requested events are super interesting, just a few nits before merging :)
 sweet!
 published with 1.3.0
  ah, that is a good heads up, thanks!
 ah, bummer, not sure i haven't had a chance to investigate 2.0.0 at all yet
  easy peasy haha thanks!
 published with 1.2.0
  --testing (from #47)
 the readme is updated to include a basic testing example with mocha (a test that passes even ;) and i've also added a link to the tests, since the tests contain a complete working example of every method.
  thanks for the simple example! investigating now
 released the fix with 1.1.1, thanks!
  i think this is fundamentally the same problem as #36, but definitely agree this is annoying with the current API. i think if there's an option to avoid teardown of the phantom instance in `.run()` then you can just put it in the callback to `.run()` and then could reinitiate nightmare commands again when necessary.

closing here and keeping #36 as the marker for the issue
  mmm dang yeah need to get the media queries right here, will look into it soon thanks
 fixed in segmentio/nightmarejs.org#a23340b
  yeah this is a great question. maybe `.run()` should have a `keepalive` parameter so that you can do the branching outside the fluent api. definitely agree that branching/looping can be necessary.
 long awaited... but v2 #200 uses generators and an explicit `.end()` method to improve the flow control.
  potentially, there are probably more efficient ways of doing it than phantomjs though. phantom will execute all the js and load all the images, etc. most likely you just need to look at the raw html of the website, which you could do with just an http request.
  this is cool! i think `.inject()` is a cleaner method name, and it would be cool to be able to inject css as well. css wouldn't be a direct translation to a phantomjs method but [it looks doable](http://stackoverflow.com/questions/20950013/phantomjs-inline-html-with-external-css-file)
 this is looking sweet other than a few nits. could you rebase and squash the commits as well? thanks @johntitus!
 thanks @johntitus!
 published with 1.2.0
  ah, yeah it's pulled from a bigger example, sorry will update that now. the `fn` function in the code snippet there is not defined. here's the updated snippet with fix that i'll put in the readme shortly:

``` js
var Nightmare = require('nightmare');
new Nightmare()
  .goto('http://yahoo.com')
  .type('input[title="Search"]', 'github nightmare')
  .click('.searchsubmit')
  .run(function (err, nightmare) {
    if (err) return console.log(err);
    console.log('Done!');
  });
```

Yahoo seems to have nicer named elements for an example, this works for me locally with 1.1.0
 fixed in 3e9573358, thanks!
  derp, thanks!
  super welcome addition once the testing is worked out! if you could rebase and squash actually that would be super nice :)
 if #74 would be the key piece for getting testing in place, let me know, would love to see this added but it'll need a rebase, squash, etc.
 nope, for now these methods this could definitely be tested against something existing and reliable like everything else. i'll get something together today then fix up the commit history.

in the future, if you think it's necessary, i'd definitely be happy to help with something like #74 though!
 this is a mess -- closing and opening a new pr
  dang yeah that's mad annoying. thanks for the heads up, fixed in https://github.com/segmentio/nightmarejs.org/commit/3c7b6193467d9b1cc20c0485dac662c6ba5ab998
  i think i did this because of irregular event triggering by phantomjs, where oftentimes a timeout was a false negative (i.e. everything had worked correctly, but phantom was being uncommunicative).

what's the use case or error you're seeing specifically? i'd like to investigate it more deeply and see if there are some improvements to be made there.
 closing until there's more details, keep me posted!
  interesting! definitely open to a pull request here
 fixed in 1.3.3
  the issue is just that if it's not passed then the callback is undefined but invoked here?
https://github.com/segmentio/nightmare/blob/master/lib/index.js#L56
  what's an example use case for nightmare?
   fixed in e649e5717e8
  thanks! LGTM
  looks good, thanks!
  thanks @queckezz! good idea here, going to eliminate the `done` parameter and just internalize that into the `.use()` method.
 thanks for your help!
  nice thanks!
 published as 0.1.7
  interesting, yeah i'm trying to think through how to embed a bit more logic/branching + the same kind of delayed execution for nightmare-swiftly plugin as well. thanks for the suggestion here, hopefully can work it into some more changes today.
 ok, since normal queued methods just get pushed onto the end, you could have something like this:

``` js
nightmare
  .goto(url)
  .use(tw.login('user', 'pw')
  .screen(path)
  .use(tw.search('503'));
```

If .use() just pushes like a normal queued function, then the actual execution order would get messed up where `screen` came before the both `tw` plugins.

So we'd need to insert the plugins "in place" where the `use` was queued, rather than pushing them on.
  interesting, looks like the wrapper could maintain the order there:
https://github.com/segmentio/nightmare/blob/master/lib/index.js#L167-L168

will investigate tonight!
 thanks! sharp eyes my friend!
  mmm great point, didn't do much diligence on it, but phantomjs-node does look healthier. would definitely accept a pr, otherwise i'll probably hack on it next weekend :D
 good idea, thanks! just merged the change
  thanks @queckezz! just noticed that while i made the changes yesterday i forgot to push (also added `.agent()`) i'll close now that i've pushed/published.
 good idea :)
 dang, yeah i definitely need to fix up the tests. hopefully next weekend as part of the switch to the other phantomjs-node lib
  the problem is throwing the error in the callback or an error happening in evaluating `fn` on the page?
  setting the `viewport` seems similar. at the moment that's an option to the constructor, but i see julian's point and could imagine wanting to change the viewport to check for responsive changes as well.

thinking of adding both as methods:

``` js
Nightmare()
    .agent('chrome')
    .viewport(200, 600)
```
 reopening until the tests are fixed
 works in the proper tests now :)
  i am planning to add a `.run(fn, cb, [args])` method that lets you execute javascript on the page and get back results in a callback, is that the gist of what you're thinking?
 fixed in 0.0.10, cheers!
