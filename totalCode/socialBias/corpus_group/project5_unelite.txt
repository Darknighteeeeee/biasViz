  I think the add Class proxy will be better.
Why don't the add Class Proxy like cglib? Thank you for your answer.
Your means that now all Methods in guava can work on Android?
 um...
But reflection is the important feature of Java.
If the situation that APIs of reflection poor performance on Android can't be improved.
May divide guava into generic and unique modules be better? Thanks.  Hi I am new to Guava. I just pull the latest code from master, and run 'mvn install -DskipTests' in my local, and I got the following errors:

[ERROR] /Users/ygao/Documents/github/guava/guava-tests/target/classes/com/google/common/primitives/UnsignedLongsBenchmark.class:110: Undefined reference: String com.google.common.primitives.UnsignedLongs.toString(long, int)
[ERROR] /Users/ygao/Documents/github/guava/guava-tests/target/classes/com/google/common/primitives/UnsignedLongsBenchmark.class:111: Undefined reference: String com.google.common.primitives.UnsignedLongs.toString(long, int)
[ERROR] /Users/ygao/Documents/github/guava/guava-tests/target/classes/com/google/common/primitives/UnsignedLongsBenchmark.class:130: Undefined reference: long com.google.common.primitives.UnsignedLongs.remainder(long, long)

Do I miss anything?

Any help would be appreciated! Thanks! Hi, I have the goal as test and it worked fine. Thanks for the reply, after I ran "man clean install -DskipTests", it works. I think it just cleaned the old artifacts.  As of 23.3, `com.google.common.collect.TreeTraverser` is deprecated. Are `Files.fileTreeTraverser()` and `MoreFiles.directoryTreeTraverser()` deprecated too? Should users migrate to `java.nio.file.SimpleFileVisitor`?

Note that `MoreFiles.directoryTreeTraverser()` appeared in 21.0 (Java 8), despite `SimpleFileVisitor` presence (Java 7). My understanding was that there won’t be any breaking changes after 22.0. So option (a) is actually not an option, is it? @szarnekow I thought that too, but then I remembered that the Guava team also announced that `@Beta` stuff will still be eligible for consideration of removal. Given that `TreeTraverser`'s still in `@Beta`, option (a) is still a valid option AFAICT.  ```
List<String> list=Lists.newArrayList();

  public static <T> void tokenTest(T object) throws Exception{
//    TypeToken<T> token=new TypeToken<T>() {};
    TypeToken<T> token=(TypeToken<T>) TypeToken.of(object.getClass());
    System.out.println(token.getRawType());
    System.out.println(token.resolveType(object.getClass().getTypeParameters()[0]));
  }
```

if i use the "TypeToken<T> token=new TypeToken<T>() {};",it will throw IllegalStateException.
if i use the "TypeToken.of(object.getClass())",it will get Class of ArrayList,but i want to get the Class of List.
Can i get the Class of List?
Can i get the Class of String?

  Suppliers class has an ofInstance(T instance) method which accept a object of type T as value and return a supplier that provides that value. It would be better off that it also has a method for the opposite direction: given a supplier, return it's value. Although we can easily get the value of a supplier by calling supplier.get(), it is feasible only when we already defined a supplier explicitly, we can not do it with a **Lambda** expression. For example:

`String str = (() -> { return "abc" + "def"; }).get();` 

The code above is invalid. We have to write this: 
```
Supplier<String> supplier = () -> {return "abc" + "def"; }; 
String str = supplier.get();
```

But if Suppliers class can have a valueOf method, we can write this:

`String str = valueOf(() -> {return "abc" + "def"; });`

That would be much more elegant. Of course, with a very short amount of inner code, it's not necessary to put code into lambda, but if there are many lines of code, putting it into a Lambda will give us better code separation of concern, hence easier to understand. Besides, providing such a method does no harm to the class.
 > but if there are many lines of code

Wouldn't you then just typically put the code in a separate private method and just call it? > If there are "many lines of code," you should pull out a method. If there aren't, then you should just execute the logic directly in the function, not in a lambda.

Of course that's the usual way people doing that, but lambda provides an alternative way, which might be useful in some cases, e.g. 5 or 10 lines of code that I wouldn't like to put to a separate method? After all, extracting method requires clearly defining the parameters of the new method, while with lambda, we can refer to the local variables very conveniently. And I believe there are some other benefits. You can just cast it into one supplier.  Guava has immutable and unmodifiable versions of Map and SortedMap (which also satisfies NavigableMap) but nothing for ConcurrentMap, as far as I can tell. Neither does the JDK itself or commons-collections. Immutable and unmodifiable ConcurrentMap implementations would be useful for satisfying bounds checking. Hi @rdicroce. Can you explain what you mean by "bounds checking"?

I ask as I struggle to understand why an unmodifiable concurrent map would be useful, as AFAICT it's kind of the whole point for concurrent maps to be mutable; they're mutable in such a way that multiple threads can safely write to and read from a given map in overlapping time intervals.

If all you want is for the map to be read and not written to, then AFAICT wrapping it in `Collections.unmodifiableMap([...])` or copying it with `ImmutableMap.copyOf([...])` should be enough.

If I've misunderstood something, please do let me know. :) In my case, we had a ConcurrentMap<X, ConcurrentMap<Y, Z>>. We want to get something out of the inner map, but it's possible the key doesn't exist in the outer map. So we used outerMap.getOrDefault(outerKey, ImmutableMap.of()).get(innerKey). But that fails bounds checking because ImmutableMap doesn't implement ConcurrentMap, so we had to change the type to ConcurrentMap<X, Map<Y, Z>>.

So I suppose what I'm really looking for is something like Collections.emptyMap() for ConcurrentMap. A Guava Table could also satisfy this particular case, but I don't see any implementations of it that are thread-safe. A synchronized Table would be a bad idea in our case. We're storing some timestamps so we can quickly determine if a client has the current version of a resource, so we can avoid a DB call. Which means this map gets hit on every request. We did ultimately change the field declaration, but that removes a compile-time safety check. The inner map needs to be thread-safe, so now it is possible for someone to accidentally put a regular Map (e.g. HashMap) that's not thread safe in there.  Could you please reconsider extending `Preconditions` with custom exceptions?
This is a follow up on #1388.

First, reasoning against such feature summed up from #1388 (mostly [this comment](https://github.com/google/guava/issues/1388#issuecomment-61351926)):
1. `Preconditions` are for programming errors (e.g. NPEs), not business logic
2. Performance issues in creating exceptions

Counterargument:
1. Looks programmers would appreciate it :) , see https://www.google.com/search?q=guava+preconditions+custom+exception& 
2. Newest Guava leverages Java 8, so now a lightweight implementation is possible:
    ```java
    public final class Preconditions {
    (...)
        public static void checkArgument(boolean expression, Supplier<? extends RuntimeException> exceptionSupplier) {
            if (!expression) {
                throw exceptionSupplier.get();
            }
        }
    (...)
    }
    ```
    and usage:
    ```java
    checkArgument(expression, () -> new MyCustomRuntimeException());
    ``` Thanks  So that projects depend on this can be published to a public artifact repository.
Note that this is not breaking backward compatibility. All codes except this file can be still compiled in Java 6. Guava has an `Automatic-Module-Name` in its `MANIFEST.MF` now, so I believe this is not quite as important as it may seem. But if I'm mistaken, then I'd be more than happy to be proven wrong.

(BTW, I think I might have misunderstood something, because `module-info.java` is Java 9 specific, right? Would a Java 8 compiler (which I believe is what is used to compile guava-jre) or an Android compiler (for guava-android) happily process it or otherwise ignore it?) It is possible to only compile ```modile-info.java``` in Java 9, so the jar file is still compatible to users who uses earlier Java version. 

A maven example:
https://github.com/twonote/radosgw-admin4j/blob/java9/pom.xml#L127
 @cpovirk could you tell me more about this problem?  Java 9 has just introduced the "Convenience Factory Methods for Collections" feature. As `ImmutableList.of()` and similar methods in Guava, these factory methods create unmodifiable collections and prohibit null elements. The created collections are serializable if all of their elements are serializable.
Please find more details on http://openjdk.java.net/jeps/269.

It's worth considering to extend the Javadoc of the corresponding Guava classes (`ImmutableList`, `ImmutableMap` and `ImmutableSet`) like it happened in 3afc6e45c39504ece02d14f4a462f65acfa98652 to discourage using the old factory methods in favor of the Java 7 diamond syntax. The reason I'm using `ImmutableList` et.al. in favour of `Collections.unmodifiableCollection` is the semantic type in my API. It's clear that I return an immutable type. Whereas returning just `Collection` will confuse callers with runtime exceptions. To add to @ooxi's comment, I'd also argue that using `Immutable*` consistently prevents unnecessary copying when using `Immutable*.copyOf([...])` a lot for defensive programming reasons. Thank you all for sharing your points on this. All of them are completely reasonable.

But in that case I am wondering if it could be possible to extend the Javadoc or https://github.com/google/guava/wiki/ImmutableCollectionsExplained Wiki page to highlight why Java 9 folks should still prefer the immutable collections provided by Guava instead of using the new ones in JDK.  A symlink should work.  Hi, following is in Kotlin, I hope you don't mind.

**My Service**
```kotlin
class TestService : AbstractExecutionThreadService() {

    // ~ Properties -------------------------------------------------------------------------------
    
    private val L = logger()  /* slf4j logger */
    val inputQueue = SynchronousQueue<String>()

    // ~ Initializers -----------------------------------------------------------------------------
    
    init {
        addListener(
            object : Service.Listener() {
                override fun starting() {
                    L.info("starting")
                }

                override fun running() {
                    L.info("running")
                }

                override fun failed(from: Service.State, failure: Throwable) {
                    L.info("failed: ${failure}")
                }

                override fun stopping(from: Service.State) {
                    L.info("stopping")
                }

                override fun terminated(from: Service.State) {
                    L.info("terminated")
                }
            },
            Executors.newSingleThreadExecutor()
        )
    }

    // ~ Methods ----------------------------------------------------------------------------------

    override fun run() {
        while (true) {
            val event = inputQueue.take()
            if (event == "CRASH") {
                throw IllegalStateException()
                
            } else if (event == "SHUTDOWN") {
                break
            }
        }
    }

    override fun triggerShutdown() {
        while (state() == Service.State.STOPPING) {
            if (inputQueue.offer("SHUTDOWN", 500, TimeUnit.MILLISECONDS)) {
                break
            }
        }
    }
}
```

**My Tests**
```
class GuavaStateExceptionTest {

    @Test
    fun startAndShutdown() {
        val app = TestService()

        val sm = ServiceManager(listOf(app))
        sm.startAsync().awaitHealthy()
        sm.stopAsync().awaitStopped()
    }

    @Test
    fun startAndShutdown() {
        val app = TestService()

        val sm = ServiceManager(listOf(app))
        sm.startAsync().awaitHealthy()
        app.inputQueue.put("CRASH")
        sm.stopAsync().awaitStopped()
    }
```

**Problems** 
The first test, starting and stopping works fine and gives the following output:
```
[pool-1-thread-1]         a.f.m.TestService*             INFO    starting
[main]                    a.f.m.TestService*             INFO    triggerShutdown
[pool-1-thread-1]         a.f.m.TestService*             INFO    running
[main]                    a.f.m.TestService*             INFO    offer
[pool-1-thread-1]         a.f.m.TestService*             INFO    stopping
[pool-1-thread-1]         a.f.m.TestService*             INFO    terminated
```

The second test, where I post an event that is supposed to crash the run-loop sometimes works with this output:
```
[pool-1-thread-1]         a.f.m.TestService*             INFO    starting
[pool-1-thread-1]         a.f.m.TestService*             INFO    running
[pool-1-thread-1]         a.f.m.TestService*             INFO    failed: java.lang.IllegalStateException
```

 And sometimes the `triggerShutdown` method hangs, because it posts to `inputQueue` and nobody `takes` from there:
```
[pool-1-thread-1]         a.f.m.TestService*             INFO    starting
[pool-1-thread-1]         a.f.m.TestService*             INFO    running
[main]                    a.f.m.TestService*             INFO    triggerShutdown
[main]                    a.f.m.TestService*             INFO    offer
[main]                    a.f.m.TestService*             INFO    offer
[main]                    a.f.m.TestService*             INFO    ...
```

Why is the logging listener not called all the time? Sometimes the stopping event is logged, sometimes it's not there. When `main` hangs in `triggerShutdown`, the `Failure` event is never logged.

```
[pool-1-thread-1]         a.f.m.TestService*             INFO    starting
[main]                    a.f.m.TestService*             INFO    triggerShutdown
[pool-1-thread-1]         a.f.m.TestService*             INFO    running
[main]                    a.f.m.TestService*             INFO    offer
[pool-1-thread-1]         a.f.m.TestService*             INFO    stopping
[main]                    a.f.m.TestService*             INFO    offer
[main]                    a.f.m.TestService*             INFO    offer
[main]                    a.f.m.TestService*             INFO    offer
[main]                    a.f.m.TestService*             INFO    offer
```

Is there another way in my scenario to access `state()` in `triggerShutdown` to see whether the service has exited while we tried to shut it down? Wbat I'm doing now is `while(isRunning())` instead of `true` and just `offer` the shutdown message once, without any waiting. If `run()` is blocked, it take the message and abort, if it is busy it will check `isRunning()` on the next loop-iteration.  Thanks. In any case I would add to the description of `triggerShutdown` that it should be fast and that it's not supposed to block, similarly do how `doStart()` is described in the docs.
I believe that every blocking action there could be replaced with some smarter construct. Ah, good find. If you happen to find a solution to the issue above, please tell.

A `ClosableQueue` would be a nice addition to guava.  I do exactly this in Gradle and it works perfectly.  **app: guava
version: 20.0**

**code 1:**
```
public class EmbedMonitoredServices {

    // ------------------------------------------------------------------------

    private static final Logger logger = LoggerFactory.getLogger(EmbedMonitoredServices.class);

    private static final Set<Service> monitoredServices = Sets.newHashSet();

    private static ServiceManager monitoredServiceManager;

    private static MonitoredWebService monitoredWebService;

    // ------------------------------------------------------------------------

    private static MonitoredWebService getMonitoredWebService() {
        if (monitoredWebService == null) {
            monitoredWebService = new MonitoredWebService();
        }
        return monitoredWebService;
    }

    private static ServiceManager getMonitoredServiceManager() {
        if (monitoredServiceManager == null) {
            monitoredServices.add(getMonitoredWebService());
            monitoredServiceManager = new ServiceManager(monitoredServices);
        }
        return monitoredServiceManager;
    }

    // ------------------------------------------------------------------------
    
    public static ServiceManager manage() {
        return getMonitoredServiceManager();
    }

    // ------------------------------------------------------------------------

    public static class MonitoredWebService extends AbstractService {

        // --------------------------------------------------------------------

        private static final String CONTEXT_PATH = "/scout-web-monitor";

        private static final String PACKAGE_PATH = EnvironmentContents.PROJECT_HOME + "/lib/ext/scout-web-monitor-1.0.0.war";

        private static Server server;

        // --------------------------------------------------------------------

        @Override
        protected void doStart() {
            server = new Server(8080);
            MBeanContainer mbContainer = new MBeanContainer(ManagementFactory.getPlatformMBeanServer());
            server.addBean(mbContainer);
            WebAppContext webapp = new WebAppContext();
            webapp.setContextPath(CONTEXT_PATH);
            webapp.setWar(PACKAGE_PATH);
            webapp.addAliasCheck(new AllowSymLinkAliasChecker());
            webapp.addLifeCycleListener(new LifeCycle.Listener() {

                @Override
                public void lifeCycleStarting(LifeCycle event) {
                    LoggingUtils.info(logger, manage().servicesByState());
                }

                @Override
                public void lifeCycleStarted(LifeCycle event) {
                    LoggingUtils.info(logger, manage().servicesByState());
                    notifyStarted();
                    LoggingUtils.info(logger, manage().servicesByState());
                }

                @Override
                public void lifeCycleFailure(LifeCycle event, Throwable cause) {
                    notifyFailed(LoggingUtils.error(logger, cause));
                }

                @Override
                public void lifeCycleStopping(LifeCycle event) {}

                @Override
                public void lifeCycleStopped(LifeCycle event) {
                    notifyStopped();
                }

            });
            server.setHandler(webapp);
            try {
                server.start();
                // erver.dumpStdErr();
                server.join();
            } catch (Exception e) {
                throw LoggingUtils.error(logger, e);
            }
        }

        @Override
        protected void doStop() {
            try {
                server.stop();
            } catch (Exception e) {
                throw LoggingUtils.error(logger, e);
            }
        }

    }

}
```

**code 2:**
```
public static void startMonitoredService(PrintStream stdout, NmapProfile profile) throws Exception {
        showLogo(stdout);
        Environments.initializeLogback();
        LoggingUtils.info(logger, "Start Monitored Service.");
        EmbedMonitoredServices.manage().startAsync().awaitHealthy();
        LoggingUtils.info(logger, "Monitored Service started.");
        LoggingUtils.info(logger, "Monitored Service started.");
}
```

**print:**
```
[INFO] Start Monitored Service.
[INFO] Logging initialized @5375ms
[INFO] jetty-9.2.22.v20170606
[INFO] {NEW=[MonitoredWebService [STARTING]]}
[INFO] jetty-9.2.22.v20170606
[WARN] ServletContext@o.e.j.s.ServletContextHandler@542e560f{/,null,STARTING} has uncovered http methods for path: /
[INFO] Started ServerConnector@8c11eee{HTTP/1.1}{0.0.0.0:61614}
[INFO] Started @6749ms
[INFO] {NEW=[MonitoredWebService [STARTING]]}
[INFO] {NEW=[MonitoredWebService [RUNNING]]}
[INFO] Started ServerConnector@32a068d1{HTTP/1.1}{0.0.0.0:8080}
[INFO] Started @7163ms
``` OK,I know,comment line server.join is work fine.  Hi,

I'd like to share the report on API changes and backward compatibility for the Guava library, which I maintain as a hobby: https://abi-laboratory.pro/java/tracker/timeline/guava/

It's generated by the https://github.com/lvc/japi-tracker tool according to the article https://wiki.eclipse.org/Evolving_Java-based_APIs_2.

Hope it will be helpful for users and maintainers of the library.

Thank you.

![guava-2](https://user-images.githubusercontent.com/1517837/31373004-03ee7b5a-ada1-11e7-8307-1186db74f83a.png)
![guava-1](https://user-images.githubusercontent.com/1517837/31373005-040f91a0-ada1-11e7-8376-d2a89a917753.png)
 See also report for Guava GWT: https://abi-laboratory.pro/java/tracker/timeline/guava-gwt/  When creating `ImmutableSortedMap` instances the documentation for methods `copyOf` and `copyOfSorted` state: 

> "NullPointerException - if any key or value in map is null"

However this behavior is not consistent an it is possible to create a map with null values.

Given a `HashMap` of stings with `map:{a:null}` all the `copOf` methods throw as expected, with a `map:{a:null, b:two}` then none of the `copyOf` methods throw.

Given a `SortedMap` of strings with `map:{a:null}` and a natural order `copyOf` and `copyOfSorted` all throw as expected; with a `map:{a:null, b:two}` then `copyOf(Map)` and `copyOfSorted(SortedMap)` throw; `copyOf(Iterable)`, `copyOf(Iterable, Comparator)`, `copyOf(Map, Comparator)` do not throw; with a `map:{a:one, b:null}`
`copyOf` and `copyOfSorted` all throw as expected.

From what I can tell this behavior is only present for maps with two elements and only when the `null` is the first value of the first key. The `of` and `builder` methods are not effected an throw as expected.

  Move to the correct pom.xml.

Fixes #2920
Commit 9feba7c949ef9fd2092c05c29dcbe0ddba7a7cf5 of #2846 placed the `Automatic-Module-Name` declaration in the wrong`pom.xml`. As such, Guava still isn't a valid module, which blocks a whole heap of projects from declaring `module-info.java`.

Feel free to make a separate change rather than merging this PR to satisfy any IP rules. @jodastephen By my understanding, if you just sign the Google CLA, then that should be enough to allow this PR to be considered for merging. I signed it! As it stands, I don't think its clear how test libraries will operate with modules - I suspect that modules don't really apply there. If runtime code might depend on testlib then of course it should have a module name.  There are several issues with using `jsr305.jar` by Guava.

JSR-305 is dormant, has been for a long while and shows no hope of ever producing an agreed set of annotations in our lifetime. Further more these annotations use `javax.` packages which it is not possible to use according to the Oracle Java binary licence, so applications can not use and ship these dependencies along with a JRE without violating the Oracle licence agreement.

> F. JAVA TECHNOLOGY RESTRICTIONS. You may not create, modify, or change the behavior of, or  authorize your licensees to create, modify, or change the behavior of, classes, interfaces, or subpackages that are in any way identified as "java", "javax", "sun", “oracle” or similar convention as specified by Oracle in any naming convention designation.

The JSR-305 group has not defined any official releases according to its jsr page so the only implementations is a seemingly random implementation provided by the FindBugs team. Even if the team where experts on the JSR (which some where) they are not official as there has been no vote and are not available from the JSR hompage - so the javax package name restriction still applies.

Using `jsr305` causes additional issues, if Guava is used in a modular JDK9 applications, because it puts the annotations into `javax.annotation` package, which is also used by a couple of other JAR-s and a legacy JDK module `java.xml.ws.annotation`. If one wants to create a modular JDK9 application with two dependencies to conflicting JAR-s, Java refuses to compile and run it because of a package split. Example:

 * Guava -> forces us to require `jsr305` automatic module,
 * Dagger -> forces us to require either `java.xml.ws.annotation` or `jsr250` automatic module.

All of the modules use `javax.annotation`.

Findbugs has been rebooted as Spotbugs and they are going to make a switch from JSR-305 to their own internal annotations in version 4.0.0 that do not break anything:

https://github.com/spotbugs/spotbugs/pull/180

I think Guava should consider switching to them in order not to pollute application dependencies with `jsr305` JAR. I agree that this is more a long-term action. I created this issue more to raise the awareness of the problems with `jsr305` and new Java. Spotbugs 4.0 is not released yet, and other tools would have to agree for a new set of annotations, and provide the sufficient support. But on the other hand, Guava is in the right position to influence a decision, which way to go.

Regarding `javax.annotation.Generated`:

 * avoiding it will only reduce the problem, not remove it (JSR-250 contains other annotations, too - if any of them is in use by any dependency or main project, you need to patch the modules).
 * Java 9 provides a new, unambiguous variant: `javax.annotation.processing.Generated`,
 * you can detect which one of them is available by the classloader, and generate the code either without any annotation, with `javax.annotation.Generated`, or with `javax.annotation.processing.Generated`. For JDK8, it would work "as usual", and for JDK9, it would depend on the required JDK module in the application module descriptor, so that the developer has a choice, which way to go.

I appreciate that you didn't forget about `Generated` :). > If we're moving off the "standard" annotations, I wonder what it makes the most sense for us to migrate to.

Adopting the Checker Framework's annotations may make sense here. Considering that, AFAIK, its nullability annotations are the most plentiful and advanced out there, it may encourage more people to try the framework out.

But if its annotations count as type annotations, then we'd be unable to use them... > Hopefully most tools care only about the simple class name of the annotations, not their packages. 

This is not true of Kotlin, although they'll be receptive to adding your annotations to their list. Looking at the options, it seems to me that Checker Framework would be a good solution. Thanks for pointing me to that, @jbduncan. I'm curious what the replacement for `javax.annotation.concurrent.Immutable` is with Checker Framework, if there is one - do you happen to know, @jbduncan? @kashike I admit that I don't know if the Checker Framework has an `Immutable` annotation, but I _do_ know that error-prone's annotations project has one. I've never tried the Checker Framework personally, so I don't know how it behaves in combination with error-prone (which, by comparison, I _have_ used), but theoretically if one can get them to work nicely together, then we'd have a superior, statically analysed solution to `javax.annotation.concurrent.Immutable`. ...but that's not even considering the other sorts of annotations that we're already using and will probably still want to use, like `@Nullable`...

This may get tricky. The Checker Framework authors themselves suggest that their own type annotations are [backwards-compatible](https://checkerframework.org/jsr308/jsr308-faq.html#backward-compatibility) with Java 6, but only if they're written inside comments.

That's not exactly ideal... > ... Spotbugs is a natural choice, since we know it has all the annotations that we want.  ...

Does it? I [don't see everything](https://github.com/spotbugs/spotbugs/tree/master/spotbugs-annotations/src/main/java/edu/umd/cs/findbugs/annotations) that was listed [above](https://github.com/google/guava/issues/2960#issuecomment-336681820) - it appears as if some annotations that are used by Guava are not in spotbugs.

As for Checker Framework: it appears to have most things, except `@Immutable`: https://gist.github.com/kashike/d8fb2007ab01041a08a2d5cf20bc2d17

~...create a custom `@Immutable` annotation?~ It seems as if errorprone has one already, actually.
 @kashike Apologies if I've not explained myself very well before, but I just want to make sure we're both on the same page with regards to the Checker Framework's annotations.

It seems to me from what @cpovirk's said already and what I personally know of the Checker Framework's annotations that, sadly, since they are  _type annotations_, they can only be used in Java 8+ projects - JSR308, which is what type annotations are derived from, is only implemented in compilers that understand Java 8.

This is a problem because `guava-android` is compiled with a Android toolchain, and modern Android toolchains only understand Java 7 syntax and a small subset of Java 8 syntax - not enough to understand type annotations as legal constructs.

The only workaround I've found so far (suggested by the Checker Framework authors [here](https://checkerframework.org/jsr308/jsr308-faq.html#backward-compatibility)) is to write type annotations in comments. So, for example, instead of:

```java
List<@Nullable String> listOfNullsAndStrings = ...;
```

we'd have:

```java
List</*@Nullable*/ String> listOfNullsAndStrings = ...;
```

The Checker Framework understands type annotations written like this, but I somewhat doubt other tools like IntelliJ IDEA, {Find,Spot}Bugs, and Google's internal tools understand them written like this too. Thus, we may not be able to use the Checker Framework's annotations in Guava until Android catches up.

If you did understand this already, apologies! Otherwise, I hope that this has cleared things up a bit. :) Thanks for the reply, @jbduncan. I'm also looking at what to use in my own projects (which are Java 8) - sorry for not stating this.

I've been using `com.google.code.findbugs:jsr305` for a long time now, but this issue has made me want to switch to something new (which, in this case, is currently going towards `org.checkerframework:checker-qual`) for annotations on things (I annotate pretty much everything that can be annotated with `@Nonnull` or `@Nullable`, as well as `@Immutable`). `checker-qual` seems to have everything *except* `@Immutable`.

I'm trying to find a replacement that has everything I need, but I haven't been able to yet. Perhaps I'll delay switching until the Guava team comes to a solution for this issue in Guava.  Hello,

This is continue of #2152 the problem still exists, but this time on java 9.

```log
java version "9"
Java(TM) SE Runtime Environment (build 9+181)
Java HotSpot(TM) 64-Bit Server VM (build 9+181, mixed mode)
```
I've tested with 22.0, 23.0, 23.1

 Tested with 23.1 as well, on java 8 it works fine but on java 9 not discovering anything.
i don't use special chars it was working fine on 22.0 i've upgraded my project to java 9 and it didn't discover any class then i tried 23.0 and 23.1 versions and none of them discovered any class. Same way as shown in #2152 
```java
    @Test
    public void testMain() throws Exception {
        ClassLoader loader = this.getClass().getClassLoader();
        ClassPath p = ClassPath.from(loader);
        ImmutableSet<ClassPath.ClassInfo> list = p.getTopLevelClasses("testpackage");
        Assert.assertEquals(3, list.size());
    }
```

Also tried with `ClassLoader.getSystemClassLoader()` and `Thread.currentThread().getContextClassLoader()` Upgrading to 23.1 fixed the issue for me.
```
openjdk version "9"
OpenJDK Runtime Environment (build 9+181)
OpenJDK 64-Bit Server VM (build 9+181, mixed mode)
```
Using like this from kotlin:
```kotlin
val topClasses = ClassPath.from(SomeClass::class.java.classLoader).topLevelClasses
```  Hacktoberfest looks like a good opportunity to get some project exposure as well as get some issues worked. Any contributors/maintainers interested in tagging some issues with the `hacktoberfest` label?  Awesome! Just thought I would toss the idea out there.  Here is an example where someone modified the TreeSet and TreeMap to include indexing functionality:
https://code.google.com/archive/p/indexed-tree-map/

I find this to be very useful, and is easily added to any binary search tree.  Just include the weight of each subtree, and update the weights as necessary.  Use the weights to find nodes by index, and vice-versa. It is more similar to the existing tree multi set. I found a couple of more examples.  In javolution.org, they have a FastSortedTable, which supports indexing.  No idea if it uses a tree, but it is basically a multiset.
http://javolution.org/apidocs/index.html

Then the Goldman Sachs / Eclipse Collections has something called TreeSortedSet, and UnmodifiableSortedSet.  These have indexOf, and forEach using a range of indices.
https://www.eclipse.org/collections/javadoc/9.0.0/index.html?overview-summary.html

This may be the closest description:
https://en.wikipedia.org/wiki/Order_statistic_tree
 @jrtom Sorted lists. Like some sort of alternative to `MinMaxPriorityQueue`? - uniformly random selection
- median and other quantiles
 agree with @maaartinus. you can use this extended ability to create stemplots of any size, too. @lowasser Your alternative may be very inefficient if the data set is modified frequently. What's more, it only supports Doubles. It is a better alternative to GapList here https://dzone.com/articles/gaplist-lightning-fast-list   Fix misspelled method name from "substing" to "substring".  In version 23.1, it looks to me that `com.google.common.graph.Traverser` has been released, but that the class has not been fully implemented yet. Was it intended to release Traverser so soon?

/cc @cgdecker  SGTM @jrtom. I'll close this issue then, as I anticipate it will resolve itself eventually. :)  Now,I have a need that get a live view of Map<K,V> from collection<V>.
Originally,i thought Maps.uniqueIndex was what I wanted.
But,i found that the Maps.uniqueIndex return type is ImmutableMap,it don't update when the collection<V> update.

For example:
```
class TestGuavaA {
    public TestGuavaA(Long id,String code, String type, String author) {
      super();
      this.id = id;
      this.type = type;
      this.code=code;
      this.author = author;
    }
    private Long id;
    private String code;
    private String type;
    private String author;

    @Override
    public String toString() {
      return ToStringBuilder.reflectionToString(this, ToStringStyle.NO_CLASS_NAME_STYLE);
    }
  }
```
I want to get a Map<Long,TestGuavaA> idToObjects,a Map<String,TestGuavaA> codeToObjects from a collection<TestGuavaA>,and modifications to the backing collection are read through to the two returned map.
This like Maps.asMap ,but is inverse.

How can i do it? Or how can i get a live view of Map<K,V> from Map<T,V>?
For example:I want to get a Map<Long,TestGuavaA> idToObjects from a Map<String,TestGuavaA> codeToObjects,and modifications to the backing map are read through to the two returned map. Thank you.I know why we can't get a live view.
But how about this idea that use decorator pattern and observer pattern to create a Map of  keep update?
What's wrong about my thinking? Thank you.   @JainSid96 @cpovirk It's not really clear to me what purpose this PR serves, given that it contains many existing commits from master. Could you clarify its purpose for me? @JainSid96, would you mind at all closing this PR? AFAICT, it is just tracking the new commits that are being added to Guava, and thus it's spamming my email inbox.  Java 8u144 (Mac 10.11.6)
Guava 23.0

Expected: Calling `parallelStream()` on an ImmutableMap-derived Set should lead to pipeline execution on multiple threads. Calling `spliterator()` on a ImmutableMap-derived Set should yield a splittable (`trySplit() != null`) spliterator.

Actual: Pipeline executes on main thread only. Spliterator is not splittable.

Diagnosis:
The spliterator is ultimately constructed using an `IntStream#range` which is sequential. The `AbstractWrappingSpliterator` that results from the `mapToObj` checks the stream context and refuses to split if the stream is sequential (even though the underlying spliterator is splittable, see `trySplit:189, StreamSpliterators$AbstractWrappingSpliterator (java.util.stream)`). `RegularImmutableSet` and friends are constructed using `ArraySpliterator`, which don't have this problem.

```
range:798, IntStream (java.util.stream)
indexed:94, CollectSpliterators (com.google.common.collect)
indexed:40, CollectSpliterators (com.google.common.collect)
spliterator:386, ImmutableSet$Indexed (com.google.common.collect)
parallelStream:602, Collection (java.util)
```


```
public class Problem {

  public static void main(String[] args) {
    Set<String> list = Stream.iterate("a", str -> str + "a")
        .limit(1000)
        .collect(toImmutableMap(Function.identity(), Function.identity()))
        .keySet();

    Logger logger = Logger.getAnonymousLogger();
    logger.info("Parallel stream is parallel: " + list.parallelStream().isParallel());
    logger.info("Parallel stream's spliterator can be split: "
        + (list.parallelStream().spliterator().trySplit() != null));

    ThreadLocal<Boolean> invoked = ThreadLocal.withInitial(() -> false);

    list.parallelStream()
        .map(str -> {
          if (invoked.get()) {
            return str;
          }
          invoked.set(true);
          logger.info("Parallel stream executed on thread " + Thread.currentThread().getName());
          return str;
        })
        .forEach(str -> {});
  }

}
```

Expected:
```
INFO: Parallel stream is parallel: true
INFO: Parallel stream's spliterator can be split: true
INFO: Parallel stream executed on thread main
INFO: Parallel stream executed on thread ForkJoinPool.commonPool-worker-4
INFO: Parallel stream executed on thread ForkJoinPool.commonPool-worker-2
...
```

Actual:
```
INFO: Parallel stream is parallel: true
INFO: Parallel stream's spliterator can be split: false
INFO: Parallel stream executed on thread main
```  Fix addresses a problem occurred on IBM JDK 6. To ensure 
that we can call underlying method, Throwables#getSizeMethod, 
to get  stack size, first a smoke test  with dummy exception. 
Once method executed with success, it is safe to return it for 
further usage.

Issue: https://github.com/google/guava/issues/2887 For the sake of clarification: there were two obvious ways:

- Guard a call to `JavaLangAccess#getStackSize` inside `AbstractList#size` in `Throwables#jlaStackTrace` with `try-catch`
- Make a dry call of `JavaLangAccess#getStackSize` and if it success, then assume, that it is safe to call it

We can go with the first option, however, I think, that second seems more elegant.  @cpovirk 
Exactly. I think it just ensures that API works fine, instead of making only one method out of two work as designed.
However, I don't have any idea, how to simulate/test it with a unit test (most probably there's no way even to do that, since it more likely to be a system/end-to-end one)  Removed duplicate tests, unified naming I signed it!  This patch changes `-android` version suffix to `-ga` for Android / Java 7 flavored version of Guava, resolving #2914.

The resolution piggy-backs on documented Maven [`ComparableVersion`](http://maven.apache.org/ref/3.5.0/maven-artifact/apidocs/org/apache/maven/artifact/versioning/ComparableVersion.html) feature that equates `ga`-suffixed versions (e.g. `24.0-ga`) with non-suffixed ones (e.g. `24.0`) in the context of comparing / ordering / determining the latest version.

Note: This also reverts [the patch](https://github.com/google/guava/commit/61d2a6faec8b27d021b9f37f7dfb6655ae060fad) by @cpovirk, restoring the original vanilla (Java 8+) Guava versioning scheme (e.g. from patched `24.0-jre` back to `24.0`).

Note: [`README.md`](https://github.com/google/guava/blob/master/README.md#latest-release) text should be updated before releasing the next version to reflect the suffix change for the Android version. I have read the issue linked. Nevertheless I think using `-ga` instead of `-android` will lead to a lot of confusion. Without having seen this pull request I would not have known the difference between `24.0` and `24.0-ga` and would most likely have picked `24.0-ga` when updating (since general availability seems better than no suffix). @ooxi You'd have every right to get confused initially (even though such mistake would usually get immediately realized at your project compile time) - what Guava is trying to achieve with releasing both android/java7 and java8+ artifacts is indeed confusing. Arguably, they do have a reason for doing this, though.

As to `GA` version being considered "better" than plain (non-suffixed) release one - I'm not sure it's clear cut (and might be highly subjective, depending on one's history of exposure to these). When I encounter such versions I try to check the project documentation on their versioning scheme and semantics.

Wikipedia's Software release life cycle article has this diagram:
![Software release life cycle](https://upload.wikimedia.org/wikipedia/commons/0/07/Software_dev2.svg)
which probably (yet not necessarily) reflects some majority opinion / consensus on the topic.

Anyway, in case of a doubt a quick glance at [Guava project landing page](https://github.com/google/guava/#latest-release) should clear any confusion and make the choice between vanilla and android/java7-specific version reasonably obvious. Thank you for such an in-depth explanation of your reasoning. While I still would have been confused and would likely have chosen the wrong version at first, you are right in your estimation that it would have been more logical to use `24.0` than `24.0-ga`. I therefore withdraw my initial rejection of this change.  We've got an `Equality` helper class in our code base that helps us implement `equals` and `hashCode` methods, and I think it'll be a nice feature for guava. It's similar to `ComparisonChain`, but for equality.

The API is basically this:

    @Override
    public boolean equals(Object obj) {
        return Equality.startComparison(this, obj, MyObj.class)
                .superEquals(super::equals)
                .field(MyObj::val1)
                .field(MyObj::val2)
                .intField(o -> o._int)
                .booleanField(o -> o._bool)
                .arrayField(o -> o._array)
                .field(o -> o._obj, new CustomEquivalence())
                .result();
    }

    @Override
    public int hashCode() {
        return Equality.startHash(this)
                .superHashCode(super::hashCode)
                .field(MyObj::val1)
                .field(MyObj::val2)
                .intField(o -> o._int)
                .booleanField(o -> o._bool)
                .arrayField(o -> o._array)
                .field(o -> o._obj, new CustomEquivalence())
                .result();
    }

    public boolean staticEquals(T obj1, T obj2) {
        return Equality.startComparison(obj1, obj2)
            .field(...)
            .field(...)
            .result();
    }

The benefits of this API are:
- It automatically handles null checks, casting, object equality, type safety, and short-circuits when appropriate.
- Implementing `equals` and `hashCode` are symmetric - just copy and paste the `.field(...)` calls. It's also easy to see if you've missed out a field from one of the methods
- It removes all the boilerplate otherwise necessary, and you can easily see what is used to determine equality in the class.

There is AutoValue, but there are many situations where you can't or don't want to use auto-generated classes like that, and this can be used to easily replace existing equals methods without otherwise changing the class. There are some cases where you either can't or don't want to use AutoValue, and then this API will really help with those manual implementations.

This API is also very useful for easily writing an `Equivalence` implementation.   Scenarios like the following happen way too often:
```java
List<Integer> myList = ...;
int myInt = myList.size > 1 ? myList.get(1) : -1;
```
My suggestion is to add a method to the `ObjectArrays` and `Lists` classes which gets an element out of a list/array or returns the default value when the index of the element is out of bounds.

Example usage:
```java
List<Integer> myList = ...;
int myInt = Lists.getDefault(myList, 1, -1);
```
This could also be done with `Optional`s:
```java
List<Integer> myList = ...;
int myInt = Lists.get(myList, 1).orElse(-1);
``` This is already in `Iterables`, no?
```java
Iterables.get(myList, 1, -1);
```
And its docs also note the JDK8 equivalent, which could also be used for arrays:
```java
Arrays.stream(myArray).skip(1).findFirst().orElse(-1);
```  The [lookup3.hashlittle()](http://www.burtleburtle.net/bob/hash/doobs.html) hashing function is useful for anything where one collision in 2^32 is acceptable, as described in the c code documentation. As I found no implementation for java in any well-known library, I believe that the adding this hashing function to Guava is a good addition to the library and users of the hashing package.

If accepted, I would like to contribute with code to add this feature. Thank you in advance. I am proposing to add an entire `HashFunction` implemented in java. I think that it is a good addition to compute hashes for table lookups.

An example usage case is to get the checksums for the HDF5 fileformat, which uses it for computing the checksum of different file blocks.  Refer to objects by their interfaces(Item 52) I signed it!  Example:
```java
if (Objects.equal(status, "STOPPED") || Object.equal(status, "RELEASED") || Object.equal(status, "DELETED")) {
    // do something
}
```
Could we add a method `Objects.equalAny(Object, Object...)`, then example will be: 
```java
if (Objects.equalAny(status, "STOPPED", "RELEASED","DELETED")) {
    // do something
}
```
It's simple, right?

Here is my implementation:
```java
  public static boolean equalAny(@Nullable Object a, @Nullable Object... any) {
    if (any == null && a == null) {
      return true;
    } else if (any != null) {
      for (Object obj : any) {
        if (equal(a, obj)) {
          return true;
        }
      }
    }
    return false;
  }
``` Can't you just do:
```java
if (Arrays.asList("STOPPED", "RELEASED", "DELETED").contains(status)) {
    // do something
}
``` @Stephan202 `Arrays.asList()` no dependency and maybe more faster for several elements;
@kluever `ImmutableSet.of()`  elegant and fast for much more elements;
Both ok, thanks  @lowasser  Maybe there should be `Ints.reverse(int[])`? Then a two step solution would be fast. If there is reverse sorting, I would think there should be an interface for implementing your own comparator (`IntComparator`, `FloatComparator`, etc.) which behave like a `Comparator`, but for primitives.

```java
Ints.sort(new int[] {5, 2, 3, 1}, Ints::compare); // IntComparator can be functional
```

There would need to be an implementation of sorting (mergesort, quicksort) which utilizes the custom comparator interface - one for each primitive potentially.

Edit: On the other hand, that is quite a bit of baggage to add, might as well use https://github.com/mintern-java/primitive. > Edit: On the other hand, that is quite a bit of baggage to add, might as well use https://github.com/mintern-java/primitive.

@thekeenant On the other hand, that library looks like it's licensed under the GPLv2 + Class Exception, which doesn't sound great to me for projects except GPL-licensed ones. That's what the classpath exemption is for.

On Fri, Sep 8, 2017 at 3:52 PM Jonathan Bluett-Duncan <
notifications@github.com> wrote:

> Edit: On the other hand, that is quite a bit of baggage to add, might as
> well use https://github.com/mintern-java/primitive.
>
> @thekeenant <https://github.com/thekeenant> On the other hand, that
> library looks like it's licensed under the GPLv2 + Class Exception, which
> doesn't sound great to me for projects except GPL-licensed ones.
>
> —
> You are receiving this because you are subscribed to this thread.
> Reply to this email directly, view it on GitHub
> <https://github.com/google/guava/issues/2936#issuecomment-328198178>, or mute
> the thread
> <https://github.com/notifications/unsubscribe-auth/AAEEEZXdAvDJj3s4jjaXEbot8YXiAtolks5sgZrjgaJpZM4PPEa8>
> .
>
 Note that [fastutil](https://github.com/vigna/fastutil) has `IntArrays#quickSort(array, IntComparator)`. Similar support is provided for other primitive types plus other sort strategies. For those who work with primitives for performance reasons, they may already be using libraries dedicated towards that purpose.   here is the requirements:

I need to manipulate the bits array directly in my case, but since the bloomfilter is a final class, I cannot extend and use such private member directly.
the only way I can do is to hack, use the bloomfilter instance as a member, and repeat what you do for the bitarray. :(
any explanation why set it to be final class? still it's about the implementation of the bloomfilter
https://github.com/google/guava/blob/master/guava/src/com/google/common/hash/BloomFilter.java > any explanation why set it to be final class?

I think it's final for the reason given in [Effective Java 2nd Edition](https://www.amazon.co.uk/Effective-Java-Second-Joshua-Bloch/dp/0321356683), _Item 16: Favor composition over inheritance_. ...but the Guava team may be able to clarify if I'm mistaken on this. :)  It's often necessary to know the size of the collection being built. For example, to special case if this is the first element, or if the collection is empty. The workarounds are ugly.

This should be free for most builders since they already track the size. I only care about this for `List`, `Set`, and `Map`, so if it's fine if it can't be added for more exotic collections like `ListMultimap`.

 I believe this has been done for `ImmutableList` [recently](https://github.com/google/guava/commit/7928bbe079303c54373453353c9ef2cd7de9365e) - so recently that it's not had the chance to make it into a release yet. AFAICT, sized builders have yet to be added for `ImmutableSet` and `ImmutableMap`. Oops, I think I posted too quickly for my own good!

If I understand what you're asking, you're asking for a method like `Immutable{List,Set,Map}.Builder#size`  for querying the size of a builder, rather than builders which are pre-sized to a certain size. Have I understood you correctly? (@lowasser got there before me. :) ) @jbduncan yes, exactly. Apologies for not explaining more clearly.

@lowasser that's a great point about duplicates for `ImmutableSet`.

We could add a `size()` method for `ImmutableList`, `ImmutableMap`, and any others where it makes sense and is free. Additionally, we could add an `isEmpty()` method for most/all builders. Knowing if the collection is empty will cover a good number of use cases, though sometimes you do need the size (most often for `ImmutableList`).  Related Pull request to fix the documentation https://github.com/google/guava/pull/2916 has been merged. 

If the delegate in the Suppliers.memoize throws an exception on calling get() then further calls to the get() method of the Memoized suppliers still goes to the delegate. With the pull request the Javadocs clarify that there is a danger that the underlying delegate could be called more than once. 

What we need is a method with the following signature

`Suppliers.memoize(Supplier<T> delegate, boolean memoizeExceptions)`

By default the single argument memoize method could delegate to the above method with a "false" flag i.e, exceptions are NOT memoized by default. However if true is passed then even when the delegate throws an exception, that exception is stored by the memoized supplier and is re-thrown everytime it is called.

**Use cases where this can be used**

- A class X uses a memoized Supplier the delegate talks to an external Paypal like service or a configuration service. When the delegate fails we do not want to retry the external service (until such time as we have a notification that the external service is back up in which case class X re-initializes the supplier)
- A class X has a memoized supplier with expiration of 5 seconds and wants an absolute guarantee that even in the case of failures the underlying delegate is NEVER called more than once in 5 seconds.

I am happy to contribute a patch if this new API is accepted.  Any updates? I am very happy to contribute a patch if people think this is a sensible change to implement Just an opinion, but I feel like memoizing the exception could have some "surprising" behavior:

- As @kevinb9n mentioned, it would still have the original stacktrace when it's rethrown on subsequent calls, which could be confusing and unhelpful to people trying to debug it.
- Exception classes sometimes assume that they're going to be immediately used by the "catch" block and then discarded. Some of them might store "heavyweight" data, expecting that will be garbage collected shortly. Or they may even reuse and modify objects within the exception at a later time, which would be (incorrectly) reflected when the original exception is rethrown later.

I think it's better if it's responsibility of the original supplier to provide additional behavior like memoizing exceptions (as appropriate to your application) or throttling calls.  @eldk Have you tried updating to the latest version of `guava-android` (23.0, I believe) instead? :) (You can find the Maven/Gradle co-ordinates for `guava-android` at https://search.maven.org/#artifactdetails%7Ccom.google.guava%7Cguava%7C23.0-android%7Cbundle). Thanks for letting me know the results of applying 23.0-android @eldk! This is out of my league now unfortunately, so let's wait for someone from the Guava team to reply. Those rules are vastly overly keep-y. Why are you suppressing warnings and
then also keeping for each?

On Mon, Aug 28, 2017 at 3:32 PM eldk <notifications@github.com> wrote:

> Hello,
>
> With :
> -dontwarn java.lang.ClassValue
> Proguard (4.7) still throw errors.
>
> In #2117 <https://github.com/google/guava/issues/2117> the link to that
> topic
> https://stackoverflow.com/questions/9120338/proguard-configuration-for-guava-with-obfuscation-and-optimization
> gives the solution for Guava 20.0 .
>
> -dontwarn com.google.common.base.**
> -keep class com.google.common.base.** {*;}
> -dontwarn com.google.errorprone.annotations.**
> -keep class com.google.errorprone.annotations.** {*;}
> -dontwarn com.google.j2objc.annotations.**
> -keep class com.google.j2objc.annotations.** { *; }
> -dontwarn java.lang.ClassValue
> -keep class java.lang.ClassValue { *; }
> -dontwarn org.codehaus.mojo.animal_sniffer.IgnoreJRERequirement
> -keep class org.codehaus.mojo.animal_sniffer.IgnoreJRERequirement { *; }
>
> Thanks @cpovirk <https://github.com/cpovirk> , @breyed
> <https://github.com/breyed>, @gengjiawen <https://github.com/gengjiawen>
>
> Eric
>
> —
> You are receiving this because you are subscribed to this thread.
> Reply to this email directly, view it on GitHub
> <https://github.com/google/guava/issues/2926#issuecomment-325455128>, or mute
> the thread
> <https://github.com/notifications/unsubscribe-auth/AAEEEd066G4sdYg6jNJBXp_KKzdvtGQIks5scxWwgaJpZM4PDKt0>
> .
>
  There's probably a good reason why we've had ImmutableList.toImmutableList since 21, but not this yet. But hey, doesn't hurt to ask :) Thanks! 🤦  In Guava 23...

Assume `nodeA` exists but  #`nodeU` does not exist. Execute:

`graph.edgeValueOrDefault(nodeA, nodeU, 5)`

The result is `null`. I would expect the result to be `5`, given that there is no edge between `nodeA` and non-existent `nodeU`. Guava 22 an earlier have the expected behavior.

I see that Guava 23 now returns an `Optional` for `edgeValue`, so the statement can easily be converted to `graph.edgeValue(nodeA, nodeU, 5).orElse(5)`, however if this is the intended behavior of the `edgeValueOrDefault` method for this situation, it deserves some additional explanation in the Javadoc. Or simply deprecate this method and recommend people transition to `edgeValue().orElse()`. Now that Guava is going to have more frequent releases and thus 23.2 is likely to be released before 24, I wonder if it would make sense to shift the milestone to 23.x.

@cpovirk, do you have any thoughts on this?  With the progress of Java 8 adoption in Android toolchain, especially the maturity of [desugar](https://developer.android.com/studio/write/java8-support.html#supported_features), the core Java 8 language features (not APIs) are now commonly used in Android development.

Currently the Android branch is fully Java 7 compliant, effectively departed from the evolution of the mainstream of Guava library. As more and more Guava functions take advantages out of Java 8 language features, especially lambda and interface default / static method, for more convenient APIs, we Android developers are still bound by the old Java 7 coding style, just because of the libraries we are using.

Please consider adopting interface default / static method in the Android branch of Guava in a future version, like some popular Java 8/9 backport libraries (such as [Android Retro-stream](https://github.com/retrostreams/android-retrostreams)). Got that, The word "android" in the branch name is a little misleading, I thought it was made solely for Android development.

Hope some day in the future, we could ditch the 1.7 source compatibility and move on. But at present, Android is still in painful version fragmentation, desugar is our only consolation for that.  I was looking at some source code when I came across one comment that let me think :
https://github.com/google/guava/blob/5087f785bed999500743e2775192ffc17d14bce6/guava/src/com/google/common/primitives/Primitives.java#L42
I still can't figure out why a BiMap can't be used there. 
To my mind, the implementation would be cleaner :
```java
    private static final BiMap<Class<?>, Class<?>> primitiveToWrapperType = ImmutableBiMap.<Class<?>, Class<?>>builder()
                .put(boolean.class, Boolean.class)
                .put(byte.class, Byte.class)
                .put(char.class, Character.class)
                .put(double.class, Double.class)
                .put(float.class, Float.class)
                .put(int.class, Integer.class)
                .put(long.class, Long.class)
                .put(short.class, Short.class)
                .put(void.class, Void.class)
                .build();
```
instead of :
```java
  /** A map from primitive types to their corresponding wrapper types. */
  private static final Map<Class<?>, Class<?>> PRIMITIVE_TO_WRAPPER_TYPE;

  /** A map from wrapper types to their corresponding primitive types. */
  private static final Map<Class<?>, Class<?>> WRAPPER_TO_PRIMITIVE_TYPE;

  // Sad that we can't use a BiMap. :(

  static {
    Map<Class<?>, Class<?>> primToWrap = new HashMap<Class<?>, Class<?>>(16);
    Map<Class<?>, Class<?>> wrapToPrim = new HashMap<Class<?>, Class<?>>(16);

    add(primToWrap, wrapToPrim, boolean.class, Boolean.class);
    add(primToWrap, wrapToPrim, byte.class, Byte.class);
    add(primToWrap, wrapToPrim, char.class, Character.class);
    add(primToWrap, wrapToPrim, double.class, Double.class);
    add(primToWrap, wrapToPrim, float.class, Float.class);
    add(primToWrap, wrapToPrim, int.class, Integer.class);
    add(primToWrap, wrapToPrim, long.class, Long.class);
    add(primToWrap, wrapToPrim, short.class, Short.class);
    add(primToWrap, wrapToPrim, void.class, Void.class);

    PRIMITIVE_TO_WRAPPER_TYPE = Collections.unmodifiableMap(primToWrap);
    WRAPPER_TO_PRIMITIVE_TYPE = Collections.unmodifiableMap(wrapToPrim);
  }

  private static void add(
      Map<Class<?>, Class<?>> forward,
      Map<Class<?>, Class<?>> backward,
      Class<?> key,
      Class<?> value) {
    forward.put(key, value);
    backward.put(value, key);
  }
```
Could you enlighten me please ? Sad indeed...
Thank you to help me understand !    You forgot to rebase and squash the branch to have only a single commit. sorry, I'm going to create a new pr on this.  Hi,

Do you have any idea why Lombok annotation processor stopped working after upgrading Guava from 16.0.1 to 23.0? I have a lot of dependencies in my project, so it might be something else, because I tried creating a sample project with only guava and lombok, and it worked just fine, but it's still Guava upgrade causing problems.

Regards,
Marcin Hi @marcingrabda.

That's not really a lot of information to go by. We may be able to help you if you can provide us with a [MVCE](https://stackoverflow.com/help/mcve). You may actually find that in producing the MVCE, you locate what's causing Lombok to stop working for you. :)

Hope this helps. Alternatively, since you've apparently said that you created a MVCE of your own in private (which I missed first time, sorry!), you could try building up your MVCE to gradually look more like the project you're dealing with that has the Lombok problem. I hope that it would allow you to locate the source of the problem.

Hope this helps again. I just tried doing it, but ended up with something that compiled/worked fine :) In case I give it one more try, I will let you know, if I found anything.  Clarify javadoc about the delegate being called utmost once. This is not true if the get method on the delegate throws RuntimeException. @googlebot signed the CLA now! Can someone tell me why there is a tag of cla:no ? I have signed the CLA 8 days ago? @kannanekanath, it seems that @googlebot wasn't intelligent enough to realise beforehand that you requested it to check the CLA status for you.

IIUC, it reacts best to phrases like "I signed it!", so for the future I'd suggest trying that. :)  in 2 create functions, with fpp setting it's INT, but given the default one (0.03), it's LONG, what is the point? in fact, by the way, can we expect more than MAX_INT insertion for this bloomfilter implementation? any clarification? @itismewxg Just to be sure, are you talking about BloomFilter or something else? Yes, I mean Bloomfilter,   so, still no answer?  Guava for Android is lacking classes that are provided in Guava for the JRE (notably around support for Java 8 in the immutable collections). The two are not interchangeable. 

Maven's dependency resolution looks at group and project IDs, and then attempts to find the most recent version. Because the only difference between the android and JRE versions of guava is the version number, this can result in Java 8 projects getting the Android version of Guava (and, presumably, vice versa).

For reference, at the time of writing [search.maven.org](http://search.maven.org/#search%7Cga%7C1%7Cguava) believes the most recent guava release is the one for Android.

![guava-oops](https://user-images.githubusercontent.com/28229/29334655-14dc5d96-8200-11e7-8276-ebdd616ef661.png)

The correct thing to do is give the Android version a different project ID. Seems like a classifier would be far more appropriate. That would also work, so long as the JRE version retained the default classifier (which I think is `jar`). See #2839, as well. #2839 could also be resolved by adding a classifier. Expecting just the version string to work won't work. Can we please get a 23.1 release that just adds the classifiers and stops projects breaking? Then pick a different project ID :) The problem right now is that more and more projects are potentially being broken. Using the right terminology now :)

So the maven namespace is segmented by group id (which can be `com.google.guava`), artifact id (which is currently `guava` in both cases) and version (`23` or `23-android` right now). The correct solution, as pointed out, is to use a classifier, but apparently this is hopelessly broken.

The next best solution is to change the artifact id. This will lead to a situation where people might end up depending on both `guava` and `guava-android`. A group id can have many different artifact ids without them clashing --- if they couldn't then maven as we know it couldn't work. @cpovirk @shs96c I'm not sure I understand what the problem is with a project potentially depending on both `guava` and `guava-android`. Can you elaborate further for me? @jbduncan, it depends on what you're targeting, and what gets put into your classpath:

- An app targeting android might end up with the JRE version of guava. In that case, someone might mistakenly depend on methods that aren't available in the Android SDK (eg. the `Stream` APIs)

- An app targeting desktop guava might not compile properly because they depend on classes that aren't present in the android flavour.

Because the packages are the same, whichever is first on the classpath will be selected. In some cases, this will work as expected. In some cases it won't. Because maven's dependency resolution is "novel" at best, which you get is a bit of a crapshoot. Unless you use version pinning, the version dependency appears to be advisory at best. @cpovirk yes there's a problem. Doing that will break android projects.
 @cpovirk, I think your understanding of maven dependency resolution isn't quite right. It does a BFS of dependencies, picking the first one that it finds. Thus, even if something like selenium declares a dep on "23.0-server", unless it's "closer" to the build than the one that specifies "19.0", version 19 will be selected. Re: Android. Yes, that's exactly what I'm saying. It's a thorny problem. Re: "guava-server". Not all java implementations are server-side. I think `guava` and `guava-android` are clearer. If you want to really spell out that one version is for the JRE, `guava-jre` seems to more accurately describe the version. Re: "maven dependency resolution" Glad you know about the full horror of how maven selects versions. It's good to have company :) 

I'm just getting reports from users who are using maven's default versioning strategy (not necessarily using gradle). I guess they're using [aether](https://wiki.eclipse.org/Aether/What_Is_Aether).

You know, GH could really do with threading of comments. In case it isn't clear, this particular issue Selenium was having was due to leaving the version as open ended:

    <dependency>
      <groupId>com.google.guava</groupId>
      <artifactId>guava</artifactId>
      <version>[23.0,)</version>
    </dependency>

This allows selenium to specify the minimum required version of guava but anticipating that we will still be compatible with future versions of guava that another project may specify. The problem we encounter is that if another project depends upon us and doesn't specify their version of guava, maven may choose the 'latest' it finds in central... which by timestamp happens to be 23.0-android.

Having users not accidentally include both android and jdk 8 versions is certainly a problem... but solving it in this way feels like bad maven practice. It seems like it's a bug for maven to try to figure out a way for everyone to identify two packages that are incompatible with each other.
 `jre` just means `Java Runtime Environment`. IBM ships one too, and the OpenJDK has a "jre" package . I _think_ it's an accepted industry term.

Yes, that's the aether version I was referring to. I think that https://github.com/google/guava/issues/2914#issuecomment-322818286 properly describes the problems that guava users are experiencing, and is what we should be trying to resolve. Oof, I can see that this is not easy to resolve. Just reading this comment thread is enough to do my head in. :stuck_out_tongue_winking_eye:

@lukeis Do you know if the Selenium team ever considered one of the following workarounds?
1. Use a static version of Guava, and update it periodically.
2. "Shade" Guava into Selenium with a tool like the Maven Shade plugin? @jbduncan we are currently working around the issue by setting the version explicitly to 23.0.

Selenium is highly customizable, in particular with our "Grid / Server" product. It would be a bit unkind to those users to shade a dependency that may need upgrading in a timely manner... we don't always timely upgrade our guava reference and it can be many months between our releases when we all get busy. @jbduncan: I'm the selenium lead :)

1. Internally we use a static version of guava, but our maven dependency used to pin to `(23,]` (version 23 or later). Prior to that, we didn't specify a range `23.0`, but this caused problems when we replaced usages of guava's `Function` with java 8's.
2. Shading will bloat the jar, and won't resolve this issue for other users. @cpovirk, yeah, making sure that the jre version is released after the android version will mask this issue for many users. Note that if different coordinates are used, in addition to the classpath ordering issue you could run into same-package conflicts in Java 9 if I understand Jigsaw correctly. If Android later supported modules then a module conflict would occur. If you went down this path then using a different package name would be advisable. The current solution avoids that, though has its own problems.

Per @cpovirk's link to the Maven's Version Plugin for update checks, a similar [plugin](https://github.com/ben-manes/gradle-versions-plugin) for Gradle exists using its dependency resolver. I personally prefer the Maven best practice of not using dynamic versions, optionally locking them down, and excluding when appropriate. In Gradle one can use a `resolutionStrategy` to reject a dependency, e.g. if the version has `-android` in it. I never had to do that in Maven though perhaps it has a similar capability.

Probably the ideal solution is to separate the two variants into their own package and coordinates to avoid any conflicts and work side-by-side. That's not an upgrade friendly approach, which I guess is why it wasn't done. Pushing the handling into the build system seems like the next best option. Re: https://github.com/google/guava/issues/2914#issuecomment-323814922 In Guava 20, `com.google.common.base.Function` did not extend `java.util.function.Function`. In Guava 21, it did. As a library that people depend on, we switched our API to accept the Java 8 `Function` rather than Guava's.

We upped our guava dependency to version 21. Projects using selenium and guava as a dependencies, however, did not pick up this change --- because of the way that maven dependency resolution works, the project would also need to bump their guava version to 21 or more. 

Fortunately, the selenium project had a way of letting maven know that we actually needed version 21 --- it was more than advisory. We set the version range to be _at least_ version 21, but left the upper bound open so that projects that depend on selenium could use a compatible later version of guava too. I think the root problem here is the difference between Java 8 and Android as base SDKs. Java 9 is coming in September, and will widen the gap further.

One solution is to shade the Android library into a different package. Libraries that expect to run on Android can make the move to the new package. Those that expect to run on the JRE need do nothing (or make a breaking change, and make _everyone_ make a choice).

On an Android device, it'll be clear that a dependency on the JRE version is a terrible mistake. However, because of the way that the JRE works, if a JRE-based library of application depends on the Android version, all that will happen is that the classpath will be longer, and deployable artefacts will be larger. Disk space is cheap. Also, why not just distribute the Android version of guava as an AAR, and not as a JAR? Given the fact that maven version/artifact resolution is not going to be
sufficient to, in and of itself, note guava-jre and guava-android as
incompatible, can we use some approach like maven-enforcer or whatever to
supply constraints, such that a project won't have both in its deps graph?
The key as I see it is that these are incompatible and there is no way, in
the raw dependency mechanism, to specify that incompatibility.

On Thu, 31 Aug 2017 at 07:53 Simon Stewart <notifications@github.com> wrote:

> Also, why not just distribute the Android version of guava as an AAR, and
> not as a JAR?
>
> —
> You are receiving this because you are subscribed to this thread.
> Reply to this email directly, view it on GitHub
> <https://github.com/google/guava/issues/2914#issuecomment-326320674>, or mute
> the thread
> <https://github.com/notifications/unsubscribe-auth/AAUN4i_jPM3icsPvbg7Fs5UTQ0qyg3dOks5sdsjMgaJpZM4O4ET0>
> .
>
 > We also promise that it's usable as on the JRE (for Java 7 users). (I don't know enough about AAR to say more than that.)

AAR is an Android-specific way of packaging a library. If you've got something that is only meant for an Android app, that's the best way to distribute it.

https://gist.github.com/lopspower/6f62fe1492726d848d6d might be useful. The only advantage would be to bundle the ProGuard rules so they're used
automatically which seems very low value compared to now shipping 3
artifacts (jdk8, jdk6/7-ish, and android).

On Fri, Sep 1, 2017 at 1:43 PM Simon Stewart <notifications@github.com>
wrote:

> We also promise that it's usable as on the JRE (for Java 7 users). (I
> don't know enough about AAR to say more than that.)
>
> AAR is an Android-specific way of packaging a library. If you've got
> something that is only meant for an Android app, that's the best way to
> distribute it.
>
> https://gist.github.com/lopspower/6f62fe1492726d848d6d might be useful.
>
> —
> You are receiving this because you commented.
>
>
> Reply to this email directly, view it on GitHub
> <https://github.com/google/guava/issues/2914#issuecomment-326642112>, or mute
> the thread
> <https://github.com/notifications/unsubscribe-auth/AAEEEWTU-6QCj_ebF-RlcVAaj7MoP0Dhks5seEImgaJpZM4O4ET0>
> .
>
 You'd be shipping two: just guava as a jar (targeting java 8, as now), and guava as an aar, which android projects could depend on. That would then contradict this statement by @cpovirk:

> Update: Admittedly "Android" is itself not the best term, since we advise Java 7 users to use it, too. An aar would require the artifact only notation in Gradle. I think that if the explicit extension and transitively unqualified dependency of guava were in the tree, then both would be retrieved. If so, this would require Android users to manually exclude which would require a fix to the user's build. That doesn't seem clearer than using a resolution strategy / enforcer to restrict versions. @cpovirk If we changed `-android` version suffix to `-a`, [maven version comparison rules](https://stackoverflow.com/a/31482463) would treat it as lesser than vanilla release version, i.e. `24.0` (for java 8+) would be considered newer than `24.0-a` (for android / java 7) by maven.
This way we can keep normal guava version normal (and "latest") while providing android / java 7 specific version, too. @yborovikov Isn't `a` intended for `alpha` releases? It could be misleading. @perceptron8 `-a` is indeed _sorted_ the same way as `-alpha` (and `-b` - as `-beta`). however, the meaning of `-a` doesn't have to translate to "alpha", and, unless we publish alpha releases to maven central, should not create much confusion (at least no more than `-android`).

for example, java `build 1.7.0_80-b15` doesn't mislead us into thinking it's a beta release, does it? :)

i believe a single sentence in the `README.md` would be enough to explain the meaning and purpose of releasing both `guava:24.0a` and `guava:24.0`. Downside of using `-a`: it might be sorted before `rc`, etc. and considered a "pre-release" version by various tools (e.g. [mvnrepository](https://mvnrepository.com/artifact/com.google.guava/guava)).
So we could use `-ga` ("google android") suffix instead - this is considered to be equal to no suffix, so `24.0` and `24.0-ga` would be treated as equally fresh by maven.

Checked these (version `xx-ga` and `xx`) against maven-enforcer-plugin's [requireUpperBoundDeps](https://maven.apache.org/enforcer/enforcer-rules/requireUpperBoundDeps.html) rule - neither is considered newer than the other, both can be used interchangeably. `GA` is sometimes used as `General Availability` in version strings. It looks like some JBoss artifacts used this and then switched to `Final`, so perhaps there was an issue they encountered. I wouldn't redefine known suffixes even if they are non-standard. @ben-manes We're trying to achieve something Maven doesn't have a prescribed solution for here.

You're right, `ga` is one of well-known qualifiers (and stands for `general availability`, as you mentioned), and that's the reason this version qualifier gets special treatment (re version comparison) from Maven.

We would be piggy-backing on this [documented](http://maven.apache.org/ref/3.5.0/maven-artifact/apidocs/org/apache/maven/artifact/versioning/ComparableVersion.html) Maven feature:

> strings are checked for well-known qualifiers and the qualifier ordering is used for version ordering. Well-known qualifiers (case insensitive) are:
> 
> -    alpha or a
> -    beta or b
> -    milestone or m
> -    rc or cr
> -    snapshot
> -    **(the empty string) or ga or final**
> -    sp

to provide two Guava versions that can be treated equally from version comparison perspective (at least by Maven itself).

This approach should resolve this very issue of Maven version comparison treating `23.0-android` version as the latest over `23.0` one - as stated by the issue submitter.

<sub>As for why JBoss switched from `ga` version suffix to `Final` - personally I have no idea, as well as why do projects use `-ga` or `.Final` suffixes for their vanilla release artifact versions, to begin with. My guess would be some historical reasons (e.g. JBoss docs circa 2004 said: ["We did not want to depend on a specific build tools naming and ordering rules, because those things tend to change over time. While Maven is the popular choice today ..."](https://developer.jboss.org/wiki/JBossProjectVersioning)).</sub> Copied from [the discussion doc](https://docs.google.com/document/d/1NYGbfz56C0Oh4IGymXjeQUVK4FcRiqDbpc4vGLnDMrY/edit#) shared by @cpovirk:

While it's considered bad practice to just tell Maven "use latest version" (or rely on version ranges), there's another practice of assuring (via `maven-enforcer-plugin`) that a library (transitively shared by multiple dependencies) resolves a version no older than what's required by any of the dependencies.

In [our case](https://github.com/uber/tchannel-java) we try to maintain Java 7 compatibility by using android-flavored guava version, and upgrade to 23.0-android broke the (java 8) builds that depend on the project yet try to enforce the latest versions among shared dependencies - `23.0-android` is considered by Maven to be a newer one and `guava-23.0` fails the check.

Arguably, java 7 / android builds will experience similar issues (e.g., trying to use `24.0-android` while some dependencies use `24.0-jre`).

Ideally, Guava would produce two versions that are considered equally fresh by Maven tooling - and there is such option: use `24.0` for vanilla version and `24.0-ga` for android one.

This would allow a project to pick the flavor it needs while enforcing that the latest (among dependencies) version is being effectively used.

(Of course, android builds would still rely on / check that Java 8 features are not being actually used in the execution path of the libraries - but that's unavoidable anyways.)  There already is the method Multimaps.flatteningToMultimap for a stream of values.
But one could also want to map an object against multiple keys coming from a stream.
So a collector method flatteningToMultimap(Function<? super T, ? extends Stream<? extends K>>, Function<? super T, ? extends V>, Supplier) would be useful.

See Issue #2911 @googlebot I signed it!  The default conflict resolution by throwing is fine most of the time, but sometimes, conflicting keys are acceptable as you either don't care about the values as in #360 (choosing the bigger city might be an option).

Sometimes, you can't do anything about the conflicts, like when I was importing inconsistent third party data recently. Letting the later inserted values win might help in cases like in #2252. 

Therefore, I'm suggesting `ImmutableMap.Builder#build(BinaryOperator<Entry<K, V>> merger)`. It should be rather easy to implement. In case of no conflict, the merger doesn't get used and building is as efficient as without it. Otherwise, some simple tweaks are needed like possible cloning and final shrinking of `entries` in `fromEntryArray`, something like ten to twenty code lines. To keep things simple, the iteration order would be always according to the first occurrence of the key, regardless of what the `merger` returns. I missed it. I could have used it, though it'd need some rewrite while the builder feels natural (as two methods are adding entries). This collector is cheating with a `LinkedHashMap` temporary, unlike the two argument variant using the builder.

I guess, the three argument variant could be trivially implemented using my proposed build method. If there are few merges, it'd be probably way more efficient. With many merges, the builder could grow much bigger than the map.

All the alternatives make the builder look an unwanted child.  I have created several of my own builders for immutable classes.

In the builders I try to use the Guava immutable collection Builder's wherever possible.  

If I use the ImmutableMap.Builder, the builder will collect duplicate keys and fail on the "build()".  (Similar problem to that was described in [https://github.com/google/guava/issues/360](url)).  

The proposal in issue 360 was to to immediately throw an IllegalArgumentException from the Builder if a duplicate key was added.  This proposal was rejected because of the potential performance impact, which makes sense.

However, would it be possible to add a "containsKey(K)" method to roll through the existing entries looking for any with a matching key? This would be admittedly be an expensive operation, but the caller must decide if he wants to take the performance hit.  The current functionality / performance of the Builder#put... would not be impacted.

```
ImmutableMap.Builder<String, FooBar> foobars = new ImmutableMap.Builder<>();

public void Builder addFoobar(FooBar foobar) {
  String foobarName = foobar.getName();
  if (foobars.containsKey(foobarName)) {
    throw new IllegalArgumentException("Duplicate FooBar name: " + foobarName);
  } else {
    foobars.put(foobarName, foobar);
  }
}

public void FooBarsHolder build() {
   return new FooBarsHolder(foobars.build());
}
```

As a workaround I am currently using a LinkedHashMap and then a ImmutableMap.copyOf(map); however, it would be nice to deal with the maps in the same manner as the lists, etc. I ran into this just yesterday and also switched to a mutable `Map`. IMHO the problem with your proposal is that nobody should ever use `ImmutableMap.Builder#containsKey` because of its quadratic complexity and because you can do
```
if (mutableMapUsedAsBuilder.put(foobarName, foobar) != null) {
    throw new IllegalArgumentException("Duplicate FooBar name: " + foobarName);
}
```
instead. It's even simpler and there's no additional lookup.

It's not exactly equivalent in case of duplicate keys, but you could use your variant as is or mine and put back the original value, *if you insist on "first wins"*. AFAIK the only advantage of using the `Builder ` in this case is that it produces less garbage, which IMHO isn't worth the overhead of `containsKey`. Hello Maaartinus, 

Thanks for your quick answer.

~~The problem I see with your proposal is that in the event that I have a duplicate key, I have now pushed it to the builder and can not remove it - a guaranteed fail if I still get around to "build()" at some point.   This would make it impossible to recover from this condition without starting all over with a new builder.~~

^^ ignore that ... see now that your were indicating I should use my mutable map and not the immutable map  The link was generated as plaintext. The change will result in the link
being rendered as a hyperlink. @cpovirk Thanks for looking into this, and the detailed responses.   I will close this PR.  I have extended a toMap function in the FluentIterable, you can flexibly specify the key and value, you can also specify the key conflict strategy  Simple change - added a few new constructors and passed the tmpDir in.
This will allow multiple threads to use this class and write to different places while preserving the existing functionality. I have read/signed the CLA. I am not sure why it wont let me put this pull request up @JoeHale It may not be accepting your PR because the email address you use to log into GitHub is different from the email address you assigned to your local Git installation's `user.email` setting.

Try double-checking the email address you set for `user.email` (following these instructions to set it or reset it if needed: https://git-scm.com/book/en/v2/Getting-Started-First-Time-Git-Setup), and then try running `git commit --amend` to hopefully correct your commit with the right email address and then `git push --force-with-lease` to push the corrected commit.  "Snapshot API Diffs from 22.0" should now be "Snapshot API Diffs from 23.0" or just "Snapshot API Diffs".

https://github.com/google/guava#snapshots
  This PR applies a good number of apparently applicable IntelliJ IDEA code inspections. Hi @cpovirk, sorry for being quiet on this.

I think a few things were missed, but I'm not sure which, so I'm rather satisfied with the commit you've pushed. Thanks!  Such references can cause JVM-level deadlocks in multithreaded environment, when one thread tries to load superclass and another thread tries to load subclass at the same time.

My refactor will not change the method provided to outer space. Assuming there is a cycle, wouldn't the initialization-on-demand holder idiom work? That would be preferable to ThreadLocal.  LocalCache.asMap().compute(...) deadlocks if its lambda throws an exception. Demonstrated by the test.
Fixed by properly handling the exception and realising the lock. I signed it!  Dear Guava developers,

I've been using ImmutableList for a while. I notice that in more than 50% of the cases I know its size before I build it. Would it be possible to expose ImmutableList.builder(int capacity)?

In fact, I can see this comment in the code:

    // TODO(lowasser): consider exposing this
    Builder(int capacity) {
      super(capacity);
    }

Best wishes,
Paul  In order to minimize the risk of integrating `@Beta`-annotated functionalities (especially in libraries), it would be nice to have API Docs including only the non-`@Beta`-parts of Guava.

See also issue #2657 . ok!  A really interesting edge case for HashMap was reported due to my usage, see https://github.com/ben-manes/caffeine/issues/176.

It seems that when the entrySet iterator removes entries, the untreeifying causes the entries to be rewritten. Then the entries returned by the iterator are stale and `setValue` has no effect on the HashMap. This is because unlike concurrent maps, the `setValue` does not perform a `map.put(key, value)` to handle the race.

I believe this is a JDK bug and we are awaiting feedback. Guava's testlib doesn't assert this case, so it might be a good addition. https://bugs.openjdk.java.net/browse/JDK-8186171  Hi guys. Probably I'm not aware about something. But why don't you want to make that preconditions set is available for public audience ? I found it very helpful to use it in my projects.

Thanks in advance, Dima.        Almost every usage of `CacheLoader` only needs to implement `load()`, so being able to do that with a lambda would be helpful. Something like this:

```java
public static <K, V> CacheLoader<K, V> cacheLoader(LoaderFunction<K, V> loader)
{
    return new CacheLoader<K, V>()
    {
        @Override
        public V load(K key)
                throws Exception
        {
            return loader.load(key);
        }
    };
}

public interface LoaderFunction<K, V>
{
    V load(K key)
            throws Exception;
} `Function` cannot throw. I still don't understand why the Supplier version typed the key as Object... @lowasser, thanks for the tip! I never noticed that method. It would be nice to have a version for functions that throw checked exceptions. @kevinb9n The reason is that users prefer their collections to be typed, if only for consistency in their code. The current form forces the cache to be `Cache<Object, V>`, whereas developers are used to be restricting to `Cache<K, V>`. That makes it incompatible with other builder steps, like `RemovalListener`, if the key has meaning outside of the loader. Its not a big deal, but in the few cases where it seemed appropriate the end result didn't use it.

Using utilities like jOOλ's `Unchecked` tricks like
```java
CacheBuilder.newBuilder()
    .build(CacheLoader.from(Unchecked.function(key -> {
      return value;
    })::apply);
```
 can work around exceptions. It looks worse in isolation, but the extra noise drops out with real build logic. (You can add `Unchecked.RETHROW_ALL` to propagate as the original checked exception if needed) In general, I agree with tunneling exceptions, but forcing users to do that here seems broken since CacheLoader and LoadingCache already support checked exceptions.
 aha, so now I understand, thanks! :)

Somehow that escaped me and I always thought it was forcing the key type, which seemed weird given the people involved.  `Cache` interface was designed to throw an exception in the case of null or empty values. While this seems a reasonable behavior for `Cache.get`, I didn't figured out how to deal when calling `Cache.getAll`.

I/O is expensive, so I collect all data I need at once using `Cache.getAll`. In the case that at least one key has no value, it throws an exception, which does not allow me to access the other valid values.

I found to options: first, using `Cache.get` instead of `Cache.getAll`; second, including null values as Optional. Both options are terrible considering performance. Is there a recommended solution to deal with this scenario? Otherwise, if possible, how could I help to improve the Cache API in this issue? @lowasser thanks for your quick reply. Using `Optional` forces me to include in the cache data that should not be there. Even knowing that I can flag the key to be quickly removed, it doesn't seem an adequate solution specially if I have a high occurrence of null values. In an extreme example, if the frequency of null values is so high that it exceeds the maximum cache size, the cache becomes an useless overhead. If the frequency of not being found but requested is high then there will be a lot of unnecessary I/O and hash table locking. In that case negative caching of the misses is useful to reduce that, which is where `Optional` can be used as a sentinel value. If that leads to cache bloat then the best option is use a Bloom Filter to filter out most absent requests. This is a fairly standard idiom inside databases and a recent example is [LinkedIn's feed rewrite](https://engineering.linkedin.com/blog/2017/07/building-the-activity-graph--part-2), which uses enhancements to Guava that they contributed. So your worst-case is bad for many reasons and requires a richer solution for a workload with a high miss rate.

The cache interface was designed in a Java 4/5 world, where Guava was a leading force in reducing null as a common return or parameter value. In this case Josh Bloch felt strongly in favor for using a checked exception, where checked is for recoverable conditions. This and implementation details fit the trade offs of the time and would be hard to argue against even in retrospect if transported back then.

In the [cache rewrite](https://github.com/ben-manes/caffeine) nulls are favored over exceptions. This is to match Java 8's `compute` methods and that `getUnchecked` or not handling the checked exception is the most common case. The update to a Java 8 API gave the opportunity to change this, but its more about keeping consistent with the community's coding style. I don't think that Guava's approach is incorrect, though, because when performance matters you'll have to add a filtering technique regardless to reduce bottlenecks. @ben-manes thanks for your explanation and references. Bloom filter sounds nicely, but would bring the overhead of managing a new structure ensuring consistency with the original data source. Given the options, I'll go for `Optional` and measure in a real scenario how it affects the performance. Thanks again @ben-manes and @lowasser for your help. @jrtom I don't think so. I guess the OP wants `getAllPresentLoadAbsentWhenPossible`, which would be an aggregate of exception ignoring `get`s. When working with single elements, you may throw and handle it in `get`, so that you don't pollute the cache (though polluting it may be a good thing as Ben wrote). I guess, something like

`try {return getAll();} catch (....) {return getAllPresent();}`

could come close to what he requested. Despite the double lookup, it could be more efficient than the alternatives, assuming that what @ben-manes wrote doesn't apply in this case.
 @Maaartinus That could have a race due to an eviction, for whatever reason. It tiny improvement would be to throw a custom exception with the results and then use `cache.putAll` to insert them. Then the results would be cached and the found set returned.  Add generics with Maps. fromProperties().

It can use like this:
```java
Map<Integer, Integer> maps = fromProperties(prop, (k)->Integer.valueOf(k), (v)->Integer.valueOf(v));
```
It's very useful when we use it to convert properties to a generics map.

And in other way, we can implement with BiFunction<T, U, R> to expand this method. I signed it!  The method try to initialize unsafeComparator and expect ExceptionInInitializerError or ClassNotFoundException if initialization fails. Actualy the static initializer throws Error if something goes wrong to "force fallback to PureJavaComparator". According to spec JVM transfers it to ExceptionInInitializerError for the first time and starting from second genertates NoClassDefFoundError (not ClassNotFoundException, no exceptions allowed to be thrown from static initializer).
```
   try {
      Class.forName(unsafeComparatorClassName());
      return true;
    } catch (ExceptionInInitializerError | ClassNotFoundException tolerable) {
      // probably running on Android
      return false;
    }
```
Guess this is a missprint and author was intended to use NoClassDefFoundError here. For example, the ForNameTest.java:
```
public class ForNameTest {

  public static void main(String[] argv) {
    System.out.println("sun.arch.data.model: " + System.getProperty("sun.arch.data.model"));
    try {
      Class.forName("unsafeComparator");
    } catch (Throwable t) {
      System.out.println("1st - " + t);
    }
    try {
      Class.forName("unsafeComparator");
    } catch (Throwable t) {
      System.out.println("2nd - " + t);
    }
  }
}

class unsafeComparator {
  static {
    if (!("32".equals(System.getProperty("sun.arch.data.model"))))
      throw new Error();
  }
}
```
produce the following output:
```
java -showversion ForNameTest
java version "1.8.0_131"
Java(TM) SE Runtime Environment (build 1.8.0_131-b11)
Java HotSpot(TM) 64-Bit Server VM (build 25.131-b11, mixed mode)

sun.arch.data.model: 64
1st - java.lang.Error
2nd - java.lang.NoClassDefFoundError: Could not initialize class unsafeComparator
```  The mechanism which detects whether to fallback on the non-lazy stack trace implementation seems to be broken on AIX 5.3 with IBMs JDK `jdk-6.0.0.645-aix-powerpc`. When iterating through the list returned by the method on such a system I get the following exception + trace

> Caused by: java.lang.UnsupportedOperationException: You cannot access stack trace depth this way in this implementation
        at sun.misc.SharedSecrets$1.getStackTraceDepth(SharedSecrets.java:172)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:60)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:37)
        at java.lang.reflect.Method.invoke(Method.java:611)
        at com.google.common.base.Throwables.invokeAccessibleNonThrowingMethod(Throwables.java:292)
        at com.google.common.base.Throwables.access$200(Throwables.java:48)
        at com.google.common.base.Throwables$1.size(Throwables.java:284)
        at java.util.AbstractList$SimpleListIterator.hasNext(AbstractList.java:51)
        at com.google.common.collect.Iterators$PeekingImpl.hasNext(Iterators.java:1171)
        at com.delphix.logger.Logger.getLogger(Logger.java:96)
        at com.delphix.session.impl.common.SessionManager.<clinit>(SessionManager.java:23)
        at java.lang.J9VMInternals.initializeImpl(Native Method)
        at java.lang.J9VMInternals.initialize(J9VMInternals.java:199)
        ... 21 more

Explicitly using `new Throwable().getStackTrace` resolved the problem. @cpovirk 
I'm interested in this one, so if no one minds, I want to make an implementation for a fallback, however, should we care only for `UnsupportedOperationException` or it is worth to catch something generic e.g. `RuntimeException`?  (hence I'm not a fan of such an idea) @cpovirk 
Agree, will do it then and create a PR soon. Thanks!   In the Guava 23.0 [release notes](https://github.com/google/guava/wiki/Release23), there was a mention of a class `GraphTraverser` which AFAICT isn't in the open source version of Guava. Is it a real class in Google-internal Guava? If so, are there any plans to eventually release it? Okey dokey, thanks for the quick response @kevinb9n!

I'll keep this issue open for now. If or when the Guava 23.0 release notes are fixed, I'll close it. :) Ta @cgdecker! :+1:   Change CacheBuilder constructor modifier to private and rewrite corresponding tests  Change CacheBuilder constructor modifier to private and rewrite corresponding tests.  First I thought this exception is connected to [Guice ](https://github.com/google/guice/issues/1119)but it is rather coming from Guava, isn't it?
What is the proper approach to track down the problem in a compex Spark app having this exception? 
On another system there is no such error and it is very hard to understand the exact source of the error.

```
Exception in thread "main" com.google.inject.internal.util.$ComputationException: java.lang.ArrayIndexOutOfBoundsException
        at com.google.inject.internal.util.$MapMaker$StrategyImpl.compute(MapMaker.java:553)
        at com.google.inject.internal.util.$MapMaker$StrategyImpl.compute(MapMaker.java:419)
        at com.google.inject.internal.util.$CustomConcurrentHashMap$ComputingImpl.get(CustomConcurrentHashMap.java:2041)
        at com.google.inject.internal.util.$StackTraceElements.forMember(StackTraceElements.java:53)
        at com.google.inject.internal.Errors.formatSource(Errors.java:690)
        at com.google.inject.internal.Errors.formatInjectionPoint(Errors.java:720)
        at com.google.inject.internal.Errors.formatSource(Errors.java:684)
        at com.google.inject.internal.Errors.format(Errors.java:555)
        at com.google.inject.ProvisionException.getMessage(ProvisionException.java:59)
        at my.custom.spark.app.main.Main.main(Main.java:68)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
        at java.lang.reflect.Method.invoke(Method.java:498)
        at org.apache.spark.deploy.SparkSubmit$.org$apache$spark$deploy$SparkSubmit$$runMain(SparkSubmit.scala:731)
        at org.apache.spark.deploy.SparkSubmit$.doRunMain$1(SparkSubmit.scala:181)
        at org.apache.spark.deploy.SparkSubmit$.submit(SparkSubmit.scala:206)
        at org.apache.spark.deploy.SparkSubmit$.main(SparkSubmit.scala:121)
        at org.apache.spark.deploy.SparkSubmit.main(SparkSubmit.scala)
Caused by: java.lang.ArrayIndexOutOfBoundsException: 43168
        at com.google.inject.internal.asm.$ClassReader.<init>(Unknown Source)
        at com.google.inject.internal.asm.$ClassReader.<init>(Unknown Source)
        at com.google.inject.internal.asm.$ClassReader.<init>(Unknown Source)
        at com.google.inject.internal.util.$LineNumbers.<init>(LineNumbers.java:62)
        at com.google.inject.internal.util.$StackTraceElements$1.apply(StackTraceElements.java:36)
        at com.google.inject.internal.util.$StackTraceElements$1.apply(StackTraceElements.java:33)
        **at com.google.inject.internal.util.$MapMaker$StrategyImpl.compute(MapMaker.java:549)**
        ... 18 more
```  setException() after setFuture is not a noop, but I don't disagree with the general premise. I suppose it's theoretically possible for something to escape when setting the listeners on the Future... but again, Future catches RuntimeExceptions thrown from execute(), and from misbehaving objects passed in to setFuture().   Hmm, I wonder if Android even supports the diamond operator... Diamond is a compilation​ feature only. Has nothing to do with runtime.

On Wed, Jul 19, 2017, 8:12 PM Jonathan Bluett-Duncan <
notifications@github.com> wrote:

> Hmm, I wonder if Android even supports the diamond operator...
>
> —
> You are receiving this because you are subscribed to this thread.
> Reply to this email directly, view it on GitHub
> <https://github.com/google/guava/pull/2875#issuecomment-316558655>, or mute
> the thread
> <https://github.com/notifications/unsubscribe-auth/AAEEEc4aphRfggnNsSCGurhyQXlqepulks5sPptxgaJpZM4Odcbr>
> .
>
 well, travis had a android test as well... Yep, looks like it passes Travis (which indeed runs the Android tests), so I've no objections to this!  Java 8 defined specific primitive spliterators for doubles, ints,  and longs.

The primitive lists of those specific types in com.google.common.primitives should implement spliterator and return those primitive optimized spliterators. The intent of my request is to allow for the framework to provide better optimized Streams. By default, the spliterator provided is based on the iterator implementation. This not only is not going to optimize access for an array, it is not likely to support splitting to allow parallel streams. Additionally, it guarantees auto-boxing is going to take place, as that is how AbstractList implements an Iterator. No, I am talking about the List returned from [Longs.asList(long...)](http://google.github.io/guava/releases/snapshot/api/docs/com/google/common/primitives/Longs.html#asList-long...-) and friends.
I apologize for not stating that more clearly in the original request. Auto boxing will still (likely) occur through streams. The stream implementation itself will be more efficient based on the backing long[] compared to the List's default Iterator.  Building an object identity is still quite verbose to write IMHO, even though we now have nice and convenient utilities:

```java
public class Item {

  private final int id;
  private final String name;

  public Item(int id, String name) {
    this.id = id;
    this.name = name;
  }

  public int getId() {
    return this.id;
  }

  public String getName() {
    return this.name;
  }

  @Override
  public boolean equals(Object otherObject) {
    if (!(otherObject instanceof Item)) {
      return false;
    } else {
      Item otherItem = (Item) otherObject;
      return Objects.equals(this.id, otherItem.id);
    }
  }

  @Override
  public int hashCode() {
    return Objects.hash(this.id);
  }

}
```

And it's getting even worst when building a comparable identity (making `compareTo` consistent with `equals`):

```java
public class Item implements Comparable<Item> {

  private final int id;
  private final String name;

  public Item(int id, String name) {
    this.id = id;
    this.name = name;
  }

  public int getId() {
    return this.id;
  }

  public String getName() {
    return this.name;
  }

  @Override
  public boolean equals(Object otherObject) {
    if (!(otherObject instanceof Item)) {
      return false;
    } else {
      Item otherItem = (Item) otherObject;
      return Objects.equals(this.id, otherItem.id);
    }
  }

  @Override
  public int hashCode() {
    return Objects.hash(this.id);
  }

  @Override
  public int compareTo(Item otherItem) {
    return ComparisonChain.start()
      .compare(this.name, otherItem.name)
      .compare(this.id, that.id)
      .result();
  }

}
```

My main point is that, identity is built using only one field in this example, but say I want to add another field to make my `Item`s unique, I'll have to update the three methods `equals`, `hashCode` and `compareTo`...

---

I was thinking of such a Java8-lambda-based `Identities` utility:

```java
public class Item {

  private static final SimpleIdentityFactory<Item> ITEM_IDENTITY_FACTORY = Identities.simpleIdentityFor(Item.class)
    .with(Item::getId)
    .build();

  private final SimpleIdentity<Item> identity;
  private final int id;
  private final String name;

  public Item(int id, String name) {
    this.identity = ITEM_IDENTITY_FACTORY.build(this);
    this.id = id;
    this.name = name;
  }

  public int getId() {
    return this.id;
  }

  public String getName() {
    return this.name;
  }

  @Override
  public boolean equals(Object otherObject) {
    return identity.equals(otherObject);
  }

  @Override
  public int hashCode() {
    return identity.hashCode();
  }

}
```

This could also probably cover the comparable identities:

```java
public class Item implements Comparable<Item> {

  private static final ComparableIdentityFactory<Item> ITEM_IDENTITY_FACTORY = Identities.comparableIdentityFor(Item.class)
    .asc(Item::getName)
    .asc(Item::getId)
    .build();

  private final ComparableIdentity<Item> identity;
  private final int id;
  private final String name;

  public Item(int id, String name) {
    this.identity = ITEM_IDENTITY_FACTORY.build(this);
    this.id = id;
    this.name = name;
  }

  public int getId() {
    return this.id;
  }

  public String getName() {
    return this.name;
  }

  @Override
  public boolean equals(Object otherObject) {
    return identity.equals(otherObject);
  }

  @Override
  public int hashCode() {
    return identity.hashCode();
  }

  @Override
  public int compareTo(Item otherItem) {
    return identity.compareTo(otherItem);
  }

}
```

I already prototyped it, but I wanted to have your feedbacks first before creating a possible PR. Do you think it's a good solution? If yes, could it be a good fit for Guava?

---

Could have been even nicer to player with interfaces default implementations and let an `Identifiable<T>` interface implement the methods for us thanks to a (non-defaulted) `getIdentity()` method, but unfortunately, [it's forbidden](https://stackoverflow.com/a/24026292/1225328) ;) @cpovirk Indeed, AutoValue looks pretty convenient, thanks for the feedback!  The link to [RangeMap](https://github.com/google/guava/wiki/NewCollectionTypesExplained#rangemap) documentation is missing in the right panel of the wiki under pages as shown below:-

<img width="243" alt="screen shot 2017-07-13 at 2 39 02 pm" src="https://user-images.githubusercontent.com/8141860/28159078-6b30d7f8-67d9-11e7-9b61-60d3d1e70e6e.png">


  Maybe an idea worth discussing (or at least one to quickly be dismissed): How about adding (some of) the methods from `Futures` as default methods to `ListenableFuture` for nice chaining:

```java
public interface ListenableFuture<V> extends Future<V> {

    void addListener(Runnable listener, Executor executor);

    default <O> ListenableFuture<O> transform(Function<? super V, ? extends O> function) {
        return Futures.transform(this, function);
    }

    default ListenableFuture<V> withFallback(final FutureFallback<? extends V> fallback) {
        return Futures.withFallback(this, function);
    }

    // TODO: add more
}
```

old:

```java
ListenableFuture<Foo> f1 = executor.submit(task);
ListenableFuture<Bar> f2 = Futures.transform(f1, (foo) -> toBar(foo));
ListenableFuture<Bar> f3 = Futures.withFallback(f2, (ex) -> handleEx(ex));
```

new

```java
ListenableFuture<Bar> f = executor.submit(task)
    .transform((foo) -> toBar(foo))
    .withFallback((ex) -> handleEx(ex));
```

Note: The call to `Futures.transform(..)` is ambiguous as the compiler can't figure out if it's `Function` of `FunctionAsync`. Adding methods named `transformSync(..)` and `transformAsync(..)` would help the compiler (and readability).
 @sfussenegger I think that the recent addition of [`FluentFuture`](https://google.github.io/guava/releases/snapshot/api/docs/com/google/common/util/concurrent/FluentFuture.html) (planned for 23.0 IIRC) more or less resolves this (albeit without extending `ListenableFuture` with default methods, as you requested).

What do you think? @jbduncan Nice. Same idea but a different implementation.  It would be nice to have Uninterruptibles support for Condition.await() and overlaods.

So we could write

```
lock.lock();
try{
  awaitUninterrutibly(condition,1,MINUTE);
}finally{
 lock.unlock();
}
```


  Please enhance `Graphs` with a method finding n-cliques, max clique (or cliques) in  a `Graph`. 
I am aware this cannot be implemented efficiently (finding max clique is a NP-complete problem), but that doesn't unfortunately mean it's useless :)  Without reading the Javadocs, there is no way to know that the `get` method -- in addition to `ExecutionException` -- could also throw `UncheckedExecutionException` (and `ExecutionError`).

These are unchecked exceptions, and so the compiler is of little help, and unexpected things happen when the code is run. Programming in Haskell has spoiled me...

In my case, this just bit me as I was using Guava to cache Hibernate DB code, an unchecked `javax.persistence.NoResultException` was throw, and my `catch` clause which unwraps the original, underlying exception failed to work:
```Java
try {
    return theCache.get(theKey);
} catch (ExecutionException e) {
    throw e.getCause();
}
```

Could the wiki please be updated to note these unchecked exceptions?   Exception cause can be set by initCause method which can lead to a circular reference:
```java
Exception cause = new Exception();
Exception exception = new Exception(cause);
cause.initCause(exception);
```
Calling `Throwables.getCausalChain( exception )` or `Throwables.getRootCause( exception )` could lead to an infinitive loop.

It is good idea to use a `Set` to add cause exceptions to avoid iterating over a circular reference when `Set.add` method returns `false`.  > Another option (instead of using a set) would be to use the old "fast pointer/slow pointer" trick.

AFAIK this is only useful when you don't have enough memory for the whole loop.

---

kevinb9n has already commented on this: https://stackoverflow.com/a/7586027/581205

I guess, people requesting this got confused by `Throwable` initializing cause to itself, which leaks when using reflection (e.g., converting to JSON). Besides this dirty trick, I doubt that there are loops out there. As you mentioned `printStackTrace` method is smart enough to avoid this loop by using a `Set` collection. 

I describe importance of this issue through an example: if Guava is used in exceptions processing frameworks/projects which their consumers are unknown and also exceptions could be thrown from many different reliable and unreliable sources it might put exception processing framework into an unknown state which is not acceptable unless to avoid using Guava for this particular case and using a custom solution similar to what JDK does for `printStackTrace`.  Libraries like log4j2 use Implementation-Version to determine which version of a library is use when logging stack traces.

The manifest inside guava's jar is currently lacking this property.
 Yep, that's exactly what it's about. It would log `[guava.jar:21.0.0]` instead of `[guava.jar:?]`, so it somewhat improves diagnostics.

Specification-Version and Implementation-Version are going to be the same here, I assume, although I think that over here, we chop the last number off the version number for the Specification-Version to indicate compatibility semantics.
  Throwing exception in compute function of Cache ConcurrentMap and computing the same key after makes deadlock in LocalCache.java:2387
  
  @Test
    public void testCacheLoaderException() {
        Map cache = CacheBuilder.newBuilder().build().asMap();

        Integer n = 1;
        try {
            cache.computeIfAbsent(n,k->{
                throw new IllegalStateException("make deadlock");
            });
        } catch (Exception e) {
        }
        int v = (int)cache.computeIfAbsent(n, k->k); //deadlock here
        Assert.assertEquals(1, v);
    }
 All recursive operations on a map are undefined behavior, so this works as intended. When the cache was a feature of MapMaker it had this behavior for computations on `get`, but I switched it to fail fast by detecting the lock was already held. Ideally the computations would emulate that for consistency and friendliness, but it isn't required.

Java 8's `ConcurrentHashMap` will live-lock on this call and `HashMap` may corrupt itself. In Java 9 it will fail fast in both cases, if detected.

So this works as intended, but could be a tad nicer. Oh shoot, I misread. I've seen the recursion issues raised so many times across hash tables that, on seeing multiple `computeIfAbsent` calls, I saw the imagined pattern.

It does appear that `LocalCache.compute` fails to handle exceptions from `loadingValueReference.compute` and leaves the failed entry in the cache. The subsequent call waits for a future that has never been finalized. Isn't this the behavior referenced in https://github.com/google/guava/pull/2799? I'm also observing some strange behaviour with guava caches under contention. Not sure if these two issues are related. If they aren't, I'm happy to open a separate issue.

While I was doing some JMH benchmarks I noticed that benchmarks that were using guava caches stalled completely and/or had very erratic performance during thread contention. Benchmark iterations very often stalled for seconds, minutes or sometimes seemingly indefinitely. It turned out that the cache was the culprit in all cases.

The issue is _very_ easy to trigger. I published a sample project on https://github.com/hibox-systems/guava-cache-test that demonstrates the issue. In my environment it works fine with 1, 2 and 3 threads. Using 4 threads or more always stalls the benchmark at some point. I have tried the benchmark with all published guava versions that are compatible with the sample code, i.e. guava 11.0 and newer. Tested with these JVM versions on Ubuntu 16.04 with a Intel Core i7-3770 CPU:
- OpenJDK 1.8.0_131-8u131-b11-2ubuntu1.16.04.3-b11
- Oracle 1.8.0_151-b12
- Oracle 9.0.1+11

FWIW, I tried replacing the guava caches in the benchmarks with caffeine caches, and all kinds of stalling and erratic performance went away. It should be unrelated due to this bug dealing with new code for Java 8. Your benchmark touches prior code.

Note that by default there are 4 hash segments, each having its own queue and counter for replaying reads. The queue is uncapped and draining is amortized across readers. There should be a per drain threshold to avoid over penalizing any thread. In a stress test like yours, one could imagine a memory issue, hang ups for the penalized callers, and contention adding to the read buffer. Caffeine uses a lossy ring buffer which avoids all of this. My guess is you are hitting the worst case which wouldn’t be expected in practice, or at least not with the hardware available when the cache was designed.  Because [`ImmutableEntry`](https://github.com/google/guava/blob/c462d69329/guava/src/com/google/common/collect/ImmutableEntry.java) is a package-private type [`Maps.immutableEntry()`](https://google.github.io/guava/releases/21.0/api/docs/com/google/common/collect/Maps.html#immutableEntry-K-V-) has to declare its return type as `Map.Entry`, which (because it's an interface) can't be guaranteed to be immutable. This means that users of `Maps.immutableEntry()` can't express the immutability of the entry objects they're constructing to anyone they pass them off to. Since the immutable types are intended to be "'Interfaces', not implementations", I think it would make sense to expose this type publicly. [AbstractMap.SimpleImmutableEntry](https://docs.oracle.com/javase/7/docs/api/java/util/AbstractMap.SimpleImmutableEntry.html) is built in, so I don't think this is necessary. `SimpleImmutableMap` is actually still problematic since it's not `final` (and hence subclasses could potentially still not be immutable).

There are cases where you want to represent a key-value mapping but can't use a `Map` structure directly (e.g. this is how [proto3 supports maps](https://developers.google.com/protocol-buffers/docs/proto3#maps)) and providing a properly immutable `Entry` implementation would make such patterns safer, rare as they may be.  I'm using Guava 20 because my runtime is fixed to Java7 (App Engine Standard)
```
<dependency>
    <groupId>com.google.guava</groupId>
    <artifactId>guava</artifactId>
    <version>20.0</version>
</dependency>
```

Here is a simple code
```
public static void main(String[] args) {
    Map<String, String[]> map = new HashMap<>();
    map.put("one", new String[] {"a", "b"});
    map.put("two", new String[] {"c", "d"});
    map.put("three", new String[] {"e", "f"});

    String join = Joiner.on("\n").withKeyValueSeparator("/").join(map);
    System.out.println(join);
}
```

And here is the output
```
one/[Ljava.lang.String;@53e25b76
two/[Ljava.lang.String;@73a8dfcc
three/[Ljava.lang.String;@ea30797
```

It seems that the `Arrays.toString()` method is not properly managed when an array need to be outputted


For the moment I managed the problem like this
```
Maps.EntryTransformer<String, String[], String> mapTransformer = new Maps.EntryTransformer<String, String[], String>() {
    @Override
    public String transformEntry(String key, String[] value) {
        return Arrays.toString(value);
    }
};

Map<String, String> map2 = Maps.transformEntries(map, mapTransformer);
String join = Joiner.on("\n").withKeyValueSeparator("/").join(map2);
System.out.println(join);
```
  It resolves #2851  I signed it!  Annotation libraries do not have `optional` any more, and are now runtime dependencies. In those libraries there are very few `RetentionPolicy.RUNTIME` annotations, and even those are not processed by Guava itself.

Please change scope of those dependencies to `<scope>provided</scope>` to have them at compile time but not to drag them into runtime. Dupe of #2824 Ok, in that case following line is not true any more: https://github.com/google/guava/blob/master/guava/pom.xml#L18  I wanted to copy map returned by `Maps.transformValues` using `Maps.immutableEnumMap. Double transformation really surprised me.

`transformEntry()` was called twice per entry:
1. [Maps.java#L150](https://github.com/google/guava/blob/fce5e62628a1eb3eab4dfdb7b6f2ce7fa3567557/guava/src/com/google/common/collect/Maps.java#L150) (null-check),
2. inside [`EnumMap(Map)`](https://docs.oracle.com/javase/8/docs/api/java/util/EnumMap.html#EnumMap-java.util.Map-) constructor.

This may be not the most elegant solution, but

```
for (Map.Entry<K, ? extends V> entry : map.entrySet()) {
  checkNotNull(entry.getKey());
  checkNotNull(entry.getValue());
}
return ImmutableEnumMap.asImmutable(new EnumMap<K, V>(map));
```

could be replaced with something similar to:

```
Class<K> keyType = (Class<K>) map.keySet().iterator().next().getDeclaringClass();
EnumMap<K, V> enumMap = new EnumMap<>(keyType);
for (Map.Entry<K, ? extends V> entry : map.entrySet()) {
  K key = checkNotNull(entry.getKey());
  V value = checkNotNull(entry.getValue());
  enumMap.put(key, value);
}
return ImmutableEnumMap.asImmutable(enumMap);
```

It would be a little less efficient than using `EnumMap(map)` constructor in case of non-views (`put()` vs `putAll()`)~~, so additional `instanceof TransformedEntriesMap` check may be desirable~~.

I know that i can use `ImmutableMap.copyOf` before passing transformed map to `Maps.immutableEnumMap` or use `Maps.toImmutableMap` collector, but I decided to let you know what happened as you may have similar usages in your code base.
 Please ignore `instanceof TransformedEntriesMap` note I made initially. This method should behave in a fully predictable way regardless of `map`' type (non-guava views etc.), so just make sure that `getValue()` is called once). By the way, `(Class<K>)` cast is unnecessary. > Actually, maybe what we should do is just perform the null checks after copying to the `EnumMap`?

@cpovirk That's clever, but it won't be as lazy as `ImmutableMap.copyOf(map)` which throws on first null key/value. This, again, could be surprising. > "Not lazy" in the sense that, if the transformation function returns null, we might transform other values before throwing? That seems probably tolerable.

Yes, that's what I meant. If this little "over-transformation" is tolerable, I don't mind at all! :) Just, please, don't transform twice.

Good luck, @lowasser! ;) Thank you! :)  The `SafeBox` example for `Monitor` is much more verbose than expected. We can do better:

```java
public class SafeBox<V> {
  private V value;
  private final Monitor monitor = new Monitor();
  private final Monitor.Guard valuePresent = guard(monitor, () -> value != null);
  private final Monitor.Guard valueAbsent = guard(monitor, () -> value == null);

  public V get() throws InterruptedException {
    try (LockedMonitor ignored = monitor.autoEnterWhen(valuePresent)) {
      V result = value;
      value = null;
      return result;
    }
  }

  public void set(V newValue) throws InterruptedException {
    try (LockedMonitor ignored = monitor.autoEnterWhen(valueAbsent)) {
      value = newValue;
    }
  }
}
```
 I think it's awkward to ignore a return value just to be able to use the Monitor with try-with-resource. 

I fully support the creation of Guards using a BooleanSupplier, though! I wonder why @cpovirk explicitly excluded Monitor in his search query at issue #2785.  @ChristianCiach agreed, though I think it's nicer than try/finally. Too bad try-with-resources doesn't let you elide the resource variable (compared to `with` in Python where the `as xxx` is optional).  **tl;dr** This fixes part of Java 8's functional mapping combined with IOException, which is currently a pain.

In this Java 8 world, I found useful to have an interface called `IOFunction` that is basically `Function` that can throw `IOException`.

Typical form:

    import java.io.IOException;
    @FunctionalInterface
    public interface IOFunction<F, T> {
      T apply(F input) throws IOException;
    }

Until here, there's nothing really interesting with this interface.

What makes it interesting is coupling it with `ByteSource` and `CharSource` to have a very quick access to a parsed object from those `ByteSource` and `CharSource`.

The typical implementation is rather obvious:

    // In ByteSource
    public <T> T read(IOFunction<InputStream, T> function) {
      try (InputStream in = openStream()) {
        return function.apply(in);
      } catch (IOException e) {
        throw new UncheckedIOException(e);
      }
    }

"Hey, but that's what `ByteProcessor` and `LineProcessor` do!"

Well, yes and no.

`ByteProcessor` takes control of things I don't want it to take control, such as the size of the chunks that need to be processed. Often `ByteProcessor` requires me to internally buffer bytes that overlap between chunks. Same thing for `LineProcessor`: not every text file is line-based. For instance, huge one-line JSON files, which happen every so often.

Also, both `ByteProcessor` and `CharProcessor` are 2-methods interfaces, meaning that they can't be `@FunctionalInterface`, so I can't simply pass a lambda or a method reference to the `read` methods.

Finally the `IOException` isn't manageable in stream-like API without much burden. This is why `UncheckedIOException` was introduced (see `java.nio.file.Files.lines`, for instance).

See how `IOFunction` makes it easy:

    Optional<CharSource> source = ... ;
    Optional<Properties> properties = source.map(s -> s.read(this::loadProperties));

    Properties loadProperties(Reader reader) throws IOException {
      Properties properties = new Properties();
      properties.load(reader);
      return properties;
    }

Look! No resource management, clean `*Source` usage. Clean mapping (as in no inner `try`), I didn't use any complex structure: just a simple method making something obvious. Try making the same with `CharProcessor`. Yup, it's a pain :( Outside of `CharSource`? Well, what's the point to have the resource managed for you then if you don't use it? :P

So to ease the use of `ByteSource` and `CharSource` with Java 8, please think about making such `IOFunction`. Of course It's also OK to have a `FromBytesFunction` for `ByteSource` and `FromCharsFunction` for `CharSource` (this naming is similar to the `ToIntFunction` style, but it seems weak, anything else is welcome, ofc.).

Note that I've edited to make the intent of the method clearer: mapping inside stream-like API. It seems this wasn't clear at first: I thought the whole "Java 8 context" was clear enough, I was wrong. As a bonus, `Properties loadProperties(CharSource source)` avoids problems like "should i close the reader?", "is anyone else using it?" etc. I know. And you're entirely right, @lowasser ! It's not the question of being a pain or something. It's more like being more fluent and readable. I didn't mention that my personal implementation catches the `IOException` and wraps it in an `UncheckedIOException`, which is the deal when using `ByteSource` in j.u.Optional or stream-like API. Writing it plainly causes lots of duplication of that bit. @ogregoire Is `source.read(this::loadProperties)` more readable than `loadProperties(source)`? Really? Who said that? I said it's about being more fluent and readable.

Fluent when dealing with streams, and readable in the code that reads: you don't have to manage the try-with-resources... The try-with-resources is nice and easy, but if we have a tool to even avoid it, why not? You want to read? Then you just write your code from your `InputStream` or your `Readable`.  When we have some reflexive symmetric transitive relation between two instances of one class then an equivalence relation is a helpful assistant for check that this relation was accounted in code earlier.
For example we processed a relation between two people (p1, p2) and we don't want to process a relation (p2,p1) because it is the same. We put (p1, p2) to a set and when we invoke 'contains' method for (p2, p1) on the set we will get true.

[More about Equivalence Relation](https://en.wikipedia.org/wiki/Equivalence_relation)
[Example of implementation](https://github.com/ivan-osipov/guava/commit/007e471f459085edea9a04a13e08c40af4659911) Guava already provides an [`Equivalence`](https://github.com/google/guava/blob/master/guava/src/com/google/common/base/Equivalence.java) class. If I understand correctly, that seems to be what you're looking for. @Stephan202 as I know the goal of an Equivalence class to define a strategy to check equality of objects, I offer the class for storing a relation between objects
@lowasser exactly, it's sort of an unordered pair. In my opinion, when we use a pair - we try to simplify life for ourself, but when we use Equivalence Relation we try to improve our algorithms
@jrtom perhaps, we can, but if we want to keep our code understandable it becomes a not good idea. And Equivalence Relation can support nullable values.  I'm sure that migrating from Maven to Bazel has been​ thought about by someone on the Guava team already, but I thought that the task might as well be jotted down in an issue on GitHub as a future reminder and a meta-issue for when the time comes.

Perhaps the two most important criteria which Bazel needs to meet before migration can even be started would be:
- [ ] Be at a stable version (likely version 1.0 or greater).
- [ ] Can run on all the major OSs that Maven supports (or some other reasonable definition of cross-platform). Will likely include widely-used Linux distributions (Ubuntu, Fedora and others), macOS/OS X, and Windows 7+. @cpovirk Do you know if Dagger receives bug reports from its Windows users who wish to build Dagger from scratch?

I suppose that's my main concern with migrating Guava to Bazel too early (disregarding potential issues like GWT), because I am primarily a Windows 7 user, and my experience with the Windows distribution of Bazel version 0.4.x on chocolatey.org is that it fails to even install core dependencies like msys2 correctly.

I raised this as an issue with the Bazel devs some time ago, but I've admittedly not yet tested if more recent versions like 0.5.x work, so maybe my fear is unfounded now. I haven't received any, but I'd happily accept any request, and we could always set up AppVeyor tests if necessary   @cpovirk, thanks. Could you please also consider (or reject) #2848?  Previously, the TreeTraverser required that `children()` extended
`Iterable<T>`. This commit adds support for trees where children are
returned as `Iterable<? extends T>`.

Use case: support for https://github.com/prestodb/presto/blob/master/presto-parser/src/main/java/com/facebook/presto/sql/tree/Node.java#L43 without need to copy children lists during traversal. @lowasser , good point, thanks, but it just doesn't look that good.

@jrtom , this is even better since signature `<T> preOrder(T x, Function<T, ? extends Iterable<? extends T>>)` will compile nicely with method references. `TreeTraversal.using(func)` can't be made to work with method references in the "relaxed" case unless explicit type for method generic is provided.

That said, is there going to be  `preOrder()` operating on `SuccessorsFunction`-s? I looked into sources, but couldn't find anything besides the interface declaration.

Last but not least, does the _probable_ retirement of `TreeTraverser` say anything in regards on this PR? :)  This is recommended for any java library which is being published to
repositories like MavenCentral or JCenter to ensure that when you do
eventually convert the library to a Java 9 module, it won't change
names requiring all of your consumers and the projects which depend
upon your consumers to update their `moudle-info.java` files to
pick up the new name.

We can debate whether or not `com.google.guava` is the name you want
to adopt for your module. Other possible candidates are:
 * `guava`
 * `google.guava`
 * `com.google.common.guava`
 * Something else

[This article](http://blog.joda.org/2017/05/java-se-9-jpms-automatic-modules.html) covers
a lot of the reasons you might want to use `com.google.guava`, but I have also read reasonable arguments for more concise names if you aren't worried about module name conflicts.

Related (a little bit) to #2571 @jodastephen, the author of that article, actually strongly [suggests](https://groups.google.com/forum/#!msg/guava-discuss/1I--H7xwwR8/OLvJo-FhAwAJ) using `com.google.common`. @Stephan202 you are right. I am happy to change the module name in the pull request to `com.google.common` if the Guava project owns that entire package namespace. I was under the (quite possibly wrong) impression that other libraries provided by other teams at Google might also contribute to that package namespace, and as such, thought that we should coordinate with other libraries/modules that provided subpackages of `com.google.common` by naming this module `com.google.common.guava`. I agree that it would be better to use the root package of the whole package hierarchy.

But, first I would like someone to be able to confidently confirm, "No other jar files inside or outside Google contribute classes to the `com.google.commons` package. It is entirely dedicated to the guava project."

If that's the case, I'll update the pull request on getting that confirmation. It's true. As long as you're willing to claim that the package root `com.google.common` is owned by the guava team, it's a fine choice. I've updated the pull request to match.

 @cpovirk Does the Guava project wholly own the `com.google.common` package and it's sub-packages, both externally on GitHub and internally within Google?

@eljobe If the Guava project does not wholly own `com.google.common` and/or it's sub-packages, will this be a problem? Hmm, after re-reading this conversation, I understand now that only the `com.google.common` package needs to be owned by the Guava team?

On the assumption that my new understanding is correct, I'll rephrase my previous questions:
1. Does the Guava project wholly own the `com.google.common` package (not necessarily it's sub-packages)?
2. If `com.google.common` _isn't_ wholly owned by Guava, would this be a problem for migrating to modules? I think I may be introducing more confusion than clarity here, but it's worth writing about in a bit more detail because we really only want to make this decision once.

First of all, I think that Stephen makes a well-reasoned argument in his [JPMS module naming](http://blog.joda.org/2017/04/java-se-9-jpms-module-naming.html) post.

The point about `com.google.common` not being wholly "owned" by the Guava team is why I originally proposed that we deviate from Stephen's suggestion and go with `com.google.guava` instead of `com.google.common`. The scenario we want to avoid is this one in the future.

There is are 3 separate and mostly-independent teams inside Google each of which maintains a module which exports some packages in the `com.google.common` namespace. Let's call the teams (the people):
Guava Team
Blue Team
Red Team

Guava Team publishes a module which exports packages (reduced for space):
 - com.google.common.annotations
 - com.google.common.base
 - com.google.common.collect

Blue Team publishes a module which exports packages:
 - com.google.common.bonnet
 - com.google.common.bird
 - com.google.common.sky

Red Team publishes a module which exports packages:
 - com.google.common.head
 - com.google.common.hydrant
 - com.google.common.robin

Only one of those teams can call their module `com.google.common`. If the Guava Team takes that, then what will the Blue Team and Red Team use? I'm assuming here that we don't really want the package structure to reflect organizational structure. It should represent what the code in the packages actually does. So, we don't want to force rerooting packages like `com.google.guava.common.base` or `com.google.blue.common.bird` just to create artificial common prefixes we can use for the module names.

There isn't really a great answer here. Personally, I think that `google.guava` would be a fine name. And `google.blue` and `google.red` may eventually make sense for the other modules once they are written. Modules (like the jars in which they are packaged) typically are the natural responsibility of a team of people. Package names are about the organizational logic of the code, but module names can (and maybe even should) reflect the group that is responsible for the module's maintenance. Suppose the Guava project grows in such a way that it makes sense to deliver a separate module for all of the "collect" and "base" packages separate from all the other packages currently bundled in the library. Which of the modules retains the name "com.google.common"?  I think it would make more sense at that point to announce to the community that the "google.guava" module is jettisoning the "collect" and "base" packages into a new "google.guava.core" or maybe "google.guava-core" or maybe even "google.lychee" module.

I actually think it might be better to separate the module names from the packages they contain because those concepts evolve through separate development lifecycles.

But, ultimately, I care less about the name you choose, than that you choose it before the 23.0 release, so we can get it published with this new manifest attribute. The choice is your's. Lets start by observing that Google (the company) owns everything under `com.google`. As such, it can choose to structure module names under there any way it wants, so long as there is a company-wide co-ordination to ensure that no package appears in two modules. This observation allows many choices for the module name however, and as such isn't that helpful.

(The observation is however that ALL Google modules should start with `com.google`, so I'd object strongly to `google.guava` as your module name).

The next observation is that the standard (Java-wide) rule for module names should be that the module name is the super-package name of the project. While this rule handles many cases, it does not of course handle the Guava case, as each package is a sibling.

In my blog, I describe this case, and argue that the implied super-package in a case like this is the next level up. Thus, I arrive at my view of `com.google.common` being the right package name for Guava. Doing so does not stop other teams using `com.google.common.bird` or `com.google.common.head` as module names if they need to.

------

Looking to the future, there is another way to view the whole problem space however. Each package in Guava is pretty isolated. There are dependencies between the packages, but they form a DAG as far as I can tell. As such, it would be perfectly possible for each package to be a separate module (where the module name is then obviously the package name).

Now, today this would be a pain to do, because it would mean publishing a separate artifact to Maven Central for each package, something that nobody would really want. However, there is a fair chance that Oracle will consider having multi-module jar files in a future release of Java (ie. one jar file containing many modules). Were this to happen, having a module for each package is suddenly not such a bad idea, as users could then depend on the subset of Guava they care about, or the whole of it, and not suffer any clashes.

In this scenario, the Guava module would then be an aggregating module that contains no bytecode of its own:

    module ???? {
      requires transitive com.google.common.annotations;
      requires transitive com.google.common.base;
      requires transitive com.google.common.collect;
    }

This is similar to the JDK, where the `java.se` module [aggregates others](https://stackoverflow.com/questions/44178366/what-is-the-significance-of-java-se-module-in-java-9). But note that there is no `java.se` package. ie. Aggregating modules can and will have names that differ from the packages, because they necessarily are aggregations of disconnected packages for the purpose of convenience.

Given this world view, `com.google.guava` is a viable module name, because the "Guava" project can be thought of as an aggregation of a set of unrelated packages Google chooses to publish publicly.

One final note however, if `com.google.guava` were chosen, Google the company would be committing to never having a package name of `com.google.guava`, as to do so would be asking for trouble.

------

So, either `com.google.common` or `com.google.guava` are reasonable choices derived through different thought processes. While I originally strongly recommended the former, the latter does now have appeal given the description above of internal teams also wanting to use the `com.google.common` module name.

Ultimately, the Guava team must decide as to which of the two world-views of the project describes it best - a single project formed of a coherent set of packages (`com.google.common`). Or an aggregation of relatively separate packages that could standalone, unified under a brand name (`com.google.guava`).
 What is the process by which the guava team can get this decision made? Now that JDK 9 looks like passing the official processes with no further changes, it is safe (and recommended) to add `Automatic-Module-Name` to Guava.

You'll keep declaring that until you write a proper module-info file, which won't be too hard to do once JDK 9 is finally released. (Maven has support for compiling module-info.java on JDK 9 and merging the .class file with the rest of the code so it all works on JDK 8).  There is a failing test on the `master` branch. It makes it difficult to test my own changes when master isn't healthy.  This might be a problem with my environment, but I'm not sure yet, so I'm filing this issue in case others have seen it.

```
$> mvn --version
pache Maven 3.5.0 (ff8f5e7444045639af65f6095c62210b5713f426; 2017-04-04T03:39:06+08:00)
Maven home: /Users/pepper/.sdkman/candidates/maven/3.5.0
Java version: 1.8.0_131, vendor: Oracle Corporation
Java home: /Users/pepper/.sdkman/candidates/java/8u131/jre
Default locale: en_US, platform encoding: UTF-8
OS name: "mac os x", version: "10.12.5", arch: "x86_64", family: "mac"

$> mvn package -e
...
Tests run: 2, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.031 sec

Results :

Tests in error: 
  testScanDirectory_symlinkCycle(com.google.common.reflect.ClassPathTest): /var/folders/hj/8mjn8yss769b4tq09bqjnlmw0000gn/T/ClassPathTest482883858389546958: unable to guarantee security of recursive delete
  testScanDirectory_symlinkToRootCycle(com.google.common.reflect.ClassPathTest): /var/folders/hj/8mjn8yss769b4tq09bqjnlmw0000gn/T/ClassPathTest3964094197949145330: unable to guarantee security of recursive delete

Tests run: 831436, Failures: 0, Errors: 2, Skipped: 0

[INFO] ------------------------------------------------------------------------
[INFO] Reactor Summary:
[INFO] 
[INFO] Guava Maven Parent ................................. SUCCESS [  0.140 s]
[INFO] Guava: Google Core Libraries for Java .............. SUCCESS [ 13.045 s]
[INFO] Guava Testing Library .............................. SUCCESS [ 23.493 s]
[INFO] Guava Unit Tests ................................... FAILURE [06:00 min]
[INFO] Guava GWT compatible libs .......................... SKIPPED
[INFO] ------------------------------------------------------------------------
[INFO] BUILD FAILURE
[INFO] ------------------------------------------------------------------------
[INFO] Total time: 06:37 min
[INFO] Finished at: 2017-06-15T10:32:15+08:00
[INFO] Final Memory: 73M/1479M
[INFO] ------------------------------------------------------------------------
[ERROR] Failed to execute goal org.apache.maven.plugins:maven-surefire-plugin:2.7.2:test (default-test) on project guava-tests: There are test failures.
[ERROR] 
[ERROR] Please refer to /Users/pepper/dev/github.com/eljobe/guava/guava-tests/target/surefire-reports for the individual test results.
[ERROR] -> [Help 1]
org.apache.maven.lifecycle.LifecycleExecutionException: Failed to execute goal org.apache.maven.plugins:maven-surefire-plugin:2.7.2:test (default-test) on project guava-tests: There are test failures.

Please refer to /Users/pepper/dev/github.com/eljobe/guava/guava-tests/target/surefire-reports for the individual test results.
	at org.apache.maven.lifecycle.internal.MojoExecutor.execute(MojoExecutor.java:213)
	at org.apache.maven.lifecycle.internal.MojoExecutor.execute(MojoExecutor.java:154)
	at org.apache.maven.lifecycle.internal.MojoExecutor.execute(MojoExecutor.java:146)
	at org.apache.maven.lifecycle.internal.LifecycleModuleBuilder.buildProject(LifecycleModuleBuilder.java:117)
	at org.apache.maven.lifecycle.internal.LifecycleModuleBuilder.buildProject(LifecycleModuleBuilder.java:81)
	at org.apache.maven.lifecycle.internal.builder.singlethreaded.SingleThreadedBuilder.build(SingleThreadedBuilder.java:51)
	at org.apache.maven.lifecycle.internal.LifecycleStarter.execute(LifecycleStarter.java:128)
	at org.apache.maven.DefaultMaven.doExecute(DefaultMaven.java:309)
	at org.apache.maven.DefaultMaven.doExecute(DefaultMaven.java:194)
	at org.apache.maven.DefaultMaven.execute(DefaultMaven.java:107)
	at org.apache.maven.cli.MavenCli.execute(MavenCli.java:993)
	at org.apache.maven.cli.MavenCli.doMain(MavenCli.java:345)
	at org.apache.maven.cli.MavenCli.main(MavenCli.java:191)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.codehaus.plexus.classworlds.launcher.Launcher.launchEnhanced(Launcher.java:289)
	at org.codehaus.plexus.classworlds.launcher.Launcher.launch(Launcher.java:229)
	at org.codehaus.plexus.classworlds.launcher.Launcher.mainWithExitCode(Launcher.java:415)
	at org.codehaus.plexus.classworlds.launcher.Launcher.main(Launcher.java:356)
Caused by: org.apache.maven.plugin.MojoFailureException: There are test failures.

Please refer to /Users/pepper/dev/github.com/eljobe/guava/guava-tests/target/surefire-reports for the individual test results.
	at org.apache.maven.plugin.surefire.SurefireHelper.reportExecution(SurefireHelper.java:74)
	at org.apache.maven.plugin.surefire.SurefirePlugin.execute(SurefirePlugin.java:642)
	at org.apache.maven.plugin.DefaultBuildPluginManager.executeMojo(DefaultBuildPluginManager.java:134)
	at org.apache.maven.lifecycle.internal.MojoExecutor.execute(MojoExecutor.java:208)
	... 20 more
[ERROR] 
[ERROR] Re-run Maven using the -X switch to enable full debug logging.
[ERROR] 
[ERROR] For more information about the errors and possible solutions, please read the following articles:
[ERROR] [Help 1] http://cwiki.apache.org/confluence/display/MAVEN/MojoFailureException
[ERROR] 
[ERROR] After correcting the problems, you can resume the build with the command
[ERROR]   mvn <goals> -rf :guava-tests
```

I can dig into this problem for a few minutes, but it would be great if someone else can take a look who might be familiar with the tests.  Test Travis with env matrix  The default implementations of `{Byte,Char}Source.isEmpty()` seem to do unnecessary work when the size is known to be non-zero.

Here is what `ByteSource` does now:

```java
public boolean isEmpty() throws IOException {
  Optional<Long> sizeIfKnown = sizeIfKnown();
  if (sizeIfKnown.isPresent() && sizeIfKnown.get() == 0L) {
    return true;
  }
  // Fall back to reading a byte from the input stream...
```

I feel like it should do this instead:

```java
public boolean isEmpty() throws IOException {
  Optional<Long> sizeIfKnown = sizeIfKnown();
  if (sizeIfKnown.isPresent()) {
    return sizeIfKnown.get() == 0L;
  }
  // Fall back to reading a byte from the input stream...
```

That way it avoids reading the input stream when the size is known to be non-zero.

I see warnings in the javadocs that some sources report inaccurate sizes, but the example given is non-empty files that report a size of zero.  Are there empty files that falsely report a non-zero size?  If not, I think this change is safe. I think both of these source code examples are equivalent, functionality- and performance-wise, because the `&&` operator _short-circuits_ by my understanding. This means that `sizeIfKnown.get() == 0L` will only be evaluated if `sizeIfKnown.isPresent()` evaluates to true.

Consequently, I believe this change doesn't really do anything. The change skips reading a byte in the known, non-empty case. > The change skips reading a byte in the known, non-empty case.

I admit I struggle to see why. Can you give an example? When `sizeIfKnown()` returns `Optional.of(1000L)`, compare when the method returns. In the first case `ifPresent()` is true but `get() == 0L` is false thus the `if` is not taken. In the second case `isPresent()` is true so the `if` is taken, and then `false` is returned. Oh, I see now! Thanks for enlightening me. :)  For understandable reasons, `com.google.common.hash.Hashing.md5` and `sha1` were deprecated because they are cryptographically broken and it's vital that programmers not rely on them for secure uses.

In a project of mine, there are legacy uses of `md5` that use it as a convenient non-cryptographic hash function, and these uses cannot be readily eliminated.

My project uses Scala, which doesn't give fine-grained control over compiler warnings. As a result, I either have to silence all compiler warnings, or see lots of deprecation warnings about `md5` usage. Both alternatives are undesirable.

I propose that the existing deprecation of `md5` and `sha1` remain; but that a non-deprecated, equivalent version of them be provided for uses such as mine. They should be named something like `unsafeMD5` or `brokenSHA1` to convey the risk of using them, but should not cause compiler warnings when used. That's a good workaround, thanks @cpovirk. By defining a Java class with its fine-grained warning suppression, I was able to eliminate the compiler warnings. This solution works for me (and I hereby place this code in the public domain):

```java
package mypackage;

import com.google.common.hash.HashFunction;
import com.google.common.hash.Hashing;

/**
 * Provides an md5 and sha1 hash function without producing deprecation warnings.
 */
public class LegacyHashing {
    @SuppressWarnings("deprecation")
    public static HashFunction md5() {
        return Hashing.md5();
    }

    @SuppressWarnings("deprecation")
    public static HashFunction sha1() {
        return Hashing.sha1();
    }
}
``` @cpovirk What about nesting `LegacyHashing` inside of `Hashing` and linking the methods the other way round (i.e., `Hashing.md5()` calling `Hashing.LegacyHashing.md5()`) in order to make them easy to discover?  Moving to Bazel would be a very valid option once Bazel cleanly supports Windows, Mac, and Linux, and has the ability to publish artifacts to Maven Central (I'm actually not sure if this feature has been implemented yet). :) It's not really Bazel's responsibility to push to central. As long as it
spits out jars pushing to central can (and should) be done using something
else. See Dagger for an example.

On Fri, Jun 2, 2017 at 6:45 PM Jonathan Bluett-Duncan <
notifications@github.com> wrote:

> Moving to Bazel would be a very valid option once Bazel cleanly supports
> Windows, Mac, and Linux, and has the ability to publish artifacts to Maven
> Central (I'm actually not sure if this feature has been implemented yet). :)
>
> —
> You are receiving this because you are subscribed to this thread.
> Reply to this email directly, view it on GitHub
> <https://github.com/google/guava/issues/2840#issuecomment-305922773>, or mute
> the thread
> <https://github.com/notifications/unsubscribe-auth/AAEEEc8EzVdZzwsDvvnxn6X38iyoZznMks5sAIt8gaJpZM4NuxEa>
> .
>
  > Strings are checked for well-known qualifiers and the qualifier ordering is used for version ordering. Unknown qualifiers are considered after known qualifiers, with lexical order (always case insensitive),

https://github.com/apache/maven/blob/master/maven-artifact/src/main/java/org/apache/maven/artifact/versioning/ComparableVersion.java

@cgdecker "" is the same as "final", so 23.0-rc1 < 23.0 = 23.0-final. It's definitely not about release order. Anyone using movable dependency resolution deserves trouble. But +1 for
killing the badge.

On Thu, Jul 27, 2017, 6:32 PM Chris Povirk <notifications@github.com> wrote:

> Sounds like a good move.
>
> Hopefully Gradle users aren't having too much trouble with 22.0-android as
> "latest."
>
> —
> You are receiving this because you are subscribed to this thread.
> Reply to this email directly, view it on GitHub
> <https://github.com/google/guava/issues/2839#issuecomment-318415886>, or mute
> the thread
> <https://github.com/notifications/unsubscribe-auth/AAEEEVLgk3WmS8krHhM3RW4Alo4u-Js7ks5sSLudgaJpZM4NurXN>
> .
>
  We just upgraded our codebase to Guava 20 and started getting this compiler error:

```
[ERROR] COMPILATION ERROR : 
[INFO] -------------------------------------------------------------
[ERROR] cannot access com.google.errorprone.annotations.CanIgnoreReturnValue
  class file for com.google.errorprone.annotations.CanIgnoreReturnValue not found
[INFO] 1 error
[INFO] -------------------------------------------------------------
```

It seems similar to #2721 except that it affects both Guava 20 and 21 and also seems much more serious since it's an actual compile error and not a warning. After investigating further, the issue seems to be when using (any) annotation processing as well as `ForwardingExecutorService` (which was annotated with `@CanIgnoreReturnValue` as part of Guava 20). My uninformed guess is that javac wants to walk the type hierarchy so it can execute the right annotation processors, so when you have a class that extends `ForwardingExecutorService` it will try to read the annotations and fail when it gets to `@CanIgnoreReturnValue`.

I pushed a very simple example [here](https://github.com/jhaber/guava20-example), you can clone it and run `mvn compile` to reproduce the issue. The project just has a class that extends `ForwardingExecutorService`:

```java
public class MyExecutorService extends ForwardingExecutorService {

  protected ExecutorService delegate() {
    return null;
  }
}
```

and a `META-INF/services/javax.annotation.processing.Processor` file to activate javac's annotation processing. Note that the service file points to a non-existent annotation processor and the build still fails with the `CanIgnoreReturnValue` error. This seems to suggest that the failure is happening while javac is setting up for annotation processing, rather than while the annotation processor is executing (eg, the failure is not related to the implementation of the annotation processor nor is there a way for an annotation processor to catch and ignore these errors).

I see that transitive dependencies have been added as part of Guava 22, which seems unfortunate but probably better than the alternative (especially in light of this issue). The other "fix" that comes to mind is to remove the class-level `@CanIgnoreReturnValue` annotation from `ForwardingExecutorService` and instead annotate the individual methods (in my testing this didn't cause the same compile error, but might cause the warnings that #2721 was referring to). Would it be possible to get a new release of Guava 20 and 21 with one of these (or some other) fix? We have ~2,000 Maven modules that depend on Guava which complicates things a bit. Maven allows you to remove dependencies with exclusions but doesn't have a mechanism to do the opposite (add a new dependency to an artifact). If that existed, we could add the errorprone annotations dependency to Guava in our parent pom and have it apply to everything. But that's wishful thinking; in the meantime we just used the shade plugin to add an errorprone annotations dependency to Guava and depend on this version of Guava internally. For anyone who needs to do the same (I'm quite surprised no one has reported this issue yet) I put the POM in a [gist](https://gist.github.com/jhaber/971262d033df389a73495a20f76ccf0d).

To your second point, I don't like the idea of adding transitive dependencies to Guava (what if these dependencies in turn start adding their own transitive dependencies, and so on). But adding the dependencies seems better than the current state because, as I noted above, it is much easier (at least with Maven) to exclude an unwanted transitive dependency than it is to add a transitive dependency that doesn't exist. Anyone who doesn't want the new dependencies can simply add the appropriate exclusions (and if using `dependencyManagement` this only needs to be done in one place). 

Other options that come to mind are to just remove the errorprone annotations which arguably don't belong in Guava, but it seems like that was already suggested and found unacceptable. A more extreme possibility is to release two versions of Guava. The first version would be like Guava 22; the classes have these extra annotations and there are transitive dependencies. The second version would have no transitive dependencies and in addition the class files would have these annotations stripped (to prevent weird issues like this one). I'm not sure if there's an existing Maven plugin that can do this specifically but it shouldn't be too hard to get working (it seems like a subset of the maven-shade-plugin functionality). @jhaber: If I understand your situation correctly you could also add `error_prone_annotations` to your parent-POM with the `provided` scope. That way it will be present compile-time but not be packaged. We do this in our project (~130 modules) for this dependency as well as others which contain only annotations (`com.google.code.findbugs:jsr305`, `org.immutables:value`). This also doesn't interfere with the dependency analysis performed by the `maven-dependency-plugin`, so it's okay if most/all modules don't _actually_ use those dependencies. Just to follow up, we've since upgraded to 22.0. Having the dependencies listed and excluding the ones we don't want has been much easier on our end. And since it seems like this is going to be maintained going forward I don't think there's a pressing need to make any patch releases.  [2017-06-01 18:16:52,334](main)([]) ERROR - ContextLoader - Context initialization failed
org.springframework.beans.factory.NoSuchBeanDefinitionException: No qualifying bean of type 'com.google.common.cache.CacheBuilderSpec' available: expected at least 1 bean which qualifies as autowire candidate. Dependency annotations: {}
        at org.springframework.beans.factory.support.DefaultListableBeanFactory.raiseNoMatchingBeanFound(DefaultListableBeanFactory.java:1466)
        at org.springframework.beans.factory.support.DefaultListableBeanFactory.doResolveDependency(DefaultListableBeanFactory.java:1097)
        at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveDependency(DefaultListableBeanFactory.java:1059)
        at org.springframework.beans.factory.support.ConstructorResolver.resolveAutowiredArgument(ConstructorResolver.java:835)
        at org.springframework.beans.factory.support.ConstructorResolver.createArgumentArray(ConstructorResolver.java:741)
        ... 94 common frames omitted
Wrapped by: org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name 'com.homeaway.ecommerce.commons.clients.PayoutVendorAccountCache': Unsatisfied dependency expressed through constructor parameter 1; nested exception is org.springframework.beans.f
        at org.springframework.beans.factory.support.ConstructorResolver.createArgumentArray(ConstructorResolver.java:749)
        at org.springframework.beans.factory.support.ConstructorResolver.autowireConstructor(ConstructorResolver.java:189)
        at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.autowireConstructor(AbstractAutowireCapableBeanFactory.java:1148)
        at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBeanInstance(AbstractAutowireCapableBeanFactory.java:1050)
        at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:512)
        at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:482)
        at org.springframework.beans.factory.support.AbstractBeanFactory$1.getObject(AbstractBeanFactory.java:306)
        at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:230)
        at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:302)
        at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:197)
        at org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:754)
        at org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:866)
        at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:542)
        at com.homeaway.api.operations.dependencies.CommonDependencyContainer.loadBeanFactory(CommonDependencyContainer.java:166)
        at com.homeaway.api.operations.dependencies.CommonDependencyContainer.<init>(CommonDependencyContainer.java:123)
        at com.homeaway.api.operations.configuration.DefaultOperationsConfiguration.createDependencyContainer(DefaultOperationsConfiguration.java:471)
        at com.homeaway.api.operations.configuration.DefaultOperationsConfiguration.resourceServiceRegistry(DefaultOperationsConfiguration.java:324)
        at com.homeaway.api.operations.configuration.DefaultOperationsConfiguration$$EnhancerBySpringCGLIB$$a2fe5538.CGLIB$resourceServiceRegistry$22(<generated>)
        at com.homeaway.api.operations.configuration.DefaultOperationsConfiguration$$EnhancerBySpringCGLIB$$a2fe5538$$FastClassBySpringCGLIB$$461876f3.invoke(<generated>)
        at org.springframework.cglib.proxy.MethodProxy.invokeSuper(MethodProxy.java:228)
        at org.springframework.context.annotation.ConfigurationClassEnhancer$BeanMethodInterceptor.intercept(ConfigurationClassEnhancer.java:356)
        at com.homeaway.api.operations.configuration.DefaultOperationsConfiguration$$EnhancerBySpringCGLIB$$a2fe5538.resourceServiceRegistry(<generated>)
        at org.springframework.beans.factory.support.SimpleInstantiationStrategy.instantiate(SimpleInstantiationStrategy.java:162) [4 skipped]
        at org.springframework.beans.factory.support.ConstructorResolver.instantiateUsingFactoryMethod(ConstructorResolver.java:588)
        at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.instantiateUsingFactoryMethod(AbstractAutowireCapableBeanFactory.java:1128)
        at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBeanInstance(AbstractAutowireCapableBeanFactory.java:1022)  Greetings, 

This test

```java
  @CollectionFeature.Require(SUPPORTS_ADD)
  public void testAddAll_supportedNonePresent() {
    assertTrue(
        "addAll(nonePresent) should return true", collection.addAll(createDisjointCollection()));
    expectAdded(e3(), e4());
  }
```
in CollectionAddAllTester

is called for my Map, and keySet() and entrySet() of the map, which is fine.
but it is also calling for the values() collection of the map. How is that supposed to work? How am i supposed to generated keys?
 Yes, i am passing SUPPORTS_ADD. ok, will remove. thanks Hello. My cell phone device have been hack and I have coming across off a lot of damage that the hacker have cause using my device I have limeted control of the cell phone any how I need help  @luisvega10 I think you might be in the wrong place, maybe try gsm hosting forums.
  I am running
```@CollectionFeature.Require(absent = KNOWN_ORDER, value = SUPPORTS_ITERATOR_REMOVE)
  public void testIterator_unknownOrderRemoveSupported() {
    runIteratorTest(MODIFIABLE, IteratorTester.KnownOrder.UNKNOWN_ORDER, getSampleElements());
  }
```
on a set, and the stimuli running is

[hasNext, hasNext, next, hasNext, remove]

My set throws an IllegalStateException on the remove, but the reference does not throw an exception.

thus, it fails, in

```if (referenceException == null) {
      if (targetException != null) {
        Helpers.fail(targetException, "Target threw exception when reference did not");
      }
```

Am i wrong in throwing that exception? i thought once hasNext() was called, the remove couldn't be called... ok. thank you.  The test
```java
@CollectionFeature.Require(value = SUPPORTS_ADD, absent = ALLOWS_NULL_VALUES)
  public void testAddAll_nullUnsupported() {
    List<E> containsNull = singletonList(null);
    try {
      collection.addAll(containsNull);
      fail("addAll(containsNull) should throw");
    } catch (NullPointerException expected) {
    }
    expectUnchanged();
    expectNullMissingWhenNullUnsupported(
        "Should not contain null after unsupported addAll(containsNull)");
  }
```

only catches NPE. My collection throws IllegalArgumentException when null is presented, and thus testlib fails the test. Seems like any exception really should be caught. or at least IAE well, there is this
* @throws IllegalArgumentException if some property of the element
     *         prevents it from being added to this collection

but ok. if NPE is expected to be thrown, then i'll change it. throwing NPEs is just so ugly  The maven artifact for guava 22.0 declares non-optional compile dependencies (e.g. jsr305, error_prone_annotations) while the previous version 21.0 declares all compile dependencies as optional. Is this intended?
  Ordering.immutableSortedCopy should allow to pass wildcard type (Similar to ImmutableList.copyOf()).

    public <E extends T> ImmutableList<E> immutableSortedCopy(Iterable<? extends E> elements).

We use it sometimes, but lack of wildcard forces to use ugly casts.  Runnable doesn't throw exceptions. Callable throws all Exceptions and has a return value, forcing one to declare a Callable<Void> argument in their code, and forcing users of the API to "return null" at the end of their lambdas for no good reason.

A ThrowingRunnable that throws a generic exception type would be really handy. Something like:

```
public interface ThrowingRunnable<T extends Exception> {
    public void run() throws T;
}
```

I don't know how many times I defined a ThrowingRunnable that throws a specific exception type. This seems pretty useful with Java 8 for helper utilities that take a lambda that throws something and throws that same thing in return. Here's a few ideas:

```
/** Runs the runnable if the executionIndentifier hasn't been seen before */
public class ExecutionMemoizer {
    public <T extends Exception> void runOnce(ThrowingRunnable<T> throwingRunnable, Object executionIdentifier) throws T {...}
}

public class ThrowingRunnables {
    public static <T extends Exception> ThrowingRunnable<T> sequence(ThrowingRunnable<? extends T>... runnables) {...}
}
```

My first question should be, I guess, why doesn't this exist already. It's not a far fetched idea, somebody probably thought of this before. There must be a reason, and I'm curious about it.

This maybe seen as a step to reimplementing java.util.function to support throwing exceptions. I'm down with that too. It seems like the norm today is, when using java.util.function stuff with lambdas that throw exceptions, to wrap exceptions in runtime exceptions and unpack at the other side. That's a bad idea and nobody should be doing that. There should be a working alternative and Guava is the place to provide it. 

If you think this would be a nice thing to have, I'll contribute.

Thanks!  This is available as `Checked` types in other utilities, e.g. [jOOL](https://github.com/jOOQ/jOOL) and [vavr](https://github.com/vavr-io/vavr). Its probably better to add one of them instead. Available in [MµG](https://github.com/google/mug/tree/master/core/src/main/java/com/google/mu/function) as well.  A `Map.compute` may return `null` to indicate the entry should be removed if present. The `valueReference` is stored within the cache, allowing a subsequent `LoadingCache.get` to wait on it. This results in `LocalCache.waitForLoadingValue` to throw an `InvalidCacheLoadException` with the message `CacheLoader returned null for key`. Since the cache loader was not invoked, this message is incorrect and means the two methods cannot be used together, concurrently.

The user expectation would be that the load proceeds by retrying the load if `null` from a computation (but fails if from a cache loader). That may require using a sentinel value.

You can checkout this [commit](https://github.com/ben-manes/caffeine/commit/764df3aac6aacb78a4fc5a2134f911fd60dfa9f9) and run `MultiThreadedTest` using `./gradlew slowGuavaTest`. 

```java
Expected: is an empty collection
     but: <[Failed: key 15 on operation com.github.benmanes.caffeine.cache.MultiThreadedTest$$Lambda$3/841283083@91eee99
com.google.common.cache.CacheLoader$InvalidCacheLoadException: CacheLoader returned null for key 15.
	at com.google.common.cache.LocalCache$Segment.waitForLoadingValue(LocalCache.java:2321)
	at com.google.common.cache.LocalCache$Segment.get(LocalCache.java:2206)
	at com.google.common.cache.LocalCache.get(LocalCache.java:4147)
	at com.google.common.cache.LocalCache.getAll(LocalCache.java:4210)
	at com.google.common.cache.LocalCache$LocalLoadingCache.getAll(LocalCache.java:5154)
	at com.github.benmanes.caffeine.cache.testing.GuavaCacheFromContext$GuavaLoadingCache.getAll(GuavaCacheFromContext.java:422)
	at com.github.benmanes.caffeine.cache.MultiThreadedTest.lambda$1(MultiThreadedTest.java:101)
	at com.github.benmanes.caffeine.testing.Threads$Thrasher.run(Threads.java:149) Actually there are simpler fixes. A sentinel value would be invasive by requiring all read/write methods to check and translate, and computers to allocate a function to translate a null to the sentinel.

- Add a `ComputingValueReference` and have an instanceOf check in `waitForLoadingValue` when a null was detected. This class could extend `LoadingValueReference` as its merely tagging the behavioral difference.
- Add a decorator to the user's `CacheLoader` and move the assertion there. (This would also be needed in `get(key, callable)`).

All would require the cache loading calls to handle a retry loop. These two (or perhaps a similar variant) would be easy to implement and isolates the changes. We could also run a snapshot through the test suites to verify.  Added some Unit Tests that cover uncovered code until yet. @cpovirk 
Would you mind approving my contribution?  New in Release 22 are a bunch of Maven dependencies that look like they should be compile-only, but are now required at runtime.
```
[INFO] +- com.google.guava:guava:jar:22.0:compile
[INFO] |  +- com.google.code.findbugs:jsr305:jar:1.3.9:compile
[INFO] |  +- com.google.errorprone:error_prone_annotations:jar:2.0.18:compile
[INFO] |  +- com.google.j2objc:j2objc-annotations:jar:1.1:compile
[INFO] |  \- org.codehaus.mojo:animal-sniffer-annotations:jar:1.14:compile
``` In case you didn't know "compile-only" is the `provided` scope. The `compile` scope is compile-time and later (i.e. including `runtime` and `test`).

Sounds like they should be either `<optional>true</optional>`, `<scope>provided</scope>`, or moved into a new "build tools" pom that people can depend on separately. I believe `<scope>provided</scope>` matches your intent, so is probably the correct solution. Any chance of a quick 22.1 release to resolve this? Otherwise we'll be adding a ton of exclusions for dependency convergence. I believe #2721 (0e29934933f33379de953727171f7ca1ec616a58) is a reasonable change, but since it affects backward compatibility, I think it should be clarified at least in the release notes. Please be aware that changes to pom.xml do not appear in the Full JDiff Report. Then my third suggestion still remains - move them to be dependencies of a new artifact.
Then people who just want to use the library don't have to add exclusions, and anyone who wants to build against it avoiding #2721 adds the extra dependency.
```
<dependency>
  <groupId>com.google.guava<groupId>
  <artifactId>guava-annotations</artifactId>  <!-- first name I thought of -->
  <type>pom</type>
  <scope>provided</scope>
</dependency>
``` Will Guava version `23.0` include that extra 4 dependencies?
I can still see them been dragged on our Maven project by `23.0-rc1`  I am using MutableValueGraph and has  graph structure as 
1,1 -> 0
1,2 -> 2
2,2 -> 0
2,3 -> 3
3,3 -> 0

now if i get edge value for (1,2) it returns 2 but for (1,3) it returns null
its their any way to make it return 5(i.e 2+3) or should i use any other data structure for this purpose  I realize you have to do something in this scenario, but there's no where I can find in the doc that mentions that users might be interested in watching for a ClassCastException from contains in this situation. I never casted in my code - I just called it like this:
Range range = Range.downTo(0);
then later:
range.contains(0.00001);
the call to contains threw a ClassCastException because the range that was created contained a lower bound of type Integer and the value I passed to contains was clearly a Double. When compareTo was used (both are comparable), the code attempted to cast one of them to the other type. As I understand it here, the problem isn't that 0 can't be cast to a double - it's that 0 (integer) can't be autoboxed into a Double. I see what you're saying. I showed you the code I wrote, but I failed to mention that I was calling Range.downTo(minValue, minInclusive) within a generic builder:
```
class GuavaRangeBuilder<T extends Comparable<?>> {
    private T minValue;
    private T maxValue;
    private BoundType minInclusive;
    private BoundType maxInclusive;
    ...
    Range build() {
        ...
        return Range.downTo(minValue, minInclusive);
        ...
}
```
No compiler warnings here - T was an Integer at the time "build()" was called, thus Range was created with an Integer as the lowerBound.

Thanks for the feedback, btw.  This is not a issue, is just a question. Is there any reason why you are using "Object var1" parameter instead of "K var1" for invalidate method? I see for all the other methods the generics are used.      UnsignedBytes, UnsignedInts and UnsignedLongs all have many methods that can be re-implemented using methods in the primitive wrapper classes new to Java 8, and/or deprecated and scheduled for removal.
Here are the obvious mappings I found in UnsignedInts:

Guava | Java 8
------|------
UnsignedInts.compare(int, int) | Integer.compareUnsigned(int, int)
UnsignedInts.toLong(int) | toUnsignedLong(int)
UnsignedInts.divide(int, int) | Integer.divideUnsigned(int, int)
UnsignedInts.remainder(int, int) | Integer.remainderUnsigned(int, int)
UnsignedInts.parseUnsignedInt(String) | Integer.parseUnsignedInt(String)
UnsignedInts.parseUnsignedInt(String, int) | Integer.parseUnsignedInt(String, int)
UnsignedInts.toString(int) | Integer.toUnsignedString(int)
UnsignedInts.toString(int, int) | Integer.toUnsignedString(int, int)

Similar mapping can be found in UnsignedBytes and UnsignedLongs (and possibly in the yet-to-be-released UnsignedShorts)
  In `ImmutableDoubleArray`, documentation ([as of 22.0-rc1](http://google.github.io/guava/releases/22.0-rc1/api/docs/com/google/common/primitives/ImmutableDoubleArray.html)) of the behaviour of `equals(Object)`, `indexOf(double)` and `lastIndexOf(double)` is ambiguous as to the treatment of NaNs.

Specific examples:
```java
ImmutableDoubleArray a = ImmutableDoubleArray.of(Double.NaN);
a.equals(a) == ? (hopefully true)
a.equals(ImmutableDoubleArray.of(Double.NaN)) == ?
a.indexOf(Double.NaN) == ?
a.lastIndexOf(Double.NaN) == ?
```

I suppose behaviour with the infinities and `-0.0` is unambiguous, but perhaps this should be documented too. Hi. Sorry, I'm not sure quite how I missed that for `indexOf(double)` and `lastIndexOf(double)` - the behaviour is quite clear.

For `equals(Object)` however there is no doc comment, which is the actual problem. (It needs to exist, unlike that of e.g. `ImmutableList<T>`, whose specification is inherited from `List<T>`.)

This also goes for `ImmutableIntArray` and `ImmutableLongArray`, although of course they don't suffer from any NaN weirdness.  Currently, `Iterables.getOnlyElement` just uses the iterator. A small optimization is to check whether the iterable implements `List` and `RandomAccess`, and if so, use `size()` and `get(0)` to get the only element. This would save an iterator allocation.  In my dissertation software, I have an instance of `MutableGraph<Equivalence.Wrapper<CustomDataClass>>`, where the associated `Equivalence` is `Equivalence.identity()`.

It involves some difficult-to-read boilerplate during interaction, due to need to create and unwrap the `Wrapper` instances. The alternative is to make `CustomDataClass`'s `equals` and `hashCode` be identity-based rather than value-based, and whereas I could do that, it feels dirty as `CustomDataClass` is supposed to be value-based (as if it were an `@AutoValue` class, or a `case class` or `data class` from Scala or Kotlin).

If I could specify upfront when creating the graph that the equality and hash codes of nodes are  determined by `identity()`, then that would eliminate a good amount of boilerplate in my code.

This could probably be expanded to accept any `Equivalence` rather than just `identity()`. However, it's not clear to me if it could be also be expanded to `ValueGraph`s and `Network`s; I suspect it would be useful sometimes for edge values to have a different `Equivalence` to nodes, so that would make things more complicated. @jrtom For my dissertation, I'm trying to model the order of "events" in a hypothetical concurrent software system:
- `CustomDataClass` is the value class - a blueprint for individual events.
- `MutableGraph` is the data structure that determines how the events are ordered.
- Each event is a node in the graph.
- A directed edge from `nodeU` to `nodeV` means that `nodeU` happen(s|ed) before `nodeV`.

Each event contains an "entity" (e.g. a networked computer) and a "message" (e.g. bits down the wire).
That's all fine, but when I insert an event into the `MutableGraph<CustomDataClass>`, I have a potential situation where if an event has an equal entity and message to an event that's already in the graph, then the new event doesn't get inserted. This happens for 2 reasons:
- `CustomDataClass.equals()` equates instances by the value of their entity and message, so the two events are considered "equal"
- `common.graph.Graph`s cannot contain 2 or more equal nodes

It's a problem because 2 or more events with an equal entity and message may occur during the lifetime of a concurrent software system (for the purposes of my dissertation). Since graphs reject equal nodes, I need a different solution.

My solution is to wrap each event with `Equivalence.identity()`. This causes two distinct events which coincidentally have equal entities and messages to _not_ be considered equal by the graph (because `==` is now used for equality), which allows both events to be inserted.

However, this means that the `MutableGraph` now contains `Wrapper<CustomDataClass>`s rather than plain `CustomDataClass`s. This introduces visual indirection, which makes code that I wrote to work with the graph harder for me to read, understand again, and update.

I hope this clears things up. I'd be very happy to answer your questions @jrtom, but as I've not explained the full story and the details are rather academic, I agree with you that it would be best to take this to email.

My email address is available on my profile; I can't seem to find yours, so how would you like to do this?  BloomFilter should follow the same philosophy as the Java Collections FrameWork: lightweight - no built-in thread-safety. When building BloomFilters we should focus on building it through reducing:

```
(bf,value)-> { bf.put(value); return bf; }
(bfl,bfr) -> { bfl.putAll(bfr); return  bfl; }
```

During this reduction process, which happens in parallel, at no point in time we need the properties of thread-safety.

Nice opportunity to write a `java.util.stream.Collector` that helps us reducing this straight out of Java 8 streams.

For reference - please see http://stackoverflow.com/questions/31788714/reducing-with-a-bloom-filter Argh, ninja'd by @lowasser. :wink: 

Anyhoo, here is what I was going to say:

---

Hi @jdesmet, I think it'll take a _lot_ of convincing towards the Guava team to drop thread-safety in `BloomFilter`, because they only just recently accepted a huge PR to allow `BloomFilter` to be thread-safe (https://github.com/google/guava/pull/2761).

I admit I don't understand why "reducing" is any better than `BloomFilter`'s current way of doing things. Can you elaborate further? Also, do you have any numbers to prove that `BloomFilter` as it is is not fast enough? Of course I did not have any concrete evidence that non-thred-safe would be faster. That was just assuming by the way the Collections Framework was laid out and documented, and lack of better researching myself. I trust the findings in [#2761](https://github.com/google/guava/pull/2761). Interesting topic thread.

On the other hand - there will be always some level of distrust, maybe also in the correctness as extra levels of complexity are introduced. After all I had this first reaction to the `@ThreadSafe` tagging.

"Reducing" was quoted as a method for building the `BloomFilter`, because it only requires the properties of a monoid, and does not require thread-safety of the underlying data structures being reduced. Otherwise, if no additional overhead, I believe that current way BloomFilter works can be properly wrapped in any reducer. All I need is the `put` and `putAll`. The correctness is fudged because Guava's BloomFilter doesn't have a `clear()` method and, fundamentally, the data structure is probabilistic. That meant the concurrent version could be low overhead because races are benign.

Had a `clear()` method been in the API, then a more invasive rewrite would have been required to have satisfactory performance. In that case a Bloom-1 design would have been appropriate. But most likely the proposal of thread safety would have been rejected as too invasive and not driven by an internal need.  Our own `MoreCollectors` class contains solely collectors which create Guava collections. Now that Guava does have collectors, having these in Guava would be useful.

    public static <T> Collector<T, ?, List<T>> toImmutableList()

    public static <T> Collector<T, ?, Set<T>> toImmutableSet()

    public static <T extends Comparable<?>> Collector<T, ?, SortedSet<T>> toImmutableSortedSet()

    public static <T, K> Collector<T, ?, Map<K, T>> toImmutableMap(
        Function<? super T, ? extends K> keyMapper)

    public static <T, K, U> Collector<T, ?, Map<K, U>> toImmutableMap(
        Function<? super T, ? extends K> keyMapper, Function<? super T, ? extends U> valueMapper)

 Argh... okay. That certainly isn't where I expected to find a collector. :/ Java's don't expose the implementation details, e.g. `toMap()` doesn't state that it is a `HashMap`. Since the collectors in Guava do expose the type, e.g. `ImmutableMap`, your approach seems quite reasonable.  New child of EventBus that uses immediate Dispatcher, which isn't used in any impl as of now. I signed it!  Referencing #1259.

The documentation for Ints.trParse explicitly says that a NullPointerException is not thrown if the input is null. However, this is not true and the function does indeed throw a NPE.

I have simply removed the misleading lines from the doc. @googlebot I signed it!          Iterator<String> iter1 = Arrays.asList("1", "5").iterator();
        Iterator<String> iter2 = Iterators.concat(Iterators.singletonIterator("2"), iter1);

        assertEquals("2", iter2.next());
        assertEquals("1", iter2.next()); // iterator points to before "5" now

        Iterator<String> iter3 = Iterators.concat(Iterators.singletonIterator("3"), iter2); // prepend 3
        assertEquals("3", iter3.next());

        assertEquals("5", iter3.next()); // here we get NoSuchElementException   Yup, that's exactly what we want. d'oh  If the computeIfAbsent methods fails with a runtime exception, successive calls to computeIfAbsent lock due to a call to oldValue.waitForValue which never will receive a value then.

A test case to reproduce this behavior - the second computeIfAbsent will never return and your app is frozen.
The pull request restores the previous state of the cache on RuntimeException and the test will finish correctly.

`public class TestGuava extends TestCase
{
    private Cache<String, Boolean> cache = CacheBuilder.newBuilder()
            .maximumSize(10000)
            .expireAfterAccess(30, TimeUnit.SECONDS)
            .build();
    private Map<String, Boolean> cacheMap = cache.asMap();

    private final static Boolean TEST_BOOLEAN = new Boolean(true);
    public void testComputeException()
    {
        try
        {
            cacheMap.computeIfAbsent("a", key ->
            {
                throw new IllegalArgumentException();
            });

            fail();
        }
        catch (Exception e)
        {
            // expected
        }

        Boolean ret = cacheMap.computeIfAbsent("a", key -> {
            return TEST_BOOLEAN;
        });

        assertEquals(Boolean.TRUE, ret);
        assertSame(TEST_BOOLEAN, ret);

        ret = cacheMap.computeIfAbsent("a", key -> {
            return new Boolean(true); // should not create a new entry
        });

        assertEquals(Boolean.TRUE, ret);
        assertSame(TEST_BOOLEAN, ret);
    }
}` I signed it! This should rethrow Throwable in case of an Error. @ben-manes : You mean instead of catching "just" the RuntimeException (which actually is rethrown) to catch a Throwable, right? Else, I don't know which "Error" you mean. Yes, use Throwable. Otherwise a [java.lang.Error](https://docs.oracle.com/javase/8/docs/api/java/lang/Error.html) or sneakily thrown checked exception will not be handled. Well, thanks to Java 8 that one was easy to fix. Done! I'd like to ask if there is something else I can do that this fix gets merged?  I would also like to see this fix merged and released soon as I've seen a couple separate projects hit deadlocks on cache `compute` and the fix for https://github.com/google/guava/issues/2743 did not fully handle the above mentioned failure cases.

Thanks!  The linked Google Spreadsheet is no longer available (at least externally). I think it's fine to remove since the link to unicode.org details which codepoints are defined as whitespace.

Also, I double checked, and the list hasn't changed compared to what's used in CharMatchers. Cool! That other link works from my side.  

I think the spreadsheet is a great reference (and I've seen it referenced around the net) so I think it's definitely worth keeping.

I'll update the PR I'm the next few days to swap the link.  I'd like RateLimiter to come out of Beta. It has been around since version 13.0 There is a TODO over at com.google.common.util.concurrent.RateLimiter.create

```java
/*
 * TODO(cpovirk): make SleepingStopwatch the last parameter throughout the class so that the
 * overloads follow the usual convention: Foo(int), Foo(int, SleepingStopwatch)
 */
@VisibleForTesting
static RateLimiter create(SleepingStopwatch stopwatch, double permitsPerSecond) {
  RateLimiter rateLimiter = new SmoothBursty(stopwatch, 1.0 /* maxBurstSeconds */);
  rateLimiter.setRate(permitsPerSecond);
  return rateLimiter;
}
```

Would you want a pull request to refactor this?  Here is the sample code that demonstrates the problem:
```java
	@Test
	public void testRemoveDuringIterate1() {
		ListMultimap<String, Integer> map = LinkedListMultimap.<String, Integer>create();
		map.get("one").add( 1);
		map.get("one").add( 2);
		map.get("one").add( 3);
		map.get("one").add( 4);
		map.get("one").add( 2);

		Iterator<Integer> it = map.get("one").iterator();
		assertTrue(it.hasNext());
		assertEquals(Integer.valueOf(1), it.next());
		map.remove("one", 4);
		List<Integer> remain = new ArrayList<>();
		it.forEachRemaining((e)->remain.add(e));
		assertEquals(Arrays.asList(2,3,2), remain);
	}

	@Test
	public void testRemoveDuringIterate2() {
		ListMultimap<String, Integer> map = LinkedListMultimap.<String, Integer>create();
		map.get("one").add( 1);
		map.get("one").add( 2);
		map.get("one").add( 3);
		map.get("one").add( 4);
		map.get("one").add( 5);

		Iterator<Integer> it = map.get("one").iterator();
		assertTrue(it.hasNext());
		assertEquals(Integer.valueOf(1), it.next());
		map.remove("one",2);
		List<Integer> remain = new ArrayList<>();
		it.forEachRemaining((e)->remain.add(e));
		assertEquals(Arrays.asList(3,4,5), remain);
	}
```

First test passes, but second fails on last check, `remain` is [2,3,4,5] instead of expected [3,4,5]
I would expect that iterator either ignores all changes, or respect them all.
 I suggest the following fix https://github.com/alsemenov/guava/commit/5562a2392823ad346c570d18cd177d8e88897852  Currently the `ToStringHelper` class constructs a StringBuilder with an initial capacity of 32 in the `toString` method
```
 @Override
    public String toString() {
      // create a copy to keep it consistent in case value changes
      boolean omitNullValuesSnapshot = omitNullValues;
      String nextSeparator = "";
      StringBuilder builder = new StringBuilder(32).append(className).append('{');
```
I think it would be useful to add an instance field to ToStringHelper that holds a Appendable instance that can be given to it, or defaulted to the ` new StringBuilder(32)`. Also additional factory methods would be added to`MoreObjects` to allow the user to specify said instance, e.g. `public static ToStringHelper toStringHelper(Appendable buffer, Object self) `.  This would allow reuse of StringBuilders as opposed to creating them every time. Scratch the `Appendable`, it can throw an `IOException`. Either `AbstractStringBuilder` or just a `StringBuilder` I am not having performance problems, but this seems like a good middle ground for people. There are cases were you don't want to allocate large `StringBuilders` over and over again, but want to stick with `ToStringHelper` for consistency sake. How about a `toString(StringBuilder sb)` and the original `toString()` that calls `toString(new StringBuilder(32))`? Having more flexibility seems like a win. I'd be more than happy to provider a PR > `ToStringHelper` already builds up a linked list of wrapped entries

I really wonder why. Building the string immediately in `add` would make it much simpler. The result would change in some strange cases, e.g., for `ToStringHelper.add("a", null).omitNullValues().toString()`, but learning to set an option before use shouldn't be hard. The result would also differ when the object changes between calls, but this doesn't seem important either. Where am I wrong?

I guess, I wouldn't use `toString(StringBuilder sb)`, but what about `appendTo(StringBuilder sb)`, which is more general (like `Joiner#appendTo`)? So there are cases where we get some really large strings (> 1K), so reusing large buffers (via a thread local or something) would be a win for me.  It is multiple things that are appended that cause the re-sizing of the buffer so it won't be a single resize. It is generally for logging. Performance critical is relative. Profiling the code you can see that the object allocation is definitely a drag. Disabling logging which basically no-ops these toStrings across improves performance by about 20%. So I wanted to still use Guava because of the flexibility in generating the toStrings, but wanted to re-use the buffers on a per-thread basis to cut down on those large allocations. It is easy enough to roll my own, but thought this would be a good addition to guava for those folks that like a middle ground.  Is it possible to support the use case here:
http://stackoverflow.com/questions/11120985/guava-collections-limit-permutation-size

Or alternatively, provide a static function like Sets#powerSet that returns instead of "the set of all possible subsets.." the set of all possible subsets of a given size? BTW I'm happy to do the legwork to implement this, provided one of the two solutions above makes sense. I believe this has been fixed as of https://github.com/google/guava/commit/8e7ff6a20794497109bcdae369c15d81d35dc3e7, with the introduction of `Sets.combinations(Set, int)`.

I don't know which release - 22.0 or 23.0 -  that it's planned for, however.  Hello.
Trying to compile my GWT (2.8.0) project by maven with dependency:
```
<dependency>
  <groupId>com.google.guava</groupId>
  <artifactId>guava-gwt</artifactId>
  <version>21.0</version>
</dependency>
```
and got the following:
```
[INFO] diagnostic C:\Users\user\.m2\repository\com\google\guava\guava-gwt\21.0\guava-gwt-21.0.jar(com/google/common/collect/Collections2.java):532: error: cannot access com.google.common.collect.AbstractIterator
  private static final class OrderedPermutationIterator<E> extends AbstractIterator<List<E>> {
                                                                   ^
  bad source file: C:\Users\user\.m2\repository\com\google\guava\guava-gwt\21.0\guava-gwt-21.0.jar(com/google/common/collect/AbstractIterator.java)
    file does not contain class com.google.common.collect.AbstractIterator
    Please remove or make sure it appears in the correct subdirectory of the sourcepath.
[ERROR] error on execute: error during compilation
...
[ERROR] Failed to execute goal org.bsc.maven:maven-processor-plugin:1.0.0:process (process) on project portal: Error executing: error during compilation -> [Help 1]
org.apache.maven.lifecycle.LifecycleExecutionException: Failed to execute goal org.bsc.maven:maven-processor-plugin:1.0.0:process (process) on project portal: Error executing
        at org.apache.maven.lifecycle.internal.MojoExecutor.execute(MojoExecutor.java:213)
        at org.apache.maven.lifecycle.internal.MojoExecutor.execute(MojoExecutor.java:154)
        at org.apache.maven.lifecycle.internal.MojoExecutor.execute(MojoExecutor.java:146)
        at org.apache.maven.lifecycle.internal.LifecycleModuleBuilder.buildProject(LifecycleModuleBuilder.java:117)
        at org.apache.maven.lifecycle.internal.LifecycleModuleBuilder.buildProject(LifecycleModuleBuilder.java:81)
        at org.apache.maven.lifecycle.internal.builder.singlethreaded.SingleThreadedBuilder.build(SingleThreadedBuilder.java:51)
        at org.apache.maven.lifecycle.internal.LifecycleStarter.execute(LifecycleStarter.java:128)
        at org.apache.maven.DefaultMaven.doExecute(DefaultMaven.java:309)
        at org.apache.maven.DefaultMaven.doExecute(DefaultMaven.java:194)
        at org.apache.maven.DefaultMaven.execute(DefaultMaven.java:107)
        at org.apache.maven.cli.MavenCli.execute(MavenCli.java:993)
        at org.apache.maven.cli.MavenCli.doMain(MavenCli.java:345)
        at org.apache.maven.cli.MavenCli.main(MavenCli.java:191)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
        at java.lang.reflect.Method.invoke(Method.java:498)
        at org.codehaus.plexus.classworlds.launcher.Launcher.launchEnhanced(Launcher.java:289)
        at org.codehaus.plexus.classworlds.launcher.Launcher.launch(Launcher.java:229)
        at org.codehaus.plexus.classworlds.launcher.Launcher.mainWithExitCode(Launcher.java:415)
        at org.codehaus.plexus.classworlds.launcher.Launcher.main(Launcher.java:356)
Caused by: org.apache.maven.plugin.MojoExecutionException: Error executing
        at org.bsc.maven.plugin.processor.AbstractAnnotationProcessorMojo.execute(AbstractAnnotationProcessorMojo.java:204)
        at org.apache.maven.plugin.DefaultBuildPluginManager.executeMojo(DefaultBuildPluginManager.java:134)
        at org.apache.maven.lifecycle.internal.MojoExecutor.execute(MojoExecutor.java:208)
        ... 20 more
Caused by: java.lang.Exception: error during compilation
        at org.bsc.maven.plugin.processor.AbstractAnnotationProcessorMojo.executeWithExceptionsHandled(AbstractAnnotationProcessorMojo.java:353)
        at org.bsc.maven.plugin.processor.AbstractAnnotationProcessorMojo.execute(AbstractAnnotationProcessorMojo.java:197)
        ... 22 more
```
Target JDK is 1.8.
I'll appreciate any help about that. Thanks. Hi @cpovirk, it does not work, furthermore with 20.0 version I see the same situation. Ok I'll try to reproduce the problem with some GWT example and let you know. Thanks for help.  It turns out `google` is now a public suffix! I signed it!  In a normal application is common to throw an exception after eval an expression like

```
if (balance < amount) {
   throw new InsufficientFundsException();
}
```

```
if (!optional.isPresent()) {
  throw new NotFoundException();
}
```

This PR aims to get rid of those boilerplate code with propagateIf

```
Throwables.propagateIf(balance < amount, () -> new InsufficientFundsException());
Throwables.propagateIf(!optional.isPresent(), () -> new NotFoundException());
```

 I signed it! I understand your point however Guava provides Preconditions which have similar idea. Look at the  throwIfInstanceOf:

```
Throwables.throwIfInstanceOf(e, MyException.class)
```
The same could be achieved with
```
if (e instanceof MyException) {
  throw (MyException) e;
}
```

Both have similar amount of caracteres. The same applies for Preconditions so I assumed that amount of caracteres is not the main factor here and reduce the boilerplate code and unneeded complexity it was the main goal. Plus, you can eliminate characters:

```
Throwables.propagateIf(balance < amount, InsufficientFundsException::new);
```  Unfortunately, in cases where useful factory methods already exist, I cannot access them ;) 
 
#2514 I think you should highlight the existence of `CacheLoader.from(func)` for lambda usage in the JavaDoc.  Currently, `TreeTraverser<T>` has a method `Iterable<T> children(T root)`.  Since for traversal, the returned `Iterable` is only used as a producer, the return type can be `Iterable<? extends T>` (and the `using()` static function can take a `Function<T, ? extends Iterable<? extends T>>`).

The use case is a tree model where at some level only leaf nodes exist, so there is for example a `List<LeafNode>`  (where `LeafNode` extends T).  With the current implementation, this has to be copied into a new list in order to compile (or using some ugly unsafe double-casting).
 @kevinb9n,
Personally I feel that users who test with such fine granularity have to accept the extra brittleness, certainly for an API that is in beta.  After all the fix is trivial (just change the variable type).  Of course, they could also just pass a Java8 method reference to TreeTraverser.using(), and then test the method directly. @jrtom I can imagine one would like to model some kind of classification in a type safe way. Let's take taxonomic hierarchy as an example (https://en.wikipedia.org/wiki/Taxonomic_rank).

```
public abstract class Rank {
	public Set<? extends Rank> getChildren() {
		return ImmutableSet.of();
	}
}

public class Life extends Rank {
	private Set<Domain> children;
	
	@Override
	public Set<Domain> getChildren() {
		return children;
	}
}

public class Domain extends Rank {
	// private Set<Kingdom> children;
	// and so on...
}

// ... and on...
```

If PECS was applied, you could easily traverse entire `Life tree` (tree of life) by using `TreeTraverser.<Rank>using(Rank::getChildren).preOrderTraversal(tree)`. Now it's impossible. BTW, no casting/copying involved.

Another example, this time from real... life: Country / State / ... / City / Street (this hierarchy is locale-dependent, so I can't translate 1:1).

The point is, sometimes you really know what kind/class of children you can expect/return and where.

I hope that this post explains at least a little. Indeed, my uses cases were along the lines of the example that @perceptron8 has shown.  Another possibility (besides having the wildcard in the superclass's return type for `getChildren()`) is that the function to map parent to children uses `instanceof` and a (clean, safe) cast to distinguish between different types, some of which may return a specific type of children.

Regarding the use of `Set` vs `Iterable`: the fact that one needs to copy the children in case the model doesn't return a `Set` is one thing that worries me a bit.  The fact that one will need to copy them specifically into a `LinkedHashSet` (or similar `Set` implementation) in order to preserve the iteration order of the model, is another thing.  Uses cases where the order is important: DOM traversal, UI component hierarchy, ... I would like to argue against using `Set` as return type in a `TreeTraverser` replacement. We use it for abstract syntax trees, and if given something like `a + a`, we certainly expect it to visit `a` twice.

Btw., our abstract syntax trees are another example where `<? extends T>` would be useful. Ours looks like this:
```
class ASTNode {
  List<? extends ASTNode> children();
}
class Expression extends ASTNode {
  List<? extends Expression> children();
}
// many more subclasses of ASTNode and Expression...
```
Currently we use several of the ugly unchecked casts to solve this. @HermanBovens I believe Traverser is already included in the latest release, [23.2](https://github.com/google/guava/releases/tag/v23.2), under `com.google.common.graph.Traverser`. @jbduncan I just noticed this so had deleted my comment, but thanks anyway. @HermanBovens Okay, thanks for letting me know. For the future, it's often best not to delete comments outright, as it leaves conversations disjointed. When I personally do it or have seen others do it, I find it's more helpful to just leave an edit explaining why the comment is no longer applicable. :)  Everytime I wanted to use `StandardSystemProperty`, it was because I was in a testing context, to render the the call to `System.getProperty(String)` abstract. The only reason I see any use to `StandardSystemProperty` is to avoid using hardcoded keys, plus a cherry-on-top access to the real value.

However, when it comes to testing, I was actually stuck with the real value of `System.getProperty(String)` (because that's what `StandardSystemProperty.value()` provides) and had to use an external framework such as [System Rules](http://stefanbirkner.github.io/system-rules/) to change the real values. I couldn't simply "mock" them.

So I never use this enum because it's either too much or too few.

I would suggest to replace `StandardSystemProperty` with an injectable, mockable layer, a bit like what exists with `Stopwatch` and `Ticker`.

My suggested approach is the following:

    public class SystemProperties {
      private static SystemProperties defaultInstance = new SystemProperties(System::getProperty);
      public static SystemProperties getInstance() { return defaultInstance; }
      public static SystemProperties getInstance(Function<String,String> mapper) { return new SystemProperties(mapper); }

      private SystemProperties(Function<String,String> mapper) { this.mapper = mapper; }
      public Optional<String> get(String key) { return Optional.ofNullable(mapper.apply(key)); }
      private String getRequired(String key) {
        String value = mapper.apply(key);
        if (value == null) { throw new RuntimeException("Expected property to exist: " + key); }
        return value;
      }

      public String fileSeparator() { return getRequired("file.separator"); }
      public String javaClassPath() { return getRequired("java.class.path"); }
      ... // All of the properties accessed through appropriately named methods.
    }

I see several advantages to this:

1. The system properties are not hardcoded by the final user (it's already the case with the current enum)
2. The properties accessor becomes injectable (it's not the case with the current enum)
3. The properties accessor isn't hard to mock: just use an existing function. (it's not the case with the current enum)
4. Access to non-standard system properties is also normalized. (it's not the case with the current enum)
5. The properties are accessed by a method to easily change under the hood (it's already the case with the current enum)

--------

The current enum and this suggestion could even live together. If we even add an interface `SystemProperty`, so that custom properties could live with standard ones (and retrofit `StandardSystemProperty` to implement that interface), we could imagine replace the method `getProperty(String)` in the above suggestion with `getProperty(SystemProperty)`.

The usage could then become:

    final SystemProperty CUSTOM_PROPERTY = SystemProperties.define("custom.property");
    @Inject SystemProperties systemProperties;
    ...
    systemProperties.get(CUSTOM_PROPERTY);

But this is already going to the next step.

-----

I could create this class and suggest a PR, but I'd like to have advice before starting it.  The following code snippet fails with IllegalStateException:
```java
Stream<Integer> stream = Arrays.asList(1).stream();
Stream<Integer> stream2 = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8).stream();
Streams.concat(stream, stream2).parallel().toArray();
```
Stack trace:
```
Exception in thread "main" java.lang.IllegalStateException: Accept exceeded fixed size of 5
	at java.util.stream.Nodes$FixedNodeBuilder.accept(Nodes.java:1224)
	at java.util.Spliterators$ArraySpliterator.forEachRemaining(Spliterators.java:948)
	at com.google.common.collect.CollectSpliterators$1FlatMapSpliterator.lambda$forEachRemaining$1(CollectSpliterators.java:246)
	at java.util.Spliterators$ArraySpliterator.forEachRemaining(Spliterators.java:948)
	at com.google.common.collect.CollectSpliterators$1FlatMapSpliterator.forEachRemaining(CollectSpliterators.java:246)
	at java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:481)
	at java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:471)
	at java.util.stream.Nodes$CollectorTask.doLeaf(Nodes.java:2183)
	at java.util.stream.Nodes$CollectorTask.doLeaf(Nodes.java:2149)
	at java.util.stream.AbstractTask.compute(AbstractTask.java:316)
	at java.util.concurrent.CountedCompleter.exec(CountedCompleter.java:731)
	at java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:289)
	at java.util.concurrent.ForkJoinTask.doInvoke(ForkJoinTask.java:401)
	at java.util.concurrent.ForkJoinTask.invoke(ForkJoinTask.java:734)
	at java.util.stream.Nodes.collect(Nodes.java:328)
	at java.util.stream.ReferencePipeline.evaluateToNode(ReferencePipeline.java:109)
	at java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:540)
	at java.util.stream.AbstractPipeline.evaluateToArrayNode(AbstractPipeline.java:260)
	at java.util.stream.ReferencePipeline.toArray(ReferencePipeline.java:438)
	at java.util.stream.ReferencePipeline.toArray(ReferencePipeline.java:444)
	at org.dive.java.Example.main(Example.java:15)
```

Everything is fine if `Streams.concat` is changed to `Stream.concat`  I met a case in using GuavaCache.

I Create GuavaCache like this:

Cache<String, Object> cache = CacheBuilder.newBuilder()
        .maximumSize(guavaCache.size())
        .expireAfterWrite(600, TimeUnit.SECONDS)
        .build();

When use this cache, I have several cache nesting, a method with cache call another method with cache, then when I want to invalidate the cache manually.
cache.cleanUp() doesn't work, and cache.invalidateAll() is ok.

Can someone provide an explanation?
Thanks. https://github.com/google/guava/wiki/CachesExplained#when-does-cleanup-happen

By the document，I thought the cleanUp() method can  eliminate entries, my understanding is wrong? Yes I think you're right @pumadong, but I think the document also implies that `cleanUp()` can only eliminate those entries which have expired (that is, those which have existed for 600 seconds or longer since the cache was last written to).

AFAICT from the javadocs, `cleanUp()` only does "maintenance", which may include removing expired entries if the cache thinks it is necessary to do so. So by my understanding, if it did anything else (like removing non-expired entries) then that would count as errorneous behaviour.

Hope this helps.  After serializing / deserializing Absent instances won't be the same (e.g. in an Apache Spark context with Kryo serialization).

Therefore the implementation below contains a bug. Why not just check if the two instances have the same class definition?

```
@Override public boolean equals(@Nullable Object object) {
  return object == this;
}
``` To bad you cannot make absent an enum...

Kryo does not use `readResolve` or `writeReplace`. That requires custom code to when configuring, e.g. by changing the default serializer to cache and honor those methods. I'm not sure about others, like FST. Absent extends Optional, so it can't extend Enum. For custom serialization frameworks, most users will expect that they will need to provide custom serializers. Beyond the basics, recommending that users implement their own or use a [package](https://github.com/magro/kryo-serializers) is all that you'd have to do. I can add a custom serializer, no worry at all. But as `Present` serialization works I expected `Absent` serialization to work also. @kevinb9n I'm sorry I don't understand your latest comment, what's the tool you're talking about? @lowasser I understand and totally agree, thank you.  I've been working on a project that centres around DAGs. I was very surprised to find cycles cropping up, so I tracked the issue down to Graphs.transitiveClosure.

I did a bit of reading (Wikipedia mostly) to see if this was expected behaviour. However, everything I saw pointed towards self-cycles not being a requirement of a transitive closure. I found [two](https://en.wikipedia.org/wiki/File:Transitive-closure.svg) [different](https://en.wikipedia.org/wiki/File:Transitive_Closure.svg) images on Wikipedia that show a closure with no self-cycle, The description on the [Transitive Closure](https://en.wikipedia.org/wiki/Transitive_closure) wiki page itself uses the example that nodes are airports and edges are flights, and the transitive closure is the graph of everything reachable from a node in **one or more hops**.

Then, I thought to actually check the documentation more thoroughly. It looks like this is intended behaviour, but should this behaviour maybe be changed? (Maybe a flag parameter that can be passed to disable self-cycles)
If not, maybe the documentation could make this a little clearer, since the Guava notion of the transitive closure is slightly different from the usual definition (unless I've really misunderstood things) - reachability elsewhere is defined as within 1 or more hops, but in Guava it is 0 or more.

There's a one-line workaround at least (`graph.nodes().forEach(n -> graph.removeEdge(n, n));`), hopefully that doesn't fall afoul of any concurrent modification rules. I think requiring the user to specify whether they want self-loops or not is best, as it would be more explicit and help to prevent surprises.

Requiring a `GraphBuilder` rather than a boolean parameter is a cool idea, but I think it may be too verbose in practice. How about an enum class like the following, which would provide more context than just a boolean param?

```java
public enum class SelfLoops {
  ALLOW, DISALLOW
}
```  Sample code [provided](https://google.github.io/guava/releases/snapshot/api/docs/com/google/common/base/Stopwatch.html) states to use the following code:
```java
 Stopwatch.createStarted(
      new Ticker() {
        public long read() {
          return android.os.SystemClock.elapsedRealtime();
        }
      });
```
However Ticker's "read" function is supposed to return nanoseconds.  Suggested change:
```java
 Stopwatch.createStarted(
      new Ticker() {
        public long read() {
          return android.os.SystemClock.elapsedRealtimeNanos();
        }
      });
```
Without this change all my times where in μs when logging using:
```
log.info("time: " + stopwatch);
```  It's all grown up.  I am not entirely sure about this, but shouldn't ForwardingCollection also forward calls to spliterator()?

The JavaDoc has a default method method warning that states:

> This class does not forward calls to default methods. Instead, it inherits their default implementations. When those implementations invoke methods, they invoke methods on the ForwardingCollection. 

While this may be true, I think spliterator() could be an exception. Let's assume I want a ForwardingList to delegate its calls to an ArrayList. An ArrayList is easily splittable and overrides spliterator() to use its efficient implementation of Spliterator.

In this case, when using a ForwardingList and not overriding spliterator() manually, the default spliterator() implementation of the List interface will be used, which is a slow iterator-based implementation.

What do you think? Am I overlooking something? Or is this by design? Thanks, that's a good explanation!   From an API I have a com.google.common.base.Optional object i.e. of the guava library and I am running my project against Java 8 version. Now, if I use transform(Optional.transform) method and use Java 8 syntax of method reference to implement a Function in transform method, it throws the error shown below.

### **Example code -**

```
package guava.optional;

import com.google.common.base.Function;
import com.google.common.base.Optional;

public class MethodReferenceIssue {

    public static void main(String[] args) {
        System.out.println(getValue());
    }
    static Optional<Long> getValue(){
        final Optional<Test> testOptional = Optional.of(new Test(2L));
        return testOptional.transform(Test::getCode);
    }
}

class Test {
    private long code;

    public Test(long code) {
        this.code = code;
    }

    public Long getCode() {
        return code;
    }
}
```
```
Error

error: method transform in class Optional<T> cannot be applied to given types;
[ERROR] ode
[ERROR] reason: cannot infer type-variable(s) V
[ERROR] (argument mismatch; invalid method reference
[ERROR] method getCode in class Test cannot be applied to given types
[ERROR] required: no arguments
[ERROR] found: ? super Test 
[ERROR] reason: actual and formal argument lists differ in length)
[ERROR] where V,T are type-variables:
[ERROR] V extends Object declared in method <V>transform(Function<? super T,V>)
[ERROR] T extends Object declared in class Optional
```

Now I have solved this for now by creating a variable of type Function and then pass it as a parameter then it works fine.

### **Example code -**

```
package guava.optional;

import com.google.common.base.Function;
import com.google.common.base.Optional;


public class MethodReferenceIssue {

    public static void main(String[] args) {
        System.out.println(getValue());
    }
    static Optional<Long> getValue(){
        final Optional<Test> testOptional = Optional.of(new Test(2L));
        Function<Test, Long> testOpt = Test::getCode;
        return testOptional.transform(testOpt);
    }
}

class Test {
    private long code;

    public Test(long code) {
        this.code = code;
    }

    public Long getCode() {
        return code;
    }
}
```

**NOTE :-** this occurs with Guava version 21.0 and it works fine with guava version 20.0 But there is a change in Function interface and that's why there is reference issue while using the method reference. Please try to run the code sample provided here.
it is not because of transform it is because com.google.common.base.Function extends java.util.function.Function. @cpovirk - I have mentioned the exact code sample and I am facing the issue in the same while running it(in this sample only). Yes, it will compile as I am also able to compile it, but it will give the mentioned error if you run the `mvn install` command or try to execute the code.
Please try executing the main and I hope you will get the same error. @cpovirk - I have faced the similar issue in `public static <F, T> Iterable<T> transform(
      final Iterable<F> fromIterable, final Function<? super F, ? extends T> function) ` in `com.google.common.collect.Iterables.java ` as I can not use Java 8 syntax for method reference as a second parameter.  合并官方版本 Hi @monkeychen, was this empty Pull Request intentional?

Did you perhaps mean to pull `google/guava:master` into your own Guava fork? :)  ```
List<String> lst = ImmutableList.of("str");
Streams.mapWithIndex(lst.stream(), (c, i) -> {
    System.out.println(c);
    return c;
}).collect(toImmutableList());
```
its print: str
that's ok

but
```
List<String> lst = ImmutableList.of("str");
Streams.mapWithIndex(lst.stream(), (c, i) -> {
    System.out.println(c);
    return c;
});
```
this print nothing.


why that, is this a bug? or just i am a stupid😂 ```
        Map<String, String> map = Maps.newHashMap();
        List<String> lst = ImmutableList.of("str");
        Streams.mapWithIndex(lst.stream(), (c, i) -> {
            map.put(c, c);
            return c;
        });
        System.out.println(map);
```
expect get  {"str", "str"} but {}  very helpful for me to understand stream.
thank you!  I can currently write:

```
    int max = Ints.max();
```

And I will get an exception at runtime. There is a way to enforce at least one argument while keeping the existing version for back compat if they have supplied an actual array.

The existing one changes signature to `public static int min(int[] array)`. Then a new overload would be coded as so, so that `Ints.max()` yields a compile time error.

    /**
    * Returns the greatest value present in {@code head}, {@code tail}.
    *
    * @param head an int {@code int} value
    * @param tail an array of {@code int} values
    * @return the value present in {@code tail} or {@code head} that is greater than or equal to every other value
    *     in the parameters
    */
    public static int max(int head, int... tail) {
      int max = head;
      for (int i = 1; i < tail.length; i++) {
        if (tail[i] > max) {
          max = tail[i];
        }
      }
      return max;
    } Yep the only breaking cases are ones that are currently runtime exceptions anyway.

I suppose the signature I should have proposed would be `max(int a, int b, int... others)` because any `max` etc with less than 2 args makes no sense. Custom linting could also catch such cases though.  # Our use-case
```
ListMultimap<String, Foo> foosByName = ...;
// First, Foos get added to the map. Then:
List<Foo> foos = foosByName.get("foo");
// this actually hands the object over to another thread which eventually sends it over the wire
output.send(foo);
...
// later
foosByName.removeAll("foo"); // internally calls clear() on the backing collection
```

...which throws this from another thread:
```
java.util.ConcurrentModificationException
    at java.util.ArrayList$Itr.checkForComodification(ArrayList.java:901)
    at java.util.ArrayList$Itr.next(ArrayList.java:851)
    at com.google.common.collect.AbstractMapBasedMultimap$WrappedCollection$WrappedIterator.next(AbstractMapBasedMultimap.java:486)
    ...
```

# Rationale
We're aggregating data into a `ListMultimap<String, Foo>`. Then, when the time is right and all data for a specific foo name has been collected, we want to send it out. This is done via handing the `List<Foo>` returned by `foosByName.get("foo")` to another thread which then _iterates_ over the list's contents and does the actual sending. While this is in progress, we can sometimes observe a `ConcurrentModificationException` being thrown because the original aggregator thread has called `foosByName.removeAll("foo")` in the meantime.

The original aggregator thread cannot instead call `List<Foo> foos = foosByName.remove("foo")` and then send the list out because its actually being sent out multiple times, to multiple destinations, upon multiple signals. But we're sure we're not mutating it in any way anymore.

# Expected behaviour
`foosByName.removeAll("foo")` should not call `clear()` on the underlying collection as it might have been handed out to someone else already. Is there any real-world reason for the call?

P.S. Obviously we changed our design as it was iffy at best. Still, the unexpected `clear()` seems to be unnecessary?  I want to count the number of elements in bloomfilter.
Here is the solution discussed in stackoverflow:

http://cstheory.stackexchange.com/questions/10023/computing-the-approximate-population-of-a-bloom-filter

and here is my implementation.    
public int getPopulationApprox() {
        double proportionOf0s = 1 - bits.bitCount / (double)bitSize() ;
        return Convert.toInteger(Math.log(proportionOf0s) / (numHashFunctions * Math.log(1 - 1.0 / bitSize())) ) ;
    }

Could any one take a look? Should I push a change? looks different
http://cstheory.stackexchange.com/questions/10023/computing-the-approximate-population-of-a-bloom-filter  "compute.amazonaws.com" is not recognized as a public suffix.  "hasPublicSuffix" returns false for a few others as well: 

InternetDomainName{name=foobar.bid} has public suffix ? false
InternetDomainName{name=foobar.xyz} has public suffix ? false
InternetDomainName{name=foobar.loan} has public suffix ? false
InternetDomainName{name=foobar.win} has public suffix ? false

My understanding is if it ends in a suffix from PSL it should return true - is that correct ?

Thanks.  Currently, the `delegate` is put directly into the instance, violating Effective Java 2nd Edition, Item 76.  Previously, the BloomFilter wasn't thread-safe and required external locking to ensure safety. Now, it's thread-safe and lock-free through the use of atomics and compare-and-swap.

This PR introduces **no** API changes beyond an extra `@ThreadSafe` annotation on the BloomFilter class. It should also be entirely backwards (and forwards) compatible with the serialization format because that too isn't being changed. 

Please extend extra scrutiny to the `LockFreeBitArray.putAll()` method because it's not present in our internal fork of the BloomFilter class and has thus not gone through our integ tests or has seen prod (I wrote it for this PR).

Fixes #2748. >To strengthen your argument, you should probably add a benchmark to show the performance impact for reads and writes in a single threaded case. See Guava's Caliper benchmarks.

I have JMH benchmarks (see this email for [Caliper vs JMH](https://groups.google.com/forum/#!msg/mechanical-sympathy/m4opvy4xq3U/7lY8x8SvHgwJ)) set up for our internal fork which is largely the same except the serialization parts have been ripped out, other hash strategies have been added etc. Perf using the standard murmur3 strategy should be identical. 

I can update that and post numbers. It's not ideal, but it's the best I have without going through the massive hassle of supporting JMH benchmarks for guava (I wouldn't trust Caliper). @ben-manes 
OK, I'm doing benchmarks first for the suggestions you've made. [Here's my benchmark code](https://gist.github.com/Valloric/f57aa7726947250065dc1a878fc33888), for reference only.

Benchmark results I currently have:

```
NOTE: "Batch" means 10k puts, NOT one put!
NOTE: The units aren't the same across benchmarks; some use nanos, some micros.

Original PR

Benchmark                                                        Mode  Cnt      Score       Error  Units
LockFreeBloomFilterBenchmark.measureContainMultiThread           avgt    4    511.674 ±    17.661  ns/op
LockFreeBloomFilterBenchmark.measureContainSingleThread          avgt    4    490.260 ±     4.765  ns/op
LockFreeBloomFilterBenchmark.measurePutBatchRandomsMultiThread   avgt    4  15080.691 ± 11069.316  us/op
LockFreeBloomFilterBenchmark.measurePutBatchRandomsSingleThread  avgt    4  10408.925 ±   203.714  us/op
LockFreeBloomFilterBenchmark.measurePutSameSingle                avgt    4    624.769 ±    39.450  ns/op

Original PR + LongAdder

Benchmark                                                        Mode  Cnt      Score     Error  Units
LockFreeBloomFilterBenchmark.measureContainMultiThread           avgt    4    494.897 ±  21.302  ns/op
LockFreeBloomFilterBenchmark.measureContainSingleThread          avgt    4    489.003 ±  14.366  ns/op
LockFreeBloomFilterBenchmark.measurePutBatchRandomsMultiThread   avgt    4  12040.170 ± 312.177  us/op
LockFreeBloomFilterBenchmark.measurePutBatchRandomsSingleThread  avgt    4  10927.175 ± 381.793  us/op
LockFreeBloomFilterBenchmark.measurePutSameSingle                avgt    4    634.361 ±  75.430  ns/op
```

As expected, LongAdder helps in the multi-threaded Put scenario. So I'll make that change. I'll run a similar benchmark for the lambda change. @ben-manes 

And here are the benchmarks for the original code, without any lock-free stuff. Note that the benchmark names for the original code still have "lockfree" in them but the code is not actually lock-free.

```
NOTE: "Batch" means 10k puts, NOT one put!
NOTE: The units aren't the same across benchmarks; some use nanos, some micros.

Original PR + LongAdder

Benchmark                                                        Mode  Cnt      Score     Error  Units
LockFreeBloomFilterBenchmark.measureContainSingleThread          avgt    4    489.003 ±  14.366  ns/op
LockFreeBloomFilterBenchmark.measurePutBatchRandomsSingleThread  avgt    4  10927.175 ± 381.793  us/op
LockFreeBloomFilterBenchmark.measurePutSameSingle                avgt    4    634.361 ±  75.430  ns/op

Without PR (no atomics or locking, original code)

Benchmark                                                        Mode  Cnt      Score      Error  Units
LockFreeBloomFilterBenchmark.measureContainSingleThread          avgt    4    474.787 ±   10.863  ns/op
LockFreeBloomFilterBenchmark.measurePutBatchRandomsSingleThread  avgt    4   8958.676 ±   56.457  us/op
LockFreeBloomFilterBenchmark.measurePutSameSingle                avgt    4    624.619 ±   37.565  ns/op
```

As expected, the puts are slightly slower (about 20%) in the lock-free version. The read perf is the same because atomic reads are free on x86 (and x86-64). It's hard for me to imagine a realistic single-threaded use-case for a bloom filter; even then, since the read path is what almost always matters in a bloom filter and that sees no slowdown, I think a 20% hit on the single-threaded put path is acceptable.
 @lowasser Any thoughts on this PR so far? @lowasser @ben-manes The latest code addresses all issues that have been brought up so far.   @lowasser @ben-manes 

OK, benchmarks with the extra IF branch. Note that I'm including another set of benchmarks for the same code pairs, but the second set is with a much smaller bloom filter: 10k puts on a BF with 50k expected insertions vs the original 10k puts on a BF with 150M expected insertions. I added this to look at cases with more thread contention.

```
Original PR + LongAdder + no-lambda

Benchmark                                                        Mode  Cnt      Score     Error  Units
LockFreeBloomFilterBenchmark.measureContainMultiThread           avgt    4    487.889 ±  14.100  ns/op
LockFreeBloomFilterBenchmark.measureContainSingleThread          avgt    4    489.317 ±   4.928  ns/op
LockFreeBloomFilterBenchmark.measurePutBatchRandomsMultiThread   avgt    4  11804.317 ±  39.740  us/op
LockFreeBloomFilterBenchmark.measurePutBatchRandomsSingleThread  avgt    4  11673.301 ± 407.479  us/op
LockFreeBloomFilterBenchmark.measurePutSameSingle                avgt    4    618.878 ±  38.190  ns/op

Original PR + LongAdder + no-lambda + extra IF in retry loop

Benchmark                                                        Mode  Cnt      Score     Error  Units
LockFreeBloomFilterBenchmark.measureContainMultiThread           avgt    4    495.849 ±  72.557  ns/op
LockFreeBloomFilterBenchmark.measureContainSingleThread          avgt    4    490.722 ±   4.135  ns/op
LockFreeBloomFilterBenchmark.measurePutBatchRandomsMultiThread   avgt    4  11860.600 ± 142.482  us/op
LockFreeBloomFilterBenchmark.measurePutBatchRandomsSingleThread  avgt    4  11234.194 ± 257.156  us/op
LockFreeBloomFilterBenchmark.measurePutSameSingle                avgt    4    630.437 ±  51.002  ns/op

=== SMALLER BENCH BLOOM FILTER! ===

Original PR + LongAdder + no-lambda

Benchmark                                                        Mode  Cnt     Score     Error  Units
LockFreeBloomFilterBenchmark.measureContainMultiThread           avgt    4   523.716 ±  76.739  ns/op
LockFreeBloomFilterBenchmark.measureContainSingleThread          avgt    4   494.077 ±   6.449  ns/op
LockFreeBloomFilterBenchmark.measurePutBatchRandomsMultiThread   avgt    4  6541.044 ± 112.961  us/op
LockFreeBloomFilterBenchmark.measurePutBatchRandomsSingleThread  avgt    4  6318.562 ± 179.519  us/op
LockFreeBloomFilterBenchmark.measurePutSameSingle                avgt    4   616.819 ±   4.884  ns/op

Original PR + LongAdder + no-lambda + extra IF in retry loop

Benchmark                                                        Mode  Cnt     Score      Error  Units
LockFreeBloomFilterBenchmark.measureContainMultiThread           avgt    4   529.688 ±   78.308  ns/op
LockFreeBloomFilterBenchmark.measureContainSingleThread          avgt    4   501.248 ±    5.284  ns/op
LockFreeBloomFilterBenchmark.measurePutBatchRandomsMultiThread   avgt    4  6574.708 ± 1121.399  us/op
LockFreeBloomFilterBenchmark.measurePutBatchRandomsSingleThread  avgt    4  6241.094 ±  275.969  us/op
LockFreeBloomFilterBenchmark.measurePutSameSingle                avgt    4   618.840 ±   20.353  ns/op
```

The results are the same with and without the extra IF. Should I add it then or not? I'm leaning "no" because it doesn't seem to be paying off. Personally I'm fine with either. Also, the extra IF seems to be introducing extra variance in the multi-threaded runs, probably because of branch prediction failures.

It could also just be noise, but it's consistent across BF sizes. Note that you are using a uniform distribution. The `if` check would be helpful if the entry had already been added to avoid unnecessary CASes. A Zipf distribution ([example](https://github.com/ben-manes/caffeine/blob/master/caffeine/src/jmh/java/com/github/benmanes/caffeine/cache/GetPutBenchmark.java)) might show beneficial results. @ben-manes That's convincing enough for me. Perf is flat on a uniform distribution and the difference in variance is likely to be noise, and even if it isn't, it probably doesn't matter.

Added the IF. @ben-manes @lowasser 

More data:

```
Original PR + LongAdder + no-lambda + extra IF in retry loop

Benchmark                                                        Mode  Cnt     Score     Error  Units
LockFreeBloomFilterBenchmark.measureContainMultiThread           avgt    4   500.731 ±  68.968  ns/op
LockFreeBloomFilterBenchmark.measureContainSingleThread          avgt    4   490.522 ±   5.937  ns/op
LockFreeBloomFilterBenchmark.measurePutBatchRandomsMultiThread   avgt    4  6530.204 ± 114.009  us/op
LockFreeBloomFilterBenchmark.measurePutBatchRandomsSingleThread  avgt    4  6267.970 ± 176.621  us/op
LockFreeBloomFilterBenchmark.measurePutSameSingle                avgt    4   615.487 ±   9.207  ns/op
```

I did another run of the benchmark with the same smaller BF config and the large variance from the previous run went away. So it's noise, making the IF a safe pick. It's either better with a zipfian distribution, or no worse. Note that with the new IF in the retry loop, we can now remove this IF check:

```java
if ((oldValue & mask) == 0) {
  bitCount.increment();
  return true;
}
```

We just always run the body now. @lowasser @ben-manes 

Code updated to address all issues raised so far.  > Note that my approval carries no weight towards integration.

I know, but it carries weight with me in that I'm more confident this is working well. :) @lowasser Friendly ping. :) @lowasser One more ping... > LGTM, I'll try to get this merged internally.

Thank you! :) Resolved merge conflicts recently introduced through changes on `master`. @lowasser Any updates? It's been 2 weeks since this PR reached a stable state... @lowasser Can I help in any way? If I can make your life easier by changing this PR, I'd be happy to do so. @lowasser @artityod Any updates? This has been ready to merge for a month and a half now... @lowasser Thanks for the update! Glad to see this hasn't fallen by the wayside. :)  Hi 
Please reopen this issue.
https://github.com/google/guava/issues/2757.

Given further updates on same. 
  Hi,

after adding `compile 'com.google.guava:guava:21.0'` to my Android project Gradle's dependencies, I got this build error:

> 
> Information:Gradle tasks [:app:assembleBrandAFastBuildDebug]
> Error:Lambda coming from jar file need their interfaces on the classpath to be compiled, unknown interfaces are java.util.function.Function
> Error:Lambda coming from jar file need their interfaces on the classpath to be compiled, unknown interfaces are java.util.function.Consumer
> Error:Lambda coming from jar file need their interfaces on the classpath to be compiled, unknown interfaces are java.util.function.BiConsumer
> Error:Lambda coming from jar file need their interfaces on the classpath to be compiled, unknown interfaces are java.util.function.Supplier
> Error:Lambda coming from jar file need their interfaces on the classpath to be compiled, unknown interfaces are java.util.function.BiConsumer
> Error:Lambda coming from jar file need their interfaces on the classpath to be compiled, unknown interfaces are java.util.function.Supplier
> Error:Lambda coming from jar file need their interfaces on the classpath to be compiled, unknown interfaces are java.util.function.BinaryOperator
> Error:Lambda coming from jar file need their interfaces on the classpath to be compiled, unknown interfaces are java.util.function.BiConsumer
> Error:Lambda coming from jar file need their interfaces on the classpath to be compiled, unknown interfaces are java.util.function.BinaryOperator
>...
> Error:Lambda coming from jar file need their interfaces on the classpath to be compiled, unknown interfaces are java.util.function.Consumer
> Error:Lambda coming from jar file need their interfaces on the classpath to be compiled, unknown interfaces are java.util.function.Consumer
> Error:Lambda coming from jar file need their interfaces on the classpath to be compiled, unknown interfaces are java.util.function.BiPredicate
> Error:Lambda coming from jar file need their interfaces on the classpath to be compiled, unknown interfaces are java.util.function.Consumer
> Error:Lambda coming from jar file need their interfaces on the classpath to be compiled, unknown interfaces are java.util.function.Function
> Error:Lambda coming from jar file need their interfaces on the classpath to be compiled, unknown interfaces are java.util.function.IntFunction
> Error:Default method void addAll(java.lang.Iterable ranges) not supported in Android API level less than 24
> Error:Default method boolean enclosesAll(java.lang.Iterable other) not supported in Android API level less than 24
> Error:Default method void removeAll(java.lang.Iterable ranges) not supported in Android API level less than 24
> Error:Default method boolean test(java.lang.Object input) not supported in Android API level less than 24
> Error:Default method void forEachEntry(java.util.function.ObjIntConsumer action) not supported in Android API level less than 24
> Error:Default method void forEach(java.util.function.Consumer action) not supported in Android API level less than 24
> Error:Default method java.util.Spliterator spliterator() not supported in Android API level less than 24
> Error:Static method void com_google_common_collect_Multiset_lambda$forEach$1(java.util.function.Consumer action, com.google.common.collect.Multiset$Entry entry) not supported in Android API level less than 24
> Error:Static method void com_google_common_collect_Multiset_lambda$forEachEntry$0(java.util.function.ObjIntConsumer action, com.google.common.collect.Multiset$Entry entry) not supported in Android API level less than 24
> Error:Default method void forEach(java.util.function.BiConsumer action) not supported in Android API level less than 24
> Error:Static method void com_google_common_collect_Multimap_lambda$forEach$0(java.util.function.BiConsumer action, java.util.Map$Entry entry) not supported in Android API level less than 24
> Error:Execution failed for task ':app:transformClassesWithPreJackPackagedLibrariesForBrandAFastBuildDebug'.
> > com.android.build.api.transform.TransformException: com.android.builder.core.JackToolchain$ToolchainException: Jack compilation exception
> Information:BUILD FAILED
> Information:Total time: 1 mins 15.703 secs
> Information:190 errors
> Information:0 warnings
> Information:See complete output in console

I'm already using:

```
android {
    compileSdkVersion 25
    buildToolsVersion "25.0.2"
...
 jackOptions {
            enabled true
        }

compileOptions {
        sourceCompatibility JavaVersion.VERSION_1_8
        targetCompatibility JavaVersion.VERSION_1_8
    }

    buildTypes {
        release {
            minifyEnabled false
            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
        }
    }
```

Gradle's project configuration snippet:
         
         classpath 'com.android.tools.build:gradle:2.5.0-alpha-preview-01'
         classpath 'me.tatarka:gradle-retrolambda:3.2.5'

In `gradle-wrapper.properties` I have:

         distributionUrl=https://services.gradle.org/distributions-snapshots/gradle-3.5-20170213202653+0000-all.zip

Could you provide any resolution to this problem? I've already found a temporary solution to this problem

After downgrading library version from:

    compile 'com.google.guava:guava:21.0'

to

    compile 'com.google.guava:guava:20.0'


build successfully completes and app runs fine.
 @kevinb9n thanks for response.  For this time, previous version Guava in version 20 is enough.

If I would find another workaround besides downgrading lib version, I would let you know.

Hope that version 22 would have this problem fixed ;-)  
 @cpovirk could you provide any solution other than downgrading Guava version as you closed unresolved issue? Just wondering. Java 8 support: compile 'com.google.guava:guava:22.0-android'  Now that Guava Supplier extends Java Supplier the Suppliers utility methods (e.g. `Suppliers#memoize(Supplier)` should accept a Java Supplier instead of a Guava one. From Guava 21 onwards, this shouldn't be a breaking change, because a Guava Supplier is a Java Supplier.

I'd be willing to submit a PR for this change if this seems acceptable. > Is it possible that breaking binary compatibility isn't a real problem anymore in the modern world? I admit I'm out of touch with that and would love some edification.

@kevinb9n 

The binary compatibility of Guava is greater and greater problem because Guava has becomes immensely popular and we're stuck with long-dead dependencies that rely on unsupported versions of Guava. So we're stuck with a dependency we need, but can't rewrite ourselves, without being given time.

What we do to fix it internally is grab a copy of the source code of the project and compile it against a more recent version of Guava (and fix its Guava usage if Guava changed its API in between).

Though this might be frightening, the process is usually easy. It's just annoyingly long sometimes, especially if the build is non-standard (meaning, not Maven or Gradle) or if the usage of Guava is intensive. Admittedly, I hadn't considered the scope of the backcompat issues here. 

One alternative: a new utility class that duplicates the methods but changes signatures to accept and return Java Supplier instead. @kevinb9n Actually I was trying to explain how we do outside of the "everything-is-up-to-date-at-all-times" world ;)  I am getting following exception while referencing guava latest 21.0 jar.
java.lang.NoClassDefFoundError: Could not initialize class com.google.common.io.BaseEncoding 

        return BaseEncoding.base64Url().omitPadding().encode(buffer); // or base32()

recently upgraded my local jar of guava from 15.0 to 21.0; but facing issues with encoding.

Please do the needful.

 Maven build is fine for this; and I can see jar is update to 21.
Issue I am getting at runtime on this. Please find the complete logs for this issue.
Code Snipet causing problem is:
    String generateRandomPassword() {
        final byte[] buffer = new byte[24];
        random.nextBytes(buffer);
        return BaseEncoding.base64Url().omitPadding().encode(buffer); // or base32()
    }

**Log traces:**

[2017-03-09T08:45:17.389+0000] [glassfish 4.1] [SEVERE] [] [org.glassfish.jersey.server.ServerRuntime$Responder] [tid: _ThreadID=41 _ThreadName=http-listener-1(1)] [timeMillis: 1489049117389] [levelValue: 1000] [[
  An exception has been thrown from an exception mapper class com.oracle.acs.gateway.services.mapper.GeneralExceptionMapper.
java.lang.NoClassDefFoundError: Could not initialize class com.google.common.io.BaseEncoding
	at com.oracle.acs.gateway.exception.GeneralExceptionMapperImpl.generateRandomErrorCode(GeneralExceptionMapperImpl.java:134)
	at com.oracle.acs.gateway.exception.GeneralExceptionMapperImpl.handleGeneralException(GeneralExceptionMapperImpl.java:85)

......
..
..


Caused by: javax.ejb.TransactionRolledbackLocalException: Exception thrown from bean: java.lang.NoSuchMethodError: com.google.common.base.CharMatcher.ascii()Lcom/google/common/base/CharMatcher;
	at com.sun.ejb.containers.EJBContainerTransactionManager.checkExceptionClientTx(EJBContainerTransactionManager.java:665)
	at com.sun.ejb.containers.EJBContainerTransactionManager.postInvokeTx(EJBContainerTransactionManager.java:507)
	at com.sun.ejb.containers.BaseContainer.postInvokeTx(BaseContainer.java:4566)
	at com.sun.ejb.containers.BaseContainer.postInvoke(BaseContainer.java:2074)
	... 108 more
Caused by: java.lang.NoSuchMethodError: com.google.common.base.CharMatcher.ascii()Lcom/google/common/base/CharMatcher;
	at com.google.common.io.BaseEncoding$Alphabet.<init>(BaseEncoding.java:452)
	at com.google.common.io.BaseEncoding$Base64Encoding.<init>(BaseEncoding.java:891)
	at com.google.common.io.BaseEncoding.<clinit>(BaseEncoding.java:316)
 Looks like repetitive of issue: https://github.com/google/guava/issues/719 
but should have been corrected in latest release. 

Following is the outcome of mvn dependacy:tree
Not seen any google-common references ...

 +- commons-beanutils:commons-beanutils:jar:1.9.3:compile
 |  \- commons-collections:commons-collections:jar:3.2.1:compile
 
 
 +- org.apache.poi:poi:jar:3.16-beta1:compile
 |  \- org.apache.commons:commons-collections4:jar:4.1:compile

 
 +- com.google.guava:guava:jar:21.0:compile

 
 +- org.glassfish.jersey.containers:jersey-container-servlet:jar:2.26-b01:provided
 |  +- org.glassfish.jersey.containers:jersey-container-servlet-core:jar:2.26-b01:provided
 |  +- org.glassfish.jersey.core:jersey-common:jar:2.26-b01:provided
 |  |  +- org.glassfish.jersey.bundles.repackaged:jersey-guava:jar:2.26-b01:provided
 |  |  \- org.glassfish.hk2:osgi-resource-locator:jar:1.0.1:provided
 |  \- javax.ws.rs:javax.ws.rs-api:jar:2.1-m02:provided

  I notice the `org.sonatype.oss-parents` is deprecated. Is there any action planed for it?

> Sonatype OSS Parent poms - oss-parents
> DEPRECATION WARNING:
> This project is no longer active or supported. We suggest to manage parent POM files for your own organization as needed. The POM files from this project no longer work with latest Maven and/or Java versions. I see it from https://github.com/sonatype/oss-parents  From a ten year old paper, there's a [function that approximates the number of items in a bloom filter](https://en.wikipedia.org/wiki/Bloom_filter#Approximating_the_number_of_items_in_a_Bloom_filter). 

All it needs is Bloomfilter's `bits.bitSize()`, `bits.bitCount()`, and `numHashFunctions`. I played around with it and found it to be remarkably accurate for large and small, empty and full filters alike. I was seeing accuracy between 2 and 5 9's based on the size of the filters.

I'd be happy to implement it (properly) if needed. I think there is value in this addition, and since it's just a calculation with some internal values, I don't see any major downsides. I suppose there isn't a way to quantify the accuracy of the results, but between Javadoc and a descriptive method name (like in "mightContain") the approximate nature of the result could be clear. Just general data introspection purposes. If committing non-unique elements, it lets you use the same data structure in place of a HyperLogLog for cardinality estimates. This is especially useful if you're using bloom filters to represent subsets of data and combining them - you can get very fast union cardinality estimates in O(1) with a small memory footprint.

It's also just a nice sanity check in general. "yeah, that number looks about right". If you get a chance, play with the snippet I posted - I was really impressed at the accuracy with various sizes and fill percents. Just FYI - I haven't abandoned this, I'm proceeding through the internal process to do this under the corporate CLA. @kluever I've been added to the Amazon CCLA under my email beutlert@amazon.com is this same?

http://cstheory.stackexchange.com/questions/10023/computing-the-approximate-population-of-a-bloom-filter It is the same. Interesting that the conversation there happened 5-9 years after it was published in a paper... but the derived formula is the same anyhow.

By the way, still waiting to get a green light from @kluever on this. I'd argue that the counter suffers from any of the same drawbacks as the formula above - it's still susceptible to collisions, so it's still an approximation. Users needing perfect precision for cardinality shouldn't be using a BloomFilter anyway. From an implementation standpoint, this requires changes to pretty much everything, including serialization (potentially breaking backward compatibility with serialized filters) and would require a change to BitArray::putAll method signature. I would be very surprised if the differences in approximations were anything but negligible. Oh! Sorry about that. I agree that works for most users, although the limitation also extends to situations where the filters are being deserialized. Being a probabilistic data structure, the approximate count is intrinsic to the object the same way mightContain() is, so this would allow the object to be passed around without having to pair it with a count. Glad to see this added - thank you!

Bit of rambling ahead...

For fun @kevinb9n regarding the `ln(1 - k/m)` => `-k/m` substitution - it's just stopping after the first term of the Taylor series expansion for ln. Since `k/m` is constrained to being so close to 0, it's still a very accurate approximation.

If calculating `k` hashes and `m` bits from the given optimal formulas using `p` fpp and `n` expected insertions, the accuracy of the first term Taylor approximation varies almost completely on `n`. At n=100, it's already 99.65% accurate. At n=1000, it's 99.965%, and we get an extra 9 for every order of magnitude n grows. Pretty nifty.  Feature request: a Graphs.reachableNodes() method that has multiple starting points.
It should be more efficient than calling the existing reachableNodes() multiple times. Do you want me to send a CL?  Upgrading Guava to v21 with GWT 2.8, i'm getting the following errors on ImmutableMap recent evolutions while compiling GWT project :

```
[ERROR] Errors in 'com/google/common/collect/super/com/google/common/collect/ImmutableMap.java'
[INFO]       [ERROR] Line 91: Type mismatch: cannot convert from Collector<capture#35-of ? super T & capture#37-of ? super T,capture#39-of ?,Object> to Collector<T,?,ImmutableMap<K,V>>
[INFO]    Tracing compile failure path for type 'com.google.common.collect.ImmutableMap'
[INFO]       [ERROR] Errors in 'com/google/common/collect/super/com/google/common/collect/ImmutableMap.java'
[INFO]          [ERROR] Line 91: Type mismatch: cannot convert from Collector<capture#35-of ? super T & capture#37-of ? super T,capture#39-of ?,Object> to Collector<T,?,ImmutableMap<K,V>>
[INFO]       [ERROR] Errors in 'com/google/common/collect/ImmutableSetMultimap.java'
[INFO]          [ERROR] com.google.common.collect.ImmutableMap cannot be resolved to a type
[INFO]       [ERROR] Errors in 'com/google/common/collect/ImmutableMultimap.java'
[INFO]          [ERROR] com.google.common.collect.ImmutableMap cannot be resolved to a type
[INFO]       [ERROR] Errors in 'com/google/common/collect/AbstractMultimap.java'
[INFO]          [ERROR] com.google.common.collect.Multimaps.Entries cannot be resolved to a type
[INFO] ------------------------------------------------------------------------
[INFO] BUILD FAILURE
[INFO] ------------------------------------------------------------------------
```

Any ideas to solve this ?  Stopwatch is missing a getter for the start time.
If you're happy with the API change, I can submit a PR.

Cheers Right. Better put, it's missing a feature to get the elapsed time since it was started. Please correct me if I'm wrong @alb-i986, but if starting time is something you're after, then I think you might be better served by something like or based on Java 8's new date library or joda-time.

After all, [if the amount of trouble programmers go through just to program timezones](https://www.youtube.com/watch?v=-5wpm-gesOY) are any indication, then I would suspect that finding the time elapsed between a "starting point" and some point in the future or past (which I assume is what you want to do) is probably harder than one would think. :/ Sorry, my bad. I now understand that `elapsed(Timeunit)` returns the elapsed time since the stopwatch was started.
So what I'm missing is a method (let's call it "partialElapsed") to get the elapsed time between now and the previous call to elapsed (or since started), so that I can write:

    sw.start();
    do1();
    log.debug("do1 took " + sw.partialElapsed(MILLIS) + "ms);
    ..
    doN();
    log.debug("doN took " + sw.partialElapsed(MILLIS) + "ms);
    log.debug("The whole process took " + sw.elapsed(MILLIS) + "ms);

For example, the stopwatch included in the Google app Clock on Android 6 supports this.

PS: @jbduncan Thanks for the link, funny and useful video :) @kevinb9n that's not even necessary, you can achieve this result fairly easily using the existing Stopwatch API.

```java
Stopwatch stopwatch = Stopwatch.createStarted();

benchmark();

System.out.printf("benchmark() took %d ms.%n", stopwatch.elapsed(TimeUnit.MILLISECONDS));
stopwatch.reset().start();

benchmark();

System.out.printf("benchmark() took %d ms.%n", stopwatch.elapsed(TimeUnit.MILLISECONDS));
stopwatch.reset().start();

...
```  @cpovirk Did you mean to close this or add it to the `22.0` milestone? I _just_ realised that this issue had an associated fix commit. Apologies!  While AbstractTable defines a method valuesSpliterator(), that method does not get called. Instead, the default implementation from AbstractCollection is used.  As part of my work at LinkedIn, I've created a lock-free version of Guava's `BloomFilter` class (technically, a lock-free version of the `BitArray` class inside `BloomFilterStrategies`). **Would Guava upstream be interested in seeing a PR for this change?** The PR would naturally come with extra tests.

### Short overview

Our use-case involves a hundred+ threads doing a total of millions of read QPS on the bloom filter with ~20 QPS of writes. So I wrapped the bloom filter with a read-write lock. This wasn't performant enough though on the read side; after lots of benchmarks and analysis, the root cause was the write lock; even removing the read locks (which of course introduces race conditions, but was done for the sake of a benchmark) made no difference for read path perf... but removing both read _and_ write locks improved read perf greatly (but it would of course be terribly unsafe). My guess is that it was exclusive access to the cache line that stored the lock data that caused excessive CPU cache bus traffic, but I don't have data to back that up.

Replacing the internals of the BitArray so that it used an `AtomicLongArray` for the `data` member along with compare-and-swap usage (plus an `AtomicLong` for the `bitcount` member) improved perf substantially.

This is all on a modern server CPU with 24 logical CPUs (12 cores) + HotSpot Java 8 JVM. Great! I'll send a PR. It might take a bit because:

1. I have a lot of stuff on my plate right now. :)
2. I need to sort out the CLA business.
3. I stripped out all the serialization bits for our `LockFreeBloomFilter` fork; you guys definitely want to keep those so it will require a bit of work. Got the code into shape for a PR. Waiting on internal legal review (part of getting CLA stuff squared away). I'm told this will take about a week. Are you using a Bloom-1 design ([paper](http://www.cise.ufl.edu/~tali/1569342377.pdf), [fix](http://sci-hub.cc/10.1109/TPDS.2014.2378268))? Otherwise you'll run into races that may not be acceptable. However, it requires a slightly different equation per the second paper. @ben-manes I haven't referred to the literature before going down the lock-free path (I probably should have) because my intention was not to create the most optimal implementation (like the one memory access version the paper you cite advocates), but merely a superior one to what's currently in Guava. I erred on the side of: 1) simplicity of implementation, 2) correctness and 3) "good enough" performance.

I'd _love_ to hear your thoughts on the code (once my legal team clears it for publishing).

This change also wasn't the only one that contributed to perf in our fork of the BloomFilter; actually the biggest benefit came from switching away from Murmur3 as the hash function and [using xxHash from the Zero Allocation Hashing project](https://github.com/OpenHFT/Zero-Allocation-Hashing) along with the Kirsch-Mitzenmacher approach exhibited in the MURMUR128_MITZ_32 strategy. 

[JMH](http://openjdk.java.net/projects/code-tools/jmh/) benchmarks on the BloomFilter with representative data for our service showed the xxHash approach taking ~93ns for `mightContain` vs ~440ns for the MURMUR128_MITZ_64 strategy that's used by default. 

The third change I made (which I very much doubt Guava upstream would like to merge) was to rip out the `Funnel` business, hardcode String as the BloomFilter key (it's the only key type we use) and use a custom `toAsciiBytes` String -> byte[] conversion function [mentioned on this page as the fastest approach.](http://java-performance.info/charset-encoding-decoding-java-78/) I benchmarked various other Charset conversions (including the "unencoded chars" approach Guava uses) and the custom function was consistently 30% faster.

We can get away with that since we know all our keys are ASCII Strings, but Guava can't.

Just in case it wasn't clear, my PR will only contain the lock-free parts (since I doubt the other parts are something upstream is interested in).
 Guava's BloomFilter is a bit of an odd result. Initially there were claims that a BF was too slow as one would have to use a `SecureRandom` to have a good distribution and dynamically configure `k` hash functions. I jumped in having just written one as interview practice (as impractical and not intended to be viewed) using a normal hash function, bitwise ops, and deriving multiple due to reading [Less Hashing, Same Performance: Building a Better Bloom Filter](https://www.eecs.harvard.edu/~michaelm/postscripts/rsa2008.pdf). Someone else wrote a blog analyzing that proposal, which unblocked the Guava team. But I wasn't involved otherwise past that initial thread and a brain dump over lunch.

The use of allocation surprised me and I think its the dominant cost of Guava's implementation. It makes sense as a very elegant API, but also a poor fit for data structures where performance matters. Usually one builds data structures where the internals bypass elegant APIs because performance matters. So Guava's is more of a good example to learn from for average cases, but not when performance is important.

That then begs the question of whether Guava wants a fast implementation. The library is best viewed as having clean APIs, excellent code, and good enough for the simple common cases. But when performance and special cases emerge, its best to deviate away. Which leads to your custom implementation being the right approach for you, but may not fit the precedent the Guava team has set.

If @lowasser is interesting in driving this forward iterating on your proposal, then maybe we should dig into the latest research to see what other gems we can incorporate. > The library is best viewed as having clean APIs, excellent code, and good enough for the simple common cases. But when performance and special cases emerge, its best to deviate away. Which leads to your custom implementation being the right approach for you, but may not fit the precedent the Guava team has set.

I agree. I think it's perfectly fine for Guava to aim for a reasonable and sound implementation that works well in a wide variety of cases even if that leaves some perf on the table. When someone really needs lots of perf, it's a great base to start from (Apache v2 FTW); it certainly saved me a ton of time since I didn't have to write everything from scratch.

Though IMO it also makes sense to improve that base perf when possible without impacting the traits you mentioned (generality, API, etc). The lock-free PR I have sitting on my machine is a fairly small diff. It doesn't change the external APIs at all and strictly improves perf. Since common  bloom filters use-cases are write-light and read-heavy and atomic _reads_ (not writes) are free on x86 (and x86-64) because of that architecture's memory model, even the single-threaded use-case won't be negatively affected. And that's without mentioning that a single-threaded use-case for a bloom filter is... rare, at best. Just wanted to drop a note saying that I haven't forgotten about this; my patch is winding its way through our internal legal review. Sorry about the delay folks! I've received all the legal approvals; I plan on sending the PR later today. Posted the PR: https://github.com/google/guava/pull/2761  I have been using Guava version 20.0 and Spring GuavaCacheManager version 4.3.3.RELEASE for caching in my application.

I'm initialising guava cache builder in spring configuration file and using cacheable annotation in cache file. 

As per Guava CacheBuilder RemovalListener docs,

> Warning: after invoking this method, do not continue to use this cache
> builder reference; instead use the reference this method returns. At
> runtime, these point to the same instance, but only the returned
> reference has the correct generic type information so as to ensure
> type safety. For best results, use the standard method-chaining idiom
> illustrated in the class documentation above, configuring a builder
> and building your cache in a single statement. Failure to heed this
> advice can result in a ClassCastException being thrown by a cache
> operation at some undefined point in the future.

*I'm using the reference returned by removal listener in spring configuration file.*

*But still is there any possibility of ClassCastException being thrown by a cache operation at some undefined point in the future for the below code?*

***Since here CacheBuilder is created/initialised with removal listener in a single step then at later point Cache build will be lazily initialised at Spring GuavaCacheManager getCache***

Spring configuration file

    @configuration
    @EnableCaching
    public class SpringConfig {
	
	@Bean
	public CacheBuilder<Object, Object> cacheBuilder() {
	    CacheBuilder<Object, Object> cacheBuilder = CacheBuilder.from("maximumSize=1000,expireAfterAccess=1d").removalListener(addRemovalListener());
	    
	    return cacheBuilder;
	}
	
	@Autowired
	private CacheBuilder<Object, Object> cacheBuilder;
	
	@Bean
	public CacheManager cacheManager() {
	    GuavaCacheManager cacheManager = new GuavaCacheManager();
	    cacheManager.setCacheBuilder(cacheBuilder);
	    cacheManager.setAllowNullValues(false);
	    return cacheManager;
	}
    
    private RemovalListener<Object, Object> addRemovalListener() {
		return new RemovalListener<Object, Object>() {
			public void onRemoval(RemovalNotification<Object, Object> removal) {

				if(RemovalCause.EXPLICIT != removal.getCause()) {

    				try {
    					String key = (String) removal.getKey();
    					String val = (String) removal.getValue();
    					......
                        ......
					} catch (Exception e) {
						logger.error("Cache RemovalListener Exception [{}]", e.getMessage(), e);
					}
				}
			}
		};
	}

    }


Spring Cache File


    @Service
    public class SpringCache {

	@Autowired
	private CacheManager cacheManager;

    @Cacheable(cacheManager="cacheManager", key="#p0", cacheNames="cacheKeysMap", sync=true)
	public String getKeyFromCache(String key) {
        ......
        ......
        return value;
    }

    @CacheEvict(cacheManager="cacheManager", key="#p0", cacheNames="cacheKeysMap")
	public void deleteFromCache(String key) {
		
	}

    } My only concern is,
_Guava CacheBuilder is created/initialised with removal listener in a single step then at later point Cache build will be lazily created._

My basic tests are working fine. 

**But since Guava docs advice to heed configuring a builder
and building your cache in a single statement for RemovalListener, I'm worried will it have an ClassCastException possibility at some undefined point in future?** My Cache will have key as String and value as CUTOM_OBJECT.

CacheBuilder<Object, Object>
RemovalListener<Object, Object>

RemovalListener logic has type casting,

> String key = (String) removal.getKey();
> CUTOM_OBJECT val = (CUTOM_OBJECT) removal.getValue();

Is that fine?  The Ordering Javadoc says:

> If you are using Java 8, this class is now obsolete (pending a few August 2016 updates). [...] However, at this time we have no plan to deprecate this class.

But the Comparators Javadoc says:

> In light of the significant enhancements to Comparator in Java 8, the overwhelming majority of usages of Ordering can be written using only built-in JDK APIs.  Because of this, and because it's awkward to have to convert comparators into Ordering instances, Ordering and its methods are planned for deletion.

So, is Ordering deprecated or not?  How urgent is migrating from Ordering to Comparator? @kevinb9n I think, regardless of whether Ordering will be deprecated or not in the future, that the note that says "(pending a few August 2016 updates)" should be amended to prevent confusion. @ronshapiro I think this issue was closed a bit prematurely, because I AFAIK the note in the javadocs about "(pending a few August 2016 updates)" has not been updated or removed yet. :) No worries! Many thanks for opening it again. :) @ronshapiro @cpovirk Many thanks for resolving this! :)  The TOC displayed on all the [Wiki](https://github.com/google/guava/wiki) pages is missing `CaseFormat` under `Strings`:

- [Strings](https://github.com/google/guava/wiki/StringsExplained)
  - Joiner
  - Splitter
  - CharMatcher
  - Charsets

The linked page contains an entry `CaseFormat` which isn't shown. Don't know what Wiki type this is, but usually they are auto-generated. Weird. Might mean there are more of these.  The [doc comments](https://google.github.io/guava/releases/21.0/api/docs/com/google/common/base/Equivalence.html) for Equivalence state that "A future version of this class will implement BiPredicate<T, T>. In the meantime, to use an equivalence (say, named equivalence) as a bi-predicate, use the method reference equivalence::equivalent."  However, as of Guava 21.0, Equivalence does implement that method.  This section should therefore go away.

I'm not sure whether this was a one-off miss when converting to Java 8, or if there are other similar misses in updating the doc comments.  I have seen that the documentation suggests that the accessor methods on mutable graph throws `ConcurrentModificationException` while iterating through `adjacentNodes()`. I have a sample dfs that removes edges while performing dfs:
```
private Set<EndpointPair<String>> backEdges(MutableGraph<String> g, String root, String current, Set<String> visited,
			Set<EndpointPair<String>> backEdges)
	{
		visited.add(current);

		for (String n : g.adjacentNodes(current))
		{
			if (!visited.contains(n))
			{
				backEdges(g, current, n, visited, backEdges);
			}
			else if (!n.equals(root))
			{
				// Found a back-edge
				EndpointPair<String> edge1 = EndpointPair.ordered(current, n);
				EndpointPair<String> edge2 = EndpointPair.ordered(n, current);

				logger.info("Removing edge {} {}", edge1.nodeU(), edge1.nodeV());
				// Remove from graph
				g.removeEdge(edge1.nodeU(), edge1.nodeV());
				g.removeEdge(edge2.nodeU(), edge2.nodeV());

				// Add to result set
				backEdges.add(edge1);
				backEdges.add(edge2);
			}
		}

		return backEdges;
	}
```

A node is removed and immediately the iterator throws exception. Is there a way that this could be avoided though only `removeEdge()` is applied here? Hi @sudharsannr. There are at least two solutions for this unfortunate little problem with the spec of `MutableGraph` that I can think of:

1. In the for-loop, copy the `g.adjacentNodes(current)` into an `ImmutableSet`. This prevents ConcurrentModificationException because the newly-created immutable set is never modified in the for-loop:
```java
for (String n : ImmutableSet.copyOf(g.adjacentNodes(current))) { // copy prevents CME
    ...
}
```
2. If copying the nodes is too expensive memory- or time-wise for your needs, try _recording_ the edges to remove within the for-loop, and then remove them all after exiting the for-loop. Something like below (I've not run it through a compiler or tested it, so YMMV):
```java
		visited.add(current);

		List<ImmutableList<String>> edgesToRemove = new ArrayList<>();
		for (String n : g.adjacentNodes(current))
		{
			if (!visited.contains(n))
			{
				backEdges(g, current, n, visited, backEdges);
			}
			else if (!n.equals(root))
			{
				// Found a back-edge
				EndpointPair<String> edge1 = EndpointPair.ordered(current, n);
				EndpointPair<String> edge2 = EndpointPair.ordered(n, current);

				logger.info("Removing edge {} {}", edge1.nodeU(), edge1.nodeV());
				// Record to remove from graph later
				edgesToRemove.add(ImmutableList.of(edge1.nodeU(), edge1.nodeV()));
				edgesToRemove.add(ImmutableList.of(edge2.nodeU(), edge2.nodeV()));

				// Add to result set
				backEdges.add(edge1);
				backEdges.add(edge2);
			}
		}
		// Remove recorded edges from graph now
		for (ImmutableList<String> e : edgesToRemove) {
			g.removeEdge(e.get(0), e.get(1));
		}

		return backEdges;
``` Option 1 would work. Option 2 would not work since it is a recursive call and cannot defer removing the edge at the end. My guess is that when edges are removed, successor and predecessors would be affected. Hi @jrtom, apologies, I realise with hindsight that it was strong of me to refer to the CME-throwing behaviour of MutableGraph as a "problem".

What I'd meant to say was, when I first encountered the CME-throwing behaviour of MutableGraph whilst iterating over one and adding new nodes to it in one of my personal projects, I was rather surprised by the CME because I didn't expect it. (I think I experienced this before the very well-written piece on Graph in the wiki was written). However, having thought about it, I understood (and still do understand now) why it throws CME, and your explanation of why it throws CME summarises it quite nicely. :)

  Current signature of `Sets.difference` method is

    SetView<E> difference(final Set<E> set1, final Set<?> set2)

however, for all usages of `set2` argument everything would work as well if argument was of type `Collection<?>`, without impact on performance for current usages. Why not to make signature less strict?

In my use case, I do following manipulation:

    BiMap<Foo,Foo> specialFoos = ...
    Set<Foo> nonspecialLeftFoos  = Sets.difference(leftFoos ,specialFoos.keySet());
    Set<Foo> nonspecialRightFoos = Sets.difference(rightFoos,specialFoos.values());

where this issue is the only reason why `specialFoos` is a `BiMap`.
Thanks for response. > (...) for all usages of set2 argument everything would work as well if argument was of type Collection<?>, without impact on performance for current usages.

`Collection.contains()`, which `Sets.difference()` uses a lot, is _O(1)_ for hash based sets and _O(log(n))_ for tree based sets. You can't guarantee anything below _O(n)_ in general (`List`, `Queue` and so on). Iterating over `Sets.difference()` would be _O(n^2)_ in that case - that's not something you want - it's about _O(n)_ now. @perceptron8 agree, I talked about not worsening performance for sets since no other type could be passed so far. For other types of collections the performance would certainly be worse. This could be emphasized in javadoc in similar manner as for example in the note in `Sets.intersection` method's javadoc. 

Anyway, if you find proposed change too risky and tend to be misused, I am fine with any of workarounds, of which the @lowasser 's one seems to be the best readable. > If you really want that behavior you can also always get it with
Sets.filter(set, not(in(Collection))).

Or, if you're on Java 8 and a fan of lambdas: `Sets.filter(set, e -> !collection.contains(e))`.  E.g. there are:

<pre lang="java">
LoadingCache<K, V> cache = CacheBuilder.newBuilder()
        .refreshAfterWrite(w, MINUTES)
        .build(new CacheLoader<K, V>() {
            public V load(K key) throws Exception {
                // long running IO;
            }
        });
</pre>

It would be great if it will be possible to make `cache` return expired value while recalculating. @lowasser. I had some more experiments and found that I have no idea how to make cache periodically refresh values (without any extra code). The main idea is the possibility to get quite fresh values instantly at any time. Using only `refreshAfterWrite` I have to do some manual polling, otherwise I could get old values or a noticeable delay (in combination with `expireAfterWrite`) after a long silence period. I see. The issue in it's current statement is exhausted.  Introduce a Collector to ease merging of Maps with java stream API.

Given (random Maps implementations used to ensure collector is generic):
```java
HashMap<String, Integer> foo = new LinkedHashMap<>();
foo.put("one", 1);
foo.put("two", 2);
NavigableMap<String, Integer> bar = new TreeMap<>();
bar.put("three", 3);
bar.put("four", 4);
Stream<Map<String, Integer>> stream = ImmutableSet.of(foo, bar).stream();
```

This code:
```java
ImmutableMap<String, Integer> collectedTheOldWay = stream
        .map(Map::entrySet)
        .flatMap(Set::stream)
        .collect(ImmutableMap.toImmutableMap(Map.Entry::getKey, Map.Entry::getValue));
```
can now be done with:
```java
ImmutableMap<String, Integer> collected = stream.collect(ImmutableMap.mergeMapsCollector());
``` Hi,

> For this feature, I'd wonder why the maps were created separately in the first place?

That is just for the example.

> Do people actually have an unbounded number of maps, or do they have a fixed number of maps that need to be combined?

Of course, the actual purpose is for an unbounded number of maps. For a fixed number of maps, your code is better.

My cases are usually like the Map is generated by a `Stream#map` call. Let's take a new example (imperative/no-stream-style first):

```java
ImmutableMap.Builder<MyKey, MyValue> allKnownValues = ImmutableMap.builder();
for (Foo foo : foos) {
    Bar bar = this.convertFooToBar(foo);
    ImmutableMap<MyKey, MyValue> mapForFoo = bar.getTheMap();
    allKnownValues.putAll(mapForFoo);
}
return allKnownValues.build();
```

With the stream API, should be:

```java
return foos.stream()
        .map(this::convertFooToBar)
        .map(Bar::getTheMap) // gives the Stream<Map<MyKey, MyValue>>
        .map(Map::entrySet)
        .flatMap(Set::stream)
        .collect(ImmutableMap.toImmutableMap(Map.Entry::getKey, Map.Entry::getValue));
```

With the suggested new API:

```java
return foos.stream()
        .map(this::convertFooToBar)
        .map(Bar::getTheMap)
        .collect(ImmutableMap.mergeMapsCollector());
```

I think this kind of creating a Map by dynamically filling it with dynamically computed maps is frequent (hence, the `ImmutableMap.Builder#putAll(Map)`). I won't discuss the need for this API because I think Guava maintainers have a much better point of view/experience for that than mine. My experience is just that people will favor 1st code (imperative style) to 2nd code which is too verbose and quite cryptic for the non-stream-API-fluent-developer and I think the 3rd one is much more functional-style (ie: declarative about the expected result), but it's just based on nothing more than my day-to-day experience.

Also, maybe `mergeMaps` is not the suitable term but I'm not a native english-speaker) and a `mergeOperator` could be passed.  Let's say I want to convert a list `list` to an immutable sorted set `set`:
```java
List<Integer> list; // Source
ImmutableSortedSet<Integer> set; // Target
```
When creating a sorted, immutable copy of an iterable or iterator over `Comparable`s, I have the option to leave the ordering implicit:
```java
set = ImmutableSortedSet.copyOf(list);
```
For the streaming API, I would love to see the same option:
```java
// Currently needed:
set = list.stream().collect(toImmutableSortedSet(naturalOrder()));
// What I want to use:
set = list.stream().collect(toImmutableSortedSet());
``` I also would like to have the `SortedSet` with natural ordering as default when no parameter is passed. I had to create a custom collector to have this functionality.

```java
public static <E extends Comparable<E>> Collector<E, ?, ImmutableSortedSet<E>> toImmutableSortedSet() {
        return ImmutableSortedSet.toImmutableSortedSet(Ordering.natural());
}
```  i.e., returns true if a parameter is annotated with @Nullable
*or* @CheckForNull. Both annotations mean "this can be null".

fixes #2656 CLA signed by Addepar, Inc. Hi @bdworth, try replying "I signed it!" without the quotes. It doesn't seem @googlebot recognised the fact that you signed the CLA (it should only have took it a few seconds to run if it did AFAICR), so entering that phrase should get it to check your CLA status and respond back. I signed it! How strange - @googlebot is still not responding...

@cpovirk, I'm not sure if you're the right person to ask, but do you know what @bdworth should do next? I didn't sign anything -- I just used that phrase since I was told googlebot wanted that.

My CEO signed a corporate CLA on behalf of Addepar. I should be on the list of contributors in the CLA he signed. Not posting the email address for that group here since this page is public. Thanks. This seems like an unnecessary amount of overhead for a simple four-line change (the rest are tests), but it'll be good to have in place. Any luck? *ping*? New CLA resubmitted.  Currently `Stopwatch` is final which makes it impossible to mock it with mockito to unit test classes using it.
It would be great to make `Stopwatch` non final to avoid this problem.

Thanks! The excellent question of @lowasser aside, as of version 2.1.0, Mockito has incubating support for [mocking final types, enums and final methods](https://static.javadoc.io/org.mockito/mockito-core/2.7.0/org/mockito/Mockito.html#39). We're successfully using this in our project. @lowasser Thanks for your question. It is probably possible to mock Ticker for tests, but this makes tests dependent on internals of Stopwatch implementation - thing that we are trying to avoid.

@Stephan202 using newer Mockito is probably an option, but unfortunately there are situations when this is not possible or diffigult. E.g. current version of spring boot test utils requires older mockito. Well, ideally in unit test we would like to make sure that our code called start/stop/etc. Not that Ticker has moved through some number of ticks. @lowasser I ran into the same issue as @mar-kolya reports. In a unit test, I want to verify that my code called `Stopwatch.elapsed`, but instead had to mock `Ticker` and then verify its `read()` was called X+1 number of times (because Stopwatch calls it when it's started). Not the end of the world, but if Stopwatch interacted with ticker in other places, my test would depend on those internals. I think you can use PowerMockito to mock the final class. Everything else you can still use Mockito to setup and verify expectation.  `NullPointerTester` has `ignore()` to ignore methods, but there's no equivalent method for ignoring constructors.

This is easy to work around by calling `testConstructor()` on a set of filtered constructors. But it would be nice if core Guava included a way to ignore constructors before calling `testAllPublicConstructors()` or `testConstructors()`.  I was surprised to learn that `ContiguousSet.asList()` returns an `ImmutableList` which copies the discrete domain values into a new array:

```
Exception in thread "main" java.lang.OutOfMemoryError: Requested array size exceeds VM limit
	at com.google.common.collect.ImmutableCollection.toArray(ImmutableCollection.java:186)
	at com.google.common.collect.ImmutableSet.createAsList(ImmutableSet.java:371)
	at com.google.common.collect.ImmutableSet.asList(ImmutableSet.java:367)
```

Can `ContiguousSet.asList()` be changed to return a subclass of `ImmutableList` which computes the values as requested instead so that a `ContiguousSet` can be viewed as a `List` to be used with methods that act on lists? Hi @lowasser, what about Eclipse Collection's [`Interval`](http://www.eclipse.org/collections/javadoc/8.0.0/org/eclipse/collections/impl/list/Interval.html)?

AFAICT, it's somewhat similar to `ContiguousSet`, in that they both are lazy views over a "range" of comparable objects, one major difference being that `Interval` implements `List<Integer>` and `RandomAccess` (which makes it more similar to `ContiguousSet.asList()` API-wise), whereas `ContiguousSet` is more generic (it can work on any generic type rather than just `Integer`).

Hmm, I wonder if the fact that `Interval` works with only `Integer`s is what allows it to implement `RandomAccess`. I've not thought hard about this yet... Are not all discrete domains enumerable? I realize that Guava only currently defines discrete domains for `Integer`, `Long`, and `BigInteger` but what would be an example of a discrete domain for which you cannot know how to offset, etc.? Yes, I agree that a default implementation as you described would be "Very Bad" but a new `abstract C offset(C start, long number)` method could be defined on `DiscreteDomain` (`long` similar to `abstract long distance(C start, C end)`). I see that Guava allows you to create [your own DiscreteDomains ](https://github.com/google/guava/wiki/RangesExplained#your-own-discretedomains) so this would be a breaking change... 膜拜大神... > 膜拜大神...

English, _s'il vous plaît_. :wink:  When compiling code that depends on Guava 21.0, [Edit: I mistakenly said 20.0 originally] using Maven, I get many warning messages like this:

> Cannot find annotation method 'value()' in type 'com.google.errorprone.annotations.CompatibleWith': class file for com.google.errorprone.annotations.CompatibleWith not found

I do not use the errorprone library in my code, so this error message is due to its use by Guava.

Obviously, these are only warning messages and are not critical.
 These warnings are happening even in some pretty simple packages where there are no exotic maven plugins.

It does not happen on all of my modules that use Guava.  But I haven't narrowed-down which Guava class is involved.

The warnings happen during the "default-compile" step from maven-compiler-plugin.  I've tried version 3.3 and 3.6 of that plugin.

The warnings appear even if I set `<showWarnings>false</showWarnings>`
 Ok.  So this is related to annotation processors of some basic sort.  My standard build involves this:

```xml
<build>
  <plugins>
      <plugin>
        <groupId>org.apache.maven.plugins</groupId>
        <artifactId>maven-compiler-plugin</artifactId>
        <version>3.3</version>
        <configuration>
          <source>1.8</source>
          <target>1.8</target>
          <compilerArgs>
            <arg>-Xlint:all</arg>
            <arg>-Xlint:-serial</arg>
          </compilerArgs>
          <showWarnings>true</showWarnings>
          <showDeprecation>true</showDeprecation>
        </configuration>
      </plugin>
  </plugins>
</build>
```

The warnings are shown only when I include `Xlint` along with either of `showWarnings` or `showDeprecation`.

Then 9 identical warnings appear if my java code contains one single line like this:
`ImmutableTable.Builder<?,?,?> builder = ImmutableTable.builder();`

So, I don't know if there is a bug in maven compiler plugin, or in Guava's `ImmutableTable` or what.  But I really shouldn't be seeing these warnings.

Again, not a bug in the program operation, just an annoying set of warning messages. We ran into this attempting to upgrade the `jdbi3` project to Guava 21:
https://github.com/jdbi/jdbi/pull/697

We also don't do anything super fancy with Maven plugins, but we do attempt to set "warnings as errors" everywhere.  That said, despite being logged at `ERROR` level, it doesn't fail the build.

```
[ERROR] Failed to execute goal org.apache.maven.plugins:maven-compiler-plugin:3.5.1:
testCompile (default-testCompile) on project jdbi3-sqlobject: Compilation failure

[ERROR] /home/travis/.m2/repository/com/google/guava/guava/21.0/guava-21.0.jar(com/google/common/collect/Multimap.class):
warning: Cannot find annotation method 'value()' in type 'CompatibleWith': 
class file for com.google.errorprone.annotations.CompatibleWith not found
``` No, sorry, an earlier version of this comment incorrectly stated the build failed.

The actual problem is that the javac output all gets logged at the maximum error level -- so the `WARNING` that this emits will be represented as an `ERROR` if there are *other* build errors, which is confusing.  Once you fix the other unrelated build errors this message then gets downgraded to a `WARNING`.  So it does not actually break out build, but it does introduce warnings -- which as soon as "warnings as errors" gets fixed (someday :crossed_fingers:) it will then actually fail the build I am also seeing this, on a standard `javac -Xlint -Werror` build with `ant`.
The messages are
```
    [javac] .../guava.jar(com/google/common/collect/Multiset.class): warning: Cannot find annotation method 'value()' in type 'CompatibleWith': class file for com.google.errorprone.annotations.CompatibleWith not found
    [javac] .../guava.jar(com/google/common/collect/Multiset.class): warning: Cannot find annotation method 'value()' in type 'CompatibleWith'
    [javac] error: warnings found and -Werror specified
```

Because we want to use `-Werror`, this breaks our build and prevents us from upgrading Guava. @PhilippWendler thanks for trying javac.  Which JDK version is it?

I have found that I can eliminate the warning message in a Maven build by using this flag for the `maven-compiler-plugin`:  `<forceJavacCompilerUse>true</forceJavacCompilerUse>`.   That should make Maven use the `javac` command in my jdk, which is 1.8.0_66.   I don't exactly understand why that removes the warning. I tested with javac 1.8.0_111 from OpenJDK. ^ And if you declare that dependency `<scope>provided</scope>`, then it shouldn't end up in your final aggregate build artifact (WAR, Uber JAR, etc.), meaning there should be no downside to doing so. You should be able to reproduce the problem in branch `guava21` of [sosy-lab/java-common-lib](https://github.com/sosy-lab/java-common-lib). You can start a build with `javac` with `ant clean build-project`. The definition of the ant target that calls `javac` is in `build/build-compile.xml`, you can see the compiler options there.

The problem is reproducible with this branch on AppVeyor ([log](https://ci.appveyor.com/project/PhilippWendler/java-common-lib/build/build%2014%20guava21)) and Travis ([log](https://travis-ci.org/sosy-lab/java-common-lib/jobs/195317529)).

Btw, we are even using error-prone already (though I disabled it in that branch for easier debugging) and want to upgrade to 2.0.15 at some point anyway, but I think that it would still be good if Guava would not have this problem.

The Eclipse Java Compiler builds our project just fine (`ant clean build-project-ecj`). @cpovirk  To reproduce the problem in Maven you must use *both* `Xlint` and `showWarnings` or `  showDeprecation`.   @PhilippWendler did something similar with `javac -Xlint -Werror`.  So it may be that the problem is related to `lint`.

You can then reproduce it with a project containing one single java class like this:
````java
public class GuavaTest {
  private ImmutableTable.Builder table = ImmutableTable.builder();
}
```` We are also experiencing this issue.  The noise makes it hard to want to push Guava 21 forward through all our projects. Any chance of a 21.1 release?  Or is 22.0 coming soon? > Does the workaround work OK?

Yes, it does work.  However I don't think you should expect that everyone will go to github and search this issue.

To me personally this definitely seems like a defect large enough to warrant a patch release.  It causes everyone who may treat warnings as errors to have to either search for this obscure issue, or to modify their projects in a way that is not reasonable (you should be able to reasonably treat warnings aggressively as external libraries should not be causing compiler warnings). I'm using guava 22.0
I tried your workaround by adding
```xml
    <groupId>com.google.errorprone</groupId>
    <artifactId>error_prone_annotations</artifactId>
    <version>2.0.15</version>
```

I have a lot of warnings before and after applying the workaround like this

```java
Compile with -strict or with -logLevel set to TRACE or DEBUG to see all errors.

   Computing all possible rebind results for 'com.google.gwt.useragent.client.UserAgentAsserter'
      Rebinding com.google.gwt.useragent.client.UserAgentAsserter
         Checking rule <generate-with class='com.google.web.bindery.requestfactory.gwt.rebind.RequestFactoryGenerator'/>
            [WARN] Unknown type 'com.google.web.bindery.requestfactory.shared.RequestFactory' specified in deferred binding rule
         Checking rule <generate-with class='com.google.web.bindery.requestfactory.gwt.rebind.RequestFactoryEditorDriverGenerator'/>
            [WARN] Unknown type 'com.google.web.bindery.requestfactory.gwt.client.RequestFactoryEditorDriver' specified in deferred binding rule
         Checking rule <generate-with class='com.google.gwt.editor.rebind.SimpleBeanEditorDriverGenerator'/>
            [WARN] Detected warnings related to 'com.google.gwt.editor.client.SimpleBeanEditorDriver'.   Are validation-api-<version>.jar and validation-api-<version>-sources.jar on the classpath?
            Specify -logLevel DEBUG to see all errors.
            [WARN] Unknown type 'com.google.gwt.editor.client.SimpleBeanEditorDriver' specified in deferred binding rule
      Rebinding com.google.gwt.useragent.client.UserAgentAsserter
         Checking rule <generate-with class='com.google.web.bindery.requestfactory.gwt.rebind.RequestFactoryGenerator'/>
            [WARN] Unknown type 'com.google.web.bindery.requestfactory.shared.RequestFactory' specified in deferred binding rule
         Checking rule <generate-with class='com.google.web.bindery.requestfactory.gwt.rebind.RequestFactoryEditorDriverGenerator'/>
            [WARN] Unknown type 'com.google.web.bindery.requestfactory.gwt.client.RequestFactoryEditorDriver' specified in deferred binding rule			
   Computing all possible rebind results for 'com.google.gwt.user.client.DocumentModeAsserter'
       Rebinding com.google.gwt.user.client.DocumentModeAsserter
          Checking rule <generate-with class='com.google.web.bindery.requestfactory.gwt.rebind.RequestFactoryGenerator'/>
             [WARN] Unknown type 'com.google.web.bindery.requestfactory.shared.RequestFactory' specified in deferred binding rule
          Checking rule <generate-with class='com.google.web.bindery.requestfactory.gwt.rebind.RequestFactoryEditorDriverGenerator'/>
             [WARN] Unknown type 'com.google.web.bindery.requestfactory.gwt.client.RequestFactoryEditorDriver' specified in deferred binding rule
       Rebinding com.google.gwt.user.client.DocumentModeAsserter
          Checking rule <generate-with class='com.google.web.bindery.requestfactory.gwt.rebind.RequestFactoryGenerator'/>
             [WARN] Unknown type 'com.google.web.bindery.requestfactory.shared.RequestFactory' specified in deferred binding rule
          Checking rule <generate-with class='com.google.web.bindery.requestfactory.gwt.rebind.RequestFactoryEditorDriverGenerator'/>
             [WARN] Unknown type 'com.google.web.bindery.requestfactory.gwt.client.RequestFactoryEditorDriver' specified in deferred binding rule
    Computing all possible rebind results for 'com.google.gwt.logging.client.LogConfiguration
``` The "Cannot find annotation method 'value()' in type 'CompatibleWith'" warning still appears with guava-22.0. Adding error_prone_annotations-2.0.19 to the dependencies helped. Update on my comment: When compiling with guava-22.0 and jdk-1.8.0_31 the warning appears without the error_prone_annotations-2.0.19. With jdk-1.8.0_131 no errors, even without the error_prone_annotations jar. I'm confess I don't yet everything that's going on here, and I'm afraid "just include the dependencies" may ignore some of the subtleties.

The first thing I don't understand is: what exactly is trying to call a method on an annotation that isn't included in the classpath? Secondly, how does that thing (whatever it is) _even know_ that the annotation has the `value()` method, if the annotation class is not on the classpath?

As was [recently cleared up](https://stackoverflow.com/a/46882631/421049) on one of my recent [Stack Overflow questions](https://stackoverflow.com/q/45596949/421049) (involving this same situation), it appears that if an annotation with a runtime retention policy is attempted to be accessed at runtime via reflection, yet that annotation is not present on the classpath, the JDK _should silently ignore the annotation_. (See also this [related Stack Overflow answer](https://stackoverflow.com/a/3568041/421049).) So if missing annotations "just disappear" at runtime, how is this "thing" finding it and trying to call its `valud()` method --- or even knowing that it has a `value()` method?

Yes, I understand that the tricky part here is that the compiler isn't trying to access the class at runtime. But in a way that makes it even more mysterious how it even knows that the annotation has a `value()` method, if that annotation's class is not present at compile time. And why is this lint tool or whatever trying to call that method in the first place?

And lastly, does this even apply to the JSR 305 annotations? Do the JSR 305 methods even have any such methods that some tool would try to find at compile time? (Again, knowing the specifics of what tool was trying to access that method might make some of these answers more apparent.) Thanks, @cpovirk . This is really interesting. I wonder if `javac` is really doing the correct thing here. It doesn't seem be following the spirit of [JLS 13.5.7](https://docs.oracle.com/javase/specs/jls/se8/html/jls-13.html#jls-13.5.7), which says, "Adding or removing annotations has no effect on the correct linkage of the binary representations of programs in the Java programming language." (See the [great answer](https://stackoverflow.com/a/46882631/421049) to my [question](https://stackoverflow.com/q/45596949/421049) on Stack Overflow.)

I might have mentioned I'm probing this in depth, not to criticize Guava, but to determine the best thing to do in our own public Java library. I'm not sure that the best response is to say, "OK, we'll just force all users of our library to download several dependencies that they don't need to actually _use_ our library" just because of a somewhat obscure use case in which it's not even clear that `javac` is doing the right thing.

As you point out, @enwired could have worked around this problem simply by adding an explicit dependency to `error_prone_annotations`. Guava's "solution" is to basically force @enwired (and everybody else) to include this dependency --- along with several other dependencies, the absence of which were not causing _anybody_ problems that we know of.

So it's a really interesting situation from a technical standpoint. From a semantics standpoint, I haven't made a final decision but it still seems more appropriate to me (see further [discussion](https://github.com/google/guava/issues/1018#issuecomment-340202085) in #1018) to make the JSR 305 dependency `<optional>` in our own library, and let the few people it affects (if anyone) explicitly include the JSR 305 dependency themselves.

Thanks for discussing this with me! As the original submitter of this bug, I'll add my two cents.

I think that there is something fishy about the fact that javac reports compiler warnings about code that is not part of the code being compiled.  I no longer think this is a bug of guava.  The change made in the guava pom file seems like a work-around for a deficiency in javac or in java language specification related to annotations.

The details are above my level of understanding.

I wish there were some way to avoid forcing me to include a dependency on errorprone.  This particular library doesn't bother me because it is small and useful.  But the general principal that could lead to other libraries becoming forced inclusions in the future does bother me.

Perhaps javac could implement an additional 'SuppressWarnings' directive for this case.  But I'm not going to file a request for that myself.  I have a TreeMultiSet as a member of the singleton object. When I clear the set using clear(), it doesn't clear any.
```
class Campaign {
   private static Campaign singleton;
   private TreeMultiset<Item> items;
  
   public Campaign() {
        items = TreeMultiSet.create();
   }
   public void destroy() {
      items.clear();
   }
   public void setItem(Item item) {
      items.add(item);
   }
   public static Campaign getSingleton() {
     if (singleton == null) {
            synchronized (Campaign.class) {
                if (singleton == null) {
                    singleton = new Campaign();
                }
            }
        }
        return singleton;
   }
}

Item item = new Item();
Campaign.getSingleton().setItem(item);
Campaign.getSingleton().destroy(); //its not clearing the set. no errors either.

``` Hi Rohit5ram, 
  I tested your method,changed the Item class to integer and  my test result turned out the clear() method is ok.

 Hi @shengxuanyi 

Using this on Android 4.2.2
Item extends some ParentItem and implements Comparable,Parcelable
```
public class Item extends ParentItem implements Comparable<Item>, Parcelable {
public int priority;
public String id;
//and so many fields
@Override
    public int compareTo(@NonNull Item item) {
        int value = item.priority.compareTo(this.priority);
        return (value != 0) ? value : 1; //to insert items with same priority.else equal priority items are overwritten
    }
}
```

In Campaign class I filter the set a lot many times.
```
Collections2.filter(items, new Predicate<Item>() {
        @Override
            public boolean apply(Item item) {
               return item.id.equals("MAIN"); 
           }
} );
```
Anything to do with these ?
 You `compareTo` is seriously broken, you really shouldn't expect any collection using it to work:

> The implementor must ensure sgn(x.compareTo(y)) == -sgn(y.compareTo(x)) for all x and y.
 @rohit5ram, could you perhaps explain to us what sort of ordering you're trying to achieve with these `Item` objects in your `TreeMultiset`? (For example, least-to-greatest ordering by `priority`, greatest-to-least ordering...)

Is this something which you're at liberty to talk about? @jbduncan greatest-to-least ordering Hi @rohit5ram, since you're on Android, I presume you cannot use Java 8 features?

If so, I think you can fix your problem if you simplify your `compareTo` implementation from
```java
int value = item.priority.compareTo(this.priority);
return (value != 0) ? value : 1;
```
to
```java
return item.priority.compareTo(this.priority);
```

I believe this should compare your `Item`s by their `priority` in reverse order (so greatest-to-least order), but I've not tested it, so please don't hold me to it. :)

My solution assumes you're _only_ interested in comparing `Item`s by their `priority`.

If you also want to compare by `id` and the other fields in your `Item` class, then you'll need something different (which I can help you with again).

Hope this helps! Hi @jbduncan 
The issue is with clear(). I am able to insert in greatest-to-least order with duplicates as well using the existing code. I have given heads up on my implementation so that it can help you to find a reason on why isn't it able to clear the set.
Can you please refer @shengxuanyi comments above @Maaartinus @lowasser  Is that the reason for clear() not able to work? The existing code is able to insert all the values into the set. If the priority is same then it's overwriting the old object. Hence I avoided and inserted it again.

I assumed TreeMultiSet take duplicates. But with this 
`item.priority.compareTo(this.priority);` 
its replacing the old object of same priority

Can you please help ? I couldn't have said it any better myself, regarding @lowasser's comments on Multisets and comparators!

@rohit5ram, does this answer all of your concerns for now? :)

Or is there anything else we can do to help you with understanding/using TreeMultiset and/or solving your overall problem (like comparing by multiple fields e.g. `priority` and then `id` and then your class's other fields)? @jbduncan @lowasser The requirement is that every object is unique(pre-known) and should be sorted based on priority. In order to sort it at the time of insertion, I chose TreeMultiSet. I feel the data structure should not be of set.
The best-suited data structure for this would be an ArrayList. So I changed the code as below.

`ArrayList<CampaignFileItem> campaignFileItems;
Collections.sort(campaignFileItems)
`

`return item.priority.compareTo(this.priority);`

Please suggest if you feel on adding anything or else you can close the issue. Thanks a lot !
 Hi @rohit5ram, there are two things I can think of which may allow you to improve your code.

1. I'd consider moving your current `Item.compareTo` implementation into it's own Ordering comparator, like so:
```java
private static final Ordering<Item> ITEM_BY_PRIORITY_REVERSE_ORDERING =
  new Ordering<Item>() {
    @Override
    public int compare(Item left, Item right) {
      Preconditions.checkNotNull(left, "left");
      Preconditions.checkNotNull(right, "right");
      return Ints.compare(left.priority, right.priority);
    }
  }.reverse();
```
The advantage of this is that you can implement `Item.compareTo` separately in terms of _all_ its fields rather than just `priority`, which is what future readers of your code would expect `compareTo` to do, I imagine.

2. I'd then consider replacing `ArrayList<CampaignFileItem> campaignFileItems = ... /* your unsorted items */; Collections.sort(campaignFileItems);` with
```java
ImmutableList<Item> campaignFileItems = ITEM_BY_PRIORITY_REVERSE_ORDERING.immutableSortedCopy(... /* your unsorted items */);
```
The advantage of this is you end up with an immutable data structure, which is easier to reason about as you can never accidentally change it (assuming `Item` itself is immutable, i.e. all its fields are `final` and they are of primitive types and/or object types which themselves cannot be mutated e.g. `String`).  Sometimes I want to check if more than one String is null or empty, but the method in the API only allows one String as argument.

Tell me what you guys think about it:
``` java
static boolean stringIsNullOrEmpty(@Nullable String... string) {
	for (int i = 0; i < string.length; i++) {
		if (string[i] == null || string[i].length() == 0) {
			return true;
		}
	}
	return false;
}
``` @kevinb9n I just thought it would be less verbose for those who want to call this method and use a new resource instead of `Strings.isNullOrEmpty(first) || Strings.isNullOrEmpty(second)...`

But I agree with you, I had not thought about the stack trace before opening the issue. If you want such a functionality, you can always use the following:

    Stream<String> strings = ... ;
    boolean anyNullOrEmpty = strings.anyMatch(Strings::isNullOrEmpty);

If you don't use streams (because of Java 7- or else), you can use:

    Predicate<String> isNullOrEmptyPredicate = new Predicate<String>() { public boolean apply(String s) { return Strings.isNullOrEmpty(s); }  }

    String[] strings = ... ;
    boolean anyNullOrEmpty = FluentIterable.from(strings).anyMatch(isNullOrEmptyPredicate); Nice, @ogregoire thank you.  updated copyright - filled in template I signed it! Hi @bepahol, I'm neither on the Guava team nor a lawyer, but I'm under the impression one isn't meant to replace the brackets _within the Apache license itself_ with a copyright year - just those in source files which themselves have an abbreviated Apache license header. @jbduncan - ahhhh ok. Makes sense, thank you.  This is kind of a meta issue.

Project contributors' e-mail addresses, which were originally displayed in an incomplete/"obfuscated" form in Google Code issues as per the authors' privacy settings, have become fully visible after migration of the issues to GitHub ([random example](https://github.com/google/guava/issues/6)).

> Original issue created by [FULL E-MAIL ADDRESS] on [TIMESTAMP]

This does not affect authors who had their username displayed instead (though it might be simple to derive their e-mail addresses from that, but that's not the point here).

Why did this happen? Why did anyone think it would be a good idea to expose people's e-mail addresses, and against their accounts' privacy settings stating otherwise?

While damange has been done already (Hello, spam!), I request the full addresses (or at least mine) to be removed from GitHub issues. (People can't do this on their own as the comments were posted by @gissuebot.)

Due to this alarming incident I feel I should refrain from contributing to Google projects for the time being. I consider this a serious breach of trust. Thanks, Colin.

Apologies accepted.  ReverseConverter, ConverterComposition, & FunctionBasedConverter classes implement Serializable without transient/serialized member variables I signed the CLA.

lowasser - it's in response to this: http://cwe.mitre.org/data/definitions/594.html & squid:S1948

"Fields in a Serializable class must themselves be either Serializable or transient even if the class is never explicitly serialized or deserialized. That's because under load, most J2EE application frameworks flush objects to disk, and an allegedly Serializable object with non-transient, non-serializable data members could cause program crashes, and open the door to attackers."

 Contributor License Agreement (CLA),I signed it! Understood - if you're fine with this, let me close the pull request.  

Thanks so much for the speedy response.  One of the things I miss most when switching from `FluentIterable` to streams is a `filter` method that takes a `Class<T>` argument and returns a `Stream<T>`. Maybe Guava could provide a utility for this?

Doing it manually like `stream.filter(o -> o instanceof MyClass).map(o -> (MyClass)o)` involves having to specify `MyClass` twice and is not safe against accidental modifications of only the latter operation. Furthermore I prefer to avoid manual casts where possible because someone reading the code would always need to ask themselves whether the cast is actually safe.

I see two ways a utility method could be done:
- A method `<T> Stream<T> filter(Stream<? extends T> stream, Class<T> cls)`. Unfortunately this breaks the fluentness.
- A method `<T> Function<? extends T, Stream<T>> filter(Class<T> cls)` which could be used with `Stream.flatMap`. Unfortunately, this adds extra object allocations.

I am not sure which of these would be better, partially because I am unsure what kind of guarantees and optimizations might be lost when using the `flatMap` approach (given that using `flapMap` makes it impossible to use any information about the size of the input stream, whereas with a combination of `map` and `filter` it is still knowable that the resulting size is at most the size of the input stream). This is one of the reason why I think it would be beneficial for Guava to add it instead of just implementing it myself. @PhilippWendler , you can also use

    stream.filter(MyClass.class::isInstance).map(MyClass.class::cast)

I admit it still duplicates `MyClass` but at least is less explicit. I usually format it on single line even if every element of fluent chain is otherwise on its own line. An other approach is to define the function
```java
public static <S, T extends S> Function<S, Stream<T>> subclasses(Class<T> clazz) {clazz) {
    return x -> clazz.isInstance(x) ? Stream.of(clazz.cast(x)) : Stream.empty();
}
```
and then use `stream.flatMap(subclasses(MyClass.class)`.  yeah, the overhead is very `tiny`
but how does this sound ? LOL, you mean manually do the inlining. 
IdentityHashMap, I just felt this new class never gets used.   Pls make ListIterator impl used here com.google.common.collect.Lists.ReverseList#listIterator a separate public class and/or provide static method to create it somewhere.
Now I can reverse list itself but not listIterator @guai Can you explain why you want this static method to be exposed? Have you already considered `Lists.reverse(theList).listIterator()`? If so, can you explain why it doesn't meet your needs? That's exactly it. I have some API method returning ListIterator and not list itself. And then I need to iterate it in reverse order. Actually wrap it in reverse iterator and pass to another already existing class which accepts iterator. ListIterator is itself an iterator. So this Reverseing anonymous class from ReverseList#listIterator does exactly what I need.  Of course I can do it once again myself, but its already there hidden. I think expose it is a good idea @lowasser, I have the control. And I already did it. But my rule of thumb when I deal with collections is to check if there something already done in guava. In this case it is, but hidden.
Is there any smell in code that returns a ListIterator instead of List which I'm not aware of?
I see no problem in this API. @guai I can't speak for @lowasser, but I think the main problem with an API that returns `{List}Iterator` is that if one needs to go through (or traverse over) the elements in the `{List}Iterator` more than once, or in a different order (like reverse order), then the only option is to _copy_ the elements in the `{List}Iterator` into an intermediate data structure, like an `ArrayList`. Understandably, this copying wouldn't be memory or time efficient.

If your API were to return `Stream`, then that would be a little bit better because one could then perform functional operations like `map` and `filter` easily. However, in this case it doesn't solve the problem that you need to reverse it, as Streams can only be traversed once like {List}Iterators.

In this case, if you could make this API of yours return a `List`, then that would allow you to create your own "reverse view" class and solve your problem efficiently. This is because (1) lists have a finite number of elements that you can query with `size()`, and (2) you can easily access elements in a list in reverse order using `get(size() - index + 1)` (as shown in Lists.ReverseList#reverseIndex) without putting them into a new list.

And since Guava already provides a reverse-view class for lists via  `Lists.reverse`, you don't even need to implement it yourself. Thus, if you can somehow make your API return a `List`, you can then easily write `Lists.reverse(yourApi()).iterator()` and pass the resulting iterator to your other API, solving your problem efficiently both memory- and time-wise.

I hope this helps. @jbduncan, but ListIterator doesn't have to be backed by a list. Its just something traversable in both directions. API may do something more than just be a list, it may (I dunno) notify some other services about content being iterated etc.
To implement a list is more of a trouble. And in this case one should implement ListIterator anyway. To return custom ListIterator looks quite reasonable to me.

I don't like the assymetry here. Its like a blind spot. Some useful class was written but I cannot use it. Hi @guai,

> but ListIterator doesn't have to be backed by a list.

You're right, it doesn't.

But if it isn't backed by a list, then that would surprise maintainers in the future, wouldn't it? I'd argue that misusing `ListIterator` like this makes this API harder to understand and use.

Is this API something you have control over? If so, I'd encourage you to replace its return type with a custom interface that has whichever methods from `ListIterator` that you need.

If not, then I think the most reasonable solution would be something like,

```java
ListIterator<T> listIterator = theListIteratorReturningApi();
Iterator<T> reverseIterator = Lists.reverse(ImmutableList.copyOf(listIterator)).iterator();
theReverseIteratorAcceptingApi(reverseIterator);
```

> To return custom ListIterator looks quite reasonable to me.

Please correct me if I missed something, but by my understanding (and [@lowasser's](https://github.com/google/guava/issues/2706#issuecomment-271952523) apparently), it's not possible to implement an efficient reverse-view of a `ListIterator` unless it's backed by a list, because the reverse-view needs to call `backingList.size()` to implement `nextIndex()` and `previousIndex()` in O(1) time. @lowasser summarised it nicely for me. :) Ok then. Gone inventing the wheels :(  In the [new docs for `Ordering#greatestOf()`](http://google.github.io/guava/releases/21.0-rc2/api/docs/com/google/common/collect/Ordering.html#greatestOf-java.lang.Iterable-int-), there's a hint for Java 8 users:

> Use `Streams.stream(iterable).collect(Comparators.greatest(k, thisComparator))` instead.

Yeah, well, [`Comparators`](http://google.github.io/guava/releases/21.0-rc2/api/docs/com/google/common/collect/Comparators.html) doesn't have `Comparators.greatest()`, does it? Am I missing an obvious method on `Stream` that would do the right thing? Ah, good, thank you!

During the day I took a look at the Ordering implementation and it does a
full sort on the data, anyway :(. For that

    ImmutableList.of("a", "b", "c", "d", "e", "f")
        .stream()
        .sorted(Comparator.comparing(str -> str.toString()))
        .limit(5)
        .collect(Collectors.toList());

might be good enough. I hoped to see a O(n) solution.

EDIT: Yes, I'm blind. The main line is O(n). Soooooo, how busy are you on a scale from 1 to 10? Guava needs your sweet, sweet code with `Ordering#greatestOf()`... Thank you. Doesn't matter when the code is there, before 22 lands would be nice.
I really appreciate what you guys are doing, keep it up!  Is there a way to invalidate an entry without causing removal listeners to be triggered? 

I want the removal listener to execute when an entry expires after a certain amount of time, not when it is invalidated manually.

Thanks.  Indeed. Give me some time, please. I need to collect my thoughts.
 You are right that keyFunction is equally useful as countFunction. I was concerned about the similarity of
* `toImmutableMap(Function keyFunction, Function valueFunction)` to
* `toImmutableMultiset(Function elementFunction, ToIntFunction countFunction)`.

The former one throws if there is at least one duplicate key mapping. The latter uses implicit, although obvious "mergeFunction" (addAll). This is fully described in javadoc, which I missed. No more confusion probably.

`Multisets.toMultiset` with `Supplier` looks good too (as good as already existing `Multimaps.toMultimap`).

I perceive no natural-order collectors as a design decision as every ImmutableSorted* collector requires explicit Comparator. That's consistent and clear. I can live with `naturalOrder()`.

In short, proposed API seems appropriate.

I keep my fingers crossed for a positive result of the review! ;) Almost there? See https://github.com/google/guava/commit/6df8b3ca1d1d6b2dfe3aff0316079da61937eef9#commitcomment-20466808 - and don't kill me, please.

It's very nice that you decided to expose these Collectors. Thank you again! @lowasser Could you, please, check above? It's just about renaming (and consistency). I can't wait to mark this as resolved. @lowasser I think this can be closed because of 15c2b77. @lowasser I think that there is still one thing missing: wildcards. I came to this today, when I tried to replace my own implementation with delegation to `Multisets.toMultiset`. I wish I had noticed this before.

Instead of
```
public static <T, E, M extends Multiset<E>> Collector<T, ?, M> toMultiset(
      Function<T, E> elementFunction,
      ToIntFunction<T> countFunction,
      Supplier<M> multisetSupplier
)
```

one would expect
```
public static <T, E, M extends Multiset<E>> Collector<T, ?, M> toMultiset(
	Function<? super T, ? extends E> elementFunction,
	ToIntFunction<? super T> countFunction,
	Supplier<M> multisetSupplier
)
```

See `Mutlimaps.toMultimap` which is similar but correct. @cpovirk Well, it's still inconsistent with [ImmutableMultiset.toImmutableMultiset(Function, ToIntFunction)](https://google.github.io/guava/releases/22.0/api/docs/com/google/common/collect/ImmutableMultiset.html#toImmutableMultiset-java.util.function.Function-java.util.function.ToIntFunction-). Does it have to be? Please, please, just use PECS. It is not only more flexible but also more idiomatic. @cpovirk Check [ImmutableSortedMultiset.toImmutableSortedMultiset(Comparator, Function, ToIntFunction)](https://google.github.io/guava/releases/22.0/api/docs/com/google/common/collect/ImmutableSortedMultiset.html#toImmutableSortedMultiset-java.util.Comparator-java.util.function.Function-java.util.function.ToIntFunction-) too! @lowasser Could you please take a look? @kevinb9n Any chances before Guava 23?  Repeatedly applying Sets.intersection(...) should not result in stack overflow error. 
Attaching a unit test to reproduce the current (erroneous?) behavior (using 'com.google.guava:guava:21.0-rc1'):

    import com.google.common.collect.Sets;
    import org.junit.Test;

    import java.util.HashSet;
    import java.util.Set;

    import static java.util.Arrays.asList;
    import static org.hamcrest.MatcherAssert.assertThat;
    import static org.hamcrest.Matchers.equalTo;
    import static org.hamcrest.Matchers.hasSize;

    public class IntersectionTest {
      @Test
      public void shouldNotResultInStackOverflow() {
        Set<String> set1 = new HashSet<>();
        Set<String> set2 = new HashSet<>(asList("4", "5"));
        for (int i = 0; i < 30000; i++) {
            set1 = Sets.intersection(set1, set2);
            assertThat(set1, hasSize(equalTo(0)));
        }
      }
    }  Hi! I checked some of the new brilliant features of 21.0-rc1 (thanks!) and here's what I found.

1. `Multimaps.toMultimap(Function, Function, Supplier)`
    * `com.google.common.base.Function` should be `java.util.function.Function`
    * `com.google.common.base.Supplier` should be `java.util.function.Supplier`

2. `Tables.toTable(Function, Function, Function, Supplier)`
    * change `com.google.common.base.Supplier` to `java.util.function.Supplier`

3. `Sets.toImmutableEnumSet()`
    * the name is confusing as it returns `ImmutableSet`, not `ImmutableEnumSet`
    * is renaming to `Sets.toImmutableSet` possible?
    * how about additional `ImmutableEnumSet.toImmutableEnumSet` returning `Collector<E, ?, ImmutableEnumSet<E>>`?

4. `ImmutableMultiset.toImmutableMultiset(ToIntFunction)`:
    * could you, please - if at all - expose above instead of
`toImmutableMultiset(Function, ToIntFunction)`? *

5. `ImmutableSortedMultiset.toImmutableSortedMultiset(ToIntFunction)`
    * could you, please - if at all - expose above instead of
`ImmutableSortedMultiset.toImmutableSortedMultiset(Comparator, Function, ToIntFunction)`?  *

6. Multisets again; please, consider adding following methods returning Collectors**:
    * `EnumMultiset.toEnumMultiset()`
    * `EnumMultiset.toEnumMultiset(IntFunction)`
    * `HashMultiset.toMultiset()`
    * `HashMultiset.toMultiset(IntFunction)`
    * `LinkedHashMultiset.toMultiset()`
    * `LinkedHashMultiset.toMultiset(IntFunction)`
    * `TreeMultiset.toMultiset()`
    * `TreeMultiset.toMultiset(IntFunction)`
    * `TreeMultiset.toMultiset(Comparator)` for `<E extends Comparable<? super E>>`
    * `TreeMultiset.toMultiset(Comparator, IntFunction)`
    * `ImmutableSortedMultiset.toImmutableSortedMultiset()` for `<E extends Comparable<? super E>>`

*) `Function` parameter seems to be unnecessary. I believe it's more idiomatic to use `Stream.map(Function).collect(toImmutableMultiset(ToIntFunction))` and/or `Collectors.mapping(Function, toImmutableMultiset(ToIntFunction))`.

With the best wishes! **) `Multisets.toMultiset(Supplier)` and `Multisets.toMultisets(IntFunction, Supplier)` could be useful for implementing mutable Multisets collectors, but you surely know that... Thank you for quick reply!

> Many of the mutable Multiset collectors you mention can be done with the JDK built-in Collectors.toCollection(Supplier) (...)

That's true. If you would like to expose `.toMultiset(IntFunction)` or `.toMultiset(Function, IntFunction)` however, consider no-arg method too.

> We consciously do not expose an ImmutableEnumSet type (...)

My mistake, can't agree more. Forget about it.

> As far as the c.g.c.b versus j.u.f function issues go, we expect ~all users of these functions to be passing in lambdas and method references for which there is no meaningful difference.

Please, be consistent within the same class at least. `toTable(Function, Function, Function, Supplier)` uses `c.g.u.b.Supplier`, but `toTable(Function, Function, Function, Supplier)` - `j.u.f.Supplier`.

And please, be careful with expectations like the above. They may be true for most of the time, but I've already encountered cases where I wanted to pass *named* j.u.f parameters to the latest Guava methods and I couldn't (I've implemented my own multiset collectors; I wanted to deprecate some of them now, temporarily delegating to Guava collectors; couldn't just pass params which were declared as j.u.f since the beginning; not a great problem, but...).

Also, if your assumption was entirely true, c.g.u.b.Function wouldn't extend j.u.f.Function.

> As regards your footnote, I would absolutely expect the Function type to be necessary for many uses (...)

I've always treated `Multiset` as something more similar to `Set` than a `Map`. It is a `Collection`, right? (being a map is an implementation detail). That's why elementFunction suprised me. BTW note that `ImmutableMultiset` *collector* is inconsistent with `ImmutableMap` about duplicates. It may be also an argument against `ToIntFunction` TBH.
 Thank you! What about `Suppliers.memoize` family (or any `Funtions` and `Suppliers` stuff) - will there be any changes there? I know it's a bit different case, and supplier::get should work there, I'd just like to know if there will be any overloads / migrations there. Thanks for clarification!  I'm a BIG fan of immutables in Guava. ImmutableList, ImmutableMap, etc.

However, some packages might not want to swallow ALL of Guava just to provide immutable APIs.

Further, there are issues with Guava versioning.  

If we had a guava-immutable module that we can just depend on which ONLY had the immutable collection support this would solve that problem.
 > Further, there are issues with Guava versioning.

What sort of issues are you referring to? How would splitting Guava up into numerous (presumably interdependent) packages make version-hell easier?

See also https://github.com/google/guava/issues/1087 The version conflict would be mitigated if guava-immutables package had a different version number.

guava-N could depend on any version of guava-immutables though.

We are on Guava 15 internally due to a broken dependency issue with another package (long story). 

 What about [Proguard](https://github.com/google/guava/wiki/UsingProGuardWithGuava)?  https://github.com/google/guava/wiki/NewCollectionTypesExplained#multimap

Actual:
"You can and should cast asMap.get(key)"

Should Be:
"You can and should cast asMap().get(key)"  Fixes issue #1597   When I'm creating my graph, I don't know all the nodes/edges, so I use proxies like the ids of the nodes and the ids of the edges while registering the edges and nodes as they come in. Think of this as a stream being parsed where the node 1 says "I'm linked to 2 and 4", but we haven't parsed 2 nor 4 already.

When I'm done creating it, I'd like to have a copy of the graph but with the actual nodes and edges. So similarly to all the `Maps.transform*` methods, I'd like to have `Graphs.transform*` methods where applicable.

The only alternative I see is to create proxy items before creating the graph, but that's a heavy burden on the user,  Thanks for your considerations, both of you.

What you showed as example, @jrtom, is exactly what I'm looking for. I'm mostly working with value graphs at the moment so I'd expect indeed more methods than the one you developed.

Regarding your solutions 1 and 2, while I didn't think of them (it's the first time I work with graphs), they don't seem very Guava-esque because option 2 doesn't allow immutable node objects and option 1 isn't very flexible.

Also, since I consider this as IO deserialization, I don't care about the performance because the IO latency seems far greater than the creation of a new graph from memory objects. @jrtom I actually wonder if it's a bit premature to close this issue, because Bazel's BUILD_file_generator has a [function](https://github.com/bazelbuild/BUILD_file_generator/blob/dfa872bb8f60d679707a53f2dd2eb93b106710bf/src/main/java/com/google/devtools/build/bfg/ClassToSourceGraphConsolidator.java#L60-L91) which is vaguely similar to what I understand this issue is requesting, and it specifically comes with a note saying:

```text
// TODO(bazel-team): Migrate this function into Guava graph library
``` (@jrtom I just happened to discover the project when browsing the [bazelbuild](https://github.com/bazelbuild) org page a few days ago (Bazel's interested me for a while now), and in turn I got curious about the project's implementation, so I skimmed over its internal files. I just happened to view a particular file, and in the process I found that particular comment.

Kind of a cool coincidence, I'd say. :smiley:) Okay, sounds like a good reason to keep this issue closed for now then. Anything to keep the open issues reasonably less cluttered is a good thing in my book. :+1:   Please avoid putting Exception with a capital E into strings.  These end up in logs and cause headaches for both manual and automated things that look for such a string.  I've seen lots of regexes changed from 'Exception' to '[^d]Exception' to work around this.  Which will work fine until someone throws an exception that ends with a d.

```
  @Override
  public String toString() {
    return MoreObjects.toStringHelper(this)
        .add("hitCount", hitCount)
        .add("missCount", missCount)
        .add("loadSuccessCount", loadSuccessCount)
        .add("loadExceptionCount", loadExceptionCount)
        .add("totalLoadTime", totalLoadTime)
        .add("evictionCount", evictionCount)
        .toString();
  }
```  Random string generator and unit tests I signed it! Hi @havlip18, have you taken the time to read the [contribution guidelines](https://github.com/google/guava/blob/master/CONTRIBUTING.md) yet? 🙂 General remarks:

* The nomenclature is rather odd considering it's Guava.
* I should be able to provide my own `Random` instance. It's important for testing and safe-threading
* I'd use a `String` insead of a `char[]` as it's so much more legible.
* Regarding the original issue, I keep my idea that I should be able to store a generator. Your implementation doesn't do that. This is the biggest win of having the issue implemented. i signed it plz recheck ##line 148 
public static String random(int len, char start, char end) {..} 
or
public static String randomNumeric(int len, char start, char end) {....}
 How about filling Appendable? For exapmple:
```java
public static void randomNumeric(int len, char start, char end, Appendable target)
```
It may be useful for Writers and StringBuilders.  Added test cases for bug regarding incosistency between Ints.tryParse
and Longs.tryParse to show there is no defect. I signed it!  Please consider adding the method `splitToArray(String)` to `Splitter`.

## Why do I want it?

1. Because I often use arrays internally when reading speed matters more than the rest.
2. Because `Splitter.splitToList(String)` was added in release 15 and an array counterpart seems totally acceptable for the same reasons `Splitter.splitToList(String)` was added..
3. Because splitting to arrays is the default Java implementation (`String.split(String)`) and I'd kind of expect `Splitter` to provide if not the same behavior (luckily) at least the same output type.
4. Because repeating `String` at least once is too verbose for such a simple use case. All alternatives need the text `String` to be written at least one extra time.

## What alternatives can I use?

I saw several ways to write this but none are really convincing:

### Guava one-liner

    String[] split = Iterables.toArray(splitter.split(text), String.class);

I'm not convinced by this, especially when I see that [StringsExplained](https://github.com/google/guava/wiki/StringsExplained) still recommends using `Lists.newArrayList(splitter.split(text))` even though `Splitter.toList(String)` exists. Also, since it's obvious we're using `String`s, I don't see why I'd have to repeat `String` several times.

### Inline, no cast, but reflection

     String[] split = splitter.splitToList(text).toArray(new String[0]);

This is rather easy to write in one line, but has the strong disadvantage to internally use reflection (because you rarely get an array of length 0 when you split from an unknown length). Again, the repetition of `String` as a type narrower is annoying.

### Inline, cast

    String[] split = (String[])splitter.splitToList(text).toArray();

The casting is rather obvious, but using Guava, I don't expect to cast very often, actually. There are lot of tools that help us avoid this. Once more we have to declare the expected return type when all I want is to split `String`s.

### Optimized (?)

    List<String> splitList = splitter.splitToList(text);
    String[] split = splitList.toArray(new String[splitList.size()]);

Probably the best answer in regards to speed (hopefully), but is on two lines because it has to use a variable. Also, this is totally redundant The fourth variant [may](https://shipilev.net/blog/2016/arrays-wisdom-ancients/) in practice not be faster than the second variant.  sometimes I need to merge List&lt;A&gt; and List&lt;B&gt; to List&lt;C&gt;, the object of A and B have a combine property such as id. Is there any function like below？
```
List<T> merge(List<F1> list1, List<F2> list2, Function<T, F1, F2> func);
``` Hmm, I admit it's not entirely clear to me what it is you want to do here @memimy2015.

Are you trying to find a way of
1. creating a list containing `list1`'s elements followed by `list2`'s elements
2. and then transforming the elements in the new list using `func`? sorry.  @jbduncan
for example.
```
class Student{
    long studentId;
    String name;
}
class Exam{
    long studentId;
    int score;
}
class ScoreRecord{
    String name;
    int score;
}
List<Student> students;
List<Exam> exams;
List<ScoreRecord> table = somefunction(students, exams, (student, exam) -> {
    if(student.getStudentId == exam.getStudentId) {
        return new ScoreRecord().setName(student.getName).setScore(exam.getScore);
    }else{
        return null;
    }
});
````
use 'somefunction' I can join the two objects by some key into object of other class  and collect as a list.
do I express it clearly? I didn't understand what you meant by "by some key", but I think the rest of what you said made sense to me.

Am I right to understand now that you're trying to combine `students` and `exams` in such a way that each corresponding element from the two lists gets transformed into a `ScoreRecord` (so something like the following, except in a more concise way)?

```java
List<String> names = ImmutableList.of("Jonathan", "Mark", "Philip");
List<String> ages = ImmutableList.of("22", "30", "18");
class Record {
	final String name;
	final String age;

	Record(String name, String age) {
		this.name = name;
		this.age = age;
	}
}
ImmutableList.Builder<Record> recordsBuilder = ImmutableList.builder();
for (int i = 0; i < Math.min(names.size(), ages.size()); i++) {
	String name = names.get(i);
	String age = ages.get(i);
	recordsBuilder.add(new Record(name, age));
}
ImmutableList<Record> records = recordsBuilder.build();
```

If so, then you'll probably have to wait until _Guava 21.0_ is released, as it will have a new [`Streams.zip`](http://google.github.io/guava/releases/snapshot/api/docs/com/google/common/collect/Streams.html#zip-java.util.stream.Stream-java.util.stream.Stream-java.util.function.BiFunction-) method which does exactly that but for streams. (I presume from your usage of a lambda expression in your last message that you know how to turn lists into streams.)

I presume that when _21.0_ is released, you'd use `Streams.zip` like this:
```java
Stream<Record> recordsStream = 
    Streams.zip(
        names,
        ages,
        (name, age) -> new Record(name, age));
// or
recordsStream = Streams.zip(names, ages, Record::new);

// you'd then transform it into a list if needed, either an immutable one (recommended if possible)...
ImmutableList<Record> records = recordsStream.collect(ImmutableList.toImmutableList());
// ...or a mutable one.
List<Record> mutableRecords = recordsStream.collect(Collectors.toCollection(ArrayList::new))
// Or if it doesn't matter to you...
List<Record> records2 = recordsStream.collect(Collectors.toList());
``` There is a litter different. The two object student and exam must match the condition of 'student.getStudentId == exam.getStudentId', when it can generate a new object of ScoreRecord.@jbduncan @memimy2015 What type of list would this method return? I have not thought about it, any type is ok, ImmutableList, List ... @liach An immutable list would be the easiest to implement. Hi @memimy2015, there's a detail which I'm still unsure about regarding what you want to achieve, so I wonder if you could clarify things further for me.

Do you want to compare elements like this (before checking on a particular "key")...
```
students.get(0) <-> exams.get(0)
students.get(1) <-> exams.get(1)
...             <-> ...
students.get(N) <-> exams.get(N)
```

...or like this?
```
students.get(0) <-> exams.get(0)
students.get(0) <-> exams.get(1)
students.get(0) <-> ...
students.get(0) <-> exams.get(N)
students.get(1) <-> exams.get(0)
students.get(1) <-> exams.get(1)
students.get(1) <-> ...
students.get(1) <-> exams.get(N)
...             <-> ...
students.get(N) <-> exams.get(N)
``` @jbduncan Should be the first one, or you won't pass lists as arguments. Hi @liach, could you explain further why you think it should be the first one? I ask as I'm struggling to understand your explanation of "or you won't pass lists as arguments". If it is the type below, then the method would be named `cartesianMerge` like `Lists.cartesianProduct`. Although you can also add `cartesianMerge`, though it would be used very rarely. For cartesian merge, you can use two iterables to iterate and get products. But for the two lists, they need the `size()` method to ensure a merge can be done.  > If it is the type below, then the method would be named cartesianMerge like Lists.cartesianProduct.

Hmm, did you mean to sound so presumptuous? I struggle to see how you came to the conclusion that @memimy2015 definitely wanted a normal merge over a Cartesian merge. As far as I can tell, they've given no indication so far that they wanted one over the other. So may I kindly ask for the future that you do not jump to conclusions so quickly and to wait to hear from @memimy2015 themselves before answering my question for them?

> But for the two lists, they need the size() method to ensure a merge can be done.

Not necessarily. It's possible to "merge" or "zip" (or whatever term you think best describes this idea) two sequences _without_ a predefined size, by simply merging until one of the two sequences is exhausted. See [`Streams.zip`](https://google.github.io/guava/releases/snapshot/api/docs/com/google/common/collect/Streams.html#zip-java.util.stream.Stream-java.util.stream.Stream-java.util.function.BiFunction-) for an example of what I mean. If I understood the original request correctly, it's not a 'zip' operation because elements should match based on their key, not on their positions. So if lists are not sorted, there should be additional operation to find the matching element by key, something like
```java
Map<Long, Exam> examByStudentId = Maps.uniqueIndex(exams, e -> e.studentId);
List<ScoreRecord> records = Lists.transform(students, student -> {
    Exam exam = examByStudentId.get(student.studentId);
    return new ScoreRecord(student.name, exam.score);
});
``` @loki-1 The point is that `List`s are ordered, compared to `Collection`s and `Iterable`s. The order of the elements in the list is based their positions instead of some other key. @loki-1 Correctly! Your method can solve my request. I want to know if there is a method I can do this by 1 line code. @liach Sorry, I don't understand what do you mean. List order may or may not be consistent with key order depending on how inputs are generated.

@memimy2015 I doubt if it should be 1 method, because you have at least 2 different operations: matching items from 2 lists and mapping them into output item. ```
students.get(0) <-> exams.get(0)
students.get(1) <-> exams.get(1)
...             <-> ...
students.get(N) <-> exams.get(N)
``` @liach I still don't see how lists are special here. For this to work, you need both input collections to be sorted in compatible way. It can be achieved with Lists, SortedSets, LinkedHashSets and so on.
```
studentsIterator.next() <-> examsIterator.next()
studentsIterator.next() <-> examsIterator.next()
...
``` Ok.  This format is becoming a thing. I couldn't find it in Guava's media types. I signed it!  Hello,

Would it be legit to add an AtomicLongMap.create(ConcurrentMap) method which keeps the provided Map as undelrying ConcurrentMap? it would typically used over a ConcurrentSkipListMap to provide ordering over keys.

Thanks I see your points. This is note a strong requirement on my side, and as you said, Java 8 provides nice alternatives. Thanks  Please add audio content-type 'audio/vorbis', 'audio/x-wav' to com.google.common.net.MediaType and ability to create MimeType using full name of mime-type, for example:

MimeType.create("audio/x-wav")  …tive iterators #2666 There is soo much overhead in this implementation... And streams unavailable: guava support java 6+ .. Next Guava will require Java 8  Unless I'm missing something, the method `UnsignedInts.checkedCast(long val)` seems to be missing. This method is available for all of the smaller types (e.g., bytes) in both signed and unsigned variants. It is also available in `Ints` for signed values. 

There doesn't seem to be a particular reason for the omission, since there doesn't seem to be any particular implementation difficulty and it exists in almost all the other "unsigned" variants.

This method is needed and useful for the same reason as all the other `checkedCast` variants. Just adding a workaround until the method is added:

`UnsignedInteger.valueOf(val).intValue()`

Of course, this unnecessarily creates an UnsignedInteger object, although escape analysis will often be able to eliminate it. Wow, haha, I had added `UnsignedShorts` locally to work around issue #670 and I failed to notice it was local while writing the above (that's why it had so few methods). I think the rest of the reasoning still holds though.  I edited my initial report so it makes more sense.  Perhaps I'm going crazy and doing something incredibly stupid, but my understanding is that the attached code should output 2, and at some point call TestObject.equals; it returns 0 and seems to never even call my defined equals() method. Everything in the specs that I read says that's how it should work, so either the doc is unclear or something is funky. Needless to say calling Objects.equal(new TestObject(7), new TestObject(7)) returns true. Additionally, Collections.frequency(ms, new TestObject(7)) returns 2, as it should. I was under the understanding they should return the same thing?

Guava version is 20.0.

is this expected behavior?
`
package ExcelMLTesters;

import com.google.common.collect.HashBasedTable;
import com.google.common.collect.HashMultiset;
import com.google.common.collect.Multiset;
import com.google.common.collect.Table;

import java.util.Objects;

public class GuavaTableTester {

    private static class TestObject {
        private int val;

        @Override
        public boolean equals(Object obj) {
            System.out.println("I'm comparing "+ this.toString() +"  and " + obj.toString());

            if (obj instanceof TestObject)
                return this.val == ((TestObject)obj).val;

            return false;
        }

        public int getVal() {
            return val;
        }

        public void setVal(int val) {
            this.val = val;
        }

        public TestObject(int val) {
            this.val = val;
        }

        @Override
        public String toString() {
            return "TestObject{" +
                    "val=" + val +
                    '}';
        }
    }
	public GuavaTableTester() {
		// TODO Auto-generated constructor stub
	}

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		Table table = HashBasedTable.create();


		table.put("a", 1, new TestObject(5));
		table.put("a", 3, new TestObject(3));
        table.put("b", 1, new TestObject(7));
        table.put("c", 1, new TestObject(7));
        table.put("d", 1, 1);
        table.put("e", 1,1);




        Multiset ms = HashMultiset.create(table.column(1).values());

        // Call me crazy, but shouldn't this output 2 and call TestObject.equals() at some point?
        System.out.println(ms.count(new TestObject(7)));
	}

}
` Yep - thank you! that did indeed work - and I did violate the hashCode contract - but FYI:

Collections.frequency actually works as expected. TestObject.equals() was **never called**, whereas in Collections.frequency it is. 

The documentation for Multiset states that the equals() method is called, unless other specified by the implementation, the implementation doc for HashMultiset does not specify otherwise.

Maybe that should be called out as a caveat for HashMultiset and its friends - as other people may be caught unawares. The part I'm referring to is, for instance, here:
http://google.github.io/guava/releases/20.0/api/docs/ - the doc for Multiset says under the general heading.

"A multiset uses Object.equals(java.lang.Object) to determine whether two instances should be considered "the same," unless specified otherwise by the implementation."

It also says, under count() : "Note that for an Object.equals(java.lang.Object)-based multiset, this gives the same result as Collections.frequency(java.util.Collection<?>, java.lang.Object) (which would presumably perform more poorly)."

The HashMultiset doc repeats the same - maybe it would be a good idea to make it explicitly understood for idiots like me that you have to make sure that hashCode is implemented.

And yes, I know it was a braindead violation of the contract by me - but it might be worth noting that equals() is not the only thing that is called in these cases (unlikely Collections.frequency which seemed to not care).

 Absolutely fair, @jrtom , that was an amateur hour mistake by me, but maybe there's a way to disambiguate the documentation is all.  Oh I agree; the reason that I went down the rabbit hole is that the doc explicitly said it uses equals() like Collections.frequency() unless the implementation doc says otherwise, and the implementation doc wasn't very clear in saying otherwise (although it should be freaking obvious to me, since it is backed by a hash table, duh).  Add collectors for `enum`-specialized `ImmutableSet` and `ImmutableMap`:

- `toImmutableEnumSet()`
- `toImmutableEnumMap(keyFunction, valueFunction)`
- `toImmutableEnumMap(keyFunction, valueFunction, mergeFunction)`

Providing these collectors in Guava would be a matter of convenience.  Users could implement functionally-equivalent collectors themselves, but I think most users would not do so.  I think `enum`-specialized collections are underused and that it is worthwhile to promote their usage and remove friction / barriers to entry.

For example, if a user has code like this:

```java
ImmutableSet<Month> months = stream.collect(ImmutableSet.toImmutableSet());
```

... then it would be cool if they could optimize their code like this:

```java
ImmutableSet<Month> months = stream.collect(ImmutableSet.toImmutableEnumSet());
```

... and it would be lame if they had to do this (it would be so lame that they wouldn't bother):

```java
ImmutableSet<Month> months = stream.collect(SomeHelper.toImmutableEnumSet(Month.class));

// Elsewhere... javadoc and tests omitted...
public static <E extends Enum<E>> Collector<E, ?, ImmutableSet<E>>
toImmutableEnumSet(Class<E> elementType) {
  Objects.requireNonNull(elementType);
  return Collectors.collectingAndThen(
      Collectors.toCollection(() -> EnumSet.noneOf(elementType)),
      Sets::immutableEnumSet);
}
``` Hi: I have been working on this issue and discovered that the fauxverride tests are failing because the original equals code no longer works. Specifically, `K extends Enum<K>` as a type literal's equals method depends on the place where it is declared and its name. (The code can be found under sun.reflect.generics.reflectiveObjects.TypeVariableImpl's equals method).

I was able to fix the tests by simply comparing the result of `Type::getTypeName`, however, this is not correct as it is also sensible to the specific name of the generics declared.

Maybe this should be its own issue? I am not sure what the correct fix would be. Any input would be much appreciated! @tli2 Oh, gross!  I hadn't considered that `ImmutableSortedSet` and friends might "inherit" these methods.

Part of me wants to call that a problem with `FauxveridesTest`.  I don't understand the reason that `MethodSignature` cares about the generic type parameters for equality.  As long as the method names and parameter types are the same, shouldn't javac enforce that the generic type parameters are also the same?  (I'm sure I'm missing something.)

In any case, I don't think it's essential that these methods live in `ImmutableSet` and `ImmutableMap`.  That home would be good for discoverability, but maybe that home would be bad for other reasons that include this fauxverides issue.  If these methods instead lived next to `Sets.immutableEnumSet(...)` and `Maps.immutableEnumMap(...)` (for example), they would still be useful. Fair enough. I can move my code. Do you think I should report a separate issue on the test? > Fair enough. I can move my code. Do you think I should report a separate issue on the test?

Unless it's causing other problems, I wouldn't bother.  I'm just a random guy from the internet though... Guava 21.0 shipped with `com.google.common.collect.Sets.toImmutableEnumSet`. If the Guava team does not plan to add the other two types of collector, then this issue can be closed. They did add the other two as well.  Thanks! D'oh I was looking in the wrong place. You're right! Nice.  Add the following methods:
```java
public class Iterators {
   // ...
   public static PrimitiveIterator.OfInt toIntIterator(Iterator<Integer> iterator);
   public static PrimitiveIterator.OfLong toLongIterator(Iterator<Long> iterator);
   public static PrimitiveIterator.OfDouble toDoubleIterator(Iterator<Double> iterator);
}
``` Also, Java standard library has no methods for getting empty iterators:
```java
public static PrimitiveIterator.OfInt emptyIntIterator();
public static PrimitiveIterator.OfLong emptyLongIterator();
public static PrimitiveIterator.OfDouble emptyDoubleIterator();
```  `RangeMap` doesn't coalesce connected ranges (by design), and it would be nice if there were a built-in way to coalesce connected ranges if they have the same value. For example:

    {[0..1): 1, [1..2): 1, [2..3): 2}

Is roughly equivalent to:

    {[0..2): 1, [2..3): 2}

And it can be both a time and space savings to be working with a smaller data structure. Particularly for a case such as a `RangeMap` built up from `Range.singleton()` keys a `coalesced()` operation could save a lot of resources. Definitely; I'd expect it to be a copy operation as a live view would eliminate the benefit of reducing the underlying number of ranges in use (and probably be much more complex to implement). `ImmutableRangeMap.coalescedFrom(RangeMap)` could also work. We opted to add a mutating `.putCoalescing()` operation rather than a copy or a view. Please let us know if you have a use case for which this isn't sufficient.  I'm writing a music tracker and I need a sparse table that does everything listed below:

- Fast insertion of elements, at any point.
- Fast removal of elements, at any point.
- Fast insertion of rows and columns, at any point.
- Fast removal of rows and columns, at any point.
- Fast sorted iteration.
- Fast slices/subtables. E.g. if the table has 200 columns and 100 rows (not necessarily densely populated), I wanna be able to get a subtable from row 10 to row 20 and column 20 to column 30. The subtable should have comparable performance to the original table, e.g. remove(1,1) in the original table should be as fast as remove(1,1) in the subtable, even if the subtable is in the middle of the original table.
- Fast indexing is NOT required, and subtables are meant to mitigate this. For iteration, caches of predecessor and successor may speed up the iteration to be O(1) (Ex. the one in [TreeMultiSet.java](https://github.com/google/guava/blob/master/guava/src/com/google/common/collect/TreeMultiset.java#L538-L539)), but the java `TreeMap`'s iteration performance is actually O(log(size)), making `TreeBasedTable` slower in iteration. Here is an analysis of @SoniEx2's requests:
(C: columns' size; R: rows' size)
>- Fast insertion of elements, at any point.

TreeBasedTable: Always O(log(C)+log(R))
>- Fast removal of elements, at any point.

TreeBasedTable: Always O(log(C)+log(R))
>- Fast insertion of rows and columns, at any point.

TreeBasedTable: Rows O(log(R)), Columns O(R*log(C))
>- Fast removal of rows and columns, at any point.

TreeBasedTable: Rows are O(log(R)), Columns O(R*log(C))
>- Fast sorted iteration.

TreeBasedTable: O(R*C) (linear time)
>- Fast slices/subtables. E.g. if the table has 200 columns and 100 rows (not necessarily densely populated), I wanna be able to get a subtable from row 10 to row 20 and column 20 to column 30. The subtable should have comparable performance to the original table, e.g. remove(1,1) in the original table should be as fast as remove(1,1) in the subtable, even if the subtable is in the middle of the original table.

For this one, creating a view would be O(1), all other operations are the time above, but a clone would be way slower in creation. (guess linear time)
>- Fast indexing is NOT required, and subtables are meant to mitigate this.

I do not understand what you mean by "mitigate". :confused:  Views should be invalidated if the backing table is modified. The reason for this is that they should hold direct references to the internal data structures so the subtable is actually smaller than the real table, thus providing faster access times.

A subtable at (100, 100) should have the same performance (NOT complexity) as one at (1, 1), given that both have the same size. Maybe this is a very specialized use-case after all... Sorry.  It is one important issue need to be fixed to support most cases which values may contain the separator.

for one example:
I can make sure my key can't contain separator. but I can't make sure my value can't contain separator due to the value is generated by third-part service or special codec which can get separator. So I think we should fix this issue. It is common issue for most of case, Throwing IAE isn't reasonable or easier to let's happen low rating bug.

Can someone help to take a look at this PR. Thanks.@cgdecker I signed it! anyone can take a look? @jiafu1115 Should this regard different types of splitters? Or add some method like `ignoreExtraSeparator()`? @liach no. only change the inner behavior for MapSplitter. This is the simplest way to meet requirement.WDYT？Thanks There must be a reason why it throws an exception when detecting more than one separators. You should ping a project manager. @liach I had pinged the issue creator @cgdecker who is also the member for guava but no feedback util now. So I does not know who I should ping. so just waiting now. I think we need to ping the authors of `Splitter`. @lowasser  @liach Thanks for your reminder. We may need to wait and wait and wait...... @eamonnmcmanus Thanks for your change for title, it is more clear now.
  Hi,

at first glance, the following program works as expected. However, it causes constant 12% load on an i7-4790 CPU @ 3.60Ghz:

```java
public static void main(final String[] args) throws InterruptedException
    {
        RateLimiter limiter = RateLimiter.create(0.1);
        Stopwatch sw = Stopwatch.createStarted();
        while (true) {
          if (Thread.interrupted()) {
              throw new InterruptedException();
          }
          if  (limiter.tryAcquire(200, TimeUnit.MILLISECONDS)) {
              System.out.println(sw.elapsed(TimeUnit.MILLISECONDS) + " ms");
          }
 }
```
**So what's wrong with my code?**

The reason for the high CPU usage is that tryAcquire _immediately returns false without waiting_ if it detects that a permit will not become available within the timout period. 

I find this to be very surprising behavior since almost any other Java method that is named `tryDoStuff(timeout)` can be reasonably expected to satisfy _at least one_ of the following postconditions when it returns normally:

- _Stuff_ has been done
- `timeout` has passed

But most of the time, `tryAcquire` will return without satisfying any of those. This is mentioned in the Javadocs but I think it's really easy to read past that part without realizing the consequences. 

If I had to propose a solution, I'd probably introduce a new method called `acquireOrWait` that implements my use case and/or highlight the consequences of early returns in the `tryAcquire` JavaDocs.

Please forgive me if this is a duplicate, I've tried searching first but couldn't find a related issue.

(Guava version: 19.0)  Hi, guys! I have some problem with method construct in ImmutableSortedSet class, cause I've received every time n-1 elements after build ImmutableSortedSet.

I found that this part of code can include a bug:
```
for (int i = 1; i < n; i++) {
      E cur = contents[i];
      E prev = contents[uniques - 1];
      if (comparator.compare(cur, prev) != 0) {
        contents[uniques++] = cur;
      }
    }
```
Why you not process the last one element? I mean this:
`for (int i = 1; i < n; i++)` ![1](https://cloud.githubusercontent.com/assets/11968111/20677455/71fcaaa6-b593-11e6-9ee6-b8513a88dc59.png)
![2](https://cloud.githubusercontent.com/assets/11968111/20677467/7b6c4b0a-b593-11e6-96f7-2f2ff97a71a8.png)
 Hi @MrNikita, are you trying to show us in your screenshots above that the element at index 2 (which starts off as "CC-third") is somehow being overwritten with "AA-last", which you believe to be erroneous behaviour? @jbduncan yes, this behavior is result of overriding "E... contents" parameter inside this method, here: 
 ```
if (comparator.compare(cur, prev) != 0) {
        contents[uniques++] = cur;
}
```

That's why one of these elements in "E... contents" array disappeared (was rewrites with the previous element) :) @lowasser , here is comparing of these objects:

![screen shot 2016-11-28 at 20 17 00](https://cloud.githubusercontent.com/assets/11968111/20682353/f39ab40e-b5a7-11e6-86cd-94c0902f5481.png)
 Its compare of "BB-second" and "CC-third" objects:

` if (comparator.compare(cur, prev) != 0) `

![screen shot 2016-11-28 at 20 39 04](https://cloud.githubusercontent.com/assets/11968111/20683025/c02ae64a-b5aa-11e6-87d6-0388f0d439d7.png)
 This is Kotlin:
```
override fun compareTo(other: RolledSectionRectangularData): Int {
        val keyCmp = compareSortKeyTo(other)
        return if (keyCmp != 0) keyCmp
        else priority.compareTo(other.priority)
    }

    protected fun compareSortKeyTo(other: NamedInfo): Int {
        return Integer.compare(priority, other.priority)
    }
``` ![screen shot 2016-11-28 at 21 06 27](https://cloud.githubusercontent.com/assets/11968111/20684034/94bfa5e6-b5ae-11e6-9921-a041b6b19f44.png)
 Yes, guys, you're right! Thank u a lot for help me with it.  Same here!

Output:

```
[0, 3, 1, 2]
Try to remove 1:
[0, 3, 1]
```

Source:

```
MinMaxPriorityQueue<Long> values = MinMaxPriorityQueue.create();
values.add(2L);
values.add(3L);
values.add(4L);
values.add(0L);
values.add(1L);
values.remove(4L);
System.out.println(values);
System.out.println("Try to remove 1:");
values.remove(1L);
System.out.println(values);
```
 Ridx511ask@pong27runner.exmple.onmicrosoft.com  In order to minimize the risk of integrating `@Beta`-annotated functionalities (especially in libraries), it might be nice to have a tool that we integrate in the compilation process and that produces warnings when a `@Beta`-annotated functionality is used.

I see this as an external Maven artefact that we include if we want to use such functionality, a bit like the tools that generate utilities during the compilation like Dagger or AutoValue.

Hopefully, this is possible without having to change `@Beta`'s retention policy from class to source. I don't really know the arcanes of the compiler so I can't really say...  expected: `NullPointerTester` treats `@CheckForNull` like `@Nullable`
actual: `NullPointerTester` fails if a `@CheckForNull` parameter isn't checked for null.

```
import javax.annotation.CheckForNull;
import javax.annotation.Nonnull;
import javax.annotation.Nullable;

import com.google.common.testing.NullPointerTester;
import org.testng.annotations.Test;

import static com.google.common.base.Preconditions.checkNotNull;

public class FooTest {

  static final NullPointerTester tester = new NullPointerTester();

  static class Foo {
    @Nonnull String a;
    @Nullable String b;
    @CheckForNull String c;

    public Foo(@Nonnull String a, @Nullable String b, @CheckForNull String c) {
      this.a = checkNotNull(a, "a");
      this.b = b;
      this.c = c;
    }

    public String concat(@Nonnull String d, @Nullable String e, @CheckForNull String f) {
      return concatStatic(d, e, f);
    }

    public static String concatStatic(@Nonnull String a, @Nullable String b, @CheckForNull String c) {
      String result = checkNotNull(a, "a");
      if (b != null) {
        result += b;
      }
      if (c != null) {
        result += c;
      }
      return result;
    }
  }

  /*
   * Tests fail complaining that no exception is thrown for parameter 2.
   */

  @Test
  public void testAllPublicConstructors() {
    tester.testAllPublicConstructors(Foo.class);
  }

  @Test
  public void testAllPublicInstanceMethods() {
    Foo foo = new Foo("a", null, null);
    tester.testAllPublicInstanceMethods(foo);
  }

  @Test
  public void testAllPublicStaticMethods() {
    tester.testAllPublicStaticMethods(Foo.class);
  }
}
```
Making this change would be useful for anyone who uses Guava with [FindBugs](http://findbugs.sourceforge.net/). FindBugs takes `@CheckForNull` to mean "this should be checked for null" and `@Nullable` to mean "this should be ignored from null checking". `javax.annotation`. Added imports above. @bdworth How about making concatStatic... actually static? ha, right. "fixed", so now all three tests fail as expected   Fair points. Sometimes I really want to use arrays, to save some space (avoid Autoboxing). I guess I'll create a wrapper class for my arrays.  I need to use guava and I must to use google maps m4b (premium), but I get the next error:

Error:Execution failed for task ':app:transformClassesWithJarMergingForDebug'.
> com.android.build.api.transform.TransformException: java.util.zip.ZipException: duplicate entry: com/google/common/base/FinalizableReference.class

this is here too: https://code.google.com/p/gmaps-api-issues/issues/detail?id=10246

any solution?  I ran into exactly this some time ago and I'm afraid you can't use `Striped` when both threads need multiple locks and you don't know which in advance. The goal of `Striped` is to reduce the number of needed locks and this can be only done by mapping multiple inputs onto the same lock. You were unlucky getting

```
A1 -> L1 <-B2
A2 -> L2 <- B1
```

and you can't avoid the deadlock by changing the order as you don't know the mapping.

I'm afraid, there's no solution involving `Striped`, unless you know all locks a thread needs upfront. In case you do, then you can use `Striped.bulkGet` so you get the locks in a fixed order.

Otherwise, if you need to lock based on identity, then you can
- lock on the object themselves
- or lock on what you get from a `Cache<YourObject, YourLock>` using `weakKeys`.

If you need to lock based on `equals`, then you can
- or lock on what you get from a `Cache<YourObject, YourLock>` using `weakValues`.
- use a `WeakHaskMap<YourObject, YourLock>`, but this works only if you can assure keeping `yourObject` alive as long as the lock is needed. *So better don't.*
 Even though issue is closed..just a thought why can't we use two Striped locking instances (one for A related locks and second for B related locks) ?

If you use Map<Key, Lock> then the purpose of striped locking is not lost. Understood.

But what I understood is A1 and B1 are resolving to same lock - A2 and B2 are resolving to same lock ? If that is the case I thought having two striped instances could solve the issue.   In version 20.0 the errorprone annotations are used throughout the codebase so the error_prone_annotations dependency is not optional anymore. I signed It!
 Ok.  I'm closing this PR so I can do more investigation.  When we updated to version 20.0 we started getting
```
Error:java: cannot access com.google.errorprone.annotations.CanIgnoreReturnValue
  class file for com.google.errorprone.annotations.CanIgnoreReturnValue not found
```
when compiling the project in IntelliJ.  The workaround is to explicitly add the error_prone_annotations dependency to our app but I'm not sure what part of our code is trying to use that annotation.  Can support be added to the new graph package classes to support `java.io.Serializable`? Yes, sorry, to clarify I am more interested in `ImmutableGraph` implementing `Serializable` so that I can easily persist graphs to use in later executions of my software. I might persist it in a database or simply as a file on a file system but ultimately I want to be able to run a process multiple times, each run generates a graph, some time later I will run it again and I'll then want to compare graphs from previous runs with the new runs.

I could create my own serialization and deserialization code for it but it would be nice to be able to simply cache it and retrieve it later.
 Hm, interesting note, thank you @cpovirk. I suppose if I changed versions then I would need to deserialize my entities with the previous version and then reserailize it with the new version; probably best to avoid it then and roll my own.

Out of curisoity, why does `ImmutableTable` and various other collection implementations in Guava implement `Serializable`?
 Sounds good. I will do my own for now and watch for a JUNG update as well. Thank you.

P.S. I know some tools like Common JCS and/or Hibernate require some entities to implement `Serializable` but that isn't currently my use case.
 @jrtom Is a JUNG re-release still in the works?  `Graph.successors()` returns nodes in an undetermined order which makes it difficult to use `Graph` as a rooted tree where the ordering of the children is important (e.g. something similar to XML) with a schema that orders some elements).

I have the following workaround but it seems expensive (although for small trees I suppose it doesn't really matter):

```kotlin
fun <N> Graph<N>.children(node: N): Set<N> {
    return nodes().toMutableSet().apply { retainAll(successors(node)) }
}
```

Can supported be added to specify the order of nodes returned by `successors()`?  fixes https://github.com/google/guava/issues/2648 . I signed it.  I should be covered by Amazon corporate CLA, though it's not appearing on my account for some reason.
 @jct-amzn I think @googlebot hasn't recognised that you've signed the CLA? By my understanding, once you type the message

> I signed it!

then googlebot should automatically detect it (it's a GitHub service/bot, not a human user :smiley:) and it should tell you what you need to do next to change the red "cla: no" label into a green "cla: yes" label.
 Thanks for your review jbduncan.  I know googlebot's a bot -- I think the gears are turning on the corporate CLA.

My google account doesn't show that I'm part of the correct corporate CLA, so I think there's some problem on the backend, in the way the dots are all connected (github email -> google group -> CLA signatory).

Anyway it's just some one-time bookkeeping and I'm working on resolving it.
 I signed it!
 Ok, trying again.  Google CLA recognizes me now.

I signed it! checking back on the status of this.  the CLA verifier probably doesn't support private email addresses in the github account.

if the bot is using this app script to do the CLA check:
https://github.com/angular/google-cla-verifier-for-github/blob/master/cla-verifier.gs

then you can see that they're just pulling the "fake" email from the patch file:
https://github.com/angular/google-cla-verifier-for-github/blob/master/cla-verifier.gs#L210

so I think there is no way the bot can trace that back to my actual email address, which should be in their signatories spreadsheet. thanks Will.  Can you update the 'cla' label so the request doesn't get auto-closed again?

I'm going to work out a different arrangement at work so this isn't so complicated next time. Hi @cpovirk, as a external reviewer, I managed to find a couple of things in that commit which I think could be improved upon. I've shared my thoughts on those things in the comments below:

1. https://github.com/google/guava/commit/7c11b8d9220b710d5598b774e22cc774f68f40e7#commitcomment-20999208
2. https://github.com/google/guava/commit/7c11b8d9220b710d5598b774e22cc774f68f40e7#commitcomment-20999157
3. https://github.com/google/guava/commit/7c11b8d9220b710d5598b774e22cc774f68f40e7#commitcomment-20999165 Thanks @cpovirk .  I'll keep AndroidIncompatible in mind for future commits.  No worries about the CLA, I know I was making it a challenge.  Guava 20 depends on error prone annotations 2.0.12 which requires Java8. 

However GWT 2.8 still allows Java7 to be used as JVM even tough internally it compiles using JDT and source level 1.8. When using Java 7 + GWT 2.8 + guava-20-gwt you get an unsupported major.minor version 52.0 error when GWT tries to load an error prone annotation from classpath.

In terms of GWT support I think the latest version of error prone annotations you should depend on is 2.0.5 as its the last version build for Java7. Looks like Guava can not use error prone annotations 2.0.5 as it does not contain LazyInit annotation. So I rebuild error prone annotations 2.0.14 using Java7 which fixes the GWT issue.
 Hmm good question, already a few days ago. I think there is probably a chance that I have used 2.0.14. 

At least I am sure that I did a google search after seeing the error and found https://github.com/google/error-prone/issues/369 . So I thought all versions above 2.0.5 had been built with Java8 and would cause the error.  Hi I have a requirement to save or pass it my graph as json to other apis but what I am seeing is graph interfaces are not serializable so any new update has been coming up relating to this requirement. Can you help me in how I can export it as a json. Yes I was targeting JSON. It was in my mind to do serialization & deserialization my own but thought to discuss it once with the community.

Thanks alot.
  I found a small typo here: https://github.com/google/guava/wiki/ReflectionExplained#is-the-first-parameter-of-the-method-annotated-with-nullable :

`method.getParameterAnnotations[0]` should be `method.getParameterAnnotations()[0]`  Why for BaseEncoding.base64Url() padding character is '**=**'? In javascript google libraries like:https://github.com/google/closure-library/blob/master/closure/goog/crypt/base64.js padding character is '**.**'. It should be url safe, but '**=**' is a URL reserved character. I think it's easy to get confused, better to force client specify padding character manually.  [@jrtom suggests](https://github.com/google/guava/issues/2609#issuecomment-260100298) moving the topic of topological sorting to a separate issue.

## Usage
The most outstanding usage of topological sorting is dependency management. For example, an order of executing tasks. (some depend on others)

## Suggestion of implementation
Since topological sorting is from graph algorithm, I proposed to put it together with direct acyclic graphs in the [previous issue](issue/2609). But the algorithm will be much slower once it involves with graphs.

Here are some ideas on implementation:

- Using graphs

- Using a hash map and a priority queue
 Will this be making it into Guava in the near future? @kashike This sort is easy to understand. Each time you keep a collection of items without a prerequisite, and you then unlock more item when you add each of those in the collection to the sorted list. You can find a loop when you can no longer unlock but there are still entries left.  This will be a method that generates a `List` view of the array argument, similar to `Arrays.asList()`. The difference is that the requested method will create an unmodifiable view of the array, which is faster than an immutable view like `ImmutableList`. (It copies the array) This method would be a single wrapper instead of a double wrapper like this:
```java
Collections.unmodifiableList(Arrays.asList(new Object{}));
```
And the one above is long enough for us to create a shortcut for it. @liach - what is the difference between unmodifiableList and immutable one?
In both cases you would like to  have a list that cannot be modified - i.e - have elements added or removed from it
 UnmodifableList's backing list can be modified, and the unmodifiable version can reflect that change.
ImmutableList is immutable, that is it can never be modified.
```java
List<String> list = Lists.newArrayList("apple", "banana");
List<String> view = Collections.unmodifiableList(list);
view.forEach(System.out::println);
System.out.println(); //to separate two outputs
list.set(1, "pear");
view.forEach(System.out::println);
```
The expected output should be:
```
apple
banana

apple
pear
``` @liach  so you would like to retrieve an unmodifiable list, which is backed by an array? Yes, and it should be as light as possible I would prefer not to have an interim allocation of Arrays.asList , but simply have
the array, and return an umodifiable list that is backed by it (I refer to the example you gave - I feel Arrays.asList is an unnecessary allocation).
I would like to work on a patch for this -
My idea is to return an object implementing the list interface, and throwing an exception on the methods that modify the list (i.e - add).
What do you think?
 Yes. Generally something like `Arrays.ArrayList` but does not support `set(int index, E element)` operation. Thanks @liach , i will be glad to contribute the patch. Hi @yairzaslavsky, I'd recommend you wait until someone on Guava team replies back to this issue before writing your patch. This is because on the [Contributing](https://github.com/google/guava/blob/master/CONTRIBUTING.md) page, it explicitly states that API additions will only be considered after a lengthy and thorough review process, and so if your write the code now, it may be all for nought. @jbduncan  I have read it, but thanks for pointing it out to me.

For me it's easier sometimes to express myself via code. I am perfectly fine with the possibility the idea gets rejects. A pull request, even if not perfect, can show what we had in mind.
 Thanks for the reply!  Starting with Guava 19 emulations of `java.util.concurrent.Future/CountDownLatch` have been added and a matching `java.util.Util.gwt.xml` has been added to publish the super source. Both classes depend on `java.lang.InterruptedException` which has been super sourced as well using `java.lang.Lang.gwt.xml`. 
However `java.util.Util.gwt.xml` does not inherit `java.lang.Lang.gwt.xml` so the GWT compiler generally does not see super source of `java.lang.InterruptedException` if you would only inherit `Util.gwt.xml` in a GWT app.

Basically if a GWT app does not directly or indirectly inherit `Collect.gwt.xml` (the only module that actually inherits `Lang.gwt.xml`) GWT compilation fails as nearly everything pulls in `Base.gwt.xml` which in turn pulls in `Util.gwt.xml`.

Also I am not so sure why `Base.gwt.xml` pulls in `Util.gwt.xml` as the code in the base package does not seem to depend on anything from java.util.concurrent, but maybe that's because inside Google you have more code covered through `Base.gwt.xml`.

So please revisit and fix your inherits structure for GWT.
 I think it's fine to document it on the Guava 19 / 20 release notes as a known issue and publish the fix with 21.0.

Btw: It's likely that GWT will provide CompletableFuture emulation in the future, thus also emulating most if not all java.util.concurrent classes Guava currently provides. I am just curious but is there a reason why you guys don't contribute reasonable implemented JRE emulation to GWT itself?
  Some times, we need events to be executed by specified executor. I signed it!
    Improved the performance of indexOf methods of primitives.
The original time efficiency was O(nm), where n is the size of the array
and m is the size of target. The new time efficiency is O(n).
The algorithm used is Sunday algorithm, a string matching algorithm that can be used on arrays.
All tests passed locally. For now I do not really have good data to test these methods. Could you provide some big data if possible?
 Hi @liach. From what I can tell, I'm not sure if you actually need big data to test the performance of your new implementations of the methods.

In situations like this, people typically write micro-benchmarks with a framework like [JMH](http://openjdk.java.net/projects/code-tools/jmh/) to show how their solutions compare to existing ones speed-wise.

So my personal suggestion would be to investigate JMH if you're not already familiar with it, and then write a micro-benchmark between the current impls and yours, show us the results, and provide us with the source code so we can help you improve the benchmark in case it doesn't follow best practices. (But I admit that I wouldn't be the best person to ask about best practices, as I hardly know how to even write benchmarks with JMH or other frameworks.)

(I know that Google use Caliper instead as their framework for micro-benchmarking, but some people think it's a bit flawed and that JMH produces more accurate results, so I'd personally be inclined to use JMH for my own benchmarks. But that's a story for another time and for someone else to talk about, as I am not familiar with the details. :smile:)
 Actually are benchmarks like [these](https://github.com/google/guava/blob/master/guava-tests/benchmark/com/google/common/primitives/UnsignedBytesBenchmark.java)?
 Yes, that's right. What you've shown is a link to one of Guava's Caliper benchmarks. However, I'd strongly recommend looking into **OpenJDK JMH** instead, because it's supposed to be much more reliable.

By my understanding, one of the reasons for this is that `for` loops are easy for the Oracle Hotspot JVM (and presumably other JVMs) to optimise away in non-obvious situations, and Caliper encourages its users to use `for` loops to benchmark code many times (this is done differently in JMH, which uses annotations and special optimization-defeating trickery instead), so Caliper benchmarks are more likely to report incorrect timings and thus are less reliable.

See https://groups.google.com/forum/#!msg/mechanical-sympathy/m4opvy4xq3U/7lY8x8SvHgwJ for more information.
 Do I do in a separate project? I am not really clear about this.
 I think so? That's what the [front page](http://openjdk.java.net/projects/code-tools/jmh/) seems to say. But I'm really not the right person to ask, as I've never written a benchmark before.
  Hi all -

I'm experiencing a problem serializing ImmutableLists in GWT. More specifically, the issue I stumbled upon is:

`[INFO] com.google.gwt.user.client.rpc.SerializationException: Type 'com.google.common.collect.SingletonImmutableList' was not included in the set of types which can be serialized by this SerializationPolicy or its Class object could not be loaded. For security purposes, this type will not be serialized.: instance = ...
`
The culprit is an object that contains an ImmutableList with a single object embedded.

Does the serialization test suite include coverage for singletons?

Thanks,
Paolo
  As discussed in https://github.com/google/guava/issues/2591#issuecomment-258624388, I wonder if it'd be worth adding a map stream class to Guava 21.0+, in the spirit of OpenGamma Strata's MapStream ([javadoc](http://strata.opengamma.io/apidocs/index.html?com/opengamma/strata/collect/MapStream.html)) or StreamEx's EntryStream ([javadoc](https://amaembo.github.io/streamex/javadoc/index.html?one/util/streamex/EntryStream.html)). @cpovirk I believe this issue should have "platform: java 8" and "package: collect' labels? :) Thanks for adding them @cpovirk! :) I would also like such a class, though I would suggest to make it more general and not only focused on maps.

It could look like this:
```java
public interface PairStream<A, B> {

  static <A, B> PairStream<A, B> empty();

  // Zip methods, with different handling of iterables of different length:
  // throwing exception, truncating, or padding with null
  static <A, B> PairStream<A, B> zip(Iterable<A> a, Iterable<B> b) { }
  static <A, B> PairStream<A, B> zipShorter(Iterable<A> a, Iterable<B> b) { }
  static <A, B> PairStream<A, B> zipPadded(Iterable<A> a, Iterable<B> b) { }

  static <T, A, B> PairStream<A, B> of(Iterable<T> it, Function<T, A> aFunc, Function<T, B> bFunc) { }

  // Additional Stream variants of factory methods where possible.

  // Maybe additional convenience method for maps?
  static <A, B> PairStream<A, B> of(Iterable<Map.Entry<A, B>> entryStream) { }
  static <A, B> PairStream<A, B> ofEntries(Map<A, B> map) { }

  <R> PairStream<R, B> mapLeft(BiFunction<A, B, R> f);
  <R> PairStream<A, R> mapRight(BiFunction<A, B, R> f);
  <R> Stream<R> map(BiFunction<A, B, R> f);

  // Maybe convenience methods for simple projections?
  Stream<A> toLeft();
  Stream<B> toRight();

  // flatMap(Left|Right) would pair each of the entries of the resulting stream
  // with the current element of the other side
  <R> PairStream<R, B> flatMapLeft(BiFunction<A, B, Iterable<R>> f);
  <R> PairStream<A, R> flatMapRight(BiFunction<A, B, Iterable<R>> f);

  <R, S> PairStream<R, S> flatMap(BiFunction<A, B, PairStream<R, S>> f);

  // Sorted keeps pairs together, also overrides with Comparators
  PairStream<A, B> sortedLeft();
  PairStream<A, B> sortedRight();

  // Instead of collectors:
  ImmutableMap<A, B> toMap();
  ImmutableMap<A, B> toMap(BinaryOperator<B> reducer);
  ImmutableMultimap<A, B> toMultimap();

  // Remaining Stream methods that can be adapted directly:

  PairStream<A, B> filter(BiPredicate<A, B> p);

  void forEach(BiConsumer<A, B> c);
  PairStream<A, B> peek(BiConsumer<A, B> c);

  PairStream<A, B> distinct();

  PairStream<A, B> limit(long maxSize);
  PairStream<A, B> skip(long n);
  long count();

  boolean anyMatch(BiPredicate<A, B> p);
  boolean allMatch(BiPredicate<A, B> p);
  boolean noneMatch(BiPredicate<A, B> p);
}
```
StreamEx's `EntryStream` seems to have a few nice additional methods that could be added here, too.

Besides the use case for maps, this `PairStream` would also be an elegant solution for the proposed `Iterators.forEachPair` (https://github.com/google/guava/issues/677#issuecomment-288425903).

It does not require any `Pair` class nor any new functional interfaces added to the API. Of course, the common argument against any Pair-related features is that pairs are bad and one should use "proper" classes instead, but I think specifically in this case the counterargument is that having a `PairStream` with methods that take `BiFunction`s and `BiPredicate`s is nicer than having a `Stream<MyDataClass>`, because one can directly access both values in the lambdas. For everyone's info, it seems that JOOQ JOOL is investigating something similar to @PhilippWendler's idea as a class called `Seq2`. Perhaps that might be a source of inspiration or things to avoid for this particular issue?

https://github.com/jOOQ/jOOL/pull/172 Looks like a `Streams.forEachPair()` has been added as of https://github.com/google/guava/commit/8f1a088475b51f03b9f28617893510cc74b82b49. I think @PhilippWendler's idea for a `PairStream` has merit, but if the name puts the Guava team off because of the association with `Pair`, then we could potentially name it `DuoStream` instead. :) @perceptron8 I noticed that you down-voted the idea of a `MapStream`. I'd be interested to hear why you think it's not such a good idea. :) @jbduncan It seems that I checked StreamEx's `EntryStream` only and I found it to be excessively complex, even bloated. I should've pay more attention to OpenGamma Strata's `MapStream` which is nice, simple and - I agree - could be useful.

It's great that you linked `Seq2` PR. Flattened `Pair` is still a `Pair`, just implicit. `PairStream`, `DuoStream`, `BiStream`... different names, same mess.

I withdraw from down-voting the `MapStream`, as it is definitely worth considering. However, I'm still against `EntryStream` and any Pair/Tuple-involving ideas.

Thanks for asking :)
 Looks like Google [MµG](https://github.com/google/mug) has just released an implementation of a [`BiStream`](https://github.com/google/mug/pull/4) class.

It's not clear to me what the relationship between Guava and MµG is, so is it worth keeping this issue open now? `Streams.zip` and `Streams.forEachPair` already handle a good part of my use cases for `PairStream`. However, one relatively large class of use cases is still missing: zipping over the entries of a map. With having `zip` and `forEachPair` for streams in Guava, it really feels like an omission that the JDK provides only `forEach` for maps and not `zip`.

Could you please add `Stream<R> Streams.zipMapEntries(Map<K, V> map, BiFunction<K, V, R> func)` to Guava? I think this would be a worthy addition that does not suffer from any of the open questions for `PairStream`. An alternative would be to add this method to `Maps`, but I think it would be less discoverable there (in `Streams`, people will notice it when they look for `Streams.zip`). Of course, adding an instance method to `ImmutableMap` in addition would also be great.

`zipMapEntries` would only be a shortcut for `map.entrySet().stream().map(entry -> func.apply(entry.getKey(), entry.getValue()))`, but I think it is still valuable because it often allows using method references instead of lambdas that unpack the entries, and because being able to assign names to the key and value parameters in a lambda transports more semantics than just calling `entry.getKey()` and `entry.getValue()`.  Quite simple and will provide at least some capabilities for visualization  Guava is a commonly used library, which nearly all of its users do not need this feature. After all, this feature should instead be done in a separate project at best.
  here is example of how our project tried to upgrade to guava 20 from 19 (simple version bump) - https://github.com/checkstyle/checkstyle/pull/3527.

it result in violations by IntelijIdea:
![screenshot- upgradetoguava20](https://cloud.githubusercontent.com/assets/812984/20042839/f168ad4a-a435-11e6-9ed8-d08c6b8a8778.png)
https://teamcity.jetbrains.com/viewLog.html?buildId=917921&tab=Inspection&buildTypeId=Checkstyle_IdeaInspectionsPullRequest

All is that only due to commit: https://github.com/google/guava/commit/f6da31136af15dd324d56d253bc17c5b9afe9759#diff-7ed40f507101a8625df970c98abcbc55

It is used jdk class `javax.annotation.CheckReturnValue` to trigger validation and google custom class `com.google.errorprone.annotations.CanIgnoreReturnValue` to suppress violation.

yes it works for google, but now for others. I think it is not accurate to use different markers for triggering and suppressions. If you want to use errorprones's `CanIgnoreReturnValue` please use smth like `com.google.errorprone.annotations.CheckReturnValue` (non existing class).

but usage of jdk marker/annotation trigger validation process of other tools. Extra dependencies are also not desirable.

It would be better to use `CheckReturnValue` on certain methods as show at - http://errorprone.info/bugpattern/CheckReturnValue.
or to use some friendly(common for all) approaches that other tools can use and ignore that methods.  > by default is important to us,

I hope you understand that guava is library so "us" should be "us and users". In other case popularity of guava will decrease. CIs will not let to upgrade to new version of guava.
I just gave example in simple opensource project.

I posted an note at error-prone team - https://github.com/google/error-prone/issues/475
 You are quite demanding for someone who is using great software free of charge. :)
 I just want to stress the point that solution should be consistent. It either jdk's annotations or errorprone's . Either way will satisfy community who use other static analysis tools in CIs.
 Umm, I may deserve some of the blame here.  I made a feature request for IntelliJ to support `@CheckReturnValue` on classes and packages (previously they supported it on methods only), and they added that feature, but I neglected to ask for `@CanIgnoreReturnValue` support at the same time.  I eventually did ask for `@CanIgnoreReturnValue` support and supposedly that is coming in the next minor version of IntelliJ, 2016.3.  I was hoping that would be released before Guava 20, but sadly it did not work out that way.  Sorry!

See https://youtrack.jetbrains.com/issue/IDEA-158576
 @michaelhixson , thank you !
I had big doubts that they consider such update, so came to guava team first.

I think we can close the issue and just wait for IntelijIdea 2016.3 release.
  Added lastIndexOf(byte[] array, byte[] target) method to Bytes primitive class and its corresponding tests.

It is a fix for the issue #2617 . I signed it!
 @luisalduucin You can add these to all the primitive classes.
 @liach Yes, sure I will, but before I would like that a Google member or guava contributor check if my approach is correct in order to proceed. Thanks. 
  Added the lastIndexOf method which receives two byte array as parameters for the Bytes primitive class and its corresponding tests.

It is a fix for the issue #2617 . I signed it!
  Being public, it always gets into way of our class (import is done automatically by auto-importing tools).
It's not used anywhere else, so can be `private`.
If it's intended to be used by inheritance, then it can be `protected` as well.
If it really neede to be public, then it's better be available through a getter method. I signed it!
  Nice addition - to get the count of all occurrences in the map (instead of iterate) No, size() returns the number of keys. I'm interested in the number of values.
 @Sharon-Ko Did you perhaps mean to talk about Multi**map** rather then Multi**set**?

If so, the javadocs for `Multimap.size()` should clear up matters for you. :)
 Sorry, my mistake. Thanks
  Hi all,
I have just downloaded GWT 2.8.0 and guava-20.0 + guava-gwt-20.0.

I added 
```
<inherits name='com.google.common.base.Base'/>
<inherits name="com.google.common.collect.Collect"/>
```
to my .gwt.xml file and the jar file in the ant gwtc classpath. Then I cleaned the gwt-unitCache and I enabled the DEBUG logging in the ant `com.google.gwt.dev.Compiler` target.

```
<target name="gwtc" description="GWT compile to JavaScript (production mode)">
    <java failonerror="true" fork="true" classname="com.google.gwt.dev.Compiler" maxmemory="512m">
      <classpath>
        <pathelement location="src"/>
        <path refid="project.class.path"/>
      </classpath>
      <!--arg line="-strict"/-->
      <arg line="-war"/>
      <arg value="war"/>
      <!-- Additional arguments like -style PRETTY or -logLevel DEBUG -->
      <arg line="-logLevel"/>
      <arg value="DEBUG"/>
      <arg line="${gwt.args}"/>
      <arg value="com.mycompany.mywebapp.MyWebApp"/>
    </java>
  </target>
```

When processing Guava-GWT Java files, the processor complains about missing annotations:

> Line 20: The import com.google.errorprone cannot be resolved
> Line 23: The import com.google.j2objc cannot be resolved

Also adding `<inherits name='java.lang.Lang'/>` to the module definition does not help ([see this stackoverflow topic](http://stackoverflow.com/questions/40360901/gwt-2-8-throws-exception-when-compiling-with-guava-20))

Could it be that latest Guava-GWT 20.0 jar was not packed with all the needed sources?



  Warning on eclipse , 

`
Bound mismatch: The generic method cast(Class<T>, B) of type MutableClassToInstanceMap<B> is not applicable for the arguments (capture#8-of ? extends Class<? extends B>, capture#12-of ? extends B). The inferred type capture#10-of ? extends B is not a valid substitute for the bounded parameter <T extends B>
` I signed it!
  link-local address validation with percent and scope id I signed it
  the issue occur when ImmutableList is included in gwt's serialization
policy and ImmutableSet not and a list created by ImmutableSet.asList
needs to be serialized

fixes #1841
 I signed it!
 I signed it!
  the issue occur when ImmutableList is included in gwt's serialization
policy and ImmutableSet not and a list created by ImmutableSet.asList
needs to be serialized

fixes #1841
  `Files.readFirstLine(File, Charset)` and `LineReader.readLine()` are documented to possibly return `null`, but these methods are not annotated with `@Nullable`, and I think they should be.

These methods are public and final and they don't override any super method.  I can't imagine that adding the `@Nullable` annotation could cause any harm.
## 

Side note:  I am trying gauge interest in adding more `@Nullable` annotations throughout the codebase.  These methods seem like the safest, most obvious candidates, but there are other candidates.  If you all aren't interested in marking these `@Nullable`, then I won't pursue the issue further.
 No worries.  I hope the failures were false positives!
  The javadoc for Function.equals has an invalid `{@object}` tag in the first sentence:

```
/**
 * <i>May</i> return {@code true} if {@object} is a {@code Function} that behaves identically to
 * this function.
 *
```

I'm sure that was supposed to be `{@code object}`.  As it is now, the word "object" does not appear in the rendered javadocs and it reads like "May return true if is a Function that..."

The same issue exists in the javadocs of a few non-public APIs, in case you want to fix them:
- `{@from}` in InternetDomainName.validateSyntax
- `{@count}` in PairedStats constructor
- `{@requiredTo}` in Quantiles.chooseNextSelection
  As it turns out, since I originally posted #2411, the needs for my university project evolved a bit, as I realised I really needed a directed acyclic graph (DAG) rather than a tree.

I believe JGraphT provides an implementation of a DAG, but despite that I decided to settle on Guava 20-rc1 and `common.graph` recently (on one hand because I had licensing worries with JGraphT, and on the other hand because I think `common.graph` is currently a much cleaner alternative to both JGrapht and JUNG), so I would be excited to see DAG support in say `(Graph|ValueGraph|Network)Builder`, in a method like `supportsCycles(boolean)`, so I don't have to implement cycle-checking support myself anymore.

What does the Guava team think of this request?
 Glad to hear you like common.graph!

This is one thing we considered as an option on the *Builders, but is not in the current release because it requires either A) additional memory overhead (e.g. a UnionFind type data structure kept in sync with the graph) or B) a much slower addEdge() method (checking for a cycle on each add).

There is Graphs.hasCycle(), which if you called after every mutation is closer to the second solution.
 I still highly recommend using common.graph rather than rolling your own. Especially in light of some research I did:

A disjoint-set/union-find data structure is sufficient for maintaining an **undirected** acyclic graph with some memory overhead but virtually (ignoring the inverse Ackermann function) no time overhead for adding edges. Although that's assuming insertions only (no deletions). However, even if we ignore the possibility or removing edges for now, the **directed** acyclic case is much harder. Maintaining the acyclic guarantee in real-time (that is, with each edge addition/remove) is an open problem in Computer Science with no known efficient algorithm:

http://cstheory.stackexchange.com/q/5179

Compared to the current O(1) runtime for adding edges, all currently known algorithms have unacceptable runtime to be part of a graph library in my opinion.

Common.graph is of course perfectly capable of representing DAGs (and in fact, many of its uses inside Google are DAGs), it just won't maintain the _acyclic_ guarantee. However, if you're able to build up the entire graph at once, a good approach is to do so and then assert that `Graphs.hasCycle()` is false.

PS: There is currently an internal version of `List<N> topologicalOrdering(Graph<N> graph)` (where `graph` is a DAG), which we're hoping to add to Guava in v21.
 @Bezier89 Regarding maintaining acyclic guarantees in real-time, have you read http://homepages.mcs.vuw.ac.nz/~djp/files/PK-JEA07.pdf?

Admittedly it only applies to DAGs, and I've not had a proper read through it, so I don't know the efficiency of the algorithm discussed, but it looks like it was written relatively recently (2007 I think), so I wonder if it would have useful information for you.
 Oh woops! Thanks for your feedback @jrtom. That'll teach me to actually _read_ a paper before sharing it with others. :P
 @jrtom Is it possible to make an `ImmutableDirectedAcyclicGraph` that implements `DirectedAcyclicGraph`? An immutable one would be possible and it can be simply created via a `GraphBuilder` or from another graph.
 Provide a list to check whether the order of a list is possible; provide a comparator to form a list.
 - Provide a `List<N>` of nodes to check whether such a topological order is applicable on this DAG;
- Provide a `Comparator<N>` to generate a `List<N>` representing the topological order. The comparator is used to determine which node to be added first when there are multiple nodes with an in-degree of zero.
 Well, those are just derived from the nature of DAG. I actually want to ask @jbduncan how DAG would be used in his project, since he proposed this first.
 Ah, okay, I was kind of hoping no-one would ask. As it turns out, after thinking about it some more and discussing it with my supervisor, I realised I didn't need a DAG after all - just a regular tree! So I'm actually not using a DAG in my project anymore. :P

I originally thought I needed a DAG because I imagined there would be scenarios where two directed branches moving outwards from the root of my "tree of messages" (https://github.com/google/guava/issues/2411#issuecomment-193399619) would need to merge back together into a single directed branch. If that were the case, a DAG would've let me model this easily, but soon afterwards I realised that branches never do merge back together (for technical reason(s) which aren't easy for me to pin down).

So I'm very sorry to say that I don't actually have anything useful to say @liach :/
 In package `collect`, there is a class called `SortedLists` which assume input `List`s for the methods in the class are all sorted. Is it possible to create a helper class like that one, probably called `DirectedAcyclicGraphs`?
 For the default `hasCycle` implementation, we can use Java 8 default methods for interfaces.
 So is a class called `AcyclicGraphs` possible to prevent such duplicates? Users need to guarantee that their graph does not have cycles before calling methods in that class.
 Yes
 Indeed. DAG will hang on. But how about topological ordering functionality? That one is commonly used.
 I mention topological ordering because it is based on DAG. I will open a separate issue.
 It is actually DAG related. See [Wikipedia](https://en.wikipedia.org/wiki/Topological_sorting):
![image](https://cloud.githubusercontent.com/assets/7806504/20235628/dcf4e184-a84b-11e6-97c2-21edb33c972c.png)
 That sounds fair enough to me. Thanks for taking the time to contribute to the earlier discussion @jrtom!  http://www.gwtproject.org/release-notes.html#Release_Notes_2_8_0
  That's not a typo; it means "if and only if".
 But then again, it's not a word I've personally seen used in _any_ context apart from Guava and [Spotless](https://github.com/diffplug/spotless), and I'm a born Englishman. (Is it a word that originated in the US perhaps?)

We were never taught the term in our lectures at university, and I don't remember coming across it in any computer science literature I've read. We always used the phrase "if and only if" instead, so I thought "iff" was a typo too until I searched it up a few days ago. So I'm not surprised at all by @m-berling's confusion on this.

So I think it's worth replacing all occurrences of "iff" with "if and only if" in the javadocs, if only to make things explicit and clearer.
 Maybe the term is more common in mathematics and logic. I'm not a native speaker and I thought it was actually quite well known.

Personally I like its brevity, but I recall seeing a PR to "fix" a similar typo in some other project a few months ago. So indeed, a case can be made that it's better to be explicit.
 Thanks for opening this. Our not-well-enforced policy has been to never use "iff" (or "e.g.", or "i.e.", or really most abbreviations) in our javadoc.
  The `ByteArrayByteSource` implementation of `ByteSource` passes its internal array to objects provided by the user, thus allowing the user to modify the data within the `ByteSource`. This directly contradicts the `ByteSource` javadoc which claims that:

> it is an immutable _supplier_ of `InputStream` instances.

The following methods display this issue:
- `ByteArrayByteSource.copyTo(OutputStream)`
- `ByteArrayByteSource.read(ByteProcessor)`
- `ByteArrayByteSource.hash(HashFunction)`

This clearly involves unexpected implementations of the parameter objects. It should be noted that neither `OutputStream` nor `ByteProcessor` javadocs even suggest that input data should not be modified. `HashFunction` does indicate that implementations should be pure functions, and goes so far as to specify that input data should not be modified, however enforcing that is obviously not possible.

A sample class which demonstrates this issue is below:

``` java
public final class Main {
  public static void main(String[] args) throws IOException {
    final ByteSource byteSource = ByteSource.wrap(new byte[]{0, 0, 0, 0});
    byteSource.copyTo(new OutputStream() {
      @Override
      public void write(final byte[] buf, final int off, final int len) {
        for (int i = 0; i < buf.length; i++) {
          buf[i] = 2;
        }
      }

      @Override
      public void write(final int b) {
        throw new UnsupportedOperationException("write has not been implemented");
      }
    });
    System.out.println(Arrays.toString(byteSource.read()));
  }
}
```
 There is a fix possible by cloning the byte array while copying. I will submit a PR soon.
 Similar case is #1855, where internal arrays are also not guarded against malicious code.
 An alternative to defensive copies would be to pass bytes to the recipient individually, though that would also incur a performance penalty.

I am in favour of simply adding some documentation to warn of potential misuse. The performance hit of a defensive copy would be frustrating.
  Using `Maps#subMap` from #1907 on a `TreeMap` twice instance causes IllegalArgumentException "fromKey out of range", when the latter range is coarser than the first one:

``` java
TreeMap<Integer, Boolean> treeMap = new TreeMap<Integer, Boolean>(ImmutableMap.of(1, false, 2, false, 3, false, 4, false, 5, false));
Maps.subMap(Maps.subMap(treeMap, Range.closed(2, 4)), Range.closed(1, 5));
```

My use case is to apply restrictions (sometimes based on userinput) on a `TreeMap<Long, ?>` (where `Long` corresponds to timestamps) at different spots in the application.

Tested w/ d67899df652c8a889c578a53a639d4c399925e2c.
 You might consider keeping track of the original `NavigableMap` and the current `Range`, and intersecting the `Range` as you receive new input, e.g.

```
public class MapViewport<K extends Comparable<? super K>, V> {
  private final NavigableMap<K, V> map;
  private Range<K> range;

  // constructor
  // setters for range such as intersection, union, and set

  public NavigableMap<K, V> getView() {
    return Maps.subMap(map, range);
  }
}
```

This has the added advantage of avoiding constructing recursively nested views.

As Louis says, `NavigableMap` is [documented](docs.oracle.com/javase/8/docs/api/java/util/NavigableMap.html#subMap-K-boolean-K-boolean-) to "_throw an IllegalArgumentException on an attempt ... to construct a submap either of whose endpoints lie outside its range._" and the `Maps`/`Sets` methods simply delegate to the appropriate `NavigableMap` methods. I'd agree it'd be reasonable for `NavigableMap` to silently accept wider view ranges rather than fail, but that's the existing behaviour.
 Thank you both for taking the time to investigate this behavior. I agree that it is a JDK issue and documented behavior.
  The entry https://github.com/google/guava/releases/tag/v20.0-rc1 points the change log of Guava 19.0 instead of Guava 20.0
  The documentation for [Quantiles.ScaleAndIndex.computeInPlace()](https://google.github.io/guava/releases/snapshot/api/docs/com/google/common/math/Quantiles.ScaleAndIndex.html#computeInPlace%28double...%29) has the wrong description of the return value; from the other methods in the class, it looks like it should say "the quantile value", not "an unmodifiable map of results: the keys will be the specified quantile indexes, and the values the corresponding quantile values".

It looks like maybe this is a copy/paste error from copying this from [Quantiles.ScaleAndIndexes.computeInPlace()](https://google.github.io/guava/releases/snapshot/api/docs/com/google/common/math/Quantiles.ScaleAndIndexes.html#computeInPlace%28double...%29).
 I think this is done, I'll let @cpovirk confirm.  Hello，I write a test code：

```
cache<String, Integer> cache =
            CacheBuilder.newBuilder()
                    .expireAfterAccess(10, TimeUnit.SECONDS).build();
cache.put("test", 1);

Thread.sleep(5000);
// output 1:1
System.out.println(cache.size() + ": " + cache.getIfPresent("test"));

Thread.sleep(10000);
// output 1:null
System.out.println(cache.size() + ": " + cache.getIfPresent("test"));
```

The cache doesn't update its size after the key expired, it's a bug or others?

Thanks & Regards.
  last master commit GUAVA-GWT not work.
Gwt 2.8 compiler return the following error
`[ERROR] Errors in 'jar:file:/home/paolo/.m2/repository/com/google/guava/guava-gwt/20.0-SNAPSHOT/guava-gwt-20.0-20161005.174957-374.jar!/com/google/common/collect/ConsumingQueueIterator.java'
               [ERROR] Line 33: No source code is available for type java.util.ArrayDeque<E>; did you forget to inherit a required module?` 
 2.8.0-rc3 and guava 20.0-rc1
 All works with latest release  Use micro sign for microsecond unit.
 This PR seems to be a subset of #2592 and should be closed?
  The current symbol for microseconds is **μs** (Greek),  The correct symbol would be **µs** (SI).  The current rendering is in error.  Moreover, it does not print on an 8-bit console unless the code page is Greek.
 This suggests that the greek mu is preferred:
http://www.unicode.org/reports/tr25/

On Thu, Oct 6, 2016 at 1:51 PM, Christopher Yeleighton <
notifications@github.com> wrote:

> The current symbol for microseconds is _μs_ (Greek), The correct symbol
> would be _µs_ (SI). The current rendering is in error. Moreover, it does
> not print on an 8-bit console unless the code page is Greek.
> 
> —
> You are receiving this because you are subscribed to this thread.
> Reply to this email directly, view it on GitHub
> https://github.com/google/guava/issues/2593, or mute the thread
> https://github.com/notifications/unsubscribe-auth/AA5Cl3ANpEZB4PNBAPGUUF6nac7mdWPEks5qxV9fgaJpZM4KQZud
> .

## 

Kevin Bourrillion | Java Librarian | Google, Inc. | kevinb@google.com
 U+03BC μ is the preferred character in a Unicode context.  Stopwatch should be usable in a non-Unicode context.  In our case, we get ?s in the log.
 Can you convince us that there exists such a thing as a "non-Unicode context"? I've never heard of that before, just software that was broken or misconfigured and needed to be fixed.

In other words, our attitude has been "Unicode (and UTF-8) everywhere" for a long time and it's seemed to serve us well.
 @kevinb9n: Windows cmd? I'd say that's the prototypical example. :smile:
 (I _do_ know it's hardly a good terminal, but it's still used in Windows contexts, and I think Microsoft have so far refrained from changing its encoding to, say, UTF-8, to preserve backwards-compatibility.)
 From my perspective, we can just as easily receive the _opposite_ report tomorrow. This is why I looked up the unicode.org guidance, and found that we are following that. It seems like this should settle it, to me.
 Hmm, good point @kevinb9n.

For Windows users, I suppose the workaround for this is to use a non-cmd terminal like PowerShell or Cygwin. (I presume they decode bytes as UTF-8 out-of-the-box, but I've not checked.)

**Edit:** Assuming, of course, it's feasible to do so.
 I do not think we would receive the opposite report any time soon.  The problem of **?s** vs **µs** is several orders of magnitude above the problem of **µs** vs **μs** in terms of severity.
The workaround is to write a wrapper around Stopwatch that replaces **µ** with **μ** in toString.  Not nice, especially because your Stopwatch is final for whatever reason.
 The fact that the TR mentions the Unicode context explicitly implies that non-Unicode contexts exist too.  So, if you believe the TR, you have to take that for granted.
BTW, Microsoft PowerShell hangs on console input when executing a binary executable, so it is not a general replacement.
 @yecril71pl Please explain how we should know that there aren't users out there today with a terminal that does support the current character but not the one you suggest? That would produce the aforementioned opposite report.

We don't want to devote time to studying these characters. We want a reference that clearly shows which one is better and we want to just go with that. It seemed like we found it.

(Note: if it's true that some program deliberately doesn't embrace UTF-8, then Guava may or may not work well with that and we really can't be concerned about that. Google's position for a long time has been that UTF-8 is the canonical and superior character encoding for the modern world.)
 Can't you use the following?

```
stopWatch.toString().replace("\u03BCs", "\u00B5s");
```
 @ogregoire: I use similar code in the wrapper.
@kevinb9n: In practice, **μ** is supported by ISO–8859–\* and EBCDIC character sets but not by IBM code pages, in which case it should be rendered as **u**.  But IBM code pages do not support **µ** either.
We can map SI **μ** to **u** in the character renderer but we cannot map Greek **µ** to **u**; it would be very inappropriate to do so as it would conflict with the normal rendering as **m**.
  The micro sign is a different character than Greek small letter mu.  The current rendering is in error.  Moreover, it does not print on an 8-bit console unless the code page is Greek, which is insane.
 See #2593 for a discussion on this change.
  Hi,

I read that you plan on adding JDK8 support in version 21. I want to bring your attention to https://bitbucket.org/cowwoc/guava-jdk8/ which I authored a few months ago.

Feel free to borrow design ideas and/or code sniplets for your upcoming release.
 Thanks for this tip. I'm sorry to say that we've done a large amount of
work on this that you just haven't gotten the chance to see yet. :-( We're
trying to get 20.0 out the door and then dump this code out to you. When
that happens, we'd appreciate your suggestions for making it better.

On Thu, Oct 6, 2016 at 10:44 AM, Gili Tzabari notifications@github.com
wrote:

> Hi,
> 
> I read that you plan on adding JDK8 support in version 21. I want to bring
> your attention to https://bitbucket.org/cowwoc/guava-jdk8/ which I
> authored a few months ago.
> 
> Feel free to borrow design ideas and/or code sniplets for your upcoming
> release.
> 
> —
> You are receiving this because you are subscribed to this thread.
> Reply to this email directly, view it on GitHub
> https://github.com/google/guava/issues/2591, or mute the thread
> https://github.com/notifications/unsubscribe-auth/AA5Cl-C8rKtJFOFSXwInWpz3Sht2GQeJks5qxTOKgaJpZM4KQOOt
> .

## 

Kevin Bourrillion | Java Librarian | Google, Inc. | kevinb@google.com
 I just wrote this up really quickly. I assume that you have an even better, more efficient version, in the works: https://medium.com/@robertmassaioli/an-immutablemultimapcollector-for-guava-3f141f9040f#.m18fnmgwo
 I'd be interested in seeing a map stream class in a similar vein to OpenGamma Strata's [MapStream](http://strata.opengamma.io/apidocs/com/opengamma/strata/collect/MapStream.html) or StreamEx's [EntryStream](https://amaembo.github.io/streamex/javadoc/one/util/streamex/EntryStream.html).

I don't have any uses for such a class yet, but I imagine it would be useful if one needs to do something where they'd either need to use deep-nested chaining of the functional methods in `common.collect.Maps` or `map.entrySet().stream()`, both of which in my opinion are a bit clunky.
 @cpovirk I realise that your invitation for particular suggestions was probably aimed at @cowwoc, so would you prefer that I raise my MapStream suggestion above as a new issue?
 Please let me know if you create a separate issue. I will add my comments there. Thank you.
 @cowwoc If there are any noteworthy things in your library that you'd like Guava to consider (or you still have any other comments you'd like to share), I suggest creating a new issue rather than waiting for @cpovirk to create one that may never come. :)
 @jbduncan The main feature I was trying to propose by opening this issue was offering a builder design pattern for Collectors in order to improve readability. I think this is one of the main features that sets my API apart from others.
 Example:

```
ImmutableSetMultimap<Integer, String> sortedMultimap = Stream.of(10, 20, 40, 30, 15).
            collect(GuavaCollectors.multimapFrom(Integer.class).
                               map(i -> i / 10, i -> Integer.toString(i)).
                               asImmutableSetMultimap().
                               sortKeys((a, b) -> b.compareTo(a)).
                               sortValues((a, b) -> b.compareTo(a)).
                               build());
```

My API still offers the static factory methods that others have implemented but for improved readability or advanced use-cases, I recommend the builder pattern.

Also, notice the way it's implemented users are guided forward by a multi-step DSL. At each step of the DSL, code-complete will offer a different set of methods until a terminal method is invoked.
 Ah I see, looks rather interesting to me. I especially like the DSL-y, aids-with-code-completion idea!

However I still think it's worth creating a new issue with this builder-pattern-based collector idea as the topic, as this issue is currently closed and the Guava team may never visit it again.
 @jbduncan Done: https://github.com/google/guava/issues/2640
  The presentation links under Learn about Guava don't work.

```
Presentation slides focusing on base, primitives, and io  
Presentation slides focusing on cache  
Presentation slides focusing on util.concurrent
```

It'll be nice to fix the links to the correct path. :) 
  InetAddresses.isInetAddress("fe80::8b2:d61e:e5c:b333%15") returns false for a valid IPv6 address. Does this method not support Link-Local IP address?
 Why does your string ends with "%15"? Is that a typo?
 Number after '%' is scope id. Please see following link for more details -
http://superuser.com/a/99753
 I see. Thank you. I looked at the code and tests, and it looks like link-local addresses with zone indices are not supported.
 So they're not supported....could they be?

(Assuming I or someone issues a PR) Is there a reason why it is not supported?  My old account is being link to my new account my old was hacked one to many times
 Sound could is try to link back to me
  Ooh, really looking forward to this.

No pressure! :wink: 
  According to IntelliJ, these usages of StringBuilder can be simplified. By my understanding, this is because they do not contain any loops, and thus, as of Java 6, JVMs are able to optimize these concatenations into more-efficient StringBuilder calls at compile time. Thus this change improves readability without losing performance.
  All code which initializes an IOException with a cause exception now uses the appropriate constructor (which was introduced in Java 6), rather than initCause. Since Guava now depends on Java 6, this (as far as I can tell) is a safe change to make.

A change was made from using an Iterator to an enhanced for-loop for (arguably) improved readability and, by my understanding, no performance impact.

All other changes should hopefully be self-explanatory. :)
 I signed it!
  I found these comments slightly confusing. (I also wonder whether you removed `sameThreadExecutor` internally, since it's scheduled for removal in August 2016, but I guess it means in "when Guava 20 is out".)
  i can't get access to the class of Constraint or Constraints, the compiler said they are not public. So how can i use these classes under a new java project?Any help guys? 
 `Constraint(s)` has, to the best of my knowledge, always been non-public. I don't really know why it was included in Guava to begin with, but you're not supposed to use it yourself - Guava itself uses it for implementation purposes only.

The recommended way of doing what `Constraint` does is to either use `Preconditions` or, if `Preconditions` makes your code difficult to read or it simply doesn't meet your needs, use combinations of if statements and exception throwing as you normally would.
 Thanks ! i just use Guava for the first time, and didn't know that Constraint(s) are suppose to be non-public . i just saw someone had use them before, Ok, forget it. Again, really appreciate for your reply!
 Oh okay, I didn't realise you were a first-time user of Guava!

In that case, I'd strongly recommend that you read the Guava [user guide](https://github.com/google/guava/wiki) and explore the javadoc (latest version [19.0](http://google.github.io/guava/releases/19.0/api/docs/)), as they will introduce you the sorts of things which Guava can do for you in a nice, readable fashion.

I presume you already know how to actually use Guava itself with a build tool like Maven or Gradle or within your IDE? If not, you may need to search for a tutorial on how to get Guava set up, as I believe the README assumes you're already familiar with how to do so.
 Sure thing, i will have a try : )
 :+1:

(On a side note, I find it curious that you saw someone use `Constraints` before.

Maybe it was public in an earlier version of Guava? Or maybe the person you saw created a package called `com.google.common.collect` in their app, put a class there, and called `Constraints` from within that class.

I believe that's legal Java, because `Constraints` is only package-private (not completely private), and so his class would have _technically_ been in the same _package_ as `Constraints` and been able to access it, even though the 2 classes would've been in different directories.

**But this is really bad practice, so don't do it in your own code.** :wink:)
  I'm using guava16.0.1 on cdh(cloudera).But when I call `Queues.newArrayDeque()` it shown me this error:

``` bash
Exception in thread "main" java.lang.NoSuchMethodError: com.google.common.collect.Queues.newArrayDeque()Ljava/util/ArrayDeque;
    at com.github.fge.jsonschema.processors.validation.ValidationStack.<init>(ValidationStack.java:70)
    at com.github.fge.jsonschema.processors.validation.InstanceValidator.<init>(InstanceValidator.java:87)
    at com.github.fge.jsonschema.processors.validation.ValidationProcessor.process(ValidationProcessor.java:54)
    at com.github.fge.jsonschema.processors.validation.ValidationProcessor.process(ValidationProcessor.java:34)
    at com.github.fge.jsonschema.core.processing.ProcessingResult.of(ProcessingResult.java:79)
    at com.github.fge.jsonschema.main.JsonSchema.doValidate(JsonSchema.java:76)
    at com.github.fge.jsonschema.main.JsonSchema.validate(JsonSchema.java:109)
    ...
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
    at java.lang.reflect.Method.invoke(Method.java:498)
    at org.apache.spark.deploy.SparkSubmit$.org$apache$spark$deploy$SparkSubmit$$runMain(SparkSubmit.scala:731)
    at org.apache.spark.deploy.SparkSubmit$.doRunMain$1(SparkSubmit.scala:181)
    at org.apache.spark.deploy.SparkSubmit$.submit(SparkSubmit.scala:206)
    at org.apache.spark.deploy.SparkSubmit$.main(SparkSubmit.scala:121)
    at org.apache.spark.deploy.SparkSubmit.main(SparkSubmit.scala)
```

What caused this?CDH or the version of guava?Can sm help me?
 which version of cdh you are using?
 Having this same problem. Just updated my version of Guava to the latest, 20.0 and still happens.

Not using Cloudera. Just trying to use validator in a servlet.  We are using Google Commons APIs in our project and security scan on our code has reported following problem. Could you please let me know if this is of any concern or it can be fixed in new version of this API.

**Problem:** The application fails to release (or incorrectly releases) a system resource before it is made available for re-use. This condition often occurs with resources such as database connections or file handles. Most unreleased resource issues result in general software reliability problems, but if an attacker can intentionally trigger a resource leak, it may be possible to launch a denial of service attack by depleting the resource pool.

**Recommendations (Generated by tool)**
When a resource is created or allocated, the developer is responsible for properly releasing the resource as well as accounting for all potential paths of expiration or invalidation. Ensure that all code paths properly release resources

Class:
com.google.common.io.Files
 This is the complete information that the tool provides.
It relates to improper closing of connections that are created in the class com.google.common.io.Files.
 After looking at the Files class, I came to a conclusion that java doc of Files should be updated to say that users of the API are responsible for closing resources. Secondly, I think the tool is reporting correctly since the class opens files but does not close them. So @venusjain10 , look at places where the Files API is used and check if the resources are closed properly and you should be OK. And for guava, someone should update the java doc.
  We are using google commons APIs in our project and security scan on our code has reported following problem. Could you please let me know if this is of any concern or it can be fixed in new version of this API.

**Problem:** Creating and using insecure temporary files can leave application and system data vulnerable to attack. In particular,file names created by the tmpnam family of functions can be easily guessed by an attacker. If an attacker can predictthe filename and create a malicious collision, he may be able to manipulate the behavior of the application.

**Recommendations (Generated by tool)**
Ensure that unpredictable names are used for temporary files and that files are created in a secure directory with appropriate permissions. Using mkstemp() is a reasonably safe way to create temporary files. It will attempt to create and open a unique file based on a filename template provided by the user, combined with a series of randomly generated characters. Note that mkstemp() is safe if only the descriptor is used and the returned filename is not used in a subsequent function call with extra privileges. Using mkstemp() does not completely eliminate race conditions but does provide better protection than other methods

Class:
com.google.common.io.FileBackedOutputStream
 I have not used the class FileBackedOutputStream directly. However I am not sure if the classes that we have used from the API internally use FileBackedOutputStream.
  We are using google commons APIs in our project and security scan on our code has reported following problem. Could you please let me know if this is of any concern or it can be fixed in new version of this API.

**Problem:** Standard random number generators do not provide a sufficient amount of entropy when used for security purposes. Attackers can brute force the output of pseudorandom number generators such as rand().
**Recommendations (Generated by tool)**
If this random number is used where security is a concern, such as generating a session identifier or cryptographic key, use a trusted cryptographic random number generator instead

com.google.common.cache.Striped64 
 Does that mean one should look for an Alternative API in case security is a concern for the project?
 Can you provide some link that provides details information of randomness prediction and control?
I need to understand how do I make sure that the randomness is Controlled and predictable as I have not invoked the Striped64 class directly in my application code.
 And in case I am looking for optimized code, what is my option? The issue is that the code scan has reported it as a major problem.
 I was just trying to confirm that the API internally does not use the class for security purposes. i understand that is not the case. Thanks for your help!
  If there's a plan to implement this method in ImmutableMap.Builder, I'm happy to send a CL.
 Yep, we're using copyOf on a hash map. Thought I'd save some memory,
though.
  The links at https://github.com/google/guava/wiki/HashingExplained#hashing are referring to 12.0 docs meanwhile the links in other sections above are referring to snapshot version.
  I wasn't able to find an issue for this, so apologies if this has been raised already.

Has Guava been tested with any of the early-access Java 9 and/or Jigsaw releases yet?

If not, this seems to be a pretty important medium-to-long-term thing to look into, as Guava currently uses sun.misc.Unsafe in a number of places, which by my understanding would prevent Guava from being used in Jigsaw-enabled versions of Java, including Java 9.
 Guava's usage of Unsafe always has a fallback if any problem occurs.

On Wed, Sep 21, 2016 at 12:36 PM, Jonathan Bluett-Duncan <
notifications@github.com> wrote:

> I wasn't able to find an issue for this, so apologies if this has been
> raised already.
> 
> Has Guava been tested with any of the early-access Java 9 and/or Jigsaw
> releases yet?
> 
> If not, this seems to be a pretty important medium-to-long-term thing to
> look into, as Guava currently uses sun.misc.Unsafe in a number of places,
> which by my understanding would prevent Guava from being used in
> Jigsaw-enabled versions of Java, including Java 9
> 
> —
> You are receiving this because you are subscribed to this thread.
> Reply to this email directly, view it on GitHub
> https://github.com/google/guava/issues/2571, or mute the thread
> https://github.com/notifications/unsubscribe-auth/AA5Cl6sN5NjLotWT34upHBri7CQqC54Aks5qsYcpgaJpZM4KDMZj
> .

## 

Kevin Bourrillion | Java Librarian | Google, Inc. | kevinb@google.com
 Yes, that's true actually!

However, I think the fallbacks work on the assumption that sun.misc.Unsafe is a class which exists and which can be made accessible by reflection, which I believe has been "fixed" in Jigsaw by either removing sun.misc.Unsafe completely or moving it to a jdk-internal module which can only be accessed with a command-line argument. If I'm mistaken on this, then I'd be more than happy to be proved so. :)

But despite all this, I still think it's important to test Guava against Java 9 and Jigsaw if it's not been done so already, in case there are other crucial areas where backwards-compatibility has been broken and would otherwise prevent open source Guava's uptake by Java 9 users in the future.
 Ah, I see.

We'll be receptive to specific fix requests, but probably won't be able to put much thought into this ourselves until we get to the point of testing migrating ourselves to Java 9.  (Bear in mind we finally successfully moved to Java 8 last week! But Java 9 should definitely be a quicker project.)
 Ah yes, I learned about your successful migration to Java 8 the other day. Congratulations!

Going back to the subject of Java 9 though, you may very well be right about it being quicker to migrate to than Java 8.

On one hand, it'll help that with the release of [MRJARs](http://openjdk.java.net/jeps/238), one can have build artifacts that continue to use internal APIs like com.sun.\* on Java 8 but use officially supported replacements on Java 9+. But on the other hand, if there are places in Guava where com.sun.\* is vital and Oracle have not provided sufficient replacement APIs, then Guava may end up being stuck on Java 8, which concerns me.

I'm also concerned by how OpenJDK 9 has, at the time of writing of me writing this, gone past the Feature Complete milestone, which may make improving the replacement APIs difficult if needed.

What are your thoughts on this @kevinb9n?

Also, whereas I don't feel qualified enough to _thoroughly_ test Guava against Java 9 & Jigsaw and to talk to Oracle in your stead (as I'm not familiar with all of Guava's intricacies), I _am_ more than happy to run Guava against Java 9 and reply back to this issue if I discover anything. Would you be happy if I did this @kevinb9n?
 According to `jdeps -jdkinternals`, Guava only relies on `sun.misc.Unsafe`, which has been mostly replaced by [variable handles](http://openjdk.java.net/jeps/193) in Java 9. There might be some other things that are different but not explicitly depended on. I'm going to try making a fork of Guava that uses Java 9 as it's JDK requirement and run my small projects on that for testing.
 I just ran `jdeps -jdkinternals` using jigsaw-jdk-9-ea+136_windows-x64_bin on my copy of Guava, and it seems that `sun.security.jca.{ProviderList, Providers}` and `sun.misc.FpUtils` are used in test code as well. But I'm not so concerned about that, because the tests which use those APIs are more-or-less one off cases, and it looks like they can be changed, disabled or removed if needed.

I also did a half-thorough search of the Guava non-test codebase, and it seems that @kevinb9n was actually right, and I was wrong!

Although using `sun.misc.Unsafe` on a JVM which doesn't have that class would cause exceptions/errors to be thrown by the Guava classes that use it, it seems the exceptions _do_ get caught _eventually_, higher up all the potential call chains, by other Guava classes, and that viable alternatives would be used whenever they happen.

So it seems this issue is actually not as urgent as I first thought it was! :stuck_out_tongue_closed_eyes: 
 I also just ran through `master` and replaced all the usages of `Unsafe` with `VarHandle`. The code looks much cleaner, and it was a quick & easy transition. So handling this when Java 9 is released probably shouldn't be too much of a hassle.

The main pain I encountered while doing this was that the tools used in the maven build can't handle Java 9 yet, so I can't actually make a build of it immediately.
 @kenzierocks Thanks for looking into that.

So I suppose this would only be urgent then if Guava starts having users who try to _compile_ the Guava sources or tests with JDK 9+ and they find that certain `sun.*` classes which Guava depends on have been removed. But we won't really know until Maven supports Java 9.

I also don't know enough to know exactly which classes have been planned for removal/module encapsulation in JDK 9 and which are just deprecated (jdeps doesn't seem to give me the whole picture here), so more research would be needed.
 The transition might be made even easier by the lexicographical [`Arrays::compare`](https://bugs.openjdk.java.net/browse/JDK-8033148) methods, which could potentially be used to implement or replace `UnsignedBytes.lexicographicalComparator`.
 I found this use of an internal JDK field which doesn't work on Java 9.

https://github.com/google/guava/commit/b5b4b40a9c17484828dbd7ceb28e0a468dad0b75#commitcomment-20536128

There's a fallback, but it just does nothing. Is that a problem? What goes wrong if we use the fallback? Filed https://github.com/google/guava/issues/2920 (SGTM, @eamonnmcmanus. Many thanks in advance!)  If you call hasLowerBound()/hasUpperBound() without checking for null you are getting a NPE if the Range itself wasn't initalized. It should return false if the lower/upper Endpoint is null.

`
  public boolean hasLowerBound() {
    return lowerBound != Cut.belowAll();
  }
`
  https://github.com/google/guava/wiki/CollectionHelpersExplained

I read it, but I don't quite get it.  

``` java
@Override public boolean addAll(Collection<? extends E> c) {
    return standardAddAll(c); // implements in terms of add
  }
```

How do you know that `standardAddAll` calls `add`?  Do you go read the source code?  Is it part of the contract in a doc I missed?  

The reason I ask is that I'm trying to do the same making a "virtual" table, and I'm not sure in how many places I need to override the calls if I'm creating my own columns.  columnMap?  columnKeySet?  All methods with the word "column" in them?
 Reading this particular paragraph...

"A sensible definition of addAll(java.util.Collection<? extends E>) in terms of add(E). If you override add(E), you may wish to override addAll(java.util.Collection<? extends E>) to forward to **this implementation**."

...makes me realise I'm not so sure what "this implementation" refers to.

I'm reasonably sure it refers to `standardAddAll`, but somehow the wording is throwing me off a bit; it's as if "this implementation" could refer to `add` instead.

Wouldn't it be better to reword the paragraph like so?

"A sensible definition of addAll(java.util.Collection<? extends E>) in terms of add(E). If you override add(E), you may wish to override addAll(java.util.Collection<? extends E>) to forward to `standardAddAll`."

(Or would most people understand the original paragraph, and is it just that my... sense?... of the English language a bit unusual? :wink:)
 I can describe what I was trying to do, and maybe that example will help clarify if the wording needs tuning.

I've got a table that fits in my allowed memory.  It has a special column "pixels" that has some poorly encoded image data, as well as other regular columns.

I'd like to "pretend" to all downstream consumers that the table doesn't have a column "pixels", but instead actually has (virtual) columns pixel.1, pixel.2... pixel.484 that map to that cell's specific offset pixel value.  (I can read the entire column and find the max pixels to find the 484 limit)  In my first naive attempt I blew it out to 484 additional columns, but that hit a memory limit.  So I read up on ForwardingTables, and it sounded perfect for these sort of "virtual" columns.

But then I ran into this paragraph, and started wondering how many places I would have to override for the virtual columns to be consistent across all method calls - if I had to do    `containsColumn` as well as `column` as well as `columnMap` etc.
  On Travis there appears to be a warning regarding a forked jvm. An example build is https://travis-ci.org/google/guava/jobs/143991838#L5029

> [INFO] Running com.google.gwt.junit.tools.GWTTestSuite@53d5264c
> [WARNING] Forked JVM has been killed on time-out after 600 seconds

This seems to be happening on all builds and I can also reproduce this error locally running on Ubuntu 16.04.
 Sadly the errors have returned after commit https://github.com/google/guava/commit/c298e2dcfed6c3f42407477b9fc6fc5094d88468, see builds https://travis-ci.org/google/guava/jobs/161959726#L5083 and https://travis-ci.org/google/guava/jobs/161705406#L5065
  Javadoc at FluentIterable#isEmpty() says:
"Determines whether this fluent iterable is empty."

However, in reality it checks whether underlying iterator is exhausted yet and never checks for emptiness. Either the method  behaviour or the javadoc is misleading.
  update source
  Typo fix - link -> line.
 I signed it!
 Ah, it was, I've done another one now, it seems you can't change the email address on the CLAs. Hopefully it can support two for the same github account. It's a lot of work to fix a single character in the documentation....
  To continue the conversation I started at https://github.com/google/guava/commit/0f0f616ef7962d97748e2b1bbbd539e96dcbc7b4#commitcomment-18709801, I found a potential replacement for lines 76-84 which both removes the need to copy `reachableNodes` set into an `ImmutableList` and, like the current solution, carefully avoids iterating over all reachable nodes within the inner loop unless necessary.

``` java
...
Set<N> reachableNodes = reachableNodes(graph, node);
visitedNodes.addAll(reachableNodes);
Iterator<N> outerIterator = reachableNodes.iterator();
for (int a = 0; outerIterator.hasNext(); a++) {
  N nodeU = outerIterator.next();
  for (N nodeV : Iterables.limit(reachableNodes, a + 1)) {
    transitiveClosure.putEdge(nodeU, nodeV);
  }
}
...
```

However, although I'm reasonably certain that the above solution uses less memory and runs faster than the old one for sufficiently large graphs, I've not actually created any benchmarks (JMH or otherwise) or done any profiling to prove so.

When I run all of the tests under `com.google.common.graph` (including some new ones which I wrote myself and put under my local copy of `GraphsTest.java`) with the above code change applied on my Windows machine, they all pass without any problems.

Has the Guava team already considered a solution like this? If not, would it be worthwhile for me to submit a Pull Request for this?
 We have gone ahead and made this change, and it should show up soon.  Thanks for the suggestion, @jbduncan!  :)
 Oh wow, fantastic! How thrilling! :blush: :grin:

I look forward to seeing it pop up in source code. 
 Will I be given credit in the commit message or somewhere else when it rolls in?

I ask because since I didn't actually submit a PR, it I doubt it'll credit me as the author in GitHub's records.
 I did mention your name in the change description. I don't believe GitHub
will register you as the author though (but if that's important I'm sure
there's a way to do it).

On Sep 13, 2016 8:47 AM, "Jonathan Bluett-Duncan" notifications@github.com
wrote:

> Will I be given credit in the commit message or somewhere else when it
> rolls in?
> 
> I ask because since I didn't actually submit a PR, it I doubt it'll credit
> me as the author in GitHub's records.
> 
> —
> You are receiving this because you were mentioned.
> Reply to this email directly, view it on GitHub
> https://github.com/google/guava/issues/2563#issuecomment-246726663, or mute
> the thread
> https://github.com/notifications/unsubscribe-auth/AGCCk59wBO-cjQXAj69xJWL_cBSqD1SYks5qpsWggaJpZM4J6BoU
> .
 @jbduncan You're mentioned in the commit message ("Credit to jbduncan for the idea").  :)
 @Bezier89 @jrtom If I could be registered as the author then that would be great. If not, then as long as I'm given credit in the commit message then that's fine with me too. :)
  if there is still bytes to read.
 CLA signed.
 After examination of the javadoc, the current behavioir is not a bug:

> An attempt is made to read as many as `len` bytes, but a smaller number may be read.

It is just that the code that exposed bad behavior did not use `com.google.common.io.ByteStreams#read` or equivalent.
  Adding checkPositive MathPreconditions before using value of x in ceilingPowerOfTwo and floorPowerOfTwo methods.
 Updated email address 
 Presently we are tightly coupled with log2 method to enforce the method contract "@throws IllegalArgumentException if {@code x <= 0}"

I'm following fail fast concept at this place. If we know that for non positive values of x this method is going to fail we can fail it even before calling log2 method.
  Please review [NewCollectionTypesExplained#multimap](https://github.com/google/guava/wiki/NewCollectionTypesExplained#multimap`).
Search for "mapping from unique keys to collections of values".

In NewCollectionTypesExplained.md there is:

> a -> [1, 2, 4]
> b -> [[3|3]]
> c -> [[5|5]]

that was likely supposed to be:

> a -> [1, 2, 4]
> b -> [3]
> c -> [5]

Thanks!
   I signed it!
 I haven't, sorry! Shame on me :(
  As detailed in issue #2554 there was a bug in com.google.common.collect.testing.Helpers#isEmpty when passed an Iterable that is not a Collection.

Added a test that fails before the patch, succeeds after.
 Fair enough! Thanks for the direction.
  I think this code:

```
 public static String toString(Iterable<?> iterable) {
    return Iterators.toString(iterable.iterator());
  }
```

Should perform a Null check, like:

```
 public static String toString(Iterable<?> iterable) {
if (iterable == null) {
    return "null";
}
    return Iterators.toString(iterable.iterator());
  }
```

Currently I have a very complex object that I can't toString() because some field in its fifth hierarchy uses this toString() and I get a NPE.
 Hi, I can't control the types inside the nested iterables.
About the backwards incompatibility:
1) Do you mean that there might be some consumer code that relies on this to throw NPE and you don't want to break it?
2) The "normal" way in Java when you try to print null to a log, is to write the string 'null' and not throw an NPE.
 Thanks for the quick respond.
I can't control those places because I am using a third party and these objects are not in my control.
   can we make :

Ints.tryParse(String s, int radix)
Longs.tryParse(String s, int radix)

more flexible:

Ints.tryParse(CharSequence s, int radix)
Longs.tryParse(CharSequence s, int radix)

?
 Overloads would work, the only concern is that the extra indirection (assume no copy paste) increases the likelihood of hitting the MaxInlineLevel limit which might result in perf degradation in certain use cases.
  I this morning mvn downloaded updates for guava-gwt-20.0-SNAPSHOT.

If I compile gwt project with gwt.version 2.8.0-beta1 I get this error.

```
Compiling module app.Application
[INFO]    Tracing compile failure path for type 'com.google.common.collect.BinaryTreeTraverser'
[INFO]       [ERROR] Errors in 'jar:file:/Users/ros/.m2/repository/com/google/guava/guava-gwt/20.0-SNAPSHOT/guava-gwt-20.0-SNAPSHOT.jar!/com/google/common/collect/BinaryTreeTraverser.java'
[INFO]          [ERROR] Line 134: No source code is available for type java.util.BitSet; did you forget to inherit a required module?
[INFO]    [ERROR] Aborting compile due to errors in some input files
```

With gwt 2.8.0-rc1 my project compile but can't upgrade gwt version.
 I agree with you.
We have a problem with SDM which fails during the first compilation and the problem seems in the generation of the source maps compiling with  GWT 2.8.0 rc1 (and rc2)(https://groups.google.com/forum/#!topic/google-web-toolkit/ATR3ZWcVrEs) 
We also hope they'll fix with final 2.8.0 but in the mean time we are stuck.
  GWT 2.8 added BitSet emulation.
 Since, this error appears now : 
[INFO]    Tracing compile failure path for type 'com.google.common.collect.BinaryTreeTraverser'
[INFO]       [ERROR] Errors in 'jar:file:/Users/cyril/.m2/repository/com/google/guava/guava-gwt/20.0-SNAPSHOT/guava-gwt-20.0-SNAPSHOT.jar!/com/google/common/collect/BinaryTreeTraverser.java'
[INFO]          [ERROR] Line 134: No source code is available for type java.util.BitSet; did you forget to inherit a required module?
[INFO]    [ERROR] Aborting compile due to errors in some input files

Somebody has an idea ?
 @spirylics https://github.com/google/guava/issues/2547
  GWT 2.8 has ArrayDeque implementation
  The implementation of the method indexOf(Object o) in the AbstractList iterates over the iterator. In the case of Cartesian list, the index can be computed instead.
  A return statement occurred in the first
iteration of the loop making the loop
statement redundant, as it is semantically
equivalent to an if-statement.

Replaced the loop-statement with the
equivalent if.
 I signed it!
  [`TreeRangeMap.getEntry()`](https://google.github.io/guava/releases/snapshot/api/docs/com/google/common/collect/TreeRangeMap.html#getEntry%28K%29) returns a `Map.Entry` that doesn't support [`Map.Entry.setValue()`](http://docs.oracle.com/javase/7/docs/api/java/util/Map.Entry.html#setValue%28V%29). This would be particularly useful for `RangeMap`s, where the caller may not know in advance what the actual key (the range) is.
 By "doesn't support put" are you referring to the unmodifiable map returned by [`.asMapOfRanges()`](https://google.github.io/guava/releases/snapshot/api/docs/com/google/common/collect/TreeRangeMap.html#asMapOfRanges%28%29)? I would agree that does't need to support `.setValue()`, though I see now it's backed by the same `Map.Entry` instances `.getEntry()` returns.

Conceptually it makes sense to me that a `TreeRangeMap`'s values could be modified by calls to `setValue()` on the entries the `TreeRangeMap` _itself_ exposes (as opposed to an unmodifiable view).

My specific use-case involved aggregating data - I constructed a `TreeRangeMap<LocalDate, Integer>` and added a series of ranges with `0` as the value. I was hoping I could then do something like:

```
for (Datapoint d : datapoints) {
  // no knowledge at this point of which range the datapoint falls into
  Entry<Range<LocalDate>, Integer> e = rangeMap.getEntry(d.date());
  e.setValue(e.getValue() + d.value());
}
```

But this raises an exception, even though I could do:

```
Entry<Range<LocalDate>, Integer> e = rangeMap.getEntry(d.date());
rangeMap.put(e.getkey(), e.getValue() + d.value());
```

I know it's not a huge distinction in terms of performance, but I was surprised `.setValue()` wasn't supported. I'd argue the intent of this second format is less clear, as well.

As another benefit, if the caller doesn't need to incorporate the old value it even becomes a one-liner:

```
rangeMap.getEntry(d.date()).setValue(d.value());
```
 I notice now that `TreeMap` doesn't support `Entry.setValue()` either (which surprised me - I'd have thought it would be particularly beneficial for a tree since it would provide O(1) value-overwrites). Nevertheless, I think there's still value for `RangeMap` since the caller may not even have the actual `Range` key a priori.
 Strange, `TreeMap.Entry.setValue(V)` **is** supported, at least Oracle Java.
  Currently the ImmutableTable is not Serializable. Is it for any reason?
  The Javadoc link just 404s to the broken Googlebot.
 The one on the front page for the latest release.  This one:
http://google.github.io/guava/releases/19.0/api/docs/
 Hmmm it may be something to do with the network administration here, I will investigate that first.  Sorry to have bothered you.
  Add a method to create a temp directory beneath a user defined parent directory instead of the system's temp directory
  add repository
  same on
  Just adding a method similar to already existing in Strings class, I'm thinking in something like [this](https://github.com/google/guava/compare/master...jonathanbeber:master)
 @lowasser got there just before me! :smiley: 
  Today I tried to build a few ImmutableMaps which store class objects and related conversion functions. This worked well for primitive types and the related Wrapper functions but not for Lists and Collections. As soon as I started to add multiple related classes java compilation broke with 

> error: incompatible types: Object is not a functional interface 

and nothing more. IntelliJ and other IDEs do not show any related error hints and when I change Immutable map to JDK classses like HashMap the error disappears.

Success:

``` java
private static final Map<Class, Function<List, ?>> convertListToType  
        = ImmutableMap.<Class, Function<List, ?>>builder()  
            .put(String.class, Object::toString)  
            .put(Set.class, HashSet<Object>::new)
            .build();  
```

``` java
    private static final Map<Class, Function<Integer, ?>> convertIntegerToType
        = ImmutableMap.<Class, Function<Integer, ?>>builder()
            .put(double.class, Double::new)
            .put(Double.class, Double::new)
            .put(float.class, Float::new)
            .put(Float.class, Float::new)
            .put(long.class, Long::new)
            .put(Long.class, Long::new)
            .put(String.class, Object::toString)
            .build();
```

Different Error Cases:

``` java
private static final Map<Class, Function<List, ?>> convertListToType  
        = ImmutableMap.<Class, Function<List, ?>>builder()  
            .put(Set.class, HashSet<Object>::new)
            .put(String.class, Object::toString)  
            .build();  
```

(This is the first success case with rows switched.)

``` java
private static final Map<Class, Function<List, ?>> convertListToType  
        = ImmutableMap.<Class, Function<List, ?>>builder()  
            .put(String.class, Object::toString)  
            .put(Set.class, HashSet<Object>::new)
            .put(HashSet.class, HashSet<Object>::new)
            .build();  
```

(This is the first success case with an additional row containing the  "HashSet.class"  information.)
 Interesting find.  Java 9's javac and Eclipse's compiler can both handle this, so it does look like a bug in Java 8's javac.

I don't know how Guava could work around this.  Consider this other code which demonstrates the same problem:

``` java
import java.util.List;
import java.util.Map;
import java.util.function.Function;

class GenericsTest {
  static class Builder<K, V> {
    Builder<K, V> put(K k, V v) { return this; }
    Map<K, V> build() { return null; }
  }

  static Map<Class, Function<List, ?>> convertListToType =
      new Builder<Class, Function<List, ?>>()
          .put(Integer.class, GenericsTest::foo)
          .put(String.class, Object::toString)
          .build();

  static <T> Integer foo(List<T> list) {
    return null;
  }
}
```

Is something wrong with the signatures of `Builder`?  If so, I don't see it.

I think the only choice is to work around this application side, for example by avoiding raw `List` in favor of wildcard `List<?>`.
 Okay. If it isn't a failure on guavas site I will close this issue.
  Hello,

I try to get all classes within a package:

``` java
ClassPath.from( Thread.currentThread().getContextClassLoader() ).getTopLevelClassesRecursive( "my.package" );
```

This works fine, except the jar file contains spaces. My jar stores all dependencies so I can get the classes from my jar:

```
test.jar/
    my/
         package/
               someclass.class
```

If I run the test.jar within a path without spaces e.g. c:\Users\MyUser\ with java -jar test.jar everything is fine, but on c:\Users\MyUser\Dir With Spaces\ and java -jar test.jar the getTopLevelClassRecursive returns an empty set.

Same error exists under OSX, if I run the jar under /User/MyUser/ with java -jar test.jar everything is fine but under /User/MyUser/New Folder/ I get also an empty set.
 Duplicate of https://github.com/google/guava/issues/2152?
 Yes, it's a duplicate. `#getTopLevelClassesRecursive` delegates to `#getTopLevelClasses`. see parsing spaces when it changed for '%20' in cmd or classLoader 

Example: file:/C:/Program%20Files/lib.jar @flashpixx #2152 has been resolved, I think you can close this one.  The snapshot API has the following typos:

`com.google.common.math.StatsAccumulator`: `public final double populationVariance()` and
`com.google.common.math.Stats`: `public double populationVariance()` say

> This is guaranteed to return zero if **the the** dataset contains only exactly one finite value.

Instead of

> This is guaranteed to return zero if **the** dataset contains only exactly one finite value.
  Hello, how do you guys like an idea for an [equalsHelper](https://github.com/vorburger/java-sandbox/blob/master/equalshelper/src/main/java/ch/vorburger/equalshelper/MoreObjects2.java), which [can be used like this](https://github.com/vorburger/java-sandbox/blob/master/equalshelper/src/test/java/ch/vorburger/equalshelper/Thing.java#L10) ? 

The point would just be to avoid repeating the well known null/this/getClass() in every equals() - less litany, more readable code, less accidental bugs.

Just a thought, interested to hear if you think this is cool (and could be something for Guava).
 AutoValue has the big disadvantage of not being compatible with major ORM frameworks, for instance. While an approach like the one suggested is.
 @lowasser yep I've seen AutoValue (but never actually tried it) - certainly like the approach a lot in general (personally I'd Code Generate my grandmother, if she was alive..), and do realize/just (re)learnt the PITA of hand-writing hashCode and equals (arrays, urgh! see https://git.opendaylight.org/gerrit/#/c/41600/), but there probably still are some cases when people hand-write equals? For those, perhaps this could be handy.

BTW: Perhaps you'd like to point to AutoValue more prominently from the main Wiki page about this where everyone looks at, on https://github.com/google/guava/wiki/CommonObjectUtilitiesExplained ?

PS: The  trouble with tribbles, erm AutoValue, is applying it to (badly written..) existing "beans" used in a code base imposes changes e.g. from constructor to builder or factory - that's not always easily possible.
  This is a semantics-preserving refactoring that migrates existing method implementations in classes to the corresponding implemented interface methods as `default` methods. The tool **does not** add new code; it only rearranges _existing_ code.

We have upgraded the compilation process to use Java 8 so that default methods can be used. However, we realize that this may not be acceptable. Still, any feedback you can supply would be helpful.
- We are evaluating a research prototype automated refactoring Eclipse plug-in called [Migrate Skeletal Implementation to Interface](https://github.com/khatchad/Migrate-Skeletal-Implementation-to-Interface-Refactoring). We have applied the tool to your project in the hopes of receiving feedback.
- The approach is very conservative. That may mean that not all changes that can be made were made. Please feel free to continue the refactoring manually if you wish.
- We only migrated methods declared in abstract classes with the hopes of such methods being suitable default methods in corresponding interfaces.
- The source code should be semantically equivalent to the original.

Thank you for your help in this evaluation! Any feedback you can provide would be very helpful. In particular, we are interested if each of the proposed changes are helpful or not.
 I signed it!
 Thank you for the consideration, @kluever! We'll be on the look out for the Java 8 branch.
 Hi @kluever and @lowasser. I am thinking of applying for a [Google Faculty Research Award](http://research.google.com/research-outreach.html#/research-outreach/faculty-engagement/faculty-research-awards), deadline September 30, 2016, and proposing something based on this research. I know it is a ways away, but I was wondering if you know anyone that would be interesting in sponsoring the application, as that is one of the available fields. I can send more information if desired. Thanks!
  HTTP/2 requires lowercase, and it's our collective future. Any code that cares
about the casing of headers is broken, so any code that breaks from this change
is destined to break when it's used with HTTP/2.

String.toLowerCase() and Ascii.toLowerCase() both have optimizations that make
code run faster if the input is already lowercase. I estimate that 0.0000001%
of Google's extensive compute resources are currently wasted converting headers
to lowercase when they could be lowercase already.
 Works for me. Two quick notes about why this is too bad:
1. Any code that cares about case sensitivity here is almost certainly incorrect. Until recently this was academic. But any header that travels through an HTTP/2 channel comes out the other end in lowercase. ”Pushing a change of this magnitude through” is fixing buggy code.
2. Because HTTP/2 exists, attempting to preserve case in HTTP headers is now a waste of code and CPU cycles. For example we use slow awkward TreeMaps with case-insensitive comparators rather than fast convenient LinkedHashMaps with lowercase keys.
   I signed it!
  The utility class `Sets` could use a new method `<T> Set<Set<T>> partition(Set<T> set, int size)`, similar to the one in `Lists` class. Such a method would be useful for various applications, e.g. for batch processing elements for which order is unspecified/unimportant, and I don't think there is a straightforward way of achieving the same effect with Java 8 streams API.
 It's simply a matter of convenience. Let's say I have a method `void processElements(Set<Element> elements)`, a set of elements `Set<Element> elements` and I'd like to process these elements in batches. I can achieve that using `Iterables.partition`, e.g. like that:

```
StreamSupport.stream(Iterables.partition(elements, batchSize).spliterator(), false)
    .map(list -> new HashSet<Long>(list)).forEach(batch -> {
        processElements(batch);
    });
```

But I'd much prefer to be able to do it like that:

```
Sets.partition(elements, batchSize).forEach(batch -> {
    processElements(batch);
});
```

I find the latter more concise and more readable.
 Or one like `partition(Set<T> set, int size, Supplier<Set<T>> setCreator)`?
  Added static method to create Striped with Locks with 'fair ordering policy' = true
 I signed it!
  Seems caused by 
LocalCache.java

  boolean isExpired(ReferenceEntry<K, V> entry, long now) {
    checkNotNull(entry);
    if (expiresAfterAccess()
        && (now - entry.getAccessTime() >= expireAfterAccessNanos)) {
      return true;
    }
    if (expiresAfterWrite()
        && (now - entry.getWriteTime() >= expireAfterWriteNanos)) {
      return true;
    }
    return false;
  }

Since expireAfterWrite = 0

But method
expiresAfterWrite() is implemented like
boolean expiresAfterWrite() {
    return expireAfterWriteNanos > 0;
  }

It never performs the time check
 I observed that behaviour during some tests with the following cache

``` java
private final LoadingCache<String, Optional<String>> someCache = CacheBuilder.newBuilder()
            .weigher(STRING_WEIGHER)
            .maximumWeight(20000)
            .expireAfterWrite(0, TimeUnit.SECONDS)
            .softValues()
            .build(new CacheLoader<String, Optional<String>>() {
                @Override
                public Optional<String> load(@NotNull final String s) throws Exception {
                    return loadCache(s);
                }
            });
```

Some previous tests loaded some values on the cache and a later test reading it was returning the actual value from the cache instead of invoking the "load" operation, even though the expireAfterWrite was set to 0.
Maybe I overlooked something. I will take a few more looks into it. 
 I couldn't reproduce. Can you provide an isolated test case?
  just like method, 

```
 public static <K, V> ImmutableMap<K, V> uniqueIndex(Iterator<K> keys,
      Function<? super K, V> valueFunction) 
```

add a method with three parameters(Iterator object, Function keyFunction, Function valueFunction), for each object in Iterator, we use keyFunciont and valueFunciton to get key and value for map.
 for _example：

``` java
 public static <T, K, V> Map<K, V> uniqueIndex(Iterator<T> values, Function<T, K> keyFunction, Function<T, V> valueFunction) {
        checkNotNull(keyFunction);
        checkNotNull(valueFunction);
        ImmutableMap.Builder<K, V> builder = ImmutableMap.builder();
        while (values.hasNext()) {
            T value = values.next();
            builder.put(keyFunction.apply(value), valueFunction.apply(value));
        }
        return builder.build();
    }
```
  See Issue #2509 
 I signed an individual CLA.
   **Failure cases:**
_1) Positive_
Values rounded incorrectly: `0.99999999999999984` to `0.99999999999999994`
Rounding modes: CEILING or UP
Expected: `1`
Actual: `2`

_2) Negative_
Values rounded incorrectly:`-0.99999999999999984` to `-0.99999999999999994`
Rounding modes: FLOOR or UP
Expected: `-1`
Actual: `-2`

**Remarks:**
The reason is that values between 0 and 1 have higher fraction precision than values between 1 and 2. The code adds 1.0 to the value x, and double arithmetic uses HALF_EVEN rounding by default. This leads to unexpected results for edge cases when HALF_EVEN triggers rounding UP to 2.

**Proposed FIX:**
The FIX is to cast the double value `x` to a long before the addition of `1.0`:
Current:`x + 1.0`
Fixed: `(long)x + 1.0`

**Pull Request:**
See pull request [#2511](https://github.com/google/guava/pull/2511)
  Specifically [here](https://github.com/google/guava/wiki/ListenableFutureExplained#application).

For the method that accepts an `AsyncFunction`, it should be renamed from `transform` to `transformAsync` instead. I would contribute but I'm not sure how to access the wiki as an intern.

:smiley: 
  merge
  `Iterators.forArray` returns `UnmodifiableIterator`, but that just calls an overload, that returns an `UnmodifiableListIterator`

It would be useful if the public method returned a `ListIterator`, rather than restricting it to `Iterator`.

Plus, it would be good if the various overloads (array, offset, length) and (array, offset, length, index) were publically accessible, seeing as one `forArray` method is public already.
 It would be binary-incompatible, since the return type of a method is part of its signature, as encoded in the invokestatic instruction in class files.
  Looks like that there is an issue in EventBus - there is a way to register same handler class with one handler method two times and event will be handled 2 times 

Here is gist with test to reproduce this issue 
https://gist.github.com/kronar/4614b636ec5c379f1cd5df2a6fed1ec4
 @lowasser I've  implemented builder for event bus which scans package in classpath and filters classes having methods annotated with @Subscribe annotation.  Couple of classes have multiple methods with this annotation so list of those classes contains duplicates. Therefore some pieces of business logic we're executed twice.  
  At ComparisonChain.java line 81.
Argument left can be null, if left is null, will throw NullPointException.
Must write as below code, not elegant.

`return ComparisonChain.start()`
`.compareFalseFirst(firstName != null, o.firstName != null)`
`.compare(firstName, o.firstName)`
  Currently, example code in the description of ImmutableSortedMultiset.Builder class contains call for constructor which doesn't exist. This PR replaces constructor with `ImmutableSortedMultiset.naturalOrder()` call
 I signed it!
  TreeMultimap.create(TreeMultimap) take O(n)

```
- add new create(TreeMultimap) method using linear constructor of TreeMap

- change specifications of TreeMultimap and AbstractbasedMultimap

- change testMultimapCreateFromTreeMultimap according to new specifications
```

issue:
https://github.com/google/guava/issues/1579
  Currently when calling `Joiner.on(String).join(Iterable<E>)` the `toString()` method is called to get a String from the given Object.
Sometimes you want to use `getName()` or `getText()` in order to get a String instead...
To achieve this the join method could be overloaded accepting a java.util.function.Fuction<T,R> parameter, with T being the generic type of the given Iterable Object, and R being a String.
This way the developer could choose how he wants to get a string from the object.
 That would be useful...
But still,,, I think my attempt would be more intentional...

```
List<JButton> buttons = new ArrayList<>();
//Initializing
Joiner.on(",").join(buttons, button -> button.getText());//returns text
```

I think this would work...

```

  /**
   * Appends the string representation of each of {@code parts}, using the previously configured
   * separator between each, to {@code appendable}.
   *
   * @since 11.0
   */
  @CanIgnoreReturnValue
  public <A extends Appendable, E> A appendTo(A appendable, Iterator<E> parts, Function<E, String> function) throws IOException {
    checkNotNull(appendable);
    if (parts.hasNext()) {
      appendable.append(toString(parts.next()));
      while (parts.hasNext()) {
        appendable.append(separator);
        appendable.append(function.apply(parts.next()));
      }
    }
    return appendable;
  }
```

The current method could be replaced with

```
public <A extends Appendable> A appendTo(A appendable, Iterator<?> parts) throws IOException {
  appendTo(appendable, parts, object -> object.toString())
}
```

EDIT: since you are not using Java 8 it would be a little different for you
 `specialJoin(Iterable<E>, Function<E, String>)` ?
EDIT:
Double checked it... there is no problem in overloading... at least using Java 8
 Also you could change

```
 private static Iterable<Object> iterable(
      final Object first, final Object second, final Object[] rest) {
    checkNotNull(rest);
    return new AbstractList<Object>() {
      @Override
      public int size() {
        return rest.length + 2;
      }

      @Override
      public Object get(int index) {
        switch (index) {
          case 0:
            return first;
          case 1:
            return second;
          default:
            return rest[index - 2];
        }
      }
    };
  }
```

to

```
 private static <E> Iterable<E> iterable(
      final E first, final E second, final E[] rest) {
    checkNotNull(rest);
    return new AbstractList<E>() {
      @Override
      public int size() {
        return rest.length + 2;
      }

      @Override
      public E get(int index) {
        switch (index) {
          case 0:
            return first;
          case 1:
            return second;
          default:
            return rest[index - 2];
        }
      }
    };
  }
```

and

```
  public final String join(@Nullable Object first, @Nullable Object second, Object... rest) {
    return join(iterable(first, second, rest));
  }
```

to

```
  public final <E> String join(@Nullable E first, @Nullable E second, E... rest) {
    return join(iterable(first, second, rest));
  }
```

In order to avoid errors of that kind and maintain type-safety, since therefore the Objects have to be all the same...
  Given:

```
List<Integer> rowKeys = ImmutableList.of(1, 2, 3);
List<Integer> columnKeys = ImmutableList.of(1, 2, 3);
ArrayTable<Integer, Integer, String> input = ArrayTable.create(rowKeys, columnKeys);
ImmutableTable<Integer, Integer, String> option1 = ImmutableTable.copyOf(input);
ImmutableTable<Integer, Integer, String> option2 = ImmutableTable.<Integer, Integer, String>builder().putAll(input).build();
```

`copyOf` and `putAll` throw exceptions as if the developer had asked them to populate cell values with `null` but in actuality the developer didn't didn't explicitly populate the cells in question. In this case, I suggest simply skipping over `null` values and only `put`ing the remaining values.
 @lowasser I was attempting to implement a Stream Collector for `ImmutableTable` using `ArrayTable` as an intermediate container. I guess my point is that it is practically impossible to convert an `ArrayTable` to any other kind of `Table` because of the way nulls are being handled.

Contrast this with `java.util` that differentiates between `null` values set by users versus non-existent mappings. This allows users to easily convert a `HashMap` to a `ConcurrentHashMap` even though the former supports `null` values while the latter does not.

Is there any particular reason that you decided to bubble this implementation detail up to the API level? An alternative implementation would be to add a `BitSet` that keeps track of which cells were explicitly set.
 >  ArrayTable has those null values. That's how it's defined; it starts filled with nulls.

Okay. That point didn't come across when I read `The value corresponding to a given row and column is null unless another value is provided.` I wish there was a way to emphasize/clarify this point. Anyway, thanks for the clarification.
  Don't know if someone is using my accounts 
  Added function Multimaps.index(Set<V>, Function<V, K>) based on
https://github.com/google/guava/issues/2468
  Based on issue https://github.com/google/guava/issues/2468
Added a function Multimaps.indexSet
  Hi, What do you think about adding additional parameters to "of" methods? Currently "of" supports up to 5 K,V.
  I tried building version 19.0 under Windows from source using maven, simply cloned the git repo and issued "mvn install" until the following error occured:

```
org/mockito/internal/stubbing/ConsecutiveStubbing.class,
com\google\common\collect\FilteredCollectionsTest$AbstractFilteredCollectionTest.class,
com\google\common\util\concurrent\AbstractFutureTest$3.class,
com\google\common\collect\TableCollectionTest$TreeRowMapHeadMapTests.class,
com/google/common/util/concurrent/testing/AbstractListenableFutureTest$4.class,
com/google/common/base/AbstractIterator.class,
com/google/common/truth/PrimitiveCharArraySubject.class, 
com\google\common\reflect\TypeTokenTest$324.class,
com/google/gson/LongSerializationPolicy.class,
com/google/inject/spi/InjectionPoint$Position.class,
org/joda/time/tz/data/Europe/Lisbon,
javax/annotation/meta/TypeQualifierDefault.java,
com/google/common/collect/BiMap.class,
com/google/common/collect/Lists$TransformingRandomAccessList$1.class, 
org/mockito/asm/tree/analysis/SmallSet.java, 
org/junit/runner/manipulation/Sorter$1.class, 
com\google\common\collect\MultimapsCollectionTest$2.class, 
com/google/common/util/concurrent/AbstractService$3.class, 
org/joda/time/tz/data/Africa/, 
net/sf/cglib/core/EmitUtils$3.class, 
com/google/common/base/CharMatcher.class, 
com/google/common/collect/MapMakerInternalMap$WeakEvictableEntry.class, 
com/google/common/util/concurrent/SettableFuture.class, 
org/joda/time/YearMonthDay.class, 
com/google/common/collect/Cut.class, 
org/mockito/internal/invocation/InvocationsFinder$RemoveNotMatching.class, 
com\google\common\hash\HashTestUtils$RandomHasherAction$1.class, 
com\google\common\reflect\TypeTokenTest$30.class]>

should have contained <com/google/common/reflect/ClassPathTest.class>
testGetClassPathEntry(com.google.common.reflect.ClassPathTest):

expected:<file:/C:/usr/test/dep.jar> 
but was:<file:/usr/test/dep.jar> 

testGetClassPathFromManifest_absoluteDirectory(com.google.common.reflect.ClassPathTest): 

Not true that <[\with\absolute\dir]> contains exactly <[C:\with\absolute\dir]>. It is missing <[C:\with\absolute\dir]> and has unexpected items <[\with\absolute\dir]>

testGetClassPathFromManifest_multiplePaths(com.google.common.reflect.ClassPathTest):

Not true that <[\with\absolute.jar,
C:\Users\tschoening\Documents\Svn\Src\Libs\trunk\Java\Google\Guava\19.0\src\guava-tests\base\relative.jar,
C:\Users\tschoening\Documents\Svn\Src\Libs\trunk\Java\Google\Guava\19.0\src\guava-tests\base\relative\dir]>
contains exactly <[C:\with\absolute.jar,
C:\Users\tschoening\Documents\Svn\Src\Libs\trunk\Java\Google\Guava\19.0\src\guava-tests\base\relative.jar,
C:\Users\tschoening\Documents\Svn\Src\Libs\trunk\Java\Google\Guava\19.0\src\guava-tests\base\relative\dir]>.
It is missing <[C:\with\absolute.jar]> and has unexpected items <[\with\absolute.jar]>

testGetClassPathFromManifest_absoluteJar(com.google.common.reflect.ClassPathTest):

Not true that <[\with\absolute.jar]> contains exactly <[C:\with\absolute.jar]>.
It is missing <[C:\with\absolute.jar]> and has unexpected items <[\with\absolute.jar]>

Tests run: 726068, Failures: 7, Errors: 0, Skipped: 0
```
  Several times now, I've wanted to know all the row & column values of the cells in a table (but not the actual values) as a `SetMultimap`:

```
<R, C> SetMultimap<R, C> tableRowColumnSet(Table<R, C, ?> table);
```

This would either be a method on the `Table` interface directly, or in the `Tables` helper class (the name needs a bit of work).

There is currently no easy way to get a view of all the rows & columns in the table without creating a new `SetMultimap` manually. This would be analogous to `Map.keySet()` and variants thereof, and seems like an obvious extension to the `Table` interface.
 +1 on this idea. Though I can't remember the context, tucked away deeply in my multi-thousand line `TODO` file there is this note:

```
- Guava: consider filing a Table -> Multimap request
```

(Thanks, I can now remove that entry from my list ;).)
 There could also be methods going the other way, analogous to `Maps.toMap`/`asMap` (using BiFunction from Java 8 as a shortcut):

```
ImmutableTable<R, C, V> toTable(SetMultimap<R, C> rowColumns, BiFunction<R, C, V> getValue);
```
 Its more thinking about the data represented in a `Table` as `(R, C) -> V` rather than `R -> C -> V`. The current API leans towards the latter, but sometimes the data you're using best fits into the former interpretation (while still allowing access as `R -> C -> V`). In that case, the 'keyset' of a table is best represented as a `SetMultimap`, as described.

Our usages here is to load values from a datastore for specific `(R, C)` pairs, which is best represented as a `SetMultimap<R, C>`. The data is loaded into a `Table<R, C, V>`, and we want to do common operations on the pre-loaded and post-loaded keyset (for example, comparisons between the two to see what was actually loaded). The calling code then wants to view the data as a Table for the standard Table operations
  The output log is

```
Loading modules
   cat.contesencatala.contesencatala
      Loading inherited module 'cat.contesencatala.contesencatala'
         Loading inherited module 'gwt.material.design.GwtMaterialWithJQuery'
            Loading inherited module 'gwt.material.design.GwtMaterialDesignBase'
               [WARN] Line 40: Setting configuration property named 'CssResource.legacy' in module 'gwt.material.design.GwtMaterialDesignBase' that has not been previously defined
Super Dev Mode starting up
   Loading inherited module 'cat.contesencatala.contesencatala'
      Loading inherited module 'gwt.material.design.GwtMaterialWithJQuery'
         Loading inherited module 'gwt.material.design.GwtMaterialDesignBase'
            [WARN] Line 40: Setting configuration property named 'CssResource.legacy' in module 'gwt.material.design.GwtMaterialDesignBase' that has not been previously defined
com.google.gwt.dev.jjs.InternalCompilerException: Error constructing Java AST
    at com.google.gwt.dev.jjs.impl.GwtAstBuilder.translateException(GwtAstBuilder.java:3099)
    at com.google.gwt.dev.jjs.impl.GwtAstBuilder$AstVisitor.endVisit(GwtAstBuilder.java:352)
    at org.eclipse.jdt.internal.compiler.ast.AllocationExpression.traverse(AllocationExpression.java:670)
    at org.eclipse.jdt.internal.compiler.ast.Assignment.traverse(Assignment.java:260)
    at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.traverse(MethodDeclaration.java:347)
    at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.traverse(TypeDeclaration.java:1379)
    at com.google.gwt.dev.jjs.impl.GwtAstBuilder.process(GwtAstBuilder.java:3058)
    at com.google.gwt.dev.javac.CompilationStateBuilder$CompileMoreLater$UnitProcessorImpl.process(CompilationStateBuilder.java:141)
    at com.google.gwt.dev.javac.JdtCompiler$CompilerImpl.process(JdtCompiler.java:384)
    at org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:470)
    at com.google.gwt.dev.javac.JdtCompiler.doCompile(JdtCompiler.java:985)
    at com.google.gwt.dev.javac.CompilationStateBuilder$CompileMoreLater.compile(CompilationStateBuilder.java:339)
    at com.google.gwt.dev.javac.CompilationStateBuilder.doBuildFrom(CompilationStateBuilder.java:580)
    at com.google.gwt.dev.javac.CompilationStateBuilder.buildFrom(CompilationStateBuilder.java:513)
    at com.google.gwt.dev.javac.CompilationStateBuilder.buildFrom(CompilationStateBuilder.java:499)
    at com.google.gwt.dev.cfg.ModuleDef.getCompilationState(ModuleDef.java:668)
    at com.google.gwt.dev.codeserver.Recompiler.initWithoutPrecompile(Recompiler.java:200)
    at com.google.gwt.dev.codeserver.Outbox.maybePrecompile(Outbox.java:82)
    at com.google.gwt.dev.codeserver.Outbox.<init>(Outbox.java:61)
    at com.google.gwt.dev.codeserver.CodeServer.makeOutboxes(CodeServer.java:156)
    at com.google.gwt.dev.codeserver.CodeServer.start(CodeServer.java:118)
    at com.google.gwt.dev.codeserver.CodeServer.main(CodeServer.java:91)
    at com.google.gwt.dev.codeserver.CodeServer.main(CodeServer.java:50)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
    at java.lang.reflect.Method.invoke(Method.java:497)
    at com.google.gwt.dev.shell.SuperDevListener$1.run(SuperDevListener.java:84)
Caused by: java.lang.NullPointerException
    at com.google.gwt.dev.jjs.impl.ReferenceMapper.get(ReferenceMapper.java:99)
    at com.google.gwt.dev.jjs.impl.GwtAstBuilder$AstVisitor.pushNewExpression(GwtAstBuilder.java:2642)
    at com.google.gwt.dev.jjs.impl.GwtAstBuilder$AstVisitor.endVisit(GwtAstBuilder.java:350)
    ... 26 more

```

You can check the code here:

https://github.com/rsallar/contesencatala/tree/gwt28error
 Thx!
 I've encountered the same issue
  We have MultiInputStream, why don't we have a MultiOutputStream?
 Exactly! I've been in the process of cleaning dependencies for one project i'm working on. Apache Commons IO have TeeOutputStream class. It's the only class from that whole library my project used. I prefer to use guava instead of apache libs. So i wrote MultiOutputStream myself for now.
 @cpovirk hi, please let me I know what is the status for this issue?
I saw the issue and have an idea how to implement it.
Please let me know.
 @cpovirk Just out of curiosity, does your implementation of "write" method of the mentioned class throw an "aggregate" exception containing the exception(s) occurred on OutputStream(s).
If yes then does the aggregated exception contain reference to faulting OutputStream?

We have implementation like.

```
  public class OutputStreamException extends IOException {
    private static final long serialVersionUID = 4271756986146326876L;
    private OutputStream stream;
    public OutputStream getFaultingStream(){
      return stream;
    }
    public OutputStreamException(Throwable ex, OutputStream stream){
      super(ex);
      this.stream = stream;
    }
  }

  public class MultiOutputStreamAggregateException extends IOException {
    private static final long serialVersionUID = -3124926231957260300L;
    private Iterable<? extends IOException> innerExceptions;
    public Iterable<? extends IOException> getInnerExcpetions() {
      return innerExceptions;
    }
    public MultiOutputStreamAggregateException(Iterable<? extends IOException> innerExceptions){
      super("Aggregated MultiOutputStream IO exception");
      this.innerExceptions = innerExceptions;
    }
  }
```

Thanks
   Currently Iterables.frequency() only supports finding object based on equals() method, and for getting frequency by custom predicate, user has to resort to doing something like Iterables.size(Iterables.filter(iterable, predicate));

Would be nice to have a convince method to enable getting frequency by predicate.
  As a developer working in an insurance company which registered in Shanghai, I have a lot of problems in checking out and pulling the volley repository through a proxy server in this insurance company. I highly recommend you store the volley repository on github.com! Thank you all very much!
 Volley is part of AOSP

On Mon, May 16, 2016, 10:51 PM Kurt Alfred Kluever notifications@github.com
wrote:

> What is the volley repository? Are you sure you reported this to the
> correct project?
> 
> —
> You are receiving this because you are subscribed to this thread.
> Reply to this email directly or view it on GitHub
> https://github.com/google/guava/issues/2482#issuecomment-219625753
  Maybe this should be an issue instead of pull request, if you find this to be against the guidelines for contributing, please feel free to close this request immediately. I wanted to send a pull request instead to demonstrate how invasive the change would be. (not very)

Basically I was using `LoadingCache<String, Value>` in my application and used it to cache data based on a string key, and I also needed to invalidate the cache, so invalidate(key) was called whenever necessary. Later on I needed to change the type of the `LoadingCache` to `LoadingCache<Wrapper, Value>` in order to pass on some extra parameters for the `CacheLoader`. Everything compiled and seemed to work fine, but after a while some cache invalidation issues started to come up.

After debugging I figured out that the signature of `invalidate(key)` is actually `invalidate(Object key)`, instead of using the actual key type. The lack of cache invalidation in turn caused inconsistency in our actual data and at least a day of extra work trying to fix everything manually. So I thought if having the key type included in the signature could've saved me hours of work, maybe I'm not the only one.

In theory it would be possible that someone is using an object for invalidation that is not a subclass of key, but would still equal to it. In practice I find this rather unlikely, but I would like to hear some comments about how to proceed with this suggested change.

Also, I have not signed the Google CLA yet, but I can do it if necessary.
 It looks like 9eed063 has intentionally erased types from getIfPresent and getAllPresent, so I would be ok by not touching these two and modify the commit accordingly. Don't know the details behind that change, but for invalidate the case still stands in my opinion...
 Looks like a similar issue is discussed in http://smallwig.blogspot.co.uk/2007/12/why-does-setcontains-take-object-not-e.html blog post and the end result would be that the current behaviour is more correct. However, in my particular case the `Well, when I typed that code into IntelliJ, it flagged a warning for me right away.` didn't seem to stand and there were no warnings whatsoever with IntelliJ IDEA 15.

Again, feel free to close this pull request. Guess I just need to solve this issue with big warning messages, but it feels quite wrong...
 I forgot to reply to this, thanks to both of you for suggestions and I'll consider adding FindBugs to the project development process.

For now I'm avoiding the issue by having a generic wrapper around the different cache types we're using with the key type always defined, and unit tests for the cache invalidation. Need to see if that becomes insufficient at some point.
  1. Addition of callback support for Preconditions API :
- checkArgument(boolean expression, Supplier<Object> errorMessge)
- checkState(boolean expression, Supplier<Object> errorMessge)
- checkNotNull(T reference, Supplier<Object> errorMessge)
- check(boolean expression, Supplier<TException> exception)
1. Throwable.catchException utility along with ThrowableAction interface and ThrowableActions utility methods.
 I signed it!
 re: Preconditions

why not just pass a custom object with an overridden toString method?
  For example [Javadoc for package `base`](http://google.github.io/guava/releases/19.0/api/docs/com/google/common/base/package-summary.html) link to [`@ParametersAreNonnullByDefault`](http://jsr-305.googlecode.com/svn/trunk/javadoc/javax/annotation/ParametersAreNonnullByDefault.html?is-external=true) results in 404.

Affects all links to JSR 305 annotations.

As far as I can tell JSR 305 is not maintained anymore. Maybe the easiest solution would be to not link to the JSR 305 annotations in the Javadoc.
 There doesn't appear to be a new home. Perhaps you could just update the Guava build to download https://repo1.maven.org/maven2/com/google/code/findbugs/jsr305/3.0.1/jsr305-3.0.1-javadoc.jar, unzip it, and then point javadoc at the dir where it was unzipped.
 @ispringer Or point to javadoc.io which does what you describe:
http://www.javadoc.io/doc/com.google.code.findbugs/jsr305/3.0.1
  We're seeing a behaviour of a Striped.lazyReadWriteLock that seem to break the documented behaviour that for the same key the same lock will be returned. Is there something obvious we're missing or misunderstood about the lazy Striped Locks? When using eager Locks, everything works as expected.

The following test reproduces the behaviour.

```
public class MyTest {

    private final Striped<ReadWriteLock> stripedLock = Striped.lazyWeakReadWriteLock(64);
    private final AtomicBoolean writeLocked = new AtomicBoolean(false);
    private final Set<String> someSet = new HashSet<>();
    private final Random random = new Random();

    private final String key = "anyKey";

    @Test
    public void test() throws Exception {
        final ExecutorService executorService = Executors.newCachedThreadPool();
        final AtomicBoolean testFailed = new AtomicBoolean(false);

        for (int i = 0; i < 1000000; i++) {
            someSet.add("" + i);
        }

        for (int i = 0; i < 10; i++) {

            executorService.submit(new Runnable() {
                @Override
                public void run() {
                    try {
                        while (!testFailed.get()) {
                            if (random.nextBoolean()) {
                                writeLockedMethod();
                            } else {
                                readLockedMethod();
                            }
                        }
                    } catch (AssertionError e) {
                        e.printStackTrace();
                        testFailed.set(true);
                    }
                }
            });
        }

        while (!testFailed.get()) {
            Thread.sleep(1000);
        }
        fail();
    }

    private void readLockedMethod() {
        final Lock readLock = stripedLock.get(key).readLock();
        readLock.lock();
        assertFalse(writeLocked.get());
        try {
            someSet.contains("" + random.nextInt(1000000)); //Just do something.
        } finally {
            readLock.unlock();
        }
    }

    private void writeLockedMethod() {
        final Lock writeLock = stripedLock.get(key).writeLock();
        writeLock.lock();
        //Since the atomic boolean is set inside the write lock, for the same key, this should never be true.
        assertFalse(Thread.currentThread().getName(),writeLocked.get());
        writeLocked.getAndSet(true);
        try {
            someSet.contains("" + random.nextInt(1000000)); //Just do something.
        } finally {
            writeLocked.getAndSet(false);
            writeLock.unlock();
        }
    }
}
```
 This is something I'm seeing as well. I had same problem with .lazyWeakReadWriteLock(int) in 20.0 version @cpovirk 

Would you consider to make the `WeakSafeReadWriteLock` public? I use a similar thing to `Striped#lazyWeakReadWriteLock`, just without the striping.

Shouldn't this be fixed in the JDK? Just removing the static modifier of the nested classes would do. We could argue that the nested locks need no reference to the enclosing class, but this issue shows it's actually needed.

I had an idea of simply extending all three involved locks and overriding the `readLock` and `writeLock` getters, making the original locks unused. Your fix is cleaner, but it's more than ten times longer. It might perform worse because CHA for `Condition` and overridden methods deeper in the call hierarchy tree. Just guessing.

 > `perObjectReadWriteLock`

That's it.

> fixing in JDK

Posted.

> in comparison with the overhead that people expect when using especially a read/write lock

In a lucky case, there's hardly anything besides a single CAS in `nonfairTryAcquire`, but agreed.

> I'm not sure we have that option for Condition

I wasn't that far at the time of posting... I'm afraid, we're not. This makes inheritance only half as usable (and the mixing would be weird), so let's forget it. 

> I'm not necessarily inclined to support the fix in the JDK

@lowasser  Agreed, I'm not sure either. But the cost is tiny, so I posted it for them to evaluate.

> if ReentrantReadWriteLock is any more special than the many other APIs

In a sense it is, as there are the three classes where each just exposes different aspects of a single `sync` (whose identity matters), so keeping them all alive for the same time sounds good. I can't recall any similar case. > > Posted.
> 
> If I recall correctly, I had to join the list before I could post. I'm not seeing your post, so that would explain it.

Thanks! I thought, I was a member already. Too many mailing lists. ;) Now, it worked. https://bugs.openjdk.java.net/browse/JDK-8189598  Looks like googlecode now returns 404 for the guava API docs. While the docs are also hosted on google.github.io this site is poorly indexed / has poor page rank in google search. So it's basically impossible to reliably google search for the docs. I'm navigating the docs manually now but that's a pain. 

Is it possible to get 301 redirects from googlecode to github.io until the search index picks it up? And/or another way to fix the index? 

thanks
 Thanks! FWIW, I didn't notice #2474 since I didn't look for closed issues. Might want to consider leaving it open for a couple of days. Otherwise you might get more dups. 
 > So it's basically impossible to reliably google search for the docs. I'm navigating the docs manually now but that's a pain.

You can always search Google with `<your query> site:google.github.io/guava/releases/19.0/api/docs/`.
  Hi,
http://docs.guava-libraries.googlecode.com/git/javadoc/com/google/common/cache/CacheBuilderSpec.html is returning a 404 error and http://docs.guava-libraries.googlecode.com is redirecting to this repo. Is this a temporary issue or have your javadocs moved? If the latter, what is the preferred reference URL? http://google.github.io/guava/releases/18.0/api/docs/ or something else?
 Thanks both, we'll use the github links from now on.
  Hi, I would like to ask for removal of com.google.common.collect.TreeTraverser from Guava's Beta, since it's a simple and convenient way to traverse hierarchies; one concrete usage (amongst many) we give to it is traversing a class hierarchy in annotation processors. Could it be done? Thanks for your attention.
 Hi, any thoughts on this request? Thanks for your kind response. I'm not having any kind of problems, it's only that today I was reassigned to a project where we make use of TreeTraverser a lot, and was a bit concerned about the plans the Guava devs have for that particular API.  To my surprise none of `copyOf` methods in immutable collections ([ex. ImmutableList#copyOf(Collection)](http://docs.guava-libraries.googlecode.com/git/javadoc/com/google/common/collect/ImmutableList.html#copyOf%28java.util.Collection%29)) document throwing NPE when copied collection / iterable / array is null itself. I believe it's not side-effect behavior but rather your [intended action](https://github.com/google/guava/wiki/UsingAndAvoidingNullExplained).

Currently you only have:

>  **Throws**:
>    `NullPointerException` - if any of `elements` is `null`

but IMO it should also state something more explicit regarding `elements` variable being `null`.
  I am very confused  and concern 
  Currently, there's two `Multimap.index` methods both returning an `ImmutableListMultimap`. It would be useful if there was a method added alongside with the following signature:

```
<K, V> ImmutableSetMultimap<K, V> indexSet(Set<V> values, Function<? super V, K> keyFunction);
```

for the specific situation in which `values` is a `Set`, then the returned multimap can be a `SetMultimap`, as any subset of the `values` set will also be a valid set. And `SetMultimap` offers semantic guarantees on value uniqueness that is not guaranteed by `Multimap` or `ListMultimap`.

Of course, this method will need a different name to not overload the existing `index` method to maintain source compatibility.
 In this example, we've got a method that takes a `SetMultimap` (that depends on the semantics provided by that class, namely, unique values per key). I want to use the output of `Multimaps.index` as the parameter to that method, but that always returns a `ListMultimap`, even if the input is a Set. So I'm forced to do an additional `ImmutableSetMultimap.copyOf` for no reason.

Coincidentally, the method requiring the `SetMultimap` is the same as mentioned in my last comment in #2487
  Hi,

Can I work on this?

Thanks,
Keerthi Korivi. Thanks @cpovirk 
Could you please point me to the change CL 116244562, so that i can get an idea?  I ask you permission to start the project to port Google Guava for .NET Framework. I can do?
 Why would you need a permission? Guava has a very [permissive license](https://raw.githubusercontent.com/google/guava/master/COPYING) :)
 Thanks Bro!
 ```
"Licensor" shall mean the copyright owner or entity authorized by
  the copyright owner that is granting the License.

  "Legal Entity" shall mean the union of the acting entity and all
  other entities that control, are controlled by, or are under common
  control with that entity. For the purposes of this definition,
  "control" means (i) the power, direct or indirect, to cause the
  direction or management of such entity, whether by contract or
  otherwise, or (ii) ownership of fifty percent (50%) or more of the
  outstanding shares, or (iii) beneficial ownership of such entity.

  "You" (or "Your") shall mean an individual or Legal Entity
  exercising permissions granted by this License.
```

I need a License so I can drive Lol  
 Yes. We Can! Lol
 Let´s Beginning the Avocado Project, a port of Google Guava for .NET
 Quenttel Mathis 2016/4/26
 T o be  honest I don't know how I got here I was looking for information  too getting Player Pro to work II was just reading something online and saw the word License I never thought would _ was ever going to get the Licesne_
 Thanks for reaching out
 Does the Guava for C# started? Please share the link if so..I am willing to contribute  Often, when you're writing a close method, you do this:

```
@Override
public void close() throws IOException {
    field1.close();
    field2.close();
}
```

But there's a leak here - if the first `field1.close()` throws an exception, field2 will not be closed. If the IOException is handled and the program continues running, then field2 will never be closed and will leak.

I propose adding a series of methods that will close several objects safely, in a similar way to try-with-resources, with the proposed outline:

```
public static void closeAll(Closeable... closeables) throws IOException {
    Exception ex = null;
    for (Closeable c : closeables) {
        try {
            closeables.close();
        }
        catch (Exception e) {
            if (ex == null)
                ex = e;
            else
                ex.addSuppressed(e);
        }
    }

    if (ex != null) {
        Throwables.propagateIfPossible(ex, IOException.class);
        throw Throwables.propagate(ex);
    }
}
```

With similar variants for `AutoCloseable`, `Iterator<? extends Closeable>`, etc... that could be used like so:

```
@Override
public void close() throws IOException {
    Closeables.closeAll(field1, field2);
}
```
 http://docs.guava-libraries.googlecode.com/git/javadoc/com/google/common/io/Closer.html
 Hmm, so the Closer could be used for Closeable:

```
public void close() throws IOException {
    Closer.create().register(f1).register(f2).close();
}
```

However, this only works for `Closeable`, there's no class that deals with `AutoCloseable` (throwing `Exception`). And it's a lot of boilerplate for taking a series of fields and closing them safely - could static members be added to Closer that just take the fields as an array or `Iterable`, allowing several objects in a collection to be closed in the same way?
 This request is specifically in the situation of member variables of a class being closeable, where the containing class itself implements `Closeable` (or `AutoCloseable`). If you're creating and destroying a `Closeable` within a single method, then try-with-resources works. But if the `Closeable` is a field on a class, then you can't using try-with-resources, you have to do it manually within the containing class's `close` implementation. You can use `Closer` within that method, but, as I've said above, it's quite verbose. A static method where you just pass in the variables to be closed would be better.

One situation where you'll have a collection is, for example, a class maintaining a pool of connections to external servers. When the pool is closed, you want to close all the open connections (presumably stored in a collection), and if an exception is thrown when closing, you don't want to leak any.
  Hi, all,
Can event bus dispatch events beyond Java Type based filter?
For example, I have the following scenario. QuoteEventListener only want to listen events filtering by ticker instead of just java type QuoteEvent.class. 

```
// stock quote event
public class QuoteEvent {
    private final String ticker;
    private final double price;
    public QuoteEvent(String ticker_, double price_) {
        ticker = ticker_;
        price = price_;
    }
    public String getTicker() {
        return ticker;
    }
    public double getPrice() {
        return price;
    }
}

QuoteEventListener listener1 = new QuoteEventListener("MSFT");
QuoteEventListener listener2 = new QuoteEventListener("GOOG");


EventBus eventBus = new EventBus("feeder");
eventBus.post(new QuoteEvent("MSFT", 12.34)); // only listener1 will be notified
eventBus.post(new QuoteEvent("GOOG", 12.34)); // only listener2 will be notified

```
 @lowasser Yes, I can filtering this in listener. But I think it would be better that listeners should never touch events that they have not subscribed. What kind of event should they touch have been decided by EventBus. Which events of this kind should they touch? I think it's better that EventBus handles too.
 @mingzhou I strongly agree... There should be an option to register some kind of ID or allow content-based filtering at the registration stage...
 @lowasser @ShiroYacha Yeah, may be something like `@Subscribe(filter=EventPredicate.class)` while `EventPredicate implements java.functional.Predicate`...
  In LocalCache.java
@Override
  public V put(K key, V value) {
    checkNotNull(key);
    checkNotNull(value);
    int hash = hash(key);
    return segmentFor(hash).put(key, hash, value, false);
  }

is there a specific reason for adding a null check for the value as well. why can't cache have null values.
  Planilha de Alterações
https://docs.google.com/spreadsheets/d/16i-99n-DpzYtVD0LsYbsyxWYMeVs-OUo7PCMbVXXSjs/edit?usp=sharing
  My use case for `Iterables.partition()` is to construct precisely sized batches, not batches with dangerous null values in some of them.

Could partition offer a parameter to disable null padding, or better yet, offer a different method that doesn't pad at all?
 @lowasser Thanks for clearing this up. I'll make a note to my team.
  `SimpleTimeLimiter` requires an `ExecutorService`, but it only uses the `submit()` method, which is trivial to convert to `execute()`:

``` java
Future<T> future = new FutureTask<>(callable);
executor.execute(future);
```

The motivation is that implementing `Executor` is much easier than `ExecutorService`, especially when the full interface is not needed. We can work around this by using an adapter, but this is kludgy because it relies on knowledge of exactly which methods of `ExecutorService` are actually used: https://github.com/airlift/airlift/blob/master/concurrent/src/main/java/io/airlift/concurrent/ExecutorServiceAdapter.java
     of course.
Just want to type less ...
  Is there a reason that `Collections2.transform` accepts a `Function<? super F, T>` as its second argument instead of a `Function<? super F, ? extends T>`? The latter is the type used by the underlying `TransformedCollection` type and would expand usability. It would also make in consistent with similar functions in other classes in `collect` like `Lists` and `Iterables`. In particular it would help resolve a certain ambiguity that comes up when overloading with this method in Java 8. Consider the following example:

``` java
public class Fns {
  public static <E, T> Collection<E> map(Function<? super T, E> fn, Collection<T> coll) {
    return Collections2.transform(coll, fn);
  }

  public static <E, T> List<E> map(Function<? super T, ? extends E> fn, List<T> coll) {
    return Lists.transform(coll, fn);
  }

  public static <E, T> List<E> map(Function<? super T, ? extends E> fn, T[] coll) {
    return map(fn, Arrays.asList(coll));
  }
}
```

This code works in Java 7, but in Java 8, the third overload generates an ambiguous reference error, because the compiler is not sure which of the first two overloads to use. This can be fixed by making the first version accept a `Function<? super T, ? extends E>`, but of course, this won't work with Collections2. If the type of the function argument to `Collections2.transform` could be changed, it would make our migration to Java 8 much easier.
 Hi, could you please let me know when we may expect this to be resolved? 
 In that case can we have another transform method?
  public class ExceptionTest {
    @Test
    public void testExceptionToString(){
        try{
           throw new RuntimeException("RuntimeException-test");
        }catch (Exception e){
            String ss = Throwables.getStackTraceAsString(e);
            System.out.println("exception:"+ss);
        }
    }

```
@Test
public void testExceptionCausalChain(){
    try{
        throw new RuntimeException("RuntimeException-test");
    }catch (Exception e){
        List<Throwable> chain = Throwables.getCausalChain(e);
        for(Throwable t :chain) {
            System.out.println("exception:" + String.valueOf(t));
        }
        e.printStackTrace();
    }
}
```
## }

I just want to focus on special package callstack!
 I just want to get the call chains under the specific package 
as

``` java
    String ss = Throwables.getStackTraceAsString(e,specialPackageName);
```
 Can you please elaborate it ? what exactly you are asking about ?
Sorry but could not get clear picture of your request .
  I noticed recently that `MutableGraph` was split away from `Graph`, so I was curious as to why Sun Microsystems didn't do the same with the interfaces in the Java Collections framework. I googled it up and found [this StackOverflow answer](http://programmers.stackexchange.com/a/289372), which I think gives a very convincing explanation as to why they opted to go for optional, `UnsupportedOperationException`-based mutation methods rather than mutable sub-interfaces.

Has the Guava team considered the advantages and disadvantages of both approaches for `com.google.common.graph`?
 Hi @kevinb9n and @jrtom, thank you both for your explanations. I can see that things aren't as clear-cut as I first imagined.

On a side note, if you ultimately decide that having `MutableGraph` as a sub-interface is the right thing to do, I wonder if it'd be worth adding a note to `Graph` that if one is using `Graph` directly, they shouldn't assume the impl is immutable (even if the interface has no mutation methods), due to `MutableGraph` being a sub-type. (It certainly wasn't obvious to me at first that `Graph`s could be anything but immutable.)

I also wonder if it'd be worth recommending the use of `MutableGraph`/`ImmutableGraph` over `Graph` to avoid this sort of confusion. I imagine this would be similar to how `List` and `Set` are encouraged over `Collection` (or `(List|Set)Multimap` over plain `Multimap` for that matter).
 Yep, the javadoc clarifies things enough for me, so thanks @jrtom! Well, actually, it's the [wiki](https://github.com/google/guava/wiki/GraphsExplained#mutable-and-immutable-graphs) that explains it, but the Graph javadoc links to it, so that's fine for me. :)  I would like to ask for removal of com.google.common.base.StandardSystemProperty from Guava's Beta, as it's a really convenient way to reference system properties, and keeps devs from using hardcoded values or mantaining our own sets of constants. Could it be possible? Thanks for your attention.
 Glad to hear that, thanks a lot for your response.
  I'm facing an interesting problem:
After upgrading guava from r18 to r19, I cannot compile my project anymore, at least not with oracle javac (JDK 8u60 on linux): 

[javac verbose logging enabled]

```
[javac] [loading ZipFileIndexFileObject[/myproduct/lib/common/log4j/apache-log4j-2.5-bin/log4j-core-2.5.jar(org/apache/logging/log4j/core/config/plugins/PluginVisitorStrategy.class)]]
[javac] error: cannot access CheckReturnValue
[javac]   class file for javax.annotation.CheckReturnValue not found
[javac] Note: Some input files use or override a deprecated API.
[javac] Note: Recompile with -Xlint:deprecation for details.
[javac] 1 error
```

Switching back to guava r18 will make the build successful again.

I don't know exactly yet why this happens but I realized that compared to r18, with r19 now more class files contain references to `javax.annotation.CheckReturnValue`
Interestingly, the last logging statement before the error is related to a log4j2 class although I can not see how the class and the compile error are related.
 I'm not using any sort of compiler plugins / processors.
It's plain javac (invoked from ant).

Interesting fact: Eclipse compiles the same project without any errors.
I'll check whether adding the jsr305 dependency will workaround the issue.
  As it is,otherwise I have to write a `return null` or invent the wheel of `Consumer<T>`.
 @cpovirk I came from scala background,but currently have to use java 7 with guava,so I think something like `foreach`,`lastIndexWhere` things would be nice.
But yes,Guava currently not have these things,so does the `Consumer` thanks anyway.
  Mutable Java collections can't be safely treated covariantly.  But there's a nice trick when you don't need to modify them:

``` java
void foo(List<Number> numbers);

void bar(List<Integer> ints) {
    foo(Collections.unmodifiableList(ints));
}
```

This works because `Collections.unmodifiableList()` takes in a `List<? extends T>` but returns a `List<T>`.  (It also requires Java 8's type inference; write `Collections.<Number>unmodifiableList(ints)` on Java &le; 7.)  Similarly for sets, maps, etc.

It would be nice to be able to do the same thing with `Multimap`s, but the `Multimaps.unmodifiable*` methods are not covariant.
 @lowasser I don't think so, changing a method from `foo(A<B> a)` to `foo(A<? extends B> a)` shouldn't break any `foo()` calls.  Is there some corner case I'm missing?

@cpovirk Ah that's unfortunate.  At least `unmodifiableMultimap(Multimap<K, ? extends V>)` would be safe, but it's kind of weird to be covariant only in the values.  That's what `Collections.unmodifiableSortedMap()` does, presumably for similar reasons.

That whole feature is weird btw.  Even `unmodifiableSetMultimap()` doesn't dynamically return `SortedSet` proxies, only `unmodifiableMultimap()` does.  It looks like `unmodifiable{List,Set,SortedSet}Multimap()` could still be made fully covariant in keys and values.
 @lowasser: I was talking about the `foo(Collections.unmodifiableList(ints));` line, which only works as written in Java 8.  Nothing to do with Guava.

@cpovirk: You're right of course, it's a sorted set of values we're talking about.
    This is something very minor, but it will let me sleep easy;

I'm writing some extensions to [RichTextFX](https://github.com/TomasMikula/RichTextFX) using [ANTLR](https://github.com/antlr/antlr4), which means indexes galore, and it would make my life easier if I could get the `ImmutableSortedMap` to commit to a `List` return type, by covariantly overloading `ImmutableSortedMap.values()` to return an `ImmutableList` instead of an `ImmutableCollection`. 

``` diff
   @Override
-  public ImmutableCollection<V> values() {
+  public ImmutableList<V> values(){
     return valueList;
   }
```

Any thoughts?

Specifically I'm building a `RangeMap<Integer, antlr.runtime.Token>` which represents text ranges as keys to the tokens as values. The tokens themselves know their text indices but its annoying to sort through them to find the token you want, much easier to keep a RangeMap of them.
 ah but this is no good,

`ImmutableRangeMap` is transformed into a `Map<Range, Value>` by `asMapOfRanges()`, which does a check to special-case an empty map, using an empty `ImmutableBiMap` instead.

Further, its aliased as an `ImmutableMap<>` rather than an ImmutableSortedMap.

Sorry for wasting your guys time!
 > I'm not sure we'd want to commit to the current implementation. Can you use values().asList() or ImmutableList.copyOf(values()), either of which would return what you want in O(1)?

I can, and thats what I'll do.

You'd need an exceptionally large text file for linear time on the number of tokens to be a problem.
  I was surprised to discover that the `put(K key, V value)` method of `TreeMultimap` will replace the existing value if the given key already exists. This defeats the purpose of a Multimap. (Yes the Java docs describe this behaviour, but that does not mean the behaviour is sensible or expected.)

I suppose there now exists code using TreeMultimap that expects this behaviour, so the put method likely should not be changed. I argue that a new method be introduced that allows adding new values for the same key. Perhaps `add(K key, V value)`.
 I cannot post reproduction instructions, mostly because when I tried to I discovered TreeMultimap.put behaves exactly as expected! Turned out the values I was adding had a custom implementation of Comparable for which compareTo returned 0 for the different objects I was adding. Oops. Sorry for wasting your time!
  @kluever hi, please let me know what is the status for this issue, I would like to contribute.
 @kluever Is there a way to track that transition? Just the [label](https://github.com/google/guava/labels/platform%3A%20java8)?
 Cool! Looking forward to it 😄 
 Is it implemented internally? I'd really like to use the conversion with Guava 21.
 ...or maybe in Guava 22? ;) @kevinb9n I think this would be good to note in the Ideas Graveyard, so that people are less likely to ask for this feature again in the future   Hi,

[Javadoc](http://docs.guava-libraries.googlecode.com/git/javadoc/com/google/common/cache/CacheBuilder.html) of CacheBuilder says it uses LRU as eviction policy, but my test says otherwise..

`private static void testCacheEvictionPolicy() {
        int maxSz = 3;
        LoadingCache<Integer, Integer> cache = CacheBuilder.newBuilder().maximumSize(maxSz).build(new CacheLoader<Integer, Integer>() {
            @Override
            public Integer load(Integer integer) throws Exception {
                return integer;
            }
        });
        callCache(cache, 3);
        printCache(cache);
        for (int i = 0; i < 1000; i++) {
            callCache(cache, 1);
        }
        callCache(cache, 4);
        printCache(cache);
    }

```
private static void callCache(LoadingCache<Integer, Integer> cache, int n) {
    for (int i = 1; i <= n; i++) {
        try {
            cache.get(i);
        } catch (ExecutionException e) {
            throw new RuntimeException(e);
        }
    }

}

private static void printCache(LoadingCache<Integer, Integer> cache) {
    System.out.println("cache begin");
    for (Map.Entry<Integer, Integer> entry : cache.asMap().entrySet()) {
        System.out.println(entry.getKey() + " : " + entry.getValue());
    }
    System.out.println("cache end");
}`
```

output:

> cache begin
> 3 : 3
> 2 : 2
> 1 : 1
> cache end
> cache begin
> 3 : 3
> 2 : 2
> 4 : 4
> cache end
  The URI constructor for file is much more robust when it comes to handling encodings.
It saves a lot of headache of worrying about implementation specific edge cases.
(Fixes #2152)
 CLA done
 Hmm, looks like there is something strange about the way manifests are parsed versus how ClassLoader paths are parsed.

I've applied the fix only to the getClassPathEntries method, even though it seems the fix would apply both there and the getClassPathFromManifest method.

@eamonnmcmanus
 I think there is an issue in the getClassPathEntry method, the "path" argument should be URLEncoded before it is passed into the URL constructor, otherwise you get some really sketchy behavior like the URL being "file:(...)/guava/guava-tests/base/the^file.jar", and calling .toURI() on that throws an exception because it isn't a valid URL.

In any case, that seems like a separate issue, so I would rather do another PR for it.  I have to read up on what constitutes a valid manifest file entry to make sure that all of the encoding problems are solved there too.

This is one of those rare cases where the implementation was wrong in two places so that the unit test that should've caught this failed.  If the original method had been using the File(URI) constructor, it would've complained about the invalid URI being generated in the getClassPathEntry method.  If the getClassPathEntry method properly encoded the URI for special characters, the File(String) constructor would fail because it doesn't decode anything.  They both cancelled each other out to cause this weird little bug.
 Making a regression test isn't trivial because ClassPathTest doesn't currently have a simple way to obtain sample jars, as far as I can see. We would want a test that would put the jar in something like "strange %directory"/test.jar but we'd need an input jar to put there. So it might not be feasible right now to make a test. (There's an additional layer of complexity because the test also has to work when run from Google's internal build system.)
 In the mean time, is it possible to merge just this fix for the non-classpath loader? It shouldn't break any backwards compatibility, and we can fix file names with special characters here at least.
  Leaking interrupt status from one task to another is a really unfortunate behavior. And while I don't disagree with your statement "we shouldn't be interrupting threads we don't own", I do think that something being the delegate of a SerializingExecutor is transferring ownership in a sense.
 @cpovirk Hi, please let me know what is the status of this issue, cause I would like to cotribute.
 @cpovirk Hi, did I understand properly, do I need to re-implement the `Splitter.onPattern` function?
BTW yesterday I did a code-change which caused to return ['o','o'] for input data as {input: "foo"; regex: "(?=o)|(?<=o)"}, may I ask for a review? (before it was returning just ['0']).
Another question may be I should create another "Issue" in order to track everything in right place?
  update
  I am writing a unit test and want to mock time. I am using the `Sleeper` `interface` and the `Ticker` abstract class. Something like this:

```
private static class FakeTime extends Ticker implements Sleeper {

    private static final long READ_DURATION_DELTA_NANOS = TimeUnit.MILLISECONDS.toNanos(50);

    private long total = 0;
    private long now;

    public FakeTime() {
        this.now = System.nanoTime();
    }

    @Override
    public void sleep(long millis) throws InterruptedException {
        this.total += millis;
        this.now += TimeUnit.MILLISECONDS.toNanos(millis);
    }

    public long getTotal() {
        return total;
    }

    @Override
    public long read() {
        long result = now;
        now += READ_DURATION_DELTA_NANOS;
        return now;
    }

}
```

Problems:
- If I need to extend another class, I would need some weird construct since multiple inheritance isn't possible in Java.
- `Ticker` feels more like an `interface` than an `abstract class`.

Proposal: Make `Ticker` an `interface`.

Thoughts?
 Guava's testlib contains `FakeTicker` which is a handy utility similar to yours. Due to the static method a change to an interface wouldn't be possible until the Java 8 release. It might still be frowned upon as a breaking change.
  Fix for #2365 
 I signed it!
  Removal listeners are nice and all, but why doesn't `Cache.invalidate()` return true when an entry is successfully removed? The information is available to it and from a thread-safety perspective we cannot really know whether a particular call to `Cache.invalidate()` really removed an entry by using removal listeners.

Consider:
T1: Cache.invalidate("key") //"key" wasn't originally in the map
T2: Cache.put("key", "value")
T2: Cache.invalidate("key")
T1 seems that RemovalListener.onRemoval("key") was invoked, but it really corresponds to action by T2.
 @kluever Thanks for the clarification. Closing seeing as this is by design and there is a reasonable workaround.
  Occasionally I deal with values that I don't want logged (e.g. passphrases, user personal details). I tend to use [Sensitive<T>](https://gist.github.com/tomfitzhenry/ceacc3dad4f693ad22da) for this. Key features are that toString doesn't output the underlying T, and that the getter is called something scaryish like `retrieveSensitiveValue` rather than `get`.

It'd be neat if this was Guava-ified.

Perhaps this is a problem better tackled by an Information Flow library, however.
 I hadn't seen that.

http://types.cs.washington.edu/checker-framework/current/checker-framework-manual.html#tainting-checker
looks
like it might be what I'm after. Thanks!

On Tue, 22 Mar 2016, 23:02 Louis Wasserman, notifications@github.com
wrote:

> I'd tend to expect this sort of problem to be best solved with Java 8 type
> annotations, and passing a variable around as a @Sensitive String rather
> than a Sensitive<String>?
> 
> —
> You are receiving this because you authored the thread.
> Reply to this email directly or view it on GitHub
> https://github.com/google/guava/issues/2435#issuecomment-200070898
  The Escaper returned by com.google.common.net.UrlEscapers.urlPathSegmentEscaper() should escape '@'.

Per http://tools.ietf.org/html/rfc3986#section-2.2 -

"""
   If data for a URI component would conflict with a reserved
   character's purpose as a delimiter, then the conflicting data must be
   percent-encoded before the URI is formed.

```
  reserved    = gen-delims / sub-delims

  gen-delims  = ":" / "/" / "?" / "#" / "[" / "]" / "@"

  sub-delims  = "!" / "$" / "&" / "'" / "(" / ")"
              / "*" / "+" / "," / ";" / "="
```

"""

'@' is a reserved delimiter (used for separating username[:password] from host name/address).

If urlPathSegmentEscaper() were to percent-encode '@', I think it would be an acceptable Escaper for escaping the host address part of a URL.

While it is less likely to cause a parsing problem in a path segment than in the host part it is strictly speaking incorrect for it not to be percent-encoded.
- Stephen
  fix bug:
List<String> resultList = Lists.transform(list, new Function<Bean, String>() {
                        @Override
                        public String apply(Bean input) {
                            return input.getId();
                        }
                    });

after using this , the resultList can't be serializable
 I signed it!
 Yes, my resultList can do serializable depends on it's implementor, so i marked the top interface Iterator serializable. 
  Capitalization change in documentation line 62, report changed to Report 

Very very trivial change to documentation of the read-me. Just cutting my teeth on Git..
 I signed it!
  As they are [common headers](https://en.wikipedia.org/wiki/List_of_HTTP_header_fields#Common_non-standard_request_fields) (at least the `X-Forwarded-Host`) it would be nice if they are defined in the class `HttpHeaders`. The `X-Forwared-Port` is used for example in [AWS](http://docs.aws.amazon.com/ElasticLoadBalancing/latest/DeveloperGuide/x-forwarded-headers.html).
 Hi, thanks for the quick reply. I'm sorry that I could not provide any reference to a RFC or something like this. I have seen both parameters only in a few nginx and httpd configs. As I want to evaluate them in my code I thought I could use the class `HttpHeaders` but then I missed them.

I updated the AWS link. I also like the definition they use there. 
  I just read http://www.cs.umd.edu/~pugh/java/memoryModel/DoubleCheckedLocking.html and notice that `MemoizingSupplier` uses double checked locking. Is the article statement not an issue because the locking is done on a `volatile` field? Or because it's on a boolean?
  **public static int lcm(int a, int b)**

```
/*
Returns least common multiple of two numbers. Uses gcd method of this library.
*/
```
 I signed it!
 The indentation depth is wrong. Guava uses 2 spaces instead of 4. Also note that the function body should be indented as well. Javadoc is missing.    //Check given number is prime number or not. If number is prime return true, else return false.
 Thanks :)
  https://github.com/google/guava/wiki/CollectionUtilitiesExplained#listsin-addition-to-static-constructor-methods-and-functional-programming-methods-lists-provides-a-number-of-valuable-utility-methods-on-list-objects seems too long for a title :)
  Created a function that returns byte array. Take paremeters of byte values, concat all of them and returns a single array.
Example:
byte array = new byte[2];
array = concatBytesToArray(0x06,0x01);
 I signed it!
 Hello,

Why not simply use `byte[] array = new byte[]{0x64, 0x61};` ?
 Hello,
If you wanna add many byte values and you don't know how many. You can't this structure.
Thanks your comment.
 But you have to either know how many you have (to pass them into the function) or pass in an array to begin with. Calling this method creates the array anyway (that's how varargs works), and your method just copies it. I see no use for such a method.
 If you want to concat many byte values. Its useful. 
Thanks your comment.
 I am new here.@kluever  I used to merge this method for fetching mbus datas. But you are right.  
This can also be done in such this way.
Thanks your comment.
    #### public static int digitsOfNFactorial(int n)

//This method calculates digits number of number n's factorial without calculating 'n!'
//For example:for n=5--> 5!=120 --> returns 3
#### public static int getNumbersOfDigit(int n)

//This method calculates digits number of n
//For example:for n=4129--> returns 4
 I signed it!
  This is version 19.0

This:

``` java
    public static void main(final String... args)
    {
        final CharMatcher m1 = CharMatcher.is('a');
        final CharMatcher m2 = CharMatcher.isNot('a').negate();

        System.out.println(m1.equals(m2));
        System.out.println(m1);
        System.out.println(m2);
    }
```

prints:

```
false
CharMatcher.is('\u0061')
CharMatcher.is('\u0061')
```

Aiie...
 @kluever pretty much so, yes; the logic is there anyway so that those two matchers are _functionally_ equivalent.

Since the logic is there to do that, what prevents equality to be computed accurately?
 OK, well, I'll just close this issue. I'd have expected however that such a collapse would have been made...

Nevermind, I'll use something else, then.
 We already normalize `CharMatcher`s in the `precomputed()` method. So we _could_ say that `equals` works as expected on the result of `precomputed()`, or (since `precomputed()` can be expensive) we could provide an `expensiveEquals(CharMatcher)` method. I agree that the use case has yet to be established, though.
 @kluever this is for [grappa](https://github.com/fge/grappa). In this package, there is a cache mechanism for `Matcher`s (note: those are not `java.util.regex.Matcher`s) taking arguments.

My goal was to replace the custom Java `char` matchers in here (which rely right now on `Characters` instances) with `CharMatcher`s. Should the latter have implemented `.equals()` (and consequently `.hashCode()`), the swap would have been easy.

So, I guess I'll have to improve `Characters` here, because it's not ideal... I'd have somewhat expected `CharMatcher` to fit the bill however.

@eamonnmcmanus well, I don't care about "initial" precomputation. Actually I haven't tested with `.precomputed()` instances... But even that additional `.expensiveEquals()` wouldn't fit the bill.

In detail, how the key of the rules to be cached is by using a stupid, simple wrapper class which just calls back to `Arrays.deep{equals,hashCode}()`, which means it is expected that the individual parameters implement `.equals()` and `.hashCode()` as expected by the user.

But again, this is a specific use case. I was just surprised that `CharMatcher` would not do this from the get go, that's all :)
  When I am working with ranges that sometimes are connected and sometimes not, It is a litle cumbersome to have to check if the ranges are connected before any calling to the intersection method.

I added a new intersection method with a new optional flag parameter "_allowEmptyRanges_". When this flag is true, the method will return an empty set when ranges are not connected (instead of throwing an IllegalArgumentException).

The change is backward-compatible but I have included specitifc unit tests for this little change.

I would be glad to hear any comments from you.
 I signed it!
  Such as the following implementation:

``` Java
  public static CacheBuilder<K, V> newBuilder() {
    return new CacheBuilder<K, V>();
  }
```

The current implementation:

``` Java
  public static CacheBuilder<Object, Object> newBuilder() {
    return new CacheBuilder<Object, Object>();
  }
```
 To facilitate reuse (I think):

``` java
CacheBuilder<Object, Object> builder = CacheBuilder
        .newBuilder()
        .expireAfterAccess(10, TimeUnit.SECONDS);

Cache<Integer, String> cache1 = builder.build();
Cache<Double, Serializable> cache2 = builder.build();
```
 Yes, for reuse.  Thanks for @cardamon 💯 
 @lowasser Thanks, I remember to search 'CacheBuilder newBuilder' in 'Pull requests', but not in 'Issues'. So not found, I'm so sorry.
  See a unit test demonstrating the issue here: https://github.com/gpanther/fastutil-guava-tests/blob/master/src/test/java/net/greypanther/guava/tests/tests/CustomToStringTest.java

It shows a HashMap subclass which overrides toString and as a result fails tests, even if CollectionFeature.NON_STANDARD_TOSTRING passed to MapTestSuiteBuilder.

I believe that methods like https://github.com/google/guava/blob/2cd4d629a2b6f1a462643b248e0972f44c5133b7/guava-testlib/src/com/google/common/collect/testing/testers/MapToStringTester.java#L45 should be marked with `@CollectionFeature.Require(absent = NON_STANDARD_TOSTRING)`.
   In the last line under the heading : **Tuples for n>=2**, there is a link to AutoValue, which points to : 
https://docs.google.com/document/d/1THRUCIzIPRqFSHb67pHV8KMbo55HphSXqlQcIx9oUiI/edit#heading=h.7ojt6jg2vdwc

which leads the user to a google doc asking to update whatever url lead them there to https://github.com/google/auto/tree/master/value
  Current implementations of `putUnencodedChars` and `putBytes` are vulnerable to collisions from concatenating variable-length sequences. Prepending lengths of the inputs (using `putInt` as an example) would fix this.
 As far as I remember, appending size doesn’t prevent ambiguity — only prepending.

I wonder if a separate implementation is needed. Does _hash_ package guarantee backward-compatibility across different VM invocations? If not, then no contract would be broken by modifying existing imlementations.
  I'd like to request the addition of a [Tree](http://mathworld.wolfram.com/Tree.html) data structure, which would be similar to a `DirectedGraph` but which has a single root, disallows cycles and self-looping edges, and is fully connected.

My use case for such a feature would be to model a sequence of actions, which may branch depending on some criteria.

I'm aware that such a data structure already exists in JUNG 2 (and this is probably the solution I'll use in the meantime), but I believe it would be something that users of the `com.google.common.graph` package, in a future stable version of Guava, would appreciate.
 That sounds great @jrtom! Many thanks for your response. I realise trees are probably not going to appear in common.graph any time soon, but nonetheless it's exciting to hear what you have in mind for common.graph and JUNG.

@lowasser, I hope to get back to you soon with an answer, I'm just waiting for a confirmation that I can talk about my use case in detail here.
 Also, thanks for fixing the typo in the issue title. :)
 Hi @lowasser. I'm struggling to explain my use case very well and succintly, so I want to apologise in advance if you struggle with the wall-of-text below and/or if I've not described things well enough for you.

I'm doing my undergraduate dissertation, where I'm writing a tool which does logical & syntax-related checks on a subset of [SBVR](http://aaaipress.org/Papers/Symposia/Spring/2008/SS-08-01/SS08-01-010.pdf), a software modelling standard like UML which uses "Structured English" statements instead of diagrams.

For my dissertation, these statements describe the ordering in which "entities" in a hypothetical concurrent software system receive "messages" from each other. The most basic statement has the format 

> entity1 **receives** msg1 **precedes** entity2 **receives** msg2

which describes how, in this system, `entity1` must receive `msg1` before `entity2` receives `msg2`. For my work, it doesn't matter where `msg1` and `msg2` come from.

I'm thinking of using a Tree to model the ordering between these messages rather than, say, a List. This is because in a more complex system, an entity (e.g. `entity1`) may expect to receive one message out of a choice of 2 or more (e.g. `msg1 | msg2`), and the message(s) it expects afterwards may change depending on whether it received `msg1` or `msg2`. In SBVR, this might be modelled as

> entity1 **receives** msg1 **or** entity1 **receives** msg2

To give a code example, if I had an SBVR statement like this:

> John **receives** msg1 **precedes** George **receives** msg2 **or** George **receives** msg3

then I might model it as a Tree like so.

<pre>Tree<EntityWithMessage, Object> messageOrderingTree = new Tree<>();
EntityWithMessage johnMsg1 = new EntityWithMessage("John", "msg1");
EntityWithMessage georgeMsg2 = new EntityWithMessage("George", "msg2");
EntityWithMessage georgeMsg3 = new EntityWithMessage("George", "msg3");
messageOrderingTree.addEdge(new Object(), johnMsg1, georgeMsg2);
messageOrderingTree.addEdge(new Object(), johnMsg1, georgeMsg3);
System.out.println(messageOrderingTree); 
// prints the following:
//           John -> msg1
//              (root)
//               /  \
//              /    \
// George -> msg2    George -> msg3</pre>

I hope this gives you a better understanding of what I'm trying to do.
 @jrtom and @lowasser, thank you both very much for your constructive feedback.

@jrtom, I understand your argument for the toString() representation for trees, and I completely agree! I only meant to show a visual example of what my tree would've looked like in case I hadn't made it clear from my makeshift API. :)

Thanks for your simple suggestion @lowasser, I'll see how it goes with using it in my dissertation.

I'm not sure what's the proper thing to do regarding leaving this issue open or closed. I presume it'd be useful to keep open as a reminder of sorts for the Tree impl, but I'd be more than happy to let @jrtom decide the usefulness of it. :)
 I'm currently using JUNG 2.1, but I recently found that [Durian](https://github.com/diffplug/durian) has tree utilities like [TreeDef](https://diffplug.github.io/durian/javadoc/3.4.0/com/diffplug/common/base/TreeDef.html) and [TreeNode](https://diffplug.github.io/durian/javadoc/3.4.0/com/diffplug/common/base/TreeNode.html) which seem to fit my use case better.

Just thought I'd bring it up, since Durian's API may prove to be a source of inspiration for a tree implementation in common.graph (or indeed the next version of JUNG).
 @jbduncan I do not think trees are directed. They are undirected graph having n vertexes and n-1 edges.
 For the tree, will we have some sort of `TreeBuilder` which take undirected and directed cases into different accounts?
 @jbduncan 

> which describes how, in this system, entity1 must receive msg1 before entity2 receives msg2. For my work, it doesn't matter where msg1 and msg2 come from.

Let's say that entityX receive msgX is called eventX. Here I will list some possibilities:
1. one event unlocks multiple events;
2. one event needs multiple events as precedent.

If both are true, then you need a DAG. If only one of them is true, then you need a tree indeed. If both are false, then it is simply a chain in which you do not really need graphs.
 @liach For my project, only 1. is true. Each and every "event" is preceded by one or zero other "events", but each "event" leads onto potentially many other branching "events". Therefore I believe a tree models my problem best, rather than a chain (e.g. list or iterable) or a DAG. :)

**Edit:** Also, only _one_ "event" can be preceded by zero events. This would make it the 'root' of my 'tree'.
 Something like below would be what most people would think of as a "ordered tree" I think.

Viewed as a whole, a tree data structure is an ordered tree, generally with values attached to each node. Concretely, it is (if required to be non-empty):

A rooted tree with the "away from root" direction (a more narrow term is an "arborescence"), meaning:
A directed graph,
whose underlying undirected graph is a tree (any two vertices are connected by exactly one simple path),
with a distinguished root (one vertex is designated as the root),
which determines the direction on the edges (arrows point away from the root; given an edge, the node that the edge points from is called the parent and the node that the edge points to is called the child),
together with:

an ordering on the child nodes of a given node, and
a value (of some data type) at each node.  At work we use a lot the Verify utility class to make postconditions checks, it's a simple and effective way to do such checks. Nevertheless, it's marked with the Beta annotation. I read about Beta APIs https://github.com/google/guava/wiki/PhilosophyExplained#beta-apis and would like to ask for Beta removal from Verify, taking into account that the usage of Verify in our codebase has grown. Would it be possible? Thanks for your attention.
 Thanks for your kind response, have a nice day!
 Can't this be closed now as well?  One common issue when dealing with enums and enummaps (and switches with enums for that matter) is that with introduction of new enum values adding new entries into enummaps (or switches) for them can be easily forgotten.
Static factory methods (or a builder) could be used to fail fast when such a situation arises.
For example:
EnumMaps.forAllKeys(K1, V1, K2, V2)
Internally, when the construction of immutable enummap is done, validation is executed so that all possible enum keys are present and not null. Additionally, by enforcing that all enums are not null any of them could be used to get enum class (getDeclaringClass) which would bring an additional benefit to callers who wouldn't need to specify the enum type explicitly.

What do you think?
 Well, I'm willing to implement it and contribute but would first like to discuss API specifics.
Where should it be located and how should those static factory methods be named?
Should non null be enforced for both keys and values or only for keys, etc. :)
 Ok, when you get some free time on your hands, please take a look at the pull request, I've also opened a topic on guava google group. GWT tests seem to fail and last time I used GWT was about 3 years ago so any help would be appreciated :).
 I think a builder is not enough and static factory methods should also be provided. I think putting both static factory methods and a builder in ImmutableMap and encoding enum in their name is a bad design choice. How many more use cases before ImmutableMap becomes too overloaded with ImmutableEnumMap stuff? I would also like to explicitly use ImmutableEnumMap type in my code or at least EnumMap since EnumMap is usually used different (at least from what I've seen) than a regular map.
 > ImmutableMap is supposed to correspond to the Map interface; ImmutableSortedMap is supposed to correspond to the SortedMap interface. EnumMap is just another implementation of Map, just as HashMap is; it just happens to be more efficient for its specific use case.

Isn't ImmutableMap just another implementation of Map? Why is ImmutableMap public and why isn't everything in Maps? Why does Java API include a public EnumMap class and no explicit class similar to ImmutableMap?

Key difference between a regular Map and an EnumMap is that key is always an enum meaning there is a finite number of possible keys, always, for every possible EnumMap instance. Usually EnumMap is an alternative to a switch statement. But there is more than [that](https://docs.oracle.com/javase/7/docs/api/java/util/EnumMap.html):

> Enum maps are maintained in the natural order of their keys.
> Null keys are not permitted.

Similar to that, ImmutableMap never allows modifying operations, is naturally thread safe if you don't modify keys/values etc.

Both the ImmutableMap and ImmutableEnumMap diverge from the Map contract more than enough that you would want an explicit type for both of them. So to sum it up, a reader will want to know that this is an EnumMap same as he wants to know it is an ImmutableMap. You don't want to check what is behind that Map definition same as you don't want to check what is the key type.
 > Of course ImmutableMap diverges from Map, and EnumMap diverges from Map in some ways, but the only way I see that ImmutableEnumMap would diverge from ImmutableMap is the iteration order?

I have already answered that:

> Key difference between a regular Map and an EnumMap is that key is always an enum meaning there is a finite number of possible keys, always, for every possible EnumMap instance.

Second thing:

> but the only way I see that ImmutableEnumMap would diverge from ImmutableMap is the iteration order?

Same logic can be applied to ImmutableMap and Map, also like I've said in my previous response.

One more thing you didn't address:

> I think a builder is not enough and static factory methods should also be provided. I think putting both static factory methods and a builder in ImmutableMap and encoding enum in their name is a bad design choice. How many more use cases before ImmutableMap becomes too overloaded with ImmutableEnumMap stuff?
  @cpovirk When do you expect the Java 8 version of the testlib to be available? Any possibility of providing snapshots so that I can experiment with it?
  pull request for #2392

Duplicates the acquire methods for backwards compatibility.
The package private methods with signature changes have not been duplicated.
 CLA is signed
 The company name is UP-nxt
  I believe a more generic **empty** range could be introduced, because `(v..v]` and `[v..v)` have their side-effects.

Given `a = (5..5]`, `b = [10..15]` currently `a.span(b)` is equal to `(5..15]`. This is because `[10..15]` doesn't currently _encloses_ `(5..5]` but since it is basically an empty range I believe general empty ranges should be enclosed by every other range.

Introducing a generic empty range would have the benefit of having the followings:
- `range.encloses(empty) == true`, for every `range`
- `empty.encloses(range) == false`, for every `range` except `range === empty`
- `empty.span(range) == range` and `range.span(empty) == range` for every `range`

What do you think?
 I thought this would be the case, but I had to ask, because it would make it a bit better, it would make `Range<C>` I believe a ring (in mathematical sense), where `+` would be the _span_ operation, `⋅` would be the _intersect_ operation. The additive identity would be the `Range.empty()` and the multiplicative identity would be `Range.all()`.

Yeah, `Optional` could work, but just for the sake of being "empty" it isn't worth making the API uglier at the user side. `RangeSet` is a bit heavy because it would allow disconnected ranges.

Thanks anyway your input, much appreciated!
  Hello,
There is already a amazing feature in Guava to split a string. However, I was wondering if I may ask for  a feature whereby, a fixed length string can be split by successive fixed length sub strings?

**Example**:"JohnDoe123 WhiteHouse St.Earth Galaxy11111"

I would like to split above given fixed length string with lengths **_4, 3, 18,12,5_** such that I can get the _**first and last names, Street Address, City, ZipCode easily**_.

Thanks in advance!
 Agreed. Going Data Structure way is surely one option. The reason I brought this up, In Banking/Financial/Insurance and perhaps other industries as well, a record is sent across the wire as a fixed length strings; Since Splitter already supporting different ways to split a string, I was just wondering that perhaps Splitting a Record in Fixed length string style to pick each column will be helpful.

Appreciate any thoughts on this.
  This closes #2397 
 I signed it!
  Currently, `Throwables.propagate` wraps all checked exceptions in a `RuntimeException`. Java 8 added `UncheckedIOException` specifically to wrap an `IOException` in an unchecked exception. `Throwables.propagate` should check for `IOException` and use this class rather than the raw `RuntimeException`.

This is a compatible change, as `UncheckedIOException` extends `RuntimeException`.
 Well, the idea is fine, but it would ruin the compatibility with previous Java versions.
 Well, this is for Java 8 only, obviously...
 Guava is supposed to work not only in Java8. It's even shown in tests that verify validity against different java versions
  No use in constructing a fresh copy of the Mac just to get the bit-length.
   Characters from the unicode in cpXXX not displayed 
D:\Projects\Scripte\gam-3.63-windows>gam info user ********
User: *********
Traceback (most recent call last):
  File "<string>", line 9136, in <module>
  File "<string>", line 6352, in doGetUserInfo
  File "C:\Users\jlee\Documents\GitHub\gam363\src\build\gam\out00-PYZ.pyz\encodings.cp866", line 12, in encode
UnicodeEncodeError: 'charmap' codec can't encode character u'\u0456' in position 16: character maps to <undefined>
 OS: Windows 8.1 - Rus
Console in cp866 - Cyrillic script
User information have same fields in UTF-8 with char Cyrillic (not English)
Error: It is not translation ftom UTF-8 (not English) to cpXXX
Note: UTF-8 - 2-byte vs cpXXX - 1-byte
 :) Sorry. Wrong project
  ```
@Test
public void thisWillPass() {
    Map<String, AtomicInteger> map = ImmutableMap.of("foo", new AtomicInteger(0));

    increment(map);

    verify(map);
}

@Test
public void thisWillFail() {
    Map<String, Integer> map = ImmutableMap.of("foo", 0);
    Map<String, AtomicInteger> aMap = Maps.transformValues(map, number -> {
        return new AtomicInteger(number);
    });

    increment(aMap);

    verify(aMap);
}

private void increment(final Map<String, AtomicInteger> map) {
    map.get("foo").incrementAndGet();
}

private void verify(final Map<String, AtomicInteger> map) {
    Assertions.assertThat(map.get("foo").get()).isEqualTo(1);
}
```

I have two test cases where one fails and the other passes. In both cases I attempt to increment an instance of AtomicInteger in a map by one. A map constructed manually works fine with the increment() method, while a map returned from Maps.transformValues() fails.

Is this by design? It's not clear to me from reading the API doc.
 I see. When I first read that paragraph, I interpreted "applied lazily" as lazy initialization, i.e. the function will be invoked eventually once. Your comment that it "does no storage of its own" really clarifies that. Thanks!
  I would like to consume permits and return either the time that the task may continue, or the time that the task must wait before continuing, as opposed to having the thread sleep.  reserveEarliestAvailable() and reserveAndGetWaitLength() are the internal methods, respectively, that provides such functionality.  Relying on the RateLimiter to sleep in order to enforce the rate is intuitive, but makes it harder to compose RateLimiters into other tools.  Additionally exposing methods to "try" acquiring, failing if the required delay would be too great, would preserve consistency with the current API.

Use-cases:
1.  Limiting the rate of asynchronous tasks.  RateLimiter enforces rates by sleeping on the acquiring threads.  I would like to enforce the rate of tasks by instead scheduling them to a ScheduledExecutorService with the delay returned by reserveAndGetWaitLength().  This creates a rate-limited ExecutorService.
2.  RateLimiter with capacity (see #1707).  An alternative to supporting createWithCapacity() is to expose reserveAndGetWaitLength().  If I want a RateLimiter with a burst capacity of B (in time), I can achieve this by sleeping for max(0, reserveAndGetWaitLength(numPermits) - B).

The alternatives are to fork or implement my own RateLimiter from scratch, exposing such methods.
 @kluever hi, please let me know what is the status of this issue.
 I really wish this issue was addressed. I really am constrained by the same need as the OP.  All the major logic is now moved to a single private method.
Now there is no code duplication, and this should be help in adding new methods to this class by writing very little code without much risk of introducing bugs
 This is a sample implementation for https://github.com/google/guava/issues/2384. The design needs to be discussed before proceeding.
  Currently the Uninterruptibles class has many methods which do basically the same thing:
1. No timeout: 
   - Wait on something 
   - catch InterruptedException 
   - repeat
   - set interrupted state if required 
   - return result if any
2. Timeout: 
   - Wait on something with timeout 
   - catch InterruptedException 
   - update timeout
   - repeat 
   - set interrupted state if required 
   - return result if any

This same logic is repeated multiple times in every method. And presumably, given the requests for more such methods to be added to the class, the duplication will increase. I suggest cleaning up the code with a generic implementation. This genericization will be private initially with no change in public API. Later on we might choose to publicize this generic implementation so that clients can take advantage of this class even in cases where they have blocking implementations which cannot be supported directly by this class
 I have created a pull request with a sample design and implementation. Please review.
 1. By allocation you mean creating a new object once in every method? 
2. Is it so much of a performance hit to worry about, given that it happens only once per call? 
3. What will it take to reconsider the decision no to go with the above design?
   One of the reasons I insist is that by going down this path, we will be in a position some time in the near future to expose a generic method for clients to use with their own and other third party blocking implementations - making this class useful in almost all cases. 

If you feel strongly about avoiding object allocation at the cost of code duplication, I would like to try out an alternative approach of using reflection - Pass the required method and arguments to a single method. 
4. What is your take on such an approach?
 Understood. Seems that the solution is not as simple as it seemed when i saw the code initially.

Thanks for your time :)
You can close this issue.
  https://github.com/google/guava/issues/1409
 I signed it!
 Sure. will do...
 Hi,
Sorry about the delay. I have added 11 tests for the following cases:
- Not holding monitor throws IllegalMonitorStateException. 
- wait, waitSuccessfullyWithTimeout, waitUnseccessfullyWithTimeout for the following cases each:
1. No interrupt
2. Single Interrupt
3. Multi Interrupt
 Keeping in mind the reasons you have given and some open questions, I am not going forward with this change.
 Closing this pull request. Please reopen if you need any further discussion.

Open question:
-  What do we do in case of timedWait methods-  return on interrupt? or keep retrying till timeout? Or take a supplier to check and retry?
- Returning on interrupt will mean that the client might need to implement code to retry with reduced time which will essentially render the API pointless
- Not returning on interrupt will mean that in some cases, the method will wait more than required
- Taking a supplier as parameter is not preferred as discussed above.

Looks like Object.wait() is not a good candidate for uninterruptibility.
  `replaceAll` is another sneaky one. Surprisingly `ConcurrentMap` does not override `Map`'s default with an atomic version which uses `entry.setValue(v)`. It has a JavaDoc warning, but is obviously easy to overlook.
  It would be useful to add missing functionality to BaseEncoding for base85 or ascii85 as its called.
There doesn't seem to many libraries that offer it (actually none) and it would be another leg up over apache.

https://en.wikipedia.org/wiki/Ascii85
 Fair enough.
I'll close.

I found it personally useful and thought it might have a good fit here.
  I'm getting many
java.lang.NoSuchMethodError: com.google.common.base.Preconditions.checkState(ZLjava/lang/String;I)V
exceptions with 20.0-SNAPSHOT

To reproduce:
1. Checkout https://github.com/google/closure-compiler/commit/583b50ce47215846ef8e81025ac27e8fc1cac448
2. Run "mvn test"
3. Will see errors like:
java.lang.NoSuchMethodError: com.google.common.base.Preconditions.checkState(ZLjava/lang/String;I)V

I suspect https://github.com/google/guava/commit/1ef638f369964c1d1f56bd0ae588535c6abd99a4
might have something to do with this?
 @cpovirk @kevinb9n Bumping the one in pom-main.xml to 20.0-SNAPSHOT works, thanks!
  Running latest SNAPSHOT version 20160130.004722:

```
 compile 'com.google.guava:guava-gwt:20.0-SNAPSHOT'
```

I get the following error when doing `gradle build`: 

```
:compileJava/Users/mg/.gradle/caches/modules-2/files-2.1/com.google.guava/guava-gwt/20.0-SNAPSHOT/a12b43e9186d04817e2e73fd3883fe5305e69dc3/guava-gwt-20.0-SNAPSHOT.jar(com/google/common/collect/AbstractIterator.java):64: error: duplicate class: com.google.common.collect.AbstractIterator
public abstract class AbstractIterator<T> extends UnmodifiableIterator<T> {
                ^
/Users/mg/.gradle/caches/modules-2/files-2.1/com.google.guava/guava-gwt/20.0-SNAPSHOT/a12b43e9186d04817e2e73fd3883fe5305e69dc3/guava-gwt-20.0-SNAPSHOT.jar(com/google/common/base/Optional.java):298: error: cannot access AbstractIterator
        return new AbstractIterator<T>() {
                   ^
  bad source file: /Users/mg/.gradle/caches/modules-2/files-2.1/com.google.guava/guava-gwt/20.0-SNAPSHOT/a12b43e9186d04817e2e73fd3883fe5305e69dc3/guava-gwt-20.0-SNAPSHOT.jar(com/google/common/base/AbstractIterator.java)
    file does not contain class com.google.common.base.AbstractIterator
    Please remove or make sure it appears in the correct subdirectory of the sourcepath.
```
 It can only solved my: 

```
tasks.withType(JavaCompile) {
  options.compilerArgs += ["-sourcepath", ""]
}
```
  Had deleted previous fork by accident.
Suggested changes implemented in this one.
 Does anyone resolve the conflict and merge the code?
I cannot find the `Tables.synchronizedTable` function in guava 20.0-rc1.This function would be useful,please.
  `Range.toString()` returns `U+2025` which is not supported by the default terminal under Windows, and most IDEs unless you explicitly change the font. If you read through https://issues.apache.org/jira/browse/SUREFIRE-1220 you will understand the insane hoops that developers have to jump through to get this to work.

Consider replacing this unicode character by `..` or `-` or `,` ASCII characters.
 Yes, gratuitous use of non-ASCII characters in toString() methods is not considerate to users who may not have the right fonts installed. It also results in a string representation that you would never want to actually make users type. Let's say you dump out some ranges in a text config file. How is a user supposed to enter those?

The problem is compounded by the fact that Range is final so you cannot subclass it to work around the problem.
 > "no telling how many things we'd break by changing it."

If computers are parsing this thing then I think we've got a problem. Pretty much everywhere I've read `Object.toString()` is designed for human consumption, not computer parsing.
 I doubt very many people have written parsers that are explicitly looking for \u2025 or else someone probably would have reported this earlier.
 Hi @lowasser. Can you provide us with some more details? Why are they parsing for `\u2025`? What are they doing with it?
 If you want to be backward compatible you could always move the separator string in a writable global variable or have a global useASCII variable.

BTW, the same issue exists with the representation of +/- infinity. It would be better to use "Infinity" (which is what Double uses) instead of the magic infinity character.
 Also, if you add a parse method to Range to read from a String you can have it support the old and new syntax. That would save people from having to write their own parser that explicitly references the separator characters.
 Yes, mutable globals should generally be avoided, but so also should hardcoded non-ASCII characters, so if the alternative is to either break existing code or leave bad behavior, it seems like a reasonable compromise until you can deprecate the old behavior.

As for a parseable interface, something like the Converter API is probably the right thing to do. Users of Java 8 can then use a lambda:

```
Range.parseRange(someString, (Double endpoint) -> Double.parseDouble(endpoint));
```

 You could add a few static methods for integer and double ranges for convenience which would probably cover most user's needs.
 A less painful alternative is to add `toString(String separator)` which lets the user override the default separator. No magic globals there. And ideally you would somehow instruct users that the `toString()` implementation will be changing in an upcoming release so if they are somehow tied to a particular separator character they should use `toString(String separator)` instead of `toString()` whose separator may change over time.

As a side-note, I would also point out that it's problematic that `Range` doesn't "know" the underlying element type. See https://github.com/google/guava/issues/2374 for a recent example of how this could lead to misunderstandings.

Would it make sense to supplement `Range` (for `Comparable` in general) with type-specific implementations such as `IntRange`, `LongRange`, etc? It would allow us to implement more intuitive behavior and adding parsing capability because more feasible.
 You might want to also look for \u221E (infinity).

An alternate toString implementation should also include a parameter for the infinity representation. It wouldn't hurt to add such a method, but it would be a less than ideal solution to the problem because it would force developers to replace all toString calls including the implicit ones in String.format calls.
 Very nice. Thanks Kurt!
  If you are using the EventBus constructor that that takes the `SubscriberExceptionHandler` you can't set the identifier.

Should an additional constructor be added so you can set the identifier?

http://google.github.io/guava/releases/19.0/api/docs/com/google/common/eventbus/EventBus.html#EventBus(com.google.common.eventbus.SubscriberExceptionHandler)
 Awesome.
Thanks!
 I just ran into the same issue missing the two-arg constructor - maybe its addition would be an easy but effective fix? a builder is cool, but needs more time to implement and test, i assume.
 @cgdecker Is it being worked on by anyone? Do you have any specific design in mind? I would like to submit a PR for this.  `Range.closedOpen(0, Integer.MIN_VALUE)` throws `IllegalArgumentException: Invalid range: [0?-2147483648)` but by my understanding, it should not.

The implementation seems to fail because it sees `upper` as being less than `lower` but in practice it should be comparing `upper-1` to lower since the upper cut is open. `upper-1` is indeed greater than `lower` so I am expecting this Range to be valid. Is this a bug or a misunderstanding on my part?
 @lowasser I understand but this is definitely non-intuitive. My API takes an inclusive `min` and exclusive `max` parameters. I need users to be able to specify a range that includes `[0, Integer.MAX_INTEGER]` or even spans the entire range of possible Integers.

How would I check whether some value is included in `[min, max)` if `max` can't equal `Integer.MAX_INTEGER`? If `Range` can't do this, is there another class I should be using?
 Correct. That is the condition I want to check for but I want to express this in terms of a `Range`. The expression you mentioned (`x.compareTo(a) >= 0 && x.compareTo(b) < 0`) holds true for my case but `a > b` does not for the aforementioned reasons.

So if I understand you correctly, you are saying that it is strictly impossible for `Range.closedOpen()` to contain the value `Integer.MAX_VALUE`? If so, I have two comments:
1. Does it really makes sense for `Range` to enforce `a > b` if it doesn't have the ability to translate `b` from open to closed? Wouldn't it better to leave out this check and let the user assert it outside the API?
2. Is it reasonable to use this as a workaround? `Range.closed(min, max-1)` If so, perhaps it makes sense to mention this in the Javadoc? Example: "Please note that closedOpen() cannot contain the maximum value of the underlying type. Consider using closed(min, max-1) for such cases instead of closedOpen(min, max)."

Update (having read your last post): Is there a way to represent `[0, infinity]` as you mentioned using `Range` for Integers? If so, how?
 Fair enough. Thank you for the explanation.
  The code site wiki had a hidden comment just before the CharMatcher section in StringsExplained, and when the docs were migrated to github it got un-commented. Also, there's a missing line that's messing up the formatting of CharMatcher: https://github.com/google/guava/wiki/StringsExplained#charmatcher

Re-commenting the comment and adding a blank line before the table at the beginning of CharMatcher fixes the formatting.

Apparently pull requests against wikis aren't a thing, so here's the fix:

```
diff --git a/StringsExplained.md b/StringsExplained.md
index beaf585..225ed92 100644
--- a/StringsExplained.md
+++ b/StringsExplained.md
@@ -60,16 +60,19 @@ If you wish to get a `List`, just use `Lists.newArrayList(splitter.split(string)

 **Warning:** splitter instances are always immutable.  The splitter configuration methods will always return a new `Splitter`, which you must use to get the desired semantics.  This makes any `Splitter` thread safe, and usable as a `static final` constant.

+<!--
 <a href='Hidden comment:
 = Escaper =
 Escaping strings correctly -- converting them into a format safe for inclusion in e.g. an XML document or a Java source file -- can be a tricky business, and critical for security reasons.  Guava provides a flexible API for escaping text, and a number of built-in escapers, in the com.google.common.escape package.

 All escapers in Guava extend the [http://google.github.io/guava/releases/snapshot/api/docs/com/google/common/escape/Escaper.html Escaper] abstract class, and support the method String escape(String).  Built-in Escaper instances can be found in several classes, depending on your needs: [http://google.github.io/guava/releases/snapshot/api/docs/com/google/common/html/HtmlEscapers.html HtmlEscapers], [http://google.github.io/guava/releases/snapshot/api/docs/com/google/common/xml/XmlEscapers.html XmlEscapers], [http://google.github.io/guava/releases/snapshot/api/docs/com/google/common/escape/SourceCodeEscapers.html SourceCodeEscapers], [http://google.github.io/guava/releases/snapshot/api/docs/com/google/common/net/UriEscapers.html UriEscapers], or you can build your own with [http://google.github.io/guava/releases/snapshot/api/docs/ an Escapers.Builder].  To inspect an Escaper, you can use Escapers.computeReplacement to find the replacement string for a given character.
 '></a>
+-->

 # CharMatcher
 In olden times, our `StringUtil` class grew unchecked, and had
 many methods like these:
+
 | `allAscii` | `collapse` | `collapseControlChars` | `collapseWhitespace` | `indexOfChars` |
 |:-----------|:-----------|:-----------------------|:---------------------|:---------------|
 | `lastIndexNotOf` | `numSharedChars` | `removeChars`          | `removeCrLf`         | `replaceChars` |
```
  Hi,
I've made certain code changes regarding that issue and was wondering if it's still being evaluated by the guava team. I'm not quite familiar with the process yet, but perhaps I can contribute the changes to the project?  There are existing `*Math.isPowerOfTwo` methods, it seems like a `nextPowerOfTwo` method is a good method to go alongside it, to return the smallest integer >= `n` that is a power of two (I was surprised this doesn't exist in guava already, TBH)

This is a simple operation that has a wide range of applications (sizing buffers, primarily, but it also has uses in collection implementations etc), and it's not immediately obvious what the bit-twiddling algorithm is doing when it appears in a codebase. Would seem like a prime candidate for an addition to guava.

There's a simple bit-twiddling algorithm for ints & longs; doubles & bigintegers can probably use a combination of the existing log, floor & pow methods, unless there are clever ways of doing the same for those types (also see http://stackoverflow.com/questions/466204/rounding-up-to-nearest-power-of-2)
 `return Integer.highestOneBit(n) << 1` ?
 When `n` is already a power of two, this will return the next highest one (I want >=, not >). Admittedly, this can be solved using a check for `IntMath.isPowerOfTwo`, but it's still not exactly obvious. There is a related method `BigInteger.bitLength` that can be used for bigintegers, but nothing for doubles that I can see...
 Well, if I have `int n = 4;` and I call `int x = Blah.nextPowerOfTwo(n)`, I logically expect that `x == 8`. Because "next", to me, means "not this one, but the one after".
 A simple version of that is below, which is what I use. As its a one-liner I put the method in the class since its only rarely needed.

``` java
static int ceilingNextPowerOfTwo(int x) {
  // From Hacker's Delight, Chapter 3, Harry S. Warren Jr.
  return 1 << (Integer.SIZE - Integer.numberOfLeadingZeros(x - 1));
}
```
 +1 :)
 With Ben's insight, you can still write:

```
return Integer.highestOneBit(n - 1) << 1;
```

Note the `n - 1`.
 doesn't work for n <= 0
 Powers of two are positive, it makes no sense to use negative values...
 but your code returns 0 for 0 and all negative integers, and should return 1
 If this is purpose (as @simonmcooper originallly wrote)

> nextPowerOfTwo
> return the smallest integer >= n that is a power of two

than you should return at least 1 for all inputs (or throw)
see http://graphics.stanford.edu/~seander/bithacks.html#RoundUpPowerOf2Float
  I'm having an issue deploying to weblogic 12c (12.1.2.0) where it loads the version of `com.google.common.base.internal.Finalizer` from weblogic instead of my WEB-INF/lib. The symptoms are identical to the [previous issue with the beans.xml](https://github.com/google/guava/issues/1527), but I have tried 15.0-cdi1.0, and also versions 17 and 19 and none of them work, so I don't think this is the same as that particular issue. I do have `prefer-web-inf-classes` in my weblogic.xml, and I have tried `prefer-application-packages` instead but it doesn't help.

If I load `Finalizer` using `Class.forName` it gets loaded from the right place, but when `FinalizableReferenceQueue` tries to load it, `Finalizer` gets loaded from weblogic's internal version (which is too old and therefore throws an `NoSuchMethodException`). I have turned on java's verbose classloading log to confirm.

You can see my simple [web.xml](https://gist.github.com/tstibbs/945a0a4c467f0547ec0c#file-web-xml), [weblogic.xml](https://gist.github.com/tstibbs/945a0a4c467f0547ec0c#file-weblogic-xml) and [servlet context listener](https://gist.github.com/tstibbs/945a0a4c467f0547ec0c#file-testfilter-java) (all it does it load the classes). The relevant bits of the log are [here](https://gist.github.com/tstibbs/945a0a4c467f0547ec0c#file-log-log), line 10 shows the class being re-loaded from the wrong place.
  Hi, I just tried updating a HashBiMap using replaceAll and a second HashBiMap, but kept getting the error "java.lang.IllegalArgumentException: value already present: null".
After checking my own code, I set up a minimal code example to see what was going wrong.
It seems like calling replaceAll on an inverse of a HashBiMap doesn't work.

The println lines are just there to show you that it should work as in the line where I combine the two maps.

```
final int upperBound = 2;
final HashBiMap<Integer, Integer> b2a = HashBiMap.create();
IntStream.range(0, upperBound).forEach(i -> b2a.put(i, 100 + i));
System.out.println("b2a" + b2a);
final HashBiMap<Integer, Integer> b2c = HashBiMap.create();
IntStream.range(0, upperBound).forEach(i -> b2c.put(i, 200 + i));
System.out.println("b2c" + b2c);
final BiMap<Integer, Integer> a2b = b2a.inverse();
System.out.println("a2b" + a2b);
System.out.println("a2c" + Maps.asMap(a2b.keySet(), k -> b2c.get(a2b.get(k))));
a2b.replaceAll((a, b) -> b2c.get(b));
System.out.println("a2b'" + a2b);
```

It is interesting to note, that putAll for a copy of the combined map works.
  i found the 19.0 add a new method for BloomFilter,i think i can put more elements into bloomFilter.but, when i try to put more than Integer.MAX_VALUE elemetns into it,it throws Exception:

<code>Caused by: java.lang.IllegalArgumentException: Out of range: 3386879438068</code>

i found the Exception occured this line:

<code>public static int checkedCast(long value) {</code>
  <code>  int result = (int) value;</code>
  <code>  if (result != value) {</code>
  <code>    // don't use checkArgument here, to avoid boxing</code>
  <code>    throw new IllegalArgumentException("Out of range: " + value);</code>
  <code>  }</code>
  <code>  return result;</code>
  <code>}</code>

so, why did you add this new Method?and,how can i put more elements into BloomFilter?
  Hello @cpovirk, I was trying to implement a speculative fix for this issue and make a pull request.

The issue that I am facing is that some classes are not present in this repository, while cloning `https://code.google.com/p/guava-libraries/` as in the [ContributorSetUp](https://github.com/google/guava/wiki/ContributorSetUp) page in the wiki has them.
This mismatch is an issue because I can't make a pull request on those files.

In detail, I was editing:
- `/guava-gwt/src-super/com/google/common/base/super/com/google/common/base/Stopwatch.java`
- `/guava-gwt/test-super/com/google/common/base/super/com/google/common/base/StopwatchTest.java`
- `/guava-gwt/test/com/google/common/base/StopwatchTest_gwt.java`

and the first two of these are missing.

Are these the right classes to edit? Can you help me in any way? 

Thanks
  SampleElements requires 5 distinct elements in the constructor (if they are not distinct some tests) but some collections (like the [Boolean collections from fastutil](http://fastutil.di.unimi.it/docs/it/unimi/dsi/fastutil/booleans/package-summary.html)) only have two distinct values.
  I am guessing the signature could be:
public Range<C>[] subtraction(Range<C> other);
?
  E.g. https://google.github.io/guava/releases/19.0/api/docs/package-list gives a 404, despite https://github.com/google/guava/blob/gh-pages/_releases/19.0/api/docs/package-list existing.

This causes things like

```
1 warning
[WARNING] Javadoc Warnings
[WARNING] javadoc: warning - Error fetching URL: https://google.github.io/guava/releases/19.0/api/docs/
```
  Hi, can I just append a String variable at the start or end of this Joiner, before invoking its join method.
For example:
build a dynamic sql string like below:
("a", "b", "c")
now there is a set named "container" contains these three elements
and I can use Joiner.on(",").join(container) to build a String "a,b,c"
after that I must add "(" and ")" manually.
Is there a exist method to let me append the fixed String "(" and ")" to this instance of Joiner so that I can build up automatically.
 thx
  [testEquals_otherContainsNull](https://github.com/google/guava/blob/a9f8b899c07a33c2203b4e6cf84861646952aeed/guava-testlib/src/com/google/common/collect/testing/testers/SetEqualsTester.java#L67) looks up the "null" value in the set-under-test (indirectly, by comparing it with a test that contains null), even if CollectionFeature.ALLOWS_NULL_QUERIES was not specified.

IMHO this test should be conditioned on CollectionFeature.ALLOWS_NULL_QUERIES being specified during the generation of the test suite.
 Just to give some context: I'm trying to test the [fastutil](http://fastutil.di.unimi.it/) collections using guava-testlib and that's how I run into this scenario ([IntOpenHashSet](http://fastutil.di.unimi.it/docs/it/unimi/dsi/fastutil/ints/IntOpenHashSet.html) throws NPE for example on equals if the "other" collection contains null).

Agreed, this is an ambiguous case. I will also try to bring it up on the fastutil mailing list, perhaps it can be resolved there.
 @lowasser I'm pretty sure `equals()` is not permitted to throw in that case.  Otherwise it would be non-symmetric with `HashSet`.
  Add new mediatypes from [#2132](https://github.com/google/guava/issues/2132).

The mediatype for php (text/php) and cmd (text/cmd) are not included,
because these are not specified by IANA.
  Guava-GWT 18.0 and 19.0 are both incompatible with GWT 2.8.0-beta1. 2.7.0 is working properly.
Both versions reference missing method int GWT core library that is no longer present in 2.8.0.

Interesting aspect is that this problem only appears in SuperDev mode, there is no error message during 'normal' GWT compile.

SuperDev mode produces the following error message:
      Compiling module XXXXX
         [ERROR] Errors in 'com/google/common/collect/super/com/google/common/collect/GwtPlatform.java'
            [ERROR] Line 38: The method createFrom(T[], int) is undefined for the type Array
         Tracing compile failure path for type 'com.google.common.collect.GwtPlatform'
            [ERROR] Errors in 'com/google/common/collect/super/com/google/common/collect/GwtPlatform.java'
               [ERROR] Line 38: The method createFrom(T[], int) is undefined for the type Array

The root cause is in class GwtPlatform (comments removed)

```
package com.google.common.collect;

import com.google.common.annotations.GwtCompatible;
import com.google.gwt.core.client.GwtScriptOnly;
import com.google.gwt.lang.Array;

@GwtCompatible
@GwtScriptOnly
public final class GwtPlatform {

  private GwtPlatform() {}

  public static <T> T[] newArray(T[] reference, int length) {
    return Array.createFrom(reference, length);
  }
}
```

As you can see, it references Array.createFrom that was removed in version 2.8.0.

I would suggest the following solution. It doesn't use any internal API and seems to be working cleaner then previous one (Array,createFrom didn't initialize the elements of new array that were not copied from reference and they stayed undefined instead of null).

```
  public static <T> T[] newArray(T[] reference, int length) {
        T[] res = (T[]) new Object[length];
        if ((reference != null) && (reference.length > 0)) {
            System.arraycopy(reference, 0, res, 0, Math.min(length, reference.length));
        }
        return res;
  }
```

Thank you!
 Alrighty, if you use the proposed code above, it does NOT depend on any internal GWT structures at all. So it is safe to use it in any case (in all GWT versions).
I'm unaware of any other troubles, but this one is easy to fix.

Thanks.
 I guess, that;s independent of this one. I'm not arguing, just if you accept this fix, it will make your life in terms of #1999 a bit easier.
 OK, maybe, I'm not an expert in low-level implementation details, I guess,
GWT team should help here.

On Thu, 7 Jan 2016 13:51 Chris Povirk notifications@github.com wrote:

> The above fix compiles but doesn't actually return a T[], only an Object[]
> that looks like one. The method is expected to return a T[].
> 
> —
> Reply to this email directly or view it on GitHub
> https://github.com/google/guava/issues/2353#issuecomment-169532631.
 are you using singleton pattern in your project .... if yes then why..
 The code above is not what you want at all.

The class literal on the object array will cause troubles later if you try to assign it to a properly typed variable.

The method you are looking for is new:
`javaemul.internal.ArrayHelper.createFrom(notCopied, length)`

All of the really intrinsic "must have this just to use java types" all live in the new javaemul.internal package.
 These types are, of course, super sourced, but I imagine that it is no problem, as they will be accessed via super-sourced types.
 Ah, I see it is patched using Arrays.copyOf, which is already emulated to route to the ArrayHelper.  Nevermind :D
  I am expecting the cache to evict keys after System.gc(). This requires:
- cache.getIfPresent(v) works
- cache is cleared after System.gc()

But unfortunately it couldn't satisfy both conditions.

Here is how I created the cache:

```
        Cache cache = CacheBuilder.newBuilder()
                .weakKeys().build();
```
- Eviction works when the key is created and not assigned to a variable

```
        cache.put(Math.random(), "a");
        System.out.println("cache: " + cache.asMap());
        System.gc();
        System.out.println("cache: " + cache.asMap());
```

This showed the correct output:

```
cache: {0.7254227566649404=a}
cache: {}
```
- Eviction doesn't work if the the key is assigned to a local variable:

```
        Cache cache = CacheBuilder.newBuilder()
                .weakKeys().build();
        {
        Double r = Math.random();
        cache.put(r, "a");
        }
        System.out.println("cache: " + cache.asMap());
        System.gc();
        System.out.println("cache: " + cache.asMap());
```

This showed the wrong output:

```
cache: {0.006581944795823524=a}
cache: {0.006581944795823524=a}        //  <=== notice here, the value is still in cache.
```
- Eviction works with primitive, but cache doesn't work

```
        double r = Math.random();
        cache.put(r, "a");
        System.out.println("cache: " + cache.asMap());
        System.out.println("v: " + cache.getIfPresent(r));
        System.gc();
        System.out.println("cache: " + cache.asMap());
```

This showed the wrong output:

```
cache: {0.3569447241229746=a}
v: null                     // <===  autoboxed Double at different time will give different segment hashes.
cache: {}
```

So, with Cache.weakKeys(), we don't have eviction on System.gc(), or cache with keys that don't have a match.
 @lowasser Is there a way to construct the key when using .weakKeys(), then?

because
- when key is primitive, getIfPresent() doesn't work as using ==
- when key is object, getIfPresent() works; but we have to keep a reference of the object for future matching, which is a strong reference.
 I think the use case is very general for expectation on .weakKeys(). not quite satisfied with this answer.
 I will explore other alternative then. I don't think the current implementation of .weakKeys() works for me if it behaves this way.
 Thanks for the information on weakKeys(). Good to find out it is only intended for comparison with == operator, and not intended for the GC based caching. 
 ah I see. I constructed the demo code to examine wrongly. (I thought out of scope with {} would remove the reference.) GC removes the cache entry after I refactored the demo code into a method.

you are right that it doesn't fit my use case. Thanks for the explanation
  Could Guava add a `@VisibleForSubpackages` annotation?  This would be similar to the existing `@VisibleForTesting` annotation which documents why an interface has more visibility than desired and that external callers should not use it.  Specifically I ran into this with Apache jclouds which has a hierarchy of subpackages within a jar, e.g., `org.jclouds.s3` and `org.jclouds.s3.binders`.  Classes of the subpackage have public visibility so that the parent package can see them but are unintentionally exported to externally callers.  Having `@VisibleForSubpackages` would warn callers and allow external tools to remove references, e.g., Javadoc, semantic versioning checkers.

If `@VisibleForTesting` were a more generic term, e.g., `@UnfortunatelyVisible`, with a user-specified reason, this would address my use case as well as other potential cases.  The more generic term also removes confusion between super- and sub-packages in my example.  This feature request would also seem to interact with Java 9 module visibility although I do not believe it has a similar source-level annotation.
 Yes, please! Although it it true that most of the time the visibility is for testing, sometimes there are other (sometimes valid) reasons, too, and this might help consolidating the mess around them.
 Shouldn't Jigsaw modules be the preferred resolution?
 We haven't thought about it; we haven't gotten any requests for it.  Any sense of how common this use case is?

Also, I agree with Ben that the long-term solution for this is the module system, but I could understand people not wanting to wait until Java 9 for a solution.
  fyi, [future-converter](https://github.com/lukas-krecan/future-converter/) provides a shim until then.
 Maybe also consider a shim for ListenableFuture -> CompletableStage for Java 9 users (packaged in an [MRJAR](http://openjdk.java.net/jeps/238)?), if [this conversation on the OpenJDK mailing lists](http://mail.openjdk.java.net/pipermail/core-libs-dev/2016-September/043699.html) ends up being fruitful.
 and spotify/futures-extra has the handy [CompletableToListenableFutureWrapper](https://github.com/spotify/futures-extra/blob/master/src/main/java/com/spotify/futures/CompletableToListenableFutureWrapper.java) (which [we use here](https://git.opendaylight.org/gerrit/#/c/64771/))  The [javadoc for TestContainerGenerator.order](https://github.com/google/guava/blob/master/guava-testlib/src/com/google/common/collect/testing/TestContainerGenerator.java#L66) states:

> This method runs only when CollectionFeature#KNOWN_ORDER is specified when creating the test suite. It should never run when testing containers such as HashSet, which have a non-deterministic iteration order.

However, 74 tests (out of 450) fail with the code below which (as described by the documentation) expects TestContainerGenerator.order not to be called and throws an UnsupportedOperationException for it:

``` java
public final class JavaUtilCollectionsTests {
  public static Test suite() {
    TestSuite suite = new TestSuite("HashSet");
    suite.addTest(SetTestSuiteBuilder.<Integer>using(new TestSetGenerator<Integer>() {
      @Override
      public SampleElements<Integer> samples() {
        return new SampleElements<Integer>(-7, 0, Integer.MIN_VALUE, 42, Integer.MAX_VALUE);
      }

      @Override
      public Integer[] createArray(int length) {
        return new Integer[length];
      }

      @Override
      public Iterable<Integer> order(List<Integer> insertionOrder) {
        throw new UnsupportedOperationException();
      }

      @Override
      public Set<Integer> create(Object... elements) {
        List<Integer> values =
            Arrays.stream(elements).map(o -> (Integer) o).collect(Collectors.toList());
        return new HashSet<>(values);
      }
    }).named("HashSet")
        .withFeatures(CollectionSize.ANY, CollectionFeature.GENERAL_PURPOSE,
            CollectionFeature.ALLOWS_NULL_VALUES, CollectionFeature.SERIALIZABLE_INCLUDING_VIEWS)
        .createTestSuite());
    return suite;
  }
}
```

The expected result would be for all the tests to pass.
 Changing the documentation to allow to just return the list if the order can not be guaranteed sounds good to me.
 @cpovirk - no problem, I appreciate them being fixed. And thank you for this extensive test-suite, it really helps in sussing out the bugs from 3rd party collection frameworks!
  Please consider adding following comparison operators to Ordering class:
- `eq(a,b)` as shortcut for `comparator.compare(a,b)==0`
- `nq(a,b)` as shortcut for `comparator.compare(a,b)!=0`
- `lt(a,b)` as shortcut for `comparator.compare(a,b)<0`
- `lte(a,b)` as shortcut for `comparator.compare(a,b)<=0`
- `gt(a,b)` as shortcut for `comparator.compare(a,b)>0`
- `gte(a,b)` as shortcut for `comparator.compare(a,b)>=0`
  Not sure if this has been discussed previously but it is trivial to add methods that return CharSequence types to the Splitter API and maintain the existing API. We have some use cases for this feature where we do not want to create temporary char[] array copies of the intermediate substrings.

The Splitter API accepts CharSequence types as input and internally manipulates CharSequence types. This patch maintains the existing methods that return String types and adds additional methods that
return CharSequence types. The performance overhead on the existing methods that return String type is one additional call to Iterators#transform() that calls toString() on the CharSequence results. Note the #toString() call was already present in the existing implementation.
 It looks like the API of Splitter was created at the time when the HotSpot
JVM did not allocate new char[] arrays for subsequences. That behavior was
changed in their release of JDK 7u6:
http://bugs.java.com/view_bug.do?bug_id=4513622. Might this warrant the
need for new methods that do not create new char[] arrays?
On Jan 2, 2016 3:26 AM, "Kurt Alfred Kluever" notifications@github.com
wrote:

> The Splitter API has been part of Guava since 1.0, and has been fairly
> stable (it's non-@Beta at this point). I'm somewhat doubtful that this
> use-case is popular enough for us to start expanding the API at this point.
> 
> —
> Reply to this email directly or view it on GitHub
> https://github.com/google/guava/pull/2345#issuecomment-168373137.
  During some analysis with DepAn, I notices that XML_ESCAPER is never used internally, nor is it accessible externally.  Seems like a good idea to delete this cruft, especially after 2 years as dead code.
 I signed it!
 You have write permission, so it is your call.  But it does seem to violate the normal Googley convention that no dead or commented out code should be checked into the repository.  I guess all rules have exceptions.
  Recently a [question on StackOverflow](http://stackoverflow.com/q/34472616/180719) showed that it was impossible to run such a portion of Java 8 code (compile-time is okay):

```
public final class SampleMain {
  public static void main(String[] argArr) {
    final ArrayListMultimap<Void, Void> arrayListMultimap = ArrayListMultimap.create();
    arrayListMultimap.clear();
    final Consumer<ArrayListMultimap> arrayListMultimapConsumer = ArrayListMultimap::clear;
    arrayListMultimapConsumer.accept(arrayListMultimap);
  }
}
```

This issue comes from the fact that some public methods are last defined in a package-private parent class. It has been referenced as issue [issue JDK-8143647](https://bugs.openjdk.java.net/browse/JDK-8143647) from the JDK and is fixed, but the fix is yet to be released.

So to workaround the JDK issue and protect Guava users from it, is it possible to look for each method that is last defined in a package-private parent class and overwrite those methods in public implementations with a rather simple call `super.method()`?
  I think I know the argument for using Object-type parameters in this new Graph thing (is it similarity to the Collections API?), but I believe it is a good time to reconsider this in view of:
- Java changes that are (hopefully) going to come sooner or later (http://mail.openjdk.java.net/pipermail/valhalla-spec-experts/2015-December/000001.html),
- Graph being a totally new interface (at least for wider public), not released, still in beta.

It's always beneficial to have as much type-constrained API as possible. It would be especially nice in case of Graph, as it has many similarly named methods that are easy to confuse (that's my experience as of now).

I'll understand if you do nothing, but, please, at least think about doing something else.
 @cpovirk I think that de8d63f and 206a5ac resolved this one (hooray!). Could you confirm, please?  I'm watching here: [Maps.uniqueIndex](http://google.github.io/guava/releases/snapshot/api/docs/com/google/common/collect/Maps.html#uniqueIndex%28java.lang.Iterable,%20com.google.common.base.Function%29)
I think those two are equivalent :)
 @lowasser oops I didn't notice that one is for Iterator, and the other one is for Iterable. will close this issue! thanks.
  Our project (https://github.com/google/closure-compiler) cannot build with GWT 2.8.0-beta1 and Guava 19.0 release. The Travis CI has been broken for a week. Can we expect a 20.0-SNAPSHOT to be published to google-snapshots soon?
 Why use a SNAPSHOT at all?  Just use 19.0, better yet inherit the version from the parent pom

I had to hack the release process for v20151216 because gwt was broken in multiple places.
 @cpovirk Thanks. I was looking at the wrong place.
@lindner The 19.0 release does not work with GWT 2.8.0-beta1, at least for Closure Compiler. 
  Mutable operations on `ImmutableRangeSet` (`add`, `remove`, `clear`, etc) should be marked as unsupported and deprecated and javadoc modified appropriately, in a similar way to mutable operations on the other immutable collections.
  I use this api to read file to String in android(guava 19.0)

```
s = Files.toString(file, Charsets.UTF_8);
```

The traditional plain ugly java works fine.
 Android Build Version Info

``` android
    compileSdkVersion 23
    buildToolsVersion "23.0.2"
```

Equivalent Java code

``` java
    public static String readFileContent(File file) {
        InputStream inputStream;
        StringBuilder total = new StringBuilder();
        try {
            inputStream = new FileInputStream(file);
            BufferedReader r = new BufferedReader(new InputStreamReader(inputStream));
            String line;
            while ((line = r.readLine()) != null) {
                total.append(line);
            }
        } catch (FileNotFoundException e) {
            LogUtil.d(TAG, String.format("e = %s", e));
        } catch (IOException e) {
            LogUtil.d(TAG, String.format("e = %s", e));
        }

        return total.toString();
    }
```

Guava doesn't report any error.
I tried the guava 18.0, it can't read the file contents too.
 @lowasser it doesn't get the file content.
 And there is a weird thing about this: when i try to print the string, the expression seems not been executed at all.It not even show "s = null" or something like that.

``` android
 LogUtil.d(TAG, "s = " + s);
```
 So I tried in another way, I write a simple gradle-java project use the same file and guava 19.0.
It works fine.
 will you look up to this? on android platform i still can't read the file using guava library.
  `ImmutableSortedMap.copyOf` has an overload with the following signature:

```
copyOf(Map<? extends K,? extends V> map, Comparator<? super K> comparator);
```

but similar methods on `ImmutableSortedSet` are declared like so:

```
copyOf(Comparator<? super E> comparator, Collection<? extends E> elements)
copyOf(Comparator<? super E> comparator, Iterable<? extends E> elements)
copyOf(Comparator<? super E> comparator, Iterator<? extends E> elements)
```

The placement of the `Comparator` argument is inconsistent. I suggest one version is deprecated, and overloads with the arguments swapped over are added.
 The `Comparator` coming second also matches with the JCL (`Collections.sort`, etc)

I would say there's no harm in deprecating the existing inconsistent ones, providing overloads, and leaving it like that for several versions. Gives people plenty of time to change.
  I think it would be really useful if guava-testlib included an implementation (or implementations) of `Executor`, `ExecutorService`, `ListeningExecutorService` and `ScheduledListeningExecutorService` that allow manual progression/execution of the submitted tasks.

I've needed this a number of times while writing tests for classes that rely on these types and it is prone to error each time. Having it in the Guava Teslib would help out.

A possible use would be something like this:

``` java
ScheduledExecutorService e = TestExecutors.newTestExecutor();
Future<?> t = e.schedule(someRunnable, 10, SECONDS);
assertFalse(t.isDone());
e.runAll(10, SECONDS);
assertTrue(t.isDone());
```

Other options would be `runOne` and overloads that only run tasks that are already past their scheduled time.
 Hi @mattnathan,

You might be interested in the deterministic implementations of those interfaces that JMock library provides: [DeterministicScheduler](http://www.jmock.org/javadoc/jmock-2.6.0/doc/org/jmock/lib/concurrent/DeterministicScheduler.html) and [DeterministicExecutor](http://www.jmock.org/javadoc/jmock-2.6.0/doc/org/jmock/lib/concurrent/DeterministicExecutor.html).

Changing your example a little bit by using `DeterministicScheduler` (which implements `ScheduledExecutorService`):

``` java
DeterministicScheduler e = new DeterministicScheduler();
Future<?> t = e.schedule(someRunnable, 10, SECONDS);
assertFalse(t.isDone());
e.tick(10, SECONDS);
assertTrue(t.isDone());
```

You are allowed to influence the progress manually by using the methods `runPendingCommands`,  `runNextPendingCommand`, `runUntilIdle` and `tick`, respectively. 
 Thanks for the pointer, will definitely take a look. One of my (unsaid) use cases for this was to have it implement `ListenableScheduledExecutor` too, but it could form the bases of that implementation quite easily I'd expect.
  Hey!
I found that the following test will fail with a TimeoutException (the Future hangs indefinitely): 

``` java
  static final int REPS = 10000;
  @Test
  public void hangs() throws InterruptedException, TimeoutException {
    SettableFuture<Integer> settableFuture = SettableFuture.create();
    ListenableFuture<Integer> chained = settableFuture;
    for (int i = 0; i < REPS; ++i) {
      chained = Futures.transform(chained, Functions.<Integer>identity());
    }
    settableFuture.set(0);

    Futures.get(chained, 10, TimeUnit.SECONDS, TimeoutException.class);
  }
```

But if I change REPS to be something smaller, like 1000 (this will depend on the size of the stack) then the test passes. I think the root cause is is that the exception can't 'surface' to the final `chained` Future due to a StackOverflowError caused by repeated DirectExecutor.execute application.

My logging config may be screwed up, but I didn't see a log for this or anything, which made finding this a bit of a chore. I checked that this happens with Guava 18 and 19. Apologies if this is a KP or already filed (I tried searching Issues, but nothing related pops up).
 Hi Chris!

I think it's perfectly reasonable for you to say that there is a limit to the amount of chaining when using a `directExecutor`. The bit I'm worried about and would love to see resolved is the disappearing `StackOverflowError`. I think the reason it goes missing is because the execution goes along these lines:
1. Start executing a `Future` from the chain
2. Execution succeeds, mark it as 'done'
3. Attempt to execute the next `Future` (use `directExecutor`)
4. Stack overflow
5. Mark current future as 'failed', wait, nope, it's done, don't need to do anything.

It looks like the exception gets absorbed into a completed future (`ChainingListenableFuture` catches it by catching all `Throwable` and calls `setException` which then ignores the exception because the `Future` is already in the `COMPLETED` state).
The exception could go to the caller (so calling `.set(0)` would throw a `StackOverflowError`) - anywhere is better than nowhere.

We did indeed hit this in ["real" code](https://github.com/facebook/buck/commit/6ee1b3e9a44c9b451411b0e376f3c7eff438fe2e) (`MoreFututres.chainExceptions` is [essentially Futures.transform](https://github.com/facebook/buck/blob/master/src/com/facebook/buck/util/concurrent/MoreFutures.java#L169)). The code that was building the chain was silly, so the fix was easy. Like I said at the beginning - the fact that the error was entirely suppressed is the real issue.

Cheers!
  Martin
 No worries! Personally I'd be fine with you going to the uncaught exception handler directly, but I guess that might be a bit extreme.

I didn't get the last bit:

> `in which case we're back in danger of a stack overflow.` 

From my understanding you'd wrap the `StackOverflowError` in something like `FutureExecutionRuntimeException` (which would be re-thrown/ignored by any intermediate futures). That should unwind the stack all the way to the top (which would most likely be a worker thread) where it would manifest as an runtime exception. How could we get another stack overflow in that case?
 Looks good to me. I think RuntimeException could also mean that the executor failed or something like that, right? In that case I think the only options to make progress are either logging (+ignore) or re-throwing wrapped in an Error (or `FutureExecutionRuntimeException`).
  The semantics of `or` on an `Optional` constructed using `Optional.fromNullable` surprised me. For the sake of example, consider this sample:

``` java
// Assume `possiblyAssignValue` returns type `String` which may per-execution randomly be
// either `"A"` or `null`
String maybeNotNull = possiblyAssignValue();
String definitelyNull = null;
String definitelyNotNull = "C";

System.out.println(Optional.fromNullable(maybeNotNull).or(definitelyNull).or(definitelyNotNull);
```

I would _expect_ that the code would sometimes print out `A` and other times `C`, pursuant to the nullness of `maybeNotNull`; however, the `or` methods will always cause a runtime exception, because they check that the argument is not `null` (or doesn't evaluate to `null`).

In my case, I am using `Optional` to help parse a response from a server, which might contain one element or another, mutually-exclusively: if I try and use `or` to do this (which I think is reasonable), then the code throws a runtime exception anytime the first element is present. In this case, the contract with the server says that the second can (and should!) be missing.

I'm not sure if it's the best solution, but one solution that presents itself to me is having a complementary set of methods on `Optional` for the two signatures which do not accept an `Optional` argument, such as `orNullable` which checks whether `defaultValue` or `supplier.get()` evaluate to `null` and return `Optional.absent` instead of throwing an exception. Such a solution would allow developers to both idiomatically code against their own assumptions about the mutual-exclusivity of two values' nullness, and explicitly handle edge cases (e.g. where the supplied default value is unexpectedly `null`) themselves.
 Can't you use the following?

```
Optional<String> maybePresent = Optional.fromNullable(possiblyAssignValue());
Optional<String> definitelyAbsent = Optional.absent();
Optional<String> definitelyPresent = Optional.of("C");
String value = maybePresent.or(definitelyAbsent).or(definitelyPresent);
```
  Here is the scenario.

I have a `Map<String,Object>` of defaults for something.

I want to build up a customized set of things that can be a partial set of those defaults.

I want to be able to overlay these customized things over the default and produce an `ImmutableMap` union of these two ( or more ) maps.

Right now I have to do this with a mutable map implementation and then wrap that with `.copyOf()`, I would rather be able to do it directly with the existing `Builder` implementations but I can not because they will throw exceptions because of the duplicate keys.

`Map<String,Object> mergedMaps = ImmutableMap.builder().putAll(defaults).put("custom","value").build();`

or

`Map<String,Object> mergedMaps = ImmutableMap.builder().putAll(defaults).putAll(partialOverlay).build();`

Is this something you will consider implementing?
 Assuming the map of defaults specifies the complete domain, I suppose you could do the following:

``` java
Map<String, Object> defaults = ...;
Map<String, Object> custom = ..;
Map<String, Object> merged = ImmutableMap.copyOf(Maps.transformEntries(defaults, custom::getOrDefault));
```

Note that `Maps::transformEntries` produces a view, so there's no unnecessary copying here.
 This is just as good if not better because of the possibility of unnecessary copying!

I am on Java 7 so I ended up with this.

```
final Map<Fields,Object> merged = ImmutableMap.copyOf(ImmutableMap.copyOf(Maps.transformEntries(defaults, new Maps.EntryTransformer<Fields, Object, Object>() {
                        final Map<Fields,Object> custom = imb.build();
                        @Override public Object transformEntry(@Nullable final Fields key, @Nullable final Object value)
                        {
                            return custom.containsKey(key) ? custom.get(key) : value;
                        }
                    })));
```

Thanks for the prompt response!
 Here is a [link to a complete Gist](https://gist.github.com/jarrodhroberson/780d38e41df96f2be980) that I use all the time now!
  There are several significant new collection methods in Java 8 (especially on the Map interface). Tests for these should be added to the guava collection test suite.
  verifySimpleMessage(expected)  change to assertThat(expected).hasMessage("A message"), 

so that the  compared target("A message") can be saw straightway
 I signed it!
this is my first contribute in open source
exciting and hope to be accepted
  Use-case (related to http://stackoverflow.com/q/1391918/14731 and http://stackoverflow.com/a/1815793/14731):

I'm using Fork/Join to populate a `ConcurrentHashMap`. Unfortunately, the latter does not guarantee iteration order (which I need). So now, every time I insert into the `ConcurrentHashMap` I also insert the key into a `ConcurrentLinkedQueue`. Then, when the user requests the output, I create a new sorted map as follows:

`ImmutableSortedMap.copyOf(concurrentHashMap, Ordering.explicit(new ArrayList<>(concurrentLinkedQueue)));`

This code is very performance-sensitive and from profiling I can tell that `Ordering.explicit()` invokes `Object.equals()` many times on the key. I'd like to instruct `Ordering.explicit()` to use `==` for comparison because (for my particular use-case) it is noticeably faster and perfectly legal (the same keys are added into the `Map` and `Queue`).
  When some data are pushed to a system, we often need to get feed back mentioning if the pushed data were correct or not. If there is some errors or warnings, the client system expects to get an object containing all errors or warnings. It can be a simple list of `String` but it is more convenient if : 
- Prebuild severity level are possible : "error", "warn".. and "info" ?
- The object has method such as `hasErrors`, `hasWarnings`, ...
- The obkect is nestable : an item can be a validation result itsef and not only a string
- The class has fluent style factory methods (or builder) for creating  the validation result.

Martin Fowler exposes this pattern as "Notification" : http://martinfowler.com/eaaDev/Notification.html

As it is a very common and generic pattern, I would like it available directly in Guava. 
  ImmutableSortedSet.copyOf(Collection) should fail if the input collection is not comparable.
This currently applies for most collections, but fails if the input is a singleton.
This is recorded in issue #1835.

I have noted that this is caught within TreeSet by invoking the comparator on the singleton item, so this change makes a similar call to catch the un-comparable items in a singleton ImmutableSortedSet.

I have added tests for a two-element input collection (which was already caught), and a new test for a single-element input; this latter test only passes once the code change has been inserted.
 _This includes some people who define Comparators that throw if given equal elements!_

Note (just for info) that this is exactly what TreeSet does when you insert its first element.
The comparator call is what triggers the failure here:

```
 SortedSet<Object> sortedSet = new TreeSet<Object>();
 sortedSet.add(notComparable);
```
  Fix for issue #2241
 I signed it!
  I've got some lazy iterators that I may or may not end up evaluating, but when I pass them into MergingIterator they are evaluated at construction time:

```
      for (Iterator<? extends T> iterator : iterators) {
        if (iterator.hasNext()) {
          queue.add(Iterators.peekingIterator(iterator));
        }
      }
```

It would be nice to preserve the laziness of the passed in iterators by having the initialization happen during runtime. Seems like it would be pretty easy to wrap up the queue initialization into a memoized supplier.
 Almost... I expect //2 to (potentially) read off all the supplied iterators, yet it currently happens at //1.
  [UseGuavaInYourBuild](https://github.com/google/guava/wiki/UseGuavaInYourBuild) is out-of-date as it refers to old versions of guava, specifically 12.0 and 10.0.1 as opposed to the latest release 18.0.

As the latest releases are documented in the [README](https://github.com/google/guava/blob/master/README.md) file this wiki-page does not really serve a purpose, and can probably be removed.
  An attempt to call _com.google.common.reflect.ClassPath#from_ ends with NullPointerException on IBM WebSphere 8.5.5.5. The following snippet from _com.google.common.reflect.ClassPath#getClassPathEntries_ causes issues:

``` java
URLClassLoader urlClassLoader = (URLClassLoader) classloader;
for (URL entry : urlClassLoader.getURLs()) {
```

_getURLs()_ on _com.ibm.ws.bootstrap.ExtClassLoader_ returns null:

``` java
    public URL[] getURLs() {
        return null;
    }

    public URL[] _getURLs() {
        return super.getURLs();
    }
```

It looks like IBM made this on purpose, so I guess reporting to Guava is more appropriate here.
  The `tryParse` methods should behave similarly: 

```
Doubles.tryParse(null)  -> null
Floats.tryParse(null)   -> null
Longs.tryParse(null)    -> NPE
Ints.tryParse(null)     -> NPE
```

For a method like this I would prefer the null result since otherwise I would use the Java parseInt. But if they all should throw NPE I think that should be clearer in the JavaDoc (even if you normally do not document @NotNull parameters).
 Just an idea: maybe they should return an optional and never throw? But then that would really break the api.
 The String "null" leads to null - but for all tryParse variations (and its expected). 
 @kluever Yes, but the String "null" could be (part of) the reason @osundblad is experiencing his results, while your tests pass, "null" and null look similar in a logfile.
 No it is not the String null. It is exacyly as I wrote it at the top:

```
Doubles.tryParse(null)  -> null
Floats.tryParse(null)   -> null
Longs.tryParse(null)    -> NPE
Ints.tryParse(null)     -> NPE
```

And since you usually use methods like this in I/O I think they should be very forgiving, ie. accept null and not throw NPE on it. 

I found it while trying to convert json to Java Objects where the JavaScript framework inserted null values instead of empty string (the json included both Integers and Doubles).
 just simply null the string
 The testcase is using `long unused = Longs.tryParse(null);` which is problematic: 
`Longs.tryParse` returns a boxed `Long`, which is unboxed to the primitive `long`.
Unboxing a null value yields a NPE, so even something returning `null`, for instance `Longs.tryParse("a")` passes the test.
Solution: use the boxed type `Long` for the `unused` var
 Sorry for the late reply. I tried to figure out how I got the null result from Doubles but could not recreate it in the hour I spent. Kind of annoyed since I and a co-worker were pair-programming and wrote JUnit test tests to prove the behavior (the I actually copy/pasted the results from the tests) at the time but since we wanted null not NPE we switched from guava to apache commons so we never checked in the tests. 

The only things I can think of is that it was an:
1 We used an old version of guava (tried a few without being able to recreate the weird behavior)
2 We somehow got another library without noticing (the dependency list was quit long)

But it is all the same since the behavior is consistent (now). (But sadly not what we needed so were using apache commons)

Sorry for the miss report
    I'm trying to run only one of the selected test cases via `mvn` like this:

```
mvn -Dtest=UntrustedInputFutureTest#testSetFutureThenInterrupt test
```

But this doesn't work, `mvn` says `There are no tests to run.`. 

How should I run only one test case? 
 Hi,

You are not able to run this test case using maven because this is defined using junit.framework.TestCase. This can be run by overriding the runTest() method or by creating a testSuite.
  This could be a compiler bug, or it could be an issue with the way `ImmutableMap.Builder()` functions. 

Here is my sample class which produces the compilation error (stack overflow during compile)

``` java
import java.util.Map;
import java.util.UUID;
import com.google.common.collect.ImmutableMap;
public class MapTest {
  private static final Map<String, Object> map = new ImmutableMap.Builder<String, Object>()
      .put("cbc3fdad-01ed-4f90-a75d-b239fb99acab", new Object())
      .put("621a7f96-3513-4b4a-9c35-bc80fbc42f18", new Object())
      .put("c95de3a1-da02-45a8-9cd4-2f6014fb47a6", new Object())
      .put("6a759307-b797-40d7-9e53-fc3c335b73b4", new Object())
      //... (10,000 total puts)
      .build()
}
```

Here is the command used to compile the class (note: I first encountered this with guava 16, then thinking it may have already been fixed it duplicated the error with v 18)

``` text
$> javac -classpath guava-18.0.jar MapTest.java 


The system is out of resources.
Consult the following stack trace for details.
java.lang.StackOverflowError
    at java.util.regex.Pattern$1.isSatisfiedBy(Pattern.java:4111)
    at java.util.regex.Pattern$5.isSatisfiedBy(Pattern.java:5251)
    at java.util.regex.Pattern$5.isSatisfiedBy(Pattern.java:5251)
    at java.util.regex.Pattern$CharProperty.match(Pattern.java:3776)
    at java.util.regex.Pattern$GroupHead.match(Pattern.java:4658)
    at java.util.regex.Pattern$Branch.match(Pattern.java:4602)
    at java.util.regex.Pattern$Branch.match(Pattern.java:4602)
    at java.util.regex.Pattern$Branch.match(Pattern.java:4602)
    at java.util.regex.Pattern$BranchConn.match(Pattern.java:4568)
    at java.util.regex.Pattern$GroupTail.match(Pattern.java:4717)
    at java.util.regex.Pattern$Curly.match0(Pattern.java:4279)
    at java.util.regex.Pattern$Curly.match(Pattern.java:4234)
    at java.util.regex.Pattern$GroupHead.match(Pattern.java:4658)
    at java.util.regex.Pattern$Branch.match(Pattern.java:4604)
    at java.util.regex.Pattern$Branch.match(Pattern.java:4602)
    at java.util.regex.Pattern$BmpCharProperty.match(Pattern.java:3798)
    at java.util.regex.Pattern$Start.match(Pattern.java:3461)
    at java.util.regex.Matcher.search(Matcher.java:1248)
    at java.util.regex.Matcher.find(Matcher.java:664)
    at java.util.Formatter.parse(Formatter.java:2549)
    at java.util.Formatter.format(Formatter.java:2501)
    at java.util.Formatter.format(Formatter.java:2455)
    at java.lang.String.format(String.java:2940)
    at com.sun.tools.javac.comp.DeferredAttr$DeferredTypeMap.<init>(DeferredAttr.java:828)
    at com.sun.tools.javac.comp.Attr.checkMethod(Attr.java:3815)
    at com.sun.tools.javac.comp.Attr.checkIdInternal(Attr.java:3593)
    at com.sun.tools.javac.comp.Attr.checkMethodIdInternal(Attr.java:3504)
    at com.sun.tools.javac.comp.Attr.checkMethodId(Attr.java:3479)
    at com.sun.tools.javac.comp.Attr.checkId(Attr.java:3466)
    at com.sun.tools.javac.comp.Attr.visitNewClass(Attr.java:2072)
    at com.sun.tools.javac.tree.JCTree$JCNewClass.accept(JCTree.java:1516)
    at com.sun.tools.javac.comp.Attr.attribTree(Attr.java:566)
    at com.sun.tools.javac.comp.Attr.attribArgs(Attr.java:664)
    at com.sun.tools.javac.comp.Attr.visitApply(Attr.java:1806)
    at com.sun.tools.javac.tree.JCTree$JCMethodInvocation.accept(JCTree.java:1465)
    at com.sun.tools.javac.comp.Attr.attribTree(Attr.java:566)
    at com.sun.tools.javac.comp.Attr.visitSelect(Attr.java:3227)
    at com.sun.tools.javac.tree.JCTree$JCFieldAccess.accept(JCTree.java:1897)
    at com.sun.tools.javac.comp.Attr.attribTree(Attr.java:566)
    at com.sun.tools.javac.comp.Attr.visitApply(Attr.java:1815)
    at com.sun.tools.javac.tree.JCTree$JCMethodInvocation.accept(JCTree.java:1465)
    at com.sun.tools.javac.comp.Attr.attribTree(Attr.java:566)
    at com.sun.tools.javac.comp.Attr.visitSelect(Attr.java:3227)
    at com.sun.tools.javac.tree.JCTree$JCFieldAccess.accept(JCTree.java:1897)
    // stack trace repeats
```

Here is my Java version

``` text
java version "1.8.0_60"
Java(TM) SE Runtime Environment (build 1.8.0_60-b27)
Java HotSpot(TM) 64-Bit Server VM (build 25.60-b23, mixed mode)
```

Here is the dummy code I used for generating the source code to do 10,000 puts on the map

``` java
import java.util.UUID;

public class MapTest {
  public static void main(String[] args) {
    StringBuilder sb = new StringBuilder();
    for (int i = 0; i < 10000; i++) {
      String id = UUID.randomUUID().toString();
      sb.append("    .put(").append(quote(id)).append(", new Object()").append(")").append(System.lineSeparator());
    }
    System.out.println(sb);
  }

  private static final String quote(String s) {
    return '"' + s + '"';
  }
}
```
 Changed compile command to the following and still getting the same error:

``` text
javac -J-Xmx4096m -classpath guava-18.0.jar MapTest.java
```

Also the code isn't in a method so is that size limit still enforced?
 Oops my bad, your suggestion fixes my compilation problem.  Thanks for the help and information!
  At present, the Range abstraction is implemented in terms of Cut, but the Cut type (and the Range constructor that utilizes that type) is package-private.

Cut seems like a mathematically-sound concept -- something that's unlikely to change soon. And there are a number of Range construction use cases where the ability to define a new Range in terms of Cuts would be a useful public operation to support. One common use case has to do with Nullable (or Optional, as you will) bounds. It's often the case that APIs, particularly external APIs like RESTful interfaces, might provide either or none of the endpoints of a range, particularly as part of a filtering request from a client. It's difficult to use the existing bounds-based static factories on Range to construct an appropriate Range easily because they (understandably) don't accept null bounds. So there's typically a lot of branching code to call the correct static factory such as .all(), .atLeast(), .atMost(), or closed() depending on whether none, either, or both of the bounds have been specified by a client

But, if code that wanted to use Guava could use Cuts directly, it could express the range constraints it wants much more directly, such as:

```
// Assume lowBound and highBound are Optional<T extends Comparable<T>>
final Cut<T> lowCut = lowBound.isPresent() ? Cut.<T>belowValue(lowBound.get()) : Cut.<T>belowAll();
final Cut<T> highCut = highBound.isPresent() ? Cut.<T>aboveValue(highBound.get()) : Cut.<T>aboveAll();
return new Range<T>(lowCut, highCut);
```

Without the ability to express the range conditions a bit more abstractly, code like that above leads to a lot of branching code to determine the correct static factory to invoke on Range.

If Cut is not the abstraction to expose publicly, maybe there's some other compact solution to this (at least in my experience) common use case of Optional / Nullable bounds?
 Thanks, @lowasser -- your alternative may help in a number of cases I've run into. I'll close this issue based on the quick replies.
  Toss this code block in a test class somewhere with appropriate imports.

```
static class Foo {
    int value;
    boolean fieldThatEqualsDoesNotUse;

    Foo(int i, boolean b) {
        value = i;
        fieldThatEqualsDoesNotUse = b;
    }

    public int hashCode() {
        return Objects.hashCode(value);
    }

    public boolean equals(Object o) {
        if (o instanceof Foo) {
            return value == ((Foo) o).value;
        }
        return false;
    }
}

@Test
public void test() {
    Foo f1 = new Foo(1, false);
    Foo f2 = new Foo(2, true);
    Foo f3 = new Foo(1, true);

    Set<Foo> s1 = ImmutableSet.of(f1, f2);

    // filter removes f1, leaving only f2
    Set<Foo> filtered = Sets.filter(s1,
            new Predicate<Foo>() {
        public boolean apply(Foo foo) {
            return foo.fieldThatEqualsDoesNotUse;
        }
    });

    assert !filtered.contains(f3);
}
```

The assert fails.

`f3.equals(f1)` is true, so a `.contains(f3)` check on the unfiltered set passes. This is correct. `f3` also passes the filter's predicate. These two facts combine in the current implementation of `FilteredCollection.contains()` to say that the filtered set contains `f3`, which is not correct.
  ### Problem:

Very small double values break the RateLimiter resulting in it allowing many more permits than it should. The tests below are similar to the ones in com.google.common.util.concurrent.RateLimiterTest but do not use a stopwatch. 
### Test Case 1: Create with limit of Double.MIN_VALUE

```
    RateLimiter r = RateLimiter.create(Double.MIN_VALUE);
    assertTrue("Unable to acquire initial permit", r.tryAcquire());
    assertFalse("Capable of acquiring an additional permit", r.tryAcquire());
    Thread.sleep(5000);
    assertFalse("Capable of acquiring an additional permit after sleeping", r.tryAcquire());
```

> Fails the second assertion ("Capable of acquiring an additional permit")
### Test Case 2: Create with limit of .0001

```
    RateLimiter r = RateLimiter.create(.0001);
    assertTrue("Unable to acquire initial permit", r.tryAcquire());
    assertFalse("Capable of acquiring an additional permit", r.tryAcquire());
    Thread.sleep(5000);
    assertFalse("Capable of acquiring an additional permit after sleeping", r.tryAcquire());
```

> Succeeds
### Test Case 3: Create with limit of 1E-13

```
    RateLimiter r = RateLimiter.create(0.0000000000001);
    assertTrue("Unable to acquire initial permit", r.tryAcquire());
    assertFalse("Capable of acquiring an additional permit", r.tryAcquire());
    Thread.sleep(5000);
    assertFalse("Capable of acquiring an additional permit after sleeping", r.tryAcquire());
```

> Fails the second assertion ("Capable of acquiring an additional permit")
 Hi,

I do not know if this is correct way to contribute but I added a test case that shows RateLimiter works even for small values. I also sent a PR for that. 

Regards,
Bahadir
  While using the SimpleStatsCounter class in the com.google.common.cache package, we found that it is not thread-safe as documented. As a simple example, we can have one thread invoking recordLoadSuccess with a non-zero value. It executes loadSuccessCount.increment() and before it can execute totalLoadTime.add(loadTime), if another threads calls a snapshot on the cache, it will return an inconsistent state (where the successCount and loadtime are inconsistent). 

Should the methods be synchronized in this class? If not, may be the documentation can be fixed to remove claims on thread-safety? 
 The challenge is that multiple fields have to be updated together, which cannot be done efficiently. The locking approach won't scale. Creating a new struct (composite update) for a CAS update won't scale due to GC pressure and CAS storms.

Perhaps the only way to implement it efficiently would be thread-local StatsCounters (mimic memcached's approach). The thread would synchronize and update, and the aggregator would synchronize to read. This would allow consistent read/writes with low overhead as the locks are not contended on. However, Java's `ThreadLocal` is not very efficient so a variant of `Striped64` would be required (e.g. see Caffeine's `StripedBuffer`).

Given that the stats are often consumed by a reporter which itself doesn't guarantee atomic updates of composite metrics, this is a moot point. If the stats are being captured as monotonically increasing over the lifetime of the cache, then an inconsistent view has marginal impact.

The current implementation is thread safe, but not atomic. I think that's a reasonable trade-off.
 I agree that it is probably an overkill to synchronise to ensure thread-safe behaviour. 

But the class is still not thread-safe as Ben suggests above. It is neither atomic nor thread-safe according to the definition of thread-safety by Brian Goetz ("Java Concurrency in Practice"), 

> Furthermore, for a class to be thread-safe, it must continue to behave correctly, in the sense described above, when accessed from multiple threads, regardless of the scheduling or interleaving of the execution of those threads by the runtime environment, without any additional synchronization on the part of the calling code. The effect is that operations on a thread-safe object will appear to all threads to occur in a fixed, globally consistent order.

We all seem to agree that there won't be a globally consistent order here. Therefore, the documentation probably can be updated to remove the thread-safe guarantee and clarify the intended semantics of the SimpleStatsCounter (similar to AbstractCache.cacheStats()). 
 A slightly looser definition is what is used in practice. The term is typically meant as whether the class functions correctly when operated on by multiple threads. What "correctly" means is defined by the API contract. This more liberal definition is used by Wikipedia,

> A piece of code is thread-safe if it only manipulates shared data structures in a manner that guarantees safe execution by multiple threads at the same time.

`SimpleStatsCounter` is thread-safe in terms of the contract's requirements, which includes the necessary caveats. If those were missing or not honored, then the races would break the thread safety requirements. The requirements is monotonically increasing counts over the lifetime of the cache, with an inconsistent snapshot view of those counts. If counters were lossy (e.g. non-volatile updates) then it couldn't honor its contract when operated on by multiple threads.

It does not perform each method operation atomically, which would be a stronger requirement. Of the options, only the approach I'd favor is experimenting with a `Striped64` version. The impact might even be less costly than the current approach by reducing the number of CAS operations (simply spin wait locking of the struct). If there is interest then I can benchmark that approach.

Adding more documentation can't hurt, though.
 @lowasser 
Yes, but instead of one per counter there could be one per composite. Then the composite is `synchonized` on to read or write to it. The aggregation would be like `sum`. Each composite would be updated as a single step so the inconsistency wouldn't be visible. Due to the low collision rate, `synchronized` would not be contended and use spin locking instead of a full lock.

[StripedBuffer](https://github.com/ben-manes/caffeine/blob/master/caffeine/src/main/java/com/github/benmanes/caffeine/cache/StripedBuffer.java) already adapts `Striped64` to custom objects. In that case a lock-free ring buffer. A variant could be used to operate on composite counters.
 A [quick hack](https://github.com/ben-manes/caffeine/commit/4c7ed823b425d8fffc13b332dd4d351cef81f843) showing what this would look like. The only missing portion is to have custom bi-functions to avoid creating a new capturing function on every call (avoid GC). Other than that making it pretty and benchmarking would be necessary.
 An updated [example](https://github.com/ben-manes/caffeine/commit/4bcc696ebf3154a75c1bcc87e7502b352b74c91b) that is cleaned up a bit. Using a simple JMH benchmark of 8 threads incrementing the counts and 1 thread reading we get the following on a 4-core / 8HT laptop.

```
StatsBenchmark.stats:record        atomic  thrpt   10  171937150.141 ops/s
StatsBenchmark.stats:snapshot      atomic  thrpt   10     109742.654 ops/s
StatsBenchmark.stats:record    concurrent  thrpt   10  152614121.235 ops/s
StatsBenchmark.stats:snapshot  concurrent  thrpt   10    3928269.479 ops/s
```

Not surprisingly the writes are a little faster by combining the operations but the read performance is reduced. That's because writers now contend with reads, so the impact is observable. Of course in practice counters won't be heavily contended on and the difference won't matter.

So that's how this could be done. Its a fun exercise, but probably not worth the effort.
 Oh, I forgot to add padding to avoid false sharing. A big improvement, but reads are still pretty poor. Updated [commit](https://github.com/ben-manes/caffeine/commit/ab0da7e09b96ad92c0c43131f4a88b7245b2edcc).

```
StatsBenchmark.stats:record        atomic  thrpt   10  215337580.177 ops/s
StatsBenchmark.stats:snapshot      atomic  thrpt   10     182681.894 ops/s
StatsBenchmark.stats:record    concurrent  thrpt   10  156842262.685 ops/s
StatsBenchmark.stats:snapshot  concurrent  thrpt   10    4037267.672 ops/s
```
  Hi,

The following test fails on the last line.
First item is not evicted.
It fails for version 18 and 19 rc2.

```
         Cache c = CacheBuilder.newBuilder()
                .concurrencyLevel(4)
                .maximumSize(1000)
                .expireAfterAccess(10000L, TimeUnit.SECONDS)
                .build();

        for (int i = 0; i < 1000;  ++i) {
            c.put(i, "v" + i);
        }
        assertNotNull(c.getIfPresent(0));
        for (int i = 1000; i < 1003;  ++i) {
            c.put(i, "v " + i);
        }
        assertNull(c.getIfPresent(1));
        assertNull(c.getIfPresent(2));
        c.cleanUp();
        assertNull("BB " + c.getIfPresent(0), c.getIfPresent(0));
```
 `getIfPresent(0)` is an access, so that entry moves from the least recently used status to the most recently used. If instead `asMap().containsKey(0)` is used then the tests passes. That's a fluke, as @lowasser explains. It can be deterministic if setting `concurrencyLevel(1)`, at which point strict LRU is enforced. Guava uses that trick for its unit tests, but it is not part of the API contract.
  If I want to load a resource I have found by classpath scanning with `ClassPath`, I need to use `Resources.asByteSource(resourceInfo.url())`. This is only little code, but hard to discover because it uses a third class `Resources` which is neither related to what I have (`ResourceInfo`) nor what I want (`ByteSource`). I also need to remember that I should go via the URL and that I cannot use `ResourceInfo.getResourceName()`.

A direct method to get a `ByteSource` from a `ResourceInfo` would make this easier. Alternatively, this should be documented at least.
  Hi folks

as we can see the methods of Cache interface, most of them are generic except `getIfPresent(Object key)`:

``` java
public interface Cache<K, V> {
...
  @Nullable
  V getIfPresent(Object key);

  V get(K key, Callable<? extends V> valueLoader) throws ExecutionException;
...
  void put(K key, V value);
...
```

is it intended? why not `V getIfPresent(K key)` to be consistent?

thanks
 你在说什么 XD

2015-11-16 14:12 GMT+08:00 Nick Tan notifications@github.com:

> Hi folks
> 
> as we can see the methods of Cache interface, most of them are generic
> except getIfPresent(Object key):
> 
> public interface Cache<K, V> {...
>   @Nullable
>   V getIfPresent(Object key);
> 
>   V get(K key, Callable<? extends V> valueLoader) throws ExecutionException;...
>   void put(K key, V value);...
> 
> is it intended? why not V getIfPresent(K key) to be consistent?
> 
> thanks
> 
> —
> Reply to this email directly or view it on GitHub
> https://github.com/google/guava/issues/2227.

## 

_达则兼济天下 穷则独善其身_
 It's the [robustness principle](https://en.wikipedia.org/wiki/Robustness_principle). Consider the following case:

```
interface Foo { }
interface Bar { }
class Key implements Foo, Bar { }

Key key = new Key();
Foo foo = key;
Bar bar = key;

Cache<Foo,String> cache = ...
cache.put(foo, "key");
String str = cache.getIfPresent(bar);
assertNotNull(str);
```

It's certain that I can retrieve `"key"` using `foo` as key. But since `foo == bar`, why shouldn't I be able to retrieve `"key"` using `bar` as key?
  **tl;dr:** A Cuckoo Filter provides similar functionality to a Bloom Filter with lower hashing overhead and deletion support.

**Add:** `public interface ProbablisticFilter`
**Add:** `public class CuckooFilter implements ProbablisticFilter`
**Modify:** `public class BloomFilter` **`implements ProbablisticFilter`**

The Cuckoo Filter is described in this paper: [Cuckoo Filter: Practically Better Than Bloom](https://www.cs.cmu.edu/~dga/papers/cuckoo-conext2014.pdf). Quoting from the abstract:

> We propose a new data structure called the cuckoo filter that can replace Bloom filters for approximate set membership tests. Cuckoo filters support adding and removing items dynamically while achieving even higher performance than Bloom filters. For applications that store many items and target moderately low false positive rates, cuckoo filters have lower space overhead than space-optimized Bloom filters. Our experimental results also show that cuckoo filters outperform previous data structures that extend Bloom filters to support deletions substantially in both time and space.

Possbile Interface:

``` java
public interface ProbablisticFilter<T> {
    boolean mightContain(T object);
    boolean put(T object);
    long size(); // cardinality
    long capacity(); // or expectedInsertions()
    double expectedFpp();
}
```

We can contribute an implementation that follows the norms of the `BloomFilter` design if there's interest.

@bdupras, @beala

/cc @binfan999 @apc999 @dave-andersen @mkaminsky & Michael Mitzenmacher (couldn't find his GitHub username)
 A casual read, this looks similar to [TinySet](http://www.cs.technion.ac.il/users/wwwb/cgi-bin/tr-get.cgi/2015/CS/CS-2015-03.pdf) and [TinyTable](http://www.cs.technion.ac.il/users/wwwb/cgi-bin/tr-get.cgi/2015/CS/CS-2015-04.pdf).
 @bdupras thinks for ping me on this issue. I will be able to help if there is anything needed from my side.  Question here, I guess for `CuckooFilter`, it will implement `delete` (or similar) as that is the differentiator of CuckooFilter from BloomFilter, right? 
 @ben-manes I think cuckoo filter shares the similar idea of TinySet in the way they both store fingerprints in a hash table for approximate set-membership tests (like BloomFilter). One key difference is TinySet is more like using traditional open-addressing hashtable, while cuckoo filter is built based on partial-key cuckoo hashing (see more in our paper  Cuckoo Filter: Practically Better Than Bloom). My very biased view is, in the context of achieving really high-space efficiency and also good performance, partial-key cuckoo hashing is very easy to understand and implement correctly. :)
 > ... `CuckooFilter`, it will implement `delete` (or similar) 

Yes, absolutely. Perhaps as a separate interface, e.g. ...

``` java
public interface DeletableFilter<T> {
    boolean delete(T object);
}
```
 @apc999 I'll see if I can get our first attempt at an implementation out to a place where you can have a look. Nicely written paper, by the way - very easy to understand.

A few things of note about our implementation...

We chose a different strategy for calculating the alternate index. The paper's method using `xor` has a side-effect of requiring the number of buckets (B) to be a power of 2. Our implementation calculates an offset from the current index that is always odd, and then applies that offset positive or negative depending on whether the current index is even or odd, wrapping around the ends of the bucket array as necessary. This requires only that the number of buckets be even, giving us more flexibility in the memory footprint than power of 2.

We also implemented rollback on insert such that if we exhaust the max_kicks, we rollback and leave the filter in a consistent state before throwing an insertion error.

@beala - did I forget anything?
 Hi @apc999! Thanks for offering your help and thanks for your paper! It's been a big win for us.

Two other additions:
1. Our fingerprint is the first non-zero string of bits in the hash of the key. If the hash is 0, the fingerprint is 1. Without this, it's ambiguous if a cell containing 0 is empty, or contains a fingerprint of 0.
2. We created a "growable cuckoo filter" which contains a list of cuckoo filters. If a cuckoo filter is full, we allocate another filter and insert into that. The rollback on insert makes this possible (otherwise an insert failure drops data).
 Thanks @kevinb9n. We'd certainly welcome an interface to implement against. Would you be interested in us providing a pull request to do that?

@kluever, we noticed in issue #1518 that you requested deletion support from the Bloom Filter. Are you still interested having a deletable filter implementation?
  We are using the cache to cache some textures in our game, lets say you have a cache with a max size of 10 textures, if you tried to you use the cache to cache 11 textures, the cache becomes useless because it will keep evicting randomly old textures, which cost us rebuilding the texture, if the cache respect the size, then it will just keep the 10 textures in cache and we only need to reload/rebuild texture-11.   This way the cache will save us 95% of the cost of build textures1-10, now it simply like you don't have a cache !

Am I missing something ?

if (cache.isFull()){
cacheloader.load
//don't add it to the cache
}else{
cacheloader.load
//add to the cache
}
 Guava uses the least-recently-used (LRU) policy, which evicts from the cache the entry that was last accessed the furthest in the past. This means that new entries are given priority over older ones by predicting that there will be a burst of new activity. In a game when a player enters inside a building, this prediction guesses that the player will stay in doors for a while, so keeping recently viewed content in the cache makes sense. Of course, that prediction may be wrong as the player may more frequently stay outside (least-frequently-used - LFU), so other policies try to find an [optimal balance](https://github.com/ben-manes/caffeine/wiki/Efficiency).

A caveat that may also be causing confusion is that Guava's Caches evict prior to reaching the maximum size threshold. This is a documented implementation quirk, with good arguments on both sides of whether this is preferable. Regardless, the cache will likely stay slightly below the maximum so a small cache (10) will be more affected by this detail.
 Using LRU or LFU are fine as long as you're respecting expireAfterWrite or expireAfterAccess. This is not about a game, it's about showing that if you overshot the size of the cache even by one item then the whole cache will become useless. I wrote some code and I'll share code, but first I'll share the results.

``` java
[Cache max size (9) and trying to load (10) items]
[Default Guava][Total Time:10082][Loading Count:100][Removal Count:91]
[Respect Max Size][Total Time:1907][Loading Count:19][Removal Count:0]
```

This code will simply load 10 items , 10 times, I added some delay (Thread.sleep(100)) to make loading expensive. The code does this through 2 methods and compare the benefits of the cache, the first is the default method (i.e. get(key)), the second method I will check  if the cache is full and simply skip loading the item from the cache (or adding it to cache) and as you see the default method made the cache useless (100% loading) also notice the total time in the second method (20%).

# 

# Example Code

``` java
import java.util.concurrent.TimeUnit;
import com.google.common.cache.CacheBuilder;
import com.google.common.cache.CacheLoader;
import com.google.common.cache.LoadingCache;
import com.google.common.cache.RemovalListener;
import com.google.common.cache.RemovalNotification;

public class GuavaTest {
    public final int MAX_CACHE_SIZE = 9;
    public int removalCount = 0;
    public int loadingCount = 0;
    private RemovalListener<String, String> removalListener = new RemovalListener<String, String>() {

        @Override
        public void onRemoval(RemovalNotification<String, String> notification) {
            // System.out.println("Removal [Count:" + removalCount + "][" +
            // notification.getKey() + ":" + notification.getValue() + "] ");
            removalCount++;
        }
    };

    LoadingCache<String, String> uselessCache = null;

    public void newCache() {
        uselessCache = CacheBuilder.newBuilder().maximumSize(MAX_CACHE_SIZE).expireAfterWrite(10, TimeUnit.SECONDS).removalListener(removalListener).build(new CacheLoader<String, String>() {
            public String load(String key) {
                return doLoad(key);
            }
        });
    }

    public String doLoad(String key) {
        // loading expensive item
        String value = key + "-LOADED";
        try {
            Thread.sleep(100);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        //System.out.println("Loading [Count:" + loadingCount + "][" + key + ":" + value + "] ");
        loadingCount++;
        return value;
    }

    public String get(String key, boolean defaultGuava) {
        String value = null;
        if (defaultGuava) {
            value = uselessCache.getUnchecked(key);
        } else {
            value = uselessCache.getIfPresent(key);
            if (value == null) {
                if (uselessCache.size() >= MAX_CACHE_SIZE) {
                    value = doLoad(key);
                } else {
                    value = uselessCache.getUnchecked(key);
                }
            }
        }

        return value;
    }

    public static void main(String[] args) {
        GuavaTest gt = new GuavaTest();
        gt.newCache();
        System.out.println("[Cache max size (9) and trying to load (10) items]");
        long lastTime = System.currentTimeMillis();
        for (int l = 0; l < 10; l++) {
            for (int i = 0; i < 10; i++) {
                String item = gt.get("" + i, true);
                // System.out.println("Got item:" + item);
            }
        }
        long totalTime = System.currentTimeMillis() - lastTime;
        System.out.println("[Default Guava][Total Time:" + totalTime + "][Loading Count:" + gt.loadingCount + "][Removal Count:" + gt.removalCount + "]");
        gt.loadingCount = 0;
        gt.removalCount = 0;
        gt.newCache();
        lastTime = System.currentTimeMillis();
        for (int l = 0; l < 10; l++) {
            for (int i = 0; i < 10; i++) {
                String item = gt.get("" + i, false);
                // System.out.println("Got item:" + item);
            }
        }
        totalTime = System.currentTimeMillis() - lastTime;
        System.out.println("[Respect Max Size][Total Time:" + totalTime + "][Loading Count:" + gt.loadingCount + "][Removal Count:" + gt.removalCount + "]");
    }
}
```
 @ben-manes thanks for the educated link (I liked Window TinyLfu)
@lowasser 
I did the your modification (Random access) and you're right about the 0.9 hit rate, but my method also provides the same results in both cases. There are many use cases where you would need to cycle through items, for examples; files in a directory or GUI children, etc. 
 If you compare your example to a different policy, like W-TinyLFU, then the hit rates are much better. As @lowasser said, this is because you're access patterns are very unfriendly for LRU so it makes the wrong predictions. Your `Respect Max Size` is the optimal hit rate since you know the access pattern is uniformly a full loop so the manual load will be best to evict / not admit. Adding Caffeine I get,

```
[Cache max size (9) and trying to load (10) items]
[Default Caffeine][Total Time:3109][Loading Count:30][Removal Count:21]
[Default Guava][Total Time:10082][Loading Count:100][Removal Count:91]
[Respect Max Size][Total Time:1967][Loading Count:19][Removal Count:0]
```
 Also, your case of not admitting a new entry is better matched by `TinyLFU` (which doesn't have an admission window). Then the results are,

```
[TinyLfu][Total Time:2278][Loading Count:22][Removal Count:13]
```
  I regularly use `ImmutableMap.of(k,v)` to make up for the lack of a Map literal in Java as I find the syntax to be cleaner than initialising a map and putting stuff into it (and immutability is an added bonus). Since my use of this class is for brevity, I like to statically import the method as the immutability is not part of my intent. However the method name `of` does not read well as it does not indicate that I’m building a map. As a result I have been using a [wrapper class](https://gist.github.com/mrmanc/8a290b9cf4d59964e8e0) to achieve the same result:

`assertThat(result).isEqualTo(mapOf("version","61d85376"));`

Each time I can’t help wondering whether the community would embrace something like this in the original code, so I thought I’d raise an issue to discuss this :smile:

An alternative would be to use `ImmutableMap.builder().put(key, value).build()`, and that would be nice if `ImmutableMap.builder()` was `ImmutableMap.map()` but I prefer the one-less-hop method I’m using.

Of course there might be a much nicer option that I’ve completely missed, and if that is the case I look forward to finding out!
 I believe this is a duplicate of #1062.
 @lowasser That's great to hear! I thought the dropping of literals in Java 8 was the end of it.

@ogregoire Thanks, you're absolutely right; this is a duplicate of #1062, which didn't come up in my searches. Closing this issue. 
  A `ComparisonTester` that is similar to `EqualsTester` but tests a `compareTo` method or a `Comparator` would be great to have.

Possible interface:

```
public class ComparisonTester {
   public ComparisonTester addEquivalenceGroup(Object... equivalenceGroup);
   public ComparisonTester testCompareTo();
   public ComparisonTester testComparator(Comparator<?> comparator);
}
```

The expected order of objects could be simply defined by the order of calls to `addEquivalenceGroup`.

The class would test that objects within each equivalence group are deemed equivalent, that the order of equivalence groups matches the actual ordering, that `compareTo` is reflexive etc.

Testing `compareTo` of `Comparable` classes could then also be added to `ClassSanityTester` and `AbstractPackageSanityTests`.
 Just had one of our Oracle colleagues ask if we had something like this.  I guess a lot of folks who don't use ComparisonChain end up implementing contract-violating compareTo methods, and they were hoping to recommend something like guava-testlib to help them.  
 I recently went over all `Comparator`s and all `compareTo` implementations in our code base, and indeed the majority of those that did not use ComparisonChain were wrong. So open-sourcing your ComparisonTester would be really appreciated.
  For transformative sources and sink, it's useful to keep track of the context the stream.

Consider the use case: I want to read a ciphered, gzipped text file. This is done using the following code:

```
File file = ... ;
String text = Gzip.unzip(Cipher.uncipher(Files.asByteSource(file), cipher)).asCharSource(UTF_8);
```

It's rather straightforward. If I want to rewrite the file, it's easy, I just do the opposite :

```
Gzip.zip(Cipher.cipher(Files.asByteSource(file), cipher)).asCharSource(UTF_8).write(modifiedText);
```

First, I have to keep the information about the file, the cipher and the encoding myself. It's not really good.

Second, not everything is that straightforward. Sometimes, decisions at runtime, based on the content itself (various formats, encoding). This happens directly in the `{Byte,Char}Source` and has to be preserved when writing into the `{Byte,Char}Sink`. Here comes the context.

Each level of writing should have its own context, but that context should also be publicly accessible so that the information can be retrieved by the user when actually using the streams.

A way I thought about implementing this is maybe to have chained streams containing their own context and which can return the final `{Byte,Char}Source` and its corresponding `{Byte,Char}Sink`.

For instance:

| Level | ByteSource | Stream | ByteSink |
| --- | --- | --- | --- |
| File | FileByteSource | FileStream (holds path) | FileByteSink |
| byte <-> char | ByteToCharSource | ToCharStream (holds charset) | ByteToCharSink |
| gzip | GzipSource | GzipStream (holds zip level) | GzipSink |

Example of usage:

```
CharStream stream = Gzip.wrap(Cipher.wrap(Files.asByteStream(file), cipher)).asCharStream(UTF_8);
CharSource usableSource = stream.asSource();
CharSink usableSink = stream.asSink();

Charset charset = usableSource.getContext(ByteToCharContext.class).getCharset();
File file = usableSink.getContext(FileContext.class).getFile();
```
 The main disadvantage if I write a single wrapper is that I have to write all the wrappers. Let's imagine I have the following:

```
File file = ... ;
ContextualByteSource byteSource = ContextualFiles.asByteSource(file);
ContextualCharSource charSource = byteSource.asCharSource(UTF_8);
```

What you're saying is that I'd have to totally rewrite the API to support this.

This is why I requested it in the first place. Because I think it's a win for the API (keeping the context is not so rare) and because implementing it myself, while entirely possible, is basically writing the whole Byte/CharSource/Sink api (including relevant factory methods) but with an extra method.
  https://github.com/google/guava/wiki/PreconditionsExplained

The first link seems broken:
([How to do this easily in Eclipse.](http://piotrjagielski.com/blog/working-with-static-imports-in-eclipse/)) 
 I agree, it doesn't really have any added value.
Thanks! :-)
  I don't think we should care about allocations/speed in unit tests.
 Seems like it would be prudent to cut Truth 1.0 first?
Is there a refaster plugin to migrate?
  for example:
 @Test
    public void test05() throws Exception {
        ListeningScheduledExecutorService executor = MoreExecutors.listeningDecorator(Executors.newSingleThreadScheduledExecutor());
        ListenableScheduledFuture<Long> future = executor.schedule(() -> {
            long now = System.currentTimeMillis();
            System.out.println(now);
            return now;
        }, 1, TimeUnit.SECONDS);
//        Futures.addCallback(future, new FutureCallback<Long>() {
//            @Override
//            public void onSuccess(Long result) {
//                System.out.println(result);
//            }
//
//            @Override
//            public void onFailure(Throwable t) {
//                t.printStackTrace(System.err);
//            }
//        });
        Thread.sleep(10 \* 1000);
    }
 guava version: 18.0
java version: 1.8.0_40
 schedule only runs the task once, maybe you want scheduleAtFixedRate or scheduleWithDelay?
    It's nice to have a function to test whether a particular string is in which case format.

In a tool application, a string will provided by external code. And if the value matches some known case format, It will then be normalised to a standard format. e.g. if input matches `UPPER_UNDERSCORE` and `LOWER_UNDERSCORE` will both converted to `LOWER_CAMEL`.

Some ideas illustrated as below:

```
/**
 * Tests which CaseFormat the <code>value</code> is.
 *
 * @param value
 * @return the case format for the value if found. <code>null</code> if no matches found.
 */
@Nullable
public static CaseFormat test(@Nonnull String value) {
    // in worst case, may need to enumerate all format
    // some quick test, like first detect underscore then check cases etc may help.
    return CaseFormat.Test;
}

/**
 * Tests whether <code>value</code> is in this case format.
 *
 * @param value
 * @return <code>true</code> if <code>value</code> is matching case format.
 */
abstract boolean matches(@Nonnull String value);
```
 Is `"whatever"` `LOWER_HYPHEN` or `LOWER_CAMEL`? Also it could be `LOWER_UNDERSCORE`.
 The case I'm facing now is:
1. first, detect which case format the incoming identifier is. (This is what's requested here)
2. if it's known case format, but not target format, then convert it into target format. (this is existing feature)
 I was just trying to highlight that CaseFormats could be ambiguous. Your new method `test` might return with `LOWER_HYPHEN`, `LOWER_CAMEL` or `LOWER_UNDERSCORE` for the input `"whatever"`.
 Ah, I get you now. Sorry for mis-understood your comments in first place.

Regarding the particular case `whatever`, since there is no `HYPHEN` and `UNDERSCORE`, then it should be returning `LOWER_CAMEL`. I do agree that there could be ambiguous, say it can return `LOWER_ALL` as well, if such a case format existing.

On the other hand, at least for a particular type, it can have a `matches` function, as drafted in my original post. In this case, my tool can enumerate supported types one by one, and naturally, there is an ordering as "one-by-one" goes in app code.

Also, even it's un-deterministic for static function included in my original post, e.g.`LOWER_CAMEL` and `LOWER_ALL` case, it either can return first one in natural order (un-deterministic), e.g. definition sequence of enum, or it may return a list of matching (deterministic). I'm not sure the other scenarios, but for my tool, either way works. Since requirement for my case is to find what's the current format, and if it's a known format, then convert it to a _normalised_ format.
 Thanks @kevinb9n 

I may not open this issue. But I would like to provide more details about my case before leave this ticket rest in peace:

The current `CaseFormat` is from Known to Known conversion. My problem is from Unknown to Known.  I have a data dictionary in XML format, and my tool generates code for Java and .Net. And Id inside the XML file, may follow Java convention (camel), or .Net (First letter capital), or `lower_lower`, or `UPPER_UPPER`. I need this feature to first tell me which known format it is, and if it's supported format, then generates Java/ .Net format id, as well as constant definition. 

What I can see it could probably be useful for IDE code formatter/ refactoring tools, but again, I'm not doing any tools like this before, it may not be the case. And even these are valid cases, I am not sure whether it qualifies the criteria. Maybe not. 

On the other hand, I cannot find any utility tools satisfy this need either. And that's the reason why I'm asking here.
 +1 - similar use case to dopsun

Alternatively what we are asking is to convert to a given case, no matter what the input format is.

In the reasoning you have given above, it really does not matter as long as we are able to go from a unknown case to a known case.  for example if "whatever" was provided and asked to convert to UPPER_CAMEL, it would return "Whatever" while for "whatEver" or "what_ever" will return "WhatEver".. 
 Hello,

In a similar case I have to validate if a given name for a location is camelCase or CamelCase and then convert it to LOWER_UNDERSCORE.

So I need to compare the return value of newLocation.getName() against something for identifying which case format is it, and then it is possible to convert from that format to the required LOWER_UNDERSCORE

Thanks a lot!!
 +5

I don't really care what the current case format for a given incoming string is, but whatever it is, I want to convert it to a specific case format. I'm not sure what systems could make use of finding out what format a string currently is in, but I would think that there's a not-small class of software that would be interested in taking in a string from some external, possibly untrusted, source and converting it to a specific case format.

We have a system that uses a case format for different fields on a variety of data for a variety of scenarios (usually it's display scenarios we care about), and we are not always in control of the input.

The alternative is to run through a bunch of guesses on the source format and see which conversion to a target format yields an identical string. Only then can the conversion be made.
   I signed it!
 Thanks for explanation. I was looking in dictionary under 'sporting' and I haven't found anything. Apparently under 'sport' there is something that may fit.
  Time limited waiting is performed frequently on `Future` and this method overloads `Futures.getUnchecked()` method with one that accepts timeout value. 
 I signed it!
 I signed it!

On Wed, 28 Oct 2015, 6:05 AM googlebot notifications@github.com wrote:

> CLAs look good, thanks!
> 
> —
> Reply to this email directly or view it on GitHub
> https://github.com/google/guava/pull/2210#issuecomment-151611921.
  To simplify the process of collecting cache stats using e.g. _io.dropwizard.metrics_, `CacheBuilder.recordStats()` should have an overloaded version that accepts a StatsCounter Supplier.

See PR: https://github.com/google/guava/pull/2208
 The concern with this is that it allows making foreign calls in critical sections. The code would need to be audited to ensure that an exception thrown by a custom implementation does not leave the cache in an invalid state. A fast but ugly solution would be to wrap a custom `StatsCounter` to consume and log any throwables. There's also the problem of slow foreign calls in critical sections, e.g. network calls, which can't be worked around. So the main task involved is ensuring that the cache is tolerant to custom implementations behaving poorly.
 I agree to some point. Since it's an easy task to wrap a custom `StatsCounter` in a _guarded StatsCounter_ it's arguable something that should be done. **The PR is now updated with a quick take on this**.

The issue with slow foreign calls could be adressed by being crystal clear about this in the doc. I believe it's a bit diminishing to think that that shouldn't be enough ;-)

> No heavy work should be done in your custom `StatsCounter` this might affect the performance of the cache in a negative and unpredictable way!
 Yep, this is now pretty much what I had in mind and considered doing in my [rewrite](https://github.com/ben-manes/caffeine). However I'd still like to hear feedback from @kevinb9n and friends, because I have a hard time justifying that this customization is useful in practice. I think that's why its been left in a state where it seems intended (by public interface), but not currently provided.

The main reason is to integrate with a framework like JMX, [Dropwizard Metrics](http://metrics.dropwizard.io/), or similar. Most of those approaches support both push and pull based accumulation, so integration is only slightly more painful by pulling the `CacheStats` and diffing if necessary. The other argument I've seen has been to clear the stats by resetting the values to zero. However that is a broken approach for many reasons, and is best done using a snapshot as a baseline to diff from. That leaves the only remaining justification being lighter weight recording, e.g. thread local or non-atomic counters. That's never brought up and, while ugly, can be worked around via decorators.

So I'm neutral and would like to hear what the Guava team thinks.

P.S. Dupe of #1685
 AFAIK, having this is the only way to collect e.g. success and fail load times (total load time is supported in CacheStats though). Getting rates/histograms directly without the need of a "cache stats collecting worker" is also compelling.

Without having a more complex _"cache stats worker"_ this is what I can come up with using `Cache.stats()`:

``` java
//registering gauges...
Gauge<Long> hitCountGauge = () -> loadingCache.stats().hitCount();
Gauge<Long> missCountGauge = () -> loadingCache.stats().missCount();
Gauge<Long> loadCountGauge = () -> loadingCache.stats().loadCount();
Gauge<Long> evictCountGauge = () -> loadingCache.stats().evictionCount();
Gauge<Long> requestCountGauge = () -> loadingCache.stats().requestCount();

metricRegistry.register(cacheName + ".hit_count", hitCountGauge);
metricRegistry.register(cacheName + ".miss_count", missCountGauge);
metricRegistry.register(cacheName + ".load_count", loadCountGauge);
metricRegistry.register(cacheName + ".evict_count", evictCountGauge);
metricRegistry.register(cacheName + ".request_count", requestCountGauge);
```

I even end up with a situation where `Cache.stats()` (with all its stats aggregation etc) needs to be called for every gauge.

By having a _custom StatsCounter_, more data can be harvested, and it will be more effective. Using e.g. _Dropwizard Metrics_, you will get things like load time histograms etc right "out of the box":

``` java
public static class MetricsStatsCounter implements StatsCounter {
    private final Meter hitsMeter;
    private final Meter missesMeter;
    private final Timer loadSuccessTimer;
    private final Timer loadErrorTimer;
    private final Meter evictionMeter;

    public MetricsStatsCounter(String metricsPrefix, MetricRegistry registry) {
        this.hitsMeter = registry.meter(metricsPrefix + "." + "hits");
        this.missesMeter = registry.meter(metricsPrefix + "." + "misses");
        this.loadSuccessTimer = registry.timer(metricsPrefix + "." + "load.success");
        this.loadErrorTimer = registry.timer(metricsPrefix + "." + "load.error");
        this.evictionMeter = registry.meter(metricsPrefix + "." + "eviction");
    }

    @Override
    public void recordHits(final int count) {
        hitsMeter.mark(count);
    }

    @Override
    public void recordMisses(final int count) {
        missesMeter.mark(count);
    }

    @Override
    public void recordLoadSuccess(final long loadTime) {
        loadSuccessTimer.update(loadTime, TimeUnit.MILLISECONDS);
    }

    @Override
    public void recordLoadException(final long loadTime) {
        loadErrorTimer.update(loadTime, TimeUnit.MILLISECONDS);
    }

    @Override
    public void recordEviction() {
        evictionMeter.mark();
    }

    @Override
    public CacheStats snapshot() {
        //since we push stats to a MetricRegistry, we will never pull stats using Cache.stats()...
        throw new UnsupportedOperationException();
    }
}
```

@kevinb9n convinced now? ;-) 
  To simplify the process of collecting cache stats using e.g. _io.dropwizard.metrics_, `CacheBuilder.recordStats()` should have an overloaded version that accepts a StatsCounter Supplier.

> Just read the _guidelines for contributing_ and realized that I should have opened an issue for this instead of going directly to a PR. I do that, but I keep this PR as a reference...
 I signed it!
  The HttpHeaders class contains a listing of known HTTP Header keys. It already contains "X-Forwarded-Proto" (X_FORWARDED_PROTO)... but is missing "X-Forwarded-Port" (suggestion: X_FORWARDED_PORT). 

These values are commonly sent as a pair when using an SSL load ballencer in front of a cluster.  
 X_FORWARDED_PORT is the suggested java name, X-Forwarded-Port has 1.8 million results, [Amazon Elastic Load Balancing](http://docs.aws.amazon.com/ElasticLoadBalancing/latest/DeveloperGuide/x-forwarded-headers.html#x-forwarded-port) seems to use it. 
  FileBackedOutputStream only uses /tmp for creating file backings. I'd like to specify where the files go.

It calls
<code>File temp = File.createTempFile("FileBackedOutputStream", null);</code>

I'm requesting that the constructor for FileBackedOutputStream accept the parameter list to File.createTempFile:
<code>File temp = File.createTempFile(prefix, suffix, directory);</code>

Thanks,
Keshav
 Nice idea, i would suggest adding `File` to constructor parameters list insead of `prefix`, `suffix`, `directory`.
  Replacing multiple spaces and tabs, which separates java tokens, by a
single space, excluding horizontal aligned tokens.
 I signed it!
 Nice, the google-java-format project looks really promising. I'll keep an eye on it. :wink:
Thanks for the information.
  ``` java
support：
Map<K1,V1> ——>Map<K1,V2>

not support：Convert Map Type ???
Map<K1,V1> ——>Map<K2,V2>

You can support in the future？？？

```
 http://commons.apache.org/proper/commons-collections/javadocs/api-3.2.1/org/apache/commons/collections/MapUtils.html#transformedMap(java.util.Map, org.apache.commons.collections.Transformer, org.apache.commons.collections.Transformer)

Sometimes such demand
Such as redis return Map < byte [], byte [] > To Map < String, the String > OR Map < String, Object >...

Hope can support key type conversion
  Guava 19 is currently incompatible to GWT 2.8 because commit https://github.com/google/guava/commit/9e56ef17c335319d21f1f2c454176c9d32687a59 has been reverted in Guava 19 release branch.

Given that GWT 2.8 is around the corner (within a month or so, see https://groups.google.com/forum/#!topic/google-web-toolkit-contributors/lq82Uc7JMIQ) its probably a good idea to create two Guava 19 releases: One that is compatible with 2.6.1/2.7 and one that is compatible with 2.8.

Otherwise GWT people have to wait for Guava 20+ or use SNAPSHOT builds before they can switch to GWT 2.8.
 Oh ok, didn't read that in the notes. Sounds fine to me as long as emphasis is put on "quickly" ;-) People are eagerly awaiting Java8 syntax and I just wanted to avoid that they can not upgrade GWT because of Guava.

Feel free to close this issue. Alternatively I would rewrite the title accordingly for tracking purpose.
  `WrappingExecutorService` seems to be a useful class in of itself. `ForwardingExecutorService` is public, but `WrappingExecutorService` is not for no apparent reason.
 +1000
 Specifically in our case we needed to do copy spring scoped beans properly into 'children' threads - this meant running code before certain things happen in executor. `WrappingExecutorService` worked marvellously, but we had to copypaste it.
 +1
A nice use case would be to create an Android-Espresso Idling resource that would wrap an ExecutorService, like this: https://gist.github.com/yairkukielka/086ef4fb1b30af6bb1522abb83f4daf6

For definition of Idling Resource, see https://developer.android.com/reference/android/support/test/espresso/IdlingResource.html
 In our case, we have in thread-local storage a "trace token" identifier for the current request being processed. We want to have this copied into the thread-local storage of worker threads for the time that those worker threads are handling tasks submitted by the request.
 This is also great for testing task submission ordering without relying on `Thread.sleep`.  Added SuppressWarnings annotation to a used member which is updated using reflection.
 I indeed couldn't find the `@UsedFromReflection` annotation.
Found almost nothing when searching for "UsedFromReflection discussion" using google's search.
@cpovirk, can you share the discussion link? Thanks.
  Added SuppressWarnings annotation to a used member which is updated using reflection
 I signed it!
 Closed because I commited using an unknown user :(
  Fixes #2196.
 oraclejdk7 and openjdk7 builds fail with:

> The log length has exceeded the limit of 4 Megabytes (this usually means that test suite is raising the same exception over and over).
> 
> The build has been terminated.

It doesn't seem to be related to this PR.

oraclejdk8 build completes with:

> Done. Your build exited with 0.

If there's something else I can do, let me know.
 I saw that gwtproject/gwt#9206 seems to be resolved.

Could someone restart following builds, please?
- https://travis-ci.org/google/guava/builds/86643322
- https://travis-ci.org/google/guava/builds/86655829

I'd like to avoid pushing commits just to trigger rebuild.
 The last commit is not related to intersection - I hope you will find it valuable, however. I found that some assertions were too weak.

@cgdecker Thanks for restarting builds!
  Let a < x < b:
- [x].intersection([x]) should return [x], returns [],
- [x].intersection([a..b]) should return [x], returns [],
- [a..b].intersection([x]) should return [x], returns [],
- [a..x].intersection([x..b]) should return [x], returns [].

I'll create a PR in a minute.
 Yes, I use `ContiguousSet.intersection`. I believe it has no users at Google - this bug would have been discovered so long time ago! But... IMO it doesn't mean it should be deprecated and removed. `ContiguousSet.intersection` can be really useful as I'll try to show in a moment. Moreover, people often don't use something because they don't know it exists: `ContiguousSet` seems to be one of the less known classes.

My use case was to count the number of days common to two intervals. I could use `Range` for intersection and then `DiscreteDomain` for distance (or something more, well, domain specific, like `java.time.temporal.ChronoUnit`), but it wouldn't be so... compact. I can't, for instance, intersect two ranges without ensuring that they are connected; or I can, but I must be prepared to catch an exception - so it's either if-else or try-catch.

My code would look like:

```
Range<LocalDate> range1 = Range.closed(...);
Range<LocalDate> range2 = Range.closed(...);
int count;
if (range1.isConnected(range2)) {
    Range<LocalDate> intersection = range1.intersection(range2);
    count = (int) intersection.lowerEndpoint().until(intersection.upperEndpoint(), ChronoUnit.DAYS) + 1;
} else {
    count = 0;
}
```

instead of:

```
ContiguousSet<LocalDate> interval1 = ContiguousSet.create(...);
ContiguousSet<LocalDate> interval2 = ContiguousSet.create(...);
int count = interval1.intersection(interval2).size();
```

(assuming I've created `DiscreteDomain<LocalDate>` already).

Also, I very often use `ContiguousSet` as `Iterable` - it's not just `size` that matters...

`ContiguousSet.intersection` is a tiny, simple method that shouldn't be hard to maintain. There are no alternatives (`Sets.intersection` creates view, etc.). I'd be happy if it stays with us.
  Would this even be a win?  The advantage to code like `return Optional.of(...)` is that Java might scalarize the whole `Optional` instance.
  [ERROR] Failed to execute goal org.apache.maven.plugins:maven-dependency-plugin:2.10:unpack-dependencies (unpack-guava-sources) on project guava-gwt:
Artifact has not been packaged yet. When used on reactor artifact, unpack should be executed after packaging: see MDEP-98. -> [Help 1]
[ERROR]
[ERROR] To see the full stack trace of the errors, re-run Maven with the -e switch.
[ERROR] Re-run Maven using the -X switch to enable full debug logging.
[ERROR]
[ERROR] For more information about the errors and possible solutions, please read the following articles:
[ERROR] [Help 1] http://cwiki.apache.org/confluence/display/MAVEN/MojoExecutionException
[ERROR]
[ERROR] After correcting the problems, you can resume the build with the command
[ERROR]   mvn <goals> -rf :guava-gwt
  FileBackendOutput holds data in either a ByteArrayOutputStream or a File. Both of them provides quick access to content size. Use that knowledge to provide fast sizeIfKnown & size implementations.
 I signed it !

On Thu, Oct 15, 2015 at 10:27 AM, googlebot notifications@github.com
wrote:

> Thanks for your pull request. It looks like this may be your first
> contribution to a Google open source project, in which case you'll need to
> sign a Contributor License Agreement (CLA).
> 
> [image: :memo:] _Please visit https://cla.developers.google.com/
> https://cla.developers.google.com/ to sign._
> 
> Once you've signed, please reply here (e.g. I signed it!) and we'll
> 
> ## verify. Thanks.
> - If you've already signed a CLA, it's possible we don't have your
>   GitHub username or you're using a different email address. Check your
>   existing CLA data https://cla.developers.google.com/clas and verify
>   that your email is set on your git commits
>   https://help.github.com/articles/setting-your-email-in-git/.
> - If you signed the CLA as a corporation, please let us know the
>   company's name.
> 
> —
> Reply to this email directly or view it on GitHub
> https://github.com/google/guava/pull/2190#issuecomment-148316266.
 I signed it with my other email address too.

On Thu, Oct 15, 2015 at 10:27 AM, googlebot notifications@github.com
wrote:

> Thanks for your pull request. It looks like this may be your first
> contribution to a Google open source project, in which case you'll need to
> sign a Contributor License Agreement (CLA).
> 
> [image: :memo:] _Please visit https://cla.developers.google.com/
> https://cla.developers.google.com/ to sign._
> 
> Once you've signed, please reply here (e.g. I signed it!) and we'll
> 
> ## verify. Thanks.
> - If you've already signed a CLA, it's possible we don't have your
>   GitHub username or you're using a different email address. Check your
>   existing CLA data https://cla.developers.google.com/clas and verify
>   that your email is set on your git commits
>   https://help.github.com/articles/setting-your-email-in-git/.
> - If you signed the CLA as a corporation, please let us know the
>   company's name.
> 
> —
> Reply to this email directly or view it on GitHub
> https://github.com/google/guava/pull/2190#issuecomment-148316266.
 `size()` can be optimised to not instantiate an `Optional` internally each time it's called. See the code below for an example of what I mean by this.

``` java
@Override
public long size() throws IOException {
  return file != null ? file.length() : memory.getCount();
}

@Override
public Optional<Long> sizeIfKnown() {
  return Optional.of(size());
}
```
  https://github.com/google/guava/issues/2156
Implementation similar to other synchronized collections.
Copy unit test template from SynchronizedMapTest.
Make Synchronized.SynchronizedMap package protected (VisibleForTesting).
 Lost my previous fork.
Requested Changes implemented in https://github.com/google/guava/pull/2377
 This doesn't seem to be in `com.google.guava:guava:jar:20.0`. Where can it be found? It's not merged into Guava yet @user454322, see https://github.com/google/guava/pull/2377. :)  The `IndexOutOfBoundsException` is not in its correct column (4th row, `checkElementIndex(int index, int size)`)

https://github.com/google/guava/wiki/PreconditionsExplained

The table is correctly formatted in the [old google wiki](https://code.google.com/p/guava-libraries/wiki/PreconditionsExplained).
  update from origin
   @cpovirk, thanks for the explanation!
  I'd like to be able to implement custom ListenableFuture class where I could easily override cancel(boolean) method. The SettableFuture seems to be best fit but unfortunately it's declared final. Removing this restriction makes it much more reusable.
 Thanks for mentioning `interruptTask()`, this is definitely better than overriding full `cancel()` method.

However, I still need both the `cancel()` and `set()` / `setException()` method. I actually think that this is pretty common use case for asynchronous tasks that are finished not by returning from method but after some notification is delivered (e.g. another `ListentableFuture`, completion callback etc.). In such case I need future for which it's possible to set the result and custom method for interrupting the task.

I believe that SettableFuture is best candidate here. Is there any drawback by making it non-final?
 Well, I see the point that with current design it can save some execution time in rather special situations though I can't judge how common they are in guava or the software based on this.

However, as you mentioned - this is mainly about optimizing `get()`, not `cancel()`... I think marking `get()` as final in `TrustedFuture` would make it safer, more readable and clear on purpose and on the other hand wouldn't affect extendability of `TrustedFuture` and as a result the inherited classes would take advantage of those performance optimizations as well :-)

Personally I agree it's not a big deal to inherit it from `AbstractFuture` in exactly the same way how `SettableFuture` is currently implemented. But I don't like I have to reinvent the wheel / duplicate the code. So maybe we can consider introducing another intermediate class `AbstractSettableFuture` and final `SettableFuture`. Although as described above it probably would hardly bring any value from the originally proposed approach.

Additionally, I'm considering implementing a `Future` class where in case of code is already running and cancellation is requested, `get()` and listener processing would be called after `set()`/`setException()` methods are called instead of immediately after invoking `cancel()`. Do you think it would be worth merging into guava or shall I skip the step for this? :-)
 Yes, I'm talking about duplicating `set` and `setException`. If I was able to inherit from `SettableFuture` it would save me few common lines of code. I need to call them externally as in this case it's basically used to implement integration pattern between 3rd-party framework and guava based code. I.e. (simplified version) `3rdparty.method().addListener((Future<?> updatedFuture) -> { guavaFuture.set(updatedFuture.get()); })`

For the `cancel()` request - I don't think it's somehow in conflict with specification. The specification only says that `isDone()` must return true and `isCancelled()` true as well but doesn't say when. And actually as the future is handled asynchronously by listener anyway it doesn't make any difference when you really "finish" the future.
 That would be even worse because I would lose reusability of such class. And secondly I understand the original purpose of `SettableFuture` as the creating code doesn't yet know who and how updates the future. Otherwise it could be rather called Forwarded which in this case is just the listener.

RE: "subsequent calls to isDone()will always return true": But it still does. The only difference is that listeners invocation is postponed until the task is finished (if it already runs). The state of future would be always CANCELLED since the completion of `cancel()`and all the affected methods would return proper value.
 Never mind. I can either copy the setters or base the code on spring [`SettableListenableFuture`](http://docs.spring.io/autorepo/docs/spring/current/javadoc-api/org/springframework/util/concurrent/SettableListenableFuture.html) which is more open in these terms.

Thanks anyway.
    This resolves #1957 by providing the tryParseUnsigned\* methods.
 Okay, I will make the changes. Do I have to close this pull request and create a new one?
 I can't add the tryParse method for UnsignedBytes as there is no UnsignedByte class to return as a null object.
 I've found some further inconsistencies. In UnsignedLongs.parseUnsignedLong, a NumberFormatException is thrown if the radix is not within the min or max radix which is consistent with Java's Long.parseLong. However, in Longs.tryParse, an IllegalArgumentException is thrown instead.

I think the new tryParse methods should throw NumberFormatException as well. But what should we do with the old methods?
  I was searching for a way to convert an Iterable to a Collection, and Guava already has it. Sadly, it's not public...

Use case: I am creating a class where the API uses Iterable (because it's the right thing to do there), but have to call a 3rd party component that requires a Collection.
 Works, but always creates a copy. Iterables.toCollections does not if it is passed a collection.
  It would be nice and helpful if guava would support [JSR-107 Java Temporary Caching API](https://jcp.org/en/jsr/detail?id=107) - either out-of-the-box or by providing an adapter.
 You really don't want it. Its horribly designed, error prone, and slow. The TCK is buggy and provides very poor coverage. The API is not friendly and the annotations are racy (non-atomic).

The implementations I've reviewed, written by the spec authors, do not even honor the API contract (e.g. ordered events are in fact not always ordered). The spec specifies the implementation algorithms to ensure that all match the design and quirks of the original reference, Ehcache. This requires extensive bridge code to reimplement features due to how over specified they are defined in the JavaDoc and TCK.

I don't think Guava can adequately implement the spec without abandoning most of the value of the cache. The team would probably discourage usage after having gone through the implementation exercise and not want to support it.

You can see my [adapter](https://github.com/ben-manes/caffeine) for a Guava-like cache. However, I'd recommend you look into the JSR and further advise you to avoid it if possible.
 It looks like @ocafebabe is attempting to implement a [guava-jcache](https://github.com/ocafebabe/guava-jcache). I don't think it will be able to pass the TCK and be fully thread-safe (e.g. entry processors are supposed to be atomic, expiry is required to be called on every operation so it can't map to guava's). When Guava is updated to JDK8 with `compute` support then I think this could be a full implementation. Until then, it is probably good enough if the caveats are acceptable.
 Indeed, I tried to run the TCK against my [guava-jcache](https://github.com/ocafebabe/guava-jcache) implementation and some tests don't pass but mostly because Guava doesn't support all the JSR-107 features (like "store by value" for instance)... But personally I don't need all the fancy JSR-107 features anyway! Let's face it, most of the time all you want from a caching solution is simply put and get operations. And in my case I also need the cache loading option since values are provided by the database but this already supported very well by Guava.

The two main reasons I had initially when I started working on this project was to be able to use Guava as my caching provider with the added value of a CacheManager (this is very handy when you need to force the invalidation of a specific cache from a caching service) and also have the possibility to plug a different caching solution (like EhCache, Hazelcast, etc.). And both are already working very well with the current state of my project!

Is there an ETA for the Guava update to JDK8?

Comments and/or suggestions are welcomed :)
 The last updated plan said [mid 2016](https://groups.google.com/d/msg/guava-discuss/ZRmDJnAq9T0/-HExv44eCAAJ).

You may enjoy browsing through [Caffine's JCache adapter](https://github.com/ben-manes/caffeine), which is a Java 8 rewrite of Guava's cache. I think you could use many of the same techniques (event ordering via future chains, computes). The only race that may be hard to tackle is that Guava's removal notifications are asynchronous, but the removal JSR event must be fully ordered. That is solved in Caffeine by introducing a `CacheWriter`. I think you can be resolve that too, but it is a little more tricky.
 I just realized that you're the author of Caffeine! I looked at this project very closely before starting to work on my own implementation. And honestly I wanted to use it but my biggest issue is the Java 8 requirement! At work we still rely on some Java libraries that aren't compatible with Java 8 yet. So for now we're stuck with Java 7! But I will revisit Caffeine as soon as we port everything to Java 8!

Thanks for you feedback!
   https://github.com/google/guava/wiki/RangesExplained#encloses

Following statement needs review:
"[3..6] does not enclose (1..1] even though it contains every value contained by the latter range"

since the second part of the statement is not accurate.
 Oh, I'm sorry.  You are correct. 

The second statement is a vacuous truth.
https://en.wikipedia.org/wiki/Vacuous_truth

More specifically, since the range (1..1] does not contain _any_ elements, the range [3..6] _vacuously_ contains _all_ elements in (1..1].
  Minor performance improvement in `ImmutableMap.copyOf(Map)`:

If `map instanceof ImmutableSortedMap`, no longer unnecessarily run the following, since it will always be `false`:

```
else if (map instanceof EnumMap)
```
 This change also clarifies the intent of the method
  The following test case fails on jdk6u45 (trigger a jdk6 bug probably fixed in jdk7). It happens as soon as an annotation processor is present in the classpath (not only auto-value).

``` java
package test;
import com.google.common.collect.ImmutableMultimap;
public final class Test {{
    ImmutableMultimap.class.toString();
}}
```

``` xml
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <groupId>guava-19rc2-regression</groupId>
    <artifactId>immutablemultimap</artifactId>
    <version>0.0.1-SNAPSHOT</version>
    <dependencies>
        <dependency>
            <groupId>com.google.guava</groupId>
            <artifactId>guava</artifactId>
            <version>19.0-rc2</version>
        </dependency>
        <dependency>
            <groupId>com.google.auto.value</groupId>
            <artifactId>auto-value</artifactId>
            <version>1.1</version>
            <optional>true</optional>
        </dependency>
    </dependencies>
    <build>
        <pluginManagement>
            <plugins>
                <plugin>
                    <groupId>org.apache.maven.plugins</groupId>
                    <artifactId>maven-compiler-plugin</artifactId>
                    <version>3.1</version>
                    <configuration>
                        <source>1.6</source>
                        <target>1.6</target>
                        <compilerArgs combine.self="append">
                            <arg>-verbose</arg>
                        </compilerArgs>
                    </configuration>
                </plugin>
            </plugins>
        </pluginManagement>
    </build>
</project>
```
 javac trace with 19rc2:

```
[parsing started E:\projects\immutablemultimap\src\main\java\test\Test.java]
[parsing completed 17ms]
[search path for source files: E:\projects\immutablemultimap\src\main\java,]
[search path for class files: C:\Program Files\Java\jdk1.6.0_45\jre\lib\resources.jar,C:\Program Files\Java\jdk1.6.0_45\jre\lib\rt.jar,C:\Program Files\Java\jdk1.6.0_45\jre\lib\sunrsasign.jar,C:\Program Files\Java\jdk1.6.0_45\jre\lib\jsse.jar,C:\Program Files\Java\jdk1.6.0_45\jre\lib\jce.jar,C:\Program Files\Java\jdk1.6.0_45\jre\lib\charsets.jar,C:\Program Files\Java\jdk1.6.0_45\jre\lib\modules\jdk.boot.jar,C:\Program Files\Java\jdk1.6.0_45\jre\classes,C:\Program Files\Java\jdk1.6.0_45\jre\lib\ext\dnsns.jar,C:\Program Files\Java\jdk1.6.0_45\jre\lib\ext\localedata.jar,C:\Program Files\Java\jdk1.6.0_45\jre\lib\ext\sunjce_provider.jar,C:\Program Files\Java\jdk1.6.0_45\jre\lib\ext\sunmscapi.jar,E:\projects\immutablemultimap\target\classes,E:\projects\maven\maven-local-repo\com\google\guava\guava\19.0-rc2\guava-19.0-rc2.jar,E:\projects\maven\maven-local-repo\com\google\auto\value\auto-value\1.1\auto-value-1.1.jar,.]
[loading com\google\common\collect\ImmutableMultimap.class(com\google\common\collect:ImmutableMultimap.class)]
[loading com\google\common\annotations\GwtCompatible.class(com\google\common\annotations:GwtCompatible.class)]
[loading java\lang\annotation\Retention.class(java\lang\annotation:Retention.class)]
[loading java\lang\annotation\RetentionPolicy.class(java\lang\annotation:RetentionPolicy.class)]
[loading java\lang\annotation\Target.class(java\lang\annotation:Target.class)]
[loading java\lang\annotation\ElementType.class(java\lang\annotation:ElementType.class)]
An exception has occurred in the compiler (1.6.0_45). Please file a bug at the Java Developer Connection (http://java.sun.com/webapps/bugreport)  after checking the Bug Parade for duplicates. Include your program and the following diagnostic in your report.  Thank you.
java.lang.NullPointerException
    at com.sun.tools.javac.code.Symbol$MethodSymbol.params(Symbol.java:1196)
    at com.sun.tools.javac.jvm.ClassReader.attachParameterAnnotations(ClassReader.java:1111)
    ...
```
 javac trace with 19rc1:

```
[parsing started E:\projects\immutablemultimap\src\main\java\test\Test.java]
[parsing completed 13ms]
[search path for source files: E:\projects\immutablemultimap\src\main\java,]
[search path for class files: C:\Program Files\Java\jdk1.6.0_45\jre\lib\resources.jar,C:\Program Files\Java\jdk1.6.0_45\jre\lib\rt.jar,C:\Program Files\Java\jdk1.6.0_45\jre\lib\sunrsasign.jar,C:\Program Files\Java\jdk1.6.0_45\jre\lib\jsse.jar,C:\Program Files\Java\jdk1.6.0_45\jre\lib\jce.jar,C:\Program Files\Java\jdk1.6.0_45\jre\lib\charsets.jar,C:\Program Files\Java\jdk1.6.0_45\jre\lib\modules\jdk.boot.jar,C:\Program Files\Java\jdk1.6.0_45\jre\classes,C:\Program Files\Java\jdk1.6.0_45\jre\lib\ext\dnsns.jar,C:\Program Files\Java\jdk1.6.0_45\jre\lib\ext\localedata.jar,C:\Program Files\Java\jdk1.6.0_45\jre\lib\ext\sunjce_provider.jar,C:\Program Files\Java\jdk1.6.0_45\jre\lib\ext\sunmscapi.jar,E:\projects\immutablemultimap\target\classes,E:\projects\maven\maven-local-repo\com\google\guava\guava\19.0-rc1\guava-19.0-rc1.jar,E:\projects\maven\maven-local-repo\com\google\auto\value\auto-value\1.1\auto-value-1.1.jar,.]
[loading com\google\common\collect\ImmutableMultimap.class(com\google\common\collect:ImmutableMultimap.class)]
[loading java\lang\Object.class(java\lang:Object.class)]
[loading com\google\common\annotations\GwtCompatible.class(com\google\common\annotations:GwtCompatible.class)]
[loading java\lang\annotation\Retention.class(java\lang\annotation:Retention.class)]
[loading java\lang\annotation\RetentionPolicy.class(java\lang\annotation:RetentionPolicy.class)]
[loading java\lang\annotation\Target.class(java\lang\annotation:Target.class)]
[loading java\lang\annotation\ElementType.class(java\lang\annotation:ElementType.class)]
Round 1:
    input files: {test.Test}
    annotations: []
    last round: false
Round 2:
    input files: {}
    annotations: []
    last round: true
[search path for source files: E:\projects\immutablemultimap\src\main\java,]
[search path for class files: C:\Program Files\Java\jdk1.6.0_45\jre\lib\resources.jar,C:\Program Files\Java\jdk1.6.0_45\jre\lib\rt.jar,C:\Program Files\Java\jdk1.6.0_45\jre\lib\sunrsasign.jar,C:\Program Files\Java\jdk1.6.0_45\jre\lib\jsse.jar,C:\Program Files\Java\jdk1.6.0_45\jre\lib\jce.jar,C:\Program Files\Java\jdk1.6.0_45\jre\lib\charsets.jar,C:\Program Files\Java\jdk1.6.0_45\jre\lib\modules\jdk.boot.jar,C:\Program Files\Java\jdk1.6.0_45\jre\classes,C:\Program Files\Java\jdk1.6.0_45\jre\lib\ext\dnsns.jar,C:\Program Files\Java\jdk1.6.0_45\jre\lib\ext\localedata.jar,C:\Program Files\Java\jdk1.6.0_45\jre\lib\ext\sunjce_provider.jar,C:\Program Files\Java\jdk1.6.0_45\jre\lib\ext\sunmscapi.jar,E:\projects\immutablemultimap\target\classes,E:\projects\maven\maven-local-repo\com\google\guava\guava\19.0-rc1\guava-19.0-rc1.jar,E:\projects\maven\maven-local-repo\com\google\auto\value\auto-value\1.1\auto-value-1.1.jar,.]
[loading com\google\common\collect\ImmutableMultimap.class(com\google\common\collect:ImmutableMultimap.class)]
[loading java\lang\Object.class(java\lang:Object.class)]
[loading com\google\common\annotations\GwtCompatible.class(com\google\common\annotations:GwtCompatible.class)]
[loading java\lang\annotation\Retention.class(java\lang\annotation:Retention.class)]
[loading java\lang\annotation\RetentionPolicy.class(java\lang\annotation:RetentionPolicy.class)]
[loading java\lang\annotation\Target.class(java\lang\annotation:Target.class)]
[loading java\lang\annotation\ElementType.class(java\lang\annotation:ElementType.class)]
[checking test.Test]
[loading java\lang\Class.class(java\lang:Class.class)]
[loading java\lang\String.class(java\lang:String.class)]
[wrote E:\projects\immutablemultimap\target\classes\test\Test.class]
[total 525ms]
```
 I suspect this is due to c62b07df3a68126e1cf549c85c35f4e55178990b
 @cpovirk I hope there is more to it than this commit, otherwise jdk6 javac is seriously fucked up!
 @cpovirk thanks for solving this!
 Unfortunately we still use jdk 6 in a number of projects at work (full migration to java 8 will not happen before Q2.2016). If this bug is not fixed then I guess we will just continue to use guava 18 until we migrate to java 8.
But then the guava readme will have to be updated to:

> Requires JDK 1.7 or higher (as of 19.0).
 I think it is worth openning a bug at openjdk. then, if it fixed, release a 19.1 that restore jdk6 compatibility.
 I confirm that I cannot reproduce the problem with 19.0-rc3. thanks!
   Current version badges
 A recipe for decision paralysis: 
<img width="252" alt="screen shot 2015-09-29 at 1 13 43 am" src="https://cloud.githubusercontent.com/assets/66577/10155800/5eed22ca-6647-11e5-8ba3-939301198fe0.png">
 I'd say squash the commits and use better labeling.  Current and Latest is a bit confusing.  If the param left is {false} and the param right is {true}, method compare returns -1.
If the param left is  {false} and the param right is {false,true},method compare also returns -1.
How could you distinguish these two situations using the return value -1 ?
 OK，^_^，got it
  Thought I'd give my 2 cents on this proverbial bikeshed. :)

Given how Google's recently migrated to Java 8 (https://github.com/google/guava/issues/2443#issuecomment-248103813), I think it's worth waiting until Guava 21 is in development to allow `Table.computeIfAbsent` to be implemented as a default method.
 Great! In that case, if this has not yet been decided on internally, I'd feel strongly about making `Table.computeIfAbsent` a default method - it would have increased "discoverability" in IDEs, since one could type e.g. `fooTable.` and they'd see `computeIfAbsent` as a potential option.
 @lowasser I get the impression from #902 and #1227 that there is real demand for a method like this or a Multitable class (but I don't know how much).

In particular, I find [this comment](https://github.com/google/guava/issues/902#issuecomment-61351113) regarding Bigtable very interesting. It suggests to me that even if Multitables are hardly useful when creating "low level" software (like command line programs), they are a lot more useful when creating more "high level" stuff like, say, Big Data applications.

At this point, it's not clear to me what other questions we should ask ourselves to determine the usefulness of `Table.computeIfAbsent`/`Multitable` in Guava itself...
 Okay, that's obviously something _I_ can't do, as I'm not a Google employee, so all I can do at this point is look forward to further internal progress on this. :)
 Just to add another possibly-complicating factor, at least some of the Table uses inside Google may become Graphs/ValueGraphs/Networks now that common.graph is available and becoming more mainstream.  (One of the current use cases that's described for Table is, in fact, for representing a graph: https://github.com/google/guava/wiki/NewCollectionTypesExplained#table)

This suggests that we may want to consider (down the road, at least) improved support for Collection-based Values in a ValueGraph.  (Similar to Map<K, Collection<V>>, one can already do ValueGraph<N, Collection<V>>, but facilitating working with that kind of data is what Multimap is for.)

@Bezier89 FYI
  Hi,

This is being pedantic, but there seems to be no specific reason for the local newCount variable to be set to this.count -1 twice in the method.

Current code ...

```
@Nullable
V remove(Object key, int hash) {
  lock();
  try {
    long now = map.ticker.read();
    preWriteCleanup(now);

    int newCount = this.count - 1;
    AtomicReferenceArray<ReferenceEntry<K, V>> table = this.table;
    int index = hash & (table.length() - 1);
    ReferenceEntry<K, V> first = table.get(index);

    for (ReferenceEntry<K, V> e = first; e != null; e = e.getNext()) {
      K entryKey = e.getKey();
      if (e.getHash() == hash && entryKey != null
          && map.keyEquivalence.equivalent(key, entryKey)) {
        ValueReference<K, V> valueReference = e.getValueReference();
        V entryValue = valueReference.get();

        RemovalCause cause;
        if (entryValue != null) {
          cause = RemovalCause.EXPLICIT;
        } else if (valueReference.isActive()) {
          cause = RemovalCause.COLLECTED;
        } else {
          // currently loading
          return null;
        }

        ++modCount;
        ReferenceEntry<K, V> newFirst = removeValueFromChain(
            first, e, entryKey, hash, valueReference, cause);
        newCount = this.count - 1;
        table.set(index, newFirst);
        this.count = newCount; // write-volatile
        return entryValue;
      }
    }

    return null;
  } finally {
    unlock();
    postWriteCleanup();
  }
}
```
 Replacement

@Nullable
V remove(Object key, int hash) {
  lock();
  try {
    long now = map.ticker.read();
    preWriteCleanup(now);

```
AtomicReferenceArray<ReferenceEntry<K, V>> table = this.table;
int index = hash & (table.length() - 1);
ReferenceEntry<K, V> first = table.get(index);

for (ReferenceEntry<K, V> e = first; e != null; e = e.getNext()) {
  K entryKey = e.getKey();
  if (e.getHash() == hash && entryKey != null
      && map.keyEquivalence.equivalent(key, entryKey)) {
    ValueReference<K, V> valueReference = e.getValueReference();
    V entryValue = valueReference.get();

    RemovalCause cause;
    if (entryValue != null) {
      cause = RemovalCause.EXPLICIT;
    } else if (valueReference.isActive()) {
      cause = RemovalCause.COLLECTED;
    } else {
      // currently loading
      return null;
    }

    ++modCount;
    ReferenceEntry<K, V> newFirst = removeValueFromChain(
        first, e, entryKey, hash, valueReference, cause);
    int newCount = this.count - 1;
    table.set(index, newFirst);
    this.count = newCount; // write-volatile
    return entryValue;
  }
}

return null;
```

  } finally {
    unlock();
    postWriteCleanup();
  }
}
  More information and code here:
https://github.com/martinm1000/g18vs19
 I was afraid of this... ;-(
  Fix typo in comments
 I signed it!
  It would be very nice to have sample of thread safe bloom filter, what you guys think?
  Avoiding nullability in Java is a recurring problem.

Other languages offer an `Optional`, which makes nullability composable.
This however is very verbose in Java and cannot consistently be inserted into an existing, nullable codebase (especially since the `Optional` can be null also).

Guava tries to simplify some of the common cases, e.g. we have a value, but if it's not set, we want a default (but the same can be true for the default).
Unfortunately this method wasn't called `defaultIfNull`, but `firstNonNull`, therefore people assumed it's a search.

This commit tries to solve that by _making_ it a search, and letting the users decide which approach they want:
ternary,

``` Java
(first != null) ? first : ((second != null) ? second : checkNotNull(third));
```

Find,

``` Java
Iterables.find(asList(first, second, third), Predicates.notNull());
```

Optional,

``` Java
Optional.fromNullable(first).or(second).or(third).get();
```

or the same approach Guava already provided:

``` Java
firstNonNull(first, second, third);
```
 I signed it as `paplorinc`! :) 

```
 On Saturday, 19 September 2015, 12:58, googlebot <notifications@github.com> wrote:
```

 Thanks for your pull request. It looks like this may be your first contribution to a Google open source project, in which case you'll need to sign a Contributor License Agreement (CLA). Please visit https://cla.developers.google.com/ to sign.Once you've signed, please reply here (e.g. I signed it!) and we'll verify. Thanks.   
- If you've already signed a CLA, it's possible we don't have your GitHub username or you're using a different email address. Check your existing CLA data and verify that your email is set on your git commits.
- If you signed the CLA as a corporation, please let us know the company's name.
  —
  Reply to this email directly or view it on GitHub.  
 Thanks, updated the commit message and posted a response to the Issue :)
 I strongly support this change, as I've been in the same pitfall: when I've first seen the method `firstNonNull` in use, I've immediately assumed that it accepts any number of arguments (as it would be logical, given it's name and intent); and then I was disappointed when I tried to use it with three arguments.
The existing alternatives are far less elegant and concise, and also fragment the code base (while for the two-parameter cases I'm using `firstNonNull`, for the three-parameter cases I'm using something different).
 @zsolt-donca, thanks, will apply your comments :)
  If input is non-null, applies the function to it.
If either the input or the result is null, will return the default value.

This is an alternative for `Optional`, similarly to `firstNonNull`:

``` Java
Optional.fromNullable(person.getName()).transform(String::toUpperCase).or("");
```

or

``` Java
String name = person.getName();
if (name != null)
  name = name.toUpperCase();
if (name == null)
  name = "";
```

can now be written as (Java 8, default value and static import):

``` Java
ifNonNull(person.getName(), String::toUpperCase, "");
```
 Signed ;) 

```
 On Saturday, 19 September 2015, 12:55, googlebot <notifications@github.com> wrote:
```

 Thanks for your pull request. It looks like this may be your first contribution to a Google open source project, in which case you'll need to sign a Contributor License Agreement (CLA). Please visit https://cla.developers.google.com/ to sign.Once you've signed, please reply here (e.g. I signed it!) and we'll verify. Thanks.   
- If you've already signed a CLA, it's possible we don't have your GitHub username or you're using a different email address. Check your existing CLA data and verify that your email is set on your git commits.
- If you signed the CLA as a corporation, please let us know the company's name.
  —
  Reply to this email directly or view it on GitHub.  
 How is it different from `Optional` approach besides not creating an `Optional` instance?

``` java
Optional.fromNullable(name).transform(n -> n.toUpperCase()).or("");
```
 Hello @dant3,

The point of this modification is to provide an alternative for `Optional` for another very common case.
The same as for Guava's `firstNonNull`, e.g. instead of

``` Java
    Optional.fromNullable(first).or(second).get();
```

we can _choose_ (this is the keyword here) to simply call

``` Java
    firstNonNull(first, second);    
```

Which delimits the different parts of the computation way better, than `Optional` could.

The same applies to this changeset also, e.g. instead of

``` Java
    Optional.fromNullable(name).transform(n -> n.toUpperCase()).or("");
```

we can _choose_ to simply call

``` Java
    ifNonNull(name, n -> n.toUpperCase(), "");
```

Which keeps the bare essentials only.

ps. I statically imported `MoreObject`, because its methods are stateless and have meaning without the surrounding object, unlike `Optional`, where simply calling `fromNullable(first)` would look unintuitive.
 (related to https://github.com/google/guava/pull/2164)
 I like the general idea presented here, as there definitely are use cases when the above-defined `ifNonNull` would be the preferable choice.

What is the expected behavior when `thenFunction` returns null? Should `ifNonNull` return 
- null (the current behavior), 
- throw an exception, like the `Optional.transform` does in the above example
- `elseValue`, like the equivalent of the above example would do if it was using `java.util.Optional` from Java 8.
 @zsolt-donca, very good observations, thanks, will apply them.
@lowasser, I understand your concern, and would like to add a few comments:
- Guava has many methods that look horrible with Java 7, e.g.

``` Java
Integer find(List<Integer> inputs) {
  return Iterables.find(inputs, new Predicate<Integer>() {
    @Override
    public boolean apply(Integer input) {
      return input == 2;
    }
  });
}
```

but can be replaced with simple constructs, e.g.

``` Java
Integer find(List<Integer> inputs) {
  for (Integer input : inputs)
    if (input == 2) return input;  
  throw new NoSuchElementException();
}
```

or

``` Java
Iterables.find(inputs, Predicates.equalTo(2))
```

The same is true in this case, i.e. one could still extract commonly used functions and use them in a similar manner.

``` Java
ifNonNull(person.getName(), Strings.toUpperCase(), "");
```
- The other argument is a more subjective one. `Idea` already presents these cases as if it were lambda style, making it more terse in reality than the variable&ternary style, i.e. instead of:

``` Java
String name = person.getName();
if (name != null)
  name = name.toUpperCase();
if (name == null)
  name = "";
```

we can still see in the IDE

``` Java
name = ifNonNull(person.getName(), (n) → { return n.toUpperCase(); }, "");
```
- And as a closing argument, in my personal opinion, Guava could really complement Java 8's shortcomings in more ways than it does now.
  Not providing useful functionality because in a deprecated Java version the syntax is uglier, is a pitty.
 Thanks for the explanation :) 
 @cgdecker, could you please take a look at https://github.com/google/guava/pull/2164 also?
  Creating  a project with the help of Guava.
  #2160
  Consider the following snippet - even though comparison would be avoided beyond the first compare call, the parameter evaluation for the second one (`this.expensiveCalculation()`) would still be done.

```
ComparisonChain.start()
    .compare(this.lessThanThat(), that.greaterThanThis())
    .compare(this.expensiveCalculation(), that.expensiveCalculation())
    .result();
```

I propose an extension similar to `Ordering::onResultOf` that can be used to avoid operations that are not needed because the comparison chain is "inactive" (result has already been determined).

```
ComparisonChain.start()
    .compare(this.lessThanThat(), that.greaterThanThis())
    .compare(this, that, ThisClass::expensiveCalculation)
    .result();
```
  The README refers to 19.0-RC1, but 19.0-rc2 is now available.
 @cgdecker thanks, I can see it's updated now.  Do you have any idea when the final release for 19.0 is coming?  In the Gerrit project we're using 19.0-rc2 and it would be nice if we can upgrade to the final version before we cut the first RC for 2.12.
  In Android a `SparseArray` implementation exists, that should be a more performant alternative to `Map<Integer, ?>` . It would be nice to have this class available in guava. Since it is already Apache licensed there shouldn't be much of a problem adding it to Guava.
 Performance is explicitly called out by SparseArray as being worse than
HashMap.

On Wed, Sep 16, 2015 at 3:52 AM Tim Roes notifications@github.com wrote:

> In Android a SparseArray implementation exists, that should be a more
> performant alternative to Map<Integer, ?> . It would be nice to have this
> class available in guava. Since it is already Apache licensed there
> shouldn't be much of a problem adding it to Guava.
> 
> —
> Reply to this email directly or view it on GitHub
> https://github.com/google/guava/issues/2157.
 Sorry I meant more memory efficient, not more performant :-/
  We make heavy use of `Table` collections. A need to do so across threads is common for us. A Guava Thread Safe `ConcurrentTable` implementation of the `Table` interface would be very useful and appreciated. 
  I'm new to osgi so perhaps I'm missing the obvious, but I have code that uses some classes in com.google.common.base, but because it is not exported in the MANIFEST.MF file, I am getting resolution errors.

I am working w/ version 15, but took at a look at v18 as well, and it looks like this package is still not exported.

Can someone tell me why that package isn't exported?  or if they have an inkling of what I"m doing wrong?
 apologies - my eyes must have been crossed.

On Fri, Sep 18, 2015 at 5:39 PM, Colin Decker notifications@github.com
wrote:

> Closed #2155 https://github.com/google/guava/issues/2155.
> 
> —
> Reply to this email directly or view it on GitHub
> https://github.com/google/guava/issues/2155#event-413619511.

## 

Adam Morgan
Salesforce ExactTarget Marketing Cloud http://www.exacttarget.com/
SMTS, Technical Services
  why the condition of the second check is "nanos==expirationNanos" instead of "nanos==0 || now-nanos>=0". I doubt it.
  **Summary**
ClassPath.getTopLevelClasses() returns empty list when the path of the classloader contains special characters.

**How to reproduce this error**
1. Create a packeage with three classes
2. Create the following unit test

``` java
    @Test
    public void testMain() throws Exception {
        ClassLoader loader = this.getClass().getClassLoader();
        ClassPath p = ClassPath.from(loader);
        ImmutableSet<ClassPath.ClassInfo> list = p.getTopLevelClasses("testpackage");
        Assert.assertEquals(3, list.size());
    }
```
1. Copy the whole project to a folder with special characters in its name (like % for example) and execute it.
2. The test will fail. If you copy the project to a folder without special characters in its path the test will pass.
 Looks to be caused by [This line](https://github.com/google/guava/blob/master/guava/src/com/google/common/reflect/ClassPath.java#L428)

It's caused because URLs automatically encode file names, while the File class expects raw unencoded input.
 I'm not sure whether incorrect URLs should be supported at all. I'd rather see an exception than no results. I believe that it is an URLClassLoader's responsibility to make sure it returns valid URLs. This is what should be supported in the first place. It's not anymore since 81b23cdc840018da4fc07ccfcd55c78391f44df0 as you already know.

Before:
https://github.com/google/guava/blob/10e33c03a6d68fe1404aa721a4a7e37c1e63c43b/guava/src/com/google/common/reflect/ClassPath.java#L291
`entry.toURI()` - yes, this could throw... in very rare circumstances.

After:
https://github.com/google/guava/blob/81b23cdc840018da4fc07ccfcd55c78391f44df0/guava/src/com/google/common/reflect/ClassPath.java#L289
`entry.getFile()` - if resource's path contains unsafe characters, you will most likely get them back... escaped.

Few days ago we switched from Guava 18 to 20. Our apps are mostly deployed into "C:\Program Files\Apache Software Foundation...". We have a lot of spaces in classpaths. Every time `new File(entry.getFile())` gives something like "/C:/Apache%20Software%20Foundation/...", one .jar is ignored by the Scanner (`!file.exists()` is true).

It seems like 81b23cdc840018da4fc07ccfcd55c78391f44df0 fixed ClassPath behavior for some exotic case but ruined the rest. I understand that it's still `@Beta`, so no offence, shit happens.

~~I've created a small test for you. Guava 14 to 18 passes, Guava 19 and 20 fails.~~
~~https://github.com/perceptron8/guava-issue-2152-test~~
[Edit: unnecessary since 896c51a, deleted]

I'd be happy if you fix this bug just with the following. There is no backward compatibility already, so why not?

```
try {
    file = new File(entry.toURI());
} catch (URISyntaxException e) {
    throw new IllegalArgumentException(e);
}
```

This would be used only for processing URLs returned by UrlClassLoader. At the time #1899 was submitted, getClassPathEntries() was used for resolving Manifest's Class-Path entries too. Now it's not AFAIK. Nothing wrong should happen. Not only spaces, but also percent signs could be supported again.

Some exhaustive unit tests for ClassPath would be really handy.
 This bug just caused us to downgrade Guava from 19.0 to 18.0, so we would be delighted if this issue could be fixed. @cpovirk The blog you mentioned at https://weblogs.java.net/blog/kohsuke/archive/2007/04/how_to_convert.html has a comment recommending, i.e., `Paths.get (entry.toURI ()).toFile ()` to handle UNC paths on Windows. Any issues with this approach? (Since Guava is migrating to Java 8 anyway...) I'm running into this problem in v21.0. Reverting to v18.0 solved the problem.  Could you confirm which version the commit mentioned above ended up in, or is expected to be in?

Thanks This problem still exists in java 9  `com.google.common.collect.ImmutableSet` is not producing consistent hash while using `com.google.common.hash.HashFunction`. If we wrap `HashSet` with `ImmutableSet` it works.
Please refer to `HashFunctionTest` below:

```
import com.google.common.collect.ImmutableSet;
import com.google.common.hash.HashCode;
import com.google.common.hash.HashFunction;
import com.google.common.hash.Hashing;
import org.apache.commons.lang3.SerializationUtils;
import org.junit.Before;
import org.junit.Test;

import java.util.HashSet;

import static org.junit.Assert.assertEquals;

public class HashFunctionTest {

    private HashFunction hashFunction;

    @Before
    public void setUp() throws Exception {
        hashFunction = Hashing.goodFastHash(128);
    }

    @Test // failed
    public void testImmutableSet() throws Exception {
        ImmutableSet<Integer> set1 = ImmutableSet.of(1, 2);
        ImmutableSet<Integer> set2 = ImmutableSet.of(2, 1);
        assertEquals(set1, set2);

        HashCode hash1 = hashFunction.hashBytes(SerializationUtils.serialize(set1));
        HashCode hash2 = hashFunction.hashBytes(SerializationUtils.serialize(set2));
        assertEquals(hash1, hash2);
    }


    @Test // failed
    public void testImmutableSetBuilder() throws Exception {
        ImmutableSet.Builder<Integer> builder1 = ImmutableSet.builder();
        builder1.add(1);
        builder1.add(2);

        ImmutableSet.Builder<Integer> builder2 = ImmutableSet.builder();
        builder2.add(2);
        builder2.add(1);

        ImmutableSet<Integer> set1 = builder1.build();
        ImmutableSet<Integer> set2 = builder2.build();
        assertEquals(set1, set2);

        HashCode hash1 = hashFunction.hashBytes(SerializationUtils.serialize(set1));
        HashCode hash2 = hashFunction.hashBytes(SerializationUtils.serialize(set2));
        assertEquals(hash1, hash2);
    }

    @Test // passed
    public void testSet() throws Exception {
        HashSet<Integer> set1 = new HashSet<>();
        set1.add(1);
        set1.add(2);
        HashSet<Integer> set2 = new HashSet<>();
        set2.add(2);
        set2.add(1);
        assertEquals(set1, set2);

        HashCode hash1 = hashFunction.hashBytes(SerializationUtils.serialize(set1));
        HashCode hash2 = hashFunction.hashBytes(SerializationUtils.serialize(set2));
        assertEquals(hash1, hash2);
    }

    @Test // passed
    public void testSetAndImmutableSet() throws Exception {
        HashSet<Integer> set1 = new HashSet<>();
        set1.add(1);
        set1.add(2);
        HashSet<Integer> set2 = new HashSet<>();
        set2.add(2);
        set2.add(1);
        assertEquals(set1, set2);

        ImmutableSet<Integer> immutableSet1 = ImmutableSet.copyOf(set1);
        ImmutableSet<Integer> immutableSet2 = ImmutableSet.copyOf(set2);

        HashCode hash1 = hashFunction.hashBytes(SerializationUtils.serialize(immutableSet1));
        HashCode hash2 = hashFunction.hashBytes(SerializationUtils.serialize(immutableSet2));
        assertEquals(hash1, hash2);
    }

    @Test // passed
    public void testSetAndImmutableSetBuilder() throws Exception {
        HashSet<Integer> set1 = new HashSet<>();
        set1.add(1);
        set1.add(2);
        HashSet<Integer> set2 = new HashSet<>();
        set2.add(2);
        set2.add(1);
        assertEquals(set1, set2);

        ImmutableSet<Integer> immutableSet1 = ImmutableSet.<Integer>builder().addAll(set1).build();
        ImmutableSet<Integer> immutableSet2 = ImmutableSet.<Integer>builder().addAll(set2).build();

        HashCode hash1 = hashFunction.hashBytes(SerializationUtils.serialize(immutableSet1));
        HashCode hash2 = hashFunction.hashBytes(SerializationUtils.serialize(immutableSet2));
        assertEquals(hash1, hash2);
    }
}
```
  https://code.google.com/p/guava-libraries/wiki/ImmutableCollectionsExplained#Why?
There is an analysis in this section, however, this report is protected from normal users, why? Could you open this benchmark report?
  I'd like to do FluentIterable.from("a").append(otherStrings);

Granted, I can do FluentIterable.from(newArrayList("a")).append(otherStrings), but seems like a vararg is reasonable to avoid the "newArrayList" boilerplate. 
  This extends current indexOf function with possibility of specifying where to start and where to end with the search, similarly to java String.indexOf methods.
 I signed it!
 Hi, sure, I'm working on project which consumes ASCII input (potentially binary) and basically need similar functions for parsing as String provides.
 If the data comes from structure I don't have control over - like ByteBuffer from NIO or ByteBuf from netty, this parameter will become pretty handy.
  I'm out of luck as this file https://raw.githubusercontent.com/publicsuffix/list/master/public_suffix_list.dat always changes at a faster rate than guava releases.
 @cpovirk All links in that pull request are dead or deleted 

https://wiki.magnolia-cms.com/display/WIKI/TldPatterns+(public+suffix+list)+generator
![image](https://cloud.githubusercontent.com/assets/286258/9805541/c862fe9e-57ee-11e5-9b19-54431a3d8303.png)

magnolia-domainnameutils package does not exist
  `ByteSource.asCharSource` is present, and very useful. But I'm finding several cases where it'd be nice to have a `ByteSource` view of a `CharSource` without first serializing out to `String` and then calling `String.getBytes(Charset)`. Additionally, having both `ByteSource.asCharSource` and `CharSource.asByteSource` would let us chain the two to transcode from a `ByteSource` in one charset to a `ByteSource` in another.
  I'm thinking about adding support for all the Java 8 [`java.util.function`](https://docs.oracle.com/javase/8/docs/api/java/util/function/package-summary.html) classes to the methods that use similar Guava classes.

For example, there would be both (type parameters removed for brevity):
- `Multimaps.filterEntries(Multimap map, google.common.base.predicate.Predicate predicate)`
-  `Multimaps.filterEntries(Multimap map, java.util.function.Predicate predicate)`

This would allow Guava to have the more convenient syntax of Java 8 lambdas without breaking backwards compatibility.

This has the obvious drawback of Guava having Java 8 as a compile time dependency. However, now that we are past Java 7 end of life, it is time to at least consider doing that anyway.

I'm proposing that I do some/most/all the work for this, but I wanted to run it by the Guava team before I began the process.
 Oh, goodness, this stemmed from me not understanding how lambdas work, specifically, that Java is smart enough to figure out whether to use `c.g.c.base.Function` vs `j.u.f.Function` based on the method signature. I had put the lambda in a local variable in my test and it didn't work (obviously). My mistake, thanks for the clarification!
   My project is using GWT 2.7.0 and Guava 18.0. When switching from 18.0 to 19.0-rc1 and making no other changes, I get the following error during GWT compilation:

```
   Tracing compile failure path for type 'com.google.common.collect.ImmutableMapEntrySet'
      [ERROR] Errors in 'com/google/common/collect/super/com/google/common/collect/ImmutableMapEntrySet.java'
         [ERROR] Line 35: Weak cannot be resolved to a type
         [ERROR] Line 20: The import com.google.j2objc cannot be resolved
   [ERROR] Hint: Check that the type name 'com.google.common.collect.ImmutableMapEntrySet' is really what you meant
   [ERROR] Hint: Check that your classpath includes all required source roots
```
 Thanks, that worked. Didn't realize there was a new dependency. I'm using Bazel, which doesn't do automatic dependency management.
  Hello is there any chance to have a license included inside the JAR/MVN?

The Guava POM includes a lot of stuff, but is missing the license:

> https://repo1.maven.org/maven2/com/google/guava/guava/19.0-rc1/guava-19.0-rc1.pom

It should look nearly like that:
`
<licenses>
<license>
<name>Apache 2</name>
<url>http://www.apache.org/licenses/LICENSE-2.0.txt</url>
<distribution>repo</distribution>
</license>
</licenses>
`
 Its part of the [parent pom](https://repo1.maven.org/maven2/com/google/guava/guava-parent/19.0-rc1/guava-parent-19.0-rc1.pom). That should be an acceptable location for license validators.
  Hi,

FluentIterable is very useful but lacks some shortcuts for transform/filtering of primitives and common data types (String, Date, Calendar).

Suggestion for transform shortcuts:
- asInt(), asLong(), asString(), asShort(), asByte(), asChar(), asDouble(), asFloat(), asDate(TimeZone), asDate(TimeZone, Format)

Suggestion for filter shortcuts:
- All: isNotNull(), isNull(),
- String: isEmpty(), isNotEmpty()
- Numbers: isNotZero(), isZero(), isPositive(), isNegative()
- Dates: isToday(), isThisWeek(), isThisMonth(), isThisYear(), isWeekEnd(), isNotWeekEnd()

The shortcuts could be clever enough to do the conversion before filtering. E.g. If I use isEmpty() as filter then asString() is executed first

In case is too specific for FluentIterable a new Fluent class can be created.

I can contribute with this change, but I prefer to talk about it first. I have some draft implementations.

Some examples of combinations:
- given a list of dates in numeric string format, get a filtered set of dates which are today

``` java
from(list).asLong().isPositive().asDate(TimeZone).isToday().toSet()
```
- given a list of text numbers, get a filtered list with the positive values as integer:

``` java
from(list).isNotNull().asInt().isPositive().toList()
```
  Per https://github.com/google/j2objc/issues/521, the @WeakOuter annotations added in https://github.com/google/guava/commit/c62b07df3a68126e1cf549c85c35f4e55178990b can cause crashes in Objective-C translations of Guava (when the client possess a strong reference only to a view of a collection, and retains no strong references to collection itself).

Since this hasn't made it to official v19 and is still in RC, should this be rolled back until it can be guaranteed correct?

cc: @kstanger 
 Removing the @WeakOuter would result in a memory leak in ALL use cases. With the @WeakOuter, the code at least works correctly in MOST use cases. This is consistent with our current strategy for collection views and is not a regression from our J2ObjC fork of Guava.

We may need to revise our strategy for collection views, but until then, this is "working as intended".
 So a leak is considered worse than a crash?
 One strategy is not _better_ than the other. The point is, neither strategy is fully _correct_ and we had to chose one. I'm happy to reconsider this decision based on your feedback, but this will be done with very careful consideration when I have the time to focus on this problem.
 That scenario would result in the collection's reference to the view being a dead pointer at some point in the future. Keep in mind we don't necessarily have ARC's automatically nil'ed __weak reference semantics, and if we did we'd still need to make the necessary modifications to check for nil.
 It's not okay because the collection will continue to return the same pointer after it's deleted. It has no way to detect that the pointer has been deleted.
  Recommend adding to 
https://github.com/google/guava/wiki/PreconditionsExplained
or maybe also in the Javadoc a reminder that a call to Preconditions.checkXX(condition, format, formatValues...) allocates an Object[] on every call, regardless of whether the condition is true or false.

While this is a property of Java and not specific to this API, it is easy to miss.
This can add a lot of garbage, and is especially bad in a UI loop on Android for example.
  FluentIterable::toList doesn't infer return type of List<? super E> like Java 8 Stream can do.

```
class BaseClass {
    final String name;

BaseClass(String name) {
        this.name = name;
    }
}
class SubClass extends BaseClass {
    SubClass(String name) {
        super(name);
    }
}
// This should compile, but can't because the LHS is BaseClass, but after transform, we have FluentIterable<SubClass> and toList() can't adapt.
List<BaseClass> ret = FluentIterable.from(Splitter.on(CharMatcher.WHITESPACE).split("Foo bar baz"))
    .transform(t -> new SubClass(t))
    .toList();

// This compiles, FWIW in Java 8
List<BaseClass> ret = Splitter.on(CharMatcher.WHITESPACE).splitToList("Foo bar baz")
    .stream()
    .map(t -> new SubClass(t))
    .collect(Collectors.toList());
```

/cc @kuangchen
 Darn - I tinkered with it.  I really wish there were lower bounds for type parameters, but apparently there are not - very clever how Stream did it - Collectors has a concrete unbounded type, but the collect method uses the lower bound wildcard `? super T` - which allows the higher type that is inferred from the LHS to be used to satisfy the unbound type of the collector.

Man, what hoops to jump through ugly and you're right… not a hard solution/workaround. I'll close this.
 http://www.angelikalanger.com/GenericsFAQ/FAQSections/TypeParameters.html#FAQ107
  `FluentIterable.of(1, 2, 3)` would be easier to use/more succinct than `FluentIterable.of(new int[]{1, 2, 3})`

This change does not break the existing API as E... becomes E[] by the time it is used in the method.
 I signed the CLA!
 @stephenh - I saw your comment on https://github.com/google/guava/issues/1070 but can't reply any longer.

FWIW, I rolled my own and have been getting good traction with it…

See https://github.com/scr/j8iterables for some useful crossovers between Guava, Stream, and Jdk8!
 This change, however, did not come in Guava 19.

I am wondering what's the solution for the overloading confusion that would be introduced by such a signature change when there's one single array argument? (A potential break in source back-compatibility.)

The other Guava APIs avoided this by naming the var-arg method differently from the one that accepts an array (`of` vs. `copyOf`), but the original signature has obviously broken this naming convention.
  Hi folks, I'm hessitant to raise a suggestion already discussed and closed, but since last time Java 8 has come along, which might give the idea merit again(?)

It seems that the "impossible" `Iterables` equivalant of `Iterators.forEnumeration` could be implemented by taking a `Supplier<Enumeration<T>>`. With lambdas & method references this can yeild uses which aren't even too horrible, such as:

```
for (MyTreeNode node : Iterables.forEnumerationSupplier(tree::preorderEnumeration)) {
  //...
}
```

and which also save a bit of memory churn c.f. `Collections.list`. 

If you're reaching for the duplicate button already, the tickets you're looking for are: #1399 and #796 ;-)  Still I think the Supplier makes this well-defined, and hence different from the "single-use iterator as an iterable" graveyard-suggestion made within those tickets.
 Oh, that's nice, and I agree this isn't _too_ horrible:

```
Iterable<MyTreeNode> nodes = () -> Iterators.forEnumeration(tree.preorderEnumeration());
for (MyTreeNode node : nodes) { ...
```

Yet since Java can't infer that the type needs to be `Iterable<T>` on the right-side of a for-each, I'd still be tempted to write my own utility to avoid either the cast or variable declaration. Simply extracting this line leads to the dangerous API:

```
public final class Enumerations {
  public static <T> Iterable<T> asIterable(Enumeration<T> en) {
    return () -> Iterators.forEnumeration(en);
  }
```

which might encourage the accident of using an exhausted Enumeration. So I think I'll still end up with this utility when rolling my own:

```
public static <T> Iterable<T> asIterable(Supplier<Enumeration<T>> factory) {
  checkNotNull(factory);
  return new Iterable<T>() {
    public UnmodifiableIterator<T> iterator() {
      return Iterators.forEnumeration(factory.get());
    }
  };
}
```

It would also allow this:

```
    Iterables.forEnumerationSupplier(this::preorderEnumeration)
        .forEach(node -> node.doSomething());
```

which has a lot less punctuation than:

```
    ((Iterable<MyTreeNode>) () -> Iterators.forEnumeration(tree.preorderEnumeration()))
        .forEach(node -> node.doSomething());
```
 (a) My motivating case was `DefaultMutableTreeNode`, which has a few different methods returning Enumerations; and in some scenarios we may not be able to use a derived class; anyway...
(b) is nice: both concise and efficient. Between that and `Collections.asList` (for traditional loops) I'm happy to drop the request. While it might add a little symmetry, it's hard to argue for much 'utility' given this good alternative in Java 8. (The requested method could probably only be used 'concisely' in Java 8.)

Thanks!
  Hello,

if one future fails in a combined future a large message with stacktrace is spit out via java.util.logging. This is inconvenient. 

```
Aug 17, 2015 7:12:44 PM com.google.common.util.concurrent.Futures$CombinedFuture setExceptionAndMaybeLog 
SEVERE: input future failed
```

We know of lots cases where this behaviour cannot or shuold not be avoided (for instance, jobs failing because of timeouts). 

The exception is propagated and handled correctly by the combined future so we have other means to find out what's wrong and handle the case gracefully (it has to be done anyway).

I can think of a few workarounds, which may even need to be applied in grops, which are equally pesky:
- Working it around by java.util.logging at the system level is not practical as it requires manual changes at the OS/environment level.
- Working it around by java.util.logging programmatically is very inconvenient because it needs to be done before starting each test, or requires all test to be derived from a common "wrapper".
- Working it around by java.util.logging via command line is also very inconvenient because it needs to be done for each test execution environment (either surefire or Eclipse JUnit runner).
- Working it around at the code level by wrapping the input futures with a fallback (or similar) for the known cases requires lots of coding. Also breaks the downstream error handling.
- Working it around by bridging JUL to Slf4j tanks performance.

Can this be avoided? Forking and rebuilding from source just to comment out a logging line is a bit overkill.
 Yes, it could be more than one error (i don't see the log every single time.) Perhaps I was misled by the wording of the error message? :)
 Sounds good. Just to know, what releae of guava this fix is it going to be
scheduled for? I'm not in a rush, but if there's a 18.0.1 soon I'll
probably take it.

On 21 August 2015 at 15:57, Chris Povirk notifications@github.com wrote:

> @lukesandberg https://github.com/lukesandberg now, since I'll end up
> sending him the CL to make this change. Luke, what do you think of the
> message I propose in my previous post? (I will make it conditional so that
> we say something different for an Error.)
> 
> (I'm ignoring the larger logging issue for the moment.)
> 
> —
> Reply to this email directly or view it on GitHub
> https://github.com/google/guava/issues/2134#issuecomment-133453097.

## 

Cheers,
Nico
 No problem, thanks for adding this issue to your roadmap :)

On 21 August 2015 at 18:08, Chris Povirk notifications@github.com wrote:

> An improvement to the log message might be able to be included in release
> 19 if we want. The underlying problem of having too much logging requires
> more thought, so I wouldn't expect anything until at least release 20.
> Sorry :(
> 
> —
> Reply to this email directly or view it on GitHub
> https://github.com/google/guava/issues/2134#issuecomment-133496699.

## 

Cheers,
Nico
 Hello,

just following it up.

This error mostly happens during stress tests. In that case it does appear that it's legitimate for multiple futures in a composite to fail. A specific stress test which wasn't failing before now fails because the inordinate amount of I/O generated by the logging message makes it slow down and time out.

As a workaround, redirecting stderr to /dev/null fixes it.

A similar level of stress could happen in production to an overloaded server. In that case, in practice, the solution (logging) will cause the problem to be worse (increase stress).

Forking the repo just to comment that line out starts to look like an attractive alternative :(

Can you change the code so it logs ONLY if a certain system property is set (and default to the old behaviour)?
 I ended up nobbling JUL altogether at runtime, following some of the advice found here:

http://stackoverflow.com/questions/6077267/java-logging-api-disable-logging-to-standard-output
 > My understanding of the code is that we log only if:
> 
>     any input fails with an Error
> 
> or
> 
>     You called allAsList, and more than one input failed, and the failures were different exceptions

In practice the second case will almost always be true if more than one Future fails. The Exceptions are collected in a ConcurrentHashSet. The problem is that almost no Exception implements equals() and hashCode() and it is highly unlikely that multiple threads throw the same instance of an Exception.

My log gets spammed with SEVERE messages because Futures.allAsList(...).cancel(true) gets called and most of my interrupted threads throw InterruptedExceptions (by design). Guava thinks one InterruptedException is different from the other, resulting in log spam.
  `MoreExecutors.java:541`

``` java
    @Override
    public <V> ListenableScheduledFuture<V> schedule(
        Callable<V> callable, long delay, TimeUnit unit) {
      TrustedListenableFutureTask<V> task = TrustedListenableFutureTask.create(callable);
      ScheduledFuture<?> scheduled = delegate.schedule(task, delay, unit);
      return new ListenableScheduledTask<V>(task, scheduled);
    }
```

`delegate.schedule(Runnable...)` is invoked here instead of the (intended?) `delegate.schedule(Callable<V>...)`. As a result, the `ScheduledListeningDecorator` is unusable for `Callable<?>`.
 No, submitting a `Callable` does not work in the general case. Depending on how the "delegated" executor is implemented (in my case behaviour of `delegate.schedule(Runnable...)` and `delegate.schedule(Callable<V>...)` differ), the return value of the decorated Callable<T> always resolves to null, which is undesired. This behaviour was not present in guava 14.0.x. I believe it was introduced in 15.0.
 Thanks :) If you need assistance on resolving this, I may have some hours to spare during the weekend.
 Even if `delegate.schedule(Callable, ...)` returns the future correctly, the`ScheduledListeningDecorator.schedule(Callable<V> callable...)` wrapping it doesn't (and returns a null future). The reason is that the wrapper _doesn't_ invoke `delegate.schedule(Callable, ...)` at all, when it should.

I'll put together a repro test and send it to you.
 Cannot reproduce the "null" issue with 19-SNAPSHOT in a simple test. Conditions must be more subtle. I can dig in a bit but probably have to get back to the office to narrow it down.

A simpler failure can be synthesized as follows:

``` java
        ScheduledThreadPoolExecutor delegate = new ScheduledThreadPoolExecutor(1) {
          @Override
            public <V> ScheduledFuture<V> schedule(Callable<V> callable,
                    long delay, TimeUnit unit) {
                return super.schedule(callable, delay, unit);
            }

            @Override
            public ScheduledFuture<?> schedule(Runnable command, long delay,
                    TimeUnit unit) {
                //behavior may be different for Runnable
                throw new IllegalArgumentException("Schedule of Runnable not supported");
            }
        };
        // this one works
        delegate.schedule(Callables.returning(42), 1, TimeUnit.MILLISECONDS);
        // this one throws!
        ListeningScheduledExecutorService service = listeningDecorator(delegate);
        service.schedule(Callables.returning(42), 1, TimeUnit.MILLISECONDS);
```

As you wrote earlier, this violates the decorator contract (the decorator and the delegate are not interchangeable).
 More investigation here.

You were right about the decorator itself not returning null. The real case is a bit more convoluted. Long story short, we have "special" schedulers in which we keep track of the executed/submitted tasks. The `null` comes as a side effect of those submitted tasks records.

Here's a repro case which mimics the problem (our original code is a lot more complicated, but this is another story).

This behaviour does not appear in `guava 14`

``` java
public void testListeningDecorator_customSchedulerFailure()
            throws Exception {
        // we keep track of all the tasks this executor has completed
        final List<FutureTask<?>> taskList = Collections
                .synchronizedList(new ArrayList<FutureTask<?>>());
        ScheduledThreadPoolExecutor delegate = new ScheduledThreadPoolExecutor(
                1) {
            @Override
            public <V> ScheduledFuture<V> schedule(Callable<V> callable,
                    long delay, TimeUnit unit) {
                final FutureTask<V> task = new FutureTask<V>(callable);
                taskList.add(task);
                return super.schedule(new Callable<V>() {
                    @Override
                    public V call() throws Exception {
                        task.run();
                        return task.get();
                    }
                }, delay, unit);
            }

            @Override
            public ScheduledFuture<?> schedule(final Runnable command,
                    long delay, TimeUnit unit) {
                final FutureTask<Void> task = new FutureTask<Void>(command,
                        null);
                taskList.add(task);
                return super.schedule(new Runnable() {
                    @Override
                    public void run() {
                        task.run();
                    }
                }, delay, unit);
            }
        };

        ListeningScheduledExecutorService service = listeningDecorator(delegate);

        // we do the same thing twice. 
        // This goes through the decorator  
        ListenableFuture<Integer> future = service.schedule(
                Callables.returning(42), 1, TimeUnit.MILLISECONDS);
        // This bypasses the decorator
        ScheduledFuture<Integer> bypass = delegate.schedule(Callables.returning(41), 1, TimeUnit.MILLISECONDS);

        assertThat(future.get()).isEqualTo(42);
        assertThat(bypass.get()).isEqualTo(41);

        assertTrue(future.isDone());
        assertListenerRunImmediately(future);
        assertEquals(0, delegate.getQueue().size());

        assertThat(taskList).hasSize(2);

        assertThat(taskList.get(1).get()).isEqualTo(41);
        assertThat(taskList.get(0).get()).isEqualTo(42); // boom!
    }
```
 You're welcome :)

That's the very inelegant workaround I've put in place - but it really
looks awful and it's not at all general.

The main problem is that the decorator is not a decorator but the
definition of the interface suggests otherwise. If it helps, it started
failing when I upgraded from Guava 14 to Guava 18. At that point it was
behaving "as expected".

To avoid bad surprises, it should follow a completely different contract
and as such implement a different interface. Anything short of that is
going to cause confusion at best.

On 18 August 2015 at 16:01, Chris Povirk notifications@github.com wrote:

> Thanks for the investigation.
> 
> For starters, we should document that this "decorator" doesn't always
> forward calls to the corresponding methods.
> 
> Going beyond that is likely to be tricky. Is there any chance that your schedule(Runnable,
> ...) method could check whether the input is already a Future and avoid
> wrapping in that case?
> 
> —
> Reply to this email directly or view it on GitHub
> https://github.com/google/guava/issues/2133#issuecomment-132240673.

## 

Cheers,
Nico
 Probably not necessary.

In this specific case the unwanted behaviour was triggered by a Guava
upgrade.

In the light of these results, it's not worth reworking the innards of the lib just
for this one corner case, as long as there is a clear and well defined
alternative.

But now it's my turn to be confused

> This implies that the returned ListeningScheduledExecutorService **never
> calls the delegate's** submit, invokeAll, and invokeAny methods, so any
> special handling of tasks must be implemented in the delegate's execute
> method or by wrapping the returned ListeningScheduledExecutorService.

Is it still the case? I'm pretty sure it wasn't the case in Guava 14. It
appears that we relied on a specific implementation detail (submit<X>
delegates to submit<X>) and assumed it was part of the contract.

Adding a caveat clause to the documentation in the tune of "while in older
versions of Guava this appeared to be not the case, the behaviour of the
wrapper is no longer guaranteed to mirror the behaviour of the delegated
executor" might help, perhaps?

On 20 August 2015 at 17:19, Chris Povirk notifications@github.com wrote:

> OK, it looks like we do document this:
> 
> Creates an ExecutorService whose submit and invokeAll methods submit
> ListenableFutureTask instances to the given delegate executor. Those
> methods, as well as execute and invokeAny, are implemented in terms of
> calls to delegate.execute.
> 
> http://google.github.io/guava/releases/18.0/api/docs/com/google/common/util/concurrent/MoreExecutors.html#listeningDecorator(java.util.concurrent.ExecutorService)
> 
> It's possible that we could change that behavior, but I'm not sure what
> the implementation would look like. It seems like what you ultimately want
> is for the Future returned by the delegate to match the Future returned
> by the decorator, but keeping two Future instances in sync is something
> that's impossible to guarantee in general. We could maybe get it closer,
> and that might be good enough in your case, but we already have a
> workaround there, so I hesitate to complicate things. (I think we've
> already had bugs in listeningDecorator.)
> 
> —
> Reply to this email directly or view it on GitHub
> https://github.com/google/guava/issues/2133#issuecomment-133064805.

## 

Cheers,
Nico
  Missed several video MimeTypes in MediaType class:

```
video/x-flv
video/3gpp
video/3gpp2
```

and some audio types:

```
audio/basic
audio/L24
audio/aac
audio/vorbis
audio/x-ms-wma
audio/x-ms-wax
audio/vnd.rn-realaudio
audio/vnd.wave
```
 I found some other missed types:

image

```
image/pjpeg: Progressive JPEG
image/vnd.wap.wbmp: WBMP
```

text

```
text/cmd: commands
text/php: PHP scripts
```

message

```
message/http (RFC 2616)
message/imdn+xml: IMDN (RFC 5438)
message/partial: E-mail (RFC 2045 and RFC 2046)
message/rfc822: E-mail; EML files, MIME files, MHT files, MHTML files (RFC 2045 and RFC 2046)
```

model

For 3D models

```
model/example: (RFC 4735)
model/iges: IGS files, IGES files (RFC 2077)
model/mesh: MSH files, MESH files (RFC 2077), SILO files
model/vrml: WRL files, VRML files (RFC 2077)
model/x3d+binary: X3DB files
model/x3d+vrml: X3DV VRML files
model/x3d+xml: X3D XML files
```

x-pkcs (https://en.wikipedia.org/wiki/PKCS)

```
application/x-pkcs12: p12 files
application/x-pkcs12: pfx files
application/x-pkcs7-certificates: p7b files (https://tools.ietf.org/html/rfc2315.html#section-9.1)
application/x-pkcs7-certificates: spc files
application/x-pkcs7-certreqresp: p7r files
application/x-pkcs7-mime: p7c files
application/x-pkcs7-mime: p7m files
application/x-pkcs7-signature: p7s files
```

application

```
application/EDI-X12: EDI X12 (RFC 1767)
application/EDIFACT: EDI EDIFACT (RFC 1767)
application/soap+xml: SOAP (RFC 3902)
application/x-woff: Web Open Font Format
application/xml-dtd: DTD (RFC 3023)
application/xop+xml: XOP
application/x-bittorrent: BitTorrent
application/x-tex: TeX
```

x

```
application/x-dvi: DVI
application/x-latex: LaTeX files
application/x-font-ttf: TrueType (not registered, but the most frequently used)
application/x-stuffit: StuffIt
application/x-rar-compressed: RAR
text/x-jquery-tmpl: jQuery templates
application/x-javascript:
```
  I am using the LoadingCache in a highly concurrent system and I observed some behavior that I am not sure is intended (to me it looks like a bug :) ). I wrote the following sample code to illustrate the problem :

``` java
public static void main(String[] args) {
        final LoadingCache<String, Object> cache = 
            CacheBuilder.newBuilder()
                                 .expireAfterAccess(65, TimeUnit.MINUTES)
                                 .build(new CacheLoader<String, Object>(){

                                                    @Override
                                                     public Object load(String arg0) throws Exception {
                                                                Object obj = new Object();
                                                                    System.out.println("creating object: " + obj);
                                                                    return obj;
                                                     }
                                  });


        int threadCount = 600;
        final String key = "hello/world";
        Runnable task = new Runnable() {

            @Override
            public void run() {
                try {
                    Object valueFromUnchecked = cache.getUnchecked(key);
                    if (valueFromUnchecked == null) {
                        System.out.println(Thread.currentThread().getName() + " valueFromUnchecked is null!!!");
                    }

                    Object value = cache.getIfPresent(key);
                    if (value == null) {
                        System.out.println(Thread.currentThread().getName() + " value is null!!!");
                    }

                    if (value != valueFromUnchecked) {
                        System.out.println(String.format(Thread.currentThread().getName() + "valueFromUnchecked:%s, value:%s", valueFromUnchecked, value));
                    }
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
        };

        for (int i = 0; i < threadCount; i++) {
            Thread t = new Thread(task);
            t.setName("thread-" + i);
            t.start();
        }
```

Sometimes thing are fine, I don't get the output of "<thread name> value is null!!!" lines and some times I do. I never get the output of "valueFromUnchecked from getUnchecked is null!!!"

My understanding of from LoadingCache java doc, is that if  `getUnchecked()` does not return null then `getIfPresent()` shouldn't return null as well; given that the cache has not expired yet. 
 A cursory glance...
- Its surprising that this fails
- Expiration isn't needed to reproduce this
- It seems that StrongValueReference returns null, though the value later materializes
- Inserting a memory fence resolves the issue (`Unsafe.fullFence()`)
- Caffeine passes

It seems like final field visibility rules aren't working as expected, since that should avoid reordering and a SVR should never return null. Probably needs to be tested on JDK6/7 for good measure. Nothing in the code looks obviously wrong fence-wise.
 Actually the statement on SVR is wrong and just some confusion when debugging. The problem is related to the `if (count != 0)` guard clause. If the cache is pre-populated with a different entry then the test passes.
 thanks for looking into this. Just FYI I compiled the above code into jvm 7 class file (because my prof system runs jvm 7). But I did run the code in both jvm7 and jvm8 both produced same result. 
 Okay, so what is happening is that when `LoadingValueReference#waitForValue()` returns the `count = 0`. This is because the computing thread doesn't increment it until after its published through the value reference. This lets the reader see the value immediately, but before the count changes. Then when the reader immediately performs a `getIfPresent` the count is still zero and it receives null due to an early exit. When the computing thread finally increments the count then everything works normally. This means that one could argue that the expected happens-before relationship is being violated.

The best approach would be to simply remove the guard conditions. I don't remember when they were introduced. Most likely Bob added them in the original computing map and, since we inherited that, we never thought about his optimization. I don't think it buys anything and a load barrier shouldn't be required for correctness.

Sorry that this wasn't immediately obvious. Its been a very long time since I've reasoned through this code. Unfortunately I don't know if this will be fixed will be fixed any time soon.
 Actually the guards might have been okay when Bob added them, and an oversight when we introduced `LoadingCache`. When we used the `Map` interface there was no way to peek into the cache, as a `get` was computing. So that's when it was probably introduced to mirror the style in other methods and we didn't consider that interaction.
 I can't reproduce it with master and the test program. Ran with TestNG `@Test(threadPoolSize = 10, invocationCount = 1000)`. I haven't looked into your analysis though.
 Sorry, had a typo. reproduced.
 so ... when will the fix of the issue be release? looks like it was intended, then removed from 20.0 release?  Guava tests build is failing on windows. PFB the failure snippet from surefire-reports. 

guava-tests/target/surefire-reports/com.google.common.base.ThrowablesTest.txt:Tests run: 30, Failures: 1, Errors: 0, Skipped: 0, Time elapsed: 0.026 sec <<< FAILURE!
Binary file guava-tests/target/surefire-reports/com.google.common.io.ResourcesTest.txt matches
guava-tests/target/surefire-reports/com.google.common.reflect.ClassPathTest.txt:Tests run: 32, Failures: 5, Errors: 0, Skipped: 0, Time elapsed: 0.463 sec <<< FAILURE!

And here is the text for those two files
## Test set: com.google.common.base.ThrowablesTest

Tests run: 30, Failures: 1, Errors: 0, Skipped: 0, Time elapsed: 0.026 sec <<< FAILURE!
testGetStackTraceAsString(com.google.common.base.ThrowablesTest)  Time elapsed: 0.002 sec  <<< FAILURE!
junit.framework.AssertionFailedError: null
        at junit.framework.Assert.fail(Assert.java:47)
        at junit.framework.Assert.assertTrue(Assert.java:20)
        at junit.framework.Assert.assertTrue(Assert.java:27)
        at com.google.common.base.ThrowablesTest.testGetStackTraceAsString(ThrowablesTest.java:498)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
        at java.lang.reflect.Method.invoke(Method.java:606)
        at junit.framework.TestCase.runTest(TestCase.java:168)
        at junit.framework.TestCase.runBare(TestCase.java:134)
        at junit.framework.TestResult$1.protect(TestResult.java:110)
        at junit.framework.TestResult.runProtected(TestResult.java:128)
        at junit.framework.TestResult.run(TestResult.java:113)
        at junit.framework.TestCase.run(TestCase.java:124)
        at junit.framework.TestSuite.runTest(TestSuite.java:243)
        at junit.framework.TestSuite.run(TestSuite.java:238)
        at org.junit.internal.runners.JUnit38ClassRunner.run(JUnit38ClassRunner.java:83)
        at org.apache.maven.surefire.junit4.JUnit4TestSet.execute(JUnit4TestSet.java:35)
        at org.apache.maven.surefire.junit4.JUnit4Provider.executeTestSet(JUnit4Provider.java:115)
        at org.apache.maven.surefire.junit4.JUnit4Provider.invoke(JUnit4Provider.java:97)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
        at java.lang.reflect.Method.invoke(Method.java:606)
        at org.apache.maven.surefire.booter.ProviderFactory$ClassLoaderProxy.invoke(ProviderFactory.java:103)
        at com.sun.proxy.$Proxy0.invoke(Unknown Source)
        at org.apache.maven.surefire.booter.SurefireStarter.invokeProvider(SurefireStarter.java:150)
        at org.apache.maven.surefire.booter.SurefireStarter.runSuitesInProcess(SurefireStarter.java:91)
        at org.apache.maven.surefire.booter.ForkedBooter.main(ForkedBooter.java:69)

---
## Test set: com.google.common.reflect.ClassPathTest

Tests run: 32, Failures: 5, Errors: 0, Skipped: 0, Time elapsed: 0.463 sec <<< FAILURE!
testGetClassPathEntry(com.google.common.reflect.ClassPathTest)  Time elapsed: 0 sec  <<< FAILURE!
junit.framework.AssertionFailedError: expected:file:/C:/usr/test/dep.jar but was:file:/usr/test/dep.jar
        at junit.framework.Assert.fail(Assert.java:47)
        at junit.framework.Assert.failNotEquals(Assert.java:283)
        at junit.framework.Assert.assertEquals(Assert.java:64)
        at junit.framework.Assert.assertEquals(Assert.java:71)
        at com.google.common.reflect.ClassPathTest.testGetClassPathEntry(ClassPathTest.java:175)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
        at java.lang.reflect.Method.invoke(Method.java:606)
        at junit.framework.TestCase.runTest(TestCase.java:168)
        at junit.framework.TestCase.runBare(TestCase.java:134)
        at junit.framework.TestResult$1.protect(TestResult.java:110)
        at junit.framework.TestResult.runProtected(TestResult.java:128)
        at junit.framework.TestResult.run(TestResult.java:113)
        at junit.framework.TestCase.run(TestCase.java:124)
        at junit.framework.TestSuite.runTest(TestSuite.java:243)
        at junit.framework.TestSuite.run(TestSuite.java:238)
        at org.junit.internal.runners.JUnit38ClassRunner.run(JUnit38ClassRunner.java:83)
        at org.apache.maven.surefire.junit4.JUnit4TestSet.execute(JUnit4TestSet.java:35)
        at org.apache.maven.surefire.junit4.JUnit4Provider.executeTestSet(JUnit4Provider.java:115)
        at org.apache.maven.surefire.junit4.JUnit4Provider.invoke(JUnit4Provider.java:97)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
        at java.lang.reflect.Method.invoke(Method.java:606)
        at org.apache.maven.surefire.booter.ProviderFactory$ClassLoaderProxy.invoke(ProviderFactory.java:103)
        at com.sun.proxy.$Proxy0.invoke(Unknown Source)
        at org.apache.maven.surefire.booter.SurefireStarter.invokeProvider(SurefireStarter.java:150)
        at org.apache.maven.surefire.booter.SurefireStarter.runSuitesInProcess(SurefireStarter.java:91)
        at org.apache.maven.surefire.booter.ForkedBooter.main(ForkedBooter.java:69)

testResourceScanner(com.google.common.reflect.ClassPathTest)  Time elapsed: 0.279 sec  <<< FAILURE!

-Ankush
 No problem..!:)
Let me know if you want me to fix this.
 @kevinb9n, I understand that you cannot run any tests on Windows internally, but I've noticed that for the Github-hosted version of Guava you use Travis CI a lot (I don't know if you also use Travis internally).

This makes me wonder if Google policy would allow you to use additional external CI services, and if so whether you'd consider using [AppVeyor](https://www.appveyor.com).

It seems to be a rather good complement to Travis, as it allows one to run CI tasks on Windows VMs, and it seems to be free for open source projects.

What are your thoughts on this?
 On a related note, is the bug in `ThrowablesTest::testGetStackTraceAsString`currently being worked on?

If not, then I have a relatively trivial fix for the bug which I'd be happy to submit a Pull Request for.
 (Although I've already made the 'fix' on my fork, I understand if it simply does not meet Guava's standards and gets rejected. :smile:)
 @cpovirk, did you mean to say "jbduncan got...", or did you mean "jbduncan, (I) got..."?
 Thanks @cpovirk, it's an honour. :)
  Iterating over the whole ContiguousSet seems wrong.
RegularContiguousSet.equals() does not use Sets.equalsImpl() either but instead compares the DiscreteDomain and first+last.
 @lowasser: Of course you're right :/ Sorry, should've thought harder.
 > not sure whether
> ContiguousSet.hashCode() is called enough to be worth worrying about or not

It was in my case, and the next silly idea was to cache the hashCode. I've opted for storing the Ranges instead, which makes a lot more sense anyway.
  You can view any JavaDoc jar hosted on Maven Central using [javadoc.io](http://www.javadoc.io/doc/com.google.guava/guava-testlib/19.0-rc1) or browse the [archive directly](https://oss.sonatype.org/service/local/repositories/releases/archive/com/google/guava/guava-testlib/19.0-rc1/guava-testlib-19.0-rc1-javadoc.jar/!/index.html) in Sonatype.
 I use a custom badge to point to the JavaDoc, though that means manually incrementing the version label. Then you can point to either site as the destination, such as the repository if you have concerns about javadoc.io.

You could do the following. The only quirk is that the convention with dashes breaks for `19-rc1`.

[![JavaDoc](https://img.shields.io/badge/javadoc-19.0.rc1-brightgreen.svg)](http://www.javadoc.io/doc/com.google.guava/guava-testlib/19.0-rc1)

``` markdown
[![JavaDoc](https://img.shields.io/badge/javadoc-19.0.rc1-brightgreen.svg)](http://www.javadoc.io/doc/com.google.guava/guava-testlib/19.0-rc1)
```
  An algorithm similar to `java.lang.Math.addExact()` should be used to compute `offset + length`  and fallback to `Integer.MAX_VALUE` or `Long.MAX_VALUE` in case of overflow. 
There is 3 occurrences of this possibly overflowing addition in `ByteSource.java`.

I found this bug because I regularly slice bytesources with a length equals to Long.MAX_VALUE.
 thanks!
while not a regression, I think the addition `offset + length` could also overflow in SlicedByteSource.sizeIfKnown()
  I would like to have a new collection type like RangeMap, but instead of Range, I would like to retrieve values using Predicate. For instance, assume we are writing class which generates random values for given type.
If we use ordinary map we have to duplicate keys:

``` java
  private final ImmutableMap<Class<?>, Randomizer> RANDOMIZERS = ImmutableMap.<Class<?>, Randomizer>builder()
          .put(byte.class, byteRandomizer)
          .put(Byte.class, byteRandomizer)
          .put(short.class, shortRandomizer)
          .put(Short.class, shortRandomizer)
          .put(Collection.class, collectionRandomizer)
          .put(List.class, collectionRandomizer)
          .put(ArrayList.class, collectionRandomizer)
          //...
          .build();

   public Object getRandomValueOf(Class<?> type) {
        Randomizer randomizer = RANDOMIZERS.get(type);

        if (randomizer == null) {
            randomizer = new DefaultRandomizer(this);
        }

        return randomizer.random(type);
    }
```

If we were able to use Predicates this code would be shorter:

``` java
 private final PredicateMap<Class<?>, Randomizer> RANDOMIZERS = MutablePredicateMap.<Class<?>, Randomizer>builder()
            .put(Predicates.<Class<?>>in(Arrays.asList(byte.class, Byte.class)), byteRandomizer)
            .put(Predicates.<Class<?>>in(Arrays.asList(short.class, Short.class)), shortRandomizer)
            .put(isEnum(), enumRandomizer)
            .put(instanceOf(Collection.class), collectionRandomizer)
            .build();
```

Why did I use maps? I think it's better than long if-else operators.
 @lowasser  It's maybe because I saw a lot of long ugly if-else chains in current project :) Yes, you are right it's weird and well refactored if-else chain can resolve my problems and it would be better.
  Ensures that the correct removal notification is published by `Segment#clear()`. Previously the operation was using the cause `EXPLICIT` when pending maintenance for expiration or collection would take precedence.

For additional safety, publishing notifications require passing a strong reference of both the key and value. This ensures that compiler reordering and races with the GC do not result in a reference collection and publishing a null value. This may not have been a problem due to happens-before ordering across methods, but simplifies away having to make these assumptions.

In addition to adding an expiration test, verified by removing the workaround in Caffeine's fixture. The tests pass with the changes and fail with 19-rc1.
  It would be nice if there was a way to simplify a Windows path - i.e. one separated by `\` instead of `/`. Whether the existing `Files.simplifyPath` method is modified to use `File.separator{Char}` or whether a new method is required I don't know.

As a work around `Files.simplifyPath(path.replace('\\', '/')).replace('/', '\\')` would work.
  would it be possible to ensure `InternetDomainName` rolls out w/ the latest version of the PSL (or as close to it as you can get) before release?

i don't know when the official release is slated for, but according to this site, https://iwantmyname.com/domains/new-gtld-launch-dates, there are new tlds on the horizon and depending on how quickly mozilla updates, it'd be nice to see as many of these included in the next release.

it'd also be great to see something happen w/ #1123 /  #475 
 yes, i believe so.
 awesome, thank you!!

do you have a target date (i realize it could change) for the 19.0 release?
 I will second the vote for #1123, _enthusiastically_.

I'm using this as part of an application feature that runs comparisons of various competing websites. Having a static list of TLDs per Guava release means that any new public suffix created since the last release (in this case, over half a year back) will trigger an `IllegalStateException` when it is used with `InternetDomainName.topPrivateDomain()`.

New TLDs are being released more frequently than in the past, and I cannot imagine that problems arising from a static, infrequently-updated list are unique to my own use cases.  The ability to dynamically update the TLD list in Guava would be an immense improvement to this area of usability.
  While I understand Kevin's point, the fix to this issue would be 15 minutes of thinkng, then _one_ method, and possibly a few tests. An hour, maybe two, an ideal candidate for a lazy Friday afternoon when nothing really productive gets done?

I'm sorry if this sounds inconsiderate, I do not and can not know how much work there is to be done by your team. This shows that you might want to post a status update and an optional roadmap, somewhere public ;).
  Since Guava is dependency-free, you could publish a sibling artifact using the 'aar' packaging [whose format](http://tools.android.com/tech-docs/new-build-system/aar-format) allows embedding proguard rules.

Android users wanting the automatic rules would specify a dependency like

``` groovy
compile 'com.google.guava:guava:19.0@aar'
```

instead of just

``` groovy
compile 'com.google.guava:guava:19.0'
```
 (Dependency-free is important because using a package qualifier on a dependency skips the deployed `pom.xml` for looking up transitive dependencies)
 Right. Any build system parsing the `pom.xml` should ignore those anyway.
 It would be great if there as a "it just works" solution. It all looks so good at first when a simple

```
compile 'com.google.guava:guava:19.0'
```

gives your project all the Guava goodness, but come time to build a real-world APK with

```
        minifyEnabled true
        shrinkResources true
```

the fun ends due to [all the errors](http://stackoverflow.com/q/9120338/145173). The error messages are obtuse and don't even provide much clue that Guava's the cause.
 Is this dead? The proguard rules in the wiki seem terribly out of date. @cpovirk Any chance you could start including it in the public repo? @cpovirk any updates?  ![jar](https://cloud.githubusercontent.com/assets/7439619/8873965/a6db4cee-3229-11e5-9d75-20f2c128e269.png)
I am using Guava v 17.0 dependency in Maven and Cassandra connection is established successfully.
But when I run same JAR on Hadoop 2.0.0-CDH4.3.1, It throws me error 

java.lang.NoSuchMethodError: com.google.common.util.concurrent.Futures.withFallback(Lcom/google/common/util/concurrent/ListenableFuture;Lcom/google/common/util/concurrent/FutureFallback;Ljava/util/concurrent/Executor;)Lcom/google/common/util/concurrent/ListenableFuture;

When I look at the Guava v17.0 JAR I cant find Futures.withFallback static method. 
Is it related to Hadoop's version compatibility with Guava as Cassandra got connected when not running on Hadoop.
 I'm using guava version 14.0.1.
I'm using storm with cassandra and i came accross the same issue. I discovered that my storm  was using guava-13.0 which overrided the guava version included in cassandra driver while lauching my topology. 
To fix it i removed the guava jar (version:13.0) from my storm lib directory and everything worked fine
 kabanfaly: Only your strategy worked out for me. I had to replace this library with the updated on in some 7-8 locations in Hadoop.
 If you are using Maven, you coud create a "fat jar" with the dependencies of guava14 (or higher) and override (shade) the package of the dependencies with conflicts, in this case "com.google" with for example "hidden.google". Maven has a Shade plugin to do that. Add this lines to your pom file:`
<build>
	<finalName>nameoffatjar</finalName>
	<plugins>
		<!-- Maven Shade Plugin -->
		<plugin>
			<groupId>org.apache.maven.plugins</groupId>
			<artifactId>maven-shade-plugin</artifactId>
			<version>2.3</version>
			<executions>
				<!-- Run shade goal on package phase -->
				<execution>
					<phase>package</phase>
					<goals>
						<goal>shade</goal>
					</goals>
					<configuration>
						<transformers>
							<!-- add Main-Class to manifest file -->
						</transformers>
						<relocations>
							<relocation>
								<pattern>com.google</pattern>
								<shadedPattern>hidden.google</shadedPattern>
							</relocation>
						</relocations>
					</configuration>
				</execution>
			</executions>
		</plugin>
	</plugins>
</build>
`  Maps.transformValues()
nonsupport key

``` java
// Map<String,String> ——> Map<byte[],byte[]>
HashMap<String, String> fromHashMap = new HashMap<String, String>();
                HashMap<byte[], byte[]> target =
                    Maps.transformValues(fromHashMap, new Function<String, byte[]>() {
                        public byte[] apply(String input){
                            return input.getBytes();
                        }
                    });

// commons-collection
Map map = MapUtils.transformedMap(hash, new Transformer() {
                    public Object transform(Object input){
                        return ((String) input).getBytes();
                    }
                }, new Transformer() {
                    public Object transform(Object input){
                        return ((String) input).getBytes();
                    }
                });
```
 Mapping keys can be supported efficiently as a view, if the mapping is bidirectional.
  Hi, I’ve searched through Guava API, looking for a random string generator, but found none. And I’ve looked at [this thread](http://stackoverflow.com/questions/20782919/does-guava-have-a-method-to-generate-random-strings) which suggested using the <code>BaseEncoding</code> in some way for your purposes. I’m not a big fan of this solution. For one thing you have to know BASE64 very well so as not to make any mistakes, such as forgetting to omit paddings. Moreover, it’s not an instant solution as most APIs usually do, you have to think twice to come up with the idea. On the other hand, the solution is too detailed to allow flexibility, consider the following cases:
- What if some chars are not supposed to appear in the string. I might want to ignore ‘I’ and ‘l’ for they look very alike.
- There is no way to generate a unicode string.
- What if I want all letters in their capital forms?

You have to write your own code to cover the cases above. There are other issues to consider:
- There’s definitely a better solution with better performance than using BaseEncoding.
- There’s no formal proof to the randomness of strings generated.

Personally, I often come across requirements for random strings in various formats, and I see a good reason for Guava to provide dedicated APIs for generating random strings. The fluid-style can perfectly fit into this situation. Please let me know your thoughts on this issue.
 See
http://stackoverflow.com/questions/41107/how-to-generate-a-random-alpha-numeric-string

Construct a BigInteger with N bits randomly obtained from a Random source
and encode it in Base-32.

Cheers,

Thiago Kronig

On Tue, Jul 21, 2015 at 11:37 AM lvxiang notifications@github.com wrote:

> Hi, I’ve searched through Guava API, looking for a random string
> generator, but found none. And I’ve looked at this thread
> http://stackoverflow.com/questions/20782919/does-guava-have-a-method-to-generate-random-strings
> which suggested using the BaseEncoding in some way for your purposes. I’m
> not a big fan of this solution. For one thing you have to know BASE64 very
> well so as not to make any mistakes, such as forgetting to omit paddings.
> Moreover, it’s not an instant solution as most APIs usually do, you have to
> think twice to come up with the idea. On the other hand, the solution is
> too detailed to allow flexibility, consider the following cases:
> - What if some chars are not supposed to appear in the string. I might
>   want to ignore ‘I’ and ‘l’ for they look very alike.
> - There is no way to generate a unicode string.
> - What if I want all letters in their capital forms?
> 
> You have to write your own code to cover the cases above. There are other
> issues to consider:
> - There’s definitely a better solution with better performance than
>   using BaseEncoding.
> - There’s no formal proof to the randomness of strings generated.
> 
> Personally, I often come across requirements for random strings in various
> formats, and I see a good reason for Guava to provide dedicated APIs for
> generating random strings. The fluid-style can perfectly fit into this
> situation. Please let me know your thoughts on this issue.
> 
> —
> Reply to this email directly or view it on GitHub
> https://github.com/google/guava/issues/2113.
 @thiagokronig checked that before, still not solving all the problems
 [This answer](http://stackoverflow.com/a/157202/581205) uses no `BigInteger` and is pretty general. It also seems to be optimal (except for using `StringBuilder` where `char[]` would do).
 @Maaartinus I don't think it's general enough as you have to redefine "AB" constantly. Except for StringBuilder, it might not be optimal in some cases, i.e, if all you want is a string of decimal digits, the following code might be faster:

```
Random rng = new Random();
char[] str = new char[length];
for(int i = 0; i < length; i ++)
    str[i] = (char) ('0' + rng.nextInt(10));
return new String(str);
```
 @ogregoire like your Rule and Ruler idea, almost same as what I have in my mind. You might consider taking the fluid-style by introducing something like a RuleBuilder. 
 @ogregoire agreed
 +1
 +1. I want to get rid of Apache's _commons-lang3_ but I need `org.apache.commons.lang3.RandomStringUtils`
 +1
 FWIW, this all seems easy enough to do with streams.  I threw together this little snippet to print 10 strings of 10 random ASCII (though you could choose what ever codepoints you want) characters:

```
Random random = new Random();
Stream<String> randomStrings =
    Stream.generate(
        () ->
            random
                .ints('a', 'z')
                .limit(10)
                .collect(
                    StringBuilder::new,
                    (builder, codePoint) -> builder.appendCodePoint(codePoint),
                    StringBuilder::append)
                .toString());
randomStrings.limit(10).forEach(System.out::println);
```

Filtering, transforming to upper case, etc. are all easy enough to implement as further stream operations.  Given that it's straightforward enough to get a random string from the APIs in the JDK, I'm having a hard time imagining that this is such a common problem as to warrant its own, specific API in Guava -- a specific API would be more readable, but probably too niche. I just searched "random string java" in Google and got 381k hit. Doesn't seem very niche to me. We generally judge need based on evidence within Google's (very large) code base, not Google searches.  By that metric, there is a much stronger need for an API to generate random cats given that "random cat java" produces 940k results. :) Okay, you got me there. I'll try to find a good API to generate random cats
then ;-)

More seriously, there are implementations that are fed here, there is a
request, there is a real need from several of your user. All that's left to
the Guava team is to review and to accept one of the PRs. Leave it in beta
for a few releases and see if it's used. If not, drop it.

Le mar. 10 janv. 2017 à 04:40, Gregory Kick <notifications@github.com> a
écrit :

> We generally judge need based on evidence within Google's (very large)
> code base, not Google searches. By that metric, there is a much stronger
> need for an API to generate random cats given that "random cat java"
> produces 940k results. :)
>
> —
> You are receiving this because you were mentioned.
> Reply to this email directly, view it on GitHub
> <https://github.com/google/guava/issues/2113#issuecomment-271478489>, or mute
> the thread
> <https://github.com/notifications/unsubscribe-auth/AAotWmLvXnfODqgRVqNWd-QUYbd1l_etks5rQv2ogaJpZM4FczoY>
> .
>
 Oh, by the way, @gk5885, have you seen any 'z' printed by your snippet?

There we go! The problem is more complex than one can expect and errors happen so easily. For working on the Guava team, you're probably a good programmer and it was rather easy for you to make that snippet. But check everywhere else, the problem is not a trivial one. At least not as trivial as you think. Working with randomness is hard because it's not easily testable, and bugs come quick (yup, even for a talented programmer like you as we just saw ;).

I'm kind of sad that the only metric for Guava is "we see it often in our codebase". Another good one would be "it seems simple, but it's a magnitude harder than that". @ogregoire I'd say that what you wrote is a generator for passwords rather than for arbitrary strings. At least that how it'd be probably used. *But then plain `Random` must not be the default as it's insecure.*

I guess, it could get nearly as popular as random java cats, except for that there are many options you didn't cover. (*)
- For example, I'm using a much simpler generator, but I need variable string length.
- Some people might require maximum speed and this could be achieved by passing `ThreadLocalRandom.current()` to `next` (with your generator they'd need to keep an instance per thread).
- I recall there was a site requiring a password containing two to four digits (and some other chars) or something like this. Crazy, I know.

(*) And nobody can cover, as there are just too many strange wishes. @Maaartinus Yes, I know! I have somewhere under my elbow a password generator that can easily take those cases into account, but that's not the point. I tried to check most of the use cases as seen on Stack Overflow. And while the options you mention aren't unknown, they are much more rare (though the `next(Random)` always was my personal favorite, it's a burden on the user).

But then, this is a free software (as in speech) and discussions and improvements are welcome, I guess! I never said I hold the one truth and if I overlooked at some things, like the `SecureRandom` as default, I humbly ask to have them pointed so I can suggest a better alternative.

@jrtom It's basically the only metric we hear of in the past few years. Yes, there are others, but that aspect is rather opaque, from a point of view external to Google.  # Abstract

goal of this PR is to replace

```
byte[] buf = new byte[BUF_SIZE];
ByteArrayOutputStream baos = new ByteArrayOutputStream();
```

with

```
Buffers.Lease<byte[]> lease = Buffers.leaseByteArray();

try{
   byte[] buffer = lease.getBuffer();
} finally {
    lease.returnLease();
}

Buffers.Lease<ByteArrayOutputStream> lease = Buffers.leaseByteArrayOutputStream();

try{
   ByteArrayOutputStream baos = lease.getBuffer();
} finally {
    lease.returnLease();
}


```

in all cases where byte-array or ByteArrayOutputStreams are used method-internal, this way avoiding unneccessary memory allocation, increasing performance and enhancing the memory profile. 
# Implementation

[ThreadLocalBuffers](https://github.com/berndhopp/guava/blob/master/guava/src/com/google/common/io/
Buffers.java) is the manager of thread-local byte-arrays and FastByteArrayOutputStreams. It uses [SoftReferences](https://docs.oracle.com/javase/6/docs/api/java/lang/ref/SoftReference.html) or [WeakReferences](https://docs.oracle.com/javase/6/docs/api/java/lang/ref/WeakReference.html) to store buffers, this way enabling Garbage Collection to collect the buffers when the system runs low on memory. All allocations of byte[] or ByteArrayOutputStream in where the allocated byte[]/BAOS is not the returned value of the method have been replaced with calls to ThreadLocalBuffers. 
ByteSource.contentEquals was challenging, because it used not one but two byte-arrays for buffering, so I used two ByteBuffers that wrap around the upper and lower part of the thread-local buffer, thereby mimicking the two buffers.
# Results

The microbenchmarks show that avoiding buffer allocation yields a significant performance boost. Tests that did not show significant differences are left out. There have been no tests where performance dropped more than 2.00%. 

| tested method | bytes copied | runtime w/ TL buffers | runtime w/out TL buffers | performance increase in % |
| --- | --- | --- | --- | --- |
| ByteStreams.copy | 10 | 105569 | 681130 | 545,2 |
| ByteStreams.copy | 100 | 107411 | 698152 | 549,98 |
| ByteStreams.copy | 10000 | 840354 | 1186307 | 41,17 |
| ByteStreams.readBytes | 10 | 68917 | 633365 | 819,03 |
| ByteStreams.readBytes | 100 | 69802 | 660336 | 846,01 |
| ByteStreams.readBytes | 10000 | 360357 | 934588 | 159,35 |
| ByteStreams.toByteArray | 10 | 122681 | 750095 | 511,42 |
| ByteStreams.toByteArray | 100 | 131705 | 773561 | 487,34 |
| ByteStreams.toByteArray | 10000 | 1962961 | 4962929 | 152,83 |
| ByteSource.contentEquals | 10 | 647140 | 3614650 | 458,56 |
| ByteSource.contentEquals | 100 | 685559 | 647694 | 453,81 |
| ByteSource.contentEquals | 10000 | 5987317 | 9460941 | 58,02 |

you can find the results here:

[ByteStreamsBenchmark w/ ThreadLocal](https://microbenchmarks.appspot.com/runs/087a68fc-af92-4971-97ae-346be17ee50b#r:scenario.benchmarkSpec.methodName,scenario.benchmarkSpec.parameters.n)
[ByteStreamsBenchmark w/out ThreadLocal](https://microbenchmarks.appspot.com/runs/dfb1c1b7-b9e2-431c-91f9-3be2f19db2a7#r:scenario.benchmarkSpec.methodName,scenario.benchmarkSpec.parameters.n)
[ByteSourceBenchmark w ThreadLocal](https://microbenchmarks.appspot.com/runs/f5517421-8f23-4237-9de1-f7d9e4c8f3ce#r:scenario.benchmarkSpec.parameters.n)
[ByteSourceBenchmark w/out ThreadLocal](https://microbenchmarks.appspot.com/runs/573ac1ff-a1e9-4870-9b0d-414e77e163e6#r:scenario.benchmarkSpec.parameters.n)
 I think both SoftReferences and ThreadLocals can create issues
1. SoftReferences can induce poor gc behavior where (iirc) it takes 2 full gc for a softreference to be collected.  I believe the general advice is "don't use them, ever"
2. ThreadLocals can cause issues in certain application containers to leak classloaders.  I believe it is possible to workaround... i don't remember how.

Since preallocated buffers are such a win, the better option is probably to modify these apis so that users can supply their own buffer (which they could manage with a ThreadLocal+SofReference or whatever is appropriate)
 Hi Luke, thank you for your comment. 

It is often advised not to use ThreadLocals in webapplications (like [here](http://niklasschlimm.blogspot.de/2012/04/threading-stories-threadlocal-in-web.html) ) since webapplications typically use thread-pools and so threads never actually finish, leaving objects threadlocal-attached to a thread to never be collected by gc. However in this case, since we only store Soft-/WeakReferences, garbage collection is able to free the buffer-memory (except for the tiny SoftReference-Object itself),  thus avoiding the problem alltogether. 

As for the SoftReference-issue, are you referring to http://bugs.java.com/bugdatabase/view_bug.do?bug_id=6912889 ? To circumvent this issue, it would be enough to just replace SoftReference with WeakReference, since WeakReference does not cause these problems, but it would come with some performance penalty. Maybe a good solution would be to use WeakReferences only for all ByteArrayOutputStreams and byte-arrays larger than the initial size of 8k, since you need to fill the heap up almost completely with softreferenced memory to cause the problem, what is hardly possible with 8k per thread. 
Also, guava uses SoftReferences in other places too, like http://docs.guava-libraries.googlecode.com/git/javadoc/com/google/common/cache/CacheBuilder.html#softValues().

Regards
Bernd

Update:

after some more googling, I found this ( I guess that is what you referred to, concerning the threadlocals ): https://wiki.apache.org/tomcat/MemoryLeakProtection#customThreadLocal
So I will rewrite the code to not use custom ThreadLocals.

Update 2:

I implemented what I mentioned above here:

[not using custom ThreadLocals](https://github.com/berndhopp/guava/commit/589c5953268835c638b73a239dfcf27226a618a6#diff-26e4970e348a674eadbfcccaac4fdb43L27)
[using WeakReferences for byte-arrays larger than init-size](https://github.com/berndhopp/guava/commit/589c5953268835c638b73a239dfcf27226a618a6#diff-26e4970e348a674eadbfcccaac4fdb43R109)
[using WeakReferences for ByteArrayOutputStreams](https://github.com/berndhopp/guava/commit/589c5953268835c638b73a239dfcf27226a618a6#diff-26e4970e348a674eadbfcccaac4fdb43R253)

to my surprise, the code has gotten more elegant with the changes IMHO :-)
 AFAIK, there's already such a leak in [`com.google.common.escape.Platform`](https://github.com/google/guava/blob/master/guava/src/com/google/common/escape/Platform.java#L40), which could be fixed trivially by avoiding `initialValue`.
 @Maaartinus exactly, I removed the overriding of initialValue [here](https://github.com/berndhopp/guava/commit/11973b139fc66741d4392abf3082db1c39662fab#diff-26e4970e348a674eadbfcccaac4fdb43L27)
 @cpovirk @cgdecker @kluever @Bezier89 @cgruber @lowasser @lukesandberg @kevinb9n @gk5885 @cushon @jrtom @eamonnmcmanus @PeteGillinGoogle @kstanger @dimo414 @ronshapiro @15characterlimi 

I'm sorry to bother all of you, but I've put a lot of effort into this PR and I presented some numbers to prove that it offers a tremendous performance improvement, so I wonder why it had been fallen asleep. Many critical functions work a multitude of times faster than before, so it should be worth considering. 

I personally do not think that there should be additional API's to let a user supply its own buffers. I consider it the obligation of the framework to handle its buffers, otherwise most of the users would either not use buffer re-use at all or end up programming their own thread-local buffer implementation. 

What are your thoughts, what is needed to get this merged? Do you have concerns about the implementation? Should there be more control for the user?

best
Bernd
 I'm not on the Guava team, but some brief comments without any implied authority:
- major comment: I'm not sure that ThreadLocal<Reference>s are the right approach here. Perhaps there is a better solution for the case that you care about (e.g. passing a pre-allocated array like in Collection.toArray()? or something else)?
  - the Reference object itself cannot be garbage collected so this will necessarily create at least two objects per calling thread. Those two objects will then stick around for the rest of the lifetime of the thread. 
  - (minor) this creates a new class of possible bugs because the methods are not safe to call from one another (because the global variable that is the thread local could be overwritten by the other method). I guess the tests should catch that.
- like others said, relying on Soft/WeakReferences often has nonobvious implications for GC performance which I'm guessing will not be apparent in your benchmarks but still exist. Yes the CacheBuilder class supports SoftReferences but only if the caller explicitly asks for them, not silently under the hood.
- the optionality of the zeroing feels like it risks potential bugs for a (I'm guessing) marginal performance benefit. At the very least, there should be two differently named methods rather than one with a boolean argument https://ariya.io/2011/08/hall-of-api-shame-boolean-trap
- the javadoc of the gwt version claims that the class uses WeakReference / SoftReference but it actually keeps a static final byte[] instead. (yuck).
- Exceptions are more helpful if they quote the offending value. E.g.
  checkArgument(minSize >= 0, "minSize must not be negative");
  checkArgument(minSize <= MAX_BYTE_SIZE, "minSize must not exceed 2^16");
  should probably be:
  checkArgument(0 <= minSize && minSize <= MAX_BYTE_SIZE, "Expected 0 <= value < %s, got %s", MAX_BYTE_SIZE, minSize);
 Hi Tobias, thanks for your comment. I'll go through them one by one.

> major comment: I'm not sure that ThreadLocals are the right approach here. Perhaps there is a >better solution for the case that you care about (e.g. passing a pre-allocated array like in >Collection.toArray()? or something else)?

There is no particular case I especially care about, this is a patch that should increase performance in every scenario. As I said, I don't think that passing a pre-allocated array or a similar api would help users along, since re-using buffers properly is a tricky task that should be handled by a framework. 

> the Reference object itself cannot be garbage collected so this will necessarily create at least >two objects per calling thread. Those two objects will then stick around for the rest of the >lifetime of the thread.

What is the second object? The Reference object itself will not be collected until the thread finishes. But this object itself only allocates a negligible amount of memory. 

> (minor) this creates a new class of possible bugs because the methods are not safe to call from >one another (because the global variable that is the thread local could be overwritten by the >other method). I guess the tests should catch that.

Here you've got a point, I'm working on a solution for that currently

> like others said, relying on Soft/WeakReferences often has nonobvious implications for GC >performance which I'm guessing will not be apparent in your benchmarks but still exist. Yes the >CacheBuilder class supports SoftReferences but only if the caller explicitly asks for them, not >silently under the hood.

I have not found much on the internet on these problems, besides http://bugs.java.com/bugdatabase/view_bug.do?bug_id=6912889 , which I have already addressed

> the optionality of the zeroing feels like it risks potential bugs for a (I'm guessing) marginal >performance benefit. At the very least, there should be two differently named methods rather >than one with a boolean argument https://ariya.io/2011/08/hall-of-api-shame-boolean-trap

well, I don't think there are any bugs in the current code. But in case the ThreadLocalBuffers-class is to be made public one day, it may be better to make zeroing mandatory right now. 

> the javadoc of the gwt version claims that the class uses WeakReference / SoftReference but it >actually keeps a static final byte[] instead. (yuck).

you're right, my bad

> Exceptions are more helpful if they quote the offending value. E.g.
> checkArgument(minSize >= 0, "minSize must not be negative");
> checkArgument(minSize <= MAX_BYTE_SIZE, "minSize must not exceed 2^16");
> should probably be:
> checkArgument(0 <= minSize && minSize <= MAX_BYTE_SIZE, "Expected 0 <= value < %s, got >%s", MAX_BYTE_SIZE, minSize);

agreed

I will push some more commits in the coming days to address these issues. 
 Update: ThreadLocal buffers are already used in Guava, @Maaartinus  pointed that out before: https://github.com/google/guava/blob/master/guava/src/com/google/common/escape/Platform.java#L29
 @15characterlimi please see my last commit where I hopefully addressed most of the possible problems you mentioned. I'm sorry that this commit does not have all the documentation yet, especially for the new Lease-concept, but I think the code should be readable as is. 
 We're sorry to be letting you wait for this long but there's a reason why we can't respond more right now. We'll be able to tell you more in a few weeks.
 @15characterlimi ok, thanks for the update
 Hi @15characterlimi, any news here?
 @cgdecker thanks for your answer. I'm a bit puzzled right now what the concerns are. Buffer reuse is a tricky task where you can do a lot of things wrong, it took me quite a lot of effort to come up with an implementation that is safe even when the same thread uses a buffer on different levels of the stack trace. Also, there is not really any good alternative algorithm or approach to the problem; if you want buffer reuse to be efficient, save and free of memory leaks, you will inevitably wind up with ThreadLocals, Weak-/SoftReferences and some sort of 'Lease' concept to avoid reuse by the same thread. Feel free to disagree on these points I mentioned, I'm willing to discuss them. But my point is: if you have a patch that increases performance in every possible scenario without any api break or side effects whatsoever, why would a user need more 'control' over it? I just cannot think of any scenario where a user-supplied buffer would make more sense than my implementation. It may outperform my implementation by a small margin if the user would cache a buffer in say a HttpSession, but there is just too much that could go wrong. 

If your concerns are that it 'looks' somewhat fragile and hard to test properly, I can totally understand that, but that is just the nature of the beast in this case.
 My concern about this is I don't know if thread-local buffers are thread-safe when used with libraries that introduce radically different concurrency models to the JVM, like [Parallel Universe's Quasar](http://docs.paralleluniverse.co/quasar/) with it's so-called "fibers" (or lightweight threads), or [Akka](http://akka.io/) with it's actor model.
 Both Quasar and Akka rely on plain old threads eventually, so the concurrency models may be different but they base on the same building blocks. In http://docs.paralleluniverse.co/quasar/ is says: 

"Using ThreadLocals in a fiber works as you’d expect – the values are local to the fiber."

Because a fiber is nothing but a wrapped Thread at the end of the day. Every concurrency library out there is based on plain old threads and ThreadLocal cannot be "tricked" out of working, so there is nothing to worry about. As long as every code execution in java happens in the context of a java thread, ThreadLocals will work and this patch will work. 
  # Abstract

goal of this PR is to replace the often seen but unneccessary 

```
byte[] buf = new byte[BUF_SIZE];
```

or 

```
ByteArrayOutputStream baos = new ByteArrayOutputStream();

```

 with thread-local instances of the respective types in all cases where they are used method-internal, this way avoiding unneccessary memory allocation, increasing performance and enhancing the memory profile. 
# Implementation

[ThreadLocalBuffers](https://github.com/berndhopp/guava/blob/master/guava/src/com/google/common/io/ThreadLocalBuffers.java) is the manager of thread-local buffers. It uses [SoftReferences](https://docs.oracle.com/javase/6/docs/api/java/lang/ref/SoftReference.html) to store buffers, this way enabling Garbage Collection to collect the buffers when the system runs low on memory. This class is package-local right now but can eventually be made public for other scenarios where a buffer is needed.
All allocations of byte[] or ByteArrayOutputStream where the allocated byte[]/BAOS was not the returned value of the method have been replaced with calls to ThreadLocalBuffers. 

ByteSource.contentEquals was challenging, because it used not one but two byte-arrays for buffering, so I used two ByteBuffers that wrap around the upper and lower part of the thread-local buffer, thereby mimicking the two buffers.
# Results

The microbenchmarks show that avoiding buffer allocation yields a significant performance boost. 

| tested method | bytes copied | runtime w/ TL buffers | runtime w/out TL buffers | performance increase in % |
| --- | --- | --- | --- | --- |
| ByteStreams.copy | 10 | 105569 | 681130 | 645,2 |
| ByteStreams.copy | 100 | 107411 | 698152 | 649,98 |
| ByteStreams.copy | 10000 | 840354 | 1186307 | 141,17 |
| ByteStreams.readBytes | 10 | 68917 | 633365 | 919,03 |
| ByteStreams.readBytes | 100 | 69802 | 660336 | 946,01 |
| ByteStreams.readBytes | 10000 | 360357 | 934588 | 259,35 |
| ByteStreams.toByteArray | 10 | 122681 | 750095 | 611,42 |
| ByteStreams.toByteArray | 100 | 131705 | 773561 | 587,34 |
| ByteStreams.toByteArray | 10000 | 1962961 | 4962929 | 252,83 |
| ByteSource.contentEquals | 10 | 647249 | 3614650 | 558,46 |
| ByteSource.contentEquals | 100 | 685559 | 3586983 | 523,22 |
| ByteSource.contentEquals | 10000 | 696307 | 9460941 | 1358,73 |

you can find the results here:

[ByteStreamsBenchmark w/ ThreadLocal](https://microbenchmarks.appspot.com/runs/087a68fc-af92-4971-97ae-346be17ee50b)
[ByteStreamsBenchmark w/out ThreadLocal](https://microbenchmarks.appspot.com/runs/dfb1c1b7-b9e2-431c-91f9-3be2f19db2a7)
[ByteSourceBenchmark w ThreadLocal](https://microbenchmarks.appspot.com/runs/f5517421-8f23-4237-9de1-f7d9e4c8f3ce)
[ByteSourceBenchmark w/out ThreadLocal](https://microbenchmarks.appspot.com/runs/573ac1ff-a1e9-4870-9b0d-414e77e163e6)
 I signed it!
  I have a `RemovalListener` attached to `LoadingCache`.
When the cache is accessed frequently, everything works good.
If there is no activity with the cache since entry write till entry expiration, then expired entity is "silently" evicted and removal listener is not called.

Tried with `expireAfterWrite == refreshAfterWrite` and `expireAfterWrite > refreshAfterWrite`.

Not sure whether it's a bug or designed behaviour caused by combination of config params. Anyway, I cannot find the solution for the problem in the documentation.
 Does it mean that entries can be evicted/expired from the cache before `RemovalListener.onRemoval` call?

Assume that `RemovalListener.onRemoval` should be called right after (or right before) the actual entry removal from cache.

Issue here is that entry becomes expired and no more available through `get(key)` method, but `RemovalListener.onRemoval` was not called
 Are entries removed in scope of maintenance?

I believe that entries should be available while they are not actually removed from cache
 So is there a way to get such entries while they aren't actually removed during queued maintenance?
 So there is a period of time when entity cannot be returned by get() (since it's expired), but the `RemovalListener` is not called yet? And cache still holds allocated memory for that entity? 
 It's not so efficient I guess. We want to use our resources with most efficiency and be able to get the entity while it sits in memory.
 I'm also experiencing the same issue. Forcing cleanup appears to work, however, this isn't a desirable workaround. My entries are supposed to expire after a short period of time, but they do not. The removal listener never gets invoked and thus throws off the functionality of my application. This is of course when I do not force cleanup.
 Ok. I believe you have reasons to hold entities in memory for some time. I don't mind. But I need to get the notification when the entity is evicted. Now it is called sometimes, and sometimes it is not. Looks like we have consistent performance and inconsistent behaviour.
 I think that it will be much clear to have _desired_ time of expiration rather exact time and then mysterious unusable entries in memory.
Thus having setting `expireAfterWrite=4h` it will be expected that entries will be expired after 4h and ~1 second. And I believe that this is pretty much acceptable behaviour.
 If an entry is present and expired than it is not suitable for use, so the cache should treat it as a miss and possibly fetch a new copy. If the entry is usable but may be stale, then if you use `refreshAfterWrite` the cache will return the existing entry and retrieve a new copy, possibly asynchronously. Expiration and refresh are closely related concepts, with the difference being whether the entry is considered usable by the application or not.

The fact that some entries are retained in memory after expiration, due to internal mechanisms, is a detail that shouldn't concern users very often. The cache makes no guarantee when a notification is published, so just like Java finalizers closing resources it shouldn't be relied upon occurring within a strict time period. Guava walks a fine line of expiring sooner than lazy caches (relying on the maximum size) and immediate expiration relying on dedicated threads and expensive data structures (e.g. O(lg n) priority queue).

Guava is pretty flexible and was careful about the tradeoffs for the common case. If those decisions aren't proper for your application, then decorating the cache to provide custom behavior is usually a workable solution.
 I believe that if entity is present it is not expired, and if entity is expired it is not present in cache.

Application is quite sensitive to removal events and expects that entries are present in cache until removal event is fired. But apparently entries becomes unavailable from cache without removal event. And logic tries to detect removal event to prevent reading of removed/expired entries (or even put them back if application knows that there's no possibility to load/refresh them using back-end loader due to outage).

Application is heavily loaded and that _maintenance_ period (even if it takes seconds) causes too much of misses and consecutive errors due to loader outage.
  Most importantly, base64 writes 4 bytes of output for every 3 bytes of input. There's no reasonable way to flush after 2 bytes of input.
 I think the problem is assuming that flush makes sense for Base64. It does not. If you need flush, don't use Base64.
  My multithreaded thrashing tests failed with Guava due to `size()` returning a negative value. The size is used for verifying that the `toArray()` methods are threadsafe (this was a common bug until JDK6 rewrote AbstractCollection's to be tolerant to races). The lines in question are,

``` java
(cache, key) -> cache.asMap().keySet().toArray(new Object[cache.asMap().size()]),
(cache, key) -> cache.asMap().values().toArray(new Object[cache.asMap().size()]),
(cache, key) -> cache.asMap().entrySet().toArray(new Entry[cache.asMap().size()]),
```

This results in a `NegativeArraySizeException` unless worked around using `Math.max(0, cache.asMap().size())` which is now done in the guava fixture. I'm not sure why this occurs, and only happened after tweaking some JVM args. Regardless this failure was reproducible and is simple to fix.

```
java.lang.NegativeArraySizeException
at com.github.benmanes.caffeine.cache.MultiThreadedTest.lambda$new$280(MultiThreadedTest.java:142)
at com.github.benmanes.caffeine.cache.MultiThreadedTest$$Lambda$29/584234975.accept(Unknown Source)
at com.github.benmanes.caffeine.testing.Threads$Thrasher.run(Threads.java:149)
at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)
at com.github.benmanes.caffeine.testing.ConcurrentTestHarness.lambda$timeTasks$344(ConcurrentTestHarness.java:100)
at com.github.benmanes.caffeine.testing.ConcurrentTestHarness$$Lambda$61/1027825150.run(Unknown Source)
at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)
at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)
at java.lang.Thread.run(Thread.java:745)
```
 The saturated cast should handle that. Both ConcurrentHashMap
implementations do a negative check, so it sounds like an expected race
even though I don't know why it might occur.
On Jul 15, 2015 7:45 AM, "Kurt Alfred Kluever" notifications@github.com
wrote:

> Are your caches _really_ big? I see we do some summing up of segment
> sizes in a loop - maybe we are overflowing Integer.MAX_VALUE?
> 
> —
> Reply to this email directly or view it on GitHub
> https://github.com/google/guava/issues/2108#issuecomment-121638255.
 Yes, its that simple. In `longSize()` use `return Math.max(0, sum)` which will cover all of the size() methods. This is essentially what I do in my [fixture](https://github.com/ben-manes/caffeine/blob/master/caffeine/src/test/java/com/github/benmanes/caffeine/cache/testing/GuavaCacheFromContext.java#L207), which is used to run all my tests against both Caffeine and Guava implementations to find bugs / check compatibility.

Again I'm not sure why this occurs from reading the code, but I was able to reproduce the exception (its racy so takes a few tries). The fix is safe and non-invasive, so easier to resolve it there than dig into the race causing it.
 Either is fine with me. Since the size is an estimate, rather than exact, I'm not overly concerned either way. The `long` avoids overflow so your idea would be for better precision.
  I was writing my own `Table` implementation today and realized I was duplicating much of the logic in Guava's `AbstractTable`, which is package-private.  I also realized I got a few implementation details wrong.  I can't copy and paste the code into my own project because `AbstractTable` relies on other package-private utilities in a few places.

Could you make `AbstractTable` public, so that other people can use it as a good starting point for their own custom tables?
  Some methods of the class `Verify` miss the proper `@throws` tag. To be consistent with the method `Verify.verify(boolean, String, Object...)`, which already contains the proper `@throws` comment, I added the `@throws` tag where missing.
  I am trying to identify what the latest version of Guava is, and where it can be downloaded from. This information is needed for a third party dependencies security review of a PCI DSS application, where guava is a dependency. 
  See the answer to #2018
  This is Guava 18.0.

I just noticed that the equality test for `Predicates.in` uses sets to test predicate equality:

```
  public void testIn_equality() {
    Collection<Integer> nums = ImmutableSet.of(1, 5);
    Collection<Integer> sameOrder = ImmutableSet.of(1, 5);
    Collection<Integer> differentOrder = ImmutableSet.of(5, 1);
    Collection<Integer> differentNums = ImmutableSet.of(1, 3, 5);

    new EqualsTester()
        .addEqualityGroup(Predicates.in(nums), Predicates.in(nums),
            Predicates.in(sameOrder), Predicates.in(differentOrder))
        .addEqualityGroup(Predicates.in(differentNums))
        .testEquals();
  }
```

This test passes, but only accidentally. What it appears to test is that two `InPredicate`s are equal, if their `target` collections contain the same elements in any order. This test will fail, however, when you replace `ImmutableSet` with an ordered type like List. It only passes because `equals` on `Set`s is true despite of element order, and `InPredicate` simply forwards `equals` to its targets. From what I understand, `InPredicate#equals` should be true even if its target collections are ordered collections.

So this is either a misleading test, or `InPredicate#equals` does not work as intended.
 That's fine--but then the test is wrong, or at least misleading? It seems to test that equality on the predicate is order-insensitive, but this is only true right now because the test uses sets... it would fail for any ordered collection.

If this tests what you say it should, then why go through this whole `sameOrder` `differentOrder` business?
 (i.e. lack of order is a property of sets, not of the predicate)
  In my case I'm using BaseEncoding.base64() encoder to write the base64-encoded data into another stream.
It seems there is no way to write the data correctly without the target stream being closed at the end.
I'm using the following code

```
    String lineSeparator = System.lineSeparator();
    BaseEncoding encoder = BaseEncoding.base64().withSeparator(lineSeparator, 64);

    String data;
    data = "{\"en_US\",0,0,\"\",-1,\"\",\"\",\"\",\"\"}";
    byte[] bytes = data.getBytes();
    ByteArrayInputStream stream = new ByteArrayInputStream(bytes);

    ByteArrayOutputStream writerStream = new ByteArrayOutputStream(100);
    Writer writer = new OutputStreamWriter(writerStream);
    OutputStream target = encoder.encodingStream(writer);
    ByteStreams.copy(stream, target);
    //target.close();
    writer.write("\n}, other text to be written");
    writer.close();
```

When I'm running the following snippet the result is 

```
    eyJlbl9VUyIsMCwwLCIiLC0xLCIiLCIiLCIiLCIif
    }, other text to be written
```

But the correct result should be

```
    eyJlbl9VUyIsMCwwLCIiLC0xLCIiLCIiLCIiLCIifQ==
    }, other text to be written
```

If I uncomment the line with target.close call I get an exception that output stream has been closed.
If I comment the line with writer.write I get the correct result but the other text has not been written and output stream has been closed.

Maybe this is a documentation issue and subject class shouldn't be used in such a scenario. In that case this should be stated in the documentation.
 Louis, I haven't found the close() call you're referring to in BufferedWriter.close().
It does set underlying stream reference to null though.
 I didn't look at all possible implementations. The one I have sources for contains this snippet

```
@SuppressWarnings("try")
public void close() throws IOException {
    synchronized (lock) {
        if (out == null) {
            return;
        }
        try (Writer w = out) {
            flushBuffer();
        } finally {
            out = null;
            cb = null;
        }
    }
}
```
 You're right.
  When the cache is being cleared, either through `Cache.invalidateAll()` or `asMap().clear()`, the removal cause is always `EXPLICIT`. However the map may contain expired or GC'd entries that would be removed on the next maintenance cycle. The removal cause should indicate the actual state of the entry, not merely the action that triggered the eventual removal.

Due to weak and soft references the key or value may be null. A listener should only expect to receive a null key or value if the cause is `COLLECTED`, as indicated by `RemovalNotification`:

> The key and/or value may be null if they were already garbage collected.

Therefore a listener might decide to inspect the properties without a null guard, leading to an NPE.

``` java
@Test
public void clear_expireAfterAccess() {
  FakeTicker ticker = new FakeTicker();
  RemovalListener<Integer, Integer> listener = Mockito.mock(RemovalListener.class);
  ArgumentCaptor<RemovalNotification<Integer, Integer>> captor =
      ArgumentCaptor.forClass(RemovalNotification.class);
  Cache<Integer, Integer> cache = CacheBuilder.newBuilder()
      .expireAfterAccess(1, TimeUnit.MINUTES)
      .removalListener(listener)
      .ticker(ticker)
      .build();
  cache.put(1, 1);
  ticker.advance(10, TimeUnit.MINUTES);
  cache.invalidateAll();

  verify(listener).onRemoval(captor.capture());
  assertThat(captor.getValue().getCause(), is(RemovalCause.EXPIRED));
}
```

The fix is to change `LocalCache$Segment#clear()` to inspect the key, value, and expiration status when determining the cause. 

Unfortunately this race condition is more widespread due to `enqueueNotification` not being tolerant to a garbage collection nulling out the key/value. Prior to constructing the notification, the method must take a strong reference to the key and value, check if either was collected, and if so publish a `COLLECTED` instead of the caller's cause.
 I would have the bandwidth (be incentivized) if the Guava team was able to provide obfuscated traces (#1110) for policy simulation. 
  Maybe this is easier to get worked on?
applied patch from https://codereview.appspot.com/5271042/

Beware: It seems that there have been some refactorings to UnsignedInteger/UnsignedInts that are probably not reflected within the UnsignedShort(s) classes.
 I signed it!
 FWIW this would be very useful. Java 8 offers limited support for unsigned types, and in particular it does not offer UnsignedShorts.checkedCast() (it only offers widening conversions). That happens to be my use case.
 @lowasser Any outstanding issues preventing this addition?  When the method `removeExactly` from the class `ConcurrentHashMultiset` is invoked with a negative number as second parameter, the method correctly throws `IllegalArgumentException`. This behavior is not documented in the javadoc comment of the method, since the `@throws` tag is missing. I added the missing tag.
 I signed it!
  bloom filter apply to filter big data usually, maybe billions of records, when the number of expected insertions is 10 billion and the false positive probability is 0.0001, it will take about 22G RAM, it not appropriate memorize by long array, I changed the type to "HashMap&lt;Integer, Long[]&gt;", ensure long array less than 20M, does this feather useful to somebody others ?
  https://google.github.io/guava/releases/18.0/api/docs/package-list should be available so that we can Javadoc link to it.  I see that the file exists at `gh-pages/_releases/18.0/api/docs/package-list`, but for some reason it doesn't make it to the website.
 I think this has something to do with use of Jekyll.

In a "plain" publishing of Javadocs to `gh-pages`, the `package-list` file is obtainable.
 Might we be able to look forward to this in the 19.0 release?
  There is a error on the wiki page [NewCollectionTypesExplained - implementations](https://github.com/google/guava/wiki/NewCollectionTypesExplained#implementations-1): 

```
<A href="http://google.github.io/guava/releases/snapshot/api/docs/com/google/common/collect/LinkedListMultimap.html">

LinkedListMultimap

Unknown end tag for <\/a>
```

and also on [NewCollectionTypesExplained - BiMap](https://github.com/google/guava/wiki/NewCollectionTypesExplained#bimap):

```
<A href="http://google.github.io/guava/releases/snapshot/api/docs/com/google/common/collect/Table.html">

Table

Unknown end tag for </a>
```
  Seems very strange that the Range class doesn't have an overlaps(Range) or intersects(Range) method.

I expect it would essentially be

```
public boolean overlaps(Range other) {
    return isConnected(other) && !intersection(other).isEmpty();
}
```
 I've made this call several times in my own code when dealing with ranges. Ranges that are part of a DiscreteDomain deserve special consideration. As this method is mostly a convenience to save code and increase readability, perhaps two versions of the method, one for DiscreteDomain Ranges, and one for non-discrete? The method for DiscreteDomain ranges could canonicalize the ranges sent in and the caller would get their expected result. The non-discrete method could do the connected/intersection call as-is. Otherwise, a single method with a clear API documentation would be nice as well. Either way, I think it's a method that would see some use and I would love to see it added.
  In Guava 18.0, `EventBus.handleException()` incorrectly logs `exception.getCause()` instead of the underlying `exception`:

```
  logger.log(Level.SEVERE, "Could not dispatch event: " 
      + context.getSubscriber() + " to " + context.getSubscriberMethod(),
      exception.getCause());
```

This means any `@Subscribe` method which throws an exception fails to log the most important information of all: the actual exception thrown. (If the exception happened to be wrapping another exception, Guava will log the wrapped exception, but that's usually not the case.)

I believe this should be:

```
  logger.log(Level.SEVERE, "Could not dispatch event: " 
      + context.getSubscriber() + " to " + context.getSubscriberMethod(),
      exception);
```

To reproduce, try the following. I would expect the log message to include `This message should appear in the logs`, but it doesn't.

```
% cat GuavaBug.java 
import com.google.common.eventbus.EventBus;
import com.google.common.eventbus.Subscribe;

public class GuavaBug {
  private static class Event { }

  @Subscribe
  public void handleEvent(Event event) {
    throw new RuntimeException("This message should appear in the logs");
  }

  public static void main(String[] args) {
    EventBus eventBus = new EventBus();
    GuavaBug guavaBug = new GuavaBug();
    eventBus.register(guavaBug);
    eventBus.post(new Event());
  }
}

% javac -cp guava-18.0.jar GuavaBug.java
% java -cp guava-18.0.jar:. GuavaBug
Jun 24, 2015 2:30:42 PM com.google.common.eventbus.EventBus$LoggingSubscriberExceptionHandler handleException
SEVERE: Could not dispatch event: GuavaBug@7de26db8 to public void GuavaBug.handleEvent(GuavaBug$Event)
```
 Hi, shouldn't this be:

``` java
 logger.log(Level.SEVERE, "Could not dispatch event: " 
      + context.getEvent() + " to " + context.getSubscriberMethod(),
      exception);
```

Instead of:

``` java
 logger.log(Level.SEVERE, "Could not dispatch event: " 
      + context.getSubscriber() + " to " + context.getSubscriberMethod(),
      exception);
```

???
 It would be fine to include all three in the log, I'm sure.
 any update with such issue, very long time since guava 18.0 released. 
  FWIW, allocation is also a performance issue in J2ObjC. This hits us hardest with autoboxing. But I expect that the collection view caches aren't going to make a dent either way.

Also worth mentioning that J2ObjC's version of java.util.AbstractMap (taken from android) uses the same pattern with "keySet" and "valuesCollection" fields. So our users already need to deal with the lifecycle problem. (We may consider changing that based on the result of this discussion)
  Something like:

Range _original = ...;
_original.equals(Range.parse(_original.toString()));
  Guava provides `Range.span(Range otherRange)` for getting the minimal `Range` which encloses both `this` and `otherRange`.  A natural thing to want is to determine the minimal span enclosing a collection of `Range`s, but as far as I can tell no method is provided for this.

if you want to implement it yourself, you either have to:
- call `Range.span` repeatedly, one `Range` at a time
- write your own logic to go through the list and correctly deal with closed, open, and unbounded endpoints.  This is what we have done, but it's not particularly simple, and someone trying to implement it could easily make an error.

Within Guava, it would be trivial to implement this using the ordering on the package-private `Cut` object currently used by `Range` to implement `Range.span`.  
 Yes, I'm looking for the same behavior as if you created a `RangeSet` and called `.span()` on it.  However, I'm suggesting it might be worthwhile to make it its own static method because implementing it with `RangeSet` is somewhat inelegant.

`ImmutableRangeSet.Builder` forbids adding overlapping ranges (which might be present) so we must use `TreeRangeSet` like this:

```
RangeSet<T> rs = TreeRangeSet.create();
for (final Range<T> range : ranges) {
   rs.add(range); // no addAll 
}
final Range<T> span = rs.span();
```

Code-wise, this isn't bad and could easily wrapped up in a method. But at a glance at least, it looks like under the hood this involves creating a `NavigableMap<Range>` and then applying the rather complex logic of `TreeRangeSet.add()`, which at the very least creates another `Range` object for each input range.

It seems inelegant to be sorting the ranges and creating lots of objects for something which could be done in a single linear pass through the ranges without creating any.  But perhaps the use case is too rare for Guava,
 It was more aesthetic than practical.  Repeatedly calling `span` allocates a new `Range` on every call [1], while if you go through the list tracking end points you can avoid creating any objects at all (except the returned answer).  But perhaps the compiler can optimize away the allocation of the temporary `Ranges`, and it is unlikely to be a performance bottleneck, anyway, so I will close the ticket.  Thanks for your all's work on Guava by the way - we use it constantly.

[1] Actually, it happened on every call only in the older version of the code I was looking at. The current version is cleverer and will reuse one if the input `Ranges` if it can.  In the case of a large collection of random `Ranges` this will happen often, though not if they are somewhat sorted, which I'd imagine is a common case.
  I was writing a subclass of `SettableFuture` that takes some additional action when `cancel()` is invoked, but _Oops_ the class is `final`...

Marking a class in a general purpose library `final` is a pretty drastic thing to do, so I assume there is a good reason.... ?

If there is no good reason, how 'bout let's make it extensible.
 Thanks, didn't realize that. Sorry for the noise.
  If you try to split "abc82" with the pattern "(?=\d)" you get [abc, 8].
The last number will be left out of the result.

http://stackoverflow.com/q/30941743/758280
 All of the other tests passed.
  I think this is a good idea, though it'd be good to warn users that (naturally) the default concurrency level may be different (see andrewgaul/modernizer-maven-plugin@6cc37bd528fbbcf6312eda58a53c307ead560ae8).

For other candidates, see the `com/google/...` entries in [`modernizer.xml`](https://github.com/andrewgaul/modernizer-maven-plugin/blob/master/src/main/resources/modernizer.xml).
 At this time Guava needs to be compatible with Java 6. Since diamond is only available in Java 7+, IMHO, I don't think this is a good idea. I think we can think in this when Guava requirements when updated to Java 7.
  _Motivating example_: Suppose you want a `Map` with `byte[]` keys, where the keys are compared by array contents (e.g., "deep equals").

You can't used any normal hash-based `Map` implementation because those hash and compare using `hashCode` and `equals()`, which for `byte[]` arrays uses object identity, not array contents. The only option is to use e.g. `TreeMap` and supply a custom comparator. But `TreeMap` requires a lot more memory per entry, provides unnecessary sorting, and moreover this workaround doesn't always work: in some cases, your keys may not have any total ordering at all.

I've encountered this problem repeatedly: I want a `HashMap` of some objects but need it to be based on custom hashing and equality methods.

_Request_: give `MapMaker` the ability to be configured with a pluggable hash/equality delegate, e.g.:

```
public interface Hasher<T> {
    boolean equals(T t1, T t2);
    int hashCode(T t);
}

public class MapMaker {
    ...
    public void <T> hasher(Hasher<T> hasher);
}
```

This would solve this problem in a nice way.

You could also provide `EqualsHasher` and `IdentityHasher` implementations of the two standard "hashers" already used by `MapMaker`, using them for normal and weak keys, respectively.
 OK, thanks. I didn't know about `Equivalence`... should have looked there.

I strongly disagree however with not providing a public way to specify an `Equivalence` to `MapMaker`. Just seems spiteful. Oh well.
  I have raised a pull request for this: https://github.com/google/guava/pull/2247
  I'm a [Spoon](https://github.com/INRIA/spoon) contributor, an open source project to analyse and transform Java source code. This project have a dependency to [JDT](https://eclipse.org/jdt/) to compile target source code. Recently, I tried to analyse Guava with Spoon but JDT can't compile our project.

What is the problem?

In [`ImmutableMap`](https://github.com/google/guava/blob/master/guava/src/com/google/common/collect/ImmutableMap.java) class, we have these methods:

``` java
// If the map is an EnumMap, it must have key type K for some <K extends Enum<K>>.
@SuppressWarnings({"unchecked", "rawtypes"})
private static <K, V> ImmutableMap<K, V> copyOfEnumMapUnsafe(Map<? extends K, ? extends V> map) {
    return copyOfEnumMap((EnumMap) map);
}

private static <K extends Enum<K>, V> ImmutableMap<K, V> copyOfEnumMap(EnumMap<K, ? extends V> original) {
    EnumMap<K, V> copy = new EnumMap<K, V>(original);
    for (Map.Entry<?, ?> entry : copy.entrySet()) {
        checkEntryNotNull(entry.getKey(), entry.getValue());
    }
    return ImmutableEnumMap.asImmutable(copy);
}
```

This code is valid but there is an error from JDT:

> Type mismatch: cannot convert from `<Enum<Enum<K>>>` to `<K>`

Before the creation of this issue, I reported the bug in the bugtracker of JDT (issue [here](https://bugs.eclipse.org/bugs/show_bug.cgi?id=469404)). In 2 words, the conclusion was that: "Yes, JDT don't support this usage of Java but there is a better practice". This better practice is explained [here](https://bugs.eclipse.org/bugs/show_bug.cgi?id=469404#c3):

``` java
private static <K extends Enum<K>> ImmutableMap<K, V> copyOfEnumMap(EnumMap<K, ? extends V> original) {
    return copyOfEnumMap((EnumMap<K,?>) map);
}
```

I tried some tricky solutions but, unfortunately, this solution can't be applied in your project. So I come to notify you that your project can't be compiled by JDT.
  The documentation for `ImmutableList.of()` states the following:

> Returns the empty immutable list. This set behaves and performs comparably to Collections#emptyList, and is preferable mainly for consistency and maintainability of your code.

One notable difference between `ImmutableList.of()` and `Collections.emptyList()` is that the former throws an `UnsupportedOperationException` on `clear()` while the latter does not. Should that be considered behaving "comparably"?

Similarly for `ImmutableMap` and `ImmutableSet`.

EDIT: I also noticed the documentation says "Returns **the** empty immutable [list/map/set]." I suppose that's a mistake?
 Regarding the singleton return value, I would say it should either be documented clearly or not at all.
 I must disagree. `Collections.emptyList()` doesn't have to return a singleton. Assuming it does, `ImmutableList.of()` doesn't have to emulate that property. Assuming it does, "the" is a very obscure way of referencing that.
  Can you please confirm that .design will be added as a public suffix in Guava 19.0
   When the method `AbstractMapBasedMultiset.add(Integer, int)` is invoked with a negative number as second argument, an `IllegalArgumentException` is thrown.

Example:

```
HashMultiset<Integer> multiset = HashMultiset.create();
multiset.add(1, -10);
```

This behavior is reasonable, but not specified in the Javadoc comment of the method. Do you think it should be described in the Javadoc?
  I'm using `ImmutableMap` for building structures that I can then automatically serialize to JSON, like the following adapted from http://json.org/example:

``` java
Map j = ImmutableMap.of(
        "id", id,
        "title", title,
        "debug", "on",
        "window", ImmutableMap.of(
                "title", "Window title",
                "name", "window_1",
                "width", 500,
                "height", 500
                )
        );
```

Coming from Python where JSON can be used in source code as-is, the above is a very nice alternative in Java land and I couldn't think of a way to make it any better, syntax-wise. However, I hit the limit of the maximum 5 key-value pairs of `ImmutableMap::of`, and then I had to use rather ugly workarounds (with `Builder` or alternatively splitting a big Map up into two and joining them together again...).

I fully understand that there is no variable arguments overload like in `ImmutableSet::of` -- you couldn't guarantee at compile-time that the number of `ImmutableMap::of` arguments is even (to form key-value pairs), it would fail at run-time, and we don't want that.

I also understand that there probably is some resistance in providing a high number of overloads. However, I still think the limit of 5 entries is [too low](https://stackoverflow.com/q/9489384/60982). And resorting to `Builder` is just plain ugly in some cases. I therefore propose to raise the number of overloads to 10, as this should cover most use cases and will create less headache for users. On the implementation side it is a trivial change and I don't see any problem.
 I guess that's personal taste, but basically for each map it adds one 
line of code (.build()), and per entry five additional characters. And 
from a visual point of view your brain has to ignore more boilerplate 
while reading code. So personally I find using ImmutableMap.of a lot nicer.
 When you push an api to the point where it feels awkward, then you may be using the wrong tool for the job. For json specifically, there are libraries like [jsonschema2pojo](http://www.jsonschema2pojo.org/) that code generate the boilerplate and then marshall with a json serializer.
 I feel that any of such pojo generator libraries are an overhead for 
_my_ use case and would slow me down considerably while prototyping. I 
need to quickly iterate on the json schema and add/remove attributes at 
any place while I go along. For that, the ImmutableMap.of is just 
perfect. I agree that for production-use or exposing such json objects 
to end-users as type-safe classes it makes sense to use jsonschema2pojo 
or similar. It's just two different use cases.
 Refastor mentions hurt my heart :broken_heart:! Open source as a Christmas present :grinning: 
 > So do we want to follow that precedent and turn this up to 11?

Are there regression benchmarks to see how this would affect Android?
 I'd been thinking of class loading being impacted by the new methods. But
now that I think of it, Proguard should take care of removing the unused
methods.
 @ustaDAH, can you give us some more context? Like a sample of your builder-using code that doesn't seem to work?
 This is an example
![image](https://cloud.githubusercontent.com/assets/7517052/15635850/32e26f78-25eb-11e6-9026-abedd7edf09f.png)

It requires List<OwnExecutableInstruction>and List<String> but it gets two objects.
 You have closed my issue recently (2489). And that was just an example, where ImmutableMap.builder() doesn't work :) I also want to use ImmutableMap.of to accept more than 5 entries.
 @jbduncan Actually, it was just a nested types in Generics that made it clumsy, it all DOES work, my bad:
`Map <String, Supplier<String>> map = ImmutableMap.<String, Supplier<String>>builder()
    .put("one", () -> "supplier1")
    .build();`
Having to repeat the type info is annoying but I think that's the limitation of automatic type inference and has nothing to do with Guava.
  In some cases, it's desirable to build a more complex error message which does not use simple string placeholder substitution like the current incarnations of `checkNotNull` and `checkArgument` support. So I think it would be nice to have variants which accept a `Supplier<String>` which will return an error message when needed. Eg.

``` java
  public static <T> T checkNotNull(T reference, Supplier<String> errorMessageSupplier) {
    if (reference == null) {
      throw new NullPointerException(errorMessageSupplier.get());
    }
    return reference;
  }
```

Which would be used like (with a Java 8 lambda for brevity):

``` java
checkNotNull(variable, () -> buildComplexMessage(variable));
```
 In my opinion this could still be added to Guava, so that those who are using Java 8 already can use this feature conveniently (Guava's `Supplier` can also be written as `() -> ..` because it's a one-method interface basically, so no need for JDK8's `Supplier`).
But even in Java 7 it could be useful, even though the `Supplier` implementation would be quite verbose, I can imagine cases where such a `Supplier` is instantiated in one place, and re-used in different calls.
  I don't think the extra links will make a meaningful difference on Android users. The bulk of the RAM in an Android app is used by high-resolution images!
 The number of objects allocated in `LinkedHashMap` is the same as in `HashMap`. Not sure about `LinkedHashMultimap`.
  I have this class:

``` java
public class Core extends AbstractIdleService {

    @Override
    protected void startUp() throws Exception {
    }

    @Override
    protected void shutDown() throws Exception {
    }

}
```

…and this unit test:

``` java
public class CoreTest {

    private final Core core = new Core();
    private final AtomicBoolean started = new AtomicBoolean();
    private final AtomicBoolean stopped = new AtomicBoolean();

    @Before
    public void setupCoreListener() {
        core.addListener(new Listener() {
            @Override
            public void running() {
                System.out.println("running");
                started.set(true);
            }

            @Override
            public void stopping(State from) {
                System.out.println("stopping");
                stopped.set(true);
            }

            @Override
            public void terminated(State from) {
                System.out.println("terminated");
                stopped.set(true);
            }
        }, MoreExecutors.directExecutor());
    }

    @Test
    public void coreCanStartUp() {
        core.startAsync().awaitRunning();
        System.out.println("testing started");
        MatcherAssert.assertThat(started.get(), Matchers.is(true));
    }

    @Test
    public void coreCanShutDown() {
        core.startAsync().awaitRunning();
        core.stopAsync().awaitTerminated();
        System.out.println("testing stopped");
        MatcherAssert.assertThat(stopped.get(), Matchers.is(true));
    }

}
```

I would expect these tests to always succeed; the service listener is run in the same thread, the boolean is stored in an `AtomicBoolean` and yet, if I run this test multiple times it sometimes fails. On stdout I see:

```
testing started
running
running
stopping
testing stopped
terminated
```

So `core.startAsync().awaitRunning()` returns before the listener for `running` is called. Is that intended and correct behaviour?
 Well, bugger. That makes sense. Thanks. :)
  To check if a list of strings contains the input string case-insensitively.

List<String> lisr= new List<String>();
list.add("Apple")t
list.add("Orange");
list.add("Mango");
if(list.containsIgnoreCase("ApPle")) {
   System.out.println("List contains input string");
}

This should print the output "List contains input string"
  As a follow up to https://github.com/google/guava/issues/2064, for testing, it would be handy to have

`EvictingQueue.of(1,2,3,4,5)` that would just create a new EvictingQueue of size 5 with the passed in elements.

Something like this, perhaps:

```
class EvictingQueue {
    //...
    public static <T> EvictingQueue<T> of(Collection<T> elements) {
        EvictingQueue<T> ret = EvictingQueue.create(elements.size());
        ret.addAll(elements);
        return ret;
    }

    public static <T> EvictingQueue<T> of(T... elements) {
        return EvictingQueue.of(Arrays.asList(elements));
    }
}
```
  When using [hamcrest assertions](http://hamcrest.org/JavaHamcrest/), I was surprised that the following didn't pass:

```
EvictingQueue<Integer> lastFive = Stream.of(1, 2, 3, 4, 5, 6, 7, 8, 9, 10).collect(Collectors.toCollection(() -> EvictingQueue.create(5));
EvictingQueue<Integer> expected = EvictingQueue.create(5);
expected.addAll(Arrays.asList(6, 7, 8, 9, 10));
assertThat(lastFive, is(expected));
```

Whereas the following did:

```
EvictingQueue<Integer> lastFive = Stream.of(1, 2, 3, 4, 5, 6, 7, 8, 9, 10).collect(Collectors.toCollection(() -> EvictingQueue.create(5));
EvictingQueue<Integer> expected = Arrays.asList(6, 7, 8, 9, 10);
assertThat(new ArrayList<>(lastFive), is(expected));
```

If it's only for testing, no big deal, but I would have expected that two EvictingQueues could be compared to each other naturally especially if the delegate is.
  Guava's cache performance has a lot of potential for improvement, at the cost of a higher initial memory footprint. The [benchmark](https://github.com/ben-manes/caffeine/wiki/Benchmarks), with the raw numbers below, shows Guava's performance on a 16-core Xeon E5-2698B v3 @ 2.00GHz (hyperthreading disabled) running Ubuntu 15.04 with JDK 1.8.0_45.

Of note is that Guava's default concurrency level (4) results in similar performance to a synchronized LinkedHashMap. This is due to the cache's overhead, in particular the GC thrashing from ConcurrentLinkedQueue and a hot read counter. It should also be noted that at the time of development synchronization was slow in JDK5, but significantly improved in JDK6_22 and beyond. This and other improvements help LinkedHashMap's performance compared to what was observed when Guava's cache was in development.

The easiest way to double Guava's performance would be to replace the `recencyQueue` and `readCount` with a ring buffer. This would replace an unbounded linked queue with a 16-element array. When the buffer is full then a clean-up is triggered and subsequent additions are skipped (no CAS) until slots become available. This could be adapted from this [implementation](https://github.com/ben-manes/caffeine/blob/master/caffeine/src/main/java/com/github/benmanes/caffeine/cache/BoundedBuffer.java).

Given the increase in server memory, it may also be time to reconsider the default concurrency level. Early design concerns included the memory overhead, as most caches were not highly contended and the value could be adjusted as needed. As the number of cores and system memory has increased, it may be worth revisiting the default setting.
#### Read (100%)

| Unbounded | ops/s (8 threads) | ops/s (16 threads) |
| :-: | :-: | :-: |
| ConcurrentHashMap (v8) | 560,367,163 | 1,171,389,095 |
| ConcurrentHashMap (v7) | 301,331,240 | 542,304,172 |
|  |  |  |
| **Bounded** |  |  |
| Caffeine | 181,703,298 | 365,508,966 |
| ConcurrentLinkedHashMap | 154,771,582 | 313,892,223 |
| LinkedHashMap_Lru | 9,209,065 | 13,598,576 |
| Guava (default) | 12,434,655 | 10,647,238 |
| Guava (64) | 24,533,922 | 43,101,468 |
| Ehcache2_Lru | 11,252,172 | 20,750,543 |
| Ehcache3_Lru | 11,415,248 | 17,611,169 |
| Infinispan_Old_Lru | 29,073,439 | 49,719,833 |
| Infinispan_New_Lru | 4,888,027 | 4,749,506 |
#### Read (75%) / Write (25%)

| Unbounded | ops/s (8 threads) | ops/s (16 threads) |
| :-: | :-: | :-: |
| ConcurrentHashMap (v8) | 441,965,711 | 790,602,730 |
| ConcurrentHashMap (v7) | 196,215,481 | 346,479,582 |
|  |  |  |
| **Bounded** |  |  |
| Caffeine | 112,622,075 | 235,178,775 |
| ConcurrentLinkedHashMap | 63,968,369 | 122,342,605 |
| LinkedHashMap_Lru | 8,668,785 | 12,779,625 |
| Guava (default) | 11,782,063 | 11,886,673 |
| Guava (64) | 22,782,431 | 37,332,090 |
| Ehcache2_Lru | 9,472,810 | 8,471,016 |
| Ehcache3_Lru | 10,958,697 | 17,302,523 |
| Infinispan_Old_Lru | 22,663,359 | 37,270,102 |
| Infinispan_New_Lru | 4,753,313 | 4,885,061 |
#### Write (100%)

| Unbounded | ops/s (8 threads) | ops/s (16 threads) |
| :-: | :-: | :-: |
| ConcurrentHashMap (v8) | 60,477,550 | 50,591,346 |
| ConcurrentHashMap (v7) | 46,204,091 | 36,659,485 |
|  |  |  |
| **Bounded** |  |  |
| Caffeine | 55,281,751 | 47,482,019 |
| ConcurrentLinkedHashMap | 23,819,597 | 39,797,969 |
| LinkedHashMap_Lru | 10,179,891 | 10,859,549 |
| Guava (default) | 4,764,056 | 5,446,282 |
| Guava (64) | 8,128,024 | 7,483,986 |
| Ehcache2_Lru | 4,205,936 | 4,697,745 |
| Ehcache3_Lru | 10,051,020 | 13,939,317 |
| Infinispan_Old_Lru | 7,538,859 | 7,332,973 |
| Infinispan_New_Lru | 4,797,502 | 5,086,305 |
 Is the "op" a read, update or insert? The latest stuff I did in cache2k only have a bottleneck for the insert operation, which implies structural changes and therefor needs locking. All other operations run fully concurrently. Can you maybe rerun your benchmarks with a cache2k setup I give you?
 You can send a pull request to add a new cache type to the [GetPutBenchmark](https://github.com/ben-manes/caffeine/blob/master/caffeine/src/jmh/java/com/github/benmanes/caffeine/cache/GetPutBenchmark.java). I looked at cache2k a while back and am not confident in it being threadsafe, so it may perform well but corrupt itself.
 > I looked at cache2k a while back and am not confident in it being threadsafe, so it may perform well but corrupt itself.

Yes, quite normal reaction. I regularly have these concerns, when I look at a code area that I had not touched for some months. I walk through the design and the JMM again and finally find good sleep. So far we had no corruption in production, even for releases marked as experimental. 
 I know adding to an unfamiliar code base is confusing, so I made an addition that I'll send you a pull request to review. Stepping through I see where some of my initial concerns regarding races are addressed for the LruCache.

On my laptop I get the following results, which matches the [Desktop-class benchmarks](https://github.com/ben-manes/caffeine/wiki/Benchmarks) section.

| Benchmark | ops/s (8 threads) |
| :-: | :-: |
| Read (100%) | 8,864,382 |
| Read (75%) / Write (25%) | 8,064,139 |
| Write (100%) | 2,489,101 |

The performance matches what I'd expect from top-level lock, which appears to be how the LRU is implemented. I haven't looked at why writes are slower, since they should take the same amount of time. This may be due to synchronization or  degradation in the custom hash table.
 A [quick and dirty hack](https://github.com/ben-manes/guava/commit/0f286172945f7f23d1c2b8f297f9816e918c6bc3) to Guava resulted in up to **25x read performance gain** at the default concurrency level (4).

| Benchmark | ops/s (8 threads) | ops/s (16 threads) |
| :-: | :-: | :-: |
| Read (100%) | 121,808,437 | 260,593,210 |
| Read (75%) / Write (25%) | 34,770,671 | 48,538,555 |
| Write (100%) | 5,064,388 | 6,045,980 |

We can increase the concurrency level (64) for better write throughput, but unsurprisingly this decreases the read throughput. This is because the cpu caching effects work against us. ConcurrentHashMap reads are faster with fewer segments (576M ops/s) and Guava's recencyQueue is associated to the segment instead of the processor. The queue fills up slower, making it more often contended and less often in the L1/L2 cache. We still see a substantial gain, though.

| Benchmark | ops/s (8 threads) | ops/s (16 threads) |
| :-: | :-: | :-: |
| Read (100%) | 40,935,985 | 84,109,039 |
| Read (75%) / Write (25%) | 40,854,227 | 64,462,500 |
| Write (100%) | 6,757,178 | 6,570,233 |

Because we are no longer thrashing on readCounter, the compute performance increases substantially as well. Here we use 32 threads with Guava at the default concurrency level.

| Computer | sameKey ops/s | spread ops/s |
| :-: | :-: | :-: |
| ConcurrentHashMap (v8) | 30,321,032 | 64,427,143 |
| Guava (current) | 23,149,556 | 71,423,966 |
| Guava (patched) | 329,220,794 | 166,448,754 |
| Caffeine | 1,558,302,420 | 533,181,707 |

I have been advocating this improvement since we first began, originally assumed that we'd get to it in a performance iteration. After leaving I didn't have a good threaded benchmark to demonstrate the improvements, so my hand wavy assertions were ignored. There are still significant gains when moving to the Java 8 rewrite, but these changes are platform compatible and non-invasive.

I don't know why I even bother anymore...
 Updated the patch so that unit tests compile & pass.
  This method exists to warn callers of `compare(Boolean, Boolean)` and
`compare(boolean, boolean)` with a deprecation warning.  Using the
private access modifier would still allow callers to use the generic
`compare(Comparable<?>, Comparable<?>)` method.
  It would be great if it were possible to ignore null values received in the ComparisonChain class.

I solve this problem by using the Optional class, but it would be better to use a condition to ignore null values of comparison
 I have a class "MyClass" that is filled from a sql query. It has 3 String fields: equip, family and shift. That class implements Comparator<MyClass> and I use ComparisonChain that compares equip, family and shift, in that order.

Well, the query returns some null values for Equip, of 100 elements, 5 has null values for equip. So the ComparisonChain throws a NullPointerException.

So, I use a Optional<String> to replace the null values with empty, just to continue the comparison correctly.

But, if the ComparisonChain has the ability to test null values before compare the values, this doesn't throws the NullPointerException, and it doesn't break the code.

I don't know, but I think that with a boolean parameter passed to constructor to define if the ComparisonChain needs test for null values before it do the comparison. And with this our code will be less.
 Yeah, that solution is good. I just wanted to simplify the third parameter, but it's ok.

Thanks my friends! ;)
  pull from head
 sorry, this is my wrong operation.i just want to pull from google/guava 's master to my fork
  The [code.google.com Guava homepage](https://code.google.com/p/guava-libraries/) tells people to come here at GitHub instead, yet key information for new users was missing from the README.
 I guess signing the CLA isn't necessary for simple documentation changes? (According to CONTRIBUTING.md, _code_ contributions require it.)
 @jonikarppinen This is a bot of google. So hopefully you do what the bot said :)
 @jonikarppinen, googlebot isn't a human user. It only responds if you post a new message w/ the text "I signed it!" (without the apostrophes). :)
   I like to create new collections using static classes like Maps, Lists, Sets, but guava missies some types of collections. For example WeakHashMap. Do it's done for some purpose? 
  Guava should improve sorting. in a way that the every type of list is supported. like right now ArrayList are supported. it should the same with CopyOnWriteArrayList.
 Yes, I know about that. See here's an example. 
I am making an application. which contains heavy real-time updates. so it uses more memory and guava's collection is more fast than androids built-in.

So i can use ArrayList to sort, No Matter but i did try that, Takes huge amount of memory and time. It always gives Fatal-Exception of Non-Thread safe operations. See after sometime i tried CopyOnWriteArrayList to avoid non-thread safe operations. But you can't Sort them with Collections it will generate UnsupportedOperationException.

So making more loops in actual code is more costly and while theres no Guava usage need then because we can use CopyOnWriteArrayList for no Exceptions and can sort with iterators. if it's durable so i can suggest that guava can implement Sorting for More ArrayListTypes inbuilt. 

Thanks.
   When using `Throwables.propagate` with a method that throws `Exception` or `Throwable`, using it properly requires some boilerplate to avoid swallowing `InterruptedException`. An example of such a method is `MethodHandle.invoke`. While it is true that such a method is very unlikely to throw `InterruptedException`, the pedant in me requires handling it correctly. It would be nice if this check could be added to `propagate`.

``` java
try {
    method.invoke();
}
catch (Throwable t) {
    if (t instanceof InterruptedException) {
        Thread.currentThread().interrupt();
    }
    throw Throwables.propagate(t);
}
```
  I would like to add more checks which can be applied on the [Preconditions](http://docs.guava-libraries.googlecode.com/git-history/release/javadoc/com/google/common/base/Preconditions.html) class. These checks would include:
- checkBlank(String)
- checkNotBlank(String)
- checkEmpty(String/Collection)
- checkNotEmpty(String/Collection)

All of these would throw an IllegalArgumentException if the check fails. Would it be acceptable to expand Preconditions to these new checks? I would be happy do to the pull request if so.
 Thanks @lowasser for the clarification. We have noticed a lot of "cookie-cutter" code patterns around some of these checks (in some cases doing multiple function calls within the precondition), which is why I wanted to suggest adding these. 

For empty / blank checks, I was considering failing the check if what was supplied was null, by throwing an IllegalArgumentException in that scenario.

I assume the checkEmpty(String) / checkNotEmpty(String) is also not wanted? Ex. checkNotEmpty would have to be non-null and length > 0.
 OK, well I will go ahead and close this out. Thanks for the feedback.
  Make the JavaDoc more clear about what happens in cases of equivalence.
 That's a fair point, and maybe it should be removed completely.
The JavaDoc had already mentioned this for the second method (which takes a user supplied equivalence class comparator), and it was confusing to me for not only what you mentioned, but also it wasn't clear to me at first what it meant by "returned in the difference".
  When I use the builder and put multiple entries into the map, the capacity keeps getting resized. I know the desired capacity before hand, so should be able to construct an immutable map of the correct size, and avoid this performance tax.

The builder already has a package private capacity constructor. I can not find documentation as to why this is not public (https://code.google.com/p/memory-measurer/wiki/ElementCostInDataStructures may have explained, but it is no longer available).
 Thumbs on this suggestion. Yeah by defining the initial size cosf of adding the each entry in a map will be reduced in time complexity in expanding the bucket
 This would be really useful. And same thing goes for all other Immutable\* classes.
 Having the ability to to specify the capacity for builders when known a priori would be very beneficial for us.
 Verified #196 is a duplicate of my request. Closing this issue.
  So I found a minor bug while browsing the source in IntelliJ and figured, heck, why not fix it? So I forked guava, built it, made my change, pushed and created a pull request, complete with affable wit.

   https://github.com/google/guava/pull/2045

The CLA bot wasn't happy. I suspected it was because I signed the CLA under javajosh@gmail.com, but my `git config user.email` was a different email. So I changed the value, reverted, created a new branch 'javajosh' and merged my change from master, pushed, and crafted a new pull request. Yet this did not, apparently, correct the problem:

   https://github.com/google/guava/pull/2046

I am flummoxed.
  The check is done on line 166, so the first check is redundant.
  The check is done on line 166, so the first check is redundant.
 I assume I just signed away my first-born. Well, you can have him, Google.
   I signed it!
  Looks like this shaves 9+ minutes in total off the build and about 3 per sub build
 I signed it!
  It would be helpful to have a method to convert a `Map<String, String>` to `Properties` to use when interacting with APIs that require it. For example, the JDBC `Driver.connect()` method takes a `Properties`.

``` java
public static Properties toProperties(Map<String, String> map) {
  Properties properties = new Properties();
  for (Map.Entry<String, String> entry : map.entrySet()) {
    properties.setProperty(entry.getKey(), entry.getValue());
  }
  return properties;
}
```
 @kluever yes, exactly
 That call is flagged as a warning in IDEs and other tools, since calling underlying Hashtable methods can corrupt the Properties object. Also, having the method allows using it as part of an expression without needing two additional statements.

I agree it is not strictly necessary, but that is true of many things in Guava.
 Would you consider reopening this?

* avoid warnings about calling type-unsafe methods on `Properties`
* allow using the result as an expression
 Is this issue accepted?
 Ok.  Hello, I was reading through the set of tests at https://github.com/google/guava/blob/master/guava-tests/test/com/google/common/base/StopwatchTest.java , and I noticed there are two tests that appear to do the same thing - testElapsed_millis() and testElapsedMillis(). Is this expected? Could one test perhaps be an old test under a different naming convention? From the history it looks like they were added independently.

The contribution guide recommends creating an issue as the first step, so I thought I would ask.

GitHub suggests that both functions are only called from guava-gwt/test/com/google/common/base/StopwatchTest_gwt.java . Would it be appropriate to create a pull request to remove one of the tests? (Or of course, feel free to simply remove one yourself if the workflow is easier; I just wanted to ask)

Cheers!
 @kluever Hey, fantastic! :) Thanks for the fast reply. Wasn't trying to assign any blame; just asking questions ;)

Thanks very much!
 @kluever Hello again,

Thanks very much for the fixes :)

Reading through the tests it seems like there might still be some possible duplication - `testStop_new()` and `testStop_alreadyStopped()` seem to be doing mostly the same thing. Would you be interested in a pull request to combine those two tests? I can create a new issue for that if you prefer.

I also noticed that the `StopwatchTest` class starts with

```
private final Stopwatch stopwatch = new Stopwatch(ticker);
```

, but according to the `Stopwatch` class docs, the `Stopwatch()` style constructors are deprecated. Should the `StopwatchTest` class be using the `createUnstarted()` interface to create its private variables instead?

Lastly, some tests - such as `testElapsed_multipleSegments()` - have multiple uses of numbers where they check things like "9 + 25 should equal 34". Would it be appropriate/would you be interested in a pull request to use some variables for those, to make sure that matching numbers will always be the same?

e.g. rather than

```
ticker.advance(9);
..
ticker.advance(25);
..
assertEquals(34, stopwatch.elapsed(NANOSECONDS));
```

something like

```
long firstAdvance = 9;
long secondAdvance = 25;
assertEquals(firstAdvance + secondAdvance, stopwatch.elapsed(NANOSECONDS));
```

Would that improve maintainability? Or just make it more unreadable? I tried to find a preference in the [Google Java Style doc](https://google-styleguide.googlecode.com/svn/trunk/javaguide.html) but perhaps I'm missing something.

Thanks for your time, let me know if you have thoughts.
 Aha! Thanks for the fast reply. I had assumed that your commit of 08a3fbf meant that https://github.com/google/guava/blob/master/guava-tests/test/com/google/common/base/StopwatchTest.java was back to being HEAD revision code. If you've already sorted out `testStop_new()` and `testStop_alreadyStopped()` then awesome.

Thanks!
  I've just tried to use `ClassPath.from(MyClass.class.getClassLoader()).getResources()` as a kind of alternative to the aging [`ResourceFinder`](http://geronimo.apache.org/maven/xbean/3.6/xbean-finder/apidocs/org/apache/xbean/finder/ResourceFinder.html) (naming sometimes surprising -- `findString` for instance, dismissing generics when searching for implementations) but that call always returned the whole JDK, probably because the parent `ClassLoader` is also added (according to the source code of `ClassPath`: it is not specified in the Javadoc). My goal here is to have something faster than looping over 20k entries over and over.

Why can't I do that myself wrapping my ideas over `ClassPath.from(...).getResources()`, by iterating and checking the URL? Because for a few `ResourceInfo` entries from the JDK, the `url()` method cannot be invoked without generating a `NullPointerException`. This starts to be a lot of undocumented features for my use case.

Would it be possible to specify a notion of "exactly the specified `ClassLoaders` or URLs" (like `jar:` and `file:` urls)? Then with filters and mapping, it's rather trivial for us to extract whatever resource we really want. To be honest, what I'd really want is a modern and efficient `ResourceFinder`.
 After the initial tests that I mention in the first sentence of the OP, I totally understand the scope of `ClassPath` and I totally agree with the concept. That's why I don't request an extension of it, but rather a complement to it which focuses on resources in general instead of classes in particular.

`ResourceInfo.getName()` doesn't say in which "context" the resource is. I'd have hoped to filter the resources by checking `ResourceInfo.url()` to filter only the one that I wanted, but as I mentioned, several resources on the JDK throw `NullPointerException`; I can filter them out too, that's not a big deal, but it starts to be a completely other framework on the base of that class. This is why I requested that this "framework" is integrated in Guava, with the functionalities similar to `ResourceFinder`.

Of course, I can do the loops and find exactly what I need. This is not about that: I'm already doing something like that at the moment. This request is to have a well thought API to easily access ressources from `ClassLoaders` or URLs, without the above-mentioned issues that are now present in `ClassPath` regarding resources.
 Well, technically, I was playing around with `ClassPath.getResources()` to understand its full scope and how its result could help me in order to remove my dependency to [`Apache xbean-finder`](http://tomee.apache.org/dev/xbean-finder.html) (if you don't know what `ResourceFinder` is, you should really check this page). I first checked `ResourceInfo.getName()` which gives me the name relative to the jar or the class path. Ok. But I had duplicates (because of the parent classpath). So I tried printing the result of `ResourceInfo.url()` to find which jar I was using then a `NullPointerException` happened. I filtered those `NullPointerException` out and started to have something correct, but I had to play with strings a lot instead of a simple `ClassLoader` in order to find my own resources.

This is where `ResourceFinder` helps a lot. It does all that but... in a kind of bad way: the API is clearly suboptimal and barely understandable and the documentation is spread all over the web (the best I could see was [this stackoverflow answer](http://stackoverflow.com/a/7237152/180719) and there are functionality that miss like resource-pattern matching or filtering (though Java 8 helps a lot now). Also, there is that "functionality" that itches which is that a resource holder is removed if it cannot read something once in it.

My conclusion is that `ClassPath.getResources()` is a work in progress and can be made much more efficient if it were decoupled from `ClassPath` into its own API which could be extended in some formidable way.
 I was playing with `ClassLoader.getResources()` and I expected more of it. The main issue is NOT that exceptions are thrown, but rather that `ClassLoader.getResources()` is too focused on the whole classpath (workarounds exist as you mentioned). I expected it to be similar to Apache's `ResourceFinder` or at least to enable me to go in that direction, I was wrong.

Why did I check that method? Because ResourceFinder is useful but has a bad API and has lots of issues in its implementation and I'm therefore looking for an alternative. 

In that regard, the current `ClassPath.getResources()` is only a step in that  direction.

Ideally, I would like to see an API in Guava that allows to efficiently locate resources. If such an api would exist, it could help
- providing a better java.util.ServiceLoader
- providing list of ResourceBundles
- getting rid of resource descriptors (files that only list the available resources)
- searching for resources rather than finding them
- unifying a filesystem and jar file in a single API for resources
 Ok, here are some examples I want to show based on my own implementation (not yet completely functional, but it's a work in progress).

``` java
ResourceLocator assetsLocator = new ResourceLocator.Builder()
    .root("/") // All the lookups will prepend this (so, it's possible to use subfolders as default).
    .classLoader(getClass().getClassLoader()) // Search in *this* classloader first for exact names
    .addJar(Paths.get("/location/to/assets.jar")) // Add a jar to search into
    .addJar(Paths.get("/location/to/i18n.jar")) // Add a second jar to search into
    .addFlatDirectory(Paths.get("/location/to/directory")) // this is an "exploded" jar, for instance
    .addJars("/location/to/plugins/*.jar") // Allows the usage of wildcards to grab all the files at once.
    .build();

// Just locate one resource, the first that is found.
Optional<URL> img1 = assetsLocator.locateResource("/img/img1.png");
// Locate several resources matching a wildcard
ImmutableSet<URL> messages = assetsLocator.locateResources("/i18n/*/Messages.properties");
// Locate the /META-INF/MANIFEST.MF of each .jar files.
ImmutableSet<URL> manifests = assetsLocator.locateResources("/META-INF/MANIFEST.MF"); // Will look in all the selected jars to find them.
ImmutableSet<URL> whatever = assetsLocator.locateResources(/* use a Guava or Java 8 Predicate<String> here, the name should be given to the predicate, not the complete URL. */);

// Replace the annoying java.util.ServiceLoader so that we don't instanciate the services.
// It is not possible with ClassPath if the jar file is not yet loaded.
ImmutableSet<Class<? extends Plugin>> pluginClasses = assetsLocator.locateImplementations(Plugin.class);
// Not only allow to locate but also to load resources. ResourceLoader should be an interface with a few "by default" implementations.
Optional<Properties> myProperties = assetsLocator.loadResource("/myProperties.properties", PropertiesLoader.utf8Loader());
```

Note: the wildcard matching should be the same as [`FileSystem.getPathMatcher(String)`](http://docs.oracle.com/javase/8/docs/api/java/nio/file/FileSystem.html#getPathMatcher-java.lang.String-).
 Why aren't all the jars in the classloader in the first place?

Well, it's because my application is an extensible server. The user can download and add plugins dynamically from the network at runtime. At launch, I don't know the plugin names (so they are not in the classpath) and I need to perform several lookups, one for each "pluggable" component. Such a tool would allow that rather easily. Think of this use case as an improved `java.util.ServiceLoader` because it doesn't need to be in the classpath yet, it doesn't instanciate (yeah for Guice) and it doesn't lose time looking where the developer knows it doesn't need to look into.

Finally, I have to admit that I have a small grudge about `ClassLoader.getResources()` because it still returns an `Enumeration`, but that's all accessory ;)
 As Ben suggested, if you know the URLs that your resources might come from,
one option is to make a throw-away URLClassLoader with those URLs (and a
null parent). You could feed that to ClassPath or (if you know the resource
names) use ClassLoader.getResources() directly on it. I think it would be
easier, for me at least, to understand your use case if you could explain
the ways in which this would fall short for it.

2015-04-21 2:38 GMT-07:00 Olivier Grégoire notifications@github.com:

> Why aren't all the jars in the classloader in the first place?
> 
> Well, it's because my application is an extensible server. The user can
> download and add plugins dynamically from the network at runtime. At
> launch, I don't know the plugin names (so they are not in the classpath)
> and I need to perform several lookups, one for each "pluggable" component.
> Such a tool would allow that rather easily. Think of this use case as an
> improved java.util.ServiceLoader because it doesn't need to be in the
> classpath yet, it doesn't instanciate (yeah for Guice) and it doesn't lose
> time looking where the developer knows it doesn't need to look into.
> 
> Finally, I have to admit that I have a small grudge about
> ClassLoader.getResources() because it still returns an Enumeration, but
> that's all accessory ;)
> 
> —
> Reply to this email directly or view it on GitHub
> https://github.com/google/guava/issues/2038#issuecomment-94721790.
 After more tests, it wouldn't fall short (bar the NullPointerException that I cannot explain).

Why does `ClassPath` exist in the first place (before it had the `getResources()` method)? To ease getting classes from a package.

The use case here is the same, but generalized to all types of resources located in a specific set of containers (directories and jars) loaded on the fly; to ease the access to those resources by matching their name and returning their URL. One could think of it like a read-only FileSystem, but for resources where names matter for search but where only the URL are unique.

The cherry on the top would be the possibility to have wildcards to match names (just like `FileSystem.getPathMatcher()`) and maybe a transformer to facilitate transforming the resources into usable objects using a `ByteProcessor` or an interface similar to `ResourceLoader<T> { T load(ByteSource); }`.
 I re-created a basic implementation (because at work, we have our own non-free proprietary implementation) of what I'd expect here: https://github.com/ogregoire/fror-common/tree/master/src/main/java/be/fror/common/resource

This one uses Java 8, and the ClassPath class (because I didn't want to lose too much time rewriting my own resource scanner). I also added a basic glob implementation. When I had the idea of returning a `Stream`, I got rid of the `ResourceLoader` since mapping could easily be done from a `Stream`. The `NullPointerException` issue is taken care of.

The implementation will probably change over time as I improve it, but you have the basic idea.
 I've updated the class to show a basic implementation of how this class can replace ServiceLoader. The test is currently working but I have a lot of issues with the `ClassLoader` management.

Also, I reintroduced the `ResourceLoader` to handle the `IOException` properly without being a real hassle for the user.
 Since this, 2 years ago, I found [Reflections](https://github.com/ronmamo/reflections) which does all this extremely well, though its API is really lacking the good guidance you guys have been consistently offering. If you're looking for a way to close this issue, I believe Reflections is the answer.  Uncorrect hashCode() implementation at com.google.common.base.Absent and com.google.common.base.Present - for example if hashCode() of reference at Present return 0 then it hashCode() equal Absent.

example: Optional.absent() has same hash code as Optional.of(0.0) or Optional.of(0)
  Some tests in `LongMathTest` test about nothing as they use `ALL_INTEGER_CANDIDATES`. For example, `expectedSuccess` in `testCheckedAdd` is always true.
  In some cases, I know that there will be at most one value for some key in a multimap, and it is pretty annoying to get the value out by the iterator and then check hasNext() and get by next(), especially if the multimaps are nested in each other.

could we wrap it and provide a method on Multimap
public Optional<V> getFirstValue(K key);
Just return the first Value by Iterator or Absent.

Similar to XMLNode.getFirstChild()
   Currently, `FluentIterable.from` is not variant in its `E` parameter. I present my use case for `from` being covariant in its type parameter:

```
Map<String, ListenableFuture<String>> futures;
ListenableFuture<?> otherFuture1;
ListenableFuture<Object> otherFuture2;

// won't compile
Iterable<ListenableFuture<?>> allActiveFutures = FluentIterable.from(futures.values())
        .append(otherFuture1)
        .append(otherFuture2)
        .filter(Predicates.not(Predicates.isNull()));

// wait for all fs to finish
```

I would like to be able to declare `FluentIterable.<ListenableFuture<?>>from(futures.values())`, but that's not currently possible. Instead, I have to do this:

```
FluentIterable.from(Collections.<ListenableFuture<?>>unmodifiableCollection(futures.values()))
```

or something along those lines, which is ugly.

As a side point, `Iterables.unmodifiableIterable` is not covariant either, whereas `Collections.unmodifiableCollection` is...
  `Range` implements it, so it would be natural if `RangeSet` also does.
  Perhaps people would find it useful to find a utility to watch for file changes in Guava? I would have. ;-)

Apache Commons IO had a FileMonitor; that was based on polling files from a background thread.  I just published something similar, but mine is based on the modern Java 7 JDK's WatchService instead, see http://blog2.vorburger.ch/2015/04/java-7-watchservice-based.html; DirectoryWatcher etc. src currently part of https://github.com/vorburger/HoTea - if this is of any interest, do let me know here; no offense taken either if you close this as N/A.
 @ronshapiro @cgdecker I'm still alive and if there's any interest for this, would be willing to raise a PR proposing to contribute a starting point for such a thing based on (above) from what I had done in https://github.com/vorburger/HoTea/tree/master/ch.vorburger.hotea/src/main/java/ch/vorburger/hotea/watchdir - I'm sure it would deserve to be torn apart, but could be starting point to kick this off.  Because Guava's collection classes (e.g. `ImmutableList`) do not override `spliterator()` they inherit the default implementation which has a characteristics of `SIZED` and `SUBSIZED`. This means that they cannot be used for parallel processing with ForkJoin.

Expected behavior: `Immutable*` should provide a more efficient `spliterator()` implementation.
 I found posts going back 1-2 years talking about adding Java8 support in the near future: http://www.reddit.com/r/java/comments/1y9e6t/ama_were_the_google_team_behind_guava_dagger/cfjd2qi and https://groups.google.com/forum/#!topic/guava-discuss/fEdrMyNa8tA

Is there an open issue tracking this work?

Is there a short-term workaround I can use in the meantime?
 > The primary issue is Google internal?

I don't understand the question.

> As it stands, for essentially all immutable collections, a good implementation is
> 
> IntStream.range(0, collection.size()).mapToObj(collection.asList()::get)

This won't do because `spliterator().characteristics()` will return `ORDERED | SIZED | SUBSIZED`. It is missing `IMMUTABLE`.
 > The Google internal Comment was a statement, not a question.

It had a question mark after it... :)

> I'm not certain the IMMUTABLE characteristic is actually used for anything?

Agreed. I thought that this was being used for parallelization but it looks like it is not. So for now I don't have a concrete use-case for this characteristic.

> That should still be an adequate substitute for most use cases I can think of...

Okay, but it is worth noting that the only characteristic it adds over the default is `ORDERED`. That said, it is useful for clients that wishs to jump to the end of a list: http://stackoverflow.com/a/29553490/14731.
  `Iterables.transform` and `Iterators.transform` are declared like so:

```
public static <F, T> Iterator<T> transform(Iterator<F> fromIterator, Function<? super F, ? extends T> function);
public static <F, T> Iterable<T> transform(Iterable<F> fromIterable, Function<? super F, ? extends T> function);
```

`Suppliers.compose` is declared like so:

```
public static <F, T> Supplier<T> compose(Function<? super F, T> function, Supplier<F> supplier);
```

These 3 methods are conceptually doing the same thing - taking values out of a 'producer' object (iterator/iterable/supplier) and lazily transforming them using a function. So they should all look the same, and in particular, have arguments in the same order.

To make them consistent, I suggest that `Suppliers.compose` is deprecated in favour of the following method:

```
public static <F, T> Supplier<T> transform(Supplier<F> supplier, Function<? super F, ? extends T> function);
```
 Transformation and composition are different things:
- Transformation is a mapping from A → B to F&lt;A&gt; → F&lt;B&gt;, where F is a functor (e.g. Iterable, List, Iterator).
- Composition is the result of combining A → B and B → C (which gives A → C).

However, Supplier&lt;A&gt; can be treated as both a function of type () → A and a functor. This means that:
- Suppliers.compose should definitely not be deprecated, because Supplier is a function.
- Suppliers.transform would make sense.
  Sometimes it is necessary to replace line endings in some text with platform line endings. One way to do it is to call CharSource.readLines() and then pass the returned list to CharSink.writeLines(). While this   solves the problem, this is not very efficient, because it allocates an intermediate ImmutableList which can be huge.

It would be nice to have a method CharSource.writeLinesTo(CharSink), which does the same job without allocating an intermediate list.
  I used Guava 18 to test [APILyzer](http://apilyzer.revelc.net/) and found one issue with Guava's API.  The public method [PotentialDeadlockException.getConflictingStackTrace()](https://github.com/google/guava/blob/v18.0/guava/src/com/google/common/util/concurrent/CycleDetectingLockFactory.java#L582) returns [ExampleStackTrace](https://github.com/google/guava/blob/v18.0/guava/src/com/google/common/util/concurrent/CycleDetectingLockFactory.java#L517) which is a private type.  [PotentialDeadlockException](https://github.com/google/guava/blob/v18.0/guava/src/com/google/common/util/concurrent/CycleDetectingLockFactory.java#L568) is a public inner class of [CycleDetectingLockFactory](https://github.com/google/guava/blob/v18.0/guava/src/com/google/common/util/concurrent/CycleDetectingLockFactory.java#L166) which also public.
  Hi, decided it will be nice to have an Optional version to the get methods of Iterables.
Also as suggested here https://github.com/google/guava/issues/1742 but with a minor difference:

Both methods will return Optional.absent if the position is grater then the requested index and will also return Optional.absent if the value in the requested index is null.

thoughts ?
 I signed it.
 Sure you could do 

``` Java
Optional.fromNullable(Iterables.get(iterable, index, null));
```

But I think it's quite a mouthful, plus there is that null where the default value is which is not a big deal when you use the 

``` Java
optionalGet(list , 4, myDeafultValue)
```

But it reduces readability when all you need is 

``` Java
optionalGet(list , 4)
```

Debugging a code with this line

``` Java
Optional.fromNullable(Iterables.get(iterable, index, null));
```

Will make you enter `iterables.get` implementation to understand the null value.
 :thumbsup: I agree with gotenxds. 
  Request for Longs.toByteArray and Ints.toByteArray (maybe others?) to add overload accepting a byte[] argument to avoid the new byte[8] allocation.
 Ah yep, thanks!

On Mon, Apr 6, 2015 at 9:20 AM, Colin Decker notifications@github.com
wrote:

> Agreed, this is what ByteBuffer.putLong(long) is for.
> 
> —
> Reply to this email directly or view it on GitHub
> https://github.com/google/guava/issues/2023#issuecomment-90129591.
  the javadoc for ExplicitOrdering says it will throw a ClassCastException if any elements are not in the explicit list defined for the ordering.  However, this depends on the comparator actually getting called.  In the case of sorting a list with a single item that is not present in the explict ordering list, an exception is not thrown because the underlying call to Arrays.sort will not call the comparator for a 1 item array.
  Maybe is intential.

I have that:

``` java
    Properties properties = new Properties();
    properties.put( "key" , null ); 
    // I know its impossible. It should show the problem
    // By me it happens because a Sytem.property value is null (with the time).
    // I´m not sure why?
    ...
    Map propertiesMap = Maps.fromProperties( properties );
```

Actual impl:

``` java
@GwtIncompatible("java.util.Properties")
  public static ImmutableMap<String, String> fromProperties,    Properties properties) {
    ImmutableMap.Builder<String, String> builder = ImmutableMap.builder();

    for (Enumeration<?> e = properties.propertyNames(); e.hasMoreElements();) {
      String key = (String) e.nextElement();
      builder.put(key, properties.getProperty(key));
    }

    return builder.build();
  }
```

The `properties.propertyNames()` is the problem. It throws a NPE.
The `properties.stringPropertyNames()` would be return a empty keySet(). 
  I suggest adding (possibly infinite) generators to the Iterators class. The idea is to have an Iterator presenting a possibly infinite sequence of values, generated on the fly a generator function so you don't have to keep all of that in memory at once. 

Two use cases are provided as unit tests: 
a) some kind of endless computation 
b) iterating over possibly infinite input. 
 I've signed it now.

On Wed, Apr 1, 2015 at 12:27 AM, googlebot notifications@github.com wrote:

> Thanks for your pull request.
> 
> It looks like this may be your first contribution to a Google open source
> project, in which case you'll need to sign a Contributor License Agreement
> (CLA) at https://cla.developers.google.com/.
> 
> If you've already signed a CLA, it's possible we don't have your GitHub
> username or you're using a different email address. Check the information
> on your CLA https://cla.developers.google.com/clas or see this help
> article on setting the email on your git commits
> https://help.github.com/articles/setting-your-email-in-git/.
> 
> Once you've done that, please reply here to let us know. If you signed the
> CLA as a corporation, please let us know the company's name.
> 
> —
> Reply to this email directly or view it on GitHub
> https://github.com/google/guava/pull/2020#issuecomment-88271134.
 Found it, at last. There was a wrong email address in the commits. I
authored everything myself.

On Wed, Apr 1, 2015 at 12:30 AM, googlebot notifications@github.com wrote:

> We found a Contributor License Agreement for you (the sender of this pull
> request), but were unable to find agreements for the commit author(s). If
> you authored these, maybe you used a different email address in the git
> commits than was used to sign the CLA (login here
> https://cla.developers.google.com/ to double check)? If these were
> authored by someone else, then they will need to sign a CLA as well, and
> confirm that they're okay with these being contributed to Google.
> 
> —
> Reply to this email directly or view it on GitHub
> https://github.com/google/guava/pull/2020#issuecomment-88271614.
  Guice depends on Cache, RemovalListener, RemovalNotification, etc....
 @sameb I think this can be closed, as it was done already in https://github.com/google/guava/commit/f79d64fa7dd2adc19e29cbef6cd98ad106d1692a
  The project [memory-measurer](https://code.google.com/p/memory-measurer) was removed. Guava's documentation link [Footprint of JDK/Guava data structures](https://code.google.com/p/memory-measurer/wiki/ElementCostInDataStructures) is 403 (Forbidden).

I wanted to verify my [analysis](https://github.com/ben-manes/caffeine/wiki/Memory-overhead) using [jamm](https://github.com/jbellis/jamm). Using OpenJDK's [Java Object Layout](http://openjdk.java.net/projects/code-tools/jol/) will be the best, but due to its immaturity it isn't as easy to quickly script.
 There's a broken link to this page in the sidebar still.
 Sorry, "the sidebar" isn't very helpful, is it?  At the bottom of the [_Wiki_ sidebar](https://github.com/google/guava/wiki) there's a link titled "Footprint of JDK/Guava data structures" that points to `http://code.google.com/p/memory-measurer/wiki/ElementCostInDataStructures`.
  Please fix the `ImmutableSortedMultiset::naturalOrder` generic type so that classes that are subclasses of classes implementing `Comparable` can be used.

Here is a snippet showing the issue:

```
public class ImmutableSortedCollectionsComparison {
  public static void main(String[] args) {
    ImmutableSortedSet     <MySubComparable> sortedSet      = ImmutableSortedSet     .<MySubComparable>naturalOrder().build();
    ImmutableSortedMultiset<MySubComparable> sortedMultiset = ImmutableSortedMultiset.<MySubComparable>naturalOrder().build();
  }
}
class MyComparable implements Comparable<MyComparable> {
  @Override public int compareTo(MyComparable o) { return 1; }
}
class MySubComparable extends MyComparable { }
```

The line of the `ImmutableSortedSet` will compile nicely, but the one of the `ImmutableSortedMultiset` won't.

Here's the faulty signature of `ImmutableSortedMultiset::naturalOrder`:

```
public static <E extends Comparable<E>> ImmutableSortedMultiset.Builder<E> naturalOrder()
```

And here is the expected signature:

```
public static <E extends Comparable<?>> ImmutableSortedMultiset.Builder<E> naturalOrder()
```

Which will then be similar to the working `ImmutableSortedSet::naturalOrder`:

```
public static <E extends Comparable<?>> ImmutableSortedSet.Builder<E> naturalOrder()
```
  Add a method that transforms a list of functions to a function which returns a list:

``` java
public static <I, A> Function<I, List<A>> allAsList(Iterable<Function<I, A>> list)
```
  Alternative way to get AssertionError instance in com.google.common.util.concurrent.GeneratedMonitorTest, since 
public AssertionError(String message, Throwable cause) 
does not exist in Java 6 yet.
 I thought I have signed the cla, but only after I created the pull request.
Is that the reason, or do I need to sign a different one?
  There exists a null `OutputStream` with `ByteStreams.nullOutputStream()`. It would be nice to have the counterpart `ByteStreams.nullByteSink()` that has methods that would specifically not do anything.

The use case I have is the following:

I have files for which I want to compute the `HashCode` and only that. So I'm using this code:

```
try (HashingInputStream in = new HashingInputStream(Hashing.sha1(), Files.newInputStream(path))) {
  while (in.read() >= 0) { /* do nothing */ }
  return in.hash();
}
```

Ideally I want to read those bytes but not doing anything. This code is great, does it as expected, but it is not really understandable at first glance that I'm actually skipping all of those. I checked some alternatives, like `ByteStreams.copy(in, ByteStreams.nullOutputStream())` or `ByteStreams.read(in, NullByteProcessor.INSTANCE)`, with `NullByteProcessor` doing what you think it does, but those always call several methods. So, how to wrap that null read properly?

I saw that `ByteSink.writeFrom(InputStream)` exists and I thought that maybe a `NullByteSink.writeFrom(InputStream)` is the exact proper way to wrap the `while (in.read() >= 0) { /* do nothing */ }` loop.

If it were implemented, I don't really know where I'd put that NullByteSink: in `ByteStreams.nullByteSink()`? In `ByteSink.nullByteSink()`? Your call ;)
 No, I had not seen that. And it will be absolutely perfect for me, thanks!

However, that's a bit something I find awful with Guava. All the functionalities are available, but are nowhere to be found. For instance, I'm using paths using Java 7-8 nio, so I'm naturally drawn to use something common between those API and what I know of Guava, the streams. Once I have the streams, well I couldn't find any solution. I had checked both [HashingExplained](https://code.google.com/p/guava-libraries/wiki/HashingExplained) and the [`c.g.c.hash package`](http://docs.guava-libraries.googlecode.com/git-history/release/javadoc/com/google/common/hash/package-summary.html) and none of those ever mentioned [`Files.hash(File, HashFunction)`](http://docs.guava-libraries.googlecode.com/git-history/release/javadoc/com/google/common/io/Files.html#hash%28java.io.File,%20com.google.common.hash.HashFunction%29) Of course, going the good old "File" way solves this, but I kind of try avoid using files ever since I use Java 7, like a lot of people, to be honest, as I can see on StackOverflow.

I have the answer to my use case yet I leave the ticket open, so if you think about nice other use cases of the null `ByteSink`, just keep it open.
 @kluever No need to apologize. Guava is extremely well done and thought. Indeed the documentation is sometimes a bit lacking, but there's nothing to apologize for. ;)
  It would be very useful if testlib supported Java 8 collections. This might be done with an extension module or, where possible, reflective invocations. For example Map's compute and merge functions.
  From time to time I have to traverse tree-based data structures where starting point are multiple root nodes  e.g. traversing files with TreeTraverser.breadthFirstTraversal(dir1, dir2, dir3) with one single call. 

One could sometimes create a single virtual root node and skip this node but it feels like a work-around.
 I am not quite sure what is your use case, and how to reproduce the issue.

Would you please put the problem in plain English with an example?
 Let's say you have a tree-based data structure like UI components where each component can be a container of children components.
My use case would be to travers several independent trees uniformly
`List<UIComponent> uiComponents = Lists.newArrayList(page1, page3, page5);`
e.g. in breadth first traversal

```
Optional<UICompontent> greenButton =
    treeTraverser.breadthFirstTraversal(uiComponents)
                 .firstMatch(greenButtonPredicate)
```

or like my directory traversal example
`Iterable<File> logFiles = fileTraverser.breadthFirstTraversal(apacheLogDir, mysqlLogDir, ...);`

I hope this use case is clear now and not pure invention. Is there a better approach I overlooked?
 Right. It is a better overview but where exactly the problem strikes? When that odd thing happens? Thanks.
 Current TreeTraverser methods breadthFirstTraversal(T), postOrderTraversal(T) and preOrderTraversal(T) require a **single** root node.
I need something like breadthFirstTraversal(Iterable<T> roots), postOrderTraversal(Iterable<T> roots) or preOrderTraversal(Iterable<T> roots).
 The concat(...) approach provided expects order for pre-order iteration.
```
Traverser t = Traverser.forTree(n -> yourChildrenMethod(n));
Iterable nodeList = Iterables.concat(
    t.depthFirstPreOrder(page1), 
    t.depthFirstPreOrder(page3), 
    t.depthFirstPreOrder(page5));
```
Given breadthFirst(...) example would iterate as follows:
1. page1 and children in bf-order
2. page3 and children in bf-order
3. page5 and children in bf-order

but requested order should be:
1. page1, page3 and page5
2. 1st level of page1, 1st level of page3 and 1st level of page5
3. 2nd level of page1, 2nd level of page3 and 2nd level of page5
4. and so on

I'm still waiting for Guava implementation in order to replace my own implementation.

Please reopen this issue again.  I ran into a situation where I was using recursion and lazy iteration to emulate the in-order traversal path of a binary tree, but wasn't able to use `Iterators.concat` due to its non gc friendly implementation.

(Note: the amount of memory that should be needed to run this is `O(maxDepth)` or `O(log N)`)

Here's code to trigger the issue, and a potential solution: https://gist.github.com/devinrsmith/121d9a5ebd460c3bbaa0
 To clarify a bit:

`public static <T> Iterator<T> concat(
      final Iterator<? extends Iterator<? extends T>> inputs)`

_is_ gc friendly if and only if the given iterator is gc friendly.

The other `concat` methods are backed by `ImmutableList.iterator()` which doesn't allow `concat` to be gc friendly.
 Hi @lowasser,

That's not a bad idea for this specific example's use case... this example's use case was a bit simplified though to try and clearly isolate and illustrate the `concat` issue.

But the larger issue still stands: the helper `concat` methods aren't gc friendly. 

I should have specified this in the initial comment: the guava concat runs out of heap space, whereas my suggested modification does not.
 I've added an example that more clearly isolates the gc unfriendliness of `concat`.

https://gist.github.com/devinrsmith/121d9a5ebd460c3bbaa0#file-guavaconcatissuebigobject-java 
  To easily visually compare elapsed times with different orders of magnitude, please overload the method `Stopwatch::toString()` with `Stopwatch::toString(TimeUnit)` (or something similar) where we can then pass a specific `TimeUnit` which allows us to see actual differences.

The current implementation is very nice to see how much time a portion of code took to execute, but if we want to compare, it'd be nice to normalize the TimeUnit.

My use case is the following: I have a hundred time measures and I often have orders of magnitude of difference between those:

```
A took 12.34 ms
B took 23.45 µs
C took 34.56 ms
```

And then we're ask ourselves "oh wait, was B "ms" or "μs" ?" And we gotta check again. Oh, so B was (roughly) 500 times faster than A.

If I always select the same `TimeUnit` (milliseconds in this case), I can have this:

```
A took 12.34 ms
B took 0.023 ms
C took 34.56 ms
```

Then it's really clear that B took a fraction of time of what A used.

A comment in Guava's code for `toString()` also mentions `Too bad this functionality is not exposed as a regular method call`. Which seems to mean that someone else also kind of needed a similar behavior.
 I see the point, and if we start to add the precision and the RoundingMode as parameter, it starts to be a lot of parameters. Well the idea is here, I trust the team to find the best way to add this if this idea is retained.
  Instead of implementing TreeTraverser.children(T) in anonymous classes each time a function that retrieves children from each node could be handy also.

What about this static method at TreeTraverser 

``` java
static <T> TreeTraverser<T> fromFunction(final Function<? super T, ? extends Iterable<? extends T>> descendants) {
  return new TreeTraverser (...);
}
```

and a possible implementation as proposal.

``` java
/**
 * @see Traversers#fromFunction(Function)
 */
static final class TreeTraverserFromFunction<T> extends TreeTraverser<T> {

  private final Function<? super T, ? extends Iterable<? extends T>> descendants;

  TreeTraverserFromFunction(final Function<? super T, ? extends Iterable<? extends T>> children) {
    descendants = checkNotNull(children);
  }

  @Override
  public Iterable<T> children(final T root) {
    @SuppressWarnings("unchecked")
    final Iterable<T> checkedIterable = (Iterable<T>) descendants.apply(root);
    return checkedIterable;
  }

  @Override
  public String toString() {
    return "TreeTraverser.fromFunction(" + descendants + ")";
  }

}
```
 +1
 I see this has been completed now (at least to some extent).

Does any more work need to be done on this (like doing a lambda version of `BinaryTreeTraverser`)? Or can this issue be closed now?
 Yeah, we still need to do it for BinaryTreeTraverser too.

On Sat, Sep 24, 2016 at 11:43 AM, Jonathan Bluett-Duncan <
notifications@github.com> wrote:

> I see this has been completed now (at least to some extent).
> 
> Does any more work need to be done on this (like doing a lambda version of
> BinaryTreeTraverser)? Or can this issue be closed now?
> 
> —
> You are receiving this because you commented.
> Reply to this email directly, view it on GitHub
> https://github.com/google/guava/issues/2006#issuecomment-249380776, or mute
> the thread
> https://github.com/notifications/unsubscribe-auth/AA5Cl867VAMPT1_BRLFPAn9vfXNb73M3ks5qtW9UgaJpZM4DxV_S
> .

## 

Kevin Bourrillion | Java Librarian | Google, Inc. | kevinb@google.com
  https://code.google.com/p/guava-libraries/wiki/CachesExplained#Features

"So, for example, iterating through cache.entrySet() does not reset access time for the entries you retrieve."

should probably be

"So, for example, iterating through cache.asMap().entrySet() does not reset access time for the entries you retrieve."
  https://code.google.com/p/guava-libraries/wiki/CachesExplained#Interruption

"(wrapped in an ExceptionException)"
should probably be
"(wrapped in an ExecutionException)"
 ExceptionException vs ExecutionException???
  ```
InternetDomainName.from("bucket.s3.amazonaws.com").topPrivateDomain()
```

 returns bucket.s3.amazonaws.com instead of "amazonaws.com". Strangely enough 

```
InternetDomainName.from("a.b.c.com").topPrivateDomain()
```

works just fine
 thanks! I'll close this then
  @cpovirk Guava compiled with GWT 2.6.1 dependency cannot be used by gwt.-maven-plugin 2.7.0 Any idea when GWT 2.7.0 will be supported? Thank you
 For information, I have tried guava 20.0-SNAPSHOT with gwt 2.8-beta1.
it works fine with a full compilation but not with dev mode and super dev mode ; I have this exception : 

``` java
[INFO] com.google.gwt.dev.jjs.InternalCompilerException: Unexpected error during visit.
[INFO]  at com.google.gwt.dev.jjs.ast.JVisitor.translateException(JVisitor.java:111)
[INFO]  at com.google.gwt.dev.jjs.ast.JVisitor.accept(JVisitor.java:130)
[INFO]  at com.google.gwt.dev.jjs.ast.JVisitor.accept(JVisitor.java:122)
[INFO]  at com.google.gwt.dev.jjs.ast.JTransformer.transform(JTransformer.java:1056)
[INFO]  at com.google.gwt.dev.jjs.impl.GenerateJavaScriptAST$GenerateJavaScriptTransformer.transform(GenerateJavaScriptAST.java:2515)
[INFO]  at com.google.gwt.dev.jjs.impl.GenerateJavaScriptAST$GenerateJavaScriptTransformer.transformExpressionStatement(GenerateJavaScriptAST.java:695)
[INFO]  at com.google.gwt.dev.jjs.impl.GenerateJavaScriptAST$GenerateJavaScriptTransformer.transformExpressionStatement(GenerateJavaScriptAST.java:514)
[INFO]  at com.google.gwt.dev.jjs.ast.JTransformer$JRewriterVisitor.visit(JTransformer.java:730)
[INFO]  at com.google.gwt.dev.jjs.ast.JExpressionStatement.traverse(JExpressionStatement.java:41)
[INFO]  at com.google.gwt.dev.jjs.ast.JVisitor.accept(JVisitor.java:127)
[INFO]  at com.google.gwt.dev.jjs.ast.JVisitor.accept(JVisitor.java:122)
[INFO]  at com.google.gwt.dev.jjs.ast.JTransformer.transform(JTransformer.java:1056)
[INFO]  at com.google.gwt.dev.jjs.ast.JTransformer.transformIntoExcludingNulls(JTransformer.java:1076)
[INFO]  at com.google.gwt.dev.jjs.impl.GenerateJavaScriptAST$GenerateJavaScriptTransformer.transformBlock(GenerateJavaScriptAST.java:578)
[INFO]  at com.google.gwt.dev.jjs.impl.GenerateJavaScriptAST$GenerateJavaScriptTransformer.transformBlock(GenerateJavaScriptAST.java:514)
[INFO]  at com.google.gwt.dev.jjs.ast.JTransformer$JRewriterVisitor.visit(JTransformer.java:622)
[INFO]  at com.google.gwt.dev.jjs.ast.JBlock.traverse(JBlock.java:91)
[INFO]  at com.google.gwt.dev.jjs.ast.JVisitor.accept(JVisitor.java:127)
[INFO]  at com.google.gwt.dev.jjs.ast.JVisitor.accept(JVisitor.java:122)
[INFO]  at com.google.gwt.dev.jjs.ast.JTransformer.transform(JTransformer.java:1056)
[INFO]  at com.google.gwt.dev.jjs.impl.GenerateJavaScriptAST$GenerateJavaScriptTransformer.transform(GenerateJavaScriptAST.java:2523)
[INFO]  at com.google.gwt.dev.jjs.impl.GenerateJavaScriptAST$GenerateJavaScriptTransformer.transformMethodBody(GenerateJavaScriptAST.java:812)
[INFO]  at com.google.gwt.dev.jjs.impl.GenerateJavaScriptAST$GenerateJavaScriptTransformer.transformMethodBody(GenerateJavaScriptAST.java:514)
[INFO]  at com.google.gwt.dev.jjs.ast.JTransformer$JRewriterVisitor.visit(JTransformer.java:829)
[INFO]  at com.google.gwt.dev.jjs.ast.JMethodBody.traverse(JMethodBody.java:81)
[INFO]  at com.google.gwt.dev.jjs.ast.JVisitor.accept(JVisitor.java:127)
[INFO]  at com.google.gwt.dev.jjs.ast.JVisitor.accept(JVisitor.java:122)
[INFO]  at com.google.gwt.dev.jjs.ast.JTransformer.transform(JTransformer.java:1056)
[INFO]  at com.google.gwt.dev.jjs.impl.GenerateJavaScriptAST$GenerateJavaScriptTransformer.transformMethod(GenerateJavaScriptAST.java:787)
[INFO]  at com.google.gwt.dev.jjs.impl.GenerateJavaScriptAST$GenerateJavaScriptTransformer.generatePrototypeDefinitions(GenerateJavaScriptAST.java:2330)
[INFO]  at com.google.gwt.dev.jjs.impl.GenerateJavaScriptAST$GenerateJavaScriptTransformer.generateTypeSetup(GenerateJavaScriptAST.java:1833)
[INFO]  at com.google.gwt.dev.jjs.impl.GenerateJavaScriptAST$GenerateJavaScriptTransformer.transformDeclaredType(GenerateJavaScriptAST.java:641)
[INFO]  at com.google.gwt.dev.jjs.impl.GenerateJavaScriptAST$GenerateJavaScriptTransformer.transformDeclaredType(GenerateJavaScriptAST.java:514)
[INFO]  at com.google.gwt.dev.jjs.ast.JTransformer.transformClassType(JTransformer.java:95)
[INFO]  at com.google.gwt.dev.jjs.ast.JTransformer$JRewriterVisitor.visit(JTransformer.java:670)
[INFO]  at com.google.gwt.dev.jjs.ast.JClassType.traverse(JClassType.java:140)
[INFO]  at com.google.gwt.dev.jjs.ast.JVisitor.accept(JVisitor.java:127)
[INFO]  at com.google.gwt.dev.jjs.ast.JVisitor.accept(JVisitor.java:122)
[INFO]  at com.google.gwt.dev.jjs.ast.JTransformer.transform(JTransformer.java:1056)
[INFO]  at com.google.gwt.dev.jjs.impl.GenerateJavaScriptAST$GenerateJavaScriptTransformer.transformProgram(GenerateJavaScriptAST.java:1202)
[INFO]  at com.google.gwt.dev.jjs.impl.GenerateJavaScriptAST$GenerateJavaScriptTransformer.transformProgram(GenerateJavaScriptAST.java:514)
[INFO]  at com.google.gwt.dev.jjs.ast.JTransformer$JRewriterVisitor.visit(JTransformer.java:918)
[INFO]  at com.google.gwt.dev.jjs.ast.JProgram.traverse(JProgram.java:1252)
[INFO]  at com.google.gwt.dev.jjs.ast.JVisitor.accept(JVisitor.java:127)
[INFO]  at com.google.gwt.dev.jjs.ast.JVisitor.accept(JVisitor.java:122)
[INFO]  at com.google.gwt.dev.jjs.ast.JTransformer.transform(JTransformer.java:1056)
[INFO]  at com.google.gwt.dev.jjs.impl.GenerateJavaScriptAST.execImpl(GenerateJavaScriptAST.java:3014)
[INFO]  at com.google.gwt.dev.jjs.impl.GenerateJavaScriptAST.exec(GenerateJavaScriptAST.java:2795)
[INFO]  at com.google.gwt.dev.jjs.JavaToJavaScriptCompiler.compilePermutation(JavaToJavaScriptCompiler.java:378)
[INFO]  at com.google.gwt.dev.jjs.JavaToJavaScriptCompiler.compilePermutation(JavaToJavaScriptCompiler.java:272)
[INFO]  at com.google.gwt.dev.CompilePerms.compile(CompilePerms.java:198)
[INFO]  at com.google.gwt.dev.ThreadedPermutationWorkerFactory$ThreadedPermutationWorker.compile(ThreadedPermutationWorkerFactory.java:50)
[INFO]  at com.google.gwt.dev.PermutationWorkerFactory$Manager$WorkerThread.run(PermutationWorkerFactory.java:74)
[INFO]  at java.lang.Thread.run(Thread.java:745)
[INFO] Caused by: java.lang.NullPointerException
[INFO]  at com.google.gwt.dev.jjs.ast.JMethod.getQualifiedJsName(JMethod.java:118)
[INFO]  at com.google.gwt.dev.jjs.impl.GenerateJavaScriptAST$GenerateJavaScriptTransformer.createStaticReference(GenerateJavaScriptAST.java:1707)
[INFO]  at com.google.gwt.dev.jjs.impl.GenerateJavaScriptAST$GenerateJavaScriptTransformer.dispatchToStatic(GenerateJavaScriptAST.java:886)
[INFO]  at com.google.gwt.dev.jjs.impl.GenerateJavaScriptAST$GenerateJavaScriptTransformer.transformMethodCall(GenerateJavaScriptAST.java:874)
[INFO]  at com.google.gwt.dev.jjs.impl.GenerateJavaScriptAST$GenerateJavaScriptTransformer.transformMethodCall(GenerateJavaScriptAST.java:514)
[INFO]  at com.google.gwt.dev.jjs.ast.JTransformer$JRewriterVisitor.visit(JTransformer.java:835)
[INFO]  at com.google.gwt.dev.jjs.ast.JMethodCall.traverse(JMethodCall.java:246)
[INFO]  at com.google.gwt.dev.jjs.ast.JVisitor.accept(JVisitor.java:127)
[INFO]  ... 52 more
[INFO]                [ERROR] at MapMaker.java(116): MapMaker$ExpiringComputingMap.setTimeout(new MapMaker$ExpiringComputingMap$1(this, key, value), LongLib.toInt(this.expirationMillis))
[INFO]                   com.google.gwt.dev.jjs.ast.JMethodCall
[INFO]                [ERROR] at MapMaker.java(116): MapMaker$ExpiringComputingMap.setTimeout(new MapMaker$ExpiringComputingMap$1(this, key, value), LongLib.toInt(this.expirationMillis))
[INFO]                   com.google.gwt.dev.jjs.ast.JExpressionStatement
[INFO]                [ERROR] at MapMaker.java(107): {
[INFO]   MapMaker$ExpiringComputingMap.setTimeout(new MapMaker$ExpiringComputingMap$1(this, key, value), LongLib.toInt(this.expirationMillis));
[INFO] }
[INFO]                   com.google.gwt.dev.jjs.ast.JBlock
[INFO]                [ERROR] at MapMaker.java(107): {
[INFO]   MapMaker$ExpiringComputingMap.setTimeout(new MapMaker$ExpiringComputingMap$1(this, key, value), LongLib.toInt(this.expirationMillis));
[INFO] }
[INFO]                   com.google.gwt.dev.jjs.ast.JMethodBody
[INFO]                [ERROR] at MapMaker.java(42): com.google.common.collect.MapMaker$ExpiringComputingMap (extends LinkedHashMap implements ConcurrentMap)
[INFO]                   com.google.gwt.dev.jjs.ast.JClassType
[INFO]                [ERROR] at Unknown(0): <JProgram>
[INFO]                   com.google.gwt.dev.jjs.ast.JProgram
[INFO]             [ERROR] Unrecoverable exception, shutting down
[INFO] com.google.gwt.core.ext.UnableToCompleteException: (see previous log entries)
[INFO]  at com.google.gwt.dev.javac.CompilationProblemReporter.logAndTranslateException(CompilationProblemReporter.java:106)
[INFO]  at com.google.gwt.dev.jjs.JavaToJavaScriptCompiler.compilePermutation(JavaToJavaScriptCompiler.java:459)
[INFO]  at com.google.gwt.dev.jjs.JavaToJavaScriptCompiler.compilePermutation(JavaToJavaScriptCompiler.java:272)
[INFO]  at com.google.gwt.dev.CompilePerms.compile(CompilePerms.java:198)
[INFO]  at com.google.gwt.dev.ThreadedPermutationWorkerFactory$ThreadedPermutationWorker.compile(ThreadedPermutationWorkerFactory.java:50)
[INFO]  at com.google.gwt.dev.PermutationWorkerFactory$Manager$WorkerThread.run(PermutationWorkerFactory.java:74)
[INFO]  at java.lang.Thread.run(Thread.java:745)
[INFO]             [ERROR] Not all permutation were compiled , completed (0/1)
```

Someone knows when guava 20 will be released ?
 Yes : https://github.com/gwtproject/gwt/issues/9259
 About exception in my last comment, the error is caused by jsinteropmode. I have forgotten to drop this config. Last guava snapshot seems to be functionnal with gwt 2.8. When can we hope a release ?
Thanks
 Are there any plans to release an RC? GWT 2.8 is just around the corner (RC2 was recently released), and due to a Guava dependency I'm unable to upgrade/test the new version at the moment (well, I'll give a try with a snapshot, but an RC or final release would be nicer).
  If you are in Java 8, you could write this as

```
cache.asMap().getOrDefault(key, value.getFoo());
```

The only negative with that version is that it can't be lazy by accepting a `Supplier`.
  In JDK8, the entrySet view supports additions which the previous version did not. The existing tests fails due because it assumes that all collection views either support additions or disallow it. An addition through the key or value views would not make sense, while the entry view easily supported. Due to the testlib feature set not being able to distinguish the different features that the views may support, this test is not forward compatible as is.

This was discovered when using testlib to validate the `Cache.asMap()` view which should provide similar semantics except serialization support. The following additions have to be added for JDK8, but it would be nice if the features could be specified for the applicable views to avoid disabling tests.

``` java
.suppressing(
    // Suppressed due to entrySet() view supporting additions, while the keySet() and
    // values() views do not. The Guava tests are unable to understand this rational.
    CollectionAddTester.class.getMethod("testAdd_unsupportedNotPresent"),
    CollectionAddAllTester.class.getMethod("testAddAll_unsupportedNonePresent"),
    CollectionAddAllTester.class.getMethod("testAddAll_unsupportedSomePresent"))
```
 Interesting, that commit suppresses those tests for `OpenJdk6MapTests`, whereas I copied from `TestsForMapsInJavaUtil` which does not. What is the rational for the duplication between the two and is the latter enabled?

It **can** support the add contract, but you're right that there is a bug! It should be delegating to `putIfAbsent()`, which is how I implemented it. It appears that there is a typo in OpenJDK which passes `false` to the internal put's `onlyIfAbsent` method. That bug exists in Doug's CVS repo so it should be reported.
 Closing as it appears to be my mistake of borrowing from the wrong test class.
  The two CacheLoader.from methods can be variant in their generic arguments like so:

```
public static <K, V> CacheLoader<K, V> from(Function<? super K, ? extends V> function);
public static <V> CacheLoader<Object, V> from(Supplier<? extends V> supplier);
```

I also think that `from(Supplier)` should take a `K` parameter, so it can be used for any variable taking a `CacheLoader<K, V>`:

```
public static <K, V> CacheLoader<K, V> from(Supplier<? extends V> supplier);
```
  Created a CHANGELOG in the root directory. With proper formatting the app could also read from this file and view the changes within the app. Changelog should be updated with each pull accept. Also, as main developers release updates to the code other contributors will now be able to see the change in the changelog.
 So first of all, this should be CHANGELIST.md.  Much more useful as a markdown file. 

Second, I'm not sure this file adds much value, as a placeholder.  It doesn't include the massive back-fill of change log information, and doesn't provide much structure so it's not really a pull request so much as a documentation request (which is fair, but that's an issue, not a p/r)

Also, we have so much coming out from internal commits, and google's internal commits are usually unique, meaningful changes with a reasonable commit description, that it is nearly certain to be just as valuable to automatically crib the descriptions from the list of commits and use that as a first-draft log of changes.  Maintaining one manually and incrementally may be worth it, but I'm not convinced.

@cgdecker - any opinions?  I'm not sure what you had in mind for release changelogs.  My personal feeling is that we take the full list from the last release and trim it into a changelog.  I do like the idea of demonstrating the delta, the additional features/changes/etc.  
 Appreciate your detailed explanation. I do feel that a changelog that users can quickly skim to see new additions is important. Now as far as actual implementation obviously that does not matter as much to me as the actual active devs.
 fyi, you should consider using [Github releases](https://github.com/blog/1547-release-your-software) instead of a changelog.
    Wouldn't be useful to have collections that can fire events every time an element is added or removed? I can contribute code for generic collections and lists.
 I wasn't aware of it. That library contains only observable lists, not collections too. But adding other observable collection types will make sense to be added there. So I will close the issue.
  Currently, guava-testlib only tests collections using ZERO(0), ONE(1), and SEVERAL(3) collection sizes. I have a collection implementation that switches its internal representation at 10 elements. I would like to use testlib to test my collection around that switching point, but I can't at the moment.

It would be great if one could specify arbitrary sizes to test collections with.
 You could include a LOTS or LARGE size that test up to (say) 100 elements. A lot of collections have got specific implementations for small-ish numbers, then once it gets to 100 elements most degenerate into a general implementation for any number of items.

Testing up to 100 would also test things like internal array resizes - ArrayList has got a default size of 10, HashMap a default size of 16, and the current code doesn't test the array resizes of those classes. And it wouldn't take too long to run as well, 100 is not that much in the grand scheme of things.
 :(  Is it planned to add to Preconditions methods checkNotNull, checkState, checkArgument with 1 or 2 arguments for string template instead of using varargs only?
for example:
public static void checkState(boolean expression, String template, Object arg1) {
        if(!expression) {
            ...
        }
    }
So new Object[] will be created only if expression is false but not each time method is called.
  Cache objects currently do not have a method of introspecting on the current "weight" value.  I am replacing an implementation of a cache that is just a synchronized LinkedHashMap.  In my current implementation of the cache, I'm keeping track of the weights of things being stored and exposing that as a metric about my cache.  This is the _only_ feature of my current implementation that is not covered by Guava's Cache.

From looking at the code, it seemed relatively easy to just create another method parallel to `size()` to handle this case so I just went ahead and did it.  The guidelines do state that API changes should start as an issue, but I didn't realize that until I had already done this and it is such a simple fix, it doesn't bother me if it gets thrown away (as long as I do get some method of introspecting on the current weight value ;) ).

I do realize that this is a public API change, it is only an addition, but it does mean that if anyone else is implementing the Cache interface from scratch, their code will have to be updated before it can work with this.  I'm not sure what level of API compatibility is maintained with Guava, but as long as people are only using Guava-built cache objects, it should be a forward-compatible change.

Also, I updated unit tests as I could find ones that seemed relevant, but I will admit that I didn't read and comprehend all tests, so I might've missed a good place to add some more verification of the weight computation.  Let me know if there are other tests to update and I'll be happy to.

If you think this is going to work, let me know and I'll make sure to get a CLA.
 It seems to be failing when trying to generate the gwt source.  I'll see if I can repro the failure on my local machine and try to fix, but any pointers to what might cause the gwt compilation to fail would be helpful.
 Ok, on my local machine, I cannot seem to download com.google.guava:guava:java-source:19.0-SNAPSHOT

Looks like it is not in sonatype-nexus-snapshots

So, it's failing, but for a different reason...  I guess I'll wait on fixing that until the discussion of whether this API change could even be considered has happened.
 The predecessor, [ConcurrentLinkedHashMap](https://github.com/ben-manes/concurrentlinkedhashmap) introduced the concept of weights and provides a `weightedSize` method. That may be a simpler migration path. (Note: currently moving to Github due to Google Code shutdown)

The JDK8 rewrite, [Caffeine](https://github.com/ben-manes/caffeine), exposes additional inspection including the weighted size through the `Policy` abstraction. That project is maturing quickly but not yet released.
 @ben-manes So, are you suggesting that instead of using a `Cache` in my code I use `ConcurrentLinkedHashMap`?

Can't really use something that isn't released yet :)
 I'm offering it as an option as your changes may not be accepted and you would have to wait for the next release if they are. If all you need are the basic features of its predecessor, then its a reasonable option. The old wiki is in the Github wiki branch since the migration didn't move it over properly.
  When creating a Guava Ordering object using `onResultOf`, a `NullPointerException` in most situations where the function returns `null` even if the object in the collection is not. (This can only be prevented by writing a specialized comparator that checks for null or wrapping the comparator with a comparator that catches `NullPointerException`s, neither of which is optimal.)

Would it be possible to have Guava respect `nullsFirst()`/`nullLast()` with regard to the result of `onResultOf` in addition to the actual object being sorted?
 That would be nice, but it throws a `NullPointerException`. Below is the stack trace (using guava-18.0.jar).

```
Exception in thread "Main Thread" java.lang.NullPointerException
at com.google.common.base.Preconditions.checkNotNull(Preconditions.java:210)
at com.google.common.collect.NaturalOrdering.compare(NaturalOrdering.java:34)
at com.google.common.collect.NaturalOrdering.compare(NaturalOrdering.java:26)
at com.google.common.collect.ByFunctionOrdering.compare(ByFunctionOrdering.java:46)
at com.google.common.collect.NullsLastOrdering.compare(NullsLastOrdering.java:44)
at java.util.Arrays.mergeSort(Arrays.java:1270)
at java.util.Arrays.mergeSort(Arrays.java:1282)
at java.util.Arrays.sort(Arrays.java:1210)
at com.google.common.collect.Ordering.sortedCopy(Ordering.java:817)
```

using the following class

```
  public class A  {

public static void main(String[] args) {
    List<A> as = Lists.newArrayList();
    as.add(new A("a"));
    as.add(new A("e"));
    as.add(new A("c"));
    as.add(new A("a"));
    as.add(new A("b"));
    as.add(new A("f"));
    as.add(new A("d"));
    as.add(new A(null));

    System.out.println(
        Ordering
        .natural()
        .onResultOf(new Function<A,String>(){
            public String apply(A a){
                return a.a;
            }
        })
        .nullsLast()
        .sortedCopy(as));
  }

  A(String a) {
    this.a = a;
  }

  private String a;
}
```
 I git it to work.

Is this documented anywhere? Also, what is the logic in arranging it this way. In other cases the logic is the inverse. For instance, with regard to `natural` the `nullLast` that follows it does not throw exceptions, so why would it do that here. Is there some rule of thumb for this.
 Thanks. I think I got it now.
  When I import Guava in Eclipse using the m2e plugin, the test will be run using Oracle JDK 6. The error then matches the one listed above for "Oracle JDK7".

In this case, the `ResourceInfo` object contains two URLs, the first of which will be used by the test:
- `jar:file:/home/myusername/tools/jdk1.6.0_45/jre/lib/ext/sunpkcs11.jar!/META-INF/JCE_RSA.RSA`
- `jar:file:/home/myusername/tools/jdk1.6.0_45/jre/lib/ext/sunjce_provider.jar!/META-INF/JCE_RSA.RSA`

The system classloader, on the other hand, returns this URL:
- `jar:file:/home/myusername/tools/jdk1.6.0_45/jre/lib/jce.jar!/META-INF/JCE_RSA.RSA`

And indeed, these files differ.
 On the other hand, when I simply run the test using Maven 3.3.1 and Oracle JDK jdk1.8.0_40 on the command line and attach Eclipse as a debugger, the "Oracle JDK8" error listed above is reproduced.

The `urlsFromLoader` contains the following URLs:
- `jar:file:/home/myusername/tools/jdk1.8.0_60_b08/jre/lib/ext/jfxrt.jar!/META-INF/INDEX.LIST`
- `jar:file:/home/myusername/.m2/repository/org/easymock/easymock/3.0/easymock-3.0.jar!/META-INF/INDEX.LIST`
- `jar:file:/home/myusername/.m2/repository/org/objenesis/objenesis/1.2/objenesis-1.2.jar!/META-INF/INDEX.LIST`

While `urlsFromClassPath` only contains:
- `jar:file:/home/myusername/tools/jdk1.8.0_60_b08/jre/lib/ext/jfxrt.jar!/META-INF/INDEX.LIST`
  Just making sure, is it documented somewhere whether for time based and size based eviction can be combined? Or are they mutual exclusive? So far, I haven't found anything saying whether it should be possible or not, but maybe I've just missed it?
 Yes they can be combined. Unless stated in CacheBuilder, the features can be mixed together. 
 Great. Thanks!
 Nah, that's probably enough.
  JDK `Executors` provides several tool methods to create `ThreadPoolExecutor` and `ScheduledThreadPoolExecutor`. But these methods are not flexible. But if build up `ThreadPoolExecutor` and `ScheduledThreadPoolExecutor` from nothing, it will be a little complex. 

Apache Camel has a `ThreadPoolBuilder` but it is complex since bind with `CamelContext`.

So I create a simple builder to create `ThreadPoolExecutor` and `ScheduledThreadPoolExecutor`.
  ImmutableList contains following code since version 15.0

 private static final ImmutableList<Object> EMPTY =
      new RegularImmutableList<Object>(ObjectArrays.EMPTY_ARRAY);
 Here is the minimal test case I could create. It hangs intermittently.

```
public static void main(String[] args) throws Exception {
    new Thread() {
        public void run() {
            ImmutableList.of();
        }
    }.start();

    Thread.sleep(1);

    Class.forName("com.google.common.collect.RegularImmutableList");
}
```

The problem is not just theoretical - we've hit the real deadlock in a large production deployment.
  The inherited doc should be overridden and mentioned that containsValue works in O(1) time in contrast to O(N) with a normal HashMap.

The javadoc for #inverse should mention that it always returns the same Inverse instance and thus saving the Inverse as a separate instance variable is not mandatory to reduce overhead.
 Is this issue approved?  Thi is an updated version with the CLA email that updates the whole codebase with the eclipse formatter that Google provides.
  Hi,

I have applied the eclipse formatter using the Google configuration for Java projects available at https://code.google.com/p/google-styleguide/source/browse/trunk/eclipse-java-google-style.xml
Is there another formatter configuration for this project?

Thanks!
 Done :)
 Perfect, thanks for recovering my text and answer my questions :)
  Reverts (at least in part) a number of changes made to jdk5-backport-v17.0-post to make it more compatible with code built against jdk5-backport-v14.0.1-post, specifically AOSP code. The reverted changes added back methods that had been present in v14 (deprecated and not) and since been removed. The intent is to allow AOSP code that built against v14.0.1 to also build against the compatibility version of v17.0 without modification (or with minimal atomic modifications). That will make upgrading itself easier and will allow other changes such as removing usages of deprecated methods to be done in stages.
  Reverts (at least in part) a number of changes made to jdk5-backport-v17.0-post to make it more compatible with code built against jdk5-backport-v14.0.1-post, specifically AOSP code. The reverted changes added back methods that had been present in v14 (deprecated and not) and since been removed. The intent is to allow AOSP code that built against v14.0.1 to also build against the compatibility version of v17.0 without modification (or with minimal atomic modifications). That will make upgrading itself easier and will allow other changes such as removing usages of deprecated methods to be done in stages.
  The function returned by Functions.forMap is like a limited read-only map. So it should be able to accept more inputs.

This is similar to `java.util.Collections.unmodifiableMap`, which has the following signature:

`public static <K,V> Map<K,V> unmodifiableMap(Map<? extends K, ? extends V> m)`

For example, the following is only possible by wrapping the input map:

``` java
Map<Integer,String> map = ...;
Function<Number,CharSequence> f = 
    Functions.forMap(Collections.<Number,CharSequence>unmodifiableMap(map));
```
 Fair enough, thanks for the reply. 
   ...and assume the identify function.
 Thanks. A default of identity seemed likely to be useful, but it's no big deal.
Our use case is:
- we have a Set<X>, a small number of which need to be remapped to some other value (whilst retaining the original X).
- we create a Map<X, X> using the identity function, then immediately override the values of the ones that need remapping.

Perhaps there are better ways of doing this anyway.
 NP, thanks for the rapid response. 
 FWIW, I'm targeting Java 6, which can't infer the type parameters of Functions.identity(), and have to do the annoying dance of having to supply redundant parameters explicitly, which is probably what sparked my desire to sort this.
  Any plans to take this out of beta?
 Any news on this one? Thanks.
  Would be keen to use these in non-`@Beta`. Are there any plans?
    This is a feature request where the cost may far outweigh the benefit, and I understand that, but I ran into it and think it would be right in principle, if difficult in practice.

Consider the following code:

Iterator<Bar> deserialize(DatabaseConnection conn) {
  return Iterators.transform(conn.fetch(), new Function<Foo, Bar>() {
    @override public Bar apply(Foo foo) {
      Bar.deserialize(foo);
    }});
}

Context:
1) conn.fetch() returns an ImmutableList<Foo>
2) Foo is the serialized form (perhaps a protobuf) of a record, and Bar is the POJO form.
3) A Foo is smaller than a Bar, so you can keep ImmutableList<Foo> in memory, but you can't keep an ImmutableList<Foo> in memory while you operate on each Bar.

The result is that, instead, we copy the ImmutableList into an array and then create an Iterator that in each call to next() nulls out that slot in the array.

It would be awesome if ImmutableList's Iterator allowed earlier elements in the list to be garbage.
  I don't know much about how ImmutableList is implemented.

In a naive singly linked list, I would expect the iterator to have this property. Would that be a reasonable expectation?

All I'm saying is:
1) this property is desirable
2) you could implement ImmutableList having this property
3) it would be nice for future changes to ImmutableList to made with 1 and 2 in mind.

Like I said from the beginning, I realize it's a pony request, so I understand it would require a different approach to ImmutableList.
 Nope, and that's why we've created ForgetfulArrayIterator. I just thought you might want to know of a time I used a collection and it wasn't the best thing ever.

What collection class should I use for reading through things once?
 Does Queue do that? It looks like Queue.iterator() doesn't remove elements from the queue, just lets you peek at them.

It sounds like you think mine isn't a popular use case (i.e., a Collection that lets you stream over immutable data once, letting what you have already seen be garbage). I wanted to offer the feedback that the implementation was doing something the interface didn't seem to require, leading to surprise on my part.
  .toString() method returns  "InternetDomainName{name=**domainORtldORwhatever**}" Should not simply return the **domainORtldORwhatever**?

Example code:

InternetDomainName owner = InternetDomainName.from("www.elmundo.es").topPrivateDomain();
System.out.println(owner.toString());

Print:

InternetDomainName{name=elmundo.es}

What I expect is:

elmundo.es

Is it an error? is it an expected behavior?

I'm using: 

<dependency>
    <groupId>com.google.guava</groupId>
    <artifactId>guava</artifactId>
    <version>18.0</version>
</dependency>

Thanks!
 Yeah, deleted my comment when I realized Storm 0.9.2 was overriding with Guava 13. Pardon me.
 I have the same problem , storm is overriding guava with a older version. Is there any solution to this problem? @chethan Is this Apache Storm, or another Storm? :)  This is not really a feature request, nor a bug report, but more of a request for comments.

I'm sure that everyone is well aware that using Guava on Android is challenging due to the size of the library. Resolving this problem by splitting up Guava into components is a massive endeavor, and something that the team may not be willing to do.

Given this, can we get clarification on the status of making Guava easier to use on Android? Is it considered a non-issue due to Proguard? Is it something being considered for future releases? If so, which release?

Thank you.
 Any progress on this? I want to split classes in com.google.common.collect into categorized modules.
 @ypresto, I don't think they have plans to split into modules. (Though there has been a tons of request about it). Have you tried jarjar? I did jarjar to break up a smaller jar with stuff I needed. 
 I didn't know about jarjar, it looks great..!
This plugin seems to be good for use with android gradle project. https://github.com/vRallev/jarjar-gradle
Thanks for letting me know!
 jarjar will be integrated in new Jack and Jill tool chain. More info at: http://tools.android.com/tech-docs/jackandjill
it is still experimental but would be worth a look as well. 
 It will be great to split guava.jar on some atomic jars (something like this: https://github.com/jjzazuet/seeds-libraries)
 For list processing, `Optional` and `Objects` Lightweight-Stream-API is good alternative.
It is tiny and has similar API to Java 8.
https://github.com/aNNiMON/Lightweight-Stream-API
 I started [miniguava](https://github.com/ypresto/miniguava) project for smaller library size..!
 @ypresto maybe you could take a look at: AbacusUtil: http://www.landawn.com  Hello,
If someone is new to guava, it'd be helpful to have more information in README.md. I tried to add some more information in README.md. Source I took information from: https://code.google.com/p/guava-libraries/
  NullPointerTester already knows the concept of a ExceptionTypePolicy.
However, the field "policy" is always set to a default value.

This patch adds an option to overwrite the policy to
allow IllegalArgumentExceptions. It also adds some unit tests.
 Hmm, Travis breaks because of an unrelated error:

testLargeNumberOfInsertions(com.google.common.hash.BloomFilterTest): Java heap space
 Apparently _even more_ heap space is necessary. See this commit from yesterday: fa24bad4e4ca19c18294062da539cdc78837efa2.
 @lowasser Maybe it is called "acceptIllegalArgumentException"? That is mentioned in the commit message where the ExceptionTypePolicy was extracted (2be342881ace329a9ebdc31990f719301de5f7c0).

I found the option to accept IllegalArgumentExceptions very useful, especially for existing code. If you can make it non-internally available, it would be great.

By the way, are there any plans to move the NullPointerTester from the internal guava-testlib to the exported part of Guava? From my experience, it is useful for any code base and not limited to Guava itself. Not long ago, I introduced a slightly modified version of it at my company (including this IllegalArgument fix and the  Nullable annotation had to be changed). Today I was positively surprised that it is now being used all over our code base.
 @cgdecker Yes, that makes sense. To be able to depend on guava-testlib is fine, too.
 👍 We are using `checkArgument(!Strings.isNullOrEmpty(xyz))` a lot, which is why this addition would be really great. I know it's called NullPointerTester and not PreconditionsTester or something, but if you have it internally, could you 'publish' it? :) Solid point. I agree kevinb9n. I guess this should be closed then?  Given that the main purpose of DeadEvent is logging/debugging, I think that this simple string representation could be useful.
  When decoding Base64/32/16 data an exception is thrown if an invalid character is found:

BaseEncoding.java:501:

``` java
    int decode(char ch) throws IOException {
      if (ch > Ascii.MAX || decodabet[ch] == -1) {
        throw new DecodingException("Unrecognized character: " + ch);
      }
      return decodabet[ch];
    }
```

The exception message prints out the character itself, which isn't terribly helpful when that is a non-printable character.  Recommend that the hex value of the character be printed instead.
  Interesting topic. I've seen issues with `String.format` and the default locale several times in production code, most recently today. I think it's a problem worthy of Guava's help.

As you mentioned, this issue is seemingly on few people's radar. Raising awareness would be a good thing to do.
 I would like this. Not as `Strings.format`, though. Although different, when skimming over code this can easily get unnoticed.
  I couldn't find how a `natural()` [`Ordering`](http://docs.guava-libraries.googlecode.com/git-history/release/javadoc/com/google/common/collect/Ordering.html) orders `null`s if not calling if `nullsFirst()`/`nullsLast()` is not called. https://code.google.com/p/guava-libraries/wiki/OrderingExplained didn't give me anything either.

Will the ordering thrown an NPE, or will it default to `nullsFirst()`? Should probably be documented.

Let me know if I've missed something.
 Ah! Thank you for pointing out my blindness... ;)
    Please see https://github.com/google/guava/blob/master/guava/src/com/google/common/primitives/Booleans.java#L235.

Isn't Java 6 available?
If it is, should that comment be removed?
Should the method be removed? (It is private and only used in a single place).
 Thank you for your answer.
Can something like this be merged?
https://github.com/mafagafogigante/guava/commit/ef1eb44e37a10e30266f5f026405b56c890d8f07
 Glad I could help.
 Maybe [this](https://github.com/google/guava/blob/master/guava/src/com/google/common/base/Strings.java#L76) is also of interest.
  Using Java8, guava18 and guava-gwt18 I get the following compile error: 

```
   Tracing compile failure path for type 'com.google.common.collect.Maps'
      [ERROR] Errors in 'jar:file:/Users/mg/Documents/Grails/GGTS3.6.3/buddyis-mobile/lib/guava-gwt-18.0.jar!/com/google/common/collect/super/com/google/common/collect/Maps.java'
         [ERROR] Line 592: Type mismatch: cannot convert from Comparator<? super capture#175-of ? super K> to Comparator<? super K>
```
  After trying: `mvn clean install`  on the Guava repo I get the following errors:

```
Jan 10, 2015 1:24:49 AM com.google.common.util.concurrent.ServiceManager <init>
WARNUNG: ServiceManager configured with no services.  Is your application configured properly?
com.google.common.util.concurrent.ServiceManager$EmptyServiceManagerWarning
    at com.google.common.util.concurrent.ServiceManager.<init>(ServiceManager.java:194)
    at com.google.common.util.concurrent.ServiceManagerTest.testEmptyServiceManager(ServiceManagerTest.java:346)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
    at java.lang.reflect.Method.invoke(Method.java:606)
    at junit.framework.TestCase.runTest(TestCase.java:168)
    at junit.framework.TestCase.runBare(TestCase.java:134)
    at junit.framework.TestResult$1.protect(TestResult.java:110)
    at junit.framework.TestResult.runProtected(TestResult.java:128)
    at junit.framework.TestResult.run(TestResult.java:113)
    at junit.framework.TestCase.run(TestCase.java:124)
    at junit.framework.TestSuite.runTest(TestSuite.java:243)
    at junit.framework.TestSuite.run(TestSuite.java:238)
    at org.junit.internal.runners.JUnit38ClassRunner.run(JUnit38ClassRunner.java:83)
    at org.apache.maven.surefire.junit4.JUnit4TestSet.execute(JUnit4TestSet.java:35)
    at org.apache.maven.surefire.junit4.JUnit4Provider.executeTestSet(JUnit4Provider.java:115)
    at org.apache.maven.surefire.junit4.JUnit4Provider.invoke(JUnit4Provider.java:97)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
    at java.lang.reflect.Method.invoke(Method.java:606)
    at org.apache.maven.surefire.booter.ProviderFactory$ClassLoaderProxy.invoke(ProviderFactory.java:103)
    at com.sun.proxy.$Proxy0.invoke(Unknown Source)
    at org.apache.maven.surefire.booter.SurefireStarter.invokeProvider(SurefireStarter.java:150)
    at org.apache.maven.surefire.booter.SurefireStarter.runSuitesInProcess(SurefireStarter.java:91)
    at org.apache.maven.surefire.booter.ForkedBooter.main(ForkedBooter.java:69)

Jan 10, 2015 1:24:49 AM com.google.common.util.concurrent.ServiceManager$ServiceListener failed
SCHWERWIEGEND: Service  [FAILED] ha

Running com.google.common.util.concurrent.UncaughtExceptionHandlersTest
Jan 10, 2015 1:24:53 AM com.google.common.util.concurrent.UncaughtExceptionHandlers$Exiter uncaughtException
SCHWERWIEGEND: Caught an exception in Thread[Thread-779,5,main].  Shutting down.
java.lang.Exception
    at com.google.common.util.concurrent.UncaughtExceptionHandlersTest.testExiter(UncaughtExceptionHandlersTest.java:42)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.009 sec
    at java.lang.reflect.Method.invoke(Method.java:606)
    at junit.framework.TestCase.runTest(TestCase.java:168)
    at junit.framework.TestCase.runBare(TestCase.java:134)
    at junit.framework.TestResult$1.protect(TestResult.java:110)
    at junit.framework.TestResult.runProtected(TestResult.java:128)
    at junit.framework.TestResult.run(TestResult.java:113)
    at junit.framework.TestCase.run(TestCase.java:124)
    at junit.framework.TestSuite.runTest(TestSuite.java:243)
    at junit.framework.TestSuite.run(TestSuite.java:238)
    at org.junit.internal.runners.JUnit38ClassRunner.run(JUnit38ClassRunner.java:83)
    at org.apache.maven.surefire.junit4.JUnit4TestSet.execute(JUnit4TestSet.java:35)
    at org.apache.maven.surefire.junit4.JUnit4Provider.executeTestSet(JUnit4Provider.java:115)
    at org.apache.maven.surefire.junit4.JUnit4Provider.invoke(JUnit4Provider.java:97)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
    at java.lang.reflect.Method.invoke(Method.java:606)
    at org.apache.maven.surefire.booter.ProviderFactory$ClassLoaderProxy.invoke(ProviderFactory.java:103)
    at com.sun.proxy.$Proxy0.invoke(Unknown Source)
    at org.apache.maven.surefire.booter.SurefireStarter.invokeProvider(SurefireStarter.java:150)
    at org.apache.maven.surefire.booter.SurefireStarter.runSuitesInProcess(SurefireStarter.java:91)
    at org.apache.maven.surefire.booter.ForkedBooter.main(ForkedBooter.java:69)

Running com.google.common.util.concurrent.UninterruptibleMonitorTest
Tests run: 16, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.378 sec
Running com.google.common.util.concurrent.WrappingExecutorServiceTest
...
Tests run: 597008, Failures: 16, Errors: 0, Skipped: 0

[INFO] ------------------------------------------------------------------------
[INFO] Reactor Summary:
[INFO] 
[INFO] Guava Maven Parent ................................ SUCCESS [0.256s]
[INFO] Guava: Google Core Libraries for Java ............. SUCCESS [16.834s]
[INFO] Guava Testing Library ............................. SUCCESS [25.873s]
[INFO] Guava Unit Tests .................................. FAILURE [5:36.508s]
[INFO] Guava GWT compatible libs ......................... SKIPPED
[INFO] ------------------------------------------------------------------------
[INFO] BUILD FAILURE
[INFO] ------------------------------------------------------------------------
[INFO] Total time: 6:20.103s
[INFO] Finished at: Sat Jan 10 01:24:53 CET 2015
[INFO] Final Memory: 47M/549M
[INFO] ------------------------------------------------------------------------
[ERROR] Failed to execute goal org.apache.maven.plugins:maven-surefire-plugin:2.7.2:test (default-test) on project guava-tests: There are test failures.
[ERROR] 
[ERROR] Please refer to /Users/mg/Downloads/GWT/guava/guava-tests/target/surefire-reports for the individual test results.
[ERROR] -> [Help 1]
[ERROR] 
[ERROR] To see the full stack trace of the errors, re-run Maven with the -e switch.
[ERROR] Re-run Maven using the -X switch to enable full debug logging.
[ERROR] 
[ERROR] For more information about the errors and possible solutions, please read the following articles:
[ERROR] [Help 1] http://cwiki.apache.org/confluence/display/MAVEN/MojoFailureException
[ERROR] 
[ERROR] After correcting the problems, you can resume the build with the command
[ERROR]   mvn <goals> -rf :guava-tests

```
 Here it is: 

```
Running com.google.common.base.StopwatchTest
Tests run: 20, Failures: 1, Errors: 0, Skipped: 0, Time elapsed: 0.011 sec <<< FAILURE!
```

Note that I compile with Java8.
 ```
Failed tests: 
  testToString(com.google.common.base.StopwatchTest): null expected:<0[.]000 ns> but was:<0[,]000 ns>
  testSimple(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.20, R0.]20]> but was:<[R0[,00, R0,20, R0,]20]>
  testSimpleWithWait(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, U0.20, R0.00, R0.]20]> but was:<[R0[,00, U0,20, R0,00, R0,]20]>
  testSimpleAcquireReturnValues(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, U0.20, R0.00, R0.]20]> but was:<[R0[,00, U0,20, R0,00, R0,]20]>
  testOneSecondBurst(com.google.common.util.concurrent.RateLimiterTest): null expected:<[U1[.00, U1.00, R0.00, R0.00, R0.00, R0.00, R0.]20]> but was:<[U1[,00, U1,00, R0,00, R0,00, R0,00, R0,00, R0,]20]>
  testWarmUp(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U0.50, U4.00, R0.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U0.50, U2.00, R0.00, R0.50, R0.50, R0.50, R0.50, R0.50, R0.50, R0.]50]> but was:<[R0[,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U0,50, U4,00, R0,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U0,50, U2,00, R0,00, R0,50, R0,50, R0,50, R0,50, R0,50, R0,50, R0,]50]>
  testWarmUpWithColdFactor(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.75, R1.26, R0.76, R0.30, R0.20, R0.20, R0.20, U0.20, U4.00, R0.00, R1.75, R1.26, R0.76, R0.30, R0.20, R0.20, R0.20, U0.20, U1.00, R0.00, R0.20, R0.20, R0.20, R0.20, R0.20, R0.20, R0.]20]> but was:<[R0[,00, R1,75, R1,26, R0,76, R0,30, R0,20, R0,20, R0,20, U0,20, U4,00, R0,00, R1,75, R1,26, R0,76, R0,30, R0,20, R0,20, R0,20, U0,20, U1,00, R0,00, R0,20, R0,20, R0,20, R0,20, R0,20, R0,20, R0,]20]>
  testWarmUpWithColdFactor1(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.20, R0.20, R0.20, R0.20, R0.20, R0.20, R0.20, U0.34, R0.00, R0.20, R0.20, R0.20, R0.20, R0.20, R0.20, R0.]20]> but was:<[R0[,00, R0,20, R0,20, R0,20, R0,20, R0,20, R0,20, R0,20, U0,34, R0,00, R0,20, R0,20, R0,20, R0,20, R0,20, R0,20, R0,]20]>
  testWarmUpAndUpdate(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U4.50, R0.00, R1.38, R1.13, R0.88, R0.34, R0.28, R0.25, R0.25, U4.25, R0.00, R0.72, R0.66, R0.59, R0.53, R0.47, R0.41, R0.34, R0.28, R0.25, R0.]25]> but was:<[R0[,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U4,50, R0,00, R1,38, R1,13, R0,88, R0,34, R0,28, R0,25, R0,25, U4,25, R0,00, R0,72, R0,66, R0,59, R0,53, R0,47, R0,41, R0,34, R0,28, R0,25, R0,]25]>
  testWarmUpAndUpdateWithColdFactor(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.75, R1.26, R0.76, R0.30, R0.20, R0.20, R0.20, U4.20, R0.00, R1.75, R1.26, R0.76, R0.20, R0.10, R0.10, R0.10, U4.10, R0.00, R0.94, R0.81, R0.69, R0.57, R0.44, R0.32, R0.20, R0.10, R0.10, R0.]10]> but was:<[R0[,00, R1,75, R1,26, R0,76, R0,30, R0,20, R0,20, R0,20, U4,20, R0,00, R1,75, R1,26, R0,76, R0,20, R0,10, R0,10, R0,10, U4,10, R0,00, R0,94, R0,81, R0,69, R0,57, R0,44, R0,32, R0,20, R0,10, R0,10, R0,]10]>
  testBurstyAndUpdate(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R0.50, R1.00, R2.]00]> but was:<[R0[,00, R1,00, R1,00, R0,50, R1,00, R2,]00]>
  testSimpleWeights(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R2.00, R4.00, R8.]00]> but was:<[R0[,00, R1,00, R1,00, R2,00, R4,00, R8,]00]>
  testInfinity_Bursty(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.00, R0.]00]> but was:<[R0[,00, R0,00, R0,]00]>
  testInfinity_BustyTimeElapsed(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.00, R0.00, R0.50, R0.]50]> but was:<[R0[,00, R0,00, R0,00, R0,50, R0,]50]>
  testInfinity_WarmUp(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.00, R0.]00]> but was:<[R0[,00, R0,00, R0,]00]>
  testInfinity_WarmUpTimeElapsed(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R1.00, R1.]00]> but was:<[R0[,00, R1,00, R1,00, R1,00, R1,]00]>

Tests run: 597008, Failures: 16, Errors: 0, Skipped: 0
```

Does this helps you?
  I used the following in my gwt.xml file: 

```
<inherits name="com.google.common.collect.Collect"/>
```

and I included both guava18 and guava-gwt18 on my classpath. the compiler error was: 

```
   Tracing compile failure path for type 'com.google.common.collect.Collections2'
      [ERROR] Errors in 'com/google/common/collect/Collections2.java'
         [ERROR] Line 201: The method and(Predicate<capture#14-of ? super E>, Predicate<capture#15-of ?>) is undefined for the type Collections2.FilteredCollection<E>
         [ERROR] Line 206: The method and(Predicate<capture#16-of ? super E>, Predicate<capture#17-of ?>) is undefined for the type Collections2.FilteredCollection<E>
   Tracing compile failure path for type 'com.google.common.collect.Maps'
      [ERROR] Errors in 'com/google/common/collect/super/com/google/common/collect/Maps.java'
         [ERROR] Line 2244: The method and(Predicate<capture#263-of ? super Map.Entry<K,V>>, Predicate<capture#264-of ? super Map.Entry<K,V>>) is undefined for the type Predicates
         [ERROR] Line 2343: The method and(Predicate<capture#265-of ? super Map.Entry<K,V>>, Predicate<capture#266-of ? super Map.Entry<K,V>>) is undefined for the type Predicates
   Tracing compile failure path for type 'com.google.common.collect.Multimaps'
      [ERROR] Errors in 'com/google/common/collect/super/com/google/common/collect/Multimaps.java'
         [ERROR] Line 1691: The method and(Predicate<capture#83-of ? super K>, Predicate<capture#84-of ? super K>) is undefined for the type Predicates
         [ERROR] Line 1954: The method and(Predicate<capture#105-of ? super Map.Entry<K,V>>, Predicate<capture#106-of ? super Map.Entry<K,V>>) is undefined for the type Predicates
         [ERROR] Line 1735: The method and(Predicate<capture#87-of ? super K>, Predicate<capture#88-of ? super K>) is undefined for the type Predicates
         [ERROR] Line 1779: The method and(Predicate<capture#91-of ? super K>, Predicate<capture#92-of ? super K>) is undefined for the type Predicates
         [ERROR] Line 1940: The method and(Predicate<capture#103-of ? super Map.Entry<K,V>>, Predicate<capture#104-of ? super Map.Entry<K,V>>) is undefined for the type Predicates
   [ERROR] Aborting compile due to errors in some input files
```
 I created a sample project. You will find it here: https://github.com/confile/GuavaGWT-Java8-Test
 I have no idea but you should keep the `-strict`.
 Here is a demo project for this issue to be reproduced: https://github.com/confile/gwtGuavaTest2

I am using the latest GWT2.7SNAPSHOT with JAva8 Update15 on OSX.
 Okay but still I cannot compile the current Guava-GWT project from source.
 Great thank you!
 Well now I can compile guava and guava-gwt from source but when using in a GWT project I still get the error. 
 Here is a demo project for eclipse which reproduces this error: 

https://github.com/confile/GWTQueryJava8Test
 Great
   Currently `FluentIterable<T>` has `#from(Itearble<T>)` 
Quite often I need to have an instance of it from some collection like `Collection<? extends T>` 
It could be nice to be able to pass such collection to `FluentIterable#from` 
 This is not clear why we cannot have
`public static <T> FluentIterable<T> from(Iterable<? extends T> foo)`
Similar constructions works for me in many cases
 Yes. Thanks. I figured out I could change my code to use `? extends'  in many places. This works but makes java code a bit ugly
   This is an easy to reproduce bug. Running the following code throws an exception. 

``` java
String ff = "us-east-1.amazonaws.com";
InternetDomainName domain = InternetDomainName.from(ff);
System.out.println(domain.topPrivateDomain());
```

> Exception in thread "main" java.lang.IllegalStateException: Not under a public suffix: us-east-1.amazonaws.com
>   at com.google.common.base.Preconditions.checkState(Preconditions.java:197)
>   at  com.google.common.net.InternetDomainName.topPrivateDomain(InternetDomainName.java:424)
>   at   *****.main(MyTestJavaClass.java:8> 9)
>     at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
>     at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
>     at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
>     at java.lang.reflect.Method.invoke(Method.java:606)
>     at com.intellij.rt.execution.application.AppMain.main(AppMain.java:134)
 You are so right. Sorry for not noticing that ... 
  At line 91 of LineBuffer, it should be better to call line.setLength(0) instead of creating another StringBuilder(). Maybe add a length limit too:

```
private static final int MAX_LINE_LEN = 0x1000; // 4K

/** Called when a line is complete. */
private boolean finishLine(boolean sawNewline) throws IOException {
    handleLine(line.toString(), sawReturn
        ? (sawNewline ? "\r\n" : "\r")
        : (sawNewline ? "\n" : ""));
    // line = new StringBuilder();
    if (line.length() > MAX_LINE_LEN) {
        line = new StringBuilder();
    } else {
        line.setLength(0);
    }
    sawReturn = false;
    return sawNewline;
}
```
 My concern was not only about the GC but the copies due to increasing capacity. I believe the initial      capacity for a new StringBuilder is almost always wrong given file lines. 16 characters is just too low, maybe not for configuration files but we are still using the default constructor. In addition to that, files tend to have equal or similar line lengths, reusing the builder is probably a better strategy to ensure right capacity.

I should report back with some tests. I believe this is a low priority micro optimization if at all, feel free to ignore unitl I come back with noteworthy results. 
  Presently, a constant function is provided in the `Functions` class with a type signature as follows

``` java
public static <E> Function<Object, E> constant(@Nullable E value) 
```

Personally, I think that a type signature as follows would be superior

``` java
public static <Q, E> Function<Q, E> constant(@Nullable E value) 
```

the reason being that while functions in the "mathematical" sense are co-variant with regard to their argument types, generics in java are not (for well-known reasons).

It's probably not trivial to introduce such a change without triggering a compilation error here or there. Still I think it might be worth considering.
 Here's my specific use case. I'd like to have an interface that returns a `Function<A, B>`. I'd like to have a dummy implementation of that, which always returns the same (constant) value. Naturally, I can build my own constant function easily (which I did), and yet it seems odd that I would need to do that.
 There are no doubt many plausible workarounds (as it were, I am quite content with mine). It is also a very minor issue. I simply felt it noteworthy that a workaround would seem to be required in the first place. Please do feel free to close it if it isn't worth your time. 

As "solutions" go though, my proposal would be to make `ConstantFunction` generic in the parameter type as follows:

``` java
  private static class ConstantFunction<D,E> implements Function<D, E>, Serializable {
    private final E value;

    public ConstantFunction(@Nullable E value) {
      this.value = value;
    }

    @Override
    public E apply(@Nullable D from) {
      return value;
    }

[snip]
```

and either change or provide an alternative to `constant(T val)`:

``` java
    public static <D, E> Function<D, E> constantD(E value) {
        return new ConstantFunction<>(value);
    }

    public static <E> Function<Object, E> constant(E value) {
        return new ConstantFunction<>(value);
    }
```

Though again, I do agree that this is generics cosmetics, and perhaps not worth the possible API change/extension.
 Thanks for your explanation and time.
  I find that I have a ton of `public static final Joiner` declarations for `,`, `.`, and `space`.  I even found one `COMMA_JOINER` in `Predicates` class.

I think, it warrants to add a few of those to a `Joiner` class:

``` java
public static final Joiner EMPTY_JOINER = on( "" );
public static final Joiner COMMA_JOINER = on( "," );
public static final Joiner DOT_JOINER = on( "." );
public static final Joiner SPACE_JOINER = on( " " );
public static final Joiner TAB_JOINER = on( "\t" );
public static final Joiner LF_JOINER = on( "\n" );
public static final Joiner CRLF_JOINER = on( "\r\n" );
```
  Should we throw an exception when -0.0 comes?
 As the only reason for forbidding negative tolerance is that it's an obvious error, I can't see how it applies to `-0.0`. OTOH I can't imagine any sane tolerance formula producing negative zero.

Still, forbidding it violates the common expectation that equal things behave the same.
  And return the future that is passed to the method.

This will remove the need for intermediary variable when submitting a list of tasks.

Here is the use case;

``` java
List< ListenableFuture< SomeGenericResult< Type1, Type2, Type3 > > futures = new ArrayList<>( );

for ( Callable<Boolean> task : tasks )
{
  futures.add(
    Futures.addCallback(
      executor.submit( task ),
      new FutureCallback<SomeGenericResult< Type1, Type2, Type3 >>(){...}
    )
  );
}

ListanableFuture< List< SomeGenericResult< Type1, Type2, Type3 > > > listFuture = Futures.succesfulAsList( futures );
```

Without the fix, there has to be a variable inside the loop, which adds to clutter:

``` java
List< ListenableFuture< SomeGenericResult< Type1, Type2, Type3 >> > futures = new ArrayList<>( );

for ( Callable<Boolean> task : tasks )
{
  ListenableFuture<SomeGenericResult< Type1, Type2, Type3 >> future = executor.submit( task );

  Futures.addCallback(
    future,
    new FutureCallback<SomeGenericResult< Type1, Type2, Type3 >>(){...}
  )

  futures.add( future );
}

ListanableFuture< List< SomeGenericResult< Type1, Type2, Type3 > > > listFuture = Futures.succesfulAsList( futures );
```
 `ListenableFuture` allows for delayed decision making.  This article explains it nicely -> https://code.google.com/p/guava-libraries/wiki/ListenableFutureExplained

Here is the main point of the article:

> The most important reason to use `ListenableFuture` is that it becomes possible to have complex chains of asynchronous operations.

Note, that you need `ListenableFuture`, not `Future` to derive this benefit.
 See my example.  During the **FAN OUT** part of my computation, I want to be able to add it to the list of `ListenableFutures` without having to declare an intermediary variable (I think this is a rather common occurence).  Because `ListenableFuture` is generic, and the computational result may be generic, this intermediate variable declaration may be rather cumbersome, and not providing any functional/semantic meaning.

Basically, I am only asking that `addCallback` method follows a common `Builder` pattern, where the object that is being built is returned, instead of `void`.
 Changed result type in the example from `Boolean` to mouthfull `SomeGenericResult< Type1, Type2, Type3 >`.
  `AsMapView` (as returned by `Maps.asMap`) is not `Serializable`. As I can see, there's no fundamental reason why it shouldn't be serializable, if the set and function are (a lot of the functions returned by the `Functions` methods are indeed serializable). This applies to the subclass `SortedAsMapView` and related class `NavigableAsMapView` as well
 The unmodifiable ones are Serializable, the modifiable ones are not, except for `TransformingSequentialList` and `TransformingRandomAccessList` (that I could find)...
  I came up own Map impl that will not stores multiple Values, if it equals, and avoid duplicating of data. (just store only one of them).
Description of map impl is available on  (http://stackoverflow.com/questions/27472712/compact-java-util-map-implementation)
The question is : how to use this map for caching results , or is it possible at all?
  **Background:** I have a use case where I need to implement/override `equals(...)` method for a class holding `Double` fields. Since `Double` rarely can be compared directly I'd like to make a fuzzy comparison between my class instances using some tolerance.

**Issue:** [`DoubleMath#fuzzyEquals(...)`](http://docs.guava-libraries.googlecode.com/git/javadoc/com/google/common/math/DoubleMath.html#fuzzyEquals%28double,%20double,%20double%29) would be a useful utilify method for doing my comparison. The issue is, it doesn't support nullable doubles.

**Proposal:** To remedy this I have put together a utility method that solves this for me:

``` java
public class Doubles {

    /**
     * Like {@link DoubleMath#fuzzyEquals(double, double, double)}, but supports nullables.
     * 
     * @param a
     *            first nullable element
     * @param b
     *            second nullable element
     * @param tolerance
     *            absolute difference tolerance. See {@link DoubleMath#fuzzyEquals(double, double, double)} for details.
     */
    public static boolean fuzzyEquals(Double a, Double b, double tolerance) {
        if (a==null && b==null)
            return true;
        else if (a != null && b != null)
            return DoubleMath.fuzzyEquals(a, b, tolerance);
        else /* (a != null ^ b != null) */
            return false;
    }

}
```

Would a similar method be useful to add to Guava? An alternative approach would be to relax `DoubleMath#fuzzyEquals(...)` method signature to accept `Double`s instead of `double`.

**Additional:** It could also be debatable if fuzzy comparison should be done in an `equals(...)` implementation. In my case, I think it's fair to say it is.
 Good call on the transitivity there... Anyhow, I have no strong feelings about this but feel free to discuss it. Sounds like it's not that much of a common issue at Google...
  In our project we want to create our own custom version from the EventBus. The EventBus supports this by overriding the method **void dispatch(Object, EventSubscriber)**.
We want to place our EventBus in our own package but the EventSubscriber is package protected. So we can not place our EventBus in it's own package without copying a lot of classes from guava.
Is it possible to make EventSubscriber public or use a public interface?
 @cgdecker, are you saying that `EventBus` should not be extended by users at all? It would be good to document that.

(This would be unfortunate, though. We have an internal `SequentialEventBus extends EventBus` implementation that ensures that all listeners have received an event _E_<sub>i</sub> before any listener receives the subsequent event _E_<sub>i + 1</sub>. It's used in an application in which relatively few events are fired and where some subscribers post events themselves. `SequentialEventBus` gives a receiver _R_ of event _A_ the guarantee that all other interested subscribers have seen _A_ before _R_ posts a follow-up event _B_. This guaranteed ordering of events simplifies reasoning about the system.)
  https://code.google.com/p/guava-libraries/source/browse/README states

> 1. Deprecated non-beta APIs will be removed two years after the
>    release in which they are first deprecated.

while https://code.google.com/p/guava-libraries/wiki/PhilosophyExplained#Non-Beta_APIs states

> Deprecated non-beta APIs will be removed eighteen months after the release in which they are first deprecated.

Is it 18 or 24 months?
 Will do! :+1: for quick fix!
  Ordering throws a IncomparableValueException if there is a mismatch between the ordering and the list to be ordered. This exception is package-local, which results in one not being able to catch it, instead one has to catch ClassCastException, which leads to messy code. 

Since the exception is thrown out of Guava, it should be public so that one can catch it.
 The case in question is as follows:

I have a web-GUI where one of the things the user can do is create a list of entites, and view these as a HTML table. It also has the possibility to delete specific rows, as well as drag-and-drop functionality in order to rearrange the ordering of the list. Upon rearranging the rows, the id's of the enitites are posted in an ordered list. On the server side I want to load the list as it sits in the database, and then order them according to the list of id's, and then save it to the database. For this I use Guava's Ordering.

But, since multiple users can manipulate the same list at the same time, one user could delete a row  while the other one is rearranging, which leads to a mismatch between the supplied id's, and the stored state from the database. In these cases, I would like to present the user with an informative error message stating that one should refresh the page, in order to get the GUI in sync with the database.

To achieve this I need to catch the exception that indicates a mismatch between the two lists sent to the ordering, and the exception being thrown when this happens is IncomparableValueException. But, since this is not public, I can not catch it, and am left with catching ClassCastException (a much wider and more general exception) instead. The result would probably be the same if it was an actual ClassCastException (the user has to refresh), but imho it's good practice to catch as narrow exceptions as possible.
  Given that `Range` is serializable, shouldn't its type parameter `C` be bound to `Serializable` too?

``` java
Range<C extends Comparable & Serializable>
```
 I understand, thanks for the explanation.
  I have several use cases that involve transforming the values held by Ranges and RangeSets.  In particular, I often have a `Range<LocalDate>` and need a `Range<Integer>` (where the latter represents a range of years) or the inverse.  While it's possible to manually extract the endpoints and construct a new Range, ideally there would be some cleaner standard way to do this.

I currently have several Function generator methods that I use which works reasonably well.  Hopefully this example will help trigger discussion, I'm happy to contribute the backing code if this pattern in fact seems desirable.

```
/**
 * Returns a function which transforms the endpoints of a range using the passed function.
 * Take note that losses of precision can change ranges, e.g. [1.2..1.9) => [1..1)
 * becomes an empty range.
 */
public static <S extends Comparable<? super S>, E extends Comparable<? super E>>
    Function<Range<S>, Range<E>> rangeTransformer(Function<S,E> f)

/**
 * Returns a function which canonicalizes a range, then transforms the endpoints using
 * the passed function.  Useful for broadening ranges, e.g. [1..2] => [1..3) => [1.0..3.0),
 * which is difficult to define in non-canonical form.
 */
public static <S extends Comparable<? super S>, E extends Comparable<? super E>>
    Function<Range<S>, Range<E>>
    canonicalizedRangeTransformer(Function<S,E> f, DiscreteDomain<S> domain) 

/**
 * Transforms a RangeSet to use a different type of Range.  Intended to be used in
 * conjunction with the rangeTransformer() methods.
 */
public static <S extends Comparable<? super E>, E extends Comparable<? super E>>
    Function<RangeSet<S>, RangeSet<E>> rangeSetTransformer(Function<Range<S>,Range<E>> f)
```

This can then be used to (reasonably) concisely define a transformation on Ranges and RangeSets, without needing to worry about as much boiler-plate.

```
public static final Function<Range<Integer>, Range<LocalDate>> YEAR_RANGE_TO_LD_RANGE = 
  canonicalizedRangeTransformer(new Function<Integer, LocalDate>() {
    @Override
    public LocalDate apply(Integer year) {
      // By canonicalizing first, we can safely always return Jan 1st
      // The range [2000..2002] becomes [2000-1-1..2003-1-1) which is equivalent.
      return new LocalDate(year, 1, 1);
    }},
    DiscreteDomain.integers());

public static final Function<RangeSet<Integer>, RangeSet<LocalDate>> YEAR_RANGESET_TO_LD_RANGESET =
  rangeSetTransformer(YEAR_RANGE_TO_LD_RANGE);
```
 > The direction that we were moving on that thread was requiring a separate transformation function for each endpoint.

I explored the same thought when I first needed these transformations, and really wanted to avoid needing to define my own `RangeTransformer` or similar class.

As I see it, there are three categories of transformations one might want to do:
1. Lossless Transformations: where two types map one-to-one, such as `String` <=> `CharSequence`.  There's little to say here, it really makes sense to make these sorts of transformations easier.
2. Expanding Transformations: where the original type maps one-to-many destination types (e.g. `Integer` => `Double` or `Integer`(year) => `LocalDate`).  This is a little odd, because there needs to be some sort of canonical destination value defined, such as the first day of the year.  I see two options, either explicitly canonicalize the Range like I do above (and so `[2000..2002]` becomes `[2000-1-1..2003-1-1)`, or implement #1551 so that the range bounds can be restored internally (`[2000-1-1..2002-12-31]`).  I could be mistaken, but I believe canonical Ranges can always be safely expanded to a more precise type without requiring separate handling for each endpoint.
3. Lossy Transformations: where the original type maps many-to-one destination type (e.g. `Double` => `Integer` or `LocalDate` => `Integer`(year)).  This is the tricky one, since it's not totally clear what something like `[2.5..3.5]` should become.  The consistent option would be to treat it just like a lossy cast, so `[2..3]`, but that "feels" wrong to me.  Alternatively we could fail-fast in such a case and only allow Ranges that can be safely cast both ways.  This might be a little more painful to use, but it also might be less error-prone.  Currently, I've implemented the lossy cast for `LocalDate` => `Integer`(year), but that's clearly not ideal (e.g. `[2000-12-31..2001-1-1]` becomes `[2000..2001]`, going from two days to two years).

Perhaps it would be sufficient to always canonicalize the original range, and just document that lossy transformations risk losing data?  
 I think Lossless Transformations should be implemented first, since they don't require separate logic for upper/lower bounds, the implementation logic should be fairly simple, and they would greatly simplify what is otherwise a very painful operation for the user.

Currently, the simplest way to implement it externally that I have found is to check whether the lower/upper bounds exist, extract the lower/upper endpoints & BoundTypes for the bounds which do exist, "cast" the endpoints, and then call either Range.range, Range.upTo, Range.downTo, or Range.all depending on which bounds exist, and pass the "casted" endpoints and extracted BoundTypes back in.

Which is ridiculous when all you're trying to do is call .getBytes(UTF8) on the endpoints that exist, to convert from a Range<String> that is easy for the user to specify, to a Range<byte[]> that is not, but which is the only Range type the underlying system will accept.  Currently, any Range can be canonicalized to `[closed, open)`, however there is no easy way to transform a Range into other bounds (notably `[closed, closed]`).  At a minimum, I would suggest providing a `closed()` method that attempts to return a fully closed Range, the same way `canonical()` does.  I can attest I have used this behavior heavily.

Even better, I would think, would be a generic way to rebound a Range however the user needs.  I'm less certain about the use cases for other bounds, but the code to properly rebound is tricky, and in particular would be easier and cleaner if it had access to the Bounds inside Range.
  I have a need to select the most recent `n` elements from a list that I know is ordered; for instance, to display data from the last ten years, in a (potentially long) list of data ordered by year.

For existing Lists it's tedious but not complicated to write out:

```
list.subList(Math.max(list.size() - n, 0), list.size())
```

though I'd argue the cleanliness of a simple `.tail()` method is still a nice win over the above.  More valuable however is providing support for arbitrary Iterables, in order to avoid creating a copy of the whole data stream simply to take a small sublist.  I imagine many users (myself included) simply absorb the cost of the full copy rather than take the time to implement a circular buffer or similar memory-efficient solution.
 I understand that this issue is about a new method for getting the tailing/last/trailing N elements, but if anyone hits this page while searching for a method to find THE last element, as I just have, then FYI  com.google.common.collect.Iterables's T getLast(Iterable<T> iterable) is what you are looking for (it's optimized for List).
 Just to mention that a302923027 makes `EvictingQueue` a little more efficient for this use-case, but it's still not as discoverable or intuitive as a method on `Iterables` would be.
  Along the lines #418: ability to start()/stop() a service a few times seems very common

Not being able to restart the service somewhat defeats the point and forces to reimplement a lot of the same boilerplate (as mentioned in #418 ensuring only one running)

Maybe AbstractService needs to be modified or new recipe added (RestartableService) since this is a recurring usage
 The functionality part is the same as in #418 (by mathias.bogaert and piotr.findeisen)

Difference would be an option to add RestartableService (vs modifying AbstractService) to guava because it is a recurring usage pattern

I found several Service(s) in our code base, but none could use AbstractService
 ability to start()/stop() a service a few times seems very common

Not being able to restart the service somewhat defeats the point and forces to reimplement a lot of the same boilerplate (as mentioned in #418 ensuring only one running)

Maybe AbstractService needs to be modified or new recipe added (RestartableService) since this is a recurring usage

(migrated from #1904)
 @cpovirk I am not collaborator so (based on [1]) i cannot reopen issues -- please reopen #418 for us

[1] http://stackoverflow.com/questions/21333654/how-to-re-open-an-issue-in-github 
  In a couple of places, in using the `com.google.common.reflect` library, I've found that it would be helpful to have a method like `public abstract java.lang.reflect.Executable getExecutable()` on the `Invokable` class. Currently I have to maintain my own internal mapping from `Invokable -> Executable` in certain situations, which is not ideal. It can be difficult to interact with other existing APIs, too.

The only issue I can see with this is that it could break compatibility with users' code if they've subclassed Invokable for some reason. If this is important, a way round it would be to just have a non-abstract `getMember()` method on `Invokable` (or `Element`) which by default just returns `this`, and which can be overridden by `MethodInvokable` and `ConstructorInvokable` as appropriate. Having to cast at the use site would be better than nothing.

Thanks,

Eli
 Ah of course, thanks, that makes sense! Interesting reading on issue #1738.

How about just the `getMember` method on `Element`, then, so we can cast to figure out if it's a `Method` or a `Constructor`? This would be backwards compatible with earlier Java versions, and if the time comes when it becomes appropriate, the method could be overridden in `Invokable` to return an `Executable` for better Java 8 support.

...Though it would be understandable if you would not be willing to commit to _any_ new changes, backwards compatibility preserving or not, until you had a full forward plan.
 Yeah sure, though I'm sure it's pretty boring :). I don't think it's because any functionality is missing, anyway. I can also do what I need to do without this, it's just slightly more of a faff in places.

The first place I'd use `getMember` is in an implementation of some methods to find overload candidates for a given method name and parameter and return types, then find the most specific. It's not a big deal here, just would make the internals a little neater since we have to map our result back to an Executable to match the public API.

The second is in the API for the inference implementation I mentioned I'm doing in another issue. I have, e.g.:

```
public Type[] inferTypes(Executable executable, Type result, Type... parameters)
```

and:

```
public <R> List<TypeToken<?>> inferTypes(Invokable<? super T, ? super R> invokable, TypeToken<R> result, TypeToken<?>... parameters)
```

and I would just like to be able to implement the latter by forwarding to the former.
 Yeah I did think the Member.getMember() thing might make it a bit weird...
Well fair enough, no biggie.

In the second case, yeah, it's either a case of flipping it and doing some
very ugly casts, or delegating both to a third method. Hardly the end of
the world haha...

Since you mention `Invokable.from(Executable)`, though, that would actually
be a nice alternative to the current minor boilerplate of figuring out
which to call between `Invokable.from(Method)` and
`Invokable.from(Constructor)` ;).

Cheers

On 3 December 2014 at 17:41, Ben Yu notifications@github.com wrote:

> Was about to do it then realized an awkward API design issue.
> 
> Invokable today implements Member. So it seems weird for it to also expose
> getMember(). getExecutable() would be less weird. But...
> 
> —
> Reply to this email directly or view it on GitHub
> https://github.com/google/guava/issues/1902#issuecomment-65453224.
  Would be useful for usecases like:

`someOptional = firstSuplier().or(secondSupplier).or(thirdSupplier)`

Right now it should be written as

```
if (!someOptional.isPresent()) {
  someOptional = secondSupplier();
}

if (!someOptional.isPresent()) {
  someOptional = thirdSupplier();
}
```
 Java 8's Optional has `orElseGet(Supplier<? extends T> other)` which doesn't return Optional.
  Hello @cgdecker , I did fixed this issue but with a little duplicate codes :) , because I tried to avoid adding new methods .

and because I am new in github , I don't know if I should create new pull request or referenced this issue from the commit is enough .  

Thank you :) 
 A workaround fro this particular issue is to use withKeyValueSeparator(Splitter.on("=").limit(2)).  When using reflect.ClassPath.from(ClassLoader classLoader), if the classloader involved has loaded classes from a local file containing spaces, a URISyntaxException will be thrown from ClassPath.java line 294.

This bug is caused by the line above it: `uri = entry.toURI();` which apparently doesn't work as expected when the URL in question contains spaces.
 There are two code paths that reach into the scan(URI,ClassLoader) function.  One of them can be easily replaced with a URL based solution but the other one which flows from: `for (URI uri : getClassPathFromManifest(file, jarFile.getManifest())) {` seems more difficult.  

I created a [fix](https://github.com/OverclockedTim/guava/commit/8cf877043172a2e2840d9daad54b3fbd4779d5fb) that makes this work in my environment (appengine devserver on Windows).  I can verify that it works in my live tests but it fails some JUnit tests that currently exist.  I am not certain that those tests are valid, but since it does fail I won't submit this as a pull request.  

Unfortunately I've spent a day on this and it is now working for my company so I probably can't spend any more time on it, but hopefully the commit listed above is helpful!
  I think there is some questionable logic in the way assignability is calculated in `TypeToken`. I'm assuming the method `isAssignableFrom` is intended to have the same semantics as `Class.isAssignableFrom`, i.e. check whether an assignment would be a widening conversion. Currently, we have the following behaviour, as an example:

```
TypeToken<? super Comparable<String>> superComparable; // ...
superComparable.isAssignableFrom(TypeToken.of(String.class)); // returns false!
```

But if we have a reference of any type which satisfies `? super Comparable<String>` it should be assignable from a reference of type `String` quite happily, and therefore represent a widening conversion, should it not?

Looking into it I think the 'problem' - if it is a problem and not just my misunderstanding of the intent of the method - is expressed by this comment, from line 793:

```
// if "to" is <? extends Foo>, "from" can be:
// Foo, SubFoo, <? extends Foo>, <? extends SubFoo>, <T extends Foo> or
// <T extends SubFoo>.
// if "to" is <? super Foo>, "from" can be:
// Foo, SuperFoo, <? super Foo> or <? super SuperFoo>.
```

Whereas the way I see it, it should be:

```
// if "to" is <? super Foo>, "from" can be:
// Foo, SubFoo, <? extends Foo>, <? extends SubFoo>, <T extends Foo> or
// <T extends SubFoo>.
// else if "to" is <? extends Foo>, with no lower bounds, the assignment will always fail.
```

Though this description is insufficient if the wildcard has both lower _and_ upper bounds (other than Object), but you see what I mean. I guess my implementation would just be:

```
return isAssignable(from, supertypeBound(to)) && isAssignable(from, subtypeBound(to));
```

Am I making sense here?
 In the case you are talking about, where the `TypeToken<? extends Comparable<String>>` is actually a `TypeToken<MyComparable<String>>`, the part of the code I'm talking about doesn't get reached anyway so it doesn't matter. Specifically I'm talking about the case where the `runtimeType` member is an instance of `WildcardType`, in which case the following is called:

```
private static boolean isAssignable(Type from, Type to) {
    if (to.equals(from)) {
        return true;
    }
    if (to instanceof WildcardType) {
        return isAssignableToWildcardType(from, (WildcardType) to);
    }
    // ...
}
```

eventually propagating down to the bit of code/comment I referenced in the original issue comment.

If this is not supported, it would be better to throw an exception than to get it wrong imo... but unless other code relies on the current behaviour it is an easy fix.

The place I'm finding this issue can be reduced to the following example, which is very much an analogue of a real world scenario so I do think a fix would be valuable:

```
// Token for a consumer:
TypeToken<Consumer<? super Comparable<String>>> literal = new TypeToken<Consumer<? super Comparable<String>>>() {};

// Reference for accept method of Consumer:
Invokable<Consumer<? super Comparable<String>>, ?> accept = literal.method(literal.getRawType().getMethod("accept", Object.class));

// Token for type of the method parameter (? super Comparable<String>):
TypeToken<?> boundedLiteral = accept.getParameters().get(0).getType();

// Can we assign a String to the method parameter type? This should return true!
boundedLiteral.isAssignableFrom(TypeToken.of(String.class));
```
 "If 'to' is a supertype of Foo, how does SubFoo match?"

It's not that it exactly 'matches' in the sense you're talking about, it's that it's _assignable_ to it. If 'to' is a supertype of Foo, then you should be able to assign a 'SubFoo' instance to a reference of that type.

```
Iterable<? super Comparable<String>> it;
Iterable<String> strings = null;
// Type mismatch: cannot convert from Iterable<String> to Iterable<? super Comparable<String>>
it = strings;
```

This is describing a slightly different sort of relationship ('is _exactly_ a' rather than 'is assignable to a'). As a simpler example to make that more obviously clear:

```
// returns true:
new TypeToken<Number>() {}.isAssignableFrom(new TypeToken<Integer>() {});

// because we can do this:
Number num;
Integer integer = null;
num = integer;

// but not this:
Iterable<Number> nums;
Iterable<Integer> ints = null;
nums = ints;
```
 "Wildcard types is a little special. You cannot have an expression like this:"

```
? super Foo foo = subFoo;
```

Sure, but you can have something like:

```
Consumer<? super Number> a = null;
a.accept(new Integer(0));
```

Which is effectively assigning an `Integer` to a reference of type `? super Number`.

I maintain that my interpretation of the rule makes more sense, and is more consistent with other behaviour, than the current implementation.

Another way to look at it is to define isAssignableFrom as: "every possible type matching 'from' is assignable to every possible type matching 'to'."

Or in the above case: "every possible type matching `? super Number` is assignable from every possible type matching `Integer`".

Or more trivially: "every possible type matching `Number` is assignable from every possible type matching `Integer`".

I'm struggling to think of how the current behaviour might be consistently defined in a similar way... There just seems to be no useful relationship between what happens when 'from' represents a WildcardType and what happens when it represents anything else.

I mean, imagine if you _could_ do:

```
? super Foo foo = subFoo;
```

or

```
Object foo = (? super Foo) subFoo;
```

You would expect that to work, right?
  TypeToken and Invokable currently have great support for reflective examination of generic types, but I think there are some blind spots when it comes to generic _methods_ which fall neatly within the scope of the library.

Consider the (fairly pointless looking) method:

```
<T> T getItem(Collection<T> c);
```

Querying the return type and getting a TypeToken over a java.lang.reflect.TypeVariable isn't that useful in most contexts. A client isn't likely to know what to do with type 'T' without doing some further manual investigation.

What would be nice is a rough analogue to the `<X> TypeToken<T> where(TypeParameter<X> typeParam,  TypeToken<X> typeArg)` method from the TypeToken API. Obviously the design would have to be a little different, since an Invokable can't be parametrised over the generic method type parameters so we can't magically capture them in a TypeParameter in the same way we do there.

But essentially it'd be nice if we could do something like this:

```
Invokable<?, ?> getItem = ...; // whatever
getItem = getItem.withTypeParameters(String.class); // varargs method expecting a class/TypeToken per generic method parameter
```

to get a reference to the parametrised method with the parametrized signature (if that is a concept which makes sense):

```
<String> String getItem(Collection<String> c)
```

Or maybe even just:

```
TypeToken<?> wildcard = ... // pass an unbounded WildcardType to `TypeToken.of` I guess
getItem = getItem.withTypeParameters(wildcard);
```

giving an invokable over the parametrized signature:

```
<?> ? getItem(Collection<?> c)
```

This way we could do a few more useful type checking tasks in serialisation libraries and the like out of the box.

Of course my ideal wish list feature would be:

```
getItem = getItem.inferTypeParametersFromArguments(new TypeToken<List<String>>() {});
```

to give an Invokable over:

```
<String> String getItem(Collection<String> c)
```

though I suppose this would require an implementation of the entire Java method type inference rules, which is far from trivial, and probably asking too much when this is a bit of a niche feature!

Cheers,

Eli
 Hi, thanks for the quick response.

I'm not _necessarily_ talking about type inference - this would be nice to take it a step further, but as you say, lots of complexity for a feature without that many use cases. Mainly I'm just talking about _explicit_ parametrisation with given types.

In other words, rather than automagically resolving the type variables in the type expressions [A, B, C] for some [x, y, z], simply check whether a given exact substitution for those type variables is valid wrt their bounds.

It's perhaps still non-trivial to verify the requested parametrisation is valid, but I had thought that it would be the same task as `where` already performs in TypeToken... Looking at it though, it seems you don't actually perform any checking on the validity of the parametrisation here, since you can just rely on getting it free from the compiler. (Which is very cleverly done, btw!)

Looks like, as you say, the only way to achieve this atm is to pull in a dependency on javac or JDT or something... and faff around with syntax trees and stuff most likely. Fun!
 Thank you, this makes sense and has given me a starting point. I will do as you describe and try to use the TypeResolver and isAssignableFrom to implement something along these lines. I will come back to reopen this issue, or to open another one, if I am successful in a way which might be useful for other people as a contribution.

Cheers,

Eli
 FWIW, for anyone still watching this, I've started implementing the type inference rules myself according to the spec for Java 8. It doesn't actually seem _that_ difficult now I've gotten a little way into it, just a fair bit of work.

I'm working using your reflection stuff without pulling in any other dependencies, and I've tried to design the API in a way which I think fits neatly with what you currently have. Assuming I do actually finish this and it's up to your standards, is there any chance you'd consider merging it in?
 Great, TypeParser and Types will come in handy for me, thanks. And I'll let you know when the type inferrer is done all the same, even if it will just live as a stand-alone project.
 Hi, if you're interested the type inferrer is pretty much done now. There were too many edge cases and new types involved with inference which weren't compatible with your library (infinite types, intersection types, type variables with upper and lower bounds, etc.), so I just reimplemented the features I needed and got rid of the dependency. It wasn't that much more work really, as the type inference algorithm effectively gives you a lot of it for free (though likely many times slower in some cases... it's not quick... thankfully this isn't an issue for me).

Anyway, the library lives here https://github.com/StrangeSkies/uk.co.strangeskies under the uk.co.strangeskies.reflection subproject. If you want to take a look, TypeLiteral and Invokable provide most of the useful functionality.
  As per I can see on the docs (https://code.google.com/p/guava-libraries/wiki/CommonObjectUtilitiesExplained), the documentation is still using _Objects_, when it should say _MoreObjects_ (Objects it's deprecated on the 1.8 version). How can I fix this minor issue?
Thanks!
 Cool. Thanks a lot! :+1: 
  I previously posted in 'guava-discuss' offering to contribute some code I wrote for sorted iteration streams:

   https://groups.google.com/forum/#!topic/guava-discuss/lxMBNCMp-Zo

In keeping with Guava's 'CONTRIBUTING.md' document, I didn't provide any code to look at when I posted to 'guava-discuss', but because I didn't get any response either, I'm going to try dangling some code. =)  Here's what my code looks like, committed in a fork of the Guava project:

   https://github.com/kenahoo-windlogics/guava/commit/5a9d85fe255a65339e5c0c232a5826e2e8bfc9bb

The short rationale from the previous post follows:

> In some work at my company, I've developed a few small classes that deal with "Sorted Set" streams in Java - the idea is that these are iterators (potentially very large or infinite) of Comparable items in strictly increasing order.  They may represent search results (in our case, streaming from a Mongo DB back end), arrival times of events, or similar.
> 
> With such streams, it is possible to define composition operations Intersection and Union, while keeping the lazy iteration semantics of Iterators, and also playing nicely with transformations like Guava's Iterators.filter() and Iterators.transform().
> 
> The idea for computing unions is similar to Guava's Iterators.mergeSorted(), but 1) duplicates in separate streams are removed, 2) duplicates in a single stream are not tolerated, 3) the semantics are more noun-based (`SortedStream u = new UnionStream(SortedStream s1, SortedStream s2))` rather than verb-based (`Iterator u = Iterators.mergeIterators(Arrays.asList(Iterator s1, Iterator s2).iterator(), new SomeNewComparator())`).
> 
> As far as I've found, there's no similar functionality in Guava for intersections.

I'd welcome any suggestions or feedback, including thoughts on whether this looks appealing to add to Guava.

Thanks,

 -Ken
 Thanks for the reply - no worries about taking a while, I've led several OSS projects and I know that's just how it goes. =)

I'm not sure how often such a thing is called for "in the wild" - I just know that I've written essentially the same utilities several times in several different languages over the past 15 years for a host of radically different situations.  This time, I decided to try to put it somewhere I'd always remember where it is - and the JVM / Guava seemed like a good place. =)

The way I use this code right now is in boolean searches - a user can specify criteria that, behind the scenes, hits multiple data sources. An `AND` is translated to an `intersection()`, an `OR` is translated to a `union()`.  This lets me cleanly separate the atomic back-end searches from the boolean logic.

Another use case would be a monitoring situation, sort of an "if-this-then-that" thing: show me events that satisfy `A AND (B OR C)` or whatever, as they occur forward in real time.  Since they're implemented lazily, they can check requirements as events arrive, rather than tying the logic to the event receiver.

As for the fail-late semantics of the streams, I think that's probably inherent to the nature of streams in general (and to lazy evaluation in even-more-general).  It could certainly be more flexible in how exceptional situations are dealt with, and of course be more general in what kinds of streams are acceptable (could be decreasing rather than increasing, could use a general Comparator or similar, etc.).

Perhaps the "flavor" of such a thing is closer to Scala or similar, but I'm sure Java & Guava have a wider audience, so it might be the sweet spot of "utility x ubiquity" as you say.
 So is this officially rejected, or just stalled?  Wondering if I should find a different home for it.
  hi, i think`com.google.common.util.concurrent.Striped` is a great tool, but why i couldn't use its `lazy` method to custom the supplier?
i just want to use Striped with my custom lock, but i found it's impossible, so should we make `lazy` a public access method?
 `Striped<L>` is a generally useful class that could be used for a fair number of things, including custom lock implementations. It would be good if this was accessible.  as TODO comments said to remove null boilerplate in CaseFormat.java . then I re-run CaseFormatTest test to ensure it passed .  
  Affected Files:796
Violations: 4071

Google Java Style guide (version of March 21, 2014): 
https://google-styleguide.googlecode.com/svn-history/r130/trunk/javaguide.html

Checkstyle Maven plugin report for Guava 17.0:
http://checkstyle.sourceforge.net/reports/google-style/guava/
All violations are thoroughly rechecked, but some very occasional false-positives could be present.

Detailed report (match of each Google Java Style rule to Checkstyle):
http://checkstyle.sourceforge.net/google_style.html

How to run (command line): 

```
~ $ cd /var/tmp
/var/tmp $ git clone https://code.google.com/p/guava-libraries/

/var/tmp $ wget -O checkstyle-6.1-all.jar http://downloads.sourceforge.net/project/checkstyle/checkstyle/6.1/checkstyle-6.1-all.jar?r=&ts=1416082535&use_mirror=tcpdiag

/var/tmp $ wget https://raw.githubusercontent.com/checkstyle/checkstyle/master/google_checks.xml

/var/tmp $ time java -jar checkstyle-6.1-all.jar -c google_checks.xml -o checkstyle-report-guava.txt -r guava-libraries

real    2m55.599s
user    3m12.596s
sys 0m1.056s
```

PS: all work was done during Google Summer of Code 2014
 > Our hacked-up version of checkstyle that we use inside Google misses a ton of things

Why not to contribute Google's fixes over Checkstyle to Checkstyle ? :)

> 926 ParameterName
> 263 LocalVariableName

Pelase update a Google Style Guide.

> 185 SingleLineJavadoc

from style guide "The single-line form may be substituted when there are no at-clauses present," . So all one line javadocs that have atclauses are not allowed.
So please fix Google Style Guide. and lets switch off that rule or update it. 

> 185 EmptyBlock (empty catch block)

Googe Style Guide need to updated to clearly state under what names and comments inside it will be allowed to have empty block. After that we could update Rules to cover them.
 > 926 ParameterName

Google’s Java Style Guide should be updated

> 740 JavadocMethod
> These violations are mostly things like _CustomFieldSerializer classes

Some exceptions for general rules will always be. You can use suppressions specific to Guava project:

```
<module name="Checker">
  <module name="SuppressionFilter">
    <property name="file" value="{path}/checkstyle_suppression.xml"/>
  </module>
  ...
</module>
```

checkstyle_suppression.xml :

```
<suppressions>
    <suppress checks="JavadocMethod"
              files=".*_CustomFieldSerializer.java"
              />
</suppressions>
```

> since the developer is allowed to use judgment about when the documentation would "have nothing useful to say" and is allowed to skip it in that case

JavadocMethod Check have option “minLineCount”="2", we could extend it to value you think in general mean “self explanatory method”. If that is not an option please confirm switching off that Check. 
But my advice is NOT switch it off, as developers can miss meaningful javadocs easily and developer will spend extra 1 min of this time to describe a method in javadoc. 1 minute is not critical time during development or before merge to target branch, but that time save you from other more sad mistakes.

> 307 Indentation
> A couple real mistakes here, but mostly we need to exclude LongAdder and Striped64 from checkstyle runs because we intentionally left them in Doug Lea's style.

checkstyle_suppression.xml :

```
<suppressions>
    <suppress checks="Indentation"
              files="LongAdder.java|Striped64.java"
              />
</suppressions>
```

> 263 LocalVariableName

ok, it is matter of your code standard, just change style guide.

> 185 SingleLineJavadoc

completely reasonable, but guide is not exact - so guide have to extended to be more precise.

> 185 EmptyBlock (empty catch block)

We could create special Check to do validation base on comment inside and base on name of variable. Checkstyle could not distinguish test code and production code so that allowance by name will be applied to all code. 
Are you agree ?

> 80 WhitespaceAround
> However, most of them are "catch... {}" and I think the error will have to be reported in different language or users will be very confused. ("Empty blocks may only be represented as {} when not part of a multi-block statement (4.1.3)")

Checkstyle have ability to change message in configuration, example - https://github.com/checkstyle/checkstyle/blob/master/src/main/resources/google_checks.xml#L40, so we could make it like:
“WhitespaceAround: '{' is not followed by whitespace. Empty blocks may only be represented as {} when not part of a multi-block statement (4.1.3)”
Are you agree ?
 @kevinb9n , it will also bee good to clarify what code is preferable (discussion at https://github.com/checkstyle/checkstyle/issues/533): 

```
boolean same = Util.<Integer, String>compare(p1, p2);  // Generic preceded method name
```

vs

```
boolean same = Util.<Integer, String> compare(p1, p2);  // Generic preceded method name, extra space between
```

will be good to put that in style document to resolve any further discussions.
 Empty Catch Block is implemented and released in Checkstyle 6.4, report was updated - "Last Published: 2015-02-28  | Version: 19.0-SNAPSHOT" 
http://checkstyle.sourceforge.net/reports/google-style/guava/

in case you need to regenerate report please use that simple steps: https://github.com/checkstyle/checkstyle/wiki/How-to-generate-Checkstyle-report-for-Google-Guava-project

FYI:
so the only item that is left to be done by Checkstyle team is "4.8.6.1 Block comment style", but will be addressed in next release.
 New options "ignoreInlineTags" and "ignoredTags" for Single Line Javadoc were added and released in Checkstyle 6.8.
<b>ignoreInlineTags</b> allows inline tags (such as {@code}, {@link} etc.) to be put in a single line javadoc. Report generated with Checkstyle 6.9 over Guava 19.0-SNAPSHOT with this option switched on shows a lot less violations: <b>53</b> (http://vladlis.github.io/reports/google_style/) against <b>227</b> (http://checkstyle.sourceforge.net/reports/google-style/guava/). So it makes sense to extend the Style Guide (http://google.github.io/styleguide/javaguide.html#s7.1.3-javadoc-at-clauses) and make it more precise in order to allow inline tags. Some googlers already reported that issue at https://github.com/checkstyle/checkstyle/pull/1545, but to change config with new option we need to have update in Google Java Style first.
<b>ignoredTags</b> could also be used if some tags, for instance @see, were allowed by the Guide in a single line javadoc.
 CommentsIndentationCheck was introduced and reliased in Checkstyle 6.12. The Check covers the section [4.8.6.1 Block comment style](http://checkstyle.sourceforge.net/reports/google-java-style.html#s4.8.6.1-block-comment-style) from Google Java Style Guide. Report generated with Checkstyle 6.12 over Guava 19.0-SNAPSHOT with CommentsIndentationCheck shows [11 violations](http://checkstyle.sourceforge.net/reports/google-style/guava/).
So, Google Java Style Guide was covered by Checkstyle as much as it was possible. See [Google's Java Style Checkstyle Coverage](Google's Java Style Checkstyle Coverage).
 > 926 ParameterName

guide is updated - https://google.github.io/styleguide/javaguide.html#s5.2.6-parameter-names

> 263 LocalVariableName

Clarification issue request was created to style project - https://github.com/google/styleguide/issues/214

> 185 SingleLineJavadoc
Single-line javadoc is explicitly allowed by 7.1.1.

confirmation request - https://github.com/google/styleguide/issues/215  The expected output is `amazonaws.com`, but an `IllegalStateException` is thrown.
  Context: 
Attempting to implement a queue that can buffer data at any incoming rate, but meter the output to a steady stream.  However, unless using the `warmupPeriod` constructor of RateLimiter, the throttling doesn't seem to kick in immediately.  

In the following example, the output of the queue (as throttled by RateLimiter) allows three items to slip through unthrottled (note the identical time stamps of A, B and C):

```
10:27:21.603 Thread 11: A
10:27:21.603 Thread 11: B
10:27:21.603 Thread 11: C
10:27:22.072 Thread 11: D
10:27:22.575 Thread 11: E
10:27:23.076 Thread 11: F
```

Code to reproduce:

``` java
import java.util.Arrays;

public class Main {

    public static void main(String[] args) throws InterruptedException {
        RateLimitedQueue<String> rlq = new RateLimitedQueue<String>(2);

        Thread.sleep(1000);

        for (String element : Arrays.asList("A","B","C","D","E","F"))
            rlq.add(element);   
    }
}
```

``` java
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.LinkedList;
import java.util.Queue;
import com.google.common.util.concurrent.RateLimiter;

public class RateLimitedQueue<T> {

    public final RateLimiter rateLimiter;
    public final Queue<T> queue;
    private Thread readerThread;
    private final int permitsNeeded = 1;

    public RateLimitedQueue(double maxEventsPerSecond) {
        rateLimiter = RateLimiter.create(maxEventsPerSecond);
        queue = new LinkedList<T>();
    }

    public void add(T value) {
        queue.add(value);
        if (readerThread == null || !readerThread.isAlive()) {
            readerThread = new Thread(new QueueConsumer<T>(this, permitsNeeded));
            readerThread.start();
        }
    }

    public void queueProcess(T data) {
        SimpleDateFormat sdf = new SimpleDateFormat("HH:mm:ss.SSS");
        System.out.println(sdf.format(new Date()) + " Thread " + Thread.currentThread().getId() + ": " + data); 
    }

}
```

``` java
public class QueueConsumer<T> implements Runnable {
    final private RateLimitedQueue<T> rlq;
    final private int permitsNeeded;

    QueueConsumer(RateLimitedQueue<T> rlq, int permitsNeeded) {
        this.rlq = rlq;
        this.permitsNeeded = permitsNeeded;
    }
    @Override
    public void run() {
        while (!rlq.queue.isEmpty()) {
            rlq.rateLimiter.acquire(permitsNeeded);
            rlq.queueProcess(rlq.queue.remove());
        }
    }
}
```
 Yes, without the sleep it does throttle as expected.  I do think it would be useful to have a mode of operation where there's a guaranteed minimum spacing between granting permits to constrain the catch up behavior (up to and including eliminating it entirely).  It wasn't until I incorporated the RateLimiter into an application with long UI pauses between data bursts that I noticed this.

In my use case, I'm trying to add and/or remove a number of marker pins on Google Maps in bulk and it seems to work more reliably if the UI thread is given a momentary break between successive API calls.  (On reflection, a simple timer might be a viable alternative here.)  
  guava's HtmlEscapers just escapes known entities (double quote, open and close angle bracket, and single quote, that's pretty much it). It does not escape a bevy of other 'suspect' characters, including crazy unicode takes on angle brackets which some well-intentioned browser may try to interpret as actual angle brackets (if such browsers exist, then that would mean `HtmlEscapers` currently has security-critical bug in it, ouch!).

I admit I haven't done the complete research on this, but on general security principles, shouldn't HtmlEscapers whitelist a select few characters (tab, space, enter, and most alphanumerics in ASCII, and that's about it), hardcode a select few character to entity mappings, and `&#` escape everything else?

While we're here, the HTML docs refer to using `&#` encoding to encode `code points`. That sounds like it means that a surrogate pair in a java string should be encoded as a single code point. Just about every existing escape library doesn't get that right.

Some basic research:
- Spring's HtmlEscapers equivalent works broadly like guava's, but has a MUCH longer list of known entities. [source code](http://grepcode.com/file/repo1.maven.org/maven2/org.springframework/spring-web/4.0.6.RELEASE/org/springframework/web/util/HtmlUtils.java#102), [list of supported entities](http://grepcode.com/file/repo1.maven.org/maven2/org.springframework/spring-web/4.0.6.RELEASE/org/springframework/web/util/HtmlCharacterEntityReferences.properties).
- Apache commons has multiple different classes that can do it, and they are implemented differently. StringEscapeUtils works similarly to spring's ([source](http://commons.apache.org/proper/commons-lang/apidocs/src-html/org/apache/commons/lang3/StringEscapeUtils.html)), but there's also Entities, which escapes everything above 0x7F as well as a few hardcoded characters. It does not handle surrogate pairs well, nor does it escape suspect ASCII characters such as 'bell', 'backspace', 'NULL', delete, etc. ([source](http://grepcode.com/file/repo1.maven.org/maven2/commons-lang/commons-lang/2.6/org/apache/commons/lang/Entities.java#Entities.escape%28java.io.Writer%2Cjava.lang.String%29)).
- The SGML spec seems to suggest that for example characters with codes 128 through 159 **may not be used at all**, yet the HtmlEscapers code doesn't escape these. ([source](http://www.w3.org/TR/REC-html40/sgml/sgmldecl.html)).

I'm willing to contribute a patch (with a whitelist and surrogate pair handling), but would like confirmation that the guava team feels that the current implementation of HtmlEscapers is security-wise rather iffy, i.e., that this patch is needed in the first place. There's also the tricky issue of context. For example, in normal HTML, there's no need to turn quotes into `&quot;`, and if you're in a CSS or javascript section inside an HTML document, you need very different escaping rules, so in some ways the problem 'please escape this string for me so I can put it in an HTML document' _requires_ a context, but for many programmers they simply don't know what context they wish to escape for.
 This OWASP html escaper code does most of the things I covered, including being based on a whitelist model, numerically escaping _anything_ not explicitly trusted. [source](https://code.google.com/p/owasp-esapi-java/source/browse/trunk/src/main/java/org/owasp/esapi/codecs/HTMLEntityCodec.java) – this strongly suggests guava's HtmlEscapers is a security issue waiting to happen.
  When dealing with hex encoded input, I have to handle both lower and uppercase input. Since decoder ist strict, I would have to `String.toLowerCase()` the input before passing it to the decoder, which is another copy process.

Nicer would be `BaseEncoding hex = BaseEncoding.base16().ignoreCase();`
 An example would be hex encoded hashes from the web. - But my usecase is a more general utility class which supports encoding itself to hex and decoding hex values to instances of itself. I don't want to make people think about this issue.

This is only a minor inconvenience, but it does violate the principle of least astonishment. I was expecting it to work, but I had to go back and fix it once someone actually used the method with uppercased input.

So maybe the default behaviour could be to ignore the case, and only be strict if either `.lowerCase()` or `.upperCase()` were used.

Thanks for taking the time :)
 Reading the explicitly referenced RFC, the first paragraph in section 8 already states:

http://tools.ietf.org/html/rfc4648#section-8 :

> The following description is original but analogous to previous
> descriptions.  Essentially, Base 16 encoding is the standard **case-**
> **insensitive** hex encoding and may be referred to as "base16" or "hex".

~~So I would go as far as calling this a minor bug.~~
**EDIT:** Well lets say, it warrants an ignoreCase() decoding setting.

commons-codec ignores case, and uses Character.digit(..)
python has a switch to be insensitive, but strict per default
golang is insensitive
and I'm shocked how bouncycastle is doing it
 :+1:  if .lowerCase() or .upperCase()  is not specified, makes sense to ignore case sensitivity on decoding.
 I think `BaseEncoding.base16().decode(str.toUpperCase())` is perfect
 Case doesn't matter when decoding base 16, so it would be nice if it just _worked_ no matter what case the input is. The lowerCase() and upperCase() methods should only affect encoding.
 It's certainly non-intuitive that it's case-sensitive. Which violates the principle of least astonishment I don't understand why this closed in 2015 @haozhun ?  
It maybe related to  "[Allow mixed case in from base functions #2669](https://github.com/prestodb/presto/issues/2669)" but only if you limit your scope to strings.  I need to be able to use the encodingStream and decodingStream and I need to be able to accept mixed case input streams for base16 decoding. I can be pretty sure the inputs will be consistent but can have no guaranty  that they will be upper or lower cased  If I need to store 85899345920 data, the amount of space is how much? It should not be 8 \* 8 \* 85899345920? 10 g? Not very understand the meaning of operation.Thank you!!
 @haochun Are you refering to anything in the Guava documentation? If your question has nothing to do with Guava I'm afraid you are not going to get your answer here.
   Hi,

I encountered a concurrency issue between the "get(K key, Callable<? extends V> valueLoader)" and "invalidate(Object key)" methods with a basic (and i suppose a common) usage of the cache which let a stale value in the cache.

Here is the use case:
- The cache is initially empty
- 1 thread is getting a value in the callable with a given key while an other thread is invalidating the same given key

**Thread 1**

``` java
Bean myBean = cache.get(ID, new Callable<Bean>() {
    @Override
    public Bean call() throws Exception {
        Bean bean = loadFromDB(ID); // (1)
        return bean; // (4)
    }
});
```

**Thread 2**

``` java
// Update just one property of the bean in DB
updatePartialDataInDB(ID, "newValue1"); // (2)
// Then, we need to invalidate the cache
cache.invalidate(ID); // (3)
```

The execution sequence order is marked with _// (number)_
After the point _// 4_, I have the old object in _myBean_ variable which is fine.
However, If i try to get again the bean with the identifier ID, I expect to have no value in the cache but a fresh bean reloaded from the DB.
Unfortunately, that is not the case and a stale value is kept in the cache.

Is that a wanted behavior?

In LocalCache$Segment#remove(Object key, int hash) line 3081 to 3087 (guava 17.0):

``` java
RemovalCause cause;
if (entryValue != null) {
    cause = RemovalCause.EXPLICIT;
} else if (valueReference.isActive()) {
    cause = RemovalCause.COLLECTED;
} else {
    // currently loading
    return null;
}
```

Shouldn't a particular process be done before _return null_ ?

Thanks
 Hi,

Do you plan to fix this issue for the next release?
If so, do you have an ETA?
This is a blocking issue for us.
Else, should we patch the code meanwhile?

Thanks
 Hi,

Speaking of semantics, it's not value that is being invalidated, it's the key. The key is certainly there - and the value is being calculated. 

Given that value V(K) is calculated from some other value X(K) (a row in DB, in this sample case), invalidate(K) should mean that any values based on values of X(K) retrieved up to the moment of invalidation are subject for recalculation.

Otherwise, the cache is pretty much useless in a simple case of caching a database row.
 The problem does not come from the current pending fetch.
As i said, this is fine to return the not up to date bean at step 4 but this one must not be kept in the cache entry for next fetches.
 I'd say this would be the expected behaviour.
 > I don't think that's 100% obvious -- I suspect there are cases where you don't want the value-in-flight to be invalidated

@lowasser I'm trying out the implementation in my private fork. I had to revisit some tests, and from what I see, there is no good reason for the current behaviour. Some tests actually assume that the value does not change when the invalidation happens, which contradicts the purpose of invalidation.

All existing tests are currently green, and ones I added too; but I need to add more tests to check subtler consequences of my changes. I can't guarantee that I will do it fast, but if you have time, let me have a try on this one.
 This is causing some very serious issues for us.  I would argue that anyone using a lazy-loading cache would expect a happens-before relationship between invalidate and a following call to get, but since it can piggy-back on an existing load operation that fetched data before invalidate was called, that relationship does not exist.

I started poking around in here to try to fix it, but as @lowasser hinted, it isn't trivial.  The main problems are

```
1. Whether to remove the LoadingValueReference, block on it, or somehow mark it as stale; and
2. How to rework the removal notifications
```

This is sufficiently painful that at this point I'm inclined to switch to another library, instead.
 @txshtkckr Please see https://github.com/baltiyskiy/guava -- I've went with the "remove LoadingValueReference" approach, firing removal notification for the value when it is loaded. It's generally done, but I'd like to add some tests cases there. There's one known problem (regaring `modCount`) which I need to poke more. 

I've put it on a pause now because I don't have much time due to other commitments, but I intend to finish it. 
 I second @sereda expectation of causality, in that a loaded value V(K) must be updated when the key is invalidated.
Has there been a consensus how to work around this particular problem? If so, it should be included in https://github.com/google/guava/wiki/CachesExplained  creat method:
![qq 20141105153403](https://cloud.githubusercontent.com/assets/9320176/4914158/8b15dc10-64be-11e4-9d48-9870e165b74f.png)

readFrom method
![qq 20141105153422](https://cloud.githubusercontent.com/assets/9320176/4914159/8b19cd98-64be-11e4-8d1c-d576887a6d23.png)

is there right?
  BloomFilter has writeTo method,that i can serialize it to file.but,i found it is slow and the serialized file is to big.i want use Kryo to serialize.but,when i use Kryo,it happed exception.So,how can i replace it?
 the exception is Kryo use asm.jar to reflect sum.nio.cs.UTF_8,but there is no access. 
I want to use Kryo,because Kryo is very fast and file is small,only 153M.but ,it has 1.2G when i use BloomFilter.writeTo() method  . How can I improve my speed, and makes the serialization files smaller
 I am a Chinese, I say relatively poor English, I hope you can understand what I mean
  This changeset adds support for [Travis CI](https://travis-ci.org/) as publicly visible means of continuous integration (additionally to the probably internally running CI system at Google).

Travis CI is configured to build Guava with Oracle JDK 7, OpenJDK 7, and OpenJDK 6. Oracle JDK 8 hasn't been added to the list because of the currently unresolved issues with building Guava with Java 8.

In order for this changeset to work, someone with the appropriate permissions on the Guava repository will have to activate the build on Travis CI, see [Activate GitHub Webhook](http://docs.travis-ci.com/user/getting-started/#Step-two%3A-Activate-GitHub-Webhook).
 I have signed the Google individual CLA.
  The `guava-parent` Maven POM still contains URLs pointing to Google Code for issues and SCM. This changesets updates the respective URLs to their counterparts on GitHub.
 I have signed the Google individual CLA.
  The function maybe uses like this:

long factorial = Collections.reduce(Lists.newArrayList(1,2,3,4,5), new Function(){
     long apply(int x, int y){
     return x*y;
}
})
  So Guava moved to Github! This is my first (and very small) fix: I spotted improperly closed tag in [ByteArrayDataInput's Javadoc](http://docs.guava-libraries.googlecode.com/git-history/v18.0/javadoc/com/google/common/io/ByteArrayDataInput.html). Should be OK now.
 No problem, I've just signed individual CLA.
 FWIW, two-way sync works fine for Guice, though we have limited google-internal things.
  I was directed here in a discussion of https://issues.cloudera.org/browse/DISTRO-638 ("Cannot install Cloudera Manager Agent if hostname starts with a digit") where the origin of that issue is that Docker generates hostnames as random hexadecimal strings, which do therefore quite often start with a digit. (And they refuse to change that, insisting that it is totally RFC-compliant to start with a digit, as long as there is also any normal letter in the hostname: https://github.com/docker/docker/issues/7756, https://github.com/docker/docker/pull/8194)

I would therefore very much like to see a change of behavior from "fail if first character of TLD is a digit" to "fail if all characters of TLD are digits".
 tgpfeiffer there is a patch for that you can even patch it easy your self with simply adding a random letter fixed in front of the container name via editing docker src and making a fork
   This should be closed.       Sorry - yes agree totally with that - and deleted original comment when I meant to edit it!!
 Hi !

Admitting your sub-class name ends with `Converter`, this "false positive" can be filtered with this rule instead of overriding `hashCode()` in every sub-classes :

```
<?xml version="1.0" ?>
<FindBugsFilter>

    <Match>
        <Bug pattern="HE_INHERITS_EQUALS_USE_HASHCODE" />
        <Class name="~.+Converter" />
    </Match>

</FindBugsFilter>
```

By the way, do you have any idea when this will be fixed ?

Thx
 I guess, there might be a small performance loss due to either override (making some call sites "more-morphic"), but it's not sure as both `hashCode` and `equals` get special treatment. AFAIK JIT is not smart enough to recognize empty overrides.

IMHO the `Converter.equals` javadoc is not really useful as 1. it states the obvious and 2. I'd be surprised if anyone has ever overridden it. I'd bet that anyone smart enough to find out that they need to override equals for `Comparator`, `Function`, `Converter`, or alike is smart enough to know that equal objects must behave the same.
   This would be a parallel of Class.asSubclass, yes? Something like the following:

```
@SuppressWarnings("unchecked")
public <U> TypeToken<? extends U> asSubclass(TypeToken<U> sub) {
    if (sub.isAssignableFrom(this))
        return (TypeToken<? extends U>)this;
    else
        throw new ClassCastException(String.format("Cannot cast %s to %s", this, sub));
}
```
 Hi! It has been a long time, but I think this is exactly what I thought of.

IMHO the term "Subclass" in the method name is misleading, as here we can have any subtype.
E.g.

``` java
TypeToken<? extends List<?>> type = new TypeToken<ArrayList<Integer>> {};
type.asSubclass(new TypeToken<List<Integer>> {}); // this should work
```

Maybe there could be two versions:
`<U> TypeToken<? extends U> asSubtype(TypeToken<U> other)`
and
`<U> TypeToken<? extends U> asSubclass(Class<U> other)`.

Sorry if I got something wrong: as I said it has been a long time.
Thank you.
  I'm not sure about other places, but this is definitely already fixed for newHashSet: https://github.com/google/guava/commit/736f404aed944516aba96812ae0eab6781bf869a#diff-7e3112faa0144939dea5de95473cfd55R156
   I apologize if I'm badly confused, but Map doesn't appear to define a "iterator()" method as is suggested by the RangeMap docs currently (explicitly in `asMapOfRanges().iterator().remove()` in the subRangeMap doc).

Is iteration in `asMapOfRanges().entrySet().iterator()` guaranteed to be ascending?  Or is there some other way to iterate?
  I confirm that a 18.0.1 release including this fix will be really useful.
Currently, any exception thrown inside a @Subscribe-annotated method is lost and that's troublesome for debugging.

Could you please consider search a minor release?
  I’m in favor of `Optional<Integer>`. I like that the Guava library encourages programmers to follow best practices, and reduces the number of bugs or risky code.

`public static Integer tryParse` is very risky. Not only for the usual reasons related to `null`, but especially here because users of Guava will be tempted to write:

> int i = Ints.tryParse(…)

which makes it even more difficult to spot that there’s a possible NPE hiding there.

Furthermore, users who strive for performance and are willing to pay the price of clarity might want to use specifically dedicated code optimisations anyway to make it even faster (e.g., see previous comment). `Optional<Integer>` sounds rather perverted due to double boxing. But there's `OptionalInt`, which is singly boxing just like `Integer` and more usable.

> Did we have any reservations that tryParse("foo", 10) might look like it's providing a default value rather than a radix?

I can only tell, that it definitely looks like the default value. What about `OptionalInt Ints.parser(radix).tryParse(string)`? It creates a new tiny object holding the radix, but in performance-critical code it can be reused. This way, you don't need a new name and you could also add `int Ints.parser(radix).tryParse(string, defaultValue)` without risking any confusion. @Maaartinus The problem however with `OptionalInt` is it lacks certain key methods which `Optional<Integer>` has built-in, like `map` and `filter`, which arguably makes `OptionalInt` not as easy to use. But, saying that, it's not clear to me which would be more important here: performance or usability.  any plans to address this?
 What would the benefit be if this metric was available?

The `loadCount` has a direct relationship with `loadSuccessCount` and `loadFailureCount`, and can be used with `totalLoadTime` (e.g. `averageLoadPenalty`). That helps determine how expensive a miss operation is. By inspecting the hit rate one can better understand how to improve performance (increase the cache size or reduce the load time). The `evictionCount` has a similar relationship.

`putCount` is a metric without much meaning behind it. The cost of creating the entry isn't clear. Other additions along that line of thought might be `invalidationCount` for manual removals of entries. These appear to be metrics that could be captured, but don't carry much weight by themselves. While it might be nice to be baked in, a user can just as easy add a counter after performing the operation.

Ideally users wouldn't manually manage the cache very often. Even if they did, I'm hard pressed to think of how this extra information would be useful from an operational standpoint
 Imagine a situation where cache is typically populated with **put**, but sometimes loads data, if there was a miss, Some kind of write-through cache., where value can be loaded, if it wasn't written. 

Currently there is no way to find out how many requests was consuming pre-calculated values and how many requests was loaded by cache.
 I guess my question is how does that metric (loaded vs pre-calculated insertions) provide operational insights? In what scenarios would you leverage this insight to make improvements?
 If I want to minimize number of loads compared with number of puts.
   I have submitted a pull request to fix this.
https://github.com/google/guava/pull/2243
  `union()`, `intersection()`, and `difference()` were added to `ImmutableRangeSet` in 04a28f4dd8.    The issue got migrated and closed:
https://github.com/gwtproject/gwt/issues/8805

But we now get the same issue with ImmutablList$SubList, mainly because RegularImmutableList.subList now returns that type instead of a RegularImmutableList. Caused by the commit: [cb3a29fb67936c2bc52b1cfee08cedab62950282](https://github.com/google/guava/commit/cb3a29fb67936c2bc52b1cfee08cedab62950282)
  While it is possible to add `@Nullable` to `equals` for own code, it may not always be possible to do this for generated code. For example, the AutoValue team decided to not do this (https://github.com/google/auto/issues/73).

Thus I think that `NullPointerTester` should special-case `equals` and behave correctly whether the annotation is present or not. After all, the JavaDoc of `equals` specifies explicitly that the parameter can be null.
  +1
 +1
 +1 +1              The reason Collections.unmodifiableMap is not a good workaround is because what I want is a simple, reliable map builder. It's too bad this implementation doesn't just work for maps. My use case is columns in a database table, some of which accept null values. Why is this not legit? @orbfish I think it's because, unfortunately, `null`s cause far too many bugs in real-life applications, and the Guava team wants to avoid that. (Programmers forget all the time that `null` can be assigned to variables of object types in Java, which causes unexpected `NullPointerException`s).

`Optional` is a little bit better, because at least it's explicit about the potential case of an instance being "absent" (which `null` is sometimes used to represent). But it's not a complete solution to the problem for various reasons.

I think what we really need here are "nonnull" types, which are types where `null` is _not_ a valid value. Unfortunately, there are no plans yet by Oracle to investigate such types in OpenJDK AFAIK, and I doubt Oracle will begin investigating them until some point after [Project Valhalla](http://openjdk.java.net/projects/valhalla/) (Value Types) reaches its conclusion, as Project Valhalla is hideously complex and may very well affect everything in the Java language, meaning it would be very difficult for Oracle to do other large-scale language investigations at the same time (like looking into "nonnull" types or a similar solution).

Just thought I'd express my personal thoughts on this matter. :) Even if Oracle decides to rewrite their database, I'm in a situation where we would not be able to redo all the tables. It's frustrating - I understand why nulls are not desirable, but I'm still finding Guava handy enough to use a lot, but opinionated in such a way that I'm having to write an entire wrapper library around it to deal with reality. Unfortunately, I find that I don't have time to rewrite Jdbc for this project. ;) I'm trying to create a map of database columns to values. Some of these values need to be null (real null, not Optional "null"). I implemented my code with the Guava immutable map builder, and found that it failed at runtime due to null values. So I'm writing another map builder to do this. I've also found that some of MoreObjects is very useful, but only if I wrap it in a null-safe version (again, for database interaction, not for a case where I can replace null with Optional).

I use Optional every day - but it isn't compatible with the entire world of Java. I more-or-less had the same question as @jrtom in the depths of my subconsciousness.

I'm curious (in a kind way) as to why you can't simply use either of Java 8's streams or Guava's functional constructs (or even using `Optional.ofNullable` manually) to "map" each `null` value from your database column into a `java.util.Optional` or Guava Optional before storing it in your immutable map. First 2 questions:  I could store an Optional in the map - but I'd have to render that back to a map with nulls before feeding it into JdbcTemplate.
Last question:  ease of use. I want my code to be more readable. Here’s what I do:
```
public static final Object JDBC_NULL = new Object();
```
Then in your calling code you can say this:
```
Object cell = map.get(columnName);
if (cell == JDBC_NULL) {
  ...
} else {
  ...
}
``` I think most people find Java's map initialization to be unbeautiful. Here's an interesting comparison (rather than me spending 15 minutes writing out the legacy version):

http://minborgsjavapot.blogspot.com/2014/12/java-8-initializing-maps-in-smartest-way.html Sorry, I meant initialization (edited). @orbfish If you're wanting to initialize the map with a constant number of entries, then I think the last "Java 8" example given in that blog you linked would be very suitable for your purposes and more-or-less as readable as the "Builder Pattern" example.

Otherwise, you have 2 options: instantiate a `LinkedHashMap` and populate it manually (as @lowasser already suggested), or create your own null-friendly map builder (which would look pretty but require quite a fair bit of testing I imagine!) As I said above, I wrote another map builder. More intuitive for anyone else who needs to use it, I think. This class would be extremely useful if Guava devs let the developer be responsible for his own code. Instead we're forced to write another map builder because people are afraid that devs will not check for null... c'mon. There are plenty of 3rd party code that happily works with nulls in maps (at least as values). I find builder pattern elegant and would like to use guava's ImmutableMap for this purpose but I can't, shame. Null is a normal object state in real-world programming and few are the cases you don't want to check for them. I would agree with you if this class removed lots of code, but it instead just force me to not check for nulls - just an if. And just because of an if - a convenience, like you said - people using Guava are forced to write duplicated code just to fit some null values that may come in.

But for what I've seen here we're better just doing it the old way. I've learned to code without `null`, I write so much less code, not "just an if" less. An `if` is usually 3 lines, but it blocks you way beyond you can imagine. I write less code because I don't check for null, I inline/stream much easier.

The Guava devs have said they will not change `ImmutableMap` to support `null`. Well, nothing forbids you to write your own null-friendly collections with Guava-inspired builders, make them available and forge a community around them.

I'm personally very happy with the choices, you aren't. A line must be drawn somewhere to make the project go further. I'm sorry you're not (yet) on the same side of the line; maybe the inventor of `null` can make you [change your mind on `null`](https://en.wikipedia.org/wiki/Tony_Hoare#Apologies_and_retractions)? That's triumph of ideology over real life, i.e. what the current state of Java as a language and ecosystem is. Just to clarify: I don't need convincing that my life would be easier without `null`. But a lot of existing code deals with nulls in maps and IMHO it's unfortunate choice to not provide at least a separate implementation with `null` support. As I've said null is a normal object state in real-world programming and we need to deal with it. You are happy with not having to write checks, good, but from "my side" I'm forced to pick the ImmutableMap and create a duplicated class with support for nulls, and this is simply not acceptable because, I repeat, null is a perfectly normal state of an object in real-world programming and therefore just saying "don't use nulls" is not justifiable. But as I said, I don't expect the devs to change their mind, so I'll just keep it the old, duplicated, way. @Ryaryu Could you clarify for me if you want an immutable data structure that can contain `null` elements, or an immutable data structure that _filters_ out given `null` elements at construction time? @jbduncan Can contains null values. If you filter the null elements at construction time you defeat the purpose of the devs since you'll be forced to use containsKey unless you traverse the key set, right? I want to be able to react the way I want to null values in the map, for this reason I am simply duplicating the class with null support nowadays. > If you filter the null elements at construction time you defeat the purpose of the devs since you'll be forced to use containsKey unless you traverse the key set, right?

Not so AFAICT.

I realise I was a bit unclear in what I was asking, apologies!

What I meant to ask, with regards to null-filtering, was if you wanted an immutable map where, during construction time (using, say, a builder), if a given entry (key-value pair) has a `null` key or value, then the map builder should simply not insert the key-value pair into the end-result map, and it should do so silently (as in it should not throw a `NullPointerException` or equivalent).

If we take what I meant to ask above, then `null` values shouldn't even exist in the end-result map (since they'd have been effectively _filtered_ out before the map was created), so by my understanding checking for the existence of `null` values with `containsKey()` shouldn't be necessary. But anyway, it's clear to me now that what you're really after is an immutable map with potentially null values. Thanks for clearing things up for me! > What's wrong with the workaround of using Collections.unmodifiableMap on a mutable map?

Will unmodifiableMap produce concurrent modification exception if I modify underlying map while iterating this unmodifiableMap? If yes then its not a workaround at all
upd: yes it does throw That's what I needed too! Ended up having to write my own.

On Thursday, April 27, 2017, Jonathan Bluett-Duncan <
notifications@github.com> wrote:

> But anyway, it's clear to me now that what you're really after is an
> immutable map with potentially null values. Thanks for clearing things up
> for me!
>
> —
> You are receiving this because you were mentioned.
> Reply to this email directly, view it on GitHub
> <https://github.com/google/guava/issues/1782#issuecomment-297714687>, or mute
> the thread
> <https://github.com/notifications/unsubscribe-auth/AHTqdqZr9Rq6mc8UuOoh4wFkXRgxvtF4ks5r0JmZgaJpZM4C1jsV>
> .
>
 Sorry @jrtom looks like I never replied to you. I can't have a special null
object, because this is being passed into jdbc, where a null value means a
null column in the database, which is sometimes needed. For this reason, I
need null values - in terms of the database, they're valid, not a coding
error.

On Mon, Dec 26, 2016 at 5:44 PM, jrtom <notifications@github.com> wrote:

> @orbfish <https://github.com/orbfish>, you don't need to create a whole
> new wrapper library. You can either create a special Null object (if you
> control the type you're storing) or you can use Optional, as @kak
> <https://github.com/kak> suggested. The latter would cause you to
> explicitly handle null objects in your code, which seems like a good thing.
>
> —
> You are receiving this because you were mentioned.
> Reply to this email directly, view it on GitHub
> <https://github.com/google/guava/issues/1782#issuecomment-269252310>, or mute
> the thread
> <https://github.com/notifications/unsubscribe-auth/AHTqdkrMZphGcZ2z2Uz6-YCFhxEh8GR-ks5rMF9XgaJpZM4C1jsV>
> .
>
 This basically makes ImmutableMap useless for me. @nitehawk42 Have you tried any of the suggestions above, like replacing `null` with a special "null" object or using `Optional` wrappers?  A high quality RangeTree structure would be useful for genomic work.  
   I've also run into this issue, currently you can't use a RateLimiter in a unit test using a fake Ticker.  I don't think this is a duplicate; the referenced "duplicate" seems unrelated.  That one was a bug, this one is a feature request, one I'd like to see. Hmm but how would you _unregister_ a subscriber?
The register method could return somekind of ID and internally track subscribers, but that seems like a not so minor change... Hmm, a fair point, but if you wanted to be able to unsubscribe, you could just put the lambda in a variable.  Or even just use the normal, more verbose way of defining a subscriber.  And in many of the circumstances I've subscribed lambdas to things, before, I simply never unsubscribed them; they were active for the entirety of the program.  The id mechanism does sound useful, but not strictly necessary. > ...but if you wanted to be able to unsubscribe, you could just put the lambda in a variable.

How would putting it in a variable allow you to do that? Presumably the same as a normal object;

```
Consumer<String> callback = (String s) -> System.out.println(s);
eventBus.register(callback);
// Later
eventBus.unregister(callback);
```

Not quite as tidy as
`eventBus.register((String s) -> System.out.println(s));`
but better than the 7-10 line current alternative.

Granted, this might cause confusion if somebody's trying to register a subclass of `Consumer<T>` but they don't want to register the `accept` method.  I guess you could overload the `register` method specifically for `Consumer`s, or even just have a separate method, though that's a little annoying. > Presumably the same as a normal object;
>
> ```java
> Consumer<String> callback = (String s) -> System.out.println(s);
> eventBus.register(callback);
> // Later
> eventBus.unregister(callback);
> ```

That makes sense to me. Thanks for the clarification!  I'm not sure about this example:

```
public void bla(List<Blub> list) {
 checkThat(list).describedAs("list has to be not null and not empty").isNotNull().isNotEmpty();
}
```

I'd rather see:

```
public void bla(List<Blub> list) {
 checkThat(list).describedAs("list").isNotNull().isNotEmpty();
}
```

The library can surely handle a little string concatenation to produce a meaningful error message with this much information.

(This is also my main beef with Preconditions.check methods in general. I can only choose between two equally unacceptable options: (a) checkNotNull(value), which as a library user, doesn't tell me which parameter was null, or (b) checkNotNull(value, "value is null"), which forces me as a library developer to say what I'm checking twice, plus adding a caveat that someone has to update both in sync, or introduce an incorrect error message. FWIW, my other beef is that it throws the wrong exception. If I wanted a NullPointerException, I could just not check the parameter!)
    There is no class called 'UninterruptiblesTest'.
Am I missing something? or was this class deleted?
   I would also like to see this implemented. One of the ideas I have is to generate bit sequences of k bits set out of total n bits and then the combinations simply correspond to k bits that are 1. Doing this would be much more efficient than going through Collections2.permutations (generates lots of duplicates) or Sets.powerset (limitation of 30 elements)

For my String processing usecase, I adopted this algorithm - it will be universally applicable for generating the bit sequences.
https://graphics.stanford.edu/~seander/bithacks.html#NextBitPermutation
 Looks like this was picked up and implemented in Release 23!
https://github.com/google/guava/wiki/Release23

"Set<Set<E>> Sets.combinations(Set<E> set, int size): returns all subsets of the given set that have the given size"   I'd suggest using the following implementation instead (still throwing `ClassCastException`), since `IllegalArgumentException` implies user-error, whereas you're suggesting using this method in cases where the programmer believes this invariant is enforced. This seems like a similar feature to [`Throwables.getCauseAs()`](https://google.github.io/guava/releases/22.0/api/docs/com/google/common/base/Throwables.html#getCauseAs-java.lang.Throwable-java.lang.Class-), which throws `CCE`.

```
public static <A, B extends A> B checkType(A value, Class<B> target, String name) {
  checkNotNull(value, "%s is null", name);
  if (!target.isInstance(value)) {
    throw new ClassCastException(String.format(
        "%s must be of type %s, not %s",
        name,
        target.getName(),
        value.getClass().getName());
  }
  return target.cast(value);
}
```

The existence of `Throwables.getCauseAs()` suggests this might be a good general-purpose addition, but on the other hand `Throwable.getCause()` is a somewhat special case, as there's no way to enforce the cause's type at compile-time.

---

Edit: a standard `(Foo) bar` cast includes the types in the error message ("*java.lang.ClassCastException: Bar cannot be cast to Foo*"), but I think there's still some value in including user-provided context alongside the types in question.  I'm running into these same problems, thought I'm not sure that dropping the queue nature of the event bus is a good idea --I actually rather like it at least conceptually. There are also a couple places where I leverage the queue for a particular feature.

Anyways, the bug me and my company are running into is also in a GUI'd app, where we have worker threads and a UI thread that should be avoided.

This test illustrates our problem:

``` Java
public class GuavaEventBusFixture{

    public void when_using_relatively_simple_chain_of_events_should_cause_deadlock(){

        //setup
        EventBus eventBus = new EventBus("testing");
        SubscriberX subX = new SubscriberX(eventBus);

        //act
        eventBus.post(new EventA());

        //never reach here, deadlock

    }

    public static class SubscriberX{

        private final EventBus eventBus;

        public SubscriberX(EventBus eventBus){
            this.eventBus = eventBus;
            eventBus.register(this);
        }

        @Subscribe public void doThingsOn(IEvent event){

            // so this particular implementation is a little odd
            // and this same phenomena can be expressed in other ways,
            // this was just the quickest way I thought of.

            SyncingUtilities.runImmediatelyOnFXThread(() -> {
                if (event instanceof EventA) {
                    eventBus.post(new EventB());
                }
            });

            // the key thing to note about this code is that maybe it dispatches an asynchronous job,
            // and then attempts to synchronize back-up on the UI thread after its done.
            // in this way our subscriber is hopping around between threads
            // and we lose the queue like nature of the event bus as a result
        }
    }

    public interface IEvent{}
    public static class EventA implements IEvent{}
    public static class EventB implements IEvent{}
}

```

_Our implementation of [`SyncingUtilities.runImmediately()`](https://gist.github.com/Groostav/4a9252d17700f7aabe0e21da10fb52a8)_

So, yeah, this is happening on our codebase with increasing frequency, and I'd like to see a fix. 
  Requiring Java 7 for now is not a big problem, but the build should detect it and fail immediately with a nice error message if run using Java 8.
 > Even if they are compiling from source, is it really major issue that Guava needs JDK 7 to compile? I guess it could be annoying if you're just trying to build Guava in your IDE to experiment with it and your only JDK is JDK 8.

FWIW compiling from sources is important to Linux distributions like Debian and Fedora. This issue is [tracked](https://bugs.debian.org/751544) by Debian as part of its transition to OpenJDK 8. Fedora is already building with Java 8 and applied a [patch](http://pkgs.fedoraproject.org/cgit/guava.git/tree/guava-java8.patch) to work around this issue.
       This was fixed a while back in this commit.  The bug was in the test
https://github.com/google/guava/commit/eb68100cc9a30cb7cca03dbe0eebad8d5e76b5b1
  Iterables and Iterator can be used when iterating over very large data sets that do not fit in memory so that can easily be more than int.
So I agree this would makes sense to use long here or even BigInteger here. 

Any comment from the guava team on this? 
  The original reason this was not done is because it added complexity, was intended for a performance vs functionality sprint, and requires coordination across segments. The smart batching was part of the original design and pushed into the backlog on the internal tracker.

As we wanted to eventually migrate to `ConcurrentHashMapV8`, performing smart batching would require to again fork the hash table which we didn't want to do again. So the JavaDoc was left open ended and an implementation note added to `LoadingCache#getAll()`. That way external implementations could implement it as they see fit and comply to the API.

The only way to add this feature in a decorator model is by a lock per entry or a lock striped array. Doing that with a j.u.c. `Lock` is heavy and other options are inefficient. Unfortunately using intrinsic object locking (aka `synchronized` - `monitorEnter` and `monitorExit`) can't be done efficiently. The language doesn't allow batch synchronized acquisition and release (w/o a recursive hack). The `Unsafe` methods are very slow due to the JVM not optimizing for unverified usages. So this has to be done at the internals of the hash table or very carefully optimized above it. That's a lot of work for a rarely requested optimization, given that the backing store is may be smart as well (e.g. some memcached clients perform request combining).

As Chris said, though, the AsyncLoadingCache can easily support this mode because the future is basically our lock object.
  +1 for this.  It's surprising to have stringConverter for every primitive except Booleans.  For symmetry's sake it makes sense there should be one for Booleans, and that it should have the same .toString() / parseX() implementation as the others.  I actually spent a while looking for it, because I was convinced that it must exist and I was just missing it.
 I agree Boolean is more special than Integer, but I think the same
arguments apply to Float, Double, and Enum.  Does Doubles.stringConverter
preserve all digits of precision?  Does it use scientific notation or lots
of zeros?  What does it do for null?  Same for Enums.stringConverter - is
it case-sensitive when reading?

You're right to shutdown my symmetry argument, bloated common libs are
creaky.

A better argument would be that all of these Primitives.stringConverters
are useful for cases where the user hasn't thought a ton about edge case
behavior - they're looking for functional defaults.  If a user cares about
edge-case behavior, they're going to make their own.  Booleans are very
common, it would be nice to have a functional default.

Ned Twigg
Lead Software Architect, DiffPlug LLC
949-264-3433
340 S Lemon Ave #3433, Walnut, CA 91789

On Wed, Nov 5, 2014 at 8:12 AM, kevinb9n notifications@github.com wrote:

> Most users will say "well, logically we figure it should use
> Boolean.valueOf()". But how many of these users could tell you off the top
> of their heads what Boolean.valueOf() does? What does it do for null?
> "FALSE"? "tRuE"?
> 
> That there is an expectation for it to call method X does not mean that
> people actually expect that behavior, and it also doesn't mean it's the
> safest behavior.
> 
> At this point I still stand by my previous points:
> 
>    1.
> 
>    Boolean is a special case compared to the others because there is much
>    greater variety of behaviors users might want, and much greater variety of
>    behaviors they might assume.
>    2.
> 
>    It's also special because it's easy to hand-roll the precise behavior
>    you want, which will leave your readers actually knowing what is going on
>    with no surprises.
>    3.
> 
>    If this converter does exist, the most conservative behavior is to
>    reject any input but "true" and "false". 95%+ of usages will probably be
>    just fine with that, and the rest, who see an exception, will be prompted
>    to decide what they want. No surprises can lurk undetected.
> 
> Btw, as reasons to add a library feature go, for us "symmetry" ranks
> pretty close to dead last. It's one of the things that's very different
> about Guava from many other libraries. Every feature has to pay for itself,
> not just seem like it is rounding out a complete set of something.
> 
> —
> Reply to this email directly or view it on GitHub
> https://github.com/google/guava/issues/1710#issuecomment-61832350.
  Is there any progress on exposing this API? I'd like to configure burst too and the underlying implementation seems to support bursting just fine, it's just not exposed.

Thanks!
 I am, too, interested in this.
 +1
 +1
 +1
 +1
 +1
 +1
 +1
 +1
 +1
 I seem that the solution is on SmoothRateLimiter.SmoothBursty.

I see that maxPermits = maxBurstSeconds \* permitsPerSecond;

However maxBurstSeconds is hardcode.

I try to extends RateLimiter and add another constructor with maxBurstSeconds parameter.

``` Java
public class RateLimiterWithCapacity extends RateLimiter {
    public static RateLimiter create(double permitsPerSecond, double maxBurstSeconds) {

        return create(SleepingStopwatch.createFromSystemTimer(), permitsPerSecond, maxBurstSeconds);
    }

    @VisibleForTesting
    static RateLimiter create(SleepingStopwatch stopwatch, double permitsPerSecond, double maxBurstSeconds) {
        RateLimiter rateLimiter = new SmoothRateLimiter.SmoothBursty(stopwatch, maxBurstSeconds /* maxBurstSeconds */);
        rateLimiter.setRate(permitsPerSecond);
        return rateLimiter;
    }
}
```

And work well. Can I pull this requests? or raise any risk problem.
 It seems that it really doesn't matter whether you pick the time-invariant option or the permit-invariant option. Either will expose the same useful capabilities.

Can you please just pick one and get it included with the public interface?

My preference is for the option with time-invariant semantics. Maybe with new/updated interfaces like the following:

| Modifier and Type | Method and Description |
| --- | --- |
| static RateLimiter | create(double permitsPerSecond) |
| | Creates a RateLimiter with the specified stable throughput, given as "permits per second" (commonly referred to as QPS, queries per second). This is equivalent to calling create(1, TimeUnit.SECONDS, permitsPerSecond).  |
| static RateLimiter | create(long permitPeriod, TimeUnit permitUnit, double permitsPerPeriod) |
| | Creates a RateLimiter with the specified stable throughput, given as "permits per period". When the rate limiter is unused, bursts of up to permitsPerPeriod permits will be allowed, with subsequent requests being smoothly limited at the stable rate of permitsPerPeriod. |
| static RateLimiter | create(double permitsPerSecond, long warmupPeriod, TimeUnit warmupUnit) |
| | Creates a RateLimiter with the specified stable throughput, given as "permits per second" (commonly referred to as QPS, queries per second), and a warmup period, during which the RateLimiter smoothly ramps up its rate, until it reaches its maximum rate at the end of the period (as long as there are enough requests to saturate it). This is equivalent to calling create(1, TimeUnit.SECONDS, permitsPerSecond, long warmupPeriod, TimeUnit warmupUnit) |
| static RateLimiter | create(long permitPeriod, TimeUnit permitUnit, double permitsPerPeriod, long warmupPeriod, TimeUnit warmupUnit) |
| | Creates a RateLimiter with the specified stable throughput, given as "permits per period", and a warmup period, during which the RateLimiter smoothly ramps up its rate, until it reaches its maximum rate at the end of the period (as long as there are enough requests to saturate it). |
| double | getRate() |
| | Returns the stable rate (as permits per period) with which this RateLimiter is configured. |
| void | setRate(double permitsPerPeriod) |
| | Updates the stable rate of this RateLimiter, that is, the permitsPerPeriod argument provided in the factory method that constructed the RateLimiter. |
| long | getPeriod() |
| | Returns the permitPeriod in nanoseconds with which this RateLimiter is configured. |


 +1     I could use a parse method to do the opposite of a custom Escaper. And I mean this in a generic way, not for parsing URL's or URI's as the author initially requested. 

I have some custom encoding of arrays in an i18n bundle (in a GWT application) and I want to unescape the texts between the split characters. (But again just a simple use case, their might already be alternative solutions)  Hi, I am interested in trying this. 
Has anyone started working on it? Do we agree to use 200 as the max value?
 Thank you for the detailed analysis and feedback. 
I took a closer look at the class and would have to agree with your assessment.
 Then the following could make sense (save a few bytes in case of a small limit)

```
private static final int MAX_PRESIZE_ARRAY_SIZE = 10;

if (!iterator.hasNext()) return Collections.emptyList();
List<String> result = new ArrayList<String>(Math.min(limit, MAX_PRESIZE_ARRAY_SIZE));
do {result.add(iterator.next());} while (iterator.hasNext());
```
   This is a feature that I'd really appreciate as well!
 +1 from me!

In the mean time, this might be a stopgap solution if you're looking to record Codahale metrics from a Guava cache:

http://antrix.net/posts/2014/codahale-metrics-guava-cache/
 The concern with allowing a custom StatsCounter is that foreign code is executed and the cache must guard against abuse.

Some stats incremented under the lock, others in the finally block when the lock is being released. An exception should not leave the cache (or its locks) in an invalid state. This leads to the question of how the cache should handle the counter failing: should the operation be rolled back or the exception caught and logged? If the counter is slow, such as making network calls, this would greatly expand the lock hold times.

I like the idea of allowing custom counters, but tolerating hostile foreign code requires a bit of thought. The easiest and probably most correct would be to have CacheBuilder decorate a custom counter to swallow and log all exceptions thrown.
  Ping? My offer to help still stands :-)
 It's a pity that this has not been done yet. 

In my OSGi project I depend on Guice 4.1, which needs Guava 19.0 and on an Apache library which depends on Guava 15.0. 

The Apache library imports Guava packages as [15.0, 16.0) which means it does not resolve in the OSGi runtime with version 19.0, so I cannot simply use maven dependency management to force version 19.0. I worked around the problem by publishing Guava 15 to my artifact repository using  a different group-id.

Any chance the Guava team can look into this for future releases?   +1
    +1
   I am also interested in this. Would it make sense to start implementing this on my side (and open a pull request) or would this duplicate existing progress?
  Regarding "Just offer a TypeToken parser", that's too limited a solution. The functionality provided by `Types.newParameterizedType()` is generally useful.

For example, I came across another use case whereby I needed a method that would "wildcardify" any raw type. For example, for some class `Foo` with 3 generic type parameters, this would return `TypeToken<Foo<?, ?, ?>>`. Of course in general it would work with any `Class<?>` parameter.

The easiest (only?) way to do this was to call `Types.newParameterizedType(rawtype, array)` where `array` is an array of unbounded `? WildcardType` objects constructed manually.
 Yep, that's right... didn't think of that.. though that's a little messier, especially when the number of generic type parameters can vary.

FWIW here's what I'm currently doing...

``` java
    private static final WildcardType QUESTION_MARK = new WildcardType() {

        @Override
        public Type[] getUpperBounds() {
            return new Type[] { Object.class };
        }

        @Override
        public Type[] getLowerBounds() {
            return new Type[0];
        }

        @Override
        public String toString() {
            return "?";
        }
    };

    ...

    /**
     * Parameterize the raw type with wildcards.
     */
    public static <T> TypeToken<? extends T> getWildcardedType(Class<T> type) {
        if (type == null)
            throw new IllegalArgumentException("null type");
        final TypeVariable<Class<T>>[] typeVariables = type.getTypeParameters();
        if (typeVariables.length == 0)
            return TypeToken.of(type);
        final WildcardType[] questionMarks = new WildcardType[typeVariables.length];
        Arrays.fill(questionMarks, QUESTION_MARK);
        return Util.newParameterizedType(type, questionMarks);
    }

```

However I still would rather see the more general functionality exposed. There are sure to be other use cases that could benefit besides the ones I've come across.
 Yes I agree my current solution is a hack... right now there's no other (easy) way to do it. This is of course more evidence that there are functionality holes remaining to be filled. Thanks.
 My current use case requiring `WildcardType` is that I'm trying to build a list of all supertypes of a type.

As described above, for reasons I don't fully understand `TypeToken.getTypes()` doesn't include the "wildcarded" type (e.g., `TypeToken.of(List.class)` does not include `List<?>`).

So as a workaround, I'm adding the "wildcarded" type to the list manually.

In any case, the whole wildcard thing is a digression. The larger issues is that it seems like there should be a programmatic way to take a raw `Class` object and build an instance of the corresponding generic type with arbitrary type parameters. The fact that there's no way to do this seems like a weird hole in the functionality. The two options discussed, (a) using Guice, or (b) building and then parsing a `String` that would use some new parsing method are acceptable I guess, but it seems like it would be a whole lot simpler to just make `public` a method that is already written and sitting there :)

As a side note, a parsing method would be nice to have for it's own reasons. E.g. it would make it easy to serialize a `TypeToken` in an XML document.
 > By getTypes() not including wildcard types, do you mean this?

I mean the output of:

``` java
import com.google.common.reflect.TypeToken;
public class xx {
    public static void main(String[] args) throws Exception {
        System.out.println(TypeToken.of(java.util.List.class).getTypes());
    }
}
```

is

```
[java.util.List, java.util.Collection<E>, java.lang.Iterable<E>]
```

which does not include `java.util.List<?>`.

Thinking about this more I realize now that `java.util.List` a not sub-type of `java.util.List<?>` - it's the other way around. So that behavior is correct. Earlier I thought `getTypes()` might be an easy way to "wildcard" a type (e.g., generate `TypeToken<List<?>>` from `List.class`) but that is not the case.

Here's a little more background: the code I'm working with is attempting to track types using `TypeToken`, which works great. In order to maintain type safety, it is also trying to follow a "no raw types" rule that states there should never be any raw types - all tracked types are genericized. But another requirement is that it allows a user to specify a type at runtime by providing a `Class` object. When that occurs, in order to follow the rule, that type needs to be converted into its genericized equivalent in a type-safe manner. This is when the "wildcarding" operation is needed.
 Just wanted to add that a `TypeToken parse(String)` method would be useful to me. [Joda-Convert](http://www.joda.org/joda-convert/) provides a standard way to convert an object to and from a string (for JSON/XML etc). Being able to do this with `TypeToken` is desirable (as it can already handle `Class`).

I also happen to think that the API should also provide a public `newParamterizedType()` is some form. For example, I'd like to be able to store in a database the TypeToken `Foo<Bar>`, but using two columns, one for `Foo.class` and one for `Bar.class`. While putting it together again using a `parse()` method would work, a `newParamterizedType()` would be more obvious. And yes, I understand the risks of creating stupid types.
 Just wanted to add that public `newParamterizedType()` is what I need too. It seems all reasons where already given and the proposed `parse` method sounds just cool. However, manually constructing `"List" + "<" + "String" + ">"` just to get it parsed sounds awkward. 

If the `Types.newParamterizedType()` in Guava is not as public-ready as the one already public in Guice, why don't you copy/move that one into Guava? It's seems that the Guava is THE library for all Java shortcomings, not Guice.

Alternatives to throwing in Guice into the projects are using Apache `TypeUtils` or Spring 4 `ResolvableType`. Either way, it just doesn't seem right when using `TypeToken` API to have to go to another library (Guive, Commons Lang or Spring) just to construct equivalent of `TypeToken<List<String>>` where "List" and "String" are given at run-time.
 PING.

2.5+ years and still waiting for `Types.newParamterizedType()` to be made public... can we get some resolution to this?

To summarize: **there are legitimate situations where we need to convert a raw class (represented by a `Class` object) back into its generic type (represented by a `TypeToken` object) using caller-supplied type parameters (represented by `Type` objects).**

This is exactly what `Types.newParamterizedType()` does.

It's there. It's useful. _Let's do this!!_

  any update on this? I'm able to compile guava-tests but still no clue how to run benchmarks..  +1 to this issue. It's completely backwards compatible to add the feature, it should be trivial to implement, and even without static analysis tools, it can be useful for documentation purposes.

I have an abstract base class in my codebase which has a method that should be protected, but we have tests that want to access it. Essentially I want to mark it

```
@VisibleForTesting(visibility = Visibility.PROTECTED)
public final void doSomething() { ... }
```

but right now, I can't. Instead, I've left a comment:

```
// This method should only be called by tests and subclasses
@VisibleForTesting
public final void doSomething() { ... }
```

but that feels more easily ignored, plus I can't ever expect static analysis tools to help me detect it if those come online later.

I suspect there may be pushback, like: You should instead be writing your tests differently so they interact with a test subclass that exposes this method publicly, or something. Of course, it's doable, but because of much of the existing code, it wouldn't be trivial - it would involve punching holes in a bunch of nested classes.

So, instead, we are resorting to using VisibleForTesting anyway, just without the extra documentation information that would definitely be a nice to have. Some projects have gotten around this by adding the [Android Annotations library](https://developer.android.com/reference/android/support/annotation/VisibleForTesting.html), but it seems like a waste to do that just for this one feature. Is there any progress on it ? The "simple" version is already in findbugs. How about the @VisibleForTesting extension (including Findbugs detector)?  A racy counter was used in the predecessor cache, CLHM, and the optimization lost when rewriting into Guava. A smarter trick is used in the Caffeine rewrite by draining once the ring buffer is full and being lossy if the buffer cannot be appended to. That appears to resolve the performance issue, due to also not being tied to a segment so the buffer is striped dynamically. If the buffer isn't needed for that configuration a disabled instance is used instead, so no penalty is incurred. 
     Well it looks like my comment on 2/15/2015 about this no longer being an issue was incorrect :(

liberal use of Futures.withTimeout triggers some pretty rough behavior relative to this since it internally cancels the timer future in the common case (no timeout), and even in the timeout case the cancellation cause is not particularly useful.

So a 'harmless' refactoring of a ScheduledExecutorService to a ListeningScheduledExecutorService will greatly increase the cost of Futures.withTimeout due to this line
https://github.com/google/guava/blob/master/guava/src/com/google/common/util/concurrent/Futures.java#L937

Cancelling the timer futures is a bit of an optimization itself since for a ScheduledThreadPoolExecutor with the removeOnCancel policy set it is likely to save memory in the common case.  So it would be unfortunate to remove that call to 'timer.cancel()' since it may increase memory pressure.

Various ideas
1. just remove the cancellation cause mechanism (other futures don't have it :/)
2. allow global static configuration so servers can set it in canary/test environments or maybe temporariliy to help debugging (maybe use a System property?)
3. All threadlocal static configuration so individual 'cancel()' callers can disable the behavior.

3 would be sufficient to solve the for Futures.withTimeout
 I was mostly thinking that the threadlocal would solve the ForwardingFuture case. (and i agree that it isn't a great solution anyway)

Of course the ideal solution would be to add an overload of cancel to ListenableFuture

`boolean cancel(boolean interrupt, @Nullable Throwable cause)`

and then we could (with some work) make it always do the right thing.  With java8 default methods we could even add it in a (mostly) backwards compatible way.

When propagating cancellation exceptions (e.g. during a transform) we can just chain or propagate the causes.   I think this would solve all known issues with the current cancellation api.  in a guava java8 world would this be doable?  ( I assume yes since we have made other similar changes to abstract classes).
 Re: ForwardingFuture  would we always have ForwardingFuture implement CancelableWithCause or maybe that would just be up to the user.  If it was opt-in i think that would solve your concerns ( ForwardingCancelableWithCauseListenableFuture.?.. ugh)  for usability we would really want a single interface type to pass around (ala RunnableFuture) so users/libraries could avoid a bunch of instanceof casts, but that is also annoying :/

Re: Android I don't really remember why i cc'd those guys  probably some long lost in person conversation.  I'll reach out to them and see if they want to comment.

I'll play around with the CancelableWithCause approach, see what it looks like.  
 I just had a chat with one of these android 'people' (eric said he would comment, but is too lazy to get a github account) and they are interested in this because they are increasingly relying on futures and even cancellation in certain cases to save network requests.   Plus, everything is more expensive on android, im sure exceptions are especially more expensive.
  You should totally update the Caches Explained wiki to mention this API! :100: 
 Any examples on how to use asyncReloading? 

I'm using CacheBuilder with Spring cache. 
Presumably it's automagically creating a default LoadingCache somewhere along the way to the @Cacheable but it'd be nice to configure a cache that does async reloading without having to override CacheLoader.reload()   For unit testing a method that takes a {Char,Byte}{Source,Sink}, what is the recommended way to do so without writing to disk?

Do teams write their own one-off implementations or is there an internal Google impl that isn't pushed publically?
 Any progress on this topic?
    I have accepted the CLA and will work on a patch.
 I worked on it but it never went into a pull request :(
   The first two suggestions, repeated below, could be done to help support Java 8 users without needing "a Java 8 version of Guava" (or at least what I choose to interpret from that statement, anyway) - is there a philosophical (or otherwise) objection to folding that in?
- Make the Builder itself Iterable, so that it can be added to its own addAll-Method.
- Add another addAll-Method overload to ImmutableCollection.Builder which accepts any ImmutableCollection.Builder.
 I was wondering, why is `stream.collect(Collectors.collectingAndThen(Collectors.toList(), ImmutableList::copyOf))` the same efficiency as `ImmutableList.copyOf(stream.iterator())`?

It sounds like the first approach requires building an array, then copying the array into an `ImmutableList` whereas the second approach only builds the array once.
 I see, thanks for the help =)
 I don't think that's 100% true. ImmutableList.copyOf(stream.iterator()) is [more efficient](https://github.com/google/guava/blob/master/guava/src/com/google/common/collect/ImmutableList.java#L249-L255) for the special case of an iterator yielding only 0 or 1 elements, where it avoids allocating the intermediary ArrayList.
 +1
 Would love to see this added into the core guava codebase.  Any traction on this yet?  Should TreeMultimap.create(TreeMultimap) be a new method in API?
If yes, what is expected behavior?
Like in TreeMultimap.create(Multimap)
-> natural order 
or like in java TreeMap(SortedMap)
-> order from other Treemultimap ?

IMO TreeMultimap.create(TreeMultimap) should be a new method with specification like in java TreeMap - new TreeMultimap with ordering from other TreeMultimap.
 Pull request:
https://github.com/google/guava/pull/2498
     I saw this issue when comparing my tests with Guava's and wondering at first why Guava's even passed. Modifying my test to mimic Guava's causes it to run forever.

The problem is that the test creates eden-space strong-reference garbage. This will be collected by a minor collection, whereas soft references requires a major collection. The correct way to do this is to classify the generated garbage as soft references in order to force a major gc. As the eviction is performed in LRU order, it should keep creating garbage until a flag reference was cleared, meaning that the cache's contents must have been evicted too.

It also appears to have a questionable usage of `drainReferenceQueues()`. It reads as if the author assumed that it would fully drain the reference queues, whereas in fact that is not a guarantee. Because the cleanup is amortized across caller threads, each type of cleanup has a threshold on how many entries it will discard. This is so if a large cache suddenly has a high number of discardable entries, an excessive penalty will not be thrusted upon one caller. Instead it is spread out on many calls if need be. This is important as no one wants a user-facing request to suddenly halt for seconds due to cache cleanup.

The following test passes with both [Caffeine](https://github.com/ben-manes/caffeine) and Guava caches.

``` java
  @Test(dataProvider = "caches")
  @CacheSpec(values = ReferenceType.SOFT, population = Population.FULL)
  public void evict_softValues(Cache<Integer, Integer> cache, CacheContext context) {
    context.original().clear();
    awaitSoftRefGc();
    cleanUp(cache, context, 0);
    assertThat(cache.size(), is(0L));
  }

  static void cleanUp(Cache<Integer, Integer> cache, CacheContext context, long finalSize) {
    // As clean-up is amortized, pretend that the increment count may be as low as per entry
    for (int i = 0; i < context.population().size(); i++) {
      cache.cleanUp();
      if (cache.size() == finalSize) {
        return; // passed
      }
    }
    Assert.fail("Expected an empty cache but has size: " + cache.size());
  }

  static void awaitSoftRefGc() {
    byte[] garbage = new byte[1024];
    SoftReference<Object> flag = new SoftReference<>(new Object());
    List<Object> softRefs = new ArrayList<>();
    while (flag.get() != null) {
      garbage = new byte[Math.max(garbage.length, garbage.length << 2)];
      softRefs.add(new SoftReference<>(garbage));
    }
  }
```
 FYI, soft reference tests must be run sequentially and cannot use the G1 garbage collector. The first not surprising and is to avoid breaking tests that run in parallel due to out of memory errors. The second is because G1 does not provide a deterministic LRU eviction (cross region) which is much more efficient than a stop-the-world major collection, but breaks a simple detection scheme like the one above.
 The best way to do this is to use `-XX:SoftRefLRUPolicyMSPerMB=0` to force soft references to behave as weak references, thereby allowing the test to safely assume a GC will clear the reference. This means running the test through the build can be reliable, but a note on the unit test has to be added for anyone running the test through their IDE.
  Hi,
I see no defect here. I checked and only Integer.parseInt(String s), or Long.parseLong(String s) can parse characters like DEVANAGARI_DIGIT_ONE. These methods can also parse a combination of several mixed non-ascii numbers.

None of the guava methods, like Ints.tryParse nor Longs.tryParse cannot parse any non-ascii characters. There is no inconsistency here either, since Ints.tryParse in the end calls Longs.tryParse.

So as far as I can tell, not a bug.  ImmutableTable was made serializable in 5562218b96f0b262deb5c0d2288c1bcc339dbbb2.
    As mentioned above, ContiguousSet.range() only works on bounded Ranges, however.  If either end is unbounded, this isn't sufficient.
 Right, just like the existing behavior in `Range.canonical()`, unbounded endpoints should be left alone.
  @cpovirk Are you planning to pursue this? Yes, that's why I'm interested :)

I think I can either move or delete all JDK emulation under Guava except this one though  it is not critical.  I think a sufficient and detailed explanation has been provided on the SO link for the same. 
http://stackoverflow.com/q/19074393/28465

As per Javadoc.
"Determines whether a character is a breaking whitespace (that is, a whitespace which can be interpreted as a break between words for formatting purposes)."

     A filter construction described in a 2014 paper [1] allows for removal. The Cuckoo Filter is an alternative to a Bloom Filter that leverages partial key cuckoo hashing and a fingerprint/bucket structure.

@beala and I have proposed the addition of a Cuckoo Filter to Guava in #2226. We have a working implementation that we could adapt to the Guava style fairly if there's interest.

[1] [Cuckoo Filter: Practically Better Than Bloom](https://www.cs.cmu.edu/~dga/papers/cuckoo-conext2014.pdf) Bin Fan, David G. Andersen, Michael Kaminsky, Michael D. Mitzenmacher

/cc @apc999
  I think we can make CharMatcher.retainFrom() not require a negated matcher. This would eliminate the need for allocating a new CharMatcher each time it's called.

If the above is okay, please assign this issue to me.
  +1
      Please close this as the easiest solution would be to port the implementation from [Caffeine](https://github.com/ben-manes/caffeine), which doesn't appear to be worth the effort.
    I'm still finding this issue in v18, Android platform. I only detected this because there was a NumberFormatException while trying to parse it to Long.

Code I'm using

```
static long readFileAsLong(String path) {
    String s = "0";
    try {
        s = Files.toString(new File(path), Charsets.UTF_8);
        Log.i(TAG, path + ": " + s);
    } catch (IOException e) {
        Log.e(TAG, "Failed to read file" + path);
    }
    long l = 0;
    try {
        l = Long.parseLong(s);
    } catch (NumberFormatException e) {
        e.printStackTrace();
    }
    return l;
}
```

Had to trim the string to get the code working.
 Hi @royale1223 
tried to reproduce the issue with the file
[test.txt](https://github.com/google/guava/files/617702/test.txt)
and code

        String s = "0";
        try {
            s = Files.toString(new File("../test.txt"), Charset.forName("UTF-8"));
        } catch (IOException e) {
        }
        long l = 0;
        try {
            l = Long.parseLong(s);
            System.out.println(l+1);
        } catch (NumberFormatException e) {
            e.printStackTrace();
        }

yet no parsing error and I get the proper result.. could you please provide the file you are using?

EDIT:
I also went through unit tests and com.google.common.io FilesTest.testToString() is a good enough test that should prove there is no defect and the method behaves correctly.    Is this functionality is there already? How you guys are achieving it. I'm making few unnecessary calls which is not necessary since I can reload the entire config data into the cache.   +1

I'm currently implementing my own interface on a lot of my classes in a very similar manner:

```
public interface Funnelable {
    void funnel(PrimitiveSink into);
}
```
  I would very much appreciate this facility being exposed. I have need of large, reproducible hashes. I currently maintain a nearly identical class to accomplish this.
 I don't have a strong opinion on that, though I agree that "concatenatedHashFunction" is a little long winded. What about simply "concatenate", or possibly "concatenatedHash", which would be in line with "goodFastHash".
  I was looking for this today and was quite surprised it isn't present. Using or() after transform() is sufficient, but it would be a nice addition to the standard.
 I'm actually wondering why this hasn't been fixed already given that Java 8 is out.

According to the [mailing list](https://groups.google.com/forum/#!msg/guava-discuss/dvz6EbPSat4/G6NkN8IY3KQJ) the issue was Java didn't have lambdas and thus it was awkward.

With RxJava and various other monadic style libraries I have gotten used to "staying in the monad". It is such a trivial change. I hope it gets in soon.
 Would you accept a PR implementing this? I would consider this "fixed" now that `com.google.common.base.Optional.toJavaUtil().flatMap(...)` exists... We need it on Android. Our minSdkVersion is 16 so we can't use java.util.Optional yet and won't be able to for several years. @zergtmn On a sort of side note, if all else fails, then there at least exists Atlassian Fugue 2.x, which is Java 1.6 compatible and provides an `Option` type which works a bit differently to Java 8's or Guava's `Optional`, but otherwise has higher order functions like `flapMap`. On a tangental note I didn't know `toJavaUtil` was added.  I am curious how  v22 is going to backport to JDK6 with the JDK8 reference. 

Are there going to be two jars? 

That is going to be interesting dealing with dependency management of that. If possible maybe make a new namespace or something? Maybe com.google.common8 or something. This is probably discussed on the mailing list but my embarrassingly lazy googling did not find anything. 

*EDIT* Ah I see how as it was done with JDK5. Artifact rename and then I guess if you depend on some other project you just exclude the JDK6 dependency (or do provided in maven parlance).   Mmhhh, as already mentioned by [sameb](https://github.com/google/guava/issues/1444#issuecomment-61352265) when most people read _subtypeOf_ they assume a real subtype like Integer -> Number or Closeable -> AutoCloseable and _NOT_ Number -> Number. I would suggest renaming to _assignableTo_ as it was already proposed.
This eliminates the question sub-class vs. subtype and if there is a predicate for `subtypeOf` why isn't there a `supertypeOf` predicate?
    Why not remove just the @Singleton annotation, which causes the problem, and leaves the @Inject? At least Guice users will have to only set the scope to this class if they need that.
 @brunojcm  That would probably have been more dangerous since then contains like Guice would create a new ServiceManager for each injection point and then some of them will fail because you can't construct a ServiceManager with started services.

in any case the annotations were removed and adding custom bindings for ServiceManager et.al. in your container should be straightforward
  There's currently a TODO in `SubscriberRegistry.getAnnotatedMethodsNotCached()` to error out in case of a generic parameter. Maybe that should be extended to include parameterized types.
    Well, for half a second I indeed got my hopes up ;-)

While I agree on the general idea of using a `Map` in a single element cache, I fear that this scenario will always lead to the developer using a wrapper to avoid that other developers store the map somewhere.
 Alternatively, using the forwarding decorator that delegates `get` to `getAll` would provide this customization. 
   Is there a plan on implementing this? I think changing FluentIterable to do the Collection optimization is a safe and worthwhile change, and does not need to be held up by discussions about further reorganizations.

Would a pull request be useful to get this forward? I am not sure because it's such a small change but I could probably create one if wanted.
  "Should" and "are" are two different things.`ImmutableSorted*.orderedBy` does **not** and will not accept `Ordering<? super T>`, as discussed in #1030. As a result, in order to create a builder for an `ImmutableSortedSet`sorted by `toString`, you have to use this monstrosity:

`ImmutableSortedSet.orderedBy((Ordering<MyType>)(Ordering<?>)Ordering.usingToString())`
 Ah... I missed that part, probably because it was buried in the middle of a long comment with no code formatting. It's still not as pretty as just being able to use `ImmutableSortedSet.orderedBy`, but I guess it will have to do.
   Also there are the Object.wait methods. I am guessing they are also used quite frequently.
 is there a reason that poll or offer has not been added? do they introduce something that will make people program incorrectly? such as https://github.com/google/guava/issues/1118 ?
  I can make a PR, would this be something that will be added?
  I'm curious if there are plans to push this out as we've written our own.
  FYI you don't need a helper method to one-line this pattern (as long as you trust `initCause()` to return `this`), e.g.:

```
throw (NumberFormatException)new NumberFormatException("Failed to parse '" + number + "'").initCause(e);
```
    It seems there is a significant demand for this, see e.g. most currently http://stackoverflow.com/questions/29747912/, but also the older, but massively popular http://stackoverflow.com/questions/513600/ and http://stackoverflow.com/questions/12786902/.

The standard answer is to use `String.format()`/`MessageFormat` if you care about readability and flexibility, then to use a `StringBuilder` if you need performance.
In the 90% of cases, this is good enough.
In the rest, under the assumption we don't need the flexibility of `String.format()`, a simple concatenation/`StringBuilder` can be hideous.

As of now (2015/05) and to my best knowledge, the current best is slf4j `MessageFormatter`, but its API could definitely be improved.
If the `Strings.format()` method were published, it would immediatelly be the nicest and clearest option out there.
  > It's longer than...
>
> `check(expression, MyCustomRuntimeException::new);`
>
> ...but at least some of the value of the proposed method would be the ability to provide a message,  which you can't normally get with a method reference.

What about

    check(expression, MyCustomRuntimeException::new, message)

and

    check(expression, MyCustomRuntimeException::new, format, args...)

The method reference can be used as a `Function<String, RuntimeException>` and that's AFAIK all you need. It assumes a single string argument constructor and you providing the formatting in the second case.
 +1 for point 2. We have a utility class like that in our code base:

```java
public final class Exceptions {
    ...

    /**  
     * Returns a {@link Supplier} of {@link IllegalArgumentException}s.
     *    
     * <p>This method is especially useful in combination with {@link
     * java.util.Optional#orElseThrow(Supplier)}.
     *    
     * @param format The exception message's {@link String#format format string}.
     * @param args Any values to be plugged into the format string.
     * @return A non-{@code null} {@link Supplier}.
     */   
    @FormatMethod
    public static Supplier<IllegalArgumentException> illegalArgument(
            final String format, final Object... args) {
        return () -> new IllegalArgumentException(String.format(Locale.ROOT, format, args));
    }    

    ...
}
```     e.g. http://stackoverflow.com/questions/30877790/guava-splitter-for-splitting-on-space-special-character-digit and/or any other splittings where a lookahead/lookbehind is needed otherwise
   +1 for adding `isEmpty()`; I just ran into a case where I could have used it.
  2015 update: Apache jclouds uses `RandomByteSource` for all its test inputs.  This is really what I was going after with this feature request:

https://github.com/jclouds/jclouds/blob/master/core/src/test/java/org/jclouds/utils/TestUtils.java#L39
  I actually don't mind the way this is done with the means of the JDK:

``` java
new FilterInputStream(stream) {
    @Override
    public void close() {
        // explain yourself here
    }
};
```
  It seems it is done in Guava 20.0 - based on http://google.github.io/guava/releases/20.0/api/docs/com/google/common/base/Throwables.html#propagate-java.lang.Throwable-
  I second this thought of adding a removeCallback method.  In my project, we too have a situation, where a large background task is being done on background.  UI uses a callback to track the updates on the future.  But if the activity is paused or destroyed,  the UI has no need for the callback.  But since callback cannot be removed,  it triggers when the UI is not visible, there by causing problems and occasionally crashes.      I have this [implemented](https://github.com/ben-manes/caffeine) and would appreciate API design feedback.

There are more reasons why this is preferred than was previously listed. An immediate one is how a weighted cache would handle an empty future. The obvious answer is to give the weight 0 (never LRU evict) and update it when the future materializes. That handling is more than one should expect in client code, and there are many other small quirks that become similarly problematic.

My implementation uses `CompletableFuture` and defaults to `ForkJoinPool.commonPool()`. The `AsyncLoadingCache` provides a `synchronous()` view of a `LoadingCache<K, V>` that handles all of the operations down to the `asMap()` view by either filtering incomplete/failed futures or blocking until the future completes for a synchronous write (like `put` vs `computeIfAbsent` would). The stats, removal on failure, etc. is handled by chaining completion handlers onto the future.

A nice benefit is that bulk load is much smarter because we have a direct future to play with. The synchronous caches perform non-blocking bulk loads and clobber anything that appears since. Instead we can insert futures that proxy to the bulk computation, so the load only happens once. This is something we wanted to do in Guava, but never got to.

Like you said, weak and soft values are not supported. The future is not counted towards size- or time-based eviction until it completes successfully, at which point its considered a fresh entry.

In the future it may be useful to allow the user to decide if failures should be removed automatically. The reason is because user-based negative caching breaks the load/failure statistic as the return value would have to be an Optional<V> so the
cache always sees a success. However that flag is messy because the synchronous view would still hide the failed results, so it feels hacky. What is intuitive, useful, and correct is open for discussion..

Any feedback on the API and design decisions would be great!
 I added an `AsyncCacheLoader` to [compliment](http://static.javadoc.io/com.github.ben-manes.caffeine/caffeine/2.2.0/com/github/benmanes/caffeine/cache/Caffeine.html#buildAsync-com.github.benmanes.caffeine.cache.AsyncCacheLoader-) `CacheLoader` when building an `AsyncLoadingCache`. This provides a more convenient hook for defining an async computation, e.g. returning the future produced by another library. This came out pretty clean by extracting the default async adapter methods from `CacheLoader`, so that `CacheLoader` extends `AsyncCacheLoader`. The lambda builder method `(key, executor) -> future` is a nice compliment while not losing the convenient `key -> value` version.
   I have a use case as well. I want to define custom annotations to be used in conjunction with @Subscribe, which allow to define IF the event will be passed to the handler method or not (i.e. filters). Package-private methods are really harmful in my humble opinion. Why not make them protected? Or, at least provide some hooks for the event dispatching.
     I would be willing to do the work to split up Guava, provided that it would be accepted. We have a small library that could use `com.google.common.base.Utf8`, which depends only on annotations and preconditions.

We prefer to minimize the dependencies of our library. Right now, we're resorting to copying in the Utf8 method implementations in order to avoid pulling in all of Guava, but I would really prefer to depend on a subset of Guava, instead.

Perhaps a more modularized Guava would be appropriate for version 20?
 We had to remove Guava from the dependencies because in old Android phones (Froyo) the dex merger doesn't work ;(

It is probably an edge case nowadays but it's still a case where having separate modules would have probably helped. 
    I would also like this. Let's add votes to this as more people want it.   So, is it fixed? I.e., do we have common joiners defined by framework?
 Perhaps something like Joiners.onSpace() ... will be useful.
   Here's okio's bytestring class: https://square.github.io/okio/1.x/okio/okio/ByteString.html
 Re: Justin's concern, with the existence of protobuf-java-util depending on both Guava and Protobuf, I don't think the two versions would be a big concern. (There can be a util for conversion between ByteString types, and Guava's ByteString can be an abstract class like Protobuf's, allowing wrapper implementations in either direction.)

Re: andreas' comment, agreed too that the JDK should have a concept of an immutable byte view, but I think third-party prototyping and resulting widespread adoption can be a good way to motivate and guide JDK development (see Joda date types, Guava Optionals and functional utils, etc., FluentIterable patterns now incorporated in Stream, etc.).

Out of curiosity, what's the process (if any) for this kind of work?
     This related issue (#1562) is still open  but it's quite old
 ImmutableTable was made serializable in 5562218b96f0b262deb5c0d2288c1bcc339dbbb2.
   Does anyone know what the state of this is? This seems very useful and I'd be interested in taking a stab at it if no-one is. I imagine it would be something similar to getAllAddresses in Apache Commons SubnetUtils: http://svn.apache.org/viewvc/commons/proper/net/trunk/src/main/java/org/apache/commons/net/util/SubnetUtils.java?view=markup
 :+1:       +1 and went with `net.jodah:expiringmap` for now
 +1 aswell. Custom expire time pr entry would be nice
 +1
 +1
 +1
 +1 Indeed, custom expire time pr entry would be nice.
 I think providing this feature in O(1) time with a clean API that does not detract from the existing one is a potentially difficult problem. In almost every algorithmic design I can think of, the approach could be served equally well by an external library decorating the cache.

The simplest O(1) approach is to rely on the `maximum size` constraint. For large caches (like memcached) they augment this with a sweeper thread to proactively discard expired entries. The more general approach requires an O(lg n) algorithm to retain a sorted order. As we've tried to avoid managing our own threads, only use O(1) algorithms, and not be excessively opinionated in how to use the cache this is a little difficult to resolve.

The first step is arguments for why variable expiration is useful in a general library. Most cases we came across then and now use a fixed time for domain-oriented caches. The variable were for specific applications, e.g. http caching, where different data commingles into a single, large cache. Justifying this feature as a common case is needed before considering the implementation details.

The second step is whether the algorithm benefits from the internal mechanisms used by the cache (periodic maintenance). If not, e.g. the lazy O(1) approach, then the feature can easily be contributed as a decorating library. That then side steps the next problem of how to evolve the API cleanly.
 I should amend the above since @lowasser referenced this ticket on SO and, as hinted to in my '14 comment, the approach I keep asking myself about is a hierarchical / hashed [wheel timer](https://pdfs.semanticscholar.org/0a14/2c84aeccc16b22c758cb57063fe227e83277.pdf). This is the scheme used by kernel timers by using hierarchical clocks where a hand points to a bucket and an entry is marked with the number of rotations before expiring. This "approximated timer" scheme works because expiration is best effort and not exact. The hierarchical version is O(m) / O(1) time (where m is small) and would fit well into the cache's periodic maintenance.

This is the only approach I could see making it into the cache as a native feature. Unfortunately I still don't see a nice way to evolve the API (Cache and CacheLoader) to feel natural.
 Could we perhaps create a new interface and not evolve the existing API?  It would be a special type of cache.
 > Unfortunately I still don't see a nice way to evolve the API (Cache and CacheLoader) to feel natural.

Wouldn't something similar to `Weigher` do? Maybe

```
interface Expirer {
    long expireAt(K key, V value, long lastWritten, long lastAccessed);
)
```

maybe with methods determining if it's to be called after write and/or access.
 For comparison, jsr107 (JCache) has a version of this called [ExpiryPolicy](http://static.javadoc.io/javax.cache/cache-api/1.0.0/javax/cache/expiry/ExpiryPolicy.html?is-external=true). It uses `null`, a sentinel value (zero), and exceptions as alternative return values to the duration. It does not provide the context (key, value, metadata) due to not wanting to fetch that information if the entry is not in local memory.

I think variable access expiration could be problematic, depending on the implementation details. It may also be the less useful variant and might not be worth supporting. So I might argue that this would be a `expireAfterWrite` with a function similar to your proposal.
 I am starting to work on this and feedback would be appreciated.

The goal of the `Expiry` interface is simplicity and to avoid object allocations. We could make it return either a duration or point-in-time, which would be in nanoseconds.

```java
interface Expiry<K, V> {
  long expireAfterCreate(K key, V value, long currentTimeNanos);
  long expireAfterUpdate(K key, V value, long currentTimeNanos, long expirationTimeNanos);
  long expireAfterRead(K key, V value, long currentTimeNanos, long expirationTimeNanos);
}
```

The duration approach would have the following characteristics:
 - The duration may not be zero or negative, meaning that it has be re-evaluated to be expired (as it would interact poorly with loaders).
- An entry can be made eternal by returning `Long.MAX_VALUE`
- To avoid updating the expiration time on a read or update, you can return 
`expirationTimeNanos - currentTimeNanos`.

The point-in-time would behave instead as,
 - The new expiration time may not be less than the current time, meaning the entry has already expired.
- An entry can be made eternal by returning `currentTimeNanos + Long.MAX_VALUE` 
- To avoid updating the expiration time on a read or update, you can return `expirationTimeNanos`

Suggestions on preferences, a better name than `Expiry`, etc. would be appreciated.

---

Implementation-wise, this will be done using a hierarchical timer wheel ([prototype](https://github.com/ben-manes/caffeine/blob/master/caffeine/src/main/java/com/github/benmanes/caffeine/cache/TimerWheel.java)). This allows add, remove, rescheduling, and expiring to be performed in O(1) time. Instead of using a O(lg n) priority queue, it uses a hierarchy of ring buffers, where each slot represents a time span (second, minute, hour). As the wheels rotate, the entries in the buckets are expired or rescheduled. This cascading effect amortizes the penalty and all operations are run during the cache's maintenance operation.

![timer wheel](https://cloud.githubusercontent.com/assets/378614/24584125/5f57609a-1717-11e7-9252-d0a83a8bc399.jpg)
 > An entry can be made eternal by returning `currentTimeNanos + Long.MAX_VALUE`

Note that the sum is negative, lone `Long.MAX_VALUE` should do. You can consider any time above e.g., `Long.MAX_VALUE / 2` as "never" (as there's no practical difference between allowing expiration duration up to 146 or 292 years).

I guess, after an operation (create, update, or read), the corresponding method gets called. I wonder how their results compose. Does the last returned result win? Technically no, but practically yes. `Ticker` uses `System.nanoTime()` which states,
> The value returned represents nanoseconds since some fixed but arbitrary <i>origin</i> time (perhaps in the future, so values may be negative).... The values returned by this method become meaningful only when the difference between two such values... is computed.

I am also leaning towards a duration API since that is consistent with the builder, e.g. `expireAfterWrite`.

And you're right, the last value wins. Otherwise we'd want an exclusive lock on the entry for reads to ensure atomicity. `expireAfterRead` (like access) has limited value as it is not about data freshness but lifetime (e.g. a session token). @ben-manes You're right, I forgot about how `System.nanoTime()` works.

The duration API could possibly be simpler:
```
interface Expiry<K, V> {
  long expireAfterCreate(K key, V value);
  long expireAfterUpdate(K key, V value, long currentDuration);
  long expireAfterRead(K key, V value, long currentDuration);
}
```
as you usually don't care about the current time. This is questionable and `currentDuration` probably needs to be computed. That's a good point on the API. My concern is that the duration may be a delta from a timestamp of an external resource. For example, basing it from a database row's `creation_date` with a 1hr TTL before a hard refresh is required. An example is a Google Maps geocode cache, which can only be held for 30 days by the license.

In these cases you need the current time to calculate with. A call to `nanoTime` or `currentTimeMillis` can be expensive under contention, so minimizing is a good practice in hot paths. Also `currentTimeMillis` can fluctuate by going backwards in time, so hopefully a call wouldn't accidentally violate a response by returning a zero/negative duration.

But perhaps I'm complicating the API by leaking optimizations? It is more important for an API to be elegant than fast. Per Josh Bloch's rule,
> Consider the performance consequences of API design decisions, but don’t warp an API to achieve performance gains. Luckily, good APIs typically lend themselves to fast implementations. ```
interface Expiry<K, V> {
  long expireAfterCreate(K key, V value, long currentTime);
  long expireAfterUpdate(K key, V value, long currentTime, long currentDuration);
  long expireAfterRead(K key, V value, long currentTime, long currentDuration);
}
```

Do you think this is the best compromise or that `currentTime` should be dropped altogether. I agree that `currentDuration` is more useful than the previous `expirationTime` field. > Do you think this is the best compromise or that `currentTime` should be dropped altogether.

I'd keep it, assuming you're sure you can always provide it for free.

> I agree that `currentDuration` is more useful than the previous `expirationTime` field.

It makes things simpler in the common case you don't want change the duration. This feature is now implemented in Caffeine. It could be ported into Guava if a core member was inclined. @Maaartinus Unfortunately thinking about the `currentTime` after release, I realized that it is misleading. The `currentTime` is from `System.nanoTime()`, which is a timestamp that should only be used to determine the elapsed time between two calls. It cannot be used when calculating against the wall clock time where `System.currentTimeMillis()` is appropriate. For entries calculated from a timestamp, e.g. 30 days since the database record's `creation_date`, the caller cannot use the `currentTime` parameter. So while the parameter was free to provide, it will likely be useless and confusing.

In v3.0 I may need to drop it. One of the nice things about Guava is the internal baking period to catch these mistakes that an independent OSS library may make.  A use case for having both could be "always give me the latest value for this key, but if no one is accessing it, expire it".
     How is this going along? Is there a timeframe as to when a fix can be expected?
 @cpovirk I have had a go at this in https://github.com/google/guava/pull/2615. I wonder if you or someone else in the Guava team would have the time to review it?
 Oh, it looks like #2086 proposes a very similar fix to mine! I now wonder if my fix covers all the possible edge cases...
   [Efficency](https://github.com/ben-manes/caffeine/wiki/Efficiency) analysis of ARC, LIRS, W-TinyLfu, and LRU compared to OPT. The hit rate, algorithm complexity, and memory footprint leads me to conclude that W-TinyLfu is the right choice.
 Please see [TinyLFU: A Highly Efficient Cache Admission Policy (2015)](http://arxiv.org/pdf/1512.00727.pdf), which I co-authored.
    My summary of this issue:
- No, guava does not have an `Either` type. Because you probably don't need it.
- In most cases you want the `Left` value to represent an exceptional case, if so, consider just using the normal exception mechanism in Java instead.
- When neither side represent a bad exceptional value. Try to look for an alternative solution.

Though other libraries have `Either<A,B>` already, see this [SO post](http://stackoverflow.com/questions/26162407/is-there-an-equivalent-of-scalas-either-in-java-8).
  +1; we are waiting on an external HTTP service and need to control how long we wait before giving up.
 Another +1 here. We run a bunch of tasks with deadlines, and this would make managing the deadlines a lot easier.
  Having a mechanism to dynamically lookup the public suffix list would be awesome. Please consider doing it.

Thank you.
      @kluever @lowasser @kevinb9n 

> Before we play with alternate eviction policies, we need to develop a means for evaluating the impact of the different policies.

I've been working on a simulator so that an evaluation can be made. **What I primarily need help in is acquiring trace data so that we can make an informed decision.**

The [simulator](https://github.com/ben-manes/caffeine/wiki/Simulator) is multi-threaded, uses either a synthetic or trace file data source, has simple interfaces for adding new policies and trace formats, writes a report of the stats to the console or file, and is driven entirely through a [configuration file](https://github.com/ben-manes/caffeine/blob/master/simulator/src/main/resources/reference.conf).

The simple eviction and admission policies are implemented and I hope to start on the more advanced ones soon. It is easy to capture additional statistics and for now I've kept it to the simple case of a maximum size. Adding weights, expiration, and coherence support shouldn't be too difficult but I thought they should be added after most of the policies were complete. It would also be useful to track the average eviction penalty, e.g. CLOCK-based policies have O(n) worst case evictions.

For example using the [Wikipedia request trace](http://www.wikibench.eu) yields the report below. First we see the upper bound due to compulsory misses (`Unbounded`) followed by the theoretical bound (`Clairvoyant`). We see that using an admission policy (`TinyLfu`) can cheaply give us near optimal efficiency, but other traces will highlight its weak temporal locality (making it good for secondary caches, but not as a primary cache's policy). We then see that 2Q style policies, which all advanced policies tend to follow, provide a close approximation. Finally we see that the sampled policies can, by mere luck, sometimes beat their strict versions. We can conclude that a member of the 2Q family (which includes LIRS and ARC) will probably be the approach to adopt.

Kevin's original proposal was to generalize this as a tool that developers could run to size their caches. This was back during the transition from soft reference collection to a maximum size as the preferred approach. I'm not sure how useful that would be, but it would be a fairly trivial enhancement.

``` bash
╔═════════════════════════════╤══════════╤════════════╤═══════════╤═════════╗
║ Policy                      │ Hit rate │ Requests   │ Evictions │ Time    ║
╠═════════════════════════════╪══════════╪════════════╪═══════════╪═════════╣
║ opt.Unbounded               │ 85.90 %  │ 10,430,564 │ 0         │ 6.759 s ║
╟─────────────────────────────┼──────────┼────────────┼───────────┼─────────╢
║ opt.Clairvoyant             │ 59.05 %  │ 10,430,564 │ 4,270,817 │ 12.57 s ║
╟─────────────────────────────┼──────────┼────────────┼───────────┼─────────╢
║ sampled.Lfu_TinyLfu         │ 57.07 %  │ 10,430,564 │ 4,477,281 │ 22.83 s ║
╟─────────────────────────────┼──────────┼────────────┼───────────┼─────────╢
║ sampled.Lru_TinyLfu         │ 57.07 %  │ 10,430,564 │ 4,477,778 │ 23.13 s ║
╟─────────────────────────────┼──────────┼────────────┼───────────┼─────────╢
║ sampled.Random_TinyLfu      │ 57.06 %  │ 10,430,564 │ 4,478,042 │ 19.18 s ║
╟─────────────────────────────┼──────────┼────────────┼───────────┼─────────╢
║ linked.Clock_TinyLfu        │ 57.05 %  │ 10,430,564 │ 4,479,825 │ 13.01 s ║
╟─────────────────────────────┼──────────┼────────────┼───────────┼─────────╢
║ linked.SegmentedLru_TinyLfu │ 57.05 %  │ 10,430,564 │ 4,479,941 │ 12.41 s ║
╟─────────────────────────────┼──────────┼────────────┼───────────┼─────────╢
║ linked.Lru_TinyLfu          │ 57.04 %  │ 10,430,564 │ 4,480,610 │ 12.94 s ║
╟─────────────────────────────┼──────────┼────────────┼───────────┼─────────╢
║ irr.JackrabbitLirs          │ 56.44 %  │ 10,430,564 │ 4,543,447 │ 11.65 s ║
╟─────────────────────────────┼──────────┼────────────┼───────────┼─────────╢
║ sampled.Mru_TinyLfu         │ 56.08 %  │ 10,430,564 │ 4,580,282 │ 23.46 s ║
╟─────────────────────────────┼──────────┼────────────┼───────────┼─────────╢
║ sampled.Fifo_TinyLfu        │ 55.92 %  │ 10,430,564 │ 4,597,168 │ 21.98 s ║
╟─────────────────────────────┼──────────┼────────────┼───────────┼─────────╢
║ two-queue.TwoQueue          │ 55.57 %  │ 10,430,564 │ 4,601,748 │ 6.642 s ║
╟─────────────────────────────┼──────────┼────────────┼───────────┼─────────╢
║ sampled.Mfu_TinyLfu         │ 55.06 %  │ 10,430,564 │ 4,687,117 │ 23.03 s ║
╟─────────────────────────────┼──────────┼────────────┼───────────┼─────────╢
║ linked.Mru_TinyLfu          │ 54.06 %  │ 10,430,564 │ 4,791,403 │ 13.56 s ║
╟─────────────────────────────┼──────────┼────────────┼───────────┼─────────╢
║ sampled.Lfu                 │ 53.80 %  │ 10,430,564 │ 4,818,750 │ 16.07 s ║
╟─────────────────────────────┼──────────┼────────────┼───────────┼─────────╢
║ linked.SegmentedLru         │ 53.30 %  │ 10,430,564 │ 4,870,549 │ 6.710 s ║
╟─────────────────────────────┼──────────┼────────────┼───────────┼─────────╢
║ linked.Clock                │ 47.80 %  │ 10,430,564 │ 5,444,026 │ 6.721 s ║
╟─────────────────────────────┼──────────┼────────────┼───────────┼─────────╢
║ linked.Fifo_TinyLfu         │ 46.86 %  │ 10,430,564 │ 5,541,789 │ 12.36 s ║
╟─────────────────────────────┼──────────┼────────────┼───────────┼─────────╢
║ linked.Lru                  │ 46.62 %  │ 10,430,564 │ 5,567,011 │ 7.074 s ║
╟─────────────────────────────┼──────────┼────────────┼───────────┼─────────╢
║ sampled.Lru                 │ 46.46 %  │ 10,430,564 │ 5,583,946 │ 17.31 s ║
╟─────────────────────────────┼──────────┼────────────┼───────────┼─────────╢
║ linked.Fifo                 │ 41.87 %  │ 10,430,564 │ 6,062,391 │ 6.105 s ║
╟─────────────────────────────┼──────────┼────────────┼───────────┼─────────╢
║ sampled.Fifo                │ 41.87 %  │ 10,430,564 │ 6,062,579 │ 18.82 s ║
╟─────────────────────────────┼──────────┼────────────┼───────────┼─────────╢
║ sampled.Random              │ 41.87 %  │ 10,430,564 │ 6,062,860 │ 12.26 s ║
╟─────────────────────────────┼──────────┼────────────┼───────────┼─────────╢
║ sampled.Mfu                 │ 31.57 %  │ 10,430,564 │ 7,137,013 │ 20.46 s ║
╟─────────────────────────────┼──────────┼────────────┼───────────┼─────────╢
║ sampled.Mru                 │ 26.75 %  │ 10,430,564 │ 7,639,960 │ 21.53 s ║
╟─────────────────────────────┼──────────┼────────────┼───────────┼─────────╢
║ linked.Mru                  │ 25.38 %  │ 10,430,564 │ 7,782,358 │ 7.025 s ║
╚═════════════════════════════╧══════════╧════════════╧═══════════╧═════════╝

Executed in 30.36 s
```
 @kevinb9n 
After exhaustive evaluation, the two best algorithms are LIRS and EdenQueue. The problem with [LIRS](https://github.com/ben-manes/caffeine/blob/05308d87f696b32b22ec0b249c1063834d4fe63b/simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/irr/LirsPolicy.java) is that it requires 3x the cache size to reach its full potential, where 2/3rds are non-resident entries (evicted keys). This incurs a lot of complexity, in addition to it being a non-trivial algorithm to implement correctly.

[EdenQueue](https://github.com/ben-manes/caffeine/blob/8f0379f0e7706c9b2796aa913e0c154d4d13d18a/simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/two_queue/EdenQueuePolicy.java) (name in flux) is my design based on TinyLfu. It uses an small LRU window that evicts to a main LRU queue, guarded by an optimized TinyLfu admission policy. I wrote a [4-bit CountMinSketch](https://github.com/ben-manes/caffeine/blob/8d7ccddd8120c556e7aaae096ba5fcdbe3b905cf/simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/admission/sketch/FrequencySketch.java) that is both memory and cpu efficient. This is used for retaining the frequency history and requires 1 long per unit of capacity (16 counters). The hit rate is near optimal across the board, is simple, has a low footprint, is O(1), and does not require retaining evicted keys.

Having talked to Doug about this, we think its the right approach to move forward on.
    My use-case would also benefit from thread safety on Bloom filters. I'm rate limiting connections and the underlying framework (Netty) is multithreaded. Merging filters doesn't help in this case because the threads need to see the same data. Having stale data violates the "no false negatives" aspect of Bloom filters and makes Guava's Bloom unsuitable for my application

I could use synchronization, but having profiled Bloom it is apparent that most of the processing on my system is generating the hash. The way Bloom works now- hashing is done on a single core. I find this silly since the Guava's hash functions are specifically designed to be stateless and thread-safe. 

Since ~90% of CPU time is tied up in hash calculation, Bloom should scale nicely using striped locks. I'm fairly familiar with the Bloom code and can submit a patch for thread safety if desired.
  Has it been tried out yet? I have a use case for a utility that observes a rate, not for logging, not for metrics. We get events and based on some specific rules we discard events - one of the rules being the rate at which it happens - if something happens too sporadicaly, we drop it.
On the other hand, and this is where things get interesting, if the event rate breaches a threshold, we want to get all the events that participated in the threshold breach.

Now, of course, we wrote the class, it worked, and a year later we discovered that the design was completely wrong and that it creates hundreds of thousands of objects and when let running for a long enough time, eventually kills the application.

This is not an easy problem and it's easy to get wrong, so a well-tested utility might be useful to the broad public.
   I've been wondering about a class like this recently too.

I think it may prove to be a nice compromise between `CharMatcher` and regexes when one needs something more powerful than matching on a single `char`, but also doesn't want their [99 problems to turn into 100 problems](https://xkcd.com/1171/). :wink:

But seriously, I think that once Guava 21.0 and 22.0 are out of the gate, this should be thoughtfully and carefully considered.   Please correct me if I am overlooking something but aren't all of the following get"Something" methods' preconditions checked (either explicitly or implicitly)?
1. `iterable.iterator().next()`*: there is a first element (i.e. it isn't an empty stream)
2. `Iterables.getLast(iterable)`: there is a last element (i.e. it isn't an empty stream or an infinite stream)
3. `Iterables.getOnlyElement(iterable)`: there is one and only one element (i.e. it isn't an empty stream or a stream with multiple elements)

In the case of getLast we can't check a java.util.Iterator to see if it is infinite or not.
If there were a way to check an iterable's precondition that it has a last element without iterating through all of the elements then I suspect that this would certainly be done but there isn't.
As such, doesn't it make sense to check all the preconditions even for getOnlyElement?

If not, then should `Iterables.getOnlyElement(iterable)` be removed from the guava library and moved to guava-testlib?

\* as recommended in `Iterables.getFirst(Iterable<? extends T> , T)` as `Iterables.getFirst(Iterable<? extends T>)` is not provided
  Thanks for linking this to my PR, @cpovirk.  I see some opinions of varargs, but not spelled out with reasoning.  

Why was it preferred to add `of(E[])` over `of(E...)` ? for methods under test that take an Iterable<E>, why wouldn't you want to just call the method with `FluentIterble.of(foo, bar, baz)`, which is much closer to the type that you want (Iterable)?  

Yes, I get it there's always that method out there somewhere that will do the same thing - i.e. `Arrays.asList(foo, bar, baz)` also implements Iterable, but it's a mental hoop to remember it, or understand why it was used as a reviewer.  

Certainly that mental-tax, however small, is worth not having to pay and choosing `FluentIterble.of(foo, bar, baz)` would be instantly intuitively obvious to everyone who sees it and stick in their minds more easily the next time they need to make an Iterable quickly for testing…
 I should point out that it was done this way for `Iterators` and I don't see why not also `FluentIterable`.

http://docs.guava-libraries.googlecode.com/git/javadoc/com/google/common/collect/Iterators.html#forArray(T...)
 Somewhat frustrating this hasn't been added. @scr FWIW I've found https://github.com/jOOQ/jOOL to be pretty nice, and generally either a) have the methods/overloads I expect, or b) the maintainer is pretty open about adding methods/overloads as requested. FWIW/YMMV.

Unfortunately GWT doesn't have java.util.stream support yet, so I'm using old-school Guava transform/etc. with lambdas until I can just use jOOL for both client- and server-side.
  Is there any plan to fix this in the near future? It is really incovenient :(
 Thanks!
  List<String> elements = Lists.newArrayList();
elements.add("ABC");
elements.add("DEF");
String str = Joiner.on("','").appendTo(new StringBuilder("'"), elements).append("'").toString();
==> 'ABC','DEF'
   Apparently, there are considerations about migrating to Java 8 for further releases. In that regards, can't this ticket be reopened with exclusively Java 8 as extra argument, since predicates are now more easy to write/use than ever, and also more widespread?

```
List<String> list = ...
String parameters = ...
String value = checkArgument(list::contains, parameter, "%s is not registered", parameter);
```
 ```
String value = checkArgument(list.contains(parameter), "%s is not registered", parameter);
```

This can't work: `parameter` is not known as parameter to `checkArgument` and you can't return it. That's the point of this request, I believe.
    I think this would be nice to have.
 I think it will be useful function. 
 I like julianhyde's solution. I also rolled my own, which is nearly identical, though he has better factory methods. one difference is that his concatenates an immutable list of lists, whereas mine is a live-view of the meta-list as well, so whole lists can be added and removed (given proper synchronization) real-time.

https://github.com/friendswithbenny/fwb-alj/blob/master/src/main/java/org/fwb/alj/col/ConcatList.java
 +1  I just copy and paste Closer and find `Closeable`  replace to `AutoCloseable`, and rename Closer to `AutoCloser` :smile: 
 Why is it such a problem to add this fix? That won't break any backwards compatibility and it is pretty straightforward 
 @alexeygrigorev I think it's because Guava would then require Java 7, and considering it currently only requires Java 6 (to support Android and legacy users), this would be a big no-no.

However, it's worth noting that the Guava team are currently in the process of [upgrading Guava for **Java 8**](https://groups.google.com/forum/#!topic/guava-discuss/ZRmDJnAq9T0) (they will keep a Java-6-compatible version around for Android), which would implicitly make it Java-7-compatible too, so hopefully we won't have to wait too long for `com.google.common.io.Closeables` to accept `AutoCloseable`s.
 Since the latest version requires Java 8 this should be reopened. Also pretty please adjust Closer. Thanks!  @gissuebot , thanks for that explanation of why Guava chose "optional" instead of "provided". FWIW, I've had a long, hard thought about which way to go with our own libraries regarding JSR 305. As you note, they will both have the same effect. But it seems to me that semantically "optional" fits better for us. Think about it this way: why would consumers want JSR 305 annotations at runtime? They may may have a tool that does post-compile analysis. Or maybe the consumer wants to produce documentation based upon the JSR 305 annotations. The tool would need access to these annotations.

Ah, but you might say that the tool will _provide_ them. Yes, but I think that Maven's "provided" gives the expectation that there _must_ be some container providing them (e.g. servlets, as you mentioned). In this case, even the "provided" part is "optional". I therefore think that "optional" provides the closest semantics; they won't be included unless users want them --- they aren't "required but automatically provided by a container".

In your explanation you indicate that "optional" is used to choose among "several sets of bytecode". But that's not always the case; perhaps you are confusing "optional" with "having an option among choices, and you must choose one". There are many use cases of "optional" for which things are entirely optional: if the dependency is present, something happens; otherwise nothing happens.

In any case, I'm not saying you made the wrong choice; I'm just saying that I thought about it a lot and I think we'll go with "optional", and I'm putting my thoughts here in case they are useful to someone else. Cheers! @garretwilson I wonder if I'm missing something with regards to your comment above, because Guava has had both a compile-time and runtime dependency on JSR305 annotations since 31st June (https://github.com/google/guava/commit/0e29934933f33379de953727171f7ca1ec616a58). Furthermore, I believe that the Guava team is considering removing or replacing them with alternative annotations to accommodate Java 9 (https://github.com/google/guava/issues/2960).

Would you mind kindly clarifying the purpose of your comment above for me? > … Guava has had both a compile-time and runtime dependency on JSR305 annotations since 31st June …

Eep! Really? What Guava version is that you're referring to?

I've been reading https://stackoverflow.com/a/24264330/421049 and doing some intense research in https://stackoverflow.com/q/45596949/421049 and thinking long and hard on how best to include JSR 305 in our own library, based on Guava optionally including it (historically using "provided"). Now you're telling me that Guava has changed its mind altogether and is now including JSR 305 transitively, so that all consumers bring in the JSR 305 dependency automatically? Just so I make sure I'm understanding correctly… > Now you're telling me that Guava has changed its mind altogether and is now including JSR 305 transitively, so that all consumers bring in the JSR 305 dependency automatically?

Yes, I believe so.

> What Guava version is that you're referring to?

If [this comment](https://github.com/google/guava/issues/2721#issuecomment-276449030) is to believed, it looks like Guava versions 22.0+ are the ones I'm talking about. (And indeed, the release page for [22.0](https://github.com/google/guava/wiki/Release22) confirms this. :smiley:)

(On a side note, it also occurs to me that Guava changed their dep on JSR305 from "provided" to "optional" some time between when this issue was closed and when 22.0 was released, as according to https://github.com/google/guava/commit/0e29934933f33379de953727171f7ca1ec616a58, the dep was last set to `<optional>true</optional>` as opposed to `<scope>provided</scope>`. I'm unclear on when they made that change, though. :thinking:)

Am I right to understand that (1) you're on a Guava version older than 22.0 and (2) you're trying to make sure you have an explicit compile-time _and_ runtime dependency on JSR305?

If so, then upgrading to [Guava 23.3](https://github.com/google/guava/releases/tag/v23.3) (the latest version at the time of me writing this), or at least some 22.0+ version, should resolve your problem automatically. :smile: Wow, thanks for notifying me of the latest developments. So it turns out that Guava had indeed eventually agreed with what I wrote above, I guess, and switched to using `<optional>` rather than a scope of `provided`! That had made more sense to me. But I never knew about that, and nobody mentioned it on the numerous Stack Overflow discussions I mentioned above. Curious. So definitely thanks for alerting me to this.

> Am I right to understand that (1) you're on a Guava version older than 22.0 and (2) you're trying to make sure you have an explicit compile-time and runtime dependency on JSR305?

You're right about the first part, but the reason why I'm investigating this has nothing to do with not getting JSR 305 in a project. Rather we have our own libraries which use JSR 305, and I am debating whether to make _their_ use of JSR 305 optional or not; I was using Guava's experience to help guide my own decision.

After much reading, researching, and contemplating, I was ready to make a final decision and settle on using `<optional>`, even though Guava (I thought) had settled on `provided`. Now Guava's latest move throws everything into doubt again. It seemed pretty evident to me that `<optional>` was the right way to go, because users may want to use our general library without pulling in another dependency (as with Guava). And finding out that Guava had switched to `<optional>`, too, was somewhat of a validation of my decision. But now why is Guava throwing out "optional" altogether? Does it have something to do with moving towards Java 9 modules, which may not support optional-ness? This new turn of events has confused me again. Oh, here is why they are non-optional now: https://github.com/google/guava/issues/2721

But interestingly that issue has to do with a _separate_ set of annotations, not the JSR 305 annotations. > But interestingly that issue has to do with a separate set of annotations, not the JSR 305 annotations.

Yes, that's right. But IIUC the whole conversation on that issue, I believe it was (or still is) applicable not only to those specific annotations ([error-prone](https://github.com/google/error-prone)'s annotations, I believe), but to all "optional" and "provided" annotations in general.

I'm pretty sure that it was because the issue applied to all "optional"/"provided" annotations that Guava depended on, rather than just error-prone's annotations, that the Guava team decided to make all of Guava's annotation deps "compile" scope. And unfortunately, Java 9 throws in a whole _other_ can of worms, with regards to Guava's dependency on the JSR305 annotations specifically. Because of how JPMS modules work, it may prompt the Guava team to drop JSR305 altogether or adopt a different annotations library.

See issue https://github.com/google/guava/issues/2960 for the gory details. :( Yeah, I saw that, but didn't quite understand the details. I'm not yet up to speed on Java 9 modules. Sheesh, why couldn't they have simply finished JSR 305 and made it part of Java? (Trying not to go into a rant here.)

Well thanks for all the info --- be sure to add anything else you think of. I'm now in a holding pattern deciding which way to go with JSR 305 in our own library. @garretwilson You're very welcome! And I'm very sorry to hear that I inadvertently made things more confusing for you.

I wish you best of luck, and I hope you can come to a reasonable conclusion in the near future!

I'm not sure if there's anything else to add, but I'd recommend that you follow #2960 so that, even if the details go over your head, you have some consensus to refer to if it reaches a solid conclusion. :) > "present at compile time but not at runtime."

…meaning "present at _users' compile time_ but not at users' runtime". That's an interesting state of affairs --- it's like a scope Maven doesn't provide. But as I [mention](https://github.com/google/guava/issues/2721#issuecomment-340509193) in #2721, it's unclear whether such a scope would really be needed. Anyway, thanks for helping make this clearer! It will help me come to a decision of what to do in my own library. Cheers!   I like this idea. Any thoughts on an API?
 FYI, we're doing this in OkHttp. I'm hoping to get something that solves most HTTP use cases, including IDNs.
https://github.com/square/okhttp/issues/1486
 Maybe a good place to start is the target spec.  RFCs 2396 and 3986 are good candidates. Android's Uri and Java's URI do 2396. However 3986 is listed as obsoleting 2396.

Whatwg has a spec for URLs, which I think Jesse is targeting in OkHTTP.

Thoughts?
 The WHATWG spec is the best yet, but it's still not exactly consistent with what the browsers do. And the browsers themselves aren't consistent with each other. I ended up doing a lot of research, including this:
https://docs.google.com/spreadsheets/d/1BgGAhJ5WE3JBsATeudamiBzxmgEhwkfcFqQmPx8qrkc/edit#gid=0
 Wow, that spreadsheet is terrifying! Well, given the multitude of specs and inconsistent behavior, maybe it's wise to divide the problem:
- Allow different types of URIs by creating a base Uri that's intended to be extended.
- Support additional specs by isolating encoding and decoding into its own class(es).

Here's a 50Kft sketch:

```
/**
 * Spec independent. Can be extended for other URIs such
 * as URL, MAILTO, or LDAP.
 */
Uri
    String getScheme()
    String getAuthority()
    ...

UriBuilder<T extends Uri>
    T build();
    UriBuilder<T extends Uri> scheme(String scheme)
    UriBuilder<T extends Uri> authority(String authority)
    ...

/**
 * Spec specific.
 */
UriCodec<T extends Uri>
    T decode(String uriString)
    String encode(T uri)

```
 Nah, my policy has been to just write one good URL that does what you want. Nobody wants to decide between Firefox parsing mode and Chrome parsing mode, they just want something that's going to work.

For example, today I'm doing the first steps towards IDNA mapping.
https://github.com/square/okhttp/pull/1612
 My thought was to choose a spec - let's say 3986 - and implement that for Guava. But factor things such that it'd be easy for clients to extend for other specs and schemes.
 The WHATWG spec is good, but it isn't perfect. There are a few edge cases where it disagrees with what the browsers actually do.
 @cpovirk , other than following the WHATWG spec, any thoughts on what would make a good URL library? Maybe some tough learnings from the multiple implementations that you already have?
 You're right - Jesse is very wise :)

google.common.net has several classes that could be used within a more general URL class (eg HostAndPort).  Would you be open to additional sub-URL classes? For example: QueryParams, PathSegments, etc?

QueryParams could be a good start. If there's even a very, very, very small chance, I'd be happy to open an issue to bounce a design and, if it moves forward, write a patch.
 You're all too kind. @ericedens please grab OkHttp if that's sufficient for you. If it's too much, extracting HttpUrl into its own standalone thing is also possible. Though I don't think _I'll_ do that, you're welcome to. There's been non-zero demand.
  +1
 +1
 +1
  I'm also interested in creating Inet6Addresses from ipv4-mapped addrs (without copy/pasting half of InetAddresses).
Makes sense not wanting something so specific in-tree, but would a patch flipping ipStringToBytes to protected be accepted?
   haven't found `Consumer<T>`:(
  I am facing the same issue with cached calls to database. The status of the issue is accepted. Are there any news about the developpement of a solution?
 This should work properly in the [rewrite](https://github.com/ben-manes/caffeine/blob/master/caffeine/src/test/java/com/github/benmanes/caffeine/cache/RefreshAfterWriteTest.java#L122). There should probably be variants of these tests for the async cache, though. A bulk refresh is not supported yet.
 I have still the same problem. Automatic refresh calls only load and not loadAll.

[main] INFO com.jcabi.aspects.aj.NamedThreads - jcabi-aspects 0.22.1/58f97a9 started new daemon thread jcabi-loggable for watching of @Loggable annotated methods
[main] INFO com.dichotomia.tests.guava.CacheLoaderExample - #loadAll('[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]'): '{0=0, 1=1, 2=2, 3=3, 4=4, 5=5, 6=6, 7=7, 8=8, 9=9}' in 162,75µs
[main] INFO com.dichotomia.tests.guava.CacheExample - #getAll([[0‥10)]): '{0=0, 1=1, 2=2, 3=3, 4=4, 5=5, 6=6, 7=7, 8=8, 9=9}' in 17,07ms
[main] INFO com.dichotomia.tests.guava.CacheLoaderExample - #load(0): '0' in 30,96µs
[main] INFO com.dichotomia.tests.guava.CacheLoaderExample - #load(1): '1' in 17,88µs
[main] INFO com.dichotomia.tests.guava.CacheLoaderExample - #load(2): '2' in 11,85µs
[main] INFO com.dichotomia.tests.guava.CacheLoaderExample - #load(3): '3' in 8,43µs
[main] INFO com.dichotomia.tests.guava.CacheLoaderExample - #load(4): '4' in 18,06µs
[main] INFO com.dichotomia.tests.guava.CacheLoaderExample - #load(5): '5' in 23,26µs
[main] INFO com.dichotomia.tests.guava.CacheLoaderExample - #load(6): '6' in 21,23µs
[main] INFO com.dichotomia.tests.guava.CacheLoaderExample - #load(7): '7' in 9,26µs
[main] INFO com.dichotomia.tests.guava.CacheLoaderExample - #load(8): '8' in 7,80µs
[main] INFO com.dichotomia.tests.guava.CacheLoaderExample - #load(9): '9' in 7,87µs
[main] INFO com.dichotomia.tests.guava.CacheExample - #getAll([[0‥10)]): '{0=0, 1=1, 2=2, 3=3, 4=4, 5=5, 6=6, 7=7, 8=8, 9=9}' in 12,03ms
 For my side this is documented as [#7](https://github.com/ben-manes/caffeine/issues/7) to support bulk refresh. I'm wrapping up v2 and not sure if this will make it.
  @kevinb9n Is it possible to make that document public?  I'm interesting in working on non-BMP support for CharMatcher.  I assume the plan is something like:
- Add

``` java
public boolean matches(int codePoint) {
  if (codePoint >= 0 && codePoint < Character.MAX_VALUE) {
    return matches((char) codePoint);
  } else {
    return false;
  }
}
```
- Override that method in all the built-in matchers
- Change uses of `String`/`CharSequence` to iterate by code point instead of by `char`
 Ping?
  @cgdecker, any update with such issue. how about the 19.0 release plan,we could not be waiting for that since 18.0.
 Thank you Google for exposing all our email addresses on migrating from Google code to Github.

The old issue (that can still be seen on the [web archive](https://web.archive.org/web/20160111155842/http://code.google.com/p/guava-libraries/issues/detail?id=960)) has all our email addresses mildly anonymized.

On copying over the issues from Google code the @gissuebot has decided to helpfully expose the full email addresses.

I'd been wondering at my sudden uptick in spam. This is the only place where I can find my email address clearly publicly posted. So thanks Google for not considering privacy when coding up the migration bot :disappointed: 
  Can this be considered again? The standard API would require instantiating BigDecimal to do rounding with special modes.

I guess a big concern over such a method is double's inability to represent rounded decimals. Maybe two variants can be added with one ignoring any inaccuracies and another throwing if output cannot be meaningfully represented?   Looks like not much has progressed on this issue for a couple years? Would be nice to more easily implement the `HashFunction` interface as an end user. Specifically, I'd like to be able to use it with "HmacSHA1", which would put it in a similar league with `MessageDigestHashFunction` (but with a key, so if implemented guava side it might look something like `Hashing.hmacsha1(byte[] key)`)
  What about doing it in a two steps manner? First deprecate the method and create a new one `readFullyOnSteroids` then in a later release rename `readFullyOnSteroids` to `readFully`?
 Sorry to reply after that long, but once again I was in need for this instead of the current state and, having forgotten about it, found this issue again.

Why is it important to keep the binary compatibility?

I understand that binary compatibility is a nice-to-have feature, but not a deal breaker. Guava makes incompatible changes with each release; why is this any different from those changes?

Today, there are already [several "classnotfoundexception" questions on SO](http://stackoverflow.com/search?q=[guava]+is%3Aquestion+classnotfoundexception) where the go-to answer is "upgrade your library", and people are recompiling anyways.

In regards to the "2 extra lines of code", I disagree: it's 2 lines of code multiplied by the number of times it is used. I read some parsing classes we have here and we're at ~300 usages on a medium-sized project (~50k loc). The workaround that was implemented was a static-import method which does what @lowasser described. And it's rather ugly (static import, extra parameter, function-style instead of method-style), but less than the current state. So no, it's not only 2 extra lines of code. 
 我是否可以理解为guawa不会成为第二个JDK？

2015-11-05 19:38 GMT+08:00 Olivier Grégoire notifications@github.com:

> Why is it important to keep the binary compatibility?
> 
> I understand that binary compatibility is a nice-to-have feature, but not
> a deal breaker. Guava makes incompatible changes with each release, why is
> this any different for the the binary compatibility?
> 
> Today, there are already several "classnotfoundexception" questions on SO
> http://stackoverflow.com/search?q=%5Bguava%5D+is%3Aquestion+classnotfoundexception
> where the go-to answer is "upgrade your library", and people are
> recompiling anyways.
> 
> In regards to the "2 extra lines of code", I disagree: it's 2 lines of
> code multiplied by the number of times it is used. I read some parsing
> classes we have here and we're at ~300 usages on a medium-sized project
> (~50k loc). The workaround that was implemented was a static-import method
> which does what @lowasser https://github.com/lowasser described. And
> it's rather ugly (static import, extra parameter, function-style instead of
> method-style), but less than the current state. So no, it's not only 2
> extra lines of code.
> 
> —
> Reply to this email directly or view it on GitHub
> https://github.com/google/guava/issues/934#issuecomment-154037535.

## 

_达则兼济天下 穷则独善其身_
 Hello,

In the light of a new "Guava for Java 8" version to come (which forces a recompile given that several classes _will_ be deleted), I respectfully ask that this issue is reconsidered.

Thanks!
   I just bumped into this as well -- patches accepted?
 Supporting extensibility appears important:

> HTTP status codes are extensible. HTTP applications are not required to understand the meaning of all registered status codes, though such understanding is obviously desirable.
- http://www.w3.org/Protocols/rfc2616/rfc2616-sec6.html#sec6.1

Supporting extensibility could happen in creation and/or consumption. Twitter uses a few nonstandard 4xx codes to signal throttling and rate limiting errors. For example, the class should be able to do something useful when asked to interpret the nonstandard 429 from 'HTTP 429 Too Many Requests'.
 +1 for something like the Spring Enum mentioned above
 I think that a full fledged class with static instances would work best, since it also has support for nonstandard status codes such as 429 Too Many Requests. Also, this way, it would also be able to store the status code and the associated message.
    In the meantime, more and more possible uses of this have appeared in our project, and for several we cannot use the Set version. So please expose this.
 I believe [`Lists.cartesianProduct` was added in 19.0](https://github.com/google/guava/wiki/Release19#commoncollect).
  There are so many real world use cases for enum ranges and discrete domains:
- Calendar months (JANUARY, FEBRUARY, ...)
- Days of week (SUNDAY, MONDAY, ...)
- Cards (JACK, QUEEN, KING, ACE)
- Task priorities (MINOR, MAJOR, CRITICAL, BLOCKER)
- Permissions  (READONLY, MODERATOR, ADMINISTRATOR)
  +1 to Multitable
 We'd really like a multitable, it is outrageous that there isn't one already.
 :+1:
 +1

Also: http://stackoverflow.com/questions/17057104/multimap-table-with-guava
 +1
 +1 +1 +1 +1    @cgdecker, is there currently any interest in implementation of this enhancement?
    One particular reason where I wanted this several times was in a test. Writing the indexOf-loop, or even the splitter is fine when you're going to test it, but if I want to assert in a test that number of occurrences in a string produced by code under test is correct, I would like to avoid putting logic in my test to verify that.
 Why isn't this added yet?! This is a no brainer Is this still being rejected? I can add this if there's interest.  Another reason to do this, now, is so we have a version of this functionality that's not tied to _our_ Supplier interface (we should use only java.util.function.Supplier for it).
 I would also like to see a "refreshing" Supplier memoizeWithExpiration - that simply maintains the existing value if an exception occurs during refresh.

I just coded a single-element refreshOnWrite cache that is wrapped by an anonymous `Supplier` instance. I think I wrote just as many comments explaining what I was doing and why, as I did lines of code.
 I have a set of config data based on the locale and I would want to cache that entire data in the memory and keep refreshing it periodically without activating the server.

Is there a way I can achieve this using this library? 

I am doing it by adding reload method and calling updateAll to one particular locale within it. But it doesn't look clean according to the library functions. How can I get functionality. Do you suggest any other library for such cases? I kept it simple, I guess (perhaps naive, but we'll see)

    public interface ResettableSupplier<T> extends Supplier<T> {
      void reset();
    }
    
    public static <T> ResettableSupplier<T> resettableMemoize(final Supplier<T> source) {
      class ResettableMemoizingSupplier implements ResettableSupplier<T> {
        private volatile Supplier<T> memoized = Suppliers.memoize(source);
    
        @Override
        public T get() {
          return memoized.get();
        }
    
        @Override
        public void reset() {
          memoized = Suppliers.memoize(source);
        }
      }
      return new ResettableMemoizingSupplier();
    }

I try to avoid this anyhow in favor of a better 'bigger picture' solution, but that's not always possible in a legacy context      I have a similar requirement. However, simply respecting the order in which subscribers are added to the bus would be sufficient for my needs. At first blush, it would appear to be as simple as using a `LinkedHashMultimap` for `subscribersByType` instead of `HashMultimap`.
  an example at least showing how to create that custom hashfunction would be great.
   I think this issue has become... outdated? What's the right word to use here?

As I discussed in https://github.com/google/guava/issues/334#issuecomment-269697414, I believe the functional interfaces in Java 8 have implemented this idea now, and as Guava 21.0 (which depends on Java 8) will be released soon, I think this issue can be safely closed.

Although, having said that, I've just remembered that there's a plan to release an Android-specific port of Guava around Guava 22.0's release. This port cannot depend on Java 8, so there might be worth in effectively porting the methods on the Java 8 functional interfaces to a class in `guava-android`.    What about SourceCodeEscapers ?
I cannot find it on Guava (18)
https://code.google.com/p/guava-libraries/source/browse/guava/src/com/google/common/escape/SourceCodeEscapers.java?r=08fb8bc14dff5e928840d4e95176b1279bb4ea58
    Can anyone upload a project demonstrating this problem? My attempts to reproduce it have failed.   Is there a reason an EventBus can't have both a custom identifier and a custom exception handler?
  I just wanted this for the exact same purpose mentioned by **_kasperni**_.
  Just FYI, Java 9 introduced a method `Objects.requireNonNullElseGet(T obj, Supplier<T> supplier)` that does exactly what you need  I would like this, as well, to nullify an `Optional<Thread>`'s `Thread` after it's completed.
     I had an example use case for this function today: clone org.springframework.security.core.context.SecurityContext and set it as current while executing a background task in a thread pool. This data structure is Serializable, so it can be saved into a servlet session, the concrete classes implementing these interfaces could be different and the data structure could be mutable, so I would like to make a copy, and doing so via serialization looks like the simplest approach.
  What about this issue? I recently stumbled upon [this implementation](https://code.google.com/p/guava-libraries/source/browse/guava/src/com/google/common/pool/?name=refs/remotes/gcode-clone/pool) by Louis Wasserman. Isn't this implementation a good one? I  tested it with load and it performed okay. Some features are missing, naturally, but it's a great start, isn't it?
 out of curiosity, given java 6 has been eol'ed for almost 3 years, at what point does guava move on?
 Its use on Android which hasn't even fully supported all of the Java 7 APIs
will artificially limit it for years.
On Mar 6, 2015 6:45 PM, "Jae Gangemi" notifications@github.com wrote:

> out of curiosity, given java 6 has been eol'ed for almost 3 years, at what
> point does guava move on?
> 
> —
> Reply to this email directly or view it on GitHub
> https://github.com/google/guava/issues/683#issuecomment-77657042.
 Extended support for Java 6 ends in December 2018, [according to Oracle](http://www.oracle.com/technetwork/java/eol-135779.html).
 what about a 'guava-extended' library that could offer this type of functionality for those using a newer jdk?
 and that aside, i'd still like to see this as part of the library even if i have to call `close` myself.
 +1 for seeing this in a future version, however that may be.
 @kevinb9n Then maybe the active approach you described in the second comment is the most appropriate for Guava on JDK 6?
 @lowasser Louis, are there any plans to release the pooling mechanism any time soon? Like maybe this year? Your implementation looks very promising!
 any progress?
 Any update on this?    I am also looking forward for java util functionality like one from groovy [List#transpose](http://docs.groovy-lang.org/docs/next/html/gapi/org/codehaus/groovy/runtime/DefaultGroovyMethods.html#transpose%28java.util.List%29) or scala [List#zip](http://www.scala-lang.org/api/2.10.3/index.html#scala.collection.immutable.List) . 
 Would still be nice to have this...

At the moment, this may be possible, but very clunky/awkward to implement, especially if you really only needed it as a one-off.
 While this issue is old I wanted to add my use case for this feature - request/response pairing.

I have a batch function that takes a collection of requests and returns a collection of responses, in order. I want to be able to do something taking both the request and response together as a pair (not a Pair) and this seems to satisfy that use case for me.

```java
Iterable<Request> requests = ...
Iterable<Response> responses = batchRequest(requests);
Iterables.forEachPair(requests, responses, (req, res) -> doSomething(req, res));
```
 @cpovirk 
For the interleave component, I have written a custom Iterator that I've been using for my own personal use that can interleave 2-N iterators of varying sizes. I'm not sure if this is something that would be desired in the core library - if so I could do a pull request. Also if that's the case, it would probably need some style/name changes to better fit the Guava code base.

```java
/**
 * An Iterator implementation which interleaves elements from the given iterators.
 *
 * Iterators do not need to be the same length.
 */
public class InterleavingIterator<T> extends AbstractIterator<T> {

    private final Queue<Iterator<T>> queue;

    public static <T> InterleavingIterator<T> ofIterators(final List<Iterator<T>> iterators) {
        return new InterleavingIterator<>(iterators);
    }

    public static <T> InterleavingIterator<T> ofIterables(final List<Iterable<T>> iterables) {
        final LinkedList<Iterator<T>> iterators = new LinkedList<>();
        for (final Iterable<T> iterable : iterables) {
            iterators.add(iterable.iterator());
        }
        return new InterleavingIterator<>(iterators);
    }

    private InterleavingIterator(final List<Iterator<T>> iterators) {
        this.queue = new LinkedList<>(iterators);
    }

    @Override
    protected T computeNext() {
        while (!queue.isEmpty()) {
            final Iterator<T> head = queue.poll();
            if (head.hasNext()) {
                final T result = head.next();
                queue.offer(head);
                return result;
            }
        }
        return endOfData();
    }

}
```    Would love if this patch could be merged...
I also needed the functionality.
 I have applied that patch and created a pull request:
https://github.com/google/guava/pull/2100
   I've started an implementation that matches exactly, not based on regex, but I guess it can easily be improved.

It can be seen here: https://gist.github.com/ogregoire/8c95bd3ab7c7e670a5012caad47125e3

If I'm not lost in other considerations, I'll try to make this into a guava-like class and create a PR. Any remarks, comments is welcome.
    JDK 8 introduced [`Duration`](https://docs.oracle.com/javase/8/docs/api/java/time/Duration.html) class for `java.time` package, so I guess this issue is obsolete. On the other hand it does not integrate with `java.util.concurrent.TimeUnit` but uses its own `ChronoUnit` and currently there's no official way (in JDK 8) for converting between these two ([there will be in JDK 9](https://bugs.openjdk.java.net/browse/JDK-8141452), though).
 Isn't the picosecond an argument anymore?
  The issue is taken care of in https://github.com/diffplug/durian "Durian: Guava's spikier (unofficial) cousin".
  Is there an ETA for when this might get into guava? I note that kryo, zookeeper, and kafka all have their own implementations of ByteBufferInputStream
   java.nio.file is not available on android.
 Any news on this?
  Just because some people use hammers to hammer in a screw doesn't mean we shouldn't have hammers.

Something like this would have been useful in the case where you've implemented the Decorator pattern, and you might either pass in a particular ConcreteComponent or an associated ConcreteDecorator, but must specify a parameter type of Component.

You might have a wide variety of ConcreteComponent implementations, each of them having some number of associated ConcreteDecorator implementations.  Since they all, at the end of the day, extend Component, you have to accept a Component, but for a given method you may only want to permit a specific ConcreteComponent and any of its associated ConcreteDecorators.  Any updates on this? @kevinb9n can you link to what a "Partition" is?
 Hi team, is there finally an implementation in guava yet? If yes what its called.  Isn't Guava running on Travis CI now?

It may be worth keeping this issue open until https://github.com/google/guava/issues/2686 is resolved, but then again maybe not... Heck, it may be worth getting Guava to run on the [TeamCity public server](https://teamcity.jetbrains.com/). Checkstyle currently does this.  Aren't you gonna merge this one? Waiting since 31 Oct 2014 and highly anticipated
  My common sense tells me, that skip should come with inject for symmetry.

```
injectBefore(anotherIterableToInject, wherePredicate);
injectAfter(anotherIterableToInject, wherePredicate);
```
 I think these `takeWhile` and `dropWhile` methods should be added to `com.google.common.collect.Streams` as well.

Oracle are planning to add `Stream.takeWhile` and `Stream.dropWhile` methods in Java 9, so these methods would also act a sort of intermediate measure for those who won't be able to use Java 9 immediately upon or shortly after its release.  :+1: 

would love to see this!
  Searching for this functionality in Guava and found this issue.  My use case is taking a key space over a dataset that was previously partitioned into n ordered partitions and wanting to repartition (redistribute?) it into a smaller number of partitions k as evenly as possible.  Very sad to see it was closed and just 15 days ago.
   Someone had posted why one cannot use the https://commons.apache.org/proper/commons-io/apidocs/org/apache/commons/io/FileUtils.html#byteCountToDisplaySize(long) method. 

Actually that does the opposite of what I want. If your answer is 1.4GB it simply rounds it off to 1GB as indicated in the Javadocs. This is absolutely not okay if you are showing the heapsize, remaining memory etc in a UI/admin pane etc. You simply cannot ignore 400MB in a rounding error. That is about 28% of the actual value. 
 This library is what I'm using:
https://github.com/JakeWharton/byteunits
  Up. This functionality might be very useful for POJOs.
Almost 5 years gone. Since previous decision. Maybe you want change it?
  ability to start()/stop() a service a few times seems very common

Not being able to restart the service somewhat defeats the point and forces to reimplement a lot of the same boilerplate (as mentioned in #418 ensuring only one running)

Maybe AbstractService needs to be modified or new recipe added (RestartableService) since this is a recurring usage

(migrated from #1904)
 same topic on StackOverflow http://stackoverflow.com/questions/8976367/restartable-service-using-guava

The proposed solution on SO does not seem to fit. 

If the Service injected in a couple places and has to be singleton (common for web-service like usage). So deleting and creating it opens up opportunity for bugs
 How about something like this: https://github.com/okigan/guava/commit/8f51b155f9ce5c60236b9a9bfdc6ca5f8bf5e51d
 > Could you provide a concrete usecase of where you would like to use this?
> Scenario: running a process that's hosts one or more guava based services.

For management purposes you need to be able to stop/start one or more of the services 
(for example, configuration needs to be updated). 

Also we can think of services in linux system and it's start/stop/restart lifecycle management.

> Would 'reset' be a method on Service? just abstractservice (and the other abstract service base classes)?
> Depends how far we want to take it
> 
> Would we add a new State enum? 
> I dont see a need for that, just the need to transition from TERMINATED to NEW
> 
> Ability to query how many times it has been restarted (generation count)?
> Also don't see the need for that, it's insufficient for debugging... 
> 
> What happens if you call reset() and the service isn't in a terminal state?
> Seems like nothing -- reset is a transition from TERMINATED to NEW only
> 
> Would we want services to be able to 'auto restart'?
> Seems this cannot be done in a clear way, the service failed to start and if the cause
> it still there we'll get an infinity loop (or that requires a smarter backoff/restart mechanism)
> In case of failure/termination you want to leave in a state that can be investigated, 
> auto-restart would delete that
> 
> I think the change to AbstractService will probably be significantly larger than the proposed
> Does not have to be AbstractService (i did that to emphasize the scope of changes needed). 
> This could be a new ResetableService which would avoid backward compatibility issues (but again @Beta is there)
 @lukesandberg Happy New Year!

Please review response above.
 > Since if we aren't modifying Service or AbstractService then it doesn't need to be a guava feature at all

Service implementation strongly recommends to use one of the provide implementations (with which I agree, as it is relatively tricky to get it right)

> there is the question of how it would interact with things like ServiceManager.

At the time of my original request I have not used ServiceManager yet, and now see that it is 
useful for managing several services. So, (in my mind) that clarifies that the method should be part of 
Service interface and ServiceManager would call it as well (for all managed services)

> (re)transition through the NEW and STARTING states buy you? 

To ensure consistent startup/initialization (avoid logic for first vs consecutive starts)

> Is it interacting with some other infra that is generically monitoring the services?

right, the decision to reset/start should be external to the service/services 
 Would a RestartableService wrapper like [this one](https://gist.github.com/vladdu/b8af7709e26206b1832b) work as an alternative? 
 @vladdu interesting, but dont think it solves the OP issue

(ex. if 'delegate' is implemented by subclass of AbstractService it will not be able to restart)
 The delegate doesn't restart, but a new one is created and started. The restartable wrapper "keeps up the appearances", so to speak.

Missing from the gist is the handling of listeners. One might want to call 'running' and 'failed' multiple times, if there is some kind of initialization/finalization. Some listeners might have global state and aren't fit for getting called more than once. This is application-dependent and I think that it would need some kind of extension to Listener to cover all cases.
 @vladdu maybe that's not bad then (I am ok not to cater to listeners with global state)
 In case anyone is interested, I have updated  [the gist](https://gist.github.com/vladdu/b8af7709e26206b1832b) so that it really works. I haven't included the obvious NeverRestartPolicy and AlwaysRestartPolicy classes. 

I am using this in a real project and it seems to work ok.

One thing that remains unclear is how it would behave with multithreaded listeners.
 Thanks @vladdu. This is really useful. Wish this was somehow implemented in the core library.
 What about changing/updating the states ?

Curren lifecycle is Service.State.STOPPING to Service.State.TERMINATED.

We can define it like: Service.State.STOPPING to Service.State.STOPPED.
And another one: Service.State.TERMINATING to Service.State.TERMINATED.

So when service stopped, it just stop, but not terminated. So calling start again will the service again. But calling a terminate() function will terminate the service, current stop behaviour.
 I think a better way of handling this is to have a `ServiceRestarter` that you pass a `ServiceProvider` this will handle the re-instantiation of the service when the service crashes.

I implemented a modified version of @vladdu's solution here:
https://github.com/WPIRoboticsProjects/GRIP/blob/master/core/src/main/java/edu/wpi/grip/core/util/service/AutoRestartingService.java
And here is it's respective test
https://github.com/WPIRoboticsProjects/GRIP/blob/master/core/src/test/java/edu/wpi/grip/core/util/service/AutoRestartingServiceTest.java

**DISCLAIMER**: 
This solution may not be technically correct and may have deadlocks.
If you find one please leave an issue on the project.
   Hello all, I would like to bump this topic up with a simple, related pull request I created (https://github.com/google/guava/pull/2164), seeing how often this is requested.

I think it's obvious there's a problem and that it should be tackled. I see two simple solutions.

The first one is described in the commit message:

```
Guava tries to simplify some of the common cases, 
e.g. we have a value, but if it's not set, we want a default
(though the same can be true for the default).

Unfortunately this method wasn't called `defaultIfNull`, but `firstNonNull`,
therefore people assumed it's a search.

This commit tries to solve that, by *making* it a search,
and letting the users decide which approach they want
```

The second one could be to deprecate it again, and add one with the same impl, named `defaultIfNull`.

(ps: slightly related: https://github.com/google/guava/pull/2163)
  Issue #1345 is related.
   Does this issue even need to be open now?

[`java.net.Socket`](https://docs.oracle.com/javase/7/docs/api/java/net/Socket.html) has implemented `Closeable` since Java 7, and Guava itself will start requiring Java 8 soon in 21.0.

(I know that an Android port will be created around the time Guava 22.0 will be released, but I believe the Android port will only support Java 7+? And I believe `Socket::close` was added in Android API level 1 anyway.)  Any progress on this? Won't Guava help us read a BOM?
  Any Progress on FluentPredicates and FluentFunctions?  
 I think this issue is now resolved with the introduction of the `java.util.function.{Predicate, Function, ...}` functional interfaces in Java 8, and with `com.google.common.base.{Predicate, Function, ...}` now extending those interfaces.

For example, [`Predicate`](https://docs.oracle.com/javase/8/docs/api/java/util/function/Predicate.html) has the "fluent" methods [and](https://docs.oracle.com/javase/8/docs/api/java/util/function/Predicate.html#and-java.util.function.Predicate-), [or](https://docs.oracle.com/javase/8/docs/api/java/util/function/Predicate.html#or-java.util.function.Predicate-) and [negate](https://docs.oracle.com/javase/8/docs/api/java/util/function/Predicate.html#negate--), which I think fulfill the OP's original request, as one can now write the following quite easily:

```java
com.google.common.base.Predicates.in(collection).negate().and(Objects::nonNull);
```

Therefore I believe that this issue can and should be closed now. :)  @kevinb9n Can we please decouple these two unrelated issues?
1. Add `Ordering.explicit(Iterable)`
2. Ability to specify handling for unknown values

The first one could be implemented right away. My use-case is needing to invoke `Ordering.explicit(Queue)`. The code in question is very performance-sensitive (invoked millions of times) so ideally I want to avoid converting the `Queue` to a `List` per invocation.
 @cpovirk I must have missed something then. Where in the code do you depend on the input being a `List`? As far as I can tell, you simply invoke a for-each loop on it, which means that an `Iterable` or `Collection` input would result in identical behavior without needing to copy the input to a `List` beforehand.
 @cpovirk To clarify, the main reason I am angling for `Iterable` is because I want to pass in a `ConcurrentLinkedQueue`.

Another approach (if you want to prevent the method from accepting non-ordered collections) would be to add a private method that consumes `Iterable` and then overload `explict()` for all known types (including `ConcurrentLinkedQueue`) which delegate to the `Iterable` method. This would have the advantage of retaining backwards compatibility.
 @cpovirk Thank you for clarifying. So I agree, we should have a `Collection` parameter instead of `Iterable`.
  I think having a method like maxSizeLimited in Lists to create and return such a ForwardingList will be a nice addition. I guess it's a case that is often encountered.
  Looks like this should be removed from the [idea graveyard](https://github.com/google/guava/wiki/IdeaGraveyard#create-a-map-from-an-iterablepair-iterablemapentry-object-alternating-keys-and-values-or-from-listk--listv), now that it's been implemented:

> create a map from an Iterable<Pair>, Iterable<Map.Entry>, Object[] (alternating keys and values), or from List<K> + List<V>
>
>TODO(kevinb): fill in
>
>Note that we may still add ImmutableMap.copyOf(Iterable<Entry>).  Any progress on this issue?
 Should this never be done in guava as Java 8 has exactly the duplicated API?

https://docs.oracle.com/javase/8/docs/api/java/util/stream/IntStream.html
 Many people use guava as a backfill of Java 8 functionality for Java 7-and-earlier projects (like Android).
 Even with Java 8, there seem to be some methods missing:
...
long LongMath.sum(int[])
BigInteger BigIntegerMath.sum(long[])
...
I'm not sure about choosing the classes according to the result type, but there are already precedents in Guava (e.g., `factorial(int)`). Both methods are rather simple, but getting them wrong isn't too hard either.

Using `IntStream::sum` sounds like a bad idea in case it might overflow one day and you might spend the next one chasing the bug.

Varargs or int/long streams arguments may be better. @Maaartinus With regards to `LongMath.sum(int[])`, I believe one can emulate it for now with both streams and Guava's help, like so. (I've not run this code example through a compiler, so it may need some tweaking, but I hope the idea comes across well.)

```java
int[] ints = ...;
long sum = Arrays.stream(ints).mapToLong(i -> i).reduce(0, LongMath::checkedAdd);
``` Likewise, for `BigIntegerMath.sum(long[])`, something like this should work:

```java
long[] longs = ...;
BigInteger sum = Arrays.stream(longs).mapToObj(BigInteger::valueOf).reduce(BigInteger.ZERO, (a, b) -> a.add(b));
``` @jbduncan Agreed. I guess, your `sum(int[])` is as fast as it can get (note that you need no `checkedAdd`), but your `sum(long[])` is probably much slower than slicing the `long` into two `int`s, accumulating each into a `long` and using `BigInteger` for the final result only. @Maaartinus 

> Agreed. I guess, your `sum(int[])` is as fast as it can get (note that you need no `checkedAdd`)...

Am I right to think that it's because a `single` long is large enough to hold the sum of an `int[Integer.MAX_VALUE]` where all elements are equal to either `Integer.MAX_VALUE` or `Integer.MIN_VALUE`?

Regardless, I think that `LongMath::checkedAdd` would almost certainly be needed when dealing with Streams with more than `Integer.MAX_VALUE` elements (which aren't common at all, I imagine). But then again, in such a situation, I imagine mapping and reducing to a `BigInteger` would be more sensible than reducing to a `long` anyway.

> ...but your `sum(long[])` is probably much slower than slicing the `long` into two `int`s, accumulating each into a `long` and using `BigInteger` for the final result only.

I'm a bit lost but very curious by what you mean here. Can you give me a code example? > Am I right to think

Yes, the minimum value is `> Integer.MAX_VALUE * Integer.MIN_VALUE > -2**62`, which fits, the maximum value is slightly smaller in magnitude.

---

> a code example
```
long MASK = 0xFFFFFFFFL;
long high = 0, low = 0;
for (long x : longs) {
     low += x & MASK;
     high += x >> 32;
}
return BigInteger.valueOf(high).shiftLeft(32).add(BigInteger.valueOf(low));
```
There may be tons of errors.      But.... What happens with Android (Android still doesn't have Java 8) or others frameworks without Java 8?
 exactly... on Java 8 i am using the language but where i can't use java 8 i would want to rely on 3rd party libraries, like guava...
 @ekovacs : I guess they have stopped this because they are migrating to Java 8 in Android N.
 I have not found a decent way to fold in Java 8 ;)
  A simple workaround is to use a mutable list to store intermediate results. Example:

```
List<String> temp = new ArrayList<>(expectedSize);

// populate "temp" ...

ImmutableList result = ImmutableList.copyOf(temp);
```

I assume that this will result in better performance than using `ImmutableList.builder()` for the same operation.

The downside, of course, is that this doesn't provide fluent syntax.
 +1  We've been waiting for this for a while.  Any movement?
 +1, any status on this? 
 +1 Excited to hear about an update!
 +1 Please put this in the next release.
 Looks like some things landed in master, so maybe in Guava 24.0 release TBD?

- [`ImmutableList.builderWithExpectedSize`](https://github.com/google/guava/commit/7928bbe079303c54373453353c9ef2cd7de9365e): https://github.com/google/guava/commit/7928bbe079303c54373453353c9ef2cd7de9365e
- [`Immutable{Map,BiMap}.builderWithExpectedSize`](https://github.com/google/guava/commit/8158909d7bda9f98a4576f89eb5fd88cb12c2bd6): https://github.com/google/guava/commit/8158909d7bda9f98a4576f89eb5fd88cb12c2bd6
- [`ImmutableSet.builderForExpectedSize`](https://github.com/google/guava/commit/d7501abccbd666a8db4dff77fa110c801a094c75): https://github.com/google/guava/commit/d7501abccbd666a8db4dff77fa110c801a094c75  We do have a couple concurrent multimap implementations internally, but they come with warnings like this:
>> Which implementations are you talking about please ? I really need ConcurrentMultimap in my use case I don't mind worse performance....  Nobody needed this since 2015?   > The "enumerate" idea is one we considered and rejected long ago; there's no need for it, "int i = 0; / i++;" works just fine.

Unless you are using i while creating an anonymous inner class, in which case i needs to be final.

Of course, you can create a final int within the loop to store the current value of i, but that's even more crufty. I guess the real problem is that you'd need to support something like Pair?    I needed a kind of "unique list" as well and struggled to implement something I was happy with. As pointed out above, a UniqueList breaks Collection utility methods like sort and shuffle. But I also realized that I really didn't need to use indices in these collections much at all. Because their are not duplicates, I could refer to the position I wanted in the list by the element itself.

So with some hesitation, I ultimately gave up on it being a "List" at all and created a new type of Collection. This collection doesn't present the user with index-based access. My collection has methods getFirst() and getLast(), but then methods like getBefore(e) and getAfter(e), to return the elements before and after the specified element. It also has addBefore, addAfter, removeBefore, removeAfter, all of which accept element arguments.

I struggled to name the new kind of Collection. I initially wanted to use "Ordering", but Guava already has something else with that name. I settled on "Chain" for now. I'm open to other name suggestions.

For my primary implementation of the interface, I effectively re-implemented a LinkedList but with the addition of a HashMap mapping elements to its bucket in the list. So I get constant-time contains, insert, and remove. One of the benefitsI get by _not_ implementing List is that I don't worry users might use the slower index-based operations that come from the linked list implementation.  There was a request for use cases. 

I started to use the Trie in apache commons4 collections to use in lookups of longest matching prefix. Its not uncommon with rules based on phone number prefixes.

Next is to do the same but for IP networks, almost like a routing table. Apache commons4 4.0 doesnt allow me to create a patricia tree on other types though. But I guess limewire is almost doing this, but refactoring has made the codebases diverge.

The lookup tables will have around ~100k entries, and there about 100k lookups per second.
 @kluever how about in 2017? :) 