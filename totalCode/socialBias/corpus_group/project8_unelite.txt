  Fix up dangling backtick.

Include missing code snippet.

<!--- Provide a general summary of your changes in the Title above -->

## Description
<!--- Describe your changes in detail -->

## Motivation and Context
<!--- Why is this change required? What problem does it solve? -->
<!--- If it fixes an open issue, please link to the issue here. -->

## Screenshots (if appropriate):

## Checklist:
<!--- Go over all the following points, and put an `x` in all the boxes that apply. -->
<!--- If you're unsure about any of these, don't hesitate to ask. We're here to help! -->
- [ ] My code follows the code style of this project.
- [ ] I have updated/added documentation affected by my changes.
- [ ] I have read the **CONTRIBUTING** document.
- [ ] I have added tests to cover my changes.
- [ ] All new and existing tests passed.
 
[![Coverage Status](https://coveralls.io/builds/11773032/badge)](https://coveralls.io/builds/11773032)

Coverage remained the same at 89.518% when pulling **fe094a4cc22123f010b1dde482209784b663a6c1 on newyork-anthonyng:feature/an/fix-marko-vs-react-docs** into **37e3dcc4f5a9a3b1628e6dfe5ca3875c57ee75f4 on marko-js:master**.
  <!--- Provide a general summary of your changes in the Title above -->

## Description
<!--- Describe your changes in detail -->
Add silent option to browser-refresh and hot-reload.
## Motivation and Context
<!--- Why is this change required? What problem does it solve? -->
<!--- If it fixes an open issue, please link to the issue here. -->

https://github.com/marko-js/marko/issues/709
## Screenshots (if appropriate):
N/A
## Checklist:
<!--- Go over all the following points, and put an `x` in all the boxes that apply. -->
<!--- If you're unsure about any of these, don't hesitate to ask. We're here to help! -->
- [ ] My code follows the code style of this project.
- [ ] I have updated/added documentation affected by my changes.
- [ ] I have read the **CONTRIBUTING** document.
- [ ] I have added tests to cover my changes.
- [ ] All new and existing tests passed.
 
[![Coverage Status](https://coveralls.io/builds/11770843/badge)](https://coveralls.io/builds/11770843)

Coverage decreased (-0.005%) to 89.518% when pulling **218050114bf778c14dfda18fe4c830b800201fef on nahtnam:silent** into **deb95bb48fdcba68de93a029c6975b8ce04c75b9 on marko-js:master**.
 
[![Coverage Status](https://coveralls.io/builds/11770843/badge)](https://coveralls.io/builds/11770843)

Coverage decreased (-0.005%) to 89.518% when pulling **218050114bf778c14dfda18fe4c830b800201fef on nahtnam:silent** into **deb95bb48fdcba68de93a029c6975b8ce04c75b9 on marko-js:master**.
 
[![Coverage Status](https://coveralls.io/builds/11770843/badge)](https://coveralls.io/builds/11770843)

Coverage decreased (-0.005%) to 89.518% when pulling **218050114bf778c14dfda18fe4c830b800201fef on nahtnam:silent** into **deb95bb48fdcba68de93a029c6975b8ce04c75b9 on marko-js:master**.
  <!----------------------------------------------------------------------
  |     IF FEATURE SUGGESTION (skip to next section for bug reports)    |
  ---------------------------------------------------------------------->
## New Feature
Add an option (`quiet`, or `silent`) that will stop console outputs.
### Description
<!--- Provide a detailed description of the change or addition you are proposing -->
Add the option somewhere like: `require('marko/browser-refresh').enable({ quiet: true });`, that will stop console.logs like the following from being printed.
```
[marko/hot-reload] File modified: /Users/nahtnam/Desktop/testing/app/templates/hello/index.marko
```
### Context
<!--- Why is this change important to you? How would you use it? -->
<!--- How can it benefit other users? -->
I am working on a site and my console output every time my server restarts is bloated. To reduce clutter it would be great to have a quiet option that would only print if there is an error or warning.
### Possible Implementation
N/A
### Open Questions
N/A
### Is this something you're interested in working on?
No I could try, but someone would have to go over the code since I have almost no experience with Marko.

EDIT: Is the main branch master, or something else? I cant find a contributors guide. @patrick-steele-idem @austinkelleher Thanks for your comments. I think I know how to do it. My only question is:

Here: https://github.com/nahtnam/marko/blob/master/src/hot-reload.js#L38 I will add a `option` parameter which will check is `silent` is defined (defaults to false). Do I add that option to the `runtime` variable so the silent option can be accessed in the other functions? I still need to finish the checklist but its a start.  
[![Coverage Status](https://coveralls.io/builds/11767095/badge)](https://coveralls.io/builds/11767095)

Coverage increased (+0.004%) to 89.527% when pulling **f73c2364d53375ba8931d4fc0a53bd97c0e54fba on 705-dynamic-root-id-attr** into **fe60da9c111ae60613e567ab957b47e9b77cebea on master**.
 
[![Coverage Status](https://coveralls.io/builds/11769889/badge)](https://coveralls.io/builds/11769889)

Coverage increased (+0.03%) to 89.558% when pulling **4e6d1fc4cf71227eb0b049e8d0711f37f86e594d on 705-dynamic-root-id-attr** into **fe60da9c111ae60613e567ab957b47e9b77cebea on master**.
 
[![Coverage Status](https://coveralls.io/builds/11769889/badge)](https://coveralls.io/builds/11769889)

Coverage decreased (-0.01%) to 89.509% when pulling **4e6d1fc4cf71227eb0b049e8d0711f37f86e594d on 705-dynamic-root-id-attr** into **fe60da9c111ae60613e567ab957b47e9b77cebea on master**.
  Closes #706.

<!--- Provide a general summary of your changes in the Title above -->

## Description
<!--- Describe your changes in detail -->

## Motivation and Context
<!--- Why is this change required? What problem does it solve? -->
<!--- If it fixes an open issue, please link to the issue here. -->

## Screenshots (if appropriate):

## Checklist:
<!--- Go over all the following points, and put an `x` in all the boxes that apply. -->
<!--- If you're unsure about any of these, don't hesitate to ask. We're here to help! -->
- [ ] My code follows the code style of this project.
- [ ] I have updated/added documentation affected by my changes.
- [X] I have read the **CONTRIBUTING** document.
- [ ] I have added tests to cover my changes.
- [ ] All new and existing tests passed.
 
[![Coverage Status](https://coveralls.io/builds/11754177/badge)](https://coveralls.io/builds/11754177)

Coverage remained the same at 89.524% when pulling **1b67ac33214058bb524ac4bcd8348c48a62b589b on newyork-anthonyng:feature/an/fix-webpack-readme** into **9e334a8986c9f3752bf5ec37e23e163887adf851 on marko-js:master**.
 
[![Coverage Status](https://coveralls.io/builds/11754177/badge)](https://coveralls.io/builds/11754177)

Coverage remained the same at 89.524% when pulling **1b67ac33214058bb524ac4bcd8348c48a62b589b on newyork-anthonyng:feature/an/fix-webpack-readme** into **9e334a8986c9f3752bf5ec37e23e163887adf851 on marko-js:master**.
 
[![Coverage Status](https://coveralls.io/builds/11754177/badge)](https://coveralls.io/builds/11754177)

Coverage remained the same at 89.524% when pulling **1b67ac33214058bb524ac4bcd8348c48a62b589b on newyork-anthonyng:feature/an/fix-webpack-readme** into **9e334a8986c9f3752bf5ec37e23e163887adf851 on marko-js:master**.
 
[![Coverage Status](https://coveralls.io/builds/11754177/badge)](https://coveralls.io/builds/11754177)

Coverage remained the same at 89.524% when pulling **1b67ac33214058bb524ac4bcd8348c48a62b589b on newyork-anthonyng:feature/an/fix-webpack-readme** into **9e334a8986c9f3752bf5ec37e23e163887adf851 on marko-js:master**.
 
[![Coverage Status](https://coveralls.io/builds/11754565/badge)](https://coveralls.io/builds/11754565)

Coverage remained the same at 89.524% when pulling **71416584f1a494f039ef07b076d8e7b20cbbf01f on newyork-anthonyng:feature/an/fix-webpack-readme** into **9e334a8986c9f3752bf5ec37e23e163887adf851 on marko-js:master**.
  <!----------------------
  |     IF BUG REPORT    |
  ---------------------->
## Bug Report
Typo inside the `webpack` markdown file.

### Context
<!--- Provide a more detailed introduction to the issue itself, and why you consider it to be a bug.  How has this bug affected you? What were you trying to accomplish? -->
```html
<!doctype html>
<html>
<body>
    <script src="static/bundle.js"/>
</body>
</html>
```
As far as I know, the `<script>` tag cannot be self-closing, and should be changed to:
```html
<script src="static/bundle.js"></script>
```
I can make a PR to fix this if this makes sense.
### Expected Behavior
<!--- Tell us what should happen -->

### Actual Behavior
<!--- Tell us what happens instead -->

### Possible Fix
<!--- Not obligatory, but suggest a fix or reason for the bug -->

<details><summary>Additional Info</summary>

### Your Environment
<!-- Include as many relevant details about the environment you experienced the bug in -->
* Version used:
* Environment name and version (e.g. Chrome 39, node.js 5.4):
* Operating System and version (desktop or mobile):
* Link to your project:

### Steps to Reproduce
<!--- Provide a link to a live example, or an unambiguous set of steps to -->
<!--- reproduce this bug include code to reproduce, if relevant -->
1. 
2. 
3. 
4. 

### Stack Trace
<!-- If an error is thrown, provide the stack trace here -->

</details>
 @patrick-steele-idem Awesome. I'm starting to dig into Marko and was assuming that it supported self-closing script tags.

I created a new [PR](https://github.com/marko-js/marko/pull/707) to address this. Let me know if anything else is needed.  ## Bug Report

### Context
component state is out of scope inside the include tag

### Expected Behavior
pass state variable to included template

### Actual Behavior
state is undefined

### Steps to Reproduce
I have a component something like

```marko
class {
  onCreate() {
    this.state = { id: 1}
  }
}

//works fine
< input id=state.id  />

//state is undefined
<include(/path/to/generic/input, {id: state.id}) />
<include(/path/to/generic/input) id=state.id />
```

### Stack Trace
```
Uncaught ReferenceError: state is not defined
    at render (index.marko:40)
    at safeRender (renderable.js:6)
    at Template.render (renderable.js:136)
    at doInclude (include-tag.js:17)
    at includeTag (include-tag.js:30)
    at render (index.marko:45)
    at Template.renderSync (renderable.js:69)
    at Object.<anonymous> (index-desktop.marko.js:12)
    at __webpack_require__ (bootstrap e38ec24‚Ä¶:19)
    at Object.<anonymous> (emitter.js:2)
``` That's great, worked straight away. Thanks for the quick response. The space after the input was a typo. Will avoid using id in the future :)  Seems to be related with #702 as error is the same staying at `4.4.2` solves the problem Installing `4.4.5` works fine for me with `npm@5`. Can't reproduce that on node 8 with NPM5 and `4.4.6`, so, it was either my misconfiguration or something already fixed. Will close the issue, thank you!  everything worked fine up until upgrading to marko 4.4.0, when building with webpack, this error cropped up
`var markoCompiler = !(function webpackMissingModule() { var e = new Error("Cannot find module \".\""); e.code = 'MODULE_NOT_FOUND'; throw e; }());`
Downgrading to marko 4.3.1 could fix the problem.
What's wrong? please! I added a github project to reproduce the problem
https://github.com/arthurchenn/markoissue702  Documentation is not proper , We are developing Progressive Web App .  we need client side Routing Mechanism like Iron Router or react Router and Ember Routing  .  Check out https://github.com/marko-js/marko/issues/645 Hey @mauricionr  , Marko 4.*
We have developed webiste and mobile website using Marko 3.* and Marko Widget . Can you suggest We want to upgrade to Marko 4 . Like Marko start providing state  in Marko 4 . Please suggest me regarding this  @gilbert  @patrick-steele-idem  : Can you suggest me  for Marko 4  , We are using marko 3.3 and marko widget . I want to upgrade for marko 4 . In Marko 4 u r proving state View architecture , We can eliminate Marko Widgets ?  @anupdineout this issue https://github.com/marko-js/marko/issues/626 has good stuff about markov3 and markov4 @patrick-steele-idem  any suggestion for Progressive Web app in Marko Js for Mobile website . Can you provide any documenation  or git demo project . i'm following lighthouse 2.0 for best practices on PWA

`npm install -g lighthouse` I dont know , @patrick-steele-idem  , https://github.com/FormidableLabs/redux-little-router  does not provide support for MarkoJS have you seen this one @anupdineout https://github.com/charlieduong94/marko-path-router ? @mauricionr  @patrick-steele-idem  Can you help me to use es6 in MarkoJS 4.  @mauricionr  @patrick-steele-idem  

https://github.com/charlieduong94/marko-path-router ?
I checked this , its not working for me  . I need Client Side routing , otherwise , I need to switch the Technology from Marko4 to React . Please Suggest  Why is not working for you? Hello @anupdineout, I would be happy to help you get `marko-path-router` set up. Please create an issue on my repo detailing the problems you are having so that we can work through them together. @charlieduong94  Thanks for reverting back . Thats was some issue with KOA Aysnc setup . Now working for me   ‚Ä¶ayground" does not contain lasso

<!--- Provide a general summary of your changes in the Title above -->

## Description
<!--- Describe your changes in detail -->

## Motivation and Context
<!--- Why is this change required? What problem does it solve? -->
<!--- If it fixes an open issue, please link to the issue here. -->

## Screenshots (if appropriate):

## Checklist:
<!--- Go over all the following points, and put an `x` in all the boxes that apply. -->
<!--- If you're unsure about any of these, don't hesitate to ask. We're here to help! -->
- [ ] My code follows the code style of this project.
- [ ] I have updated/added documentation affected by my changes.
- [ ] I have read the **CONTRIBUTING** document.
- [ ] I have added tests to cover my changes.
- [ ] All new and existing tests passed.
 
[![Coverage Status](https://coveralls.io/builds/11658451/badge)](https://coveralls.io/builds/11658451)

Coverage increased (+0.4%) to 89.824% when pulling **be03de928ebdf7bcbb390e29b2f3832285de847d on tindli:patch-2** into **a1e6310f08c5816e98c831863bbe8d7cb08bdf8b on marko-js:master**.
  <!--- Provide a general summary of your changes in the Title above -->

## Description
<!--- Describe your changes in detail -->

## Motivation and Context
<!--- Why is this change required? What problem does it solve? -->
<!--- If it fixes an open issue, please link to the issue here. -->

## Screenshots (if appropriate):

## Checklist:
<!--- Go over all the following points, and put an `x` in all the boxes that apply. -->
<!--- If you're unsure about any of these, don't hesitate to ask. We're here to help! -->
- [ ] My code follows the code style of this project.
- [ ] I have updated/added documentation affected by my changes.
- [ ] I have read the **CONTRIBUTING** document.
- [ ] I have added tests to cover my changes.
- [ ] All new and existing tests passed.
 
[![Coverage Status](https://coveralls.io/builds/11658199/badge)](https://coveralls.io/builds/11658199)

Coverage remained the same at 89.468% when pulling **3a1580d5a6473906c26bc329590627aab065e609 on tindli:patch-1** into **1551993272726fbf2edd35eb20845a63954f902d on marko-js:master**.
  
[![Coverage Status](https://coveralls.io/builds/11611428/badge)](https://coveralls.io/builds/11611428)

Coverage decreased (-0.7%) to 89.496% when pulling **2d0d8000cb9fd577f1eb81932799d6691c369613 on dist-dir** into **3d757a20f39bcb4dc5ae48b4b0d7ed7288e4c407 on master**.
 üëçüèª  
[![Coverage Status](https://coveralls.io/builds/11594315/badge)](https://coveralls.io/builds/11594315)

Coverage increased (+0.004%) to 90.21% when pulling **4cf05973a593210fefa30bc863371ae4ce214ab9 on 695-xml-unrecognized-tags** into **3d757a20f39bcb4dc5ae48b4b0d7ed7288e4c407 on master**.
 
[![Coverage Status](https://coveralls.io/builds/11594315/badge)](https://coveralls.io/builds/11594315)

Coverage increased (+0.004%) to 90.21% when pulling **4cf05973a593210fefa30bc863371ae4ce214ab9 on 695-xml-unrecognized-tags** into **3d757a20f39bcb4dc5ae48b4b0d7ed7288e4c407 on master**.
   
<!--- Provide a general summary of your changes in the Title above -->

## Description
<!--- Describe your changes in detail -->
enable res.marko can catch a error safe
use like 
```javascript
res.marko(..).catch((err) => {
  next(err);
})
```
## Motivation and Context
<!--- Why is this change required? What problem does it solve? -->
<!--- If it fixes an open issue, please link to the issue here. -->
enable res.marko can catch a error safe
see issue #692

## Screenshots (if appropriate):

## Checklist:
<!--- Go over all the following points, and put an `x` in all the boxes that apply. -->
<!--- If you're unsure about any of these, don't hesitate to ask. We're here to help! -->
- [x] My code follows the code style of this project.
- [ ] I have updated/added documentation affected by my changes.
- [ ] I have read the **CONTRIBUTING** document.
- [ ] I have added tests to cover my changes.
- [x] All new and existing tests passed.
 
[![Coverage Status](https://coveralls.io/builds/11540128/badge)](https://coveralls.io/builds/11540128)

Coverage remained the same at 90.206% when pulling **6fff9dea1dca773c37fa52e0b3bb1009fd48b827 on moonrailgun:patch-1** into **c648b764f203d0c0284470d6267dfd9864a004f5 on marko-js:master**.
 my pleasure  I actually started encountering this today and have provided an example:

https://github.com/ianvonholt/marko-widget-test/tree/4.4.2

It seems that the onMount of child components is not being executed at all, nor are events being assigned. 

If the parent component has no component logic, no `module.exports` or `class {}`, then it works just fine. 

I provided two examples one with the class logic, one without.  

 I've sat on this one for a couple days and I have to say that I have no definitive conclusion on my stance with this. I understand the performance gains with only having the input/state for the top-level UI component serialized down to the browser. However, this method makes the combination of components rather lacking. 

With the current behavior in `marko@4.3+`, each instance where a developer is going to want nested components to be different for every page will fail to fully boot. Unless, that is, the developer explicitly creates different variations of the parent component with the desired top level UI components, or the component is utilized just as a template. The former bloats the number of components while the latter would remove any sort of logic you may want to apply to the parent component.  @patrick-steele-idem I was just looking through the commit log, looks wonderful. 

I'll run it through some tests on my end and let you know if there are any problems.   I am using vue.js at the moment and am interested in Marko. They are very similar and make it easy to transition one to the other. The one thing noticed is Marko is missing "scoped" but that's for another discussion. No one?   ### Question

Thank you so much for making components take reference in the latest beta version! But it seems like it only takes references from marko template (static). If I want to pass function reference from `component.js` down to child component, the child component still not able to receive the reference. I'm not sure if I'm using it correctly or not. Could you share some working demos to demonstrate passing reference from `component.js` down please? Thanks again! Hi @patrick-steele-idem, thanks for the response. 

I was not able to reproduce this time, maybe I didn't use it correctly that time. But I did encounter a different problem. The references passed down does not able to recgonize the correct execution context. 

/test-component/index.marko
```html
<test-inner-component handler=component.handler />
```

/test-component/component.js
```javascript
module.exports = {
  onCreate () {
    this.value = 'value'
  },
  handler () {
    return this.value // or do anything with the current controller context
  }
}

```

/test-inner-component/index.marko
```html
<div>
  <button on-click('click')>Click</button>
</div>
```
/test-inner-component/component.marko
```javascript
module.exports = {
  click () {
    console.log(this.input.handler())
  }
}
```

Supposely, the console should have a log as `value` printed when I click the button in the `test-inner-component`. But it actually printed `undefined`. 

I even tried to bind context for the function reference in `test-component` at `onCreate`, `onInput` or `onMount` like `this.handler = this.handler.bind(this)`. None of them actually work. 

Could you advise how this `pass reference` suppose to work? Does it only suppose to work without any context? 

Another use case I can think of is to pass marko component into another component, but that leads to another question I created: https://github.com/marko-js/marko/issues/684. How can I pass in a fully functional component (with template and controller) into another component? The only way I'm aware of it to pass in something like this: `require('./a-component.marko')`, but how can I associate a controller with that template? 

Sorry for the long question and thank you for the help. 
  A piece of documentation describing how to use Marko alongside [Huncwot](https://github.com/zaiste/huncwot). I'd be happy to hear your feedback.

## Description
I'm building a library similar to Express and Koa called Huncwot. I'm planning to use Marko as its default (and only) view engine. Huncwot is inspired by Clojure's ring with routes as (pure) functions returning *data* describing responses. In this pull request I'm describing how to use Marko with Huncwot.

## Motivation and Context
Server-side integration example using Huncwot is simpler and requires less code for the same result as in Koa or Express.

## Screenshots (if appropriate):

## Checklist:
- [x] My code follows the code style of this project.
- [X] I have updated/added documentation affected by my changes.
- [X] I have read the **CONTRIBUTING** document.
- [ ] I have added tests to cover my changes. (N/A)
- [ ] All new and existing tests passed.
 
[![Coverage Status](https://coveralls.io/builds/11347864/badge)](https://coveralls.io/builds/11347864)

Coverage remained the same at 90.204% when pulling **ecbf3a306ddcc6d303a2c45a5bcb9b7ce35a147d on zaiste:docs-marko-huncwot** into **71cc431b1e9f2b59aeaf394ff6a9e9510ff1d8de on marko-js:master**.
  Currently, this:
```js
app.locals.foo = 'foo!';
app.locals.serializedGlobals = { foo: true };
```
Doesn't work, because [`component-globals-tag.js`](https://github.com/marko-js/marko/blob/master/components/taglib/component-globals-tag.js#L20) sets each property to `false` after reading them. If there's a reason for doing that, I can't find it, and removing that line fixes the problem. 
[![Coverage Status](https://coveralls.io/builds/11338800/badge)](https://coveralls.io/builds/11338800)

Coverage decreased (-0.0009%) to 90.203% when pulling **3f5e28b4e7612a2254d6a600d755fec5e4241b93 on Hesulan:serialized-globals-no-set** into **ee9b70cf33a71715f2c0b6f394ab3b3054c4419c on marko-js:master**.
  ## Description
Was reading through docs and found some html entities.

## Motivation and Context
Pretty sure they were not suppose to be there üòú.

## Checklist:
<!--- Go over all the following points, and put an `x` in all the boxes that apply. -->
<!--- If you're unsure about any of these, don't hesitate to ask. We're here to help! -->
- [x] My code follows the code style of this project.
- [x] I have updated/added documentation affected by my changes.
- [x] I have read the **CONTRIBUTING** document.
- [ ] I have added tests to cover my changes.
- [ ] All new and existing tests passed.
 
[![Coverage Status](https://coveralls.io/builds/11312862/badge)](https://coveralls.io/builds/11312862)

Coverage remained the same at 90.204% when pulling **adf7801490f9b785b49c0c4e19950fc0ccd95cc8 on DylanPiercey:patch-1** into **ca27cb54b3c3e0f7a07a5aa9cbe19f56348b811b on marko-js:master**.
 Gotcha, thanks!  <!--- Provide a general summary of your changes in the Title above -->

## Description
<!--- Describe your changes in detail -->
Adding option to customize default timeout for await tags

## Motivation and Context
<!--- Why is this change required? What problem does it solve? -->
<!--- If it fixes an open issue, please link to the issue here. -->
We use await a lot and we need to customize the default await timeout for all await tags and we think this will help us to fix the timeout problem

I've opened an issue asking about this thing #621 

## Checklist:
<!--- Go over all the following points, and put an `x` in all the boxes that apply. -->
<!--- If you're unsure about any of these, don't hesitate to ask. We're here to help! -->
- [x] My code follows the code style of this project.
- [ ] I have updated/added documentation affected by my changes.
- [x] I have read the **CONTRIBUTING** document.
- [ ] I have added tests to cover my changes.
- [ ] All new and existing tests passed.
 
[![Coverage Status](https://coveralls.io/builds/11250601/badge)](https://coveralls.io/builds/11250601)

Coverage increased (+0.0009%) to 90.228% when pulling **6582b5b4a703458aa6cc7c4930abc52ec6cd5951 on mauricionr:default_await_timeout** into **29eb4d2c0066ecfa3e57d2b8bd8134617f4340fb on marko-js:master**.
 Squashed @austinkelleher 

Thanks :rocket:  
[![Coverage Status](https://coveralls.io/builds/11251597/badge)](https://coveralls.io/builds/11251597)

Coverage increased (+0.0009%) to 90.228% when pulling **8c534d926eaa86bfe5b41208412088fd227c7c6e on mauricionr:default_await_timeout** into **29eb4d2c0066ecfa3e57d2b8bd8134617f4340fb on marko-js:master**.
 @austinkelleher i will discuss with my team about override the `<await>` tag, thanks for the demo! i saw @austinkelleher, really good proposal, and with this override, looks like we will be able to override any core tag? Thanks @austinkelleher and @patrick-steele-idem simpler than the other aproach  <!--- Provide a general summary of your changes in the Title above -->

## Description
Marko global defaults and user globals aren't merged. If user globals exists the `defaults` are ignored.


## Motivation and Context
Look at https://github.com/marko-js/marko/issues/677

## Checklist:
<!--- Go over all the following points, and put an `x` in all the boxes that apply. -->
<!--- If you're unsure about any of these, don't hesitate to ask. We're here to help! -->
- [X] My code follows the code style of this project.
- [ ] I have updated/added documentation affected by my changes.
- [X] I have read the **CONTRIBUTING** document.
- [] I have added tests to cover my changes.
- [ ] All new and existing tests passed.

Tests suite doesn't works on windows! I will open an issue for this. 
[![Coverage Status](https://coveralls.io/builds/11201181/badge)](https://coveralls.io/builds/11201181)

Coverage increased (+0.002%) to 90.225% when pulling **5bcf5043012b3cf91056ae30fdc8ae6278fb9ec6 on StarpTech:merge_marko_globals_and_marko_defaults** into **e03362d94265e1d490b1a14fd515e7d16e5c876d on marko-js:master**.
  # Environment
Windows
NodeJs: v7.9.0
Marko: beta

The framework runtime variables in `out.global`
```
components:GlobalComponentsContext
uid: 1
```

are serialized to (in browser)
```
components: undefined
uid: NaN
```
when I access them in client side component. 

Another question is why they exists in the "user global" space ? This data should be land in a seperate namespace. Found the issue here https://github.com/marko-js/marko/blob/845c177be67bce46cc55b1d64b7e451dfe5c01da/components/util-browser.js#L1 window.$MG (defaults) must be merged.

Next issue is the `components` property. global `components` was purposefully set to `undefined` https://github.com/marko-js/marko/blob/845c177be67bce46cc55b1d64b7e451dfe5c01da/components/ComponentsContext.js#L41 Hi, yes my PR has been merged.   Right now I'm changing the component state with events. When a value changes (e.g. in an input tag) I use the on-change or on-keypress events to handle state changes. However in a form with a lot of states you need to have a lot of event handlers in the component class.
It gets unwieldy to have full control over all the business logic. It would be easier and clean to have an attribute like angular or vue.js (v-model, model.. or something like this) that takes a property of the state object and update it automatically.
I don't know if such a feature is already available but from the documentation I haven't seen anything like that.
Is it possible to implement a 2 way data binding out of the box? or, if not possible, can you suggest the best pattern to manage such cases?
Thanks.
  This is happening in 4.3.1 as well with callback and promises in the await tag.   ## New Feature

### Description
I'd like to be able to pass an option to renderToString that removes comments from that template. Perhaps also console.log calls.

### Context
Sometimes when I'm developing, especially in the view file which spits out most of my HTML page, I want to comment out / in certain sections - such as code for analytics trackers or other such things. This is so I can easily add / remove features as I develop without losing the code.

For now I mostly use Marko for server-side rendering my base HTML page which I plug another view engine (ReactJS) on top of. The ability to remove / add certain `<meta>` tags or some JavaScript on the fly using comments would be great - as these things are often changing. Right now all my pages are rendered with all the commented out sections too, which is adding to page size.

### Possible Implementation
Have an options object that can be passed to renderToString, with something like:
```
{
  removeComments: true,
  removeConsole: true
}
``` Oh, I wasn't aware that HTML-style comments were being removed. Looking back at my project I see that certain tags I commented out that way have actually been removed. That's cool.

It's mainly the JavaScript part of my code that I've been commenting out sections of - inside of HTML `<script>` tags. It seems these comments are not removed.

I might have to look at a babel solution then - although I've just tried to get rid of any babel on my server recently. When I do a `require` of the `.marko` file template, would the server know to transform the resulting JavaScript file which is generated by Marko? There doesn't seem to be a place where I actually reference the JavaScript file directly, and could potentially pass it to a babel transformer. I don't want babel to by default transform every JavaScript file because that can become a bit heavy.  
[![Coverage Status](https://coveralls.io/builds/11130285/badge)](https://coveralls.io/builds/11130285)

Coverage increased (+0.03%) to 90.296% when pulling **6ff3706ed1152d993a56ed2a081f3ea1fda8f29a on issue-651** into **9604a853ee3a2f487caa9add6a0173d02301109f on master**.
  ## Bug Report

### Context
Unable to use CSS rule `!important` in style block of marko file.

### Expected Behavior
The following is valid CSS in a marko file.
```
style {
  .foo-class {
    height: 50px !important;
  }
}
<div.foo-class/>
```
### Actual Behavior
Error when compiling:
```Module not found: Error: Can't resolve 'important;/n  }"}'```

### Your Environment
<!-- Include as many relevant details about the environment you experienced the bug in -->
* Version used: v4.2.7
 That'd be consistent. I am using `marko-loader`. The PR (https://github.com/marko-js/marko-loader/pull/13) that I just submitted against the `marko-loader` repo resolves this issue for me.  Having a dedicated section for scoped attributes would be a lot nicer than prefixing each class with `__`. I think most people would prefer to use only scoped css for their components and having to write `__` for every class in both the css and the template can get quite annoying after a while. 

Although when mixing global and scoped styles with @austinkelleher 's approach, there could end up being some confusion about what classes are scoped or not when looking at a pretty involved template with lots of styling going on. But then again, Vue users doesn't seem to be too bothered by that. I agree with the scoped attributes like:

```css
style.less.scoped {

}

style.less {

}

style.scss.scoped {

}

style.scss {

}
```

Instead of:

```css

    .global-button-selector { 
        color: grey;
    }
    __disabled-button { 
        color: grey;
    }
```

which in my opinion looks a bit messy and doesn't feel **concise** like most of the framework. I talked to @austinkelleher about this a while back and I've warm up to the idea of keeping scoped and non-scoped css classes under the same style block. I think that making class names that start with a capital letter scoped would end up working well. It feels less yucky compared to `.__`. 

There are languages out there that have different functionality for things that start with a uppercase or lowercase letter. For example, functions, structs, and struct attributes in `golang` that start with a capital letter are exported and are available outside of the package they are defined in, while lowercased variants are kept within the scope of the package. Although this is backwards from what was proposed (and `go` is _very_ different from css), I don't think the concept would be too foreign.

If marko ended up going this route, I think that it would have to be an opt in feature. It could end up breaking layouts for some people. You know, double underscore looks weird at first, but looking back on this thread a few weeks later it doesn't look bad at all. I think I prefer it since you can tell something different is happening, as opposed to the capital letters that look like a naming convention. *Note: I'll probably update after I get more sleep and have time to think*

I'm kind of wracking my brain on this one. On one hand, easy of implementation is obviously critical. On the other, this doesn't feel like a solid solution. 

### Main Concern: Tight coupling between scoped nature of css and markup

If I started off with 

```html
<button.primary/>
```

```css
.primary {
  color: blue;
}
```

but I decided suddenly that there was a conflict and I needed to scope it.

```css
.__primary {
  color: blue;
}
```

If I forget to update the markup or miss a reference then there could be a non-obvious style bug introduced. 

---

I know that's very likely obvious, but the above combined with the fact that the `__` needs to be added for everything scoped just seems error prone to me. 


# Modified Vue-like approach

Vue takes a pipelined approach. 

scoped styles -> vue-loader -> preprocessor -> internal vue-loader postcss plugin

Using a grouped approach like @austinkelleher mentioned would require something similar. 

## Implementation

**In a single file marko component**

```html
<button.primary/>

styles.scoped.less {
  button.primary {
    color: blue;
  }
}
```
*Generated output*
```css
button.primary[data-m-3ds24df] {
  color: blue;
}
```

The flow here would be more or less the same as vue's.

**In a split component**

style.mobile.css (Phase 0 -- source)
```css
scoped {
  button.primary {
    color: blue;
  }
}
.global-class {
  color: red;
}
```

Phase 1 -- marko transform

```css
@scoped(data-m-3ds24df) {
  button.primary {
    color: blue;
  }
}
.global-class {
  color: red;
}
```

Phase 2 -- postprocessor
Phase 3 -- marko-scoped-postcss

```css
button.primary[data-m-3ds24df] {
    color: blue;
  }
.global-class {
  color: red;
}
```

## Intended Results*
- Solves "scoped styles must be separated out from unscoped styles." 
  - Separation exists still, but can be localized to a file
- Solves: "Marko must understand each compile-to-CSS language." 
  - Look for a common denotation in each of the files like `@scoped` or something similar but unique. 
- Doesn't solve: "scoped style classes cannot be passed to nested components." 
  - I don't think this is a best practice to begin with, but it's still obviously an issue. 
- Might solve: "not compatible with multi-file adaptive styles." 
  - I would be very interested to know how this works to begin with. Regardless, after marko figured out what styles that component depended on it'd have to check for `@scoped`. If that was present, you'd just add the attribute directly onto every direct node of that component. (I'm not sure but I believe that doesn't extend to children). 


***Note: I'm making a lot of assumptions here that I don't have all the info to back up.**

Granted, I understand that this is significantly more complex than the proposed solution. Technically, given @patrick-steele-idem's note about the implementation details of the proposed solution I could see it just being a standalone webpack/lasso plugin anyway.
 @zephraph thanks for bringing attention to this topic again. I really don't see the issue with having marko support multiple CSS preprocessors. 

Having to install the desired preprocessor: SCSS, Less, PostCSS or Stylus via NPM so it's available to compile styles.scoped.less, styles.scoped.scss, etc is a minor trade-off in order to improve readability and improve the framework's usability. I am strongly of the opinion that all styles in a component should be scoped to that component by default.

Instead of `.__foo` to indicate that the `.foo` class is private, I would prefer to have to prefix something like `.GLOBAL.foo` to escape the particular component.

Consider this option:

```
style {
    .foo { color: red; }
    i { color: blue; }
}

global-style-exports {
   i { color: pink; }
}

<div class="foo">
  <i>Hello</i> <b>World</b>
</div>
```

Much discussion about CSS on the internet revolves around "global by default" was a misfeature in CSS (similar to it being in a misfeature in JS).  In the above example- it should be hard for styles to escape from the component. @ramses0, I really like the idea of all component styles being scoped by default. That would definitely be a breaking change though.    ## Bug Report

### Context
opening tag-brackets (`<`) being improperly converted to `&lt;`

[source](https://github.com/marko-js/marko/blob/master/docs/syntax.md#directives)
![source](https://cloud.githubusercontent.com/assets/23745012/24867738/79794f80-1e0e-11e7-9a2b-8ea816c9c5d5.png)

[rendered](http://markojs.com/docs/syntax/#directives)
![rendered](https://cloud.githubusercontent.com/assets/23745012/24867739/79ead6be-1e0e-11e7-9499-251eec545676.png)

### Expected Behavior
output:
``` marko
<strong if(true)>
    Marko is awesome
</strong>
```

### Actual Behavior
output:
``` marko
&lt;strong if(true)>
    Marko is awesome
&lt;/strong>
```

<details>
### Your Environment
* Version used: 4.2.7
* Environment name and version: Firefox 52, Chrome 57
* Operating System and version: Ubuntu 16.10
</details> where can the latest rendered master be seen?  ### Environment
Marko: 4.1.1
Node: 7.4.0
### Expected Behavior
Should only render the value.
### Actual Behavior
It renders javascript tag and the value.

### Steps to Reproduce

```marko
    <@title>
        <await(recipe from input.recipe)>
            ${recipe.name}
        </await>
    </@title>
```
will produce
```marko
<title>test&lt;script&gt;(function(){var w=window;w.$components=(w.$components||[]).concat({"w":[["s0",0,{},{"d":null,"b":null}],["s1",1,{"year":2017},{"d":null,"b":null}]],"t":["/recipe-detail$1.0.0/src/components/app-nav/index.marko","/recipe-detail$1.0.0/src/components/app-footer/index.marko"]})||w.$components})()&lt;/script&gt;</title>
```  ## Bug Report

### Context
Whilst trying to programmatically render components, one of the components started throwing an exception `Render error. Exception: Error: No component found`. After further investigation, I narrowed it down to whether any element within the component has a `for-key` or `key` attribute.

### Expected Behavior
The component should render as normal.

### Actual Behavior
With a `for-key` attribute, the following exception is thrown when `renderSync()` is called:
![image](https://cloud.githubusercontent.com/assets/19622548/24833117/5640d312-1c74-11e7-9825-7d9e549a5234.png)

With a `key` attribute, the following exception is thrown when `renderSync()` is called:
![image](https://cloud.githubusercontent.com/assets/19622548/24833126/7b45b43e-1c74-11e7-9083-af34dc8cb0d2.png)

<details><summary>Additional Info</summary>

### Your Environment
* Marko v4.2.6
* Chrome 57.0.2987.133 (64-bit), Node 6
* macOS Sierra 10.12.4

### Steps to Reproduce
I've created [a quick repository](https://github.com/edwarddamato/playground) where you can replicate this issue.

### Stack Trace
Stack traces provided above.

</details>
 Yeah, that fixes it. I'll keep an eye on this. Thanks!  ## Bug Report

### Context
On a new component with `index.marko`, create a single `<if(state.myVar)>test</if>` and run the server.
 
### Expected Behavior
The component `index.marko.js` should contain `function render(input, out, __component, component, state) {`

### Actual Behavior
The component `index.marko.js` contains `function render(input, out) {`

### Your   ##Environment
* Version used: marko@4.2.7
* Environment name and version (e.g. Chrome 39, node.js 5.4): Chrome 57.0.2987.133 , node.js 7.2.1
* Operating System and version (desktop or mobile): desktop MacOS X 10.12.4 beta

### Steps to Reproduce
1. Create a component with a single line `<if(state.myVar)>test</if>`
2. Add `onCreate` to component where `this.state = input`
3. Add `onMount` to component where `this.setState('myVar', 123)`
4. Pass component to a page
5. Load the page

### Stack Trace

```
events.js:160
      throw er; // Unhandled 'error' event
      ^

Error: Render error. Exception: ReferenceError: state is not defined
    at render (**/views/components/my-form/index.marko.js:29:7)
    at renderCompontent (**/node_modules/marko/components/taglib/helpers/renderComponent.js:3:5)
    at render (**/views/components/app/index.marko.js:21:3)
    at renderer (**/node_modules/marko/components/renderer.js:191:9)
    at render (**/views/pages/form/index.marko.js:33:3)
    at safeRender (**/node_modules/marko/runtime/renderable.js:6:9)
    at Template.render (**/node_modules/marko/runtime/renderable.js:136:20)
    at ServerResponse.response.marko (**/node_modules/marko/express.js:47:18)
    at app.get (**/server.js:74:7)
    at Layer.handle [as handle_request] (**/node_modules/router/lib/layer.js:93:5)
    at AsyncStream.error (**/node_modules/marko/runtime/html/AsyncStream.js:411:13)
    at Timeout._onTimeout (**/node_modules/marko/runtime/renderable.js:17:22)
    at ontimeout (timers.js:365:14)
    at tryOnTimeout (timers.js:237:5)
    at Timer.listOnTimeout (timers.js:207:5)
```  <!--- Provide a general summary of your changes in the Title above -->

## Description
<!--- Describe your changes in detail -->
+ clarify on-* wildcard usage
+ event handler basic and advanced notes
+ events comparison with dom, jquery, marko
+ link to example https://github.com/marko-js/markojs-website/pull/10

## Motivation and Context
<!--- Why is this change required? What problem does it solve? -->
<!--- If it fixes an open issue, please link to the issue here. -->
In the chat earlier we found an opportunity to improve the docs around event handlers.

## Screenshots (if appropriate):

## Checklist:
<!--- Go over all the following points, and put an `x` in all the boxes that apply. -->
<!--- If you're unsure about any of these, don't hesitate to ask. We're here to help! -->
- [x] My code follows the code style of this project.
- [x] I have updated/added documentation affected by my changes.
- [x] I have read the **CONTRIBUTING** document.
- [ ] I have added tests to cover my changes.
- [ ] All new and existing tests passed.
 
[![Coverage Status](https://coveralls.io/builds/10973696/badge)](https://coveralls.io/builds/10973696)

Coverage remained the same at 90.146% when pulling **13a2c81fddfe14a60149c86e233b41a613cad64d on tcrowe:on-event-doc-04062017** into **8019774911de50cf41c4b50963ac15dae8d4be7a on marko-js:master**.
 
[![Coverage Status](https://coveralls.io/builds/10973696/badge)](https://coveralls.io/builds/10973696)

Coverage remained the same at 90.146% when pulling **13a2c81fddfe14a60149c86e233b41a613cad64d on tcrowe:on-event-doc-04062017** into **8019774911de50cf41c4b50963ac15dae8d4be7a on marko-js:master**.
 
[![Coverage Status](https://coveralls.io/builds/10973696/badge)](https://coveralls.io/builds/10973696)

Coverage increased (+0.5%) to 90.615% when pulling **13a2c81fddfe14a60149c86e233b41a613cad64d on tcrowe:on-event-doc-04062017** into **8019774911de50cf41c4b50963ac15dae8d4be7a on marko-js:master**.
   Can I take this on ? I've got some free time these days and Im looking to get started around here. Thanks for the pointers guys. Will hopefully get this done over the weekend :) Okay so noob question, the only way to get the html out of a document fragment is by first appending it to a div and then getting its innerHTML right ? Is there any other way that I could be doing this ? Any progress on this yet? `renderToString` on the browser would be pretty nice to have. @mlrawlings Im still interested to work on this. Although I kinda stopped looking into this because I never could decide if the method I suggested was the way to go forward. @patrick-steele-idem @mlrawlings If the expected behaviour is to return the first top level element, we could just return the `outerHtml` from `this.___getNode().firstChild`. This works but I'm not sure this is the way forward.

Also, if I append the document fragment from `___getNode()` to a dummy VElement I created using `appendChild`, and try to access the firstChild it should give me the first child of the document fragment right ? This does not seem to be happening. Any ideas ?  ## Bug Report

### Context
I have a couple of Marko 3 components that have a `key` attribute that after upgrading to marko 4 break the whole page when used.

I believe `key` is now a reserved attribute.

### Expected Behavior
Component works

### Actual Behavior
Page fails to render and the following error is logged: `Render error. Exception: Error: No component found`

### Possible Fix
Allow key if defined in marks-tag.json of component.

<details><summary>Additional Info</summary>

### Your Environment
<!-- Include as many relevant details about the environment you experienced the bug in -->
* Version used: 4.2.4
* Environment name and version: node.js v7.8.0
* Operating System and version (desktop or mobile): mac OS Sierra

### Steps to Reproduce
<!--- Provide a link to a live example, or an unambiguous set of steps to -->
<!--- reproduce this bug include code to reproduce, if relevant -->
1. Create component with defined `key` attribute
2. Use in a page
3. Everything breaks

### Stack Trace
<!-- If an error is thrown, provide the stack trace here -->

</details>
  ## Bug Report

### Context

When using `<await-error>` to deal with rejected promises, marko calls `console.error` with the error. See https://github.com/marko-js/marko/blob/master/taglibs/async/await-tag.js#L111 .

For us this has two consequences:

- The console.error call ends up in stdout. In our container setup we use stdout for logging, with JSON entries. The marko output confuses our log parser.
- It's inconsistent to warn about an error in the case where the developer has explicitly provided an error handling tag.

### Expected Behavior

`<await-error>` tag does not cause `console.error` to be called.

### Actual Behavior

`<await-error>` tag does causes `console.error` to be called.

### Possible Fix

Having this logging can be useful during dev. Maybe ut could be behind a flag or something, so you can pass `silent-error=true` to the `<await>` tag or similar?

### Your Environment

* Version used: 4.1.2
* Environment name and version: node v6.6.0

### Steps to Reproduce

1. Load the code from https://gist.github.com/runeh/7adf1873b45ffa9d0b6723da4e410f4c into http://markojs.com/try-online/ 
2. Look at output in error console
 I ended up changing our code to deal the promise rejection in the renderer. But that seems unidiomatic, given that there are tags meant for dealing with timeouts and errors inside of await?

Anyway, it still feels counter-intuitive to me that there is `console.error` output in a case where I've explicitly added code to deal with the error. I would prefer it not logging on my behalf in that case.  This proposal seem to be more secure too, since arbitrary properties will no longer be "leaked" to the browser. > If a nested UI component derives its props/state or generates input properties from anything other than passed in input (e.g. this.locale = out.global.locale)` then that information will not be available when the UI component mounts in the browser.

Does this now mean that accessing the out stream from `onInput` will no longer be serialized and sent to the browser for components? @ianvonholt, we wouldn't need that hack if globals were also serialized and/or we could define the global object when initializing components in the browser. I created #646 specifically for that.  Should it? @patrick-steele-idem it's certainly not a problem to use `if(!` instead, I just was under impression that `unless` is some sort of global attribute like `if`...  Hi, in `Marko 4.2.1` a newline is inserted and my cursor jumps to the end of the textarea on every input if I try to bind its value to the state:

![marko-textarea](https://cloud.githubusercontent.com/assets/3694962/24590462/e0c79ec0-17ed-11e7-96cb-3dced2487006.gif)

**custom-input.marko**

```
class {
  onChange(e) {
    this.emit('change', e.target.value)
  }
}

div
  textarea key='input' on-input('onChange') value=input.value -- ${input.value}
  p
    strong -- ${input.value}
```

If I remove the strong tag that outputs `input.value` it works fine. If I use an `input` instead of the `textarea` it works fine as well. If I remove the `${input.value}` from the `textarea`'s body it works as well but then the initial `input.value` isn't shown.

The code is server-rendered so I'm guessing that this has to do with serialisation maybe?

Full code: https://github.com/maximilianschmitt/lasso-test

Thanks for your help! Thanks for your feedback @mindeavor. I'm removing `value` but this does not fix the issue unfortunately. Hey @patrick-steele-idem! Thank you for your help. I can verify that your proposed workaround of using the HTML syntax works. :)  Hello

## Bug Report
I was moving a div around the page with the mouse, then I got a weird behavior. I'm quite new with all this stuff but it looks like a bug.
### Context
Marko template:
`div style={position:'absolute',top:0} -- test`
Rendering:
`var bloc = require('./bloc');`
`bloc.renderSync().appendTo(document.body);`
### Expected Behavior
<!--- Tell us what should happen -->
'top' property should be set to zero and the text should be displayed at the top of the page.
### Actual Behavior
<!--- Tell us what happens instead -->
The value 0 for 'top' is ignored and the 'top' property is not set in the style (according to FF inspector). The text is displayed at the default position that depends on previous elements in body.
- No error message.
- Negative values are accepted and the position of the div is correct
- Same problem with 'left' property (not tested with other ones)
- Same problem when state is changed with code

<details><summary>Additional Info</summary>

### Your Environment
<!-- Include as many relevant details about the environment you experienced the bug in -->
* Version used: marko 4.2.0
* Environment name and version: node.js 6.10.0-win-x64 Firefox 52.0.2
* Operating System and version: Windows 10 desktop



</details>
 I surely could not have be so quick. I don't even know how I can test modified code‚Ä¶ I may be more helpful in some days/weeks.
Many thanks.   When I try to write something like the stop-watch component in the try online section, i get the following error when the script try to update the component:

```
Uncaught TypeError
    at Component.$__rerender (pages-1407d337.js:3344)
    at Component.update (pages-1407d337.js:3305)
    at updateComponents (pages-1407d337.js:1890)
    at updateUnbatchedComponents (pages-1407d337.js:1862)
    at pages-1407d337.js:1841
$__rerender @ pages-1407d337.js:3344
update @ pages-1407d337.js:3305
updateComponents @ pages-1407d337.js:1890
updateUnbatchedComponents @ pages-1407d337.js:1862
(anonymous) @ pages-1407d337.js:1841
```


below is the function where I hit the error: 


```
$__rerender: function(input) {
   if (input) {
      this.input = input;
   }
    var self = this;
    var renderer =  self.$__renderer;

    if (!renderer) {
        throw TypeError();
     }
.............................
```

`self.$__renderer` is undefined.


In my case there's a template rendered by express with marko/express.
The template has a tag called sidebar. This tag is where the code lives and it's build using the multi files structure:
component-browser.js
component.js
index.marko.

- component-browser.js handles the OnMount() and browser events.
- component.js handles onCreate()

In the onMount() I declared and assigned the intervalId to the global setTimeout() function that change the state using this.state.width every 1 second. (I'm using es6 function syntax so that the `this` scope is preserved)
When the interval changes the state i get the error i mentioned above.

Can you please help to understand where I'm wrong ?
Thanks

 I'm having the same issue on version 4.2.1. @maximilianschmitt If you are using a main template you can try to something like this:

`template.marko`
```
include(input.lasso)
<!doctype html>
html
  head
    app-head(input)
    lasso-head
  body
    div id="main-app"
      app-header(input)
      app-body(input)

    browser-refresh enabled="true"
    lasso-body

  <!--custom scripts-->
  <include(input.scripts)/>
```

`page.marko`

```
include('~/theme/html.marko')
    @lasso
        lasso-page package-path="./browser.json"
    @title -- Dashboard
    @body
        app-main
```

Notice the @lasso tag in the page.marko file. Instead of putting the `lasso-page package-path=".."` tag in the main template I delegated the page to send it to the main template that receive it at the top of the file with the tage `include(input.lasso)`

I don't know why but that solved the issue for me.
Furthermore I removed the component-browser.js file and write both the server and client logic inside the component.js file  Thanks for the clarification @patrick-steele-idem and @ovidius72! :)  I'm testing Marko for server-side and client-side rendering and I've been looking for a way to define the global variables (`out.global`) when bootstrapping client-side components. Is it possible?

At the moment I'm just seeing that `input` and `state` are passed from backend to client, but global variables are left blank in the page (and I rather use specific globals in the client).

Sample code (using intentionally bad practices):

server:
```
<h1>${out.global.title}</h1>

...

template.stream({
  $global: {
    title: 'Foo'
  }
});
```

client:
```
import component from '...';
import markoComponents from 'marko/components';
markoComponents.init();

// How can I define $global?
```

Thanks for the hard work. It's amazing how simple it is to have universal components with Marko. I'm not sure if I got it right. From what I see you're suggesting using the `onInput` handler to assign the global values in the server to the component input so it's serialized in the HTML for the client. Then in the client, the `onMount` handler is called and the serialized input is put again in the store with the globals. Am I right?

Apart from being a little "hacky" IMO, my problem with that approach is that the thing I'm putting in globals are functions, not serializable values. For more context, they're a translation function (which already has the locale and the translations set for the current request) and a function to get urls (which rely on an internal mapping, e.g.: '/img/logo.png' => 'https://some-cdn.com/img/logo-v1234.png'), among other things. I use dependency injection a lot and I'd like to inject the client-side versions of those functions in the template.

I can come up with a hack to do this but I wanted to know if the library itself provided access to the `out` object being used in the client. Would you consider implementing it o accepting a PR that did that? @patrick-steele-idem I like your approach because we work with the same interface `out.global` but you always have to define which propertys are serialized to the browser right? It would be nice if we could work in the same way as on server side. In my opinion "global" data shouldn't need manual adjustment in every component.

Intial state should be that the whole `$global` object will be serialized.

```marko
class {
}
```

```marko
<div>
    Title: ${out.global.title}
</div>
```

If you dont want to serialize everything we can define a whitelist (with some tooling)

```marko
class {
    get globals() {
        return ['title'] // only title
        return ['!title'] // all except title
        return ['foo.bar'] // only bar
        return [] // share nothing
    }
}
```
If you dont define a globals getter everything is shared.

```marko
<div>
    Title: ${out.global.title}
</div>
``` Sorry for the delay.

Before telling what my preference would be, take into account that I'm not using Marko in production, I'm still playing with it to evaluate if it fits my needs (my company's).

I think we should be able to pass top-level input and globals in the client initialization as we do with server-side rendering.

If in the server we do:

```javascript
template.stream({
  currentPage: 'Home page',
  $global: {
    staticUrl: () => { ... }
  }
});
```

We should be able to do so in the client:

```javascript
import component from '...';
import markoComponents from 'marko/components';
markoComponents.init({
  $input: {
    // Add variables to the serialized input
  },
  $replaceInput: {
    // Replace all serialized input
  },
  $global: {
    staticUrl: () => { ... } // client-side version
  },
  $replaceGlobal: {
    ...
  }
});
```

The problem with this approach, as far as I know, is that there's no guarantee that there will only be a single top-level component in the page, so passing these values to markoComponents.init could be problematic (although it'd solve my needs).

My use case is something like this (and it's already working with Nunjucks):

```javascript
$ const { staticUrl } = out.global;

<img src="${staticUrl('/img/logo.png')}">
```

@gilbert that pattern may work for me but I'd need many changes in my code to be able to import the function that resolves urls, as I rely a lot on dependency injection. The function that resolves urls is not so simple as appending the path to a variable CDN hostname, but all paths are mapped to a cache-friendly version. Also I don't think it's a good idea to use `out` as a global variable in `window`. In case this weren't possible having a reference to the `out` variable used to initialize components would also be enough:

```javascript
import component from '...';
import markoComponents from 'marko/components';
Object.assign(markoComponents.out.$global, {
  // My global variables
});
markoComponents.init();
```

Or having access to the serialized data:

```javascript
import component from '...';
import markoComponents from 'marko/components';
const serializedState = markoComponents.getSerializedState();
Object.assign(serializedState, {
  // My variables
});
markoComponents.init();
```
  Hi. Just read about Marko recently. Can Marko be used for mobile app development - does it have anything similar to React Native or Ionic? I'm using marko for a progressive web app, so i guess marko can do it

marko <3 mauricionr,

Can you talk a bit about how you do it? Do you use any other libraries/frameworks? Thanks. @mauricionr if you have the time, a write up or a github starter repo would be really appreciated. 

Grouping efforts towards building something like https://github.com/nuxt/nuxt.js for marko would be great, I'm willing to contribute, however it seems like there are still a few missing pieces to the puzzle such as client side routing. So an example of a barebones PWA with client side routing and offline capabilities would make a good starting point. I'm using the pwa [checklist](https://developers.google.com/web/progressive-web-apps/checklist) from google and the [sw-toolbox](https://github.com/GoogleChrome/sw-toolbox), and i'm not using client side routing.

@sebastianmacias @selforganized i will put the example in my repo :rocket: 

 @sebastianmacias @selforganized 

I started implement service worker in my demo at [PWA Road Show S√£o Paulo](https://events.withgoogle.com/pwa-roadshow-latin-america/#content)

checkout of my [demo repo](https://github.com/mauricionr/marko-pwa) and [live demo](https://lit-headland-75537.herokuapp.com/)

![image](https://cloud.githubusercontent.com/assets/2263551/24765410/0d67703a-1ace-11e7-86b6-3b96f0693b65.png)


Hope this can help with PWA :rocket:  @mauricionr thanks! will be checking it out later this week I will get some free time to improve them :) Bro , I need client side Routing mechanism for MarkoJS + Marko Widgets with SEO things .Please suggest me regarding   Hi again!

For a project I'm looking at building with Marko 4 (I'm on `Marko 4.2.0`), I want an `input` element to be autosized so that the width of the input always matches the width of its value. The following works fine for the most part:

```
static var autosize = require('autosize-input')

class {
  onMount() {
    // resize the input on input
    autosize(this.getEl('input'))
  }

  onChange(e) {
    this.emit('change', e.target.value)
  }
}

div
  input key='input' value=input.value on-input('onChange')
  -- ${input.value}
```

However, on the first input (e.g. entering a space) the `style` attribute (that the autosize-module sets) seems to be removed:

![marko-autosize](https://cloud.githubusercontent.com/assets/3694962/24577712/37153aec-16d3-11e7-971f-91822d449d6b.gif)

Full code: https://github.com/maximilianschmitt/lasso-test

I wonder if this is intentional behaviour? I've also tried manually resizing in the `onRender` and `onUpdate` hooks but this causes flickering.

Now finally I modified `autosize-input` to return the style and use Marko's state to update the `style` together with the `input`'s value. This solves my issue above but with this pattern the cursor of the `input` jumps to the end if I enter a character:

```
static var autosize = require('autosize-input')

class {
  onCreate() {
    this.state = { autosize: {} }
  }

  onMount() {
    var component = this

    // on every input, call my callback with the calculated style
    autosize(this.getEl('input'), null, function (style) {
      component.state.autosize = style
      component.setStateDirty('autosize')
    })
  }

  onChange(e) {
    this.emit('change', e.target.value)
  }
}

div
  input key='input' style=state.autosize value=input.value on-input('onChange')
```

![marko-autosize2](https://cloud.githubusercontent.com/assets/3694962/24577803/4c669560-16d5-11e7-9c4d-ed088b85a8d6.gif)

Full code: https://github.com/maximilianschmitt/lasso-test/tree/cursor-jump

Thanks for your help! :) Hey, thanks! Interesting to hear what caused the issue. `4.2.1` fixed it for me. :) Thank you!  Hi! When I'm developing I sometimes I edit several files for something to work. Sometimes however I receive the following error:

```
  Error: Render error. Exception: TypeError: renderFunc is not a function
      at safeRender (/home/karl/dev/instanty/node/node_modules/marko/runtime/renderable.js:6:9)
      at Template.render (/home/karl/dev/instanty/node/node_modules/marko/runtime/renderable.js:131:20)
      at Readable._read (/home/karl/dev/instanty/node/node_modules/marko/runtime/stream.js:44:17)
      at Readable.read (_stream_readable.js:350:10)
      at resume_ (_stream_readable.js:739:12)
      at _combinedTickCallback (internal/process/next_tick.js:80:11)
      at process._tickCallback (internal/process/next_tick.js:104:9)
      at AsyncStream.error (/home/karl/dev/instanty/node/node_modules/marko/runtime/html/AsyncStream.js:411:13)
      at Timeout._onTimeout (/home/karl/dev/instanty/node/node_modules/marko/runtime/renderable.js:12:22)
      at ontimeout (timers.js:380:14)
      at tryOnTimeout (timers.js:244:5)
      at Timer.listOnTimeout (timers.js:214:5)
```

That I receive and exception is brilliant. However it would be really *really* nice if it could reference where my application is breaking. Or am I missing something? Hi! Unfortunately I can't recreate it at will I'm afraid. It however does seem to popup for me quite often. Here is a longer log:

```
[browser-refresh] Triggering refresh of client styles...
[browser-refresh] Refresh triggered
[browser-refresh] Refresh triggered
[browser-refresh] File has been changed: src/client/components/app-footer/_flags.scss
[browser-refresh] Special reload: /src/client/components/app-footer/_flags.scss
[lasso] File modified: /home/karl/dev/instanty/node/src/client/components/app-footer/_flags.scss
[lasso/browser-refresh] StyleSheet modified: /home/karl/dev/instanty/node/src/client/components/app-footer/_flags.scss
[lasso] File modified: /home/karl/dev/instanty/node/src/client/components/app-footer/_flags.scss
[lasso/browser-refresh] StyleSheet modified: /home/karl/dev/instanty/node/src/client/components/app-footer/_flags.scss
[lasso] File modified: /home/karl/dev/instanty/node/src/client/components/app-footer/_flags.scss
[lasso/browser-refresh] StyleSheet modified: /home/karl/dev/instanty/node/src/client/components/app-footer/_flags.scss
[browser-refresh] Triggering refresh of client styles...
[lasso] File modified: /home/karl/dev/instanty/node/src/client/components/app-footer/_flags.scss
[lasso/browser-refresh] StyleSheet modified: /home/karl/dev/instanty/node/src/client/components/app-footer/_flags.scss
[lasso] File modified: /home/karl/dev/instanty/node/src/client/components/app-footer/_flags.scss
[lasso/browser-refresh] StyleSheet modified: /home/karl/dev/instanty/node/src/client/components/app-footer/_flags.scss
[lasso] File modified: /home/karl/dev/instanty/node/src/client/components/app-footer/_flags.scss
[lasso/browser-refresh] StyleSheet modified: /home/karl/dev/instanty/node/src/client/components/app-footer/_flags.scss
[lasso] File modified: /home/karl/dev/instanty/node/src/client/components/app-footer/_flags.scss
[lasso/browser-refresh] StyleSheet modified: /home/karl/dev/instanty/node/src/client/components/app-footer/_flags.scss
[lasso] File modified: /home/karl/dev/instanty/node/src/client/components/app-footer/_flags.scss
[lasso/browser-refresh] StyleSheet modified: /home/karl/dev/instanty/node/src/client/components/app-footer/_flags.scss
[lasso] File modified: /home/karl/dev/instanty/node/src/client/components/app-footer/_flags.scss
[lasso/browser-refresh] StyleSheet modified: /home/karl/dev/instanty/node/src/client/components/app-footer/_flags.scss
[lasso] File modified: /home/karl/dev/instanty/node/src/client/components/app-footer/_flags.scss
[lasso/browser-refresh] StyleSheet modified: /home/karl/dev/instanty/node/src/client/components/app-footer/_flags.scss
[lasso] File modified: /home/karl/dev/instanty/node/src/client/components/app-footer/_flags.scss
[lasso/browser-refresh] StyleSheet modified: /home/karl/dev/instanty/node/src/client/components/app-footer/_flags.scss
[lasso] File modified: /home/karl/dev/instanty/node/src/client/components/app-footer/_flags.scss
[lasso/browser-refresh] StyleSheet modified: /home/karl/dev/instanty/node/src/client/components/app-footer/_flags.scss
[lasso] File modified: /home/karl/dev/instanty/node/src/client/components/app-footer/_flags.scss
[lasso/browser-refresh] StyleSheet modified: /home/karl/dev/instanty/node/src/client/components/app-footer/_flags.scss
[lasso] File modified: /home/karl/dev/instanty/node/src/client/components/app-footer/_flags.scss
[lasso/browser-refresh] StyleSheet modified: /home/karl/dev/instanty/node/src/client/components/app-footer/_flags.scss
[lasso] File modified: /home/karl/dev/instanty/node/src/client/components/app-footer/_flags.scss
[lasso/browser-refresh] StyleSheet modified: /home/karl/dev/instanty/node/src/client/components/app-footer/_flags.scss
[lasso] File modified: /home/karl/dev/instanty/node/src/client/components/app-footer/_flags.scss
[lasso/browser-refresh] StyleSheet modified: /home/karl/dev/instanty/node/src/client/components/app-footer/_flags.scss
[lasso] File modified: /home/karl/dev/instanty/node/src/client/components/app-footer/_flags.scss
[lasso/browser-refresh] StyleSheet modified: /home/karl/dev/instanty/node/src/client/components/app-footer/_flags.scss
[lasso] File modified: /home/karl/dev/instanty/node/src/client/components/app-footer/_flags.scss
[lasso/browser-refresh] StyleSheet modified: /home/karl/dev/instanty/node/src/client/components/app-footer/_flags.scss
[lasso] File modified: /home/karl/dev/instanty/node/src/client/components/app-footer/_flags.scss
[lasso/browser-refresh] StyleSheet modified: /home/karl/dev/instanty/node/src/client/components/app-footer/_flags.scss
[lasso] File modified: /home/karl/dev/instanty/node/src/client/components/app-footer/_flags.scss
[lasso/browser-refresh] StyleSheet modified: /home/karl/dev/instanty/node/src/client/components/app-footer/_flags.scss
[lasso] File modified: /home/karl/dev/instanty/node/src/client/components/app-footer/_flags.scss
[lasso/browser-refresh] StyleSheet modified: /home/karl/dev/instanty/node/src/client/components/app-footer/_flags.scss
[lasso] File modified: /home/karl/dev/instanty/node/src/client/components/app-footer/_flags.scss
[lasso/browser-refresh] StyleSheet modified: /home/karl/dev/instanty/node/src/client/components/app-footer/_flags.scss
[lasso] File modified: /home/karl/dev/instanty/node/src/client/components/app-footer/_flags.scss
[lasso/browser-refresh] StyleSheet modified: /home/karl/dev/instanty/node/src/client/components/app-footer/_flags.scss
[lasso] File modified: /home/karl/dev/instanty/node/src/client/components/app-footer/_flags.scss
[lasso/browser-refresh] StyleSheet modified: /home/karl/dev/instanty/node/src/client/components/app-footer/_flags.scss
[lasso] File modified: /home/karl/dev/instanty/node/src/client/components/app-footer/_flags.scss
[lasso/browser-refresh] StyleSheet modified: /home/karl/dev/instanty/node/src/client/components/app-footer/_flags.scss
[lasso] File modified: /home/karl/dev/instanty/node/src/client/components/app-footer/_flags.scss
[lasso/browser-refresh] StyleSheet modified: /home/karl/dev/instanty/node/src/client/components/app-footer/_flags.scss
[lasso] File modified: /home/karl/dev/instanty/node/src/client/components/app-footer/_flags.scss
[lasso/browser-refresh] StyleSheet modified: /home/karl/dev/instanty/node/src/client/components/app-footer/_flags.scss
[lasso] File modified: /home/karl/dev/instanty/node/src/client/components/app-footer/_flags.scss
[lasso/browser-refresh] StyleSheet modified: /home/karl/dev/instanty/node/src/client/components/app-footer/_flags.scss
[lasso] File modified: /home/karl/dev/instanty/node/src/client/components/app-footer/_flags.scss
[lasso/browser-refresh] StyleSheet modified: /home/karl/dev/instanty/node/src/client/components/app-footer/_flags.scss
[lasso] File modified: /home/karl/dev/instanty/node/src/client/components/app-footer/_flags.scss
[lasso/browser-refresh] StyleSheet modified: /home/karl/dev/instanty/node/src/client/components/app-footer/_flags.scss
[lasso] File modified: /home/karl/dev/instanty/node/src/client/components/app-footer/_flags.scss
[lasso/browser-refresh] StyleSheet modified: /home/karl/dev/instanty/node/src/client/components/app-footer/_flags.scss
[browser-refresh] Triggering refresh of client styles...
[browser-refresh] Refresh triggered
[browser-refresh] Refresh triggered

  Error: Render error. Exception: TypeError: renderFunc is not a function
      at safeRender (/home/karl/dev/instanty/node/node_modules/marko/runtime/renderable.js:6:9)
      at Template.render (/home/karl/dev/instanty/node/node_modules/marko/runtime/renderable.js:131:20)
      at Readable._read (/home/karl/dev/instanty/node/node_modules/marko/runtime/stream.js:44:17)
      at Readable.read (_stream_readable.js:350:10)
      at resume_ (_stream_readable.js:739:12)
      at _combinedTickCallback (internal/process/next_tick.js:80:11)
      at process._tickCallback (internal/process/next_tick.js:104:9)
      at AsyncStream.error (/home/karl/dev/instanty/node/node_modules/marko/runtime/html/AsyncStream.js:411:13)
      at Timeout._onTimeout (/home/karl/dev/instanty/node/node_modules/marko/runtime/renderable.js:12:22)
      at ontimeout (timers.js:380:14)
      at tryOnTimeout (timers.js:244:5)
      at Timer.listOnTimeout (timers.js:214:5)

Render error. Exception: TypeError: renderFunc is not a function
    at safeRender (/home/karl/dev/instanty/node/node_modules/marko/runtime/renderable.js:6:9)
    at Template.render (/home/karl/dev/instanty/node/node_modules/marko/runtime/renderable.js:131:20)
    at Readable._read (/home/karl/dev/instanty/node/node_modules/marko/runtime/stream.js:44:17)
    at Readable.read (_stream_readable.js:350:10)
    at resume_ (_stream_readable.js:739:12)
    at _combinedTickCallback (internal/process/next_tick.js:80:11)
    at process._tickCallback (internal/process/next_tick.js:104:9)

  Error: Render error. Exception: TypeError: renderFunc is not a function
      at safeRender (/home/karl/dev/instanty/node/node_modules/marko/runtime/renderable.js:6:9)
      at Template.render (/home/karl/dev/instanty/node/node_modules/marko/runtime/renderable.js:131:20)
      at Readable._read (/home/karl/dev/instanty/node/node_modules/marko/runtime/stream.js:44:17)
      at Readable.read (_stream_readable.js:350:10)
      at resume_ (_stream_readable.js:739:12)
      at _combinedTickCallback (internal/process/next_tick.js:80:11)
      at process._tickCallback (internal/process/next_tick.js:104:9)
      at AsyncStream.error (/home/karl/dev/instanty/node/node_modules/marko/runtime/html/AsyncStream.js:411:13)
      at Timeout._onTimeout (/home/karl/dev/instanty/node/node_modules/marko/runtime/renderable.js:12:22)
      at ontimeout (timers.js:380:14)
      at tryOnTimeout (timers.js:244:5)
      at Timer.listOnTimeout (timers.js:214:5)

Render error. Exception: TypeError: renderFunc is not a function
    at safeRender (/home/karl/dev/instanty/node/node_modules/marko/runtime/renderable.js:6:9)
    at Template.render (/home/karl/dev/instanty/node/node_modules/marko/runtime/renderable.js:131:20)
    at Readable._read (/home/karl/dev/instanty/node/node_modules/marko/runtime/stream.js:44:17)
    at Readable.read (_stream_readable.js:350:10)
    at resume_ (_stream_readable.js:739:12)
    at _combinedTickCallback (internal/process/next_tick.js:80:11)
    at process._tickCallback (internal/process/next_tick.js:104:9)
```

To get rid of the error I just have to stop my npm script `npm run dev` and start it up again, where I got the following error:

```
  Error: An error occurred while trying to compile template at path "/home/karl/dev/instanty/node/src/client/components/app-footer/index.marko". Error(s) in template:
  1) [src/client/components/app-footer/index.marko:32:0] The closing "footer" tag does not match the corresponding opening "span" tag
  
      at handleErrors (/home/karl/dev/instanty/node/node_modules/marko/compiler/Compiler.js:82:21)
      at Compiler.compile (/home/karl/dev/instanty/node/node_modules/marko/compiler/Compiler.js:151:9)
      at _compile (/home/karl/dev/instanty/node/node_modules/marko/compiler/index.js:89:33)
      at Object.compile (/home/karl/dev/instanty/node/node_modules/marko/compiler/index.js:103:12)
      at doLoad (/home/karl/dev/instanty/node/node_modules/marko/runtime/loader/index-default.js:133:45)
      at load (/home/karl/dev/instanty/node/node_modules/marko/runtime/loader/index-default.js:5:16)
      at Object.<anonymous> (/home/karl/dev/instanty/node/src/client/components/app__sign-in/index.marko.js:21:27)
      at Module._compile (module.js:571:32)
      at loadSource (/home/karl/dev/instanty/node/node_modules/marko/runtime/loader/index-default.js:47:20)
      at doLoad (/home/karl/dev/instanty/node/node_modules/marko/runtime/loader/index-default.js:140:24)
```

The error above is expected as my code isn't correct.

So the rendersync error seems to happen when I use browser refresh, I edit a file which is incorrect, it trys to re-render and then tries to update the client. As stated, to fix the rendersync error I just have to manually stop and start my `npm run dev` script.

My `npm run dev` is as follows: `"NODE_ENV=development NODE_PATH=\"$(pwd)\" browser-refresh --nolazy --inspect=9229 src/index.js"`

I'll update if I see anything new or figure out a pattern.  Hi!

I've been developing with React for the past 2 years and using Marko really feels nice and fresh. :) I love how fast and lightweight it feels

But one thing I couldn't figure out and found no examples for, is keeping the `value` of an `input` in sync with the component's `state`. With React, you do `<input value={state.value} onChange={this.onChange} />` where `onChange` calls `setState({ value: e.target.value })` and it just works.

Intuitively I thought the correct way to go about this in Marko would be to do something like this:

```
class {
  onCreate() {
    this.state = { value: 'Hello' }
  }

  handleInput(e) {
    this.state.value = e.target.value
  }
}

input value=state.value on-input('handleKeydown')
-- ${state.value}
```

`keyDown` is being called, however the component is not rerendering if I type in the input. The text next to it (`-- ${state.value}`) always says `Hello`. Also, the `input` only seems to pick up every second character I type in. If I add a `setStateDirty('value')` to my `handleInput`-function, the input's value always stays at `Hello`. I can tell (by logging) that in this case the component is rerendering (with no visible result though).

Is my approach fundamentally wrong? How do you normally keep state and input components in sync?

Thanks for your help!

Best,
Max @mindeavor ah, thank you! :)  ## Bug Report

### Context

At markojs.com, clicking the tab next to "Color picker" gives a js error.

### Expected Behavior

Switch tabs.

### Actual Behavior

Error.

### Possible Fix

I'm totally new here.

<details><summary>Additional Info</summary>

### Your Environment
<!-- Include as many relevant details about the environment you experienced the bug in -->
* Version used: n/a
* Environment name and version (e.g. Chrome 39, node.js 5.4): Chromium Version 56.0.2924.76 Built on Ubuntu , running on LinuxMint 18.1 (64-bit)
* Operating System and version (desktop or mobile): ibid
* Link to your project: n/a

### Steps to Reproduce
1. load markojs.com
2. open error console (clean at this point)
3. click said link

### Stack Trace

```
Uncaught Error: Not allowed
    at h.beginAsync (index-83c75fc1.js:63)
    at c.exports (index-83c75fc1.js:110)
    at index-83c75fc1.js:111
    at b.f (index-83c75fc1.js:71)
    at h._ (index-83c75fc1.js:111)
    at index-83c75fc1.js:112
    at b.f (index-83c75fc1.js:71)
    at g._.l.r.type (index-83c75fc1.js:112)
    at index-83c75fc1.js:55
    at index-83c75fc1.js:47
beginAsync @ index-83c75fc1.js:63
c.exports @ index-83c75fc1.js:110
(anonymous) @ index-83c75fc1.js:111
b.f @ index-83c75fc1.js:71
h._ @ index-83c75fc1.js:111
(anonymous) @ index-83c75fc1.js:112
b.f @ index-83c75fc1.js:71
g._.l.r.type @ index-83c75fc1.js:112
(anonymous) @ index-83c75fc1.js:55
(anonymous) @ index-83c75fc1.js:47
b._t @ index-83c75fc1.js:41
_S @ index-83c75fc1.js:47
update @ index-83c75fc1.js:47
h @ index-83c75fc1.js:41
f @ index-83c75fc1.js:41
(anonymous) @ index-83c75fc1.js:41
```

</details>
  ## Bug Report

### Expected
I try to build Mixin  mechanism for enhancing marko componentÔºå unfortunately, it seems component instance was created out of normal way. 

### Code

[___mixins.js : L5 - L13___](https://github.com/wujjpp/marko-starter-kit/blob/master/src/core/mixins/mixins.js#L5-L13)

```
export default (...mixins) => {
  class MixedComponent {}
  for (let mixin of mixins) {
    for (let name of Object.keys(mixin)) {
      MixedComponent.prototype[name] = mixin[name]
    }
  }
  return MixedComponent
}
```

[___history-mixin.js : L1 - L6___](https://github.com/wujjpp/marko-starter-kit/blob/master/src/core/mixins/history-mixin.js#L1-L6)
```
export default {
  funcInMixin() {
    console.log('funcInMixin called')
  }
}
```

[___component.js : L5 - L23___](https://github.com/wujjpp/marko-starter-kit/blob/master/src/routes/mixin/components/app-main/component.js#L5-L23)
```
import {
  Mixins,
  HistoryMixin
} from '../../../../core/mixins'

var MixedBaseClass = Mixins(HistoryMixin)

class Bar extends MixedBaseClass {}

export default class MyClass extends MixedBaseClass {
  foo() {
    //the following 2 lines codes are working as expected.
    var bar = new Bar()
    bar.funcInMixin() //print 'funcInMixin called' in console

    // In fact,we want component instance has mixed function `funcInMixin`
    // Unfortunately `this.funcInMixin` is undefined, it caused unhandled exception
    this.funcInMixin()
  }
}
``` @patrick-steele-idem Thanks for your help, it works.

___foo-mixin.js___
```JavaScript
export default {
  foo() {
    console.log('function called in foo mixin')
  }
}
```

___bar-mixin.js___
```JavaScript
export default {
  bar() {
    console.log('function called in bar mixin')
  }
}
```
___mixins.js___
```JavaScript
export default (...mixins) => (component) => {
  for (let mixin of mixins) {
    Object.assign(component.prototype, mixin)
  }
  return component
}
```
___component.js___
```JavaScript
import {
  Mixins,
  FooMixin,
  BarMixin
} from '../../../../core/mixins'

class MyComponent {
  callFunc() {
    this.bar()
    this.foo()
  }
}

export default Mixins(FooMixin, BarMixin)(MyComponent)
```
  `macro` needs to be rewritten!!

```marko
   <if(xxx)>
      <macro yy()>
        ... if ...
      </macro>
   </if>
   <else>
      <macro yy()>
         .. else ...
      </macro>
   </else>
```

```javascript
"use strict";
function render(input, out) {
	if(xxx){
		function macro_yy(){
			out.w("... if ...");
		}
	}else{
		function macro_yy(){
			out.w("... else ...");
		}
	}

	macro_yy();   //  it will be throw 'ReferenceError: macro_yy is not defined'  in strict model

}

``` @mindeavor Yeah, that's what I'm doing

```marko
<macro yy()>
   <if(xxx)>
      ... if ...
   </if>
   <else>
      ... else ...
   </else>
</macro>
``` @patrick-steele-idem  thanks  ## Bug Report
NOTE: I'm not sure if it is a BUG, but the vue's behavior is we wanted.

### Code

___/routes/index/index.marko___
```
<html>
  <head>
    <title>Welcome | Marko Demo</title>    
    <script src="https://unpkg.com/jquery"/>
    <script src="https://unpkg.com/easy-pie-chart/dist/jquery.easypiechart.min.js"/>
  </head>
  <body>
    <app-main/>
  </body>
</html>
```

___/routes/index/components/app-main/index.marko___
```
style {
  .chart {
    position: relative;
    display: inline-block;
    width: 110px;
    height: 110px;
    margin-top: 50px;
    margin-bottom: 50px;
    text-align: center;
  }
  .chart canvas {
    position: absolute;
    top: 0;
    left: 0;
  }
  .percent {
    display: inline-block;
    line-height: 110px;
    z-index: 2;
  }

  .percent:after {
    content: '%';
    margin-left: 0.1em;
    font-size: .8em;
  }
}

class {
    constructor() {
        this.state = { count:0 };
    }
    onMount(){
      $('.chart').easyPieChart({
        easing: 'easeOutBounce',
        onStep: function(from, to, percent) {
          $(this.el).find('.percent').text(Math.round(percent))
        }
      })
      this.chart = $('.chart').data('easyPieChart')
      this.chart.update(Math.round(Math.random() * 200 - 100))
    }

    inc() {
        this.state.count++
    }
    dec(){
      this.state.count--
    }

    updateChart(){
      this.chart.update(Math.round(Math.random() * 200 - 100))
    }
}
<div id="app">
  <div>
    <span>Count: ${state.count}</span>
    <button onClick("inc")>inc</button>
    <button onClick("dec")>dec</button>
    <span>--> Click the "+" or "-" button, will cause canvas(generated by easy pie chart plugin) be removed, vue doesn't has this issue</span>
  </div>
  <div>
    <span class="chart">
      <span class="percent"/>
    </span>
    <button onClick("updateChart")>Update chart</button>
  </div>
</div>

```
### Steps
After page loaded, the easyPieChart create a canvas inside `<span class="chart"><canvas ..... /></span>`, if you click `Update chart` button, the chart will be refreshed, all things goes well, but if you click `inc` or `dec` button, the canvas disappeared.  actually, we want canvas keep in document.

Vue has the right behavior(we wanted), I have created the same [demo app of vue version](https://jsfiddle.net/wujjpp/or132f6L/) 

Also, I have uploaded the [marko version of  demo app](https://github.com/wujjpp/marko-vdom-issue.git)


 @mindeavor Thanks for your reply, and fixed issue in this case.  but it cause `<span class="percent">${Math.round(state.percent)}</span>`  no longer to be updated.
Although, we can create special DOM structure to avoid the issue, but it make DOM structure more complex. Anyway, **Thanks for your solution again.**

[___template.marko : L58-L64___](https://github.com/wujjpp/marko-starter-kit/blob/master/src/routes/test/components/app-main/index.marko#L58-L64)
```
<div class="col-md-12">     
      <span class="chart" no-update>
        <span class="percent">${Math.round(state.percent)}</span>      
      </span>
      <span class="btn btn-default" onClick('updateChart')>Update chart</span>
</div>
```
[___component.js : L8-L51___](https://github.com/wujjpp/marko-starter-kit/blob/master/src/routes/test/components/app-main/component.js#L8-L51)
```
export default class Test {
  onMount() {   
    $('.chart').easyPieChart({
      easing: 'easeOutBounce',
      onStep: function(from, to, percent) {
        //$(this.el).find('.percent').text(Math.round(percent))
      }
    })
    this.chart = $('.chart').data('easyPieChart');
    this.chart.update(this.state.percent)
  }
  ...
  updateChart() {   
    this.state.percent = Math.random() * 200 - 100
    this.chart.update(this.state.percent)
  }
```

  @mindeavor Correct, create special DOM structure for handling.
 @mindeavor I have another question: 
what's the difference between "input" and "state"? like "props" and "state" in react? @mindeavor Thanks  ### Open Questions
<!--- What still needs to be discussed -->
I understand marko can be used with a number of server side frameworks like express that handle URL dispatching but does it include any client side router or are any plans to support this?

Thanks I like the JSX-syntax support in React Router. Also need solid support of server-side rendering. The Inferno port of React Router is probably worth looking at: https://github.com/infernojs/inferno/tree/master/packages/inferno-router Any update on this? 

Besides the router I think a router-link core component would be needed,  similar to this: https://router.vuejs.org/en/api/router-link.html  :+1: Maybe something like `<taglib('./path/to/taglib') />` or `<marko-tag('./path/to/tag.marko') />`, to avoid overloading `import`? I agree with @mindeavor that auto-detection has worked extremely well. 

Are you proposing this change instead of defining a `tags-dir` withn a `marko.json`?  Looks like bug is fixed. I just reinstall all my modules and now everything work like expected I'm getting this error: 

`Uncaught TypeError: component.$__setCustomEvents is not a function`

when using multi files structure for components and exporting as a class.  `module.exports = class {}.`
It works when a literal object is exported `module.exports = {}.`
 
marko version is  4.2.0
node: 6.10  <!----------------------
  |     IF BUG REPORT    |
  ---------------------->
## Bug Report

I'm trying to use `$!{}` to output some HTML that is generated on the server, but it's not rendering.

### Context
<!--- Provide a more detailed introduction to the issue itself, and why you consider it to be a bug.  How has this bug affected you? What were you trying to accomplish? -->

I am passing an `input` tag like this: `<input type="text" value="" />`. Looking at the element in chrome devtools it looks like:  `<INPUT type="text" value=""></INPUT>`. If I edit the element in devtools to be like the input it works fine.

### Expected Behavior
<!--- Tell us what should happen -->

It should output: `<input type="text" value="" />`

### Actual Behavior
<!--- Tell us what happens instead -->
It outputs:  `<INPUT type="text" value=""></INPUT>`
### Possible Fix
<!--- Not obligatory, but suggest a fix or reason for the bug -->

<details><summary>Additional Info</summary>

### Your Environment
<!-- Include as many relevant details about the environment you experienced the bug in -->
* Version used: 4.1.3
* Environment name and version (e.g. Chrome 39, node.js 5.4): Node 6.9.2
* Operating System and version (desktop or mobile): Ubuntu 16.04

### Steps to Reproduce
<!--- Provide a link to a live example, or an unambiguous set of steps to -->
<!--- reproduce this bug include code to reproduce, if relevant -->
Add the following component to your app:

```
class {

  onCreate() {
    this.state = {
      html: "<input type='text' name='test' value='x' />"
    }
  }
}

<div>$!{state.html}</div>
```
<!-- If an error is thrown, provide the stack trace here -->

</details>
 A regular `div` tag works fine, although the tag is upper-cased. An `img` tag has the same problems as `input`, so it seems to be a problem with tags that don't require a closing tag. Excellent. Thank you.  Related to: https://github.com/marko-js/marko/issues/619

<!--- Provide a general summary of your changes in the Title above -->
Replaced constructor with onCreate
## Description
<!--- Describe your changes in detail -->

## Motivation and Context
<!--- Why is this change required? What problem does it solve? -->
<!--- If it fixes an open issue, please link to the issue here. -->

## Screenshots (if appropriate):

## Checklist:
<!--- Go over all the following points, and put an `x` in all the boxes that apply. -->
<!--- If you're unsure about any of these, don't hesitate to ask. We're here to help! -->
- [ ] My code follows the code style of this project.
- [ ] I have updated/added documentation affected by my changes.
- [ ] I have read the **CONTRIBUTING** document.
- [ ] I have added tests to cover my changes.
- [ ] All new and existing tests passed.
 
[![Coverage Status](https://coveralls.io/builds/10717211/badge)](https://coveralls.io/builds/10717211)

Coverage remained the same at 90.093% when pulling **3558b5a0dff24ec65d0b29d7c4b6017c9e41ca83 on basickarl:patch-1** into **e24c00eb8b34242173a81eaee3a0c1e6ce4d54b7 on marko-js:master**.
  ### Context

Hey @patrick-steele-idem , i'm using marko v3 in production and i'm trying to convince my team to upgrade to marko v4

I'm trying to find the performance diff between v3 and v4

Do you guys know where i can find? or do you guys have something to help me speed up this upgrade

Thanks! Both :rocket:  Really Thanks in advance @patrick-steele-idem :beers:   Updated `counter.marko` example in `ReadME.md` file to use `onCreate()` instead of `constructor()` 
[![Coverage Status](https://coveralls.io/builds/10645416/badge)](https://coveralls.io/builds/10645416)

Coverage remained the same at 90.093% when pulling **3b3e10d1e156a93d65b752cacc4d494c0f6e1ca4 on krypton97:master** into **3c604ed11f2b815ea4fe369471a2555b03383399 on marko-js:master**.
  You actually can serialize functions, I'm working on a dashboard using VueJS that takes advantage of that.  with nunjucks i can {{ var | dump }}, what is the equivalent for marko? @patrick-steele-idem Yes, deleted my comment. ;-)  ### Open Questions
How do you implement css in isolation with markojs?  With the movement of component based authoring instead of document.  People found that its better to isolate css selectors to per component as opposed to its default cascading nature.

Is this something marko js aim to solve?

### Is this something you're interested in working on?
Yes
 Do you mean having a separate stylesheet for each component? You can either use the new `style { ... }` tag, or put a `style.css` in the component's directory and make sure your bundler finds it.

If you mean actually *restricting* the CSS to specific sections of the final document, as far as I know that's not possible (except in Firefox with `<style scoped>`). Other frameworks just quietly add extra classes and selectors to make it *look* that way. More of the latter,

It's not possible doing it in css alone.  However, it is possible with the help of a build step. Basically obfuscating the classname with hashes eg. `.container` _becomes_ `.cn2o3j`.

Prior art are css-modules, styled-components, styled-jsx.
 This is one of the reasons I'm still using Vue.js. It has support for scoped CSS via classname injection.

The other reason is that .vue files are just HTML files, so you don't need to use prefixes like `$` or `-`, and they don't need their own editor extensions for syntax highlighting. @mindeavor, I don't want to derail this topic, but .vue files support `<script>` and `<style>` elements,  so there's no need to put your JavaScript in a string.

And according to the [HTML spec](https://html.spec.whatwg.org/multipage/syntax.html#attributes-2), there's nothing wrong with dots in attribute names.

See [Single File Components](https://vuejs.org/v2/guide/single-file-components.html) for more information.

![image](https://cloud.githubusercontent.com/assets/468153/24052357/3882643a-0b03-11e7-874e-d47865057648.png) @patrick-steele-idem I think I'm leaning towards Vue's implementation as a recommendation. Which is just hooking up to post-css.  With post-css you can basically create any transform you want, sass, less, css-modules.

Since we'll all shoving this down to compiler step.  There won't be any added bulk to the final output.

 +1 Vue like implementation Random idea: if the style processing can actually take a list of processors then a `scoped` processor could perhaps be created. This would allow things such as `style.scoped { ... }` and `style.less.scoped { ... }`. +1 Vue like implementation :+1:   On a related note, should `class { ... }` be renamed to `component { ... }`? That seems like a more accurate description, fits better with the theme (`style { }` => `style.css`, `component { }` => `component.js`), and would be less likely to confuse new users who expect it to behave like an ES6 `class`. I use a lot of classes outside of Marko specific code and use the onCreate method instead of the constructor method to avoid confusion. I advocate removing the `constructor` method and standardize the `onCreate` method across both `module.exports` and the `Marko` class component definition.   <!--- Provide a general summary of your changes in the Title above -->

## Description
The `await` tag basic implementation and advanced use signature.

## Motivation and Context
I wanted to fill in the basic implementation because it's so handy. If you think this will help users I will also volunteer to document the advanced usage but doing so could take a whole page. Your thoughts?

## Screenshots (if appropriate):

## Checklist:
<!--- Go over all the following points, and put an `x` in all the boxes that apply. -->
<!--- If you're unsure about any of these, don't hesitate to ask. We're here to help! -->
- [x] My code follows the code style of this project.
- [x] I have updated/added documentation affected by my changes.
- [x] I have read the **CONTRIBUTING** document.
- [ ] I have added tests to cover my changes.
- [ ] All new and existing tests passed.
 
[![Coverage Status](https://coveralls.io/builds/10542523/badge)](https://coveralls.io/builds/10542523)

Coverage remained the same at 86.815% when pulling **2ed2fe3e6c9d5b4ee62645871d490682c7d66ec1 on tcrowe:await-docs-basic** into **bce2727c60a1072aaaef3cff682408a079b9977a on marko-js:master**.
 
[![Coverage Status](https://coveralls.io/builds/10542570/badge)](https://coveralls.io/builds/10542570)

Coverage remained the same at 86.815% when pulling **2b05f8d5803af2a70f20e53ba1f78a88c969ec6e on tcrowe:await-docs-basic** into **bce2727c60a1072aaaef3cff682408a079b9977a on marko-js:master**.
 
[![Coverage Status](https://coveralls.io/builds/10542629/badge)](https://coveralls.io/builds/10542629)

Coverage remained the same at 86.815% when pulling **623610bf0262af56826812359387ff9b7f8003a3 on tcrowe:await-docs-basic** into **bce2727c60a1072aaaef3cff682408a079b9977a on marko-js:master**.
 @mindeavor Yes you can. You can discover a lot about it from here:
https://github.com/marko-js/marko/search?utf8=%E2%9C%93&q=await You're welcome! üëç   <!----------------------------------------------------------------------
  |     IF FEATURE SUGGESTION (skip to next section for bug reports)    |
  ---------------------------------------------------------------------->
## New Feature

### Description
<!--- Provide a detailed description of the change or addition you are proposing -->

### Context
<!--- Why is this change important to you? How would you use it? -->
<!--- How can it benefit other users? -->

### Possible Implementation
<!--- Not obligatory, but suggest an idea for implementing addition or change -->

### Open Questions
<!--- What still needs to be discussed -->

### Is this something you're interested in working on?
<!--- Yes or no -->

<!----------------------
  |     IF BUG REPORT    |
  ---------------------->
## Bug Report
I started out following the webpack-marko integration tutorial on http://markojs.com/docs/webpack/
and got the error message "error in cannot find module 'marko/compiler' " even with webpack version 1.14.0.

### Context
<!--- Provide a more detailed introduction to the issue itself, and why you consider it to be a bug.  How has this bug affected you? What were you trying to accomplish? -->

![image](https://cloud.githubusercontent.com/assets/26175060/23806596/203176dc-0577-11e7-9360-70c1c5e68089.png)

### Expected Behavior
<!--- Tell us what should happen -->

### Actual Behavior
<!--- Tell us what happens instead -->

### Possible Fix
<!--- Not obligatory, but suggest a fix or reason for the bug -->

<details><summary>Additional Info</summary>

### Your Environment
<!-- Include as many relevant details about the environment you experienced the bug in -->
* Version used:
* Environment name and version (e.g. Chrome 39, node.js 5.4):
* Operating System and version (desktop or mobile):
* Link to your project:

### Steps to Reproduce
<!--- Provide a link to a live example, or an unambiguous set of steps to -->
<!--- reproduce this bug include code to reproduce, if relevant -->
1. 
2. 
3. 
4. 

### Stack Trace
<!-- If an error is thrown, provide the stack trace here -->

</details>
 I think this is because `marko-loader` does not depend on the `marko` package.  If you install the marko package this should work:

```sh
npm install --save-dev marko
# or
yarn add --dev marko
``` To be clear, this is consistent behavior for any webpack `*-loader`: For example, when using the babel-loader, babel-core needs to be installed separately. Try this , if you like [marko starter kit](https://github.com/wujjpp/marko-starter-kit)  <!----------------------
  |     IF BUG REPORT    |
  ---------------------->
## Bug Report

### Context
<!--- Provide a more detailed introduction to the issue itself, and why you consider it to be a bug.  How has this bug affected you? What were you trying to accomplish? -->
I was working on a personal project and wanted to replace an existing rendered component with the newly rendered one using the following code:

```javascript
var $featured = document.querySelector('.featured_fish');
var featuredFish = require('../fh-featured-fish');

// featuredFish reference: 
//  https://gist.github.com/pcanella/da7eb300409034ed93c2ffe7525ed656

featuredFish.render(f).then(function(result){
        result.replace($featured);
});
```

Then, in console I get the following issue 

`Uncaught (in promise) TypeError: destroyElRecursive is not a function(‚Ä¶)beforeRemove @ bundle.js:3670replace @ bundle.js:3691(anonymous function) @ bundle.js:5274`


### Expected Behavior
<!--- Tell us what should happen -->
Ideally, it should just replace the dom element, right?

### Actual Behavior
<!--- Tell us what happens instead -->
`Uncaught (in promise) TypeError: destroyElRecursive is not a function(‚Ä¶)beforeRemove @ bundle.js:3670replace @ bundle.js:3691(anonymous function) @ bundle.js:5274`

### Your Environment
<!-- Include as many relevant details about the environment you experienced the bug in -->
* Version used: V4
* Environment name and version: Version 54.0.2840.71 (64-bit)
* Operating System and version (desktop or mobile): OS X on Chrome
* Link to your project: Not up yet, so I really don't have a repo at the moment...

### Stack Trace
<!-- If an error is thrown, provide the stack trace here -->
`Uncaught (in promise) TypeError: destroyElRecursive is not a function(‚Ä¶)beforeRemove @ bundle.js:3670replace @ bundle.js:3691(anonymous function) @ bundle.js:5274`
</details>
 @patrick-steele-idem ah! I am actually using browserify/markoify for this specific instance. This is my script I run before `app.js` runs

`"browserify -g markoify --extension='.marko' assets/js/main.js -o assets/js/bundle.js`

My "main.js" file just has some document level event binding (working on getting rid of that, but it doesn't really affect marko at all)  Don't understand. Why not just use a function? @andersea It actually hooks into a built-in extension system that's been part of `require()` since almost the beginning, but it has also been deprecated for nearly as long ([require.extensions](https://nodejs.org/api/globals.html#globals_require_extensions)).

It was originally decided that the added convenience outweighed the risk (#78). However, with the related changes Patrick mentioned, this may be the perfect time to rethink that.

Also, it's not *necessary* to use the extension, the old way still works without it:
```js
var template = require('marko').load(require.resolve('./path/to/template.marko'));
``` Thanks for that answers. Closing.  Koa 2.0.1 is released as `latest` version, so, these docs needs to be updated. Also added gzip example to feature Koa + Marko streaming flexibility. 
[![Coverage Status](https://coveralls.io/builds/10482007/badge)](https://coveralls.io/builds/10482007)

Coverage remained the same at 87.104% when pulling **f6af3372e757fff3c414dc3702a9675919860074 on tinovyatkin:master** into **aec7ae301361754943aabbaca52464188a0f28f1 on marko-js:master**.
  <!--- Provide a general summary of your changes in the Title above -->

## Description
The developer can `require` marko files then use component auto init.

I found out about it in the [marko-webpack/src/pages/home/client.js](https://github.com/marko-js-samples/marko-webpack/blob/master/src/pages/home/client.js) file.

## Motivation and Context
It may be helpful to include it in the documentation.

## Checklist:
<!--- Go over all the following points, and put an `x` in all the boxes that apply. -->
<!--- If you're unsure about any of these, don't hesitate to ask. We're here to help! -->
- [x] My code follows the code style of this project.
- [x] I have updated/added documentation affected by my changes.
- [x] I have read the **CONTRIBUTING** document.
- [ ] I have added tests to cover my changes.
- [ ] All new and existing tests passed.
 
[![Coverage Status](https://coveralls.io/builds/10456017/badge)](https://coveralls.io/builds/10456017)

Coverage decreased (-2.8%) to 87.074% when pulling **25c38059755b1f6b6ac81af4a94b2525a77a8417 on tcrowe:comp-auto-init** into **6e5f5fe4f3cc02abcb124097254dc8c13d1534fe on marko-js:master**.
 
[![Coverage Status](https://coveralls.io/builds/10456017/badge)](https://coveralls.io/builds/10456017)

Coverage decreased (-2.8%) to 87.074% when pulling **25c38059755b1f6b6ac81af4a94b2525a77a8417 on tcrowe:comp-auto-init** into **6e5f5fe4f3cc02abcb124097254dc8c13d1534fe on marko-js:master**.
 
[![Coverage Status](https://coveralls.io/builds/10456017/badge)](https://coveralls.io/builds/10456017)

Coverage decreased (-2.8%) to 87.074% when pulling **25c38059755b1f6b6ac81af4a94b2525a77a8417 on tcrowe:comp-auto-init** into **6e5f5fe4f3cc02abcb124097254dc8c13d1534fe on marko-js:master**.
  I noticed that docs for express integration just have you `require('marko/express')`, which means it's using the side-effect pattern to modify the global `express.response` object.

The typical express middleware pattern would be:

```js
const express = require('express')
const marko = require('marko/express')

const app = express()
app.use(marko)
```

Is there a specific reason marko/express doesn't use the middleware pattern?

Looking at [marko/express.js](https://github.com/marko-js/marko/blob/v4.0.0/express.js), it doesn't seem like it needs to cause side-effects to integrate with express.

Using side-effects instead of the middleware pattern means that you can't isolate marko integration to a specific express app, route, or path. Granted, the current implementation is opt-in (you only call `res.marko` if you need to) but if more features are added to express integration, the inability to isolate the integration may become a problem.  I am new to Marko, and I found a tricky error when I try to layout the html page in sections.

src/component/app-sections/index.marko
```html
<div class="panel-body" style="background-color: #eee;">
      <form class="form-horizontal" key="anything" role="form">
         <div class="form-group" for(section in data.sections)>
          <label class=['col-md-3', 'control-label'] style="text-align: left;">
            ${section.label} <if(section.requiredField)><span.field_req_designator>*</span></if>
          </label>
          <div class='col-md-9'>
            <include(section)/>
          </div>
      </form>
</div>
```

When I add "key" attribute like this `<form class="form-horizontal" key="anything" role="form">`, it will report such an error below. If I removed the key, everything compiles fine.
```
[marko/hot-reload] Template successfully reloaded: /Users/dofu/git/epnportal/src/components/app-sections/index.marko.js
events.js:160
      throw er; // Unhandled 'error' event
      ^

Error: Async fragment failed. Exception: Error: No component found
    at Error (native)
    at getCurrentComponent (/Users/dofu/git/epnportal/node_modules/marko/components/taglib/helpers/getCurrentComponent.js:13:15)
    at Object.render (/Users/dofu/git/epnportal/src/components/app-sections/index.marko.js:20:21)
    at hotReloadProxy (/Users/dofu/git/epnportal/node_modules/marko/hot-reload/index.js:82:31)
    at Object.render (/Users/dofu/git/epnportal/src/components/app/index.marko.js:62:3)
    at hotReloadProxy (/Users/dofu/git/epnportal/node_modules/marko/hot-reload/index.js:82:31)
```

The rest pieces of code:
~/src/component/app/index.marko
```html
<div>
  <app-sections>
    <@section label='Advertiser' requiredField=true>
      <app-dropbox name='advertiser' options=dropboxAdvertiser />
    </@section>
</div>
```

~/src/component/app-sections/marko-tag.json
```json
{
  "@sections <section>[]": {
    "@label": "string",
    "@requiredField": "boolean",
    "@*": "string"
  }
}
```

I am really excited to see Marko v4 coming out with many new features, bravo! @mindeavor In the [official document](http://markojs.com/docs/components/#codekeycode), it mentions:  
The key attribute can be applied to **both HTML elements and custom tags for UI components**. If applied to an HTML element, a unique id attribute will be added to the HTML element. The assigned ID will be a concatenation of the parent component ID with the provided value of the key attribute.

I think my use case is to apply on the html element. And, later, I can use `this.getEl(elId)` to manipulate the DOM. @patrick-steele-idem Thanks for the clarification, that makes sense!  ## Bug Report

### Context
I'm trying to use a single-file component as `components/{name}.marko` instead of `components/{name}/index.marko`.

### Expected Behavior
App starts and is able to serve that page (localhost:8000).

### Actual Behavior
The stacktrace below is thrown when the app starts.

### Your Environment
* Version used:
  * marko 4.0.0
  * lasso 2.11.5
  * lasso-marko 2.3.0

### Steps to Reproduce
1. clone https://github.com/drewfish/marko-bug606
2. run `npm install`
3. run `node server.js` and see the error as mentioned

### Stack Trace
```
/Users/drew/dev/node-moomet/research/bugx/node_modules/marko/compiler/Compiler.js:84
        throw error;
        ^

Error: An error occurred while trying to compile template at path "/Users/drew/dev/node-moomet/research/bugx/components/page-meter/index.marko". Error(s) in template:
1) [components/page-meter/index.marko:9:13] Unrecognized tag: meter-channel - More details: https://github.com/marko-js/marko/wiki/Error:-Unrecognized-Tag

    at handleErrors (/Users/drew/dev/node-moomet/research/bugx/node_modules/marko/compiler/Compiler.js:82:21)
    at Compiler.compile (/Users/drew/dev/node-moomet/research/bugx/node_modules/marko/compiler/Compiler.js:151:9)
    at _compile (/Users/drew/dev/node-moomet/research/bugx/node_modules/marko/compiler/index.js:89:33)
    at Object.compile (/Users/drew/dev/node-moomet/research/bugx/node_modules/marko/compiler/index.js:103:12)
    at compile (/Users/drew/dev/node-moomet/research/bugx/node_modules/marko/node-require.js:52:38)
    at Object.markoRequireExtension [as .marko] (/Users/drew/dev/node-moomet/research/bugx/node_modules/marko/node-require.js:120:27)
    at Module.load (module.js:487:32)
    at tryModuleLoad (module.js:446:12)
    at Function.Module._load (module.js:438:3)
    at Module.require (module.js:497:17)
``` Hmm... it looks like I can workaround this by adding entries to my marko.json like this:
```json
{
    "<meter-channel>": {
        "renderer": "./components/meter-channel.marko"
    },
    "tags-dir": "./components"
}
``` Looking at the implementation of compiler/taglib-loader/scanTagsDir.js this might be a feature request (instead of a bug) üòÑ   ## Bug Report

### Context
When a component `class` has a parsing issue, the exception thrown has a typo. Additionally, `Error:` is appended to the message twice.

### Expected Behavior
The error should read: `Unable to parse JavaScript for **component** class.`

### Actual Behavior
The error output is: `Unable to parse JavaScript for componnet class. Error: Error:`

### Possible Fix
Fix typo and remove `Error:`. Can tackle this issue if needed.  Hello,

I am using Marko (great tool by the way!) to generate XML.
I have a ¬´root¬ª .marko file and a few included files. I would like to keep the indentation in the rendered file for various reasons.

However, when I indent the xml tags in the included file, I have this error:
` Line has extra indentation at the beginning`

The root .marko file looks like this:
```
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<myxml>
    <include("./myxml-include.marko", data)/>
</myxml>
```

And the included file (note the indentation):
```
    <SubObject>
        <Value>primary</Value>
    </SubObject>
```
Is there a way to remove this formatting rule?

Thanks! Thanks, it's working!  I have a question.

What about the templates that have `Class` like in marko widget?

Since The bodies of class declarations and class expressions are executed in strict mode.

And what about the compiled templates also use class?

Thanks!

reference:

https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Classes Got it @patrick-steele-idem thanks!  Biggest reason for this is parity with `onClick` which has access to the full data/state/input context.

index.marko-current
```
<div onClick('handleFoo')>click</div>
```

component.js:
```
module.exports = {
   handleFoo( e ) {
     alert( this.getFullName() );
   }
   getFullName() {
     return input.firstName + " " + input.lastName
   }
}
```

Compare the `-current` and `-proposed` convenience, debuggability, consistency, etc.

For some (many?) functions, eventually those component functions may move to a more structured project lib, but during initial development, having all functions available in `this.*` and `component.*` is extremely convenient.

index.marko-proposed
```
<div onClick('handleFoo')>${ component.getFullName() }</div>
$ console.log( component.getFullName() )
```

index.marko-current
```
import helper from './helper'
<div onClick('handleClick')>${ helper.getFullName( input, state ) }</div>
$ console.log( helper.getFullName( input, state ) )
```

component.js-current
```
import helper from './helper'
module.exports = {
   handleClick() {
     alert( helper.getFullName( input, state ) );
   }
}
``` Yep... just pointing out why it's an improvement over the current options / alternatives.

`${ component.getFullName() }` would make me very happy. :-)  I got an situation here.

My team is using `await` in a page that we need to handle more then one Promise
They tried to use something like this

```HTML
<await(data from firstProvider)>
    <await(complementData from secondProvider)>
    </await>
</await>
```

They said to me they got some errors with nested `await` and i was thinking in two solutions for this scenario

I was thinking about wrap the Promises in an especifc provider and use `Promise.all(requests)`

or create a custom tag like this one `<await-all(data from [Promise1, Promise2, ....])</await-all>`

What is the best solution to implement something like this?

What do you think about it??

Thanks and i'm in love with marko :rocket:  ```HTML
<var watcher=Promise.all([firstProvider(), secondProvider()] />
<await(response from watcher) ></await>
```

i will test something like this! Here's my demo/test about this issue

https://github.com/mauricionr/marko-demo

```HTML
<var watchers=Promise.all([data.promise1, data.promise2]) />
```

the service 

```javascript
module.exports = () => {
    return new Promise((resolve, reject) => {
        request.get(config.categories, (error, response, body) => {
            setTimeout(() => {
                resolve(JSON.parse(body));
            }, 5000)
        })
    })
}
```
the controller

```javascript
module.exports = (req, res) => {
    template.render({
       name:'Mauricio Nunes dos reis',
       colors:['red', 'green', 'blue'],
       promise1:categorieService(),
       promise2:categorieService()
   }, res)
}
```

the view

```HTML
<!DOCTYPE html>
<html>
    <head>
        <meta charset="UTF-8">
        <title>Marko Demo</title>
    </head>
    <body>
        <h1>Marko Demo</h1>
        <h2>${data.name}</h2>
        <section>
            <ul>
                <li for(color in data.colors)>${color}</li>
            </ul>
        </section>
        <var watchers=Promise.all([data.promise1, data.promise2]) />
        <await(response from watchers) client-reorder=true>
            <await-placeholder>
                Loading data...
            </await-placeholder>
            <await-error>
                An error occurred!
            </await-error>
            <await-timeout>
                A timeout occurred!
            </await-timeout>

            <h3>Promise1</h3>
            <section>
                <ul>
                    <li for(cat in response[0])>${cat.name}</li>
                </ul>
            </section>
            <h3>Promise2</h3>
            <section>
                <ul>
                    <li for(cat2 in response[0])>${cat2.name}</li>
                </ul>
            </section>
        </await>
        <await-reorderer/>
    </body>
</html>
```

Works well :rocket: 

But i could not see the *Loading data* and i'm using the tag `await-placeholder`

Since i'm using `json-server` to fake and json api, i put an timeout to looks like the real world and could not see the loading.

Any guess?

Thanks guys!! @mlrawlings yes, but you can double check if really is server-side rendering here's the [demo](https://github.com/mauricionr/marko-demo)  In `rc.17` and earlier, Marko would automatically add a widget's `index.marko` to the internal dependency array if needed. As of `rc.20`, the `<class { ... } />` tag adds the `index.marko` to the dependency list as expected, but if a `component.js` or `component-browser.js` is used instead then it will add that to the dependencies, but *not* the corresponding `index.marko`. @mlrawlings Looks like a `console.log` slipped through, and it's not marked as `latest-beta`. But other than that it works! :)  ## Question

I'm using marko and is awesome

My question is, there's any Best Practice guide for production enviroment?

Thanks guys! For client-side, see #490; The documentation is still a work-in-progress. Patrick mentioned using `minprops` and `envify` to reduce code size, but you should really just follow the standard best practices for *all* client-side code: Minify, gzip, and cache responsibly. How you actually *do* that depends on your other libraries and frameworks - `express`, `lasso`, etc.

Server-side, the only recommendation I'm aware of is to set `NODE_ENV=production`. That's because `Marko` is designed to be the best of both worlds - convenient in development, efficient in production.  
[![Coverage Status](https://coveralls.io/builds/10269446/badge)](https://coveralls.io/builds/10269446)

Coverage increased (+0.003%) to 89.811% when pulling **35dc0c4429b9adbca2bc774e6c2a07b8d905c1d7 on 593-scriptlet-metadata** into **34f60a777ad6fd1ce9e7c78b5cca774982695ded on master**.
  Strawman argument was for:

```
<scope>
   $ var x = 1
   $ var y = 2
   This is ${x}, ${y} valid.
</scope>
This is ${x}, ${y} undefined.
```

...compiling to an IIFE for scope protection, and using `$ ...` for JS execution.

Rationale is that a dangling `$ var x = ...` at the top of a file could have spooky action at a distance towards the bottom of the file, but if it were captured in some sort of `<scope> ...` block then the area required to analyze is much smaller. A lot of tags generate nested functions, so with `$ var ...;` it's impossible to know where the scope begins or ends until you look at the compiled output - it could stop at the nearest parent tag, or extend all the way to the top-level render function. That *usually* doesn't matter, but it would be nice to have a more explicit way to handle variable scope.

I agree with using `$ ...;` for inline javascript, but things like tag scope need to be handled by the compiler. So here's my idea: The `<var>` tag could be reintroduced, with `<var ...></var>` compiling to an IIFE as before. However, self-closing `<var ... />` tags would now be *template*-scoped.

Example:
```html
<if(input.foo)>
  <var foo=input.foo /><!-- hoisted -->
  <var bar=input.bar><!-- scoped -->
    $ console.log(foo, bar);
  </var>
  <var foo=null /><!-- hoisted -->
</if>
$ console.log(foo); // input.foo ? null : undefined
$ console.log(bar); // ReferenceError
```
```js
var foo;
if (input.foo) {
  foo = input.foo;
  (function(){
    var bar = input.bar;
    console.log(foo, bar);
  })();
  foo = null;
}
console.log(foo); // input.foo ? null : undefined
console.log(bar); // ReferenceError
```

A name other than `<var>` could be used for backward-compatibility, but ~~`v4` has already shipped without it~~, and I feel it would be fairly easy to explain that "`<var ... />` is now template-scoped".

> Edit: Whoops, looks like `<var>` is still present in `v4` but it prints a deprecation warning. Still, at this point I think it would be safe enough to make this change.  just stumbled into something similar, this works:

```
class {
    sayHi() {
        alert(`Hi!`);
    }
}

<main>
    <h1>test</h1>

    <button on-click('sayHi')>Click me!</button>
</main>
```
this works:
```
<include('../../layout.marko')>
    <@body>
        <main>
            <h1>test</h1>
 
            <button>Click me!</button>
        </main>
    </@body>
</include>
```
but this doesn't:
```
class {
    sayHi() {
        alert(`Hi!`);
    }
}

<include('../../layout.marko')>
    <@body>
        <main>
            <h1>test</h1>
 
            <button on-click('sayHi')>Click me!</button>
        </main>
    </@body>
</include>
```   <!----------------------
  |     IF BUG REPORT    |
  ---------------------->
## Bug Report

### Context
placing non-breaking space (`&nbsp;`) in a template element renders out as `√Ç` on the browser (VDOM).

### Expected Behavior
should render simply as (`&nbsp;`)

### Actual Behavior
renders as `√Ç`.

<details><summary>Additional Info</summary>

```
< div class="cartCoupTitle" >
        ${coup.title}< br/ >
        < span class="cartCoupGUID" >${coup.GUID}< /span ><br/>
        < strong >Expires< /strong > &nbsp; &nbsp;${coup.expires}
< /div >
```

VDOM

``` marko_forEach(state.productCoupons, function(coup) { 
out.e("div", marko_attrs31, 2) 
.e("div", marko_attrs32, 7) 
.t(coup.title) .n(marko_node27) 
.e("span", marko_attrs34, 1) 
.t(coup.GUID)
 .n(marko_node28) 
.n(marko_node29)
 .t(" √Ç¬†√Ç¬†") 
.t(coup.expires) 
.e("div", marko_attrs33, 1) 
.e("strong", null, 2) 
.t("$") 
.t(coup.authorizedPrice); }); 
```
</details>
  +1  Hello,

While refactoring for `rc14` I realise that new syntax for `data.renderBody` invocation must be like this:

```
$ if(data.renderBody) data.renderBody(out);
```
That's not looks very good inside a HTML like template. May be it's better to create a dedicated tag like `<tag-body-out />` for that purpose? It will be rendering for nothing or body... Simple and elegant? is `data` deprecated too and we should use `input` instead?  Or could be more vue like

for((key, value) in data)//object

And

for(item in data)//array

Thanks :)  ```
WARNING!!
The "<invoke>" tag is deprecated. Please use "$ <js_code>" for JavaScript in the template. See: https://github.com/marko-js/marko/wiki/Deprecation:-var-assign-invoke-tags
  at node_modules/marko/taglibs/core/invoke-tag.js:3:13
```

note the module where it happens...  
[![Coverage Status](https://coveralls.io/builds/10073306/badge)](https://coveralls.io/builds/10073306)

Coverage decreased (-0.001%) to 89.82% when pulling **724f8addf843df941416ded82c1b02f308102e86 on 574-picture-tag** into **097ebc15b3a348de2ec07ee4eb3a01b40aad7eb1 on master**.
  Compilation broken with error `Unrecognized tag: picture` while `picture` is certainly a standard HTML5 tag   
[![Coverage Status](https://coveralls.io/builds/10060503/badge)](https://coveralls.io/builds/10060503)

Coverage increased (+0.006%) to 89.391% when pulling **768d8085f7adc8811e027ec7a88cae682a703a9e on 558-deprecate-tags** into **41b2c0878a6c9af69fb22889e97cee5495fc9bdb on master**.
 
[![Coverage Status](https://coveralls.io/builds/10060503/badge)](https://coveralls.io/builds/10060503)

Coverage increased (+0.006%) to 89.391% when pulling **768d8085f7adc8811e027ec7a88cae682a703a9e on 558-deprecate-tags** into **41b2c0878a6c9af69fb22889e97cee5495fc9bdb on master**.
  
[![Coverage Status](https://coveralls.io/builds/10060177/badge)](https://coveralls.io/builds/10060177)

Coverage decreased (-0.04%) to 89.34% when pulling **608d098cffb0019bf2eee34dc4583943761434f0 on 570-ref-to-key** into **41b2c0878a6c9af69fb22889e97cee5495fc9bdb on master**.
  I do think "key" is a more accurate description, though I'm not entirely convinced the change is necessary. My only major concern would be possible naming collisions - I can think of plenty of other uses for a custom "key" attribute, but not very many for "ref", which has always been pretty much reserved for widgets anyway. That's not to say I disagree, but I'd like to hear a few more pro's and con's.

If this change is implemented, I would be in favor of providing a temporary / opt-in `"ref" -> "key"` alias, perhaps in a `marko-v3-compat` package like what was suggested in #558. Ah, forgot about React. I'd say those are pretty good reasons to make the switch.  
[![Coverage Status](https://coveralls.io/builds/10036031/badge)](https://coveralls.io/builds/10036031)

Coverage increased (+0.02%) to 89.332% when pulling **00dda0a537e306cf063e8d3103679c316617bf41 on 487-template-compiler-version** into **ffdc91382fb41484585b60ea98f840d3f8f5b25f on master**.
 
[![Coverage Status](https://coveralls.io/builds/10036496/badge)](https://coveralls.io/builds/10036496)

Coverage increased (+0.02%) to 89.332% when pulling **645d184da0abc2b854931f2718dd75e9d382c616 on 487-template-compiler-version** into **ffdc91382fb41484585b60ea98f840d3f8f5b25f on master**.
 
[![Coverage Status](https://coveralls.io/builds/10036496/badge)](https://coveralls.io/builds/10036496)

Coverage increased (+0.02%) to 89.332% when pulling **645d184da0abc2b854931f2718dd75e9d382c616 on 487-template-compiler-version** into **ffdc91382fb41484585b60ea98f840d3f8f5b25f on master**.
  <!--- Provide a general summary of your changes in the Title above -->
This fix will ensure that an empty array does not output a an empty class attribute: `class=""`.

## Description
- modified helpers.js line 55 adds ` || null` when the array is empty (because a joined empty array is falsy);
- fixed tests to accommodate

## Motivation and Context
I was attempting to use arrays for class names because of the utility of concatenating them together was taken up by Marko. But, when the array was ever empty, I would have the `class=""` throughout my app, and my tests. This issue added unnecessary bloat. Therefore, the motivation for this fix.

## Checklist:
<!--- Go over all the following points, and put an `x` in all the boxes that apply. -->
<!--- If you're unsure about any of these, don't hesitate to ask. We're here to help! -->
- [x] My code follows the code style of this project.
- [X] I have updated/added documentation affected by my changes.
- [X] I have read the **CONTRIBUTING** document.
- [X] I have added tests to cover my changes.
- [X] All new and existing tests passed.
 
[![Coverage Status](https://coveralls.io/builds/9985791/badge)](https://coveralls.io/builds/9985791)

Coverage remained the same at 84.055% when pulling **0460d268ea3a412ebb91877da56f0c7847177f4b on seangates:v3** into **3ed82b7a0013ab8f8a1e82fc33447738e156cf7e on marko-js:v3**.
 @mindeavor Noted. Fixed!  I just switched from rc 8 to 12 and my widgets getTemplateData method is no longer being called in any of my widgets. Was this removed for some reason? I have no problems with it being removed, just didn't realize it was, so it broke my code when I moved form rc 8 to 12. I couldn't tell if it was a bug or intended. I tried looking at the revisions, but couldn't make heads or tales of where the change actually happened. :)

I was only using it because the [Roadmap ](https://github.com/marko-js/marko/blob/master/ROADMAP.md) under heading **New widget lifecycle methods**  shows the getTemplateData method in the **new** list. So I thought I was supposed to be using it. :) I guess the roadmap doc just needs to be updated to remove it. 

Thanks for confirming.  An error should not be thrown -- https://html.spec.whatwg.org/multipage/scripting.html#custom-elements That just goes back to the boilerplate issue I opened a while back -- https://github.com/lasso-js/lasso-marko/issues/3

Now, if the parser encounters `<my-awesome-element>...</y-awesome-element>` then it should certainly throw an error. But the author may be fully expecting `<my-awesome-element/>` to be dumped into the rendered HTML as-is. I'm definitely against this being the default, but I would love to have this as an opt-*in* setting. Whitelisting tags is decent, but whitelisting tags b/c hopefully someday somebody will use concise-mode is making the wrong tradeoff in my mind.  Disable concise-mode by default.  All (most) issues with top-level tags magically go away  (eg: the following gem `ex0007.marko`).  Tags are tags.  `<for>` is `<for>` (and is wrapped in a tag, not a bareword).  It is a *serious* struggle to get behind "floating `class` statements" as is. (specifically referring to single-file-components).

```
$ cat ex0007.marko
this is
for
you
<h1>Test</h1>

$ markoc *.marko
- Failed to compile "ex0007.marko". Error: Error: An error occurred while trying to compile template at path "/home/rames/Git/marko-v4-spa-example/src/pages/test/ex0007.marko". Error(s) in template:
1) [ex0007.marko:2:0] Invalid <for> tag. Argument is missing. Example: <for(color in colors)>
```
 @mindeavor @ramses0 How would disabling concise mode actually solve the problem being discussed, which is whether to throw an error when an invalid tag is encountered? I understand that you don't like the syntax, but many of us do and are using it in production.

P.S.: You can use HTML syntax for the new tags, too: `<class { ... } />` `<static { ... } />`. @Hesulan - root level text is terrible.  My vote is for putting it into a `<div>`.  It is especially terrible when "for he's a jolly good fellow" gets parsed as a `<for ...` tag by marko.  However, "concise mode" has to treat every word in the file as if it _might_ be a tag (or `class` or `static` or `import` or whatever else exists in the global marko keyword namespace).  As someone who doesn't use concise mode, I see that trying to serve two masters in "single file components" is incredibly short-sighted.

The current single-file-component format has the benefit that it is backed by working code, but as an outsider / recreational user of markojs, I see it as full of traps for implementors and users, especially compared to non-single-file-components.  It also appears as though you can't really opt out of single-file component mode either. @ramses0 
You have a point, root level text is definitely a downside. But it's also easily solved with a `-- `, and aside from a "Hello World!" file, it would be difficult to find many real world use-cases.

Single-file components are still entirely optional, they're just more convenient than writing a separate `component.js` when working with small, simple components. The only component-related thing that I know of in v3 that won't work in v4 is `<script marko-init>`, which is being replaced by `<static>`.

I do understand preferring HTML over concise, and it's my opinion that the official documentation should try to use HTML syntax as much as possible (even though I almost always use concise). @mindeavor I'm still unclear on *how* disabling concise syntax would solve the problem, or how it's at the root of it. +1 for throwing an error. Many complex projects rely on knowing when there is an issue with an unknown or incorrect tag. @mindeavor I'm not sure what that has to do with throwing errors for invalid tag names, and those are all just different examples of the same thing - plain text as a root element.

@patrick-steele-idem On further thought, I think I would agree with throwing errors by default, as long as it's easy to disable and clearly documented. @mindeavor Ah, I see what you meant now. That's not the point though, the point is to catch invalid tag names. Root level text in concise mode is just one of the *many* ways that a typo could slip past, and to simply disable such a widely used feature by default would be a huge overreaction and wouldn't solve the problem of invalid tag names. Catching accidental root-level concise tags is only a nice *side*-effect of the proposed solution. @mindeavor From what I understood, the reason this came up is because if you type something like `<ing ... />` it's quite likely that you *meant* to type `<img ... />` unless you've explicitly defined a custom `ing` tag. Throwing an error would *also* help to catch accidental concise tags. I honestly can't remember the last time I even used root-level text outside of a Hello World example, but I can see how it would get annoying.

I do think only throwing on single-word tags is a reasonable condition, and I believe @mlrawlings mentioned something similar earlier in this thread. @mlrawlings would you be in favor of splitting out the potential discussion: "require concise mode to be explicitly opted in to"?

I believe it would require:

```
<class {
  onClick() { ... }
}/>
```

...which makes total sense to me.  Or a flag to explicitly opt out of the potential bugginess / confusion of mixing concise-mode, markojs single file components, javascript, and HTML?  I keep hearing `--` is the magic token, but haven't seen any documentation on that.  `"use strict"` is a precedent, `@concise-mode` was a strawman syntax, even `@strict-html` or `@disable-concise` would be welcome.  Hope I'm not hi-jacking the thread here, but on the topic of Classes, it seems you cannot use the extend keyword. If I make a component using a class that extends another class, it fails due to a instance check "_classCallCheck" where the instance is the Widget class, but it's checking for the Constructor of the parent. I get a failure of "cannot call a class as a function". This _seems_ to be caused by how Babel transpiles e6 code. Here's the relevant compiled code.

```
       function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
            }
        }
        var Test = function() {
            function Test() {
                _classCallCheck(this, Test);
            }
            _createClass(Test, [{
                key: "constrcutor",
                value: function constrcutor() {
                    console.log(parent);
                }
            }]);
            return Test;
        }();
        var Room = function(_Test) {
            _inherits(Room, _Test);
            function Room() {
                _classCallCheck(this, Room);
                return _possibleConstructorReturn(this, (Room.__proto__ || Object.getPrototypeOf(Room)).apply(this, arguments));
            }
            _createClass(Room, [{
                key: "onInput",
                value: function onInput(input) {
                    console.log("IT WORKED");
                }
            }]);
            return Room;
        }(Test);
        exports.default = Room;
        module.exports = exports["default"];
```

You can see the _classCallCheck is called twice, once for the child, once for the parent. It's the parent call that fails as the instance is "Widget" but the Constructor is "Room".

Is this the same issue as you mentioned above? @jasonmacdonald Michael was talking about the `<class { ... } />` tag. None of the code generated by Marko currently compiles to anything greater than ES5, and javascript classes are ES6. Could babel be trying to compile the `.marko` template by mistake? For sure it's Babel compiling the es6 classes. I'm trying to use a class as my component definition. But, it seems to be Marko that is adding the _classCallCheck to the compiled component definition. @jasonmacdonald I'm not quite sure what you mean, but using a class as a component definition is invalid. The `<class { ... } />` tag mentioned here is just a convenient syntax (with a bit of a misleading name), it doesn't *actually* generate an instantiable class. Sorry if I'm not being clear. I'm talking about Marko 4 widgets, defining a widget component using an ES6 Class instead of an Object. I'll start a different thread as this one isn't what I thought it was. Thanks!  @mlrawlings I think this really comes down to the developer knowing that using a v3 taglib in v4 can be tricky. These tags aren't the only breaking changes; The switch from `-` to `--` in concise comes to mind, along with several other edge-cases. Unless the parser and compiler can be switched into some sort of "legacy" mode whenever an outdated taglib is being loaded, I don't see any other way around the occasional compatibility issue, though in some cases a `marko-v3-compat` taglib might help. As a recreational user of marko v3 transitioning to v4, I am 100% in favor of "kill stuff that's going to die" (ie: `var`, etc).  `npm install markojs-v3-deprecated` is totally fine by me.

I *will* say that I am especially disappointed by the removal of the `<var>...</var>` special tag.

Conceptually being able to scope my sins of using `<var/>` in my logicless templates in the first place is invaluable.  Forgive my use of tables (throwaway code during development), but I used them like this:

```
      <var
        flavors=data.fnRandomFlavors( data.selection )
        ingredients=data.fnRandomPopularIngredients()
      >
        <h1>${data.fnCap(data.selection)} and...</h1>
             <td align="right"><a href="/drinks-with/${data.selection}/$${flavors[0]}">
              ${data.fnCap(flavors[0])}
            </a></td>
            <td>or</td>
            <td><a href="/drinks-with/${data.selection}/$${flavors[1]}">
              ${data.fnCap(flavors[1])}
            </a></td>
          </tr>
          <tr>
            <td align="right"><a href="/drinks-with/${data.selection}/${ingredients[0]}">
              ${data.fnCap(ingredients[0])}
            </a></td>
            <td>or</td>
            <td><a href="/drinks-with/${data.selection}/${ingredients[1]}">
              ${data.fnCap(ingredients[1])}
            </a></td>
          </tr>
```


The introduction of `$ var flavor=input.someFunc()` kill the template and you end up with PHP all over again.

What I mean is that with a scoped `<var>` tag, I can easily determine if the template is factorable (ie: what dependencies or requirements it might have).

With a "dangling `$ var ...`" statement... Every. Single. Line. after that `$ var ...` statement is suspect, and requires brainpower to determine if it is using any of the declared `$ var ...` variables.

In summary:

1) marko-v3-compat package is totally fine

2) killing `<var />`, or encouraging the use of `$ ...` for anything other than debugging is bordering on criminal (it basically makes the entire file unable to be reasoned about unless the human first does a "compilation pass" looking for `$ var ...` and then remembering where it is used).

I've written and seen enough bad PHP, and bad JS, written by good people (but not good programmers) that I would view use of markojs as highly suspicious.

*THINK* about this.  When you see `Array.prototype.something = function() { ... }` does that make you happy that the person before you was so clever? Or fill you with rage that now you have to audit the entire source tree for uses of `*.prototype` and then see how that interacts with the rest of the codebase?

In the below code, `<var a=...>` is demonstrable better from a maintenance programmer perspective compared to `$ var b=...;`  Neither is ideal, but `<var a=...>` as a shortcut to make the layout of the template easier, cleaner, etc. is much better.

```
<div>
    <var a=fnFoo()>
        ...snip...
        Hello ${a}
    </var>
    $ var b=fnBar();
    ...snip...
    <div>
    ...snip...
    Hello ${b}
    </div>
</div>
 @ramses0 I believe the main reason for deprecating `<var>`, `<assign>`, `<invoke>`, etc. is because the number of tags that attempt to simulate real javascript was becoming unmanageable, but you make a good point.

@mlrawlings Perhaps it would be a good idea to hold off on removing the `<var>` tag? I feel like it's enough of a special case to warrant keeping it around, especially since it fits each syntax so nicely. @mindeavor Internally, a `<var>` tag with body text compiles to an IIFE, which enforces scope:
```html
<var foo=1 bar=2>
    /* ... */
</var>
```
```js
(function(){
    var foo=1, bar=2;
    /* ... */
})();
``` Will there be (or is there) a way within marko to trigger an IIFE context for scope protection, as referenced in this comment?

https://github.com/marko-js/marko/issues/558#issuecomment-277313323 `<scope/>` is elegantly nasty in a way.  :-) ... it makes it very clear what you're doing, but still requires you to use `$ ...` but then you know your `$ ...`'s can't infect outside that `<scope>` block.  I guess I'm highly in favor of it... good design instinct.  "it would be nice" if there was a setting to emit a warning of something like the following:

```
Warning: file.marko:123  raw javascript `$ ...` found not at top of file or top of <scope> block.
```

ie: encourage `$` items to be in blocks at the beginning of the file instead of randomly sprinkled throughout.  If I can consistently open a template and know that `$ ...` is all bunched up at the top then I'll be a much happier camper.  But adding in a `$ ...debugging()...` randomly might be perfectly appropriate and encouraged (just not checked in / not for prod).

In short, though... I really appreciate you taking into consideration the issue of `<scope>` and would be highly in favor of it!  
[![Coverage Status](https://coveralls.io/builds/9949120/badge)](https://coveralls.io/builds/9949120)

Coverage increased (+0.02%) to 89.23% when pulling **526acaed4475c31379081feee143adb17b5e87a8 on 363-hot-reload-extensions** into **35517181e1e9602222b12bdfd7fb62767595c8d8 on master**.
  <!----------------------------------------------------------------------
  |     IF FEATURE SUGGESTION (skip to next section for bug reports)    |
  ---------------------------------------------------------------------->
## New Feature

### Description
I am using .html files only with marko html in it, but that prevents me from using marko's hot reload.

Lines:
- v4: https://github.com/marko-js/marko/blob/master/hot-reload/index.js#L133
- v3: https://github.com/marko-js/marko/blob/v3/hot-reload/index.js#L128 (and maybe L136 too)

### Context
I know that it's probably recommended to use .marko.html but I would like to stick with my implementation where I use `require('marko/node-require').install({ extension: '.html' })`.

### Possible Implementation
It would be cool if there would be an options object so I could simply use `{ extension: 'html' }` in the hot reload `.enable()` method too, or maybe even use the extension string from the install so that would work automatically.

### Open Questions
See above.

### Is this something you're interested in working on?
Yep, as long as it's clear how the implementation would work
 Sorry for the duplicate, I should have searched for that. Will think of that, but I have no idea how marko works so I don't know whether I will fit into this. I have currently fixed it manually editing the file for now.  Not sure if this is known, but I was testing a simple Marko 4 Widget in IE and it fails when trying to call new Symbol(). This doesn't appear to be supported in IE 11. As you can see [here ](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Symbol) Symbol isn't supported on any IE versions. Is this intended?

Is it expected that we need to pollyfill fill this? Promise is also missing from compiled bundle. :(  Here's the snippet where it appears...

```
},{}],49:[function(require,module,exports){
var KEY = Symbol();

function UniqueId(out) {
    this.prefix = out.global.widgetIdPrefix || 'w';
    this.nextId = 0;
}

function nextWidgetId(out) {
    var global = out.global;

    var idProvider = global[KEY] ||
        (global[KEY] = new UniqueId(out));

    return idProvider.prefix + (idProvider.nextId++);
}
```

This is using Browserify to compile. Maybe Browserfiy is adding it? Nope, looks like it's coming from widgets/util.js, which is included by Widget.js

Interestingly, I switched to try and compile with Webpack and that util package doesn't seem to appear in it's output. So I guess Browserify is including stuff it shouldn't. Grr, too many options/differences with these damn bundlers. I switched over to Webpack and the issue seems to have gone away. However, if I can find a few mins I'll put together a simple project to show the issue. I'll close this for now and update if I can put something together, @jasonmacdonald Just wanted to add, because you mentioned `Promise` not being bundled: Marko doesn't provide a Promise polyfill, and as far as I know the only parts of Marko that require a global `Promise` object are the AsyncStream's `.then()` and `.catch()` methods, and only if you choose to call them.  This might be just me not fully understanding Widget scopes/states, or more likely it's working as intended, but if I have Widget (A) and Widget (B). Widget A uses Widget (B) in it's template and supplies some body content (template) for Widget B. The data scope is bound to Widget A for that body content and not Widget B (which actually renders it). 

Example

Widget A Template - data = 1
```
<widgetB data="2">
   <!-- trying to declare this inner content as a template 
   to be used to render the contents of Widget B -->
   <div>${data}</div>
</widgetB>
```

Widget B template - data = 2
```
<!--I want this to render the body declared in Widget A, but use the data scope of this Widget B-->
<div w-body></div>
```

This ends up rendering the value **1** in the div, not **2.**

What I was hoping was that the scope of WidgetB's data, value (**2**), would be supplied to the transcluded content. I suspect this is working as intended, but is there a way to get the result I was hoping for? 

What I'm trying to do is have widgetB  be able to declare a template to be used inside it's own template when rendered. Think of a tile list component, where I'm trying to supply a transcluded template to be used to render each tile when the tile list renders, rather than declaring the tile itself inside the tile list, for re-usability and flexibility. So each tiles data would be driven internal to Widget B, and I'm defining the template ${params} externally. I also tried using input.renderBody(out, WidgetB_data), inside WidgetB. But, that still seems to use WidgetA data. Thanks, mlrawlings! I'll give these a try! I think I might have a snag, all this assumes I'm only rendering the transcluded content once. But what I'm trying to do is use the transcluded content template as an itemRenderer for a loop, basically.

something like this (very simplified)

WIdget
```
<tileList data="${some_array_of_items}">
    <div>${item}</div>
</tileList>
```

TileList
```
<div for(item in items)>
    <div w-body></div>
</div>
```

Seems if I manually call input.bodyRenderer() it would just repeat the same content. Maybe I'm approaching this wrong. I'm just trying to make a reusable tielist component for an image gallery, where the user of the component can easily define how the content is rendered by specifying the item renderer in the body. I know I could have them define a path to a template to be used for rendering, was just trying to avoid extra files. oh, let me try that! You're the best, mlrawlings! Cheers! Wish I knew more of these secrets :) Can Marko Widgets use Marko 4? NPM complains that Marko Widgets wants a Peer dependency for 3.0 oh, really? I'll definitely use that then ok, awesome. Got Marko 4 all set-up and things seems to be working, for the most part. One thing I can't seem to get to work anymore is the "var" part to add the extra variable to the renderBody.

I've tried adding it to the marko-taglib and also to the top of the component with...

```
exports.tag = {
    "var": "item"
}
```

BUt the compiled output doesn't seem to add the var anymore. I had it working in Marko 3. Did this part change? I can't find anything about how to do these configs in the [Roadmap page.](https://github.com/marko-js/marko/blob/v4.0.0-rc.8/ROADMAP.md).

I'm sorry for the all the questions. :( ok, after some trial and error, I was able to get the "var" to appear in the compiled output, but only if I added a marko-tag.json file to the "Widget" component directory, along side my component.js and index.html. I used the following JSON

```
{
  "var": "item"
}
```

No clue if this is correct way though. We used to be able to add these in the component file using an exports.tag, but that doesn't seem to work anymore. Kind of annoying to have to add another file to accomplish this.

I'm still a bit muddy on all these JSON files (marko-taglib.json vs marko-tag.json vs marko.json) and where exactly they are supposed to live. It seems I need to have a marko-tag.json somewhere high in the directory that defines the components directory defining "tags-dir": "./src/components" or nothing gets found.

I'm sure it's just me fumbling my way through this without docs :(   I think it's not readable and clear like old syntax. Example if you are newbie in marko world and you see
```
<script template-helpers>
   function sum(a, b) {
      return a + b;
   }
</script>
```
You can easy understand that some logical operations is happen in script tags but if you see

```
static function sum(a, b) {
   return a + b;
}
```
You can think someone try to write in output "static function ... etc". Also if you need to write really to output something like this you need to wrap this code and it's not intuitive.

I like marko html syntax and custom tags because it make me fill everything is standard with some extra power.

Another thing why i like html syntax is if i have already written code in html it's really easy to integrate with my project without any other efforts but otherwise result can be unexpected.

I don't like concise, mix syntax and maybe i am wrong. @Eldar-X 
You're certainly not alone in preferring standard over concise syntax. I personally prefer concise, but I do feel that the official documentation should use HTML syntax whenever possible.

@mindeavor @patrick-steele-idem 
I much prefer using a separate tag rather than hijacking `<script>`. Even with the `template-helpers` or `marko-init` attribute, the first time I saw that it took a while to click. Someone new to Marko might not realize that it transforms top-level `<script>` and `<style>` tags, but when I see something like `<static>` or `static { /* ... */ }` I immediately recognize that it's special.

@patrick-steele-idem 
I really like this proposal. Correct me if I'm wrong, but I'm assuming the HTML syntax would look like:
```
<static {
    function myHelper() { /* ... */ }
} />
<component class {
    onInput() { /* ... */ }
} />
```
Would `<static>` still accept body content like `<script marko-init>` did?
```
<static>
    function myHelper() { /* ... */ }
</static>
``` If we do, it will be a problem to put spaces after $ because most of our text editors can divide our code like this
```
<div>
Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris 
nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. 
Excepteur sint occaecat cupidatat non proident, sunt in culpa $
{
// What?
} qui officia deserunt mollit anim id est laborum.
<div>

``` 
Also i still think it should be at least for html version at least inside tags maybe like this
```
<$>
var myCode = true;
</$>

<{>
var myCode = true;
<}>

<${>
var myCode = true;
</}>

``` @patrick-steele-idem The only problem I see is that the `$ ...` would be parsed as a tag name in concise, but as text in HTML. I would prefer either `<$></$>`, or making that concise-only (in HTML you'd probably want to use `$${ ... }` instead anyway).

Other than that I like this proposal. Though I do feel it's important to mark this as a breaking change, since anyone previously using something like `$${price}` will now need to escape the first `$`. ~~Actually, now that I think about, I feel like it would be more intuitive if the behaviors of `$${ ... }` and `<% ... %>` were swapped (then `$${...}` would be a multi-line, multi-statement version of `${...}`), but that *might* be too much of a breaking change.~~

Edit: Whoops, nevermind. For some reason I was thinking `$${...}` would replace `static { ... }`. Haven't had my coffee yet this morning. 1) When this moves forward, will the deprecate state be eternal? Or is there a timeline to remove the old syntax? People tend to stick to the old syntax until forced to change. Will there be a migration tool?
2) I guess this is not related to the syntax change, but is JS linting possible in JS embedded in marko file?
3) I prefer a syntax that permits parsing such that we can still write easy-to-read, lint-able code (without changing a team's current JSLint/ESLint settings) - i.e., multi-lined object literal, usual indents, etc. For small JS, I am okay having it in marko; for larger JS, my preference is to put it in separate JS file. I'd want to be able to move the JS from marko to JS file without reformatting.
4) I prefer a single way of doing things - syntax flexibility of doing the same thing tends to end up in multiple ways of writing code within the same code base - and leads to endless discussion in opinions. @mikewoo200 
1. I'm not aware of anything in Marko that's ever been deprecated for too long without being removed, but with a change like this there will be plenty of deprecation notices. There will also be a migration tool sometime after v4 is released.

2. That would depend on whether the linter you're using supports linting only a section of the file. Alternatively, you could lint the entire resulting `.marko.js` file.

3. That's one of the main reasons for these changes; the way it's currently done doesn't make that easy, but the `class { ... }` syntax would. 2. What's a good linter than supports linting only a section of the file? We wouldn't lint`.marko.js` because it's a generated file that we don't check into our app codebase. @patrick-steele-idem, for "valid JS" linting (unused, undefined, etc.), what you mentioned would work. But for style linting (spaces, indents) in the template, what can we do? @patrick-steele-idem I'm a little unclear on the exact behavior of `$${ ... }`. Is it the same as `<% ... %>`, or will you be able to `return` something from it to be inserted into the document? For example, would this:
```
<div>
    $${
        return result;
    }
</div>
```
do basically the same thing as `<div>${result}</div>`?

I'm also not sure that `$${ ... }` needs to be restricted to the beginning of the line. It makes perfect sense for `$ ...`, but why not allow this:
```
<div>$${
    /* ... */
}</div>
``` @mlrawlings I like that, though I'm not sure what you mean by "special case `$` to *disallow* `$ { ... }`".

Here's my interpretation of the parser logic:
* If the tag name is `$`, immediately begin parsing as a multi-line expression (which also tracks `depth` within `{}`, `()`, and `[]` pairs)
* Continue until `char === "\n" && depth === 0` (end of line and we're not inside a pair of brackets)
* If the expression text spans multiple lines and begins with `{`, strip the opening `{` and closing `}`

If you need to enclose a multi-line tag's content in a javascript block statement, you'll simply need to use two pairs of brackets:
```
$ { /* begin script */ { /* begin block */
   /* ... */
/* end block */ } /* end script */ }
```
Optionally, the single-line syntax could *also* strip a single pair of surrounding brackets to avoid confusion. I'm late to the party, but I want to add my voice in support of *not* "concise" syntax. I do not think floating JS blocks are indicative enough of the code being associated with the template system. And as someone who abhors the "class" sugar, I'd be loath to use it solely for that reason. I would much rather see something like the following:

```
<marko-script>
module.exports = {
  handleClick: function (event) {}
}
</marko-script>
``` @jsumners I don't completely disagree - it would be nice to have a more HTML-like syntax - but after digging through the compiler code and giving it a lot of thought I'm personally convinced in favor of `class`. Also keep in mind that `<class {} />` (or `<script> module.exports = ... </script>`) is really just a convenience to avoid writing a separate `component.js` for small, simple components.

@patrick-steele-idem @mlrawlings On a related note, could `<static>` fall back to using body-text if the `{ /* ... */ }` attribute is omitted? I think a lot of users would prefer that, and it would certainly ease the transition from `<script marko-init>`. @patrick-steele-idem Yes, but could it fall back to parsing body-text if the block is omitted?
```
<static {
   /* ... */
} />
```
```
<static>
   /* ... */
</static>
``` @mlrawlings I only meant for `<static>`, and only in the way that's already used by `<script marko-init>` (which `<static>` is replacing). It wouldn't make sense for `<class>`, and I really don't like hijacking tags like `<style>`.  ## Bug Report

### Context

I'm trying to compile the following template:

```html
<script marko-init>
  const states = {
    foo: 'bar'
  };
</script>
<p>${(state_names[state] || state)[0].toUpperCase()}</p>
```

But the grouping around `(state_names[state] || state)` is not respected in the output.

### Expected Behavior

```js
// ...

  return function render(data, out) {
    out.w("<p>" +
      escapeXml((state_names[state] || state)[0].toUpperCase()) +
      "</p>");
  };
}

// ...
```

### Actual Behavior

```js
// ...

  return function render(data, out) {
    out.w("<p>" +
      escapeXml(state_names[state] || state[0].toUpperCase()) +
      "</p>");
  };
}

// ...
```

See how the grouping around `state_names[state] || state` is dropped.

### Your Environment

* Version used:
* Marko 3.14.0
* Node.js 6.9.2
* macOS Sierra (10.12.2) Thanks a lot!  I have a template that is in HTML format, but the parser is assuming concise mode, so warnings for issue 43 and 48 from htmljs-parser are now popping up in the console.

How do you disable concise mode if you do not use it? I didn't know about wrapping with `--` as I couldn't find any documentation on that.  Thanks for the tip.  That should work, and probably much easier than figuring out how to change marko to pass the concise: false option to htmljs-parser  <!----------------------
  |     IF BUG REPORT    |
  ---------------------->
## Extra quotation marks on output of non string objects

When variable is not a string output have extra quotation marks

```
const template = require('template.marko');
template.stream({
test : new Date();
})

// template file

<div data-test="${data.test}"/>
// Output is
<div data-test=""2017-01-19T12:58:42.801Z""></div> 
// In marko v3 output was
<div data-test="2017-01-19T12:58:42.801Z"></div> 
```  ## Exporting data from template

I think it would be very nice feature if we can exporting data from template files because now marko files have much power and we can make logical operations some times we just want to export result for using it somewhere else.

### Example use case:

We have cms and we want define output fields for this template then in our admin page we want get all fields of selected template file for fill them.
  Looks like what i need.
Let's make some example something like this is working?
```
// foo.marko
<script>
var fields = {};
</script>

<div class="myField-1">
 <% fields["first"] = {
 name:"firstField",
 type:"textarea"
} %>
</div>

<div class="myField-2">
 <% fields["second"] = {
 name:"secondField",
 type:"datePicker"
} %>
</div>

export var info = {
 name: "Home Page",
fields: fields
}

// bar.js
const template = require('foo.marko');
console.log(template.info) // name: "Home Page", fields: { first, second }
```  <!----------------------------------------------------------------------
  |     IF FEATURE SUGGESTION (skip to next section for bug reports)    |
  ---------------------------------------------------------------------->
## Inline output support for marko widgets

<!--- Provide a detailed description of the change or addition you are proposing -->
While marko widget now part of marko.js how about add support for printing compiled output of widgets inline to template file without bundlers? 

<!--- Why is this change important to you? How would you use it? -->
I think it's important feature because widgets must be independent from 3rd part tools but can provide support for them.
 Now for working with marko we must bundle output of widget yes? But why we can't just put output of widget into html between script tag? for example we have onclick listener in our widget why just not put in html? I know that bundled js have some better features but it also may be not bad Even the simplest widget depends on the `marko/widgets` runtime, which needs to be bundled anyway. It *might* be possible to add a compiler optimization to recognize this edge case and use plain JS instead, but that could easily break something. Alternatively, you could just add `<script>document.getElementById(...).addEventListener(...);</script>` yourself or even write a custom attribute transformer.

If you're just wanting specific widgets to be embedded in the page rather than included in the main bundle, most bundlers provide a way to do that. Lasso, for example:
```json
{
     "dependencies": [
        { "require": "./component.js", "inline": true }
    ]
}
```
Which results in something like:
```html
<body>
    ...
    <script src="/static/page-1ae394d6.js"></script>
    <script>
        /* component.js */
    </script>
</body>
```   
[![Coverage Status](https://coveralls.io/builds/9689890/badge)](https://coveralls.io/builds/9689890)

Coverage remained the same at 88.696% when pulling **7ff3d9bea59c89cc1f9346b36af288d3a832fcc2 on greenkeeper/fs-extra-2.0.0** into **f419c9f8e4bd8c285fba38c96b6a684402819597 on master**.
 
[![Coverage Status](https://coveralls.io/builds/9689890/badge)](https://coveralls.io/builds/9689890)

Coverage remained the same at 88.696% when pulling **7ff3d9bea59c89cc1f9346b36af288d3a832fcc2 on greenkeeper/fs-extra-2.0.0** into **f419c9f8e4bd8c285fba38c96b6a684402819597 on master**.
  
[![Coverage Status](https://coveralls.io/builds/9687277/badge)](https://coveralls.io/builds/9687277)

Coverage decreased (-0.03%) to 88.666% when pulling **f26e6ef22b518986f5b07621377364f1392c5c70 on 532-markoc-version** into **f419c9f8e4bd8c285fba38c96b6a684402819597 on master**.
  
[![Coverage Status](https://coveralls.io/builds/9657182/badge)](https://coveralls.io/builds/9657182)

Coverage remained the same at 88.708% when pulling **9ee4909c4c820d05faa3794028cabca3ab5cd4f9 on greenkeeper/md5-hex-2.0.0** into **1564788f2e0b84dce79d755602b7bdf9f26f8a58 on master**.
   Directories named `~node_modules` and `~runtime` seem to have been accidentally added to the NPM package starting from `4.0.0-beta.6`, bringing the `package.tgz` size from < 300 kB to > 3 MB. Still there as of `4.0.0-rc.0`.

/cc @patrick-steele-idem @mlrawlings   @patrick-steele-idem and @mlrawlings This reflects the behavior that was available in v3 with getInitialState and I don't see any problems with backwards compatibility. Thank You!  I've been following the 4.0 milestone, however I'm getting the following error: 

```
Error: An error occurred while trying to compile template at path "site/components/hero-image/index.marko". Error(s) in template:
1) [site/components/hero-image/index.marko:3:2] The include attribute must have an argument. For example: include("./target.marko") or include(data.renderBody)
```

However, with respect to https://github.com/marko-js/marko/issues/418, examples and notes illustrate the following approach:

```include()``` is the same as ```include(data.renderBody)```

Commit https://github.com/marko-js/marko/commit/306e19b88e9e305c83b9da1b4eab3fa8e028ee8f introduces the body-slot tag. 

Should we be using body-slot instead of the deprecated w-body tag, or transition to include(data.renderBody)? The `<body-slot>` tag was removed shortly after being added, and `include()` with no arguments was disallowed. I believe `include(data.renderBody)` is now the recommended way to do this.

You can also do something like:
```
<html>
    <head>
        <include(data.head) />
    </head>
    <body>
        <include(data.body || data.renderBody) />
    </body>
</html>
```
Then use it like:
```
<include('./layout.marko')>
    <@head>
        <title>Foo!</title>
    </@head>
    <@body>
        Foo!
    </@body>
</include>
```
or
```
<include('./layout.marko')>
    Foo!
</include>
``` @patrick-steele-idem Thank You. 

I have a all of the code using the proper `include(target)` due to the various research through the issues list. However, it wasn't readily apparent which direction was actually correct and I wanted a bit more feedback on what was the final decision.   In ES6 "of" gives you the value and "in" gives you the key.  Would adding `"body": "static-text"` in the `marko.json` fix that (similar to the [app-markdown](https://github.com/marko-js-samples/ui-components-playground/blob/master/src/components/app-markdown/marko-tag.json) sample component)?  
[![Coverage Status](https://coveralls.io/builds/9553643/badge)](https://coveralls.io/builds/9553643)

Coverage increased (+0.005%) to 88.435% when pulling **45c9d2e7cad4332b03ef885c80ba032d7adc1e37 on austinkelleher:514-deprecate-widget-types** into **a5ce5182b63b7614d5f4454e1502c3fdde7cffbc on marko-js:master**.
  ## Input tag is being filled with undefined value when the component's state change.

### Context
I found what I think is a bug. When I change the state of my component and there is an input in the template, Marko fills it with an undefined value even if I don‚Äôt explicitly set the input‚Äôs value .


![image](https://cloud.githubusercontent.com/assets/5007653/21706817/dc09a5b2-d397-11e6-8df5-67627de085a7.png)

that‚Äôs my template markup

![image](https://cloud.githubusercontent.com/assets/5007653/21706827/f4a06b06-d397-11e6-8615-792ca4fbdb7e.png)

my component‚Äôs code

I am currently using `4.0.0-beta.5`

I updated to  `4.0.0-beta.8` and still getting that error

### Expected Behavior

Input's value shouldn't be set.

### Actual Behavior
Input's value is getting filled with an undefined value.

### Environment
* Version used: 4.0.0-beta.5 and 4.0.0-beta.8
* Environment: Chrome  55.0.2883.95 and node.js 7.3.0
* Operating System and version: macOS 10.12.2
  
[![Coverage Status](https://coveralls.io/builds/9540973/badge)](https://coveralls.io/builds/9540973)

Coverage increased (+0.001%) to 88.434% when pulling **42ba9e135d76965c2ffe49ccb543384816accdba on austinkelleher:421-deprecate-w-bind** into **6aaf8679a88e53cef644582e51edca94517a51e4 on marko-js:master**.
 
[![Coverage Status](https://coveralls.io/builds/9541118/badge)](https://coveralls.io/builds/9541118)

Coverage increased (+0.001%) to 88.434% when pulling **444550ee61753923dba844466c758f6b35d0fb52 on austinkelleher:421-deprecate-w-bind** into **6aaf8679a88e53cef644582e51edca94517a51e4 on marko-js:master**.
 
[![Coverage Status](https://coveralls.io/builds/9551413/badge)](https://coveralls.io/builds/9551413)

Coverage increased (+0.006%) to 88.436% when pulling **2e7d202cd5e8f61358c79f14ae1b1a4b865b7dd0 on austinkelleher:421-deprecate-w-bind** into **a5ce5182b63b7614d5f4454e1502c3fdde7cffbc on marko-js:master**.
 
[![Coverage Status](https://coveralls.io/builds/9551413/badge)](https://coveralls.io/builds/9551413)

Coverage increased (+0.006%) to 88.436% when pulling **2e7d202cd5e8f61358c79f14ae1b1a4b865b7dd0 on austinkelleher:421-deprecate-w-bind** into **a5ce5182b63b7614d5f4454e1502c3fdde7cffbc on marko-js:master**.
 
[![Coverage Status](https://coveralls.io/builds/9551413/badge)](https://coveralls.io/builds/9551413)

Coverage increased (+0.006%) to 88.436% when pulling **2e7d202cd5e8f61358c79f14ae1b1a4b865b7dd0 on austinkelleher:421-deprecate-w-bind** into **a5ce5182b63b7614d5f4454e1502c3fdde7cffbc on marko-js:master**.
 
[![Coverage Status](https://coveralls.io/builds/9552196/badge)](https://coveralls.io/builds/9552196)

Coverage increased (+0.007%) to 88.437% when pulling **f091f35dddb0cbc524d4e46b4653c4c9231c3b8e on austinkelleher:421-deprecate-w-bind** into **a5ce5182b63b7614d5f4454e1502c3fdde7cffbc on marko-js:master**.
  üëç  ## Bug Report

### Context
<!--- Provide a more detailed introduction to the issue itself, and why you consider it to be a bug.  How has this bug affected you? What were you trying to accomplish? -->
Using latest marko 4 beta 8, I want to render a component that uses the await tag - purely in the browser. The component is built according to [http://markojs.com/try-online/#Async_Await](http://markojs.com/try-online/#Async_Await)

```JavaScript
var template = require('./template.marko');

module.exports = function(input, out) {
  template.render({
    userDataProvider: function(args, callback) {
      var backThen = Date.now();
      console.log('renderer.js:6 - starting...');
      setTimeout(function() {
        console.log('renderer.js:9 - done', Date.now() - backThen);
        callback(null, {
          firstName: 'John',
          lastName: 'Doe',
          age: 50
        });
      }, 2500);
    }
  }, out);
};
```

while being required by a simple index page that collects all the components (currently just one)

```JavaScript
var template = require('./index.marko');

template.render({}, function(err, result) {
  result.replaceChildrenOf(document.getElementById('root'));
});
```

which itself is injected via lasso `2.8.4` / lasso-cli `2.0.6` / lasso-marko `2.2.0` into a simple `index.html` file.

Checkout [https://github.com/Primajin/markojs-4-clientside](https://github.com/Primajin/markojs-4-clientside) as a reference.

### Expected Behavior
<!--- Tell us what should happen -->
Template should render asynchronously after 2,5 seconds.

### Actual Behavior
<!--- Tell us what happens instead -->
Tab / Browser uses 99% of CPU, can only be killed by taskmanager. Smells like an infinite loop.

### Possible Fix
<!--- Not obligatory, but suggest a fix or reason for the bug -->
instead of using `replaceChildrenOf` use `appendTo`

```JavaScript
var template = require('./index.marko');

template.render({}, function(err, result) {
  result.appendTo(document.getElementById('root'));
});
```

<details><summary>Additional Info</summary>

### Your Environment
<!-- Include as many relevant details about the environment you experienced the bug in -->
* Version used: 4.0.0-beta.8
* Environment name and version (e.g. Chrome 39, node.js 5.4): Chrome Version 57.0.2972.0 (Offizieller Build) **canary** (64-Bit)
* Operating System and version (desktop or mobile): Desktop MBP 10.12.2 (Sierra) 
* Link to your project: https://github.com/Primajin/markojs-4-clientside

### Steps to Reproduce
<!--- Provide a link to a live example, or an unambiguous set of steps to -->
<!--- reproduce this bug include code to reproduce, if relevant -->
1. Check out my project
2. `npm install`
3. switch lines 4 and 6 in `src/index.js`
4. `npm run build`
5. open `index.html` in your browser
</details>
 I think it's duplicate of  https://github.com/marko-js/marko/pull/505   <!----------------------
  |     IF BUG REPORT    |
  ---------------------->
## Bug Report

### Context
In node-require.js, right before the module.exports, `install()` is called. Consequently, default options are used.
* This causes an exception to be thrown on read-only systems since the default option in the compiler is to writeToDisk. 
* This also results in `install()` potentially being called twice.

### Expected Behavior
`require("marko/node-require").install({compilerOptions: {writeToDisk: false}})` should result in a single call to `install()`, with the options specified.

### Actual Behavior
`require("marko/node-require").install({compilerOptions: {writeToDisk: false}})` calls `install()` twice: Once from the base class (just before the `module.exports` line) with no options, and a second time with the options specified.

### Possible Fix
Remove `install();` on line 134 of node-require.js. Note: With this fix, `require("marko/node-require")` will no longer by default call `install()`.

<details><summary>Additional Info</summary>

### Your Environment
* Version used: 4.0.0-beta.8
* node.js version: v6.9.1
* Operating System: Windows 10 x64


</details>
 Related: #365  ../widgets/util - don't have  $__destroyWidgetForEl and $__destroyElRecursive functions

Fixed infinite loop in replaceChildrenOf function  main.marko
```
<include('../layouts/default.marko', data)>
	<@pagetitle></@pagetitle>
	<@body>
		<include ('./user.marko', data)/>
	</@body>
</include>
```
default.marko
```
<!doctype html>
<html lang="en">
	<head>
		<meta charset="UTF-8"/>
		<meta name="format-detection" content="telephone=no">
		<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no, maximum-scale=1">
		<title>
			<if (data.pagetitle)><include (data.pagetitle)></include></if>
		</title>
		<link rel="stylesheet" href="/build/style/front.css">
	</head>
	<body>
		<include("../parts/sidebar.marko", data) />
		<if(data.body)>
			<main>
				<include(data.body) />
			</main>
		</if>
	</body>
</html>
```

with <!doctype html> in first line of template error has been happend
```
ERROR in ../api/views/front/layouts/default.marko
Module build failed: Error: Node does not have a `writeCode` method: {
    "type": "DocumentType"
}
    at CodeWriter.write (/var/www/node_modules/marko/compiler/CodeWriter.js:113:9)
    at writeNode (/var/www/node_modules/marko/compiler/CodeWriter.js:80:26)
    at Array.forEach (native)
    at CodeWriter.writeStatements (/var/www/node_modules/marko/compiler/CodeWriter.js:98:19)
    at CodeWriter.writeBlock (/var/www/node_modules/marko/compiler/CodeWriter.js:48:14)
    at FunctionDeclaration.writeCode (/var/www/node_modules/marko/compiler/ast/FunctionDeclaration.js:60:16)
    at CodeWriter.write (/var/www/node_modules/marko/compiler/CodeWriter.js:115:18)
    at writeNode (/var/www/node_modules/marko/compiler/CodeWriter.js:80:26)
    at Array.forEach (native)

    at CodeWriter.writeStatements (/var/www/node_modules/marko/compiler/CodeWriter.js:98:19)
    at Program.writeCode (/var/www/node_modules/marko/compiler/ast/Program.js:16:16)
    at CodeWriter.write (/var/www/node_modules/marko/compiler/CodeWriter.js:115:18)
    at CompiledTemplate.get code [as code] (/var/www/node_modules/marko/compiler/Compiler.js:99:20)
    at _compile (/var/www/node_modules/marko/compiler/index.js:90:24)
    at compile (/var/www/node_modules/marko/compiler/index.js:100:12)
    at Object.compileForBrowser (/var/www/node_modules/marko/compiler/index.js:111:12)
    at Object.module.exports (/var/www/node_modules/marko-loader/src/index.js:7:30)
 @ ../api/views/front/common/404.marko 2:23-58
```

without DOCTYPE it works.

Type of compile - vdom with compileFileForBrowser function. I can't think of any use-cases where this would really be necessary, but I also can't see much reason to throw an error. Browsers seem to silently remove the `<!DOCTYPE>` tag whenever it occurs somewhere it shouldn't, I feel like that's probably the best thing for Marko to do as well. I just tried to reuse server templates on client side. Thanks for the patch!  <!----------------------
  |     IF BUG REPORT    |
  ---------------------->
## Bug Report

### Context
```
<div id="cartShipSelList" class="prodDDList">
    <ul>
      <li for(opt in data.shipMethods) onMouseOver("handleHover") onMouseOut("handleRemHover")>Sample Text</li>
    </ul>
</div>
```

### Expected Behavior
Currently only one of them will work on it's own, they work when one is not included. You would expect to both be able to receive onMouseOver and onMouseOut events.

### Actual Behavior
Template will not compile with both as it errors at: 
```
marko_forEach(data.shipMethods, function(opt) {
    widget.e("mouseout", "handleRemHover", __widgetId1);
```

Stating that __widgetId1 is undefined


<!--- Provide a link to a live example, or an unambiguous set of steps to -->
<!--- reproduce this bug include code to reproduce, if relevant -->
1. 
2. 
3. 
4. 

### Stack Trace
index.marko.js:273 Uncaught ReferenceError: __widgetId1 is not defined
    at index.marko.js:273
    at forEachHelper (helpers.js:93)
    at render (index.marko.js:272)
    at renderer (renderer.js:273)
    at Template.renderSync (renderable.js:37)
    at displayWidget (tfv5.js:1382)
    at Object.<anonymous> (tfv5.js:1436)
    at i (jquery.min.js:2)
    at Object.fireWith [as resolveWith] (jquery.min.js:2)
    at z (jquery.min.js:4)
(anonymous) @ index.marko.js:273
forEachHelper @ helpers.js:93
render @ index.marko.js:272
renderer @ renderer.js:273
renderSync @ renderable.js:37
displayWidget @ tfv5.js:1382
(anonymous) @ tfv5.js:1436
i @ jquery.min.js:2
fireWith @ jquery.min.js:2
z @ jquery.min.js:4
(anonymous) @ jquery.min.js:4

</details>  
[![Coverage Status](https://coveralls.io/builds/9504769/badge)](https://coveralls.io/builds/9504769)

Coverage remained the same at 88.264% when pulling **e425290687ca050b3e0453dcc77a393f0273e0c6 on austinkelleher:no-update-data-attr** into **832cc6d328dcb750fc28f2c1d72c7c80ac863fcb on marko-js:master**.
 
[![Coverage Status](https://coveralls.io/builds/9504856/badge)](https://coveralls.io/builds/9504856)

Coverage remained the same at 88.264% when pulling **e425290687ca050b3e0453dcc77a393f0273e0c6 on austinkelleher:no-update-data-attr** into **832cc6d328dcb750fc28f2c1d72c7c80ac863fcb on marko-js:master**.
  <!----------------------
  |     IF BUG REPORT    |
  ---------------------->
## Bug Report

### Context
Updating from version v3.13.0 to v3.14.0 adds lots of warnings about single hyphen for concise line being deprecated. I think such behaviour should occur on next major release as it requires a lot of code changes. Moreover, there is no clear documentation on how code should be changed as replacing `-` with `--` does not always make the warning disappear.

```
The usage of a single hyphen at the start of a concise line is now deprecated. Use "--" instead.
See: https://github.com/marko-js/htmljs-parser/issues/43
```

<details>

### Your Environment
<!-- Include as many relevant details about the environment you experienced the bug in -->
* Version used: v3.14.0
* Environment name and version: node.js 6.9

### Code sample producing warnings

This is valid v3.13 syntax
``` marko
<!DOCTYPE html>
html [lang="en"]
  body
    h1 - Title
    script
      - var a = 'marko';
```

If translated to either this styles it still outputs the warning (for line 6):

``` marko
<!DOCTYPE html>
html [lang="en"]
  body
    h1 -- Title
    script
      -- var a = 'marko';
```

``` marko
<!DOCTYPE html>
html [lang="en"]
  body
    h1 -- Title
    script
      ---
      var a = 'marko';
      ---
```

Only this style is not printing any warning: 

``` marko
<!DOCTYPE html>
html [lang="en"]
  body
    h1 -- Title
    script --
       var a = 'marko';
```

So will this last one be the only allowed style in the future?

</details>
 Thanks for the quick resolution. As wrapping code with `---` is still valid I don't think it will be a major pain. 
I just had an "oh dear, WTF" moment after updating Marko, as nothing was said in the changelog so I thought npm went crazy and messed up versions üòâ   
[![Coverage Status](https://coveralls.io/builds/9489127/badge)](https://coveralls.io/builds/9489127)

Coverage remained the same at 88.032% when pulling **f13c75d7493cd109e5220a26fc4f9c6987e13cd2 on austinkelleher:495-import-colon** into **306e19b88e9e305c83b9da1b4eab3fa8e028ee8f on marko-js:master**.
  <!----------------------
  |     IF BUG REPORT    |
  ---------------------->
## Bug Report

### Context
Renaming destruction imports are not working in `v4.0-beta.5` :

```
<import { client: twilio } from '../../lib/twilio.js' />
```

results in compilation error, while

```
<script template-helpers>
  const { client: twilio } = require('../../lib/twilio.js');
</script>
```

works fine... Sorry, my fault, I forgot ES6 syntax while doing refactoring for `<import>` from `require`. Thank you!  
[![Coverage Status](https://coveralls.io/builds/9484750/badge)](https://coveralls.io/builds/9484750)

Coverage increased (+0.07%) to 88.105% when pulling **d67e55fda6aee9191639965ac82f6dacc7ee1ce5 on austinkelleher:422-deprecate-w-preserve-attrs** into **306e19b88e9e305c83b9da1b4eab3fa8e028ee8f on marko-js:master**.
 
[![Coverage Status](https://coveralls.io/builds/9500522/badge)](https://coveralls.io/builds/9500522)

Coverage increased (+0.01%) to 88.242% when pulling **30575767240ca069d437f440986b9c6dcac48c92 on austinkelleher:422-deprecate-w-preserve-attrs** into **28392e985f7496aba23519c7e180e955628e595a on marko-js:master**.
 
[![Coverage Status](https://coveralls.io/builds/9500607/badge)](https://coveralls.io/builds/9500607)

Coverage increased (+0.01%) to 88.241% when pulling **30575767240ca069d437f440986b9c6dcac48c92 on austinkelleher:422-deprecate-w-preserve-attrs** into **28392e985f7496aba23519c7e180e955628e595a on marko-js:master**.
  ## Bug Report

### Context

in dom.js exports.mixin

target[methodName] = function(referenceEl) is reached with referenceEl as a string

It then goes on to try to get the ownerDocument with referenceEl.ownerDocument which won't work on a string so doc is undefined.

it then goes through var newNode = getNode.call(this, doc); with an undefined doc but still creates the new dom element

then appendTo(newChild, referenceParentEl) is called and it appends the widget div to the referenceParentEl

it then goes into the following with the same undefined doc and emits a mount node event
if (afterInsert) {
    afterInsert.call(this, doc);
}

then emits a mount event

then entered initClientRendered(widgetDefs, doc) in init-widgets-browser.js with an undefined doc and tries to fix the undefined doc with window.doc which resolves undefined also

then initWidget(widgetDef, doc) with that undefined doc

then tries to get rootIds with var rootIds = widgetDef.roots; which returns undefined so it skips the next code block to go right to:
el = doc.getElementById(id);
el.__widget = widget;
els = [el];

this is where it errors due to doc being undefined

### Expected Behavior
getNode() should be called if the input is a string

### Actual Behavior
string is never converted to a dom reference so it continues to be treated as a string through following calls

### Possible Fix
call getNode() on initial input


### Your Environment
<!-- Include as many relevant details about the environment you experienced the bug in -->
* Version used:
* Environment name and version (e.g. Chrome 39, node.js 5.4):
* Operating System and version (desktop or mobile):
* Link to your project:

### Steps to Reproduce
<!--- Provide a link to a live example, or an unambiguous set of steps to -->
<!--- reproduce this bug include code to reproduce, if relevant -->
in a client side js file call the following (with the path changed to your widget)
1. var catProdWidget = require('src/components/cat-prod-widget');
2. catProdWidget.renderSync().appendTo('catProdList').getWidget();
3. 
4. 

### Stack Trace
<!-- If an error is thrown, provide the stack trace here -->
Uncaught TypeError: Cannot read property 'getElementById' of undefined
    at initWidget (http://localhost:3003/static/src/marko$4.0.0-beta.4/widgets/init-widgets-browser.js:117:17)
    at Object.initClientRendered (http://localhost:3003/static/src/marko$4.0.0-beta.4/widgets/init-widgets-browser.js:238:22)
    at WidgetsContext.initWidgets (http://localhost:3003/static/src/marko$4.0.0-beta.4/widgets/WidgetsContext.js:79:21)
    at EventEmitter.<anonymous> (http://localhost:3003/static/src/marko$4.0.0-beta.4/widgets/index-browser.js:80:28)
    at EventEmitter.emit (http://localhost:3003/static/src/events$1.1.1/events.js:81:17)
    at RenderResult.afterInsert (http://localhost:3003/static/src/marko$4.0.0-beta.4/runtime/RenderResult.js:69:16)
    at RenderResult.afterInsert (http://localhost:3003/static/src/marko$4.0.0-beta.4/runtime/RenderResult.js:110:14)
    at RenderResult.exports.mixin.Object.keys.forEach.target.(anonymous function) [as appendTo] (http://localhost:3003/static/src/marko$4.0.0-beta.4/runtime/dom.js:130:29)
    at loadAll (http://localhost:3003/static/src/Tree_Fort_Bikes_5_0$1.0.0/site/public/js/tfv5.js:2722:34)
    at HTMLDocument.<anonymous> (http://localhost:3003/static/src/Tree_Fort_Bikes_5_0$1.0.0/site/public/js/tfv5.js:2620:7)
</details>
  ## New Feature
Currently there is no easy way to use Marko for plain text parsing. 

### Description
Add non-renderable block to tell Marko to thread this block as text-only (still parsing variables and conditionals and such, just not forcing to transform html tags). 

### Context
The use case is for email rendering, where you probably want to render a html and text version. For example using [nodemailer ](https://github.com/nodemailer/nodemailer)> [node-email-templates](https://github.com/crocodilejs/node-email-templates) > [consolidate.js](https://github.com/tj/consolidate.js) will result in having problems to render the text version as marko will try to generate html tags out of the text sentences.

### Possible Implementation
#### Option 1)
e.g. see this proposal https://github.com/marko-js/marko/issues/343
```
<marko-parser body='static-text'>
        Content
         More Content
        ${data.myVar}
</marko-parser>
```
Important: In this example the output should not include the <marko-parser> tag

#### Option 2)
Javascript call has a new attribute to specify whether the template should be parsed as text-only or with html (transformations) Thanks for your quick response. Unfortunately i does not work. As soon as i'm using <static-text> in my template, the output is null (no error in console). I tried to move the components folder to different places, but nothing worked. Also i added a renderer.js or template.json but also... no luck. Maybe it has something to do how consolidate is calling Marko(`.load(options.filename, ContentAsStr, options`), although i would assume the actual folder lookup should not be affected by this. currently my workaround is to use

```
<div marko-preserve-whitespace>
         Content
         More Content
        ${data.myVar}
</div>
```

and then manually removing both divs from the output string. the latest from npm. 3.13.2 Perfect, now it works flawlessly. I guess the code-generator.js was the missing puzzle piece ;) Thx for the help and your (still very) quick response. Highly appreciated. And yes, it works for v3 too.   
[![Coverage Status](https://coveralls.io/builds/9452562/badge)](https://coveralls.io/builds/9452562)

Coverage increased (+0.004%) to 87.968% when pulling **405ff119b42b9eed4d88951beb932f3ef5531050 on austinkelleher:477-for-map** into **b0d77b8cb03535c42b88d4e10be14bb1a7b6f6f7 on marko-js:master**.
 
[![Coverage Status](https://coveralls.io/builds/9452562/badge)](https://coveralls.io/builds/9452562)

Coverage increased (+0.004%) to 87.968% when pulling **405ff119b42b9eed4d88951beb932f3ef5531050 on austinkelleher:477-for-map** into **b0d77b8cb03535c42b88d4e10be14bb1a7b6f6f7 on marko-js:master**.
 
[![Coverage Status](https://coveralls.io/builds/9452562/badge)](https://coveralls.io/builds/9452562)

Coverage increased (+0.004%) to 87.968% when pulling **405ff119b42b9eed4d88951beb932f3ef5531050 on austinkelleher:477-for-map** into **b0d77b8cb03535c42b88d4e10be14bb1a7b6f6f7 on marko-js:master**.
  <!----------------------------------------------------------------------
  |     IF FEATURE SUGGESTION (skip to next section for bug reports)    |
  ---------------------------------------------------------------------->
## New Feature

### Description
There are 2 use cases for this:
1. People who want to primarily use React but want to have some (perhaps presentational-only) components written in marko.
2. People who use primarily marko templates but want to use React (i.e. render React components) in some dynamic pages (this is marko-widget's use case, but let's say that a hype-driven tech lead wants React for dynamic stuff by all means necessary).

### Context
1. We need an easy-to-use template system as we have freelancers churning out new templates that come and go every once in a while. Here, marko seems like a good fit.
2. Static parts need to be easily integrated with non-React JS libraries like jQuery. Dynamic parts are written in React.
3. The team has invested quite a bit in the React ecosystem, so we are not keen on introducing something like marko-widgets.
4. We are concerned with the performance of server-side React rendering.

From reasons above, [react-templates](https://github.com/wix/react-templates) almost made it but not quite (mainly due to reasons 2 and 4).

After this, marko users can also tap into the larger React ecosystem for things like integration, off-the-shelf components.

### Possible Implementation
The 2 use cases boils down to these requirements:
1. Render React components in marko perhaps using taglib. (e.g. `<div><react-component prop1="a" prop2="b"/></div>`) This react root should be able to have isomorphic/universal rendering (meaning it can gain the ability to be re-rendered client-side, if the developer chooses to include react on client side).
2. Render marko components as React components. (e.g. in JSX: `<div><MarkoTemplate template={require("a/b.marko")} /></div>`) 

Both seems very doable to me, but would like some input on potential headaches.

1. This can (should?) be an optional module / custom taglib.
2. Each `<react-component/>` tag can live as a separate React root. Most SPAs only have one root that renders the whole page, but this usually won't be the case if rendering starts from marko. 

### Open Questions
1. Do we need to handle children tags inside templates (the content inside `MarkoTemplate`)?
2. Need to figure out how to use singleton store (redux etc) for multiple React roots.
3. Building SPAs will be difficult if we have multiple react roots in a page, but this may be a concern more for React and not for marko.

### Is this something you're interested in working on?
Yes
 I think the best solution long-term would be to have Marko have seamless interoperability with custom elements. That way, react / mithril / any library will be able to work without any extra work from marko.

For research, [server-components](https://github.com/pimterry/server-components) has done some work in this area. Thanks for the inputs. I believe v4 is just around the corner looking at the beta releases coming out these few days?

> It's possible to translate a rendered Marko VDOM tree to a React VDOM tree with a performance hit (via tree traversal of the Marko VDOM output)

This is what I pondered on as well - there is something similar for handlebars: https://github.com/stevenvachon/handlebars-react I don't know much about marko internals but maybe translating parsed AST to React VDOM directly can be a better approach?

> Alternatively, a Marko component can be rendered and mounted during the componentDidUpdate() lifecycle method (client-side only)

CMIIW, but I think if we render a new react root in `componentDidUpdate` the VDOM diffing would never work because it is a fresh re-render each time. This should be much simpler to implement though, as compared to VDOM translation.  ## New Feature

### Description
```
var str = __helpers.s,
      ...
      cv = '4.0.1-beta4'
```

### Context

Sometimes it's difficult to determine *which* compiler version output the *.js on disk (ie- command line compiler, marko-loader, etc).  This is a possible enhancement to aid in debugging, perhaps sometimes you need bug reports of "send me template.marko and template.marko.js" and it'd be nice to know *how* template.marko.js was transformed.

Drawback is an increase in filesize per template.marko.js, over a project w/ 50 templates, could be ~500 bytes, although very likely they would gzip well since all would be identical. (in addition, add `--version | -v` support to `markoc` command)  Currently:
```
  "devDependencies": {                                                          
    "marko": "^3.10.0"                                                          
  },                                                                            
```   
[![Coverage Status](https://coveralls.io/builds/9437515/badge)](https://coveralls.io/builds/9437515)

Coverage remained the same at 87.964% when pulling **39defaaf9ea434f3a3519d44ab2098f101ea844c on Hesulan:issue-484** into **291f67849215549e97f9bd7b52904d3bfa2403e0 on marko-js:master**.
 
[![Coverage Status](https://coveralls.io/builds/9437515/badge)](https://coveralls.io/builds/9437515)

Coverage remained the same at 87.964% when pulling **39defaaf9ea434f3a3519d44ab2098f101ea844c on Hesulan:issue-484** into **291f67849215549e97f9bd7b52904d3bfa2403e0 on marko-js:master**.
  The widget runtime uses a custom `.concat` method, but the native array `.concat` method returns a new array without modifying the original, which results in `window.$widgets` being an empty array and the init code being lost if the widgets are initialized before the runtime registers its custom method. 
[![Coverage Status](https://coveralls.io/builds/9397580/badge)](https://coveralls.io/builds/9397580)

Coverage remained the same at 87.934% when pulling **3eedac5e51170dcf95bd714058ff4ddb04c5ec14 on Hesulan:async-widget-bug** into **42fceecce5f10bd6c7e0ed38efe75f6bb8f54720 on marko-js:master**.
  Does this mean getRenderedWidgetIds will deprecate after 4.0? Which function can replace it then? Thanks.  <!--- Provide a general summary of your changes in the Title above -->

## Description
<!--- Describe your changes in detail -->
Minor update to documentation. Adding VSCode's syntax highlighter.

## Motivation and Context
<!--- Why is this change required? What problem does it solve? -->
<!--- If it fixes an open issue, please link to the issue here. -->

## Screenshots (if appropriate):

## Checklist:
<!--- Go over all the following points, and put an `x` in all the boxes that apply. -->
<!--- If you're unsure about any of these, don't hesitate to ask. We're here to help! -->
- [x] My code follows the code style of this project.
- [x] I have updated/added documentation affected by my changes.
- [x] I have read the **CONTRIBUTING** document.
- [ ] I have added tests to cover my changes.
- [x] All new and existing tests passed.
 
[![Coverage Status](https://coveralls.io/builds/9333532/badge)](https://coveralls.io/builds/9333532)

Coverage remained the same at 87.742% when pulling **ea1d74e27e360f5d4add14f718512abbcd9ee7fe on johnjv:vscode-ext** into **fae66bfb0692725edaf04025f80ff9109e52aa18 on marko-js:master**.
    <!----------------------
  |     IF BUG REPORT    |
  ---------------------->
## Bug Report

### Context
I am trying to use a dynamic expression to set an html tag. The compiled code seems to be slightly incorrect, resulting in mangled html.

My marko looks like (adding parenthesis here doesn't help):
```
<${data.type === 'primary' ? 'div' : 'span'}> 
```

### Expected Behavior
Compiled output should be
`out.w("<" + (data.type === "primary" ? "div" : "span") + ">");`

### Actual Behavior
Compiled output is:
`out.w("<" + data.type === "primary" ? "div" : "span" + ">");`

</details>
 @mlrawlings Thanks for the quick fix!  Hello,

Destructing `import` like following¬†compiles correctly:

```html
<import¬†{ readFileSync } from 'fs' />
```
results to following:
```javascript
   fs = require("fs"),
¬†¬† readFileSync = fs.readFileSync,
```

However, destructing imports, like
```html
<import { asset } from '../../../shared/marko/asset' />
```

results in wrong compilation:
```javascript
asset = require("../../../shared/marko/asset"),
asset2 = asset.asset,
```

Side note: which version of Node Marko 4¬†is¬†targeting? Why not current LTS (Node 6) and just keep destruction intact, as well as use¬†`const` instead of `var`?
 @tinovyatkin The compiler currently requires ES6 (Node 4+), but all built-in taglibs are currently designed to compile into ES5-compatible code (ES6+ tags *may* eventually be included if there's enough interest - see #428). This is so that templates can be rendered in all modern browsers without needing to be transpiled.

The `asset2` assignment is definitely an oversight, it's *supposed* to prevent automated naming collisions but in this case appears to be renaming the wrong one. As far I see ¬†`<import>` compiles into `require` and it's no way browser compatible with our without destruction. And it's new tag, so, I think it's quite fair to require `ES6` for new tags without loosing any backward compatibility
 Plenty of modern client-side code depends on a third-party library like `browserify` to implement CommonJS `require`, and Marko is no exception. In other words, `require()` most certainly *is* browser-compatible.

That being said, I do like the idea of native ES6+ tags, as long as they're opt-in and clearly marked - see #428, toward the end of the discussion. If anyone is interested, let me know and we can discuss the details. @Hesulan I'm sorry to say, but there is no logic to say `can be rendered in all modern browsers without needing to be transpiled` and then `require() most certainly is browser-compatible`. No, it's not.¬†There is no browser on the planet that understand `require` without transpilation¬†/ compilation / whatever you want to call it. So, the question¬†still remain - why introduce new tag that¬†have no way (apart of static inlining) to compile into ES5 and attempt to compile it into ES5 while you just may keep it as ES6 / node destruction? @tinovyatkin Marko and Marko Widgets run in the current versions of all major browsers without any transpiling. While `require()` certainly isn't native, it's considered a dependency, or at worst a polyfill. Native destructuring would require the entire file to be transpiled, and there's no reason to do that here since the current ES5 implementation already works perfectly aside from this bug.

Don't get me wrong, I'm certainly not against ES6+ features in the core taglibs; in fact, if you look at the PR I linked to, you'll see that I've personally been working on exactly that. But `<import>` is a *really* useful tag for all environments, and in this case the cost would far outweigh the gain. @scttdavs Another option might be to use one of the reserved template variable names ('data' or 'out') to temporarily store each module:
```js
var data = require("asset");
var asset = data.asset;
var data = ...
```
If someone needs to `<import { data as data } from 'asset' />` then they're probably doing something wrong, since it will get overwritten by `render(data, out)` anyway. If it's a vote, I certainly hope Marko developers will decide to just keep destruction intact and document that fact. It's a shame that nowadays development frameworks sometimes trying to pretend they are for people who don't know how to code. 
You are introducing new tag with `ES6 like imports`, requiring Node 4 for compiler and trying to reinvent the wheel of destruction?

Why not `<import { asset } from 'asset'>` => `const { asset } = require('asset')`?
What exactly is bad with this approach to a new, ES6-like tag? Marko is trying hard to make resulting `.marko.js` readable, and introducing namespaces, generated names, etc, no way helps that..
 It just occurred to me that `require()` is expected to cache loaded modules:
```
var foo = require('./foo').foo;
var bar = require('./foo').bar;
```
Not very pretty, but perhaps more readable, and definitely more collision-proof. Thoughts? @patrick-steele-idem Good point. I don't think execution speed would really be a problem since all of this is happening once when the module is first loaded, but minifying would be, especially with lasso since the url becomes a lot longer...

The `_module` suffix solution should work just fine, as long as it's well documented.   ```
    {
      "name": "test",
      "script": "./src/test",
      "instances": 1,
      "exec_mode": "cluster",
      "watch": true,
      "env": {
        "INTERVAL" : 60000,
        "HOST": "127.0.0.1",
        "PORT": 14211
      }
    },
```

i have error: `Error: Cannot find module 'marko'` @khmelevskii Works for me. Are you still having this problem? If so, could you give more details? I just experienced similar problems. Although my application runs under pm2, it does not render the HTML properly. For the record, I am requiring the module using `require('marko/node-require').install();`.

No problems when starting the application with `node app.js`, but with pm2, the HTML does not get rendered anymore. Google Chrome doesn't even render the HTML, but simply displays the raw HTML instead.

If you need, I could provide a more accurate description of what is happening, but please specify what kind of details you would want. @patrick-steele-idem Although the `Content-Type` header was not the issue, I can now confirm that my problems were separate from the issue discussed in the original ticket. My apologies for the inconvenience, however I can now confirm that pm2 does work with marko. I've been using pm2 successfully with both Marko v3 and Marko v4 (latest beta) without any problems. No problems here.  `include` or new `import` syntax within this `<style>` will be very good addition too! As well as an API for tag renderer to append anything to this, like `out.styles.append('.test-rule { color: red }')`   
[![Coverage Status](https://coveralls.io/builds/9053451/badge)](https://coveralls.io/builds/9053451)

Coverage increased (+0.03%) to 84.019% when pulling **99e7873d6c34d80aa754a46131cd3371322be776 on v3-render-to-string** into **91c215c054f011a148cd5d04b7fca2af28bd38ab on v3**.
  
[![Coverage Status](https://coveralls.io/builds/9013227/badge)](https://coveralls.io/builds/9013227)

Coverage increased (+0.03%) to 86.828% when pulling **eb140ab1119c217028a0d6f571bad4f6678e5ada on scttdavs:import-tag** into **41b115909066619032ae8d3e80c49432083b13c8 on marko-js:master**.
 
[![Coverage Status](https://coveralls.io/builds/9015917/badge)](https://coveralls.io/builds/9015917)

Coverage increased (+0.02%) to 86.822% when pulling **4633d841126e30a1b88f6a825983facf4e0a9f9f on scttdavs:import-tag** into **41b115909066619032ae8d3e80c49432083b13c8 on marko-js:master**.
 
[![Coverage Status](https://coveralls.io/builds/9016368/badge)](https://coveralls.io/builds/9016368)

Coverage increased (+0.05%) to 86.844% when pulling **66768de91ca07c801265898c493768230f9ac325 on scttdavs:import-tag** into **41b115909066619032ae8d3e80c49432083b13c8 on marko-js:master**.
 
[![Coverage Status](https://coveralls.io/builds/9016653/badge)](https://coveralls.io/builds/9016653)

Coverage increased (+0.02%) to 86.821% when pulling **dfe85613d42fe82b68b098f629da12b13ac00014 on scttdavs:import-tag** into **41b115909066619032ae8d3e80c49432083b13c8 on marko-js:master**.
 
[![Coverage Status](https://coveralls.io/builds/9016653/badge)](https://coveralls.io/builds/9016653)

Coverage increased (+0.02%) to 86.821% when pulling **dfe85613d42fe82b68b098f629da12b13ac00014 on scttdavs:import-tag** into **41b115909066619032ae8d3e80c49432083b13c8 on marko-js:master**.
 
[![Coverage Status](https://coveralls.io/builds/9051041/badge)](https://coveralls.io/builds/9051041)

Coverage increased (+0.02%) to 86.819% when pulling **db7fa47fa19e17dec0a836a7bf4efb65e60c9c33 on scttdavs:import-tag** into **41b115909066619032ae8d3e80c49432083b13c8 on marko-js:master**.
 
[![Coverage Status](https://coveralls.io/builds/9051041/badge)](https://coveralls.io/builds/9051041)

Coverage increased (+0.04%) to 86.84% when pulling **db7fa47fa19e17dec0a836a7bf4efb65e60c9c33 on scttdavs:import-tag** into **41b115909066619032ae8d3e80c49432083b13c8 on marko-js:master**.
  The autotest `compareHelper` now normalizes the ending newline of both the `expected` and `actual` strings to avoid test failures when `expected.*` is saved on a POSIX-compliant (non-Windows) OS. 
[![Coverage Status](https://coveralls.io/builds/8970748/badge)](https://coveralls.io/builds/8970748)

Coverage remained the same at 86.778% when pulling **aacab561eb2bea5436ea56df4b2615d9ea5cf238 on Hesulan:issue-446** into **aa254d165588aafb1605464dec8bd91e70991e3d on marko-js:master**.
  ### Description
The autotests work correctly when the `expected.*` file is created and saved on Windows. However, Linux and OS X comply with POSIX, which requires a proper ending newline (`\n` immediately followed by the `EOF` symbol). The produced `actual.*` file doesn't have one, which causes the autotests to fail.

### Possible Fix
The autotest runner could simply ignore the presence or absence of an ending newline. Alternatively, the rendered output could be made POSIX-compliant (by adding a proper EOF newline), but Windows displays it as a blank line and allows it to be removed which could lead to confusion.

### Steps to Reproduce
1. Open an `expected.*` file from the autotest directory in any text editor
2. Do one of the following:
  a. (Linux or OS X) Save the file with no changes
  b. (Windows) Insert a blank newline at the end of the file and save the changes
3. Run the test suite

### Example
Saving `test/autotests/render/assign-tag/actual.html` on Linux with no changes and running `npm test` produces:
```
AssertionError: 'HELLO 1230' deepEqual 'HELLO 1230\n'
```

### What does Git have to say about all of this?
Git expects there to be an ending newline (because there really *should* be), and has to internally add `"\ No newline at end of file"` as a workaround, shown by github as a red symbol on the last line - go look at the commit diff for almost any file written on Windows, you'll see what I mean.

### Workarounds
The only workaround I can find is to delete the last line and use `echo -n ... >>` to reinsert it without a trailing newline. I agree, and I feel like `/(\r\n|\n)$/` (or `/\r?\n$/`) would probably be safer. The only thing to keep in mind would be if something depends on there being a newline, but that could simply add two newlines (`\n\n`) and only the second one would be removed.  ## Description
Docs on how to create a container template using `<invoke data.renderBody(out) />`

## Motivation and Context
Useful for other users.

## Checklist:
- [x] My code follows the code style of this project.
- [ ] I have updated/added documentation affected by my changes.
- [x] I have read the **CONTRIBUTING** document.
- [ ] I have added tests to cover my changes.
- [x] All new and existing tests passed.
 
[![Coverage Status](https://coveralls.io/builds/8966592/badge)](https://coveralls.io/builds/8966592)

Coverage remained the same at 86.796% when pulling **9a5c2c33a47fa84c341eb2935f67388052c15eb7 on JeroenVdb:master** into **6a9a50402e00b746cbb07cfb6cfeacbd5c8279b9 on marko-js:master**.
  As discussed in #439, the `Promises/A+` specification explicitly defines `.then` as accepting at least two arguments: `onResolved` and `onRejected`. The `.catch` method is defined by ECMAScript for *native* implementations, but third-party libraries are under no obligation to include it (though *most* do, for convenience and compatibility).

In the interest of caution, this only calls `.then(undefined, onRejected)` if neither `.catch` nor `.fail` is a function. However, in my opinion, it would be completely safe to remove those two calls altogether, as any implementation which is even *remotely* compliant will handle this as expected. 
[![Coverage Status](https://coveralls.io/builds/8946857/badge)](https://coveralls.io/builds/8946857)

Coverage decreased (-0.02%) to 86.793% when pulling **96d93ee9fe7de57547cc979e8bd67955d00ae699 on Hesulan:issue-439** into **270ae3d17aba69ec2357fe187b7bf20fd16f11da on marko-js:master**.
 
[![Coverage Status](https://coveralls.io/builds/8950094/badge)](https://coveralls.io/builds/8950094)

Coverage decreased (-0.03%) to 86.778% when pulling **3f203366623733d8f5b1e17f82c94f8c2bdee52c on Hesulan:issue-439** into **270ae3d17aba69ec2357fe187b7bf20fd16f11da on marko-js:master**.
 
[![Coverage Status](https://coveralls.io/builds/8950094/badge)](https://coveralls.io/builds/8950094)

Coverage decreased (-0.03%) to 86.778% when pulling **3f203366623733d8f5b1e17f82c94f8c2bdee52c on Hesulan:issue-439** into **270ae3d17aba69ec2357fe187b7bf20fd16f11da on marko-js:master**.
  
[![Coverage Status](https://coveralls.io/builds/8937323/badge)](https://coveralls.io/builds/8937323)

Coverage decreased (-0.1%) to 86.697% when pulling **152717cbaac60dc0a19bb151dd3ae004a8a09ffa on render-api** into **270ae3d17aba69ec2357fe187b7bf20fd16f11da on master**.
 Doesn't this cause "finish" to return a new RenderResult, making the "self.on('finish', function(){ resolve(new RenderResult(out)); })" redundant?

Either way, looks great to me! I'll look a bit closer tomorrow just to be sure, but I believe this should work perfectly, at least concerning Promise compliance. (In other words, wouldn't "self.on('finish', resolve);" do the same thing? Or I might just have mis-read something.) Nevermind, was half asleep when I typed that, I did mis-read something. Just skimmed over the code again, it all looks good to me!  I finally got around to looking at the newly added `.then` method from #423 , and it turns out that it's nowhere near spec-compliant: attempting to call `.catch` causes an error to be thrown ("TypeError: fn is not a function", referring to the `undefined` passed as the first argument to `.then(fn, fnErr)`), the handlers are called synchronously, ~~and `.then` itself ceases to function properly once the stream is finished (subsequent calls return a Promise resolved with `undefined`).~~

~~There are only 3 possible solutions I can think of:~~
~~1. Let `.then` be non-compliant. It will only work if called *before* the stream is finished, among other things.~~
~~2. Attach a Promise instance to the stream regardless of whether `.then` is ever called or not. The renderer would then always require a native or polyfilled `Promise` implementation, even if `.then` is never actually used.~~
~~3. Write a partial `Promise` implementation directly into the renderer. I could do this if needed, but it would probably be better to simply require a native or polyfilled implementation.~~

EDIT: It seems I was mistaken about it ceasing to function after 'finish' is called, though it doesn't quite appear to function correctly in the first place.

EDIT 2: I'm actually getting all sorts of weird problems from this code and I'm not entirely sure what's causing most of them. In case someone else wants to take a stab at it, here's a spec-compliant solution, but it caused the test suite to throw an out-of-memory error when I tried it:
```js
then: function(fn, fnErr) {
    var self = this;
    return new Promise(function(resolve, reject) {
        self.on('error', reject);
        self.on('finish', resolve);
    }).then(fn, fnErr);
}
``` So I just now realized why that was throwing an error: The stream itself is being passed to 'finish', which is then passed to `resolve`, which attempts to call the stream's `.then` method, which leads to an infinite loop. It needs to instead pass the result string to `resolve`, but the test suite currently depends on the resolved value being the stream itself (which *definitely* violates the Promises/A+ spec, since the stream is a thenable).

In other words, the tests need to be rewritten. Then the above solution, with `self.on('finish', function(data){resolve(data.getOutput());});` instead of `self.on('finish', resolve);`, should work perfectly. (I'm *pretty* sure it's `data.getOutput()`, but double check that...)

I won't get the chance to do that tonight, or probably tomorrow either, so if anyone else would like to do the honors, be my guest. If not, I'll hopefully get to it this week. If the point is to get the stream itself when it's done rendering, then doesn't ".on('finish')" already pretty much do that?

Both in theory and practice, the point of Promises has always been to handle a single, immutable result (or error) the same way regardless of whether it is known yet or not. In this case, I feel that would be the resulting string. In other words, it seems to me that ".render().then()" should behave like ".renderSync()", but allowing for asynchronous values within the template. Either way, for a thenable to be passed to the first callback given to ".then()" explicitly defies the core of what a javascript "Promise" is. A separate non-thenable version of the stream like what you described would be the only acceptable way to do that. Hm. Somehow didn't notice that ".renderSync()" now returns a stream, too. In that case, this either needs to pass around a non-thenable version of the stream, or not be named ".then". What if we were to simply rename `.then`? The only real problem here (aside from the broken `.catch` method) is that we're passing an object (the stream) with a `.then` method to the `.then()` callback, which explicitly violates the specification. But if it were named something else, like `.promisify()`, `.and()`, or literally anything other than `.then()` or `.catch()`, then my example from "Edit 2" in the original post would work perfectly as-is. Fixed in #443. Thanks!  I'm not sure I understand. It sounds like you're saying this would cause "bar/marko.json" and "./other/marko.json" to behave as though they were directly written in the root "marko.json", correct? What would that affect? Bundling? Module loading? In other words, could you give an example use-case from the end user's perspective?

I can't see any reason not to implement this, I'm just a little unclear on the motivation to do so.
 Ah, makes sense. I would suggest either "include(s)" or "import(s)", the word "extends" doesn't sound quite right for what this would be doing.  While digging around in the compiler just now I noticed that some of the code is *not* Promises/A+ compliant, specifically the `<await>` tag. These are mostly edge-cases, and will *probably* never break anything, but here's what I found:

* The promise resolution procedure must only access the `.then` property once. So instead of `if (typeof promise.then === 'function') { promise.then(...); }` it should use `var then = promise.then; if (typeof then === 'function') { then.call(promise, ...); }`

* If attempting to retrieve the `.then` property throws an error, then the error must be caught and the resulting promise must be rejected with the error as the reason. (It currently isn't being caught.)

* The `.catch(onRejected)` method is neither defined nor required by the specification, it's simply a convenient alias for `.then(null, onRejected)` which *most* promise implementations *choose* to provide. 

Those are just the things I happened to remember, there are probably a few other technicalities that I've forgotten about since I last read through the spec. I'll try to work on this when I get the chance but until then I thought I should post this somewhere. I'll also keep an eye out for other places in the code that might handle Promises incorrectly and add them here.

Promises/A+ Specification: https://promisesaplus.com/ This also raises an interesting question: Should Marko actually be trying to handle Promise resolution directly, or would it be better to rely on a native/polyfilled `Promise` implementation? It looks like that's what #251 is currently doing.

If Marko is to handle "thenables" directly, then I would be in favor of adding a common helper utility for it - which would essentially be a built-in polyfill - so that each tag or feature which needs to handle Promise resolution won't end up re-implementing their own non-compliant handling code. I have enough experience writing spec-compliant thenables to do that, but I would much prefer letting a dedicated `Promise` implementation handle it.
 Quick update: Since #251 only applies when the user explicitly calls the `.then` method, it's considered a special case. The `<await>` tag, however, needs to be usable in pre-ES5 environments, which leaves either a built-in polyfill or just more compliant handling code as the only options.

However, I've also noticed one other issue: The `<await>` tag currently accepts either a value, a Promise, or a node-style function (last argument is an error-first callback). I'll continue working on this under the assumption that we want the `<await>` tag to continue to handle node-style functions, but be aware that this behavior defies the Promises/A+ specification. I'm basing these comments solely on the Promises/A+ specification, which defines the behavior and requirements of the ".then" method common to all implementations. ECMAScript defines the ".catch" method for native implementations, but libraries have no obligation whatsoever to include it. The second argument to ".then", however, *is* explicitly defined and must be supported by all implementations.

The ".then" only being accessed once is a subtle requirement, I wouldn't have even known about it if not for the 'promises-aplus-tests' package. To be honest, it probably won't ever affect anything.

Currently, if attempting to access ".then" throws an error, it is simply thrown. It should instead cause the resulting Promise to be rejected.

The Promises/A+ specification explicitly defines how to resolve an object *or function* - the "await" tag resolves functions in a non-compliant way. I believe the inconsistency is acceptable as long as users are aware of it, I just felt it was worth mentioning.

Ultimately, the changes I'm proposing would only really affect edge-cases, like weird (but still compliant) implementations that don't have a ".catch" method, or can't handle synchronously-thrown errors. I suppose most of those technicalities likely won't ever affect anything, so as long as the test cases are fairly thorough we should be fine. Though I do still suggest relying on the second argument to `.then`, as it's explicitly defined and used by every implementation that's even remotely compliant, while `.catch` is completely optional for third-party libraries.

The rest of it we can probably just leave as-is, as long as we acknowledge that it's not *technically* spec-compliant.  ### Open Questions
What version of the browser support ? @cheft 

None of the built-in tags currently generate anything above ES5. You can find a detailed compatibility table for all major browsers [here](https://kangax.github.io/compat-table/es5/).

The compiler currently requires at least partial ES6 support (Node.js 4+). If you're not already compiling your templates _before_ sending them to the browser, you really should.

The renderer runs in all modern browsers; if you need to support older browsers (like IE8), you will need to transpile the renderer and the compiled (".marko.js") templates with [Babel](https://babeljs.io/) before serving them to the client.
  I like this idea, and I believe I've found a simple way to implement it:

```
<await(result from promise)>
    <await-error if(process.env.NODE_ENV === 'development')>
        <script type="text/javascript">console.log("async tag failed!")</script>
    </await-error>
</await>
```

That works correctly with or without `client-reorder`. This is just a proof of concept, we would want to implement something like it directly in the renderer code and pass the actual error message through.
  Interesting, I like it! I'm still a little fuzzy on a few of the details, though I'm also reading this on my phone and half asleep... It's been a long day.

I especially like the @ syntax. `<@body></@body>` would be fine with me if getting the parser to accept `<@body></body>` is a lot of work.

It looks like the `<include>` tag combined with @ tags should be able to do everything the layout taglib does and more, if so then I'd have no problem with it being deprecated in favor of this once it's fully implemented.
 Would there ever be a situation where the target parent of the nested tag could be ambiguous? If not, then I can't see any reason not to deprecate the old syntax.
 In other words, are there any situations where "@error" could mean either "await:error" or "something-else:error"? I can't think of any, but it's worth asking.
 Hmm, that's a good question... what about a slightly different syntax for one of the two conditions? Nested tags that can be defined multiple times could use `<@tabs>`, while single-instance tags could use something like `<:tab>`, or vice-versa.
  ## Description

```js
var template = require('some.marko')
template.stream() // exception on line 234 of runtime/marko-runtime.js
```

## Motivation and Context

Fixes a runtime exception when streaming without providing a data context.

I would provide a test for this, but I can't find where it would go or any tests that resemble the case to emulate.

 [![Coverage Status](https://coveralls.io/builds/8859130/badge)](https://coveralls.io/builds/8859130)

Coverage remained the same at 83.969% when pulling **22e6ed2f94e615c0cada3ccb66258ab354e01234 on jsumners:empty-data** into **1c0c92eb360493c595e763e10305206ce5ed315f on marko-js:v3**.
 @austinkelleher thanks. I added the test.
 [![Coverage Status](https://coveralls.io/builds/8859285/badge)](https://coveralls.io/builds/8859285)

Coverage remained the same at 83.969% when pulling **ba73d974aabb46b1510fd0d1b12126b0444b6742 on jsumners:empty-data** into **1c0c92eb360493c595e763e10305206ce5ed315f on marko-js:v3**.
 @austinkelleher I wrote this against the v3 branch. It is a bug that is impacting my current usage of Marko.
 [![Coverage Status](https://coveralls.io/builds/8859934/badge)](https://coveralls.io/builds/8859934)

Coverage increased (+0.02%) to 83.985% when pulling **dd094254d0162914f5401a4d20f79643d157f075 on jsumners:empty-data** into **1c0c92eb360493c595e763e10305206ce5ed315f on marko-js:v3**.
 @mlrawlings thank you.
  [![Coverage Status](https://coveralls.io/builds/8839791/badge)](https://coveralls.io/builds/8839791)

Coverage increased (+0.6%) to 87.596% when pulling **63862a8b9204cfd8e146691920593ef6c85331d9 on charlieduong94:420-deprecate-w-on-attr** into **3eb3c286e8147448e58e623e2d294a09a75bbac4 on marko-js:master**.
 [![Coverage Status](https://coveralls.io/builds/8839968/badge)](https://coveralls.io/builds/8839968)

Coverage decreased (-22.1%) to 64.874% when pulling **0716f90b2d9b1c3ace0f8976142583b8fe654b85 on charlieduong94:420-deprecate-w-on-attr** into **3eb3c286e8147448e58e623e2d294a09a75bbac4 on marko-js:master**.
 [![Coverage Status](https://coveralls.io/builds/8840342/badge)](https://coveralls.io/builds/8840342)

Coverage decreased (-22.1%) to 64.874% when pulling **cfc1d8c001d14638d8f1d5b1135a51819d062513 on charlieduong94:420-deprecate-w-on-attr** into **3eb3c286e8147448e58e623e2d294a09a75bbac4 on marko-js:master**.
 [![Coverage Status](https://coveralls.io/builds/8846126/badge)](https://coveralls.io/builds/8846126)

Coverage decreased (-0.4%) to 86.541% when pulling **e7ab99f66a5f92de53aef9bfedbf6f4d6a4f0bda on charlieduong94:420-deprecate-w-on-attr** into **3eb3c286e8147448e58e623e2d294a09a75bbac4 on marko-js:master**.
  [![Coverage Status](https://coveralls.io/builds/8834643/badge)](https://coveralls.io/builds/8834643)

Coverage decreased (-5.6%) to 81.331% when pulling **a19bac4cb30795292295726f90ff38cea3cb999c on austinkelleher:419-deprecate-w-preserve** into **c35bbf0b9d341211499fbe0eeca9f03d5a4691fd on marko-js:master**.
 [![Coverage Status](https://coveralls.io/builds/8834744/badge)](https://coveralls.io/builds/8834744)

Coverage decreased (-18.2%) to 68.791% when pulling **a19bac4cb30795292295726f90ff38cea3cb999c on austinkelleher:419-deprecate-w-preserve** into **c35bbf0b9d341211499fbe0eeca9f03d5a4691fd on marko-js:master**.
 [![Coverage Status](https://coveralls.io/builds/8835416/badge)](https://coveralls.io/builds/8835416)

Coverage decreased (-0.4%) to 86.535% when pulling **0dca32c8ba60b07e14cd47e019bf34dead0a0007 on austinkelleher:419-deprecate-w-preserve** into **c35bbf0b9d341211499fbe0eeca9f03d5a4691fd on marko-js:master**.
 [![Coverage Status](https://coveralls.io/builds/8835416/badge)](https://coveralls.io/builds/8835416)

Coverage decreased (-5.6%) to 81.331% when pulling **0dca32c8ba60b07e14cd47e019bf34dead0a0007 on austinkelleher:419-deprecate-w-preserve** into **c35bbf0b9d341211499fbe0eeca9f03d5a4691fd on marko-js:master**.
  [![Coverage Status](https://coveralls.io/builds/8819913/badge)](https://coveralls.io/builds/8819913)

Coverage increased (+0.02%) to 72.134% when pulling **f192f486cca4145af4e4734e49b8ef5dc3f47775 on austinkelleher:410-await-reorderer-body-transform** into **3622cc4421458649980138950ec0fbf9ac5121dd on marko-js:master**.
  ## Pre-ES6 Support
How should Marko deal with ES6+ features in pre-ES6 environments?

### Definitions
"ES6+" refers to features and keywords introduced in ES2015 or later, and the environments which support them.

"pre-ES6" refers to environments which do *not* support features introduced in ES2015 or later, in which those features must either be transpiled or polyfilled before execution, or not used at all.

### Context
It is of course possible to use ES6+ features within user-written code, which simply gets copied into the compiled output in the case of a template or executed as-is in the case of a component or taglib. The burden then falls on the developer to know which features may or may not be used in their environment.

However, as discovered while working on #428, Marko's compiler is perfectly capable of generating ES6+ code, though it doesn't currently do so. The purpose of this issue is open a discussion on the possible ways of dealing with situations where a new enhancement or taglib wishes to make use of such features while rendering, which may not yet be supported in all environments, especially client-side.

### Possible Solutions
1. Automatically compile certain features and keywords differently based on a configuration option. This would require the most effort to implement and maintain.

2. Don't allow ES6+ to be generated by the Marko core. Any enhancement or taglib that wants to use newer language features *must* be a separate module.

3. Clearly mark all features and tags which require ES6+ support. The burden then falls once again on the end developer to know what they can or cannot use, or to run it through a transpiler before rendering.

4. Create an optional transpiler plugin. If a valid transpiler (like Babel) is passed to the compiler, then whenever an ES6+ feature is encountered it will be automatically fed through the transpiler's API. It could possibly even accept other transpilers like coffeescript or typescript. I would be willing to work on this when I find the time if others are interested.

Those are just the ideas I could think of, this is intended to start an open-ended discussion. Suggestions and constructive criticism are welcome! @patrick-steele-idem I was thinking more about long-term compatibility. I feel like `import`/`export` is just the tip of the iceburg. Aside from big things like that and `async`/`await`, the little things also start to look really tempting, like rest/spread operators, destructuring, argument defaults...

I guess a variation of my question might be something like "Where will the line be drawn on legacy support in the (near-ish) future, and what will be the recommended solutions"? The compiler already requires Node.js 4+ to run, though I believe none of the core components or tags currently _produce_ anything higher than ES5.

The idea of built-in support for running in ES3-only is ridiculous, but for the compiler to assume native ES7 `async`/`await` support would be equally laughable. Aside from the note about the compiler requiring Node 4+ I couldn't find anything that explicitly stated the lowest supported version, or detailed information on what is needed to make it work in legacy environments, but I feel that's something that needs to be addressed.
 At the moment I agree that it's pretty safe to stick with ES6 or lower for the compiler code, and the renderer doesn't use anything newer than ES5, or maybe even ES3 (unless of course the user writes ES6+ code). But things like that have a way of getting fuzzy fast, especially with constantly evolving standards like ECMAScript, Node, and the major browsers.
 I think what was really bothering me is that none of the documentation - at least that I can find - describes which features and ES versions are required by the various pieces of Marko, other than a side-note somewhere about the compiler using ES6 classes and a vague statement about the renderer being "supported in all web browsers" in the FAQ.

For example, a list like the following could be added to the documentation:
* The compiler requires and must be compatible with ES6/ES2015 (Node 4+)
* The runtime requires and must be compatible with ES5
* Built-in taglibs must generate ES5-compatible code
* Additions which use ES6+ features must only do so when called by the user (e.g. #423)

It would also be helpful to include information on how to transpile with Babel, and when that would be necessary, for new users who may not already know those things.  [![Coverage Status](https://coveralls.io/builds/8810198/badge)](https://coveralls.io/builds/8810198)

Coverage decreased (-0.01%) to 72.102% when pulling **375936a26feacf980e5312964ce7f65f4bae0875 on austinkelleher:426-deprecated-async-events** into **3622cc4421458649980138950ec0fbf9ac5121dd on marko-js:master**.
  ## Description
I simply copied `var-tag.js` and its `marko.json` entry to create `<let>` and `<const>` tags in `taglibs/core`.

## Motivation and Context
I was surprised to find that `context.builder.vars()` already had an optional second parameter for variable type ('var', 'let', or 'const'), but only `<var>` had been implemented as a tag.

This pull request is meant to be a starting point, but it could also be applied as-is. The commit is purely additive and no existing functionality should be affected.

## TODO
* Add automated tests
* Add documentation
* (optional) Throw compiler error on identifier re-declaration or on `const` re-assignment

## Additional Notes
Providing a body to a `<var>` tag causes it to compile into an IIFE to restrict its scope. Because the `<let>` and `<const>` tags simply re-use the same code they currently do the same, but they could be made to use a block statement (`{ ... }`) instead. Hmm... it seems the auto-tests are currently failing, I assume that's because I didn't write any. Unfortunately I'm not sure when I'll next get the chance to work on this. If anyone would like to take over from here, feel free to do so.
 [![Coverage Status](https://coveralls.io/builds/8803035/badge)](https://coveralls.io/builds/8803035)

Coverage decreased (-0.05%) to 85.073% when pulling **f5786f7c0dbf58fe90c3be4b5ae624de9a2bbf00 on Hesulan:let-const-tags** into **9a86d848f29b2b1780b1683d7c5903901238499c on marko-js:marko-v4**.
 [![Coverage Status](https://coveralls.io/builds/8803035/badge)](https://coveralls.io/builds/8803035)

Coverage decreased (-0.05%) to 85.073% when pulling **f5786f7c0dbf58fe90c3be4b5ae624de9a2bbf00 on Hesulan:let-const-tags** into **9a86d848f29b2b1780b1683d7c5903901238499c on marko-js:marko-v4**.
 I agree that the compiler should throw an error on re-initialization or const re-assignment, that's point number 3 in the TODO section of the pull request. It's getting compiled into actual `let` and `const` calls so it will eventually do that during render anyway, but it would be nice if it could do that at compile-time. But that's something that will need to be done deeper within the code, probably somewhere inside the `Vars` AST node; so far these commits have only touched the taglib code.

I'm not sure why I didn't think of this before, but it will also be necessary for the compiler to handle `let` and `const` differently in pre-ES6 environments, where the keywords either need to be transpiled, or require strict-mode (as two of the four travis-ci tests apparently do). In any case, it seems this isn't quite as simple as it appeared.

Assuming ES6 or higher, anyone can grab these commits to play with locally, it's worked perfectly for me so far. I might also get around to making this a separate taglib in the next day or two, at least until someone with more time on their hands (possibly my future self? I can only hope...) figures out how to make it not break things.
 So I've been mulling this over, and here are the solutions I can think of:
1. Pull these tags into a separate module. This would be fairly simple, I would just need to make a few minor changes and publish to npm.
2. Provide built-in support for compiling to `var` instead. This would be overkill, and I'm not even sure where to begin.
3. Add `'use strict';` to the top of the compiled output. This would make it work correctly in Node 4 and 5, but would also change the behavior of the entire template in very subtle ways, albeit mostly for edge cases.
4. Expect end users to know that they can't use these tags natively in pre-ES6 environments. We would also need to modify the integration tests to skip certain ones on Node 4 and 5.
5. Pull these tags into a new built-in taglib specifically made for support-breaking features (something like `es6-taglib`) which can then be enabled/disabled by a compiler flag (like `require('marko/compiler').defaultOptions.es6_tags = true`). This would be especially helpful in the case of client-side rendering, where templates might be rendered in a much lower environment version than the one they were compiled in, and developers shouldn't have to keep track of which tags support which versions. Any future tags which generate ES6+ code would also be placed here.

I'm sure there other options I haven't considered as well. Either way, I'd like to hear your thoughts!
 For me, the point of `const` and `let` is that they're clean, effective, _native_ solutions to specific problems. A separate taglib or module would provide a safe, "official" place for tags like these which are built around ES6+ features and concepts to be implemented without the risk of accidentally breaking compatibility; anyone who chooses to `require()` it knows what they're getting into. That being said, the addition of another taglib or module to maintain isn't something to propose lightly.

In any case, this certainly isn't urgent. Perhaps we could simply put this on the back-burner while we experiment with ideas for other ES6+ tags, and see how much interest there is from the community? In the meantime, I could easily port these to a separate module and publish it for everyone to play with.
 For anyone interested, I finally got around to publishing these as a standalone package: 

```
npm install --save marko-taglib-let-const
```

(Note: The `--save` part is necessary because marko only searches for taglibs listed as dependencies in your `package.json`.)
  [![Coverage Status](https://coveralls.io/builds/8801714/badge)](https://coveralls.io/builds/8801714)

Coverage decreased (-0.1%) to 71.953% when pulling **538196fc8a1dc9ecdcbea31714723dd8e544fec2 on charlieduong94:394-introduce-ref-and-for-ref-attributes** into **00b52ae5be30b9665bb289732adfd4bc985aa2e3 on marko-js:master**.
 [![Coverage Status](https://coveralls.io/builds/8801798/badge)](https://coveralls.io/builds/8801798)

Coverage decreased (-0.1%) to 71.953% when pulling **4409cecb4bcb7a9ff1b642545eb1436c606cfe17 on charlieduong94:394-introduce-ref-and-for-ref-attributes** into **00b52ae5be30b9665bb289732adfd4bc985aa2e3 on marko-js:master**.
 [![Coverage Status](https://coveralls.io/builds/8801850/badge)](https://coveralls.io/builds/8801850)

Coverage decreased (-0.1%) to 71.953% when pulling **e1940a7ff0d1d056c2800a1d20acf44a90b24275 on charlieduong94:394-introduce-ref-and-for-ref-attributes** into **00b52ae5be30b9665bb289732adfd4bc985aa2e3 on marko-js:master**.
  @patrick-steele-idem It seems that this currently coerces non-string values, such as `undefined`, `null`, and `{}`, into `<undefined></undefined>`, `<null></null>`, and `<[object Object]></[object Object]>`. Should it throw an error instead?  I'm more than a little hesitant about this... I do see how it could be useful, but considering what little would be gained (expression whitespace already works inside parenthesis, and is arguably easier to read most of the time) versus the potential costs (reserved operator names, inconsistent behavior, potential ambiguity, etc.), I feel this needs more discussion, especially since it would likely affect any future enhancements which deal with or depend on whitespace behavior.

Perhaps if this were to be opt-in, and only enabled by default on certain tags like `<var>` and `<assign>`? I would love to see something like that, and it would virtually eliminate the problems I mentioned (you can pretty much assume that anything on a `<var>` tag after the `=` is part of the value expression).
 I haven't peeked at the code yet, but if this could be a some sort of opt-in flag on the tag definition (or renderer, or AST node, or wherever it would fit best), then any other tags - possibly even user-made taglibs - could simply enable this "loose whitespace" support with relative ease without changing the expected behavior for anything else.
 I would much prefer a parsing mode switch based on the tag name, it seems like it would be much less messy and more reusable than having each tag manually stitch everything back together, or it might even be as simple as adding a couple of flags to the commit from the related PR. Is the parser able to read a config parameter from somewhere user-accessible, like the `marko.json` definition, or would the tag names which support this need to be hard-coded?
 I like the idea of the comma syntax being concise-specific. It already has more of a javascript-y vibe (actually python-y because of the significant indentation, but you get my point), while the standard syntax feels more like enhanced HTML, at least in my opinion. Also, my original concern was over allowing whitespace everywhere within value assignments without explicit boundaries; I can't think of any serious problems that allowing whitespace around the `=` might cause, aside from looking horrible when misused (`<tag foo = foo bar = bar baz = (baz + 1)/>`), but that can be said about almost anything.

As for only requiring commas sometimes, another possibility might be an all-or-nothing; if the tag contains values with whitespace, then there must be a comma between every attribute. As a side effect, that would also make it a bit easier to read, you would end up with either `tag foo=(1 + 2) bar=3 baz` or `tag foo = 1 + 2, bar=3, baz` instead of `tag foo = 1 + 2, bar=3 baz`.
 Requiring a semicolon at the end with the comma syntax would solve that first part, then it would be either:

```
tag baz = 3; - Hello World;  ‚Üí  <tag baz = 3;>Hello World;</tag>
```

 or 

```
tag baz = 3 - Hello World;  ‚Üí  <tag baz = 3 - Hello World;></tag>
```
 typed that on my phone and I think it messed up the formatting... hopefully you know what I meant
 When in *concise mode*, could a `;` (semicolon) simply end the current tag like `>` does in *HTML mode*?

For example:
```
nav.navbar; ul
    li for(link in data.links); a href=link.href - ${link.title}
```
Would be shorthand for:
```
nav.navbar
    ul
        li for(link in data.links)
            a href=link.href - ${link.title}
```
or
```
<nav.navbar><ul>
    <li for(link in data.links)><a href=link.href>${link.title}</a></li>
</ul></nav>
``` I agree with restricting this feature to concise syntax. The HTML-JS syntax is naturally more verbose, and with that verbosity you gain explicitness.

    <assign name=( lastName.toUpperCase() + ', ' + firstName.toLowerCase() ) />

This looks nice and readable to me. I have no desire to remove these parenthesis, just as I have no desire to remove general closing tags :)  [![Coverage Status](https://coveralls.io/builds/8784764/badge)](https://coveralls.io/builds/8784764)

Coverage increased (+0.03%) to 71.587% when pulling **0310d778a61fcc6931de8d39d9a97d6feb658751 on austinkelleher:251-render-promise** into **da11d73f52c2c1482124b8e189160f9a34ae1cf5 on marko-js:master**.
 [![Coverage Status](https://coveralls.io/builds/8784838/badge)](https://coveralls.io/builds/8784838)

Coverage increased (+0.03%) to 71.587% when pulling **beb86527865b287e31137c50519d592db4d12ca7 on austinkelleher:251-render-promise** into **da11d73f52c2c1482124b8e189160f9a34ae1cf5 on marko-js:master**.
 [![Coverage Status](https://coveralls.io/builds/8784974/badge)](https://coveralls.io/builds/8784974)

Coverage increased (+0.03%) to 71.494% when pulling **41fbe7a1d61614a05cecffc7260dc81458db3cd5 on austinkelleher:251-render-promise** into **abe0e2db2d32b729897905aba8fa17313a1f11e8 on marko-js:master**.
 [![Coverage Status](https://coveralls.io/builds/8784974/badge)](https://coveralls.io/builds/8784974)

Coverage increased (+0.03%) to 71.494% when pulling **41fbe7a1d61614a05cecffc7260dc81458db3cd5 on austinkelleher:251-render-promise** into **abe0e2db2d32b729897905aba8fa17313a1f11e8 on marko-js:master**.
 The `Promises/A+` specification requires that a `Promise` instance must only ever handle the very first call to either `resolve` or `reject`, and ignore all further attempts at either. So as long as the correct one is called first it doesn't matter what happens after, the resolved/rejected `Promise` instance becomes immutable.
 That being said, do be aware that a fulfilled `Promise` exhibits _shallow_ immutability; the resolved/rejected value is effectively a `const` in that you cannot _replace_ it, but you can still modify the result's properties. And since calling `resolve` or `reject` doesn't cause the function to exit, it's entirely possible to accidentally mutate the result.
  Is there another way to achieve the same result? I can think of a few cases where it would be useful, though perhaps not strictly necessary, to be able to explicitly bind a widget file path. One example would be #514 - is there an alternative, or would that functionality no longer be possible? @patrick-steele-idem Ah, that does clarify. Thanks! Probably a good idea to mention those alternatives somewhere in the v3-v4 upgrade docs, and maybe a few examples to make refactoring easier. In marko@4.0.0-rc.17 it appears that in `onMount()`, `this.el` is the first element and `this.els` is all top-level elements (when there are multiple top-level elements).  [![Coverage Status](https://coveralls.io/builds/8752709/badge)](https://coveralls.io/builds/8752709)

Coverage decreased (-0.04%) to 71.423% when pulling **849c1193b9318ef91a3fde4b3498b6671b8594b1 on austinkelleher:387-handleFileModified-warning** into **a35e6bdbc3fe6e7f4e92fb377c435e29ab3d6e33 on marko-js:master**.
  The [language guide](https://github.com/marko-js/marko/blob/master/docs/language-guide.md) makes no reference to the `marko-body` attribute.  This attribute is necessary to keep Marko from interpreting inline scripts or inline CSS, but without being documented it's difficult to find this mechanism at all. > This means that the parser won't recognize HTML tags inside `<script>` and `<style>` tags since those tags do not contain HTML. Therefore, you should very rarely need to know about the `marko-body` attribute.

In our case we had `${` without a matching `}` (code that didn't intend to invoke Marko at all) and this caused an error.  I'd shudder to think what would've happened if it silently transformed something causing weird changes in behavior without any warning.  I mean it makes sense that maybe you want to `${JSON.stringify(foo)}` in the middle of a script tag, though it seems a bit dangerous to me that expressions are enabled in script tags by default.  I do understand the logic of keeping it consistent with other tags, however, and obviously it would be a breaking change, so I'm not suggesting that... just kind of musing.

Anyway, documenting `marko-body` would've at least made it easier to correct the problem when we figured out what it was.

I suppose the correct approach is just not to have inline JavaScript at all -- but sometimes that's nice for testing a quick template mock-up.
  [![Coverage Status](https://coveralls.io/builds/8744473/badge)](https://coveralls.io/builds/8744473)

Coverage increased (+0.03%) to 71.175% when pulling **1bb1c9ca0c1c386e52b66168daafcfe1b90bd2db on austinkelleher:407-node-require-extensions** into **36ef493526e47e4009ef7872b031c6918bfc1c3a on marko-js:master**.
 [![Coverage Status](https://coveralls.io/builds/8744661/badge)](https://coveralls.io/builds/8744661)

Coverage increased (+0.04%) to 71.185% when pulling **ef71399d6acbaf302e08b2fc579b59a2469bf6c3 on austinkelleher:407-node-require-extensions** into **36ef493526e47e4009ef7872b031c6918bfc1c3a on marko-js:master**.
 [![Coverage Status](https://coveralls.io/builds/8745008/badge)](https://coveralls.io/builds/8745008)

Coverage increased (+0.04%) to 71.191% when pulling **228ae8f0c7cda5660933b96713a43330c9abe47a on austinkelleher:407-node-require-extensions** into **36ef493526e47e4009ef7872b031c6918bfc1c3a on marko-js:master**.
 [![Coverage Status](https://coveralls.io/builds/8745063/badge)](https://coveralls.io/builds/8745063)

Coverage increased (+0.04%) to 71.191% when pulling **228ae8f0c7cda5660933b96713a43330c9abe47a on austinkelleher:407-node-require-extensions** into **36ef493526e47e4009ef7872b031c6918bfc1c3a on marko-js:master**.
  [![Coverage Status](https://coveralls.io/builds/8699522/badge)](https://coveralls.io/builds/8699522)

Coverage remained the same at 71.14% when pulling **6ef6bb65fe6eaff0bf3ca82c7b79b49eb26a25cb on abiyasa:bug-on-nested-widget-id** into **21a43c010a75ca06857598f49ea3368b3e33c3c2 on marko-js:master**.
 [![Coverage Status](https://coveralls.io/builds/8699522/badge)](https://coveralls.io/builds/8699522)

Coverage remained the same at 71.14% when pulling **6ef6bb65fe6eaff0bf3ca82c7b79b49eb26a25cb on abiyasa:bug-on-nested-widget-id** into **21a43c010a75ca06857598f49ea3368b3e33c3c2 on marko-js:master**.
  For the purpose of hoisting `require()` calls out of the `render` function, the new `<import>` tag *should* handle that (see: ECMAScript's top level requirement for `import` statements - though I haven't had the chance to look at the pull yet so I can't be sure if it actually does this). I know that's not the only use for `<script marko-init>`, but thought I should throw that out there.

Regarding `<render>` and `<init>`, why not both? `<init>` could simply be a drop-in replacement for `<script marko-init>`, while `<render>` would be optional, and if present would refactor the output in the way you described.

I get the feeling that the `<render>` tag might take a while to get working correctly, but `<init>` should be quick and easy to add (and looks much nicer and more easily recognizable than `<script marko-init>`, at least in my opinion).  When using `require('marko/hot-reload').handleFileModified`, if a not-resolvable template path is passed there will be no warning (or other notification)

A very minor quibble, but this was related to a somewhat elusive bug in my code.

Maybe just a warning, or change the existing output from:

```
[marko/hot-reload] File modified: /cant/resolve/this/path/to/index.marko
```
to something like:
```
[marko/hot-reload] ERROR! cannot resolve template path: /cant/resolve/this/path/to/index.marko
```  <!----------------------
  |     IF BUG REPORT    |
  ---------------------->
## Bug Report

Compiler throws an error on valid RegEx expressions in HTML5 `pattern` attribute for `input` elements.
### Context

Given following code example

``` html
<input type="text" pattern="\w{2,20}" />
```
### Expected Behavior

Compile normally, as it valid attribute value
### Actual Behavior

Throws Error
`'Invalid string ("\\w{1,30}"): SyntaxError: Unexpected token w in JSON at position 2'`

<details><summary>

Additional Info</summary>


### Your Environment

<!-- Include as many relevant details about the environment you experienced the bug in -->
- Version used: `"marko": "^4.0.0-beta.1"`
- Environment name and version: `node.js 7.0`
- Operating System and version (desktop or mobile): MacOS
### Stack Trace

<!-- If an error is thrown, provide the stack trace here -->

```
ERR! [10:40:05] [Marko] 1) [src/marko/vip-puj.marko:111:88] Invalid string ("\w{1,30}"): SyntaxError: Unexpected token w in JSON at position 2
ERR! [10:40:05] [Marko] 
ERR! [10:40:05] [Marko]     at handleErrors (/Users/tino/Sites/transfers.do/node_modules/marko/compiler/Compiler.js:72:21)
ERR! [10:40:05] [Marko]     at Compiler.compile (/Users/tino/Sites/transfers.do/node_modules/marko/compiler/Compiler.js:127:9)
ERR! [10:40:05] [Marko]     at _compile (/Users/tino/Sites/transfers.do/node_modules/marko/compiler/index.js:89:33)
ERR! [10:40:05] [Marko]     at doLoad (/Users/tino/Sites/transfers.do/node_modules/marko/runtime/loader/index.js:163:42)
ERR! [10:40:05] [Marko]     at compileMarkoFile (/Users/tino/Sites/transfers.do/tasks/marko.js:45:26)
ERR! [10:40:05] [Marko]   errors: 
ERR! [10:40:05] [Marko]    [ CompileError {
ERR! [10:40:05] [Marko]        context: [Object],
ERR! [10:40:05] [Marko]        node: undefined,
ERR! [10:40:05] [Marko]        message: 'Invalid string ("\\w{1,30}"): SyntaxError: Unexpected token w in JSON at position 2',
ERR! [10:40:05] [Marko]        code: 'INVALID_STRING',
ERR! [10:40:05] [Marko]        pos: [Object],
ERR! [10:40:05] [Marko]        endPos: [Object] } ] }
```

</details>
 I think accepting native RegEx as value will looks logical and very appropriate!
 Also, I'm not sure that this pattern attribute will work in same way in all browsers after escaping `\\`, but can't find related spec thought...
  It's obvious why the whitespace of `<pre>` tags is not removed, but why for `<script>` tags too? Normally, you minify javascript code too so I don't get why this is ignored by default. Is there any why to enable minification for the `<script>` tag globally? `require('marko/compiler').defaultOptions.preserveWhitespace = true` sadly only does this globally, but if I have a `<pre>` tag it's displaying incorrectly. Is there a way to do this programmatically instead of a .json config file?
  The page displays, all the js appears to load, but the onClick `handleThisClick` handler isn't firing (which should display a console log) and the c-nav.scss css isn't being applied (#c-nav). The base.scss style is working though (red).

(I'm using lasso-babel/lasso-sass)

my route:

```
    let template = require('src/marko/pages/sign_in/sign_in.marko');
    ctx.body = template.stream({
        press: 'press'
    });
```

src/marko/pages/sign_in/sign_in.marko:

```
<lasso-page package-path="./browser.json" />

<layout-use( "../../layouts/base/base.marko", data) show-header=false>
    <layout-put into="body">
        BODY CONTENT ${data.press}
        <c-nav(data) />

    </layout-put>
    <layout-put into="footer">FOOTER CONTENT</layout-put>
    </layout-use>
```

src/marko/pages/sign_in/browser.json:

```
{
    "dependencies": [
        "../../components/c-nav/browser.json"
    ]
}
```

src/marko/layouts/base/base.js:

```
console.log('base.js included');

import text from './text.js';
text();
```

src/marko/layouts/base/base.marko:

```
<!-- lasso -->
<lasso-page package-path="./browser.json" />
<!-- /lasso -->
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>
        <layout-placeholder name="title" />
    </title>
    <!-- lasso -->
    <lasso-head/>
    <!-- /lasso -->
</head>

<body>
    <div class="base">base.marko body below</div>

    <layout-placeholder name="body" />

    <!-- lasso -->
    <lasso-body/>
    <!-- /lasso -->
    <!-- marko widgets -->
    <init-widgets/>
    <!-- /marko widgets -->
</body>

</html>

```

src/marko/layouts/base/base.scss:

```
.base {
    width: 100px;
    height: 30px;
    background: red;
}
```

src/marko/layouts/base/browser.json:

```
{
    "dependencies": [
        "require-run: ./base",
        "./*.scss"
    ]
}
```

src/marko/layouts/base/text.js:

```
'use strict';
export default () => {
    console.log('test.js included');
};
```

src/marko/components/c-nav/browser.json:

```
{
    "dependencies": [
        "require: marko-widgets",
        "require: ./widget",
        "./*.scss"
    ]
}

```

src/marko/components/c-nav/c-nav.js:
`exports.render = require('./renderer').render;`

src/marko/components/c-nav/c-nav.marko:

```
<nav role="navigation" id="c-nav" w-bind="./widget">
    <ul class="main-navigation">
        <li>
            <a href="/">Home</a>
        </li>
        <li>
            <div w-onClick="handleThisClick">${data.press}</div>
        </li>
    </ul>
</nav>
```

src/marko/components/c-nav/c-nav.scss:

```
#c-nav {
    background: green;
    width: 100%;
    height: 40px;
}
```

src/marko/components/c-nav/renderer.js:

```
module.exports = require('marko-widgets').defineRenderer({
    template: require('./c-nav.marko'),

    getInitialProps: function (input, out) {
        console.log(input);
        return input;
    }
});
```

src/marko/components/c-nav/widget.js:

```
module.exports = require('marko-widgets').defineWidget({
    handleThisClick: function () {
        console.log('c-nav click');
    }
});

```

The console fires `base.js included` and `test.js included`.
 @patrick-steele-idem Hello! I actually found out what the issue is. It's possibly related to https://github.com/lasso-js/lasso-marko/issues/3.

I had to move the `pages/sign_in/browser.json` dependencies to the `layouts/base/browser.json`dependencies. Which is weird, since I am declaring the usage of the components in `pages/sign_in/sign_in.marko` and not in `layouts/base/base.marko`.
  ## Bug Report

Hot reload doesnt work in ExpressJS setup
### Your Environment

Win8.1 
Chrome
 Hi, the browser refresh only refreshes the browser page load.
I did manual refresh, and it doesnt work.
The file watch does work and the method handleFileModified(templatePath) is triggered, but nothing happens, even though there is console printout from that says 'file refreshed...' (or something). Also, there isnt new js file compiled/created either, even after setting write to file option as true.
 @sriver111 I happened to have this error 5 minutes ago, the console printout, is it the relative path or the absolute path. It needs to be the absolute path i.e. `/home/user/dev/yourproject/src/markofiles/component/app-mycomponent/template.marko` or on Windows `C:\yourproject\wherever-your-marko-template-files-are\template.marko`
 Hi Patrick, u are right. The path has to be absolute to work.
Thanks and cheers!
  Hi there!
This code doesn't work now. Before he worked fine.

```
let HomePage = require('./home.marko');
let response = {
    $global: {
        active: 'home',
        logged: logged,
        moment: moment,
    },
    currentPage: currentPage,
};
HomePage.stream(response).pipe(res);
```

I have a layout and his part(home.marko). I load a part of layout and give him the data for rendering, but nothing.

In a layout i tried to print data: `${out.global.active}`. What i doing wrong? Previously everything worked fine.
 @patrick-steele-idem Thanks a lot!
  Hello, marko neighbors! I use Express with Marko. Example:

```
template.render(data, res)
```

How do I handle rendering errors in this case? Thanks!
  `require('marko/compiler').taglibFinder.includeDir(dirPath);` 
would be nice feature
I have many directories inside my project folder that have `package.json` inside because i need them to have individual node_modules inside and for other reasons as well

now I cannot bubble to main project folder and make some components available across all directories

there is `taglibLookup.registerTaglib` but seems to work only in node environment :/ (in webpack doesn't seem to work)
  <!----------------------
  |     IF BUG REPORT    |
  ---------------------->
## Bug Report

I'm getting "maximum call stack exceeded". What am I doing wrong?
### Context

I'm trying to benchmark marko against our current favorite, handlebars, because I expect it'll be a lot faster. I'm running a matcha test, so I have the following code:

```
const handlebars = require('handlebars');
require('marko/node-require').install();
const fs = require('fs');

const data = // [snipped for brevity]

suite('Post template', () => {
//snipped Handlebars test 

    bench('marko', (next) => {
        const template = require('./post.marko');
        template.render(data, () => {
            //throw away the render output
            next();
        });
    }); 
```
### Expected Behavior

I should see benchmark results
### Actual Behavior

During the marko test, an error is thrown that aborts the suite

<details><summary>

Additional Info</summary>


### Your Environment

I'm using C9, running this using matcha for node.js
### Stack Trace

```
RangeError: Maximum call stack size exceeded
    at Array.join (native)
    at Object.posix.resolve (path.js:442:52)
    at Function.Module._resolveLookupPaths (module.js:249:17)
    at Function.Module._resolveFilename (module.js:316:31)
    at Function.Module._load (module.js:276:25)
    at Module.require (module.js:353:17)
    at require (internal/module.js:12:17)
    at /home/ubuntu/workspace/benchmarks/matcha-tests.js:35:20
    at iterate (/home/ubuntu/workspace/node_modules/matcha/lib/matcha/bench.js:178:5)
    at /home/ubuntu/workspace/node_modules/matcha/lib/matcha/bench.js:180:7
```

</details>
 Thanks, that worked great! Yeah, I got the idea from your benchmark set, but my group wanted to see how it performs with our templates. I figured it was simple enough to do.. until I hit this issue >.>

Thanks again!
  It seems to me that some of those tags might be simpler than others. Like you said, `<init-widgets/>` may not recognize widgets within an `<await>` tag (though I have a couple thoughts on how it might). Others, like `<browser-refresh/>`, could simply attach themselves to the compiler (or perhaps even the renderer) and append/prepend themselves unconditionally. Ordering and precedence shouldn't affect those much, but that's something we would still need to figure out eventually.

> Side note: I just noticed that the content of `<await(...) client-reorder>` ends up in `<head>` if it's the first document element; in other words, `<!DOCTYPE html><await(foo from Promise.resolve('foo')) client-reorder>${foo}</await>bar<await-reorderer/>` produces `<html><head>foo</head><body>bar</body></html>` instead of `<html><body>foobar</body></html>`. It's an uncommon edge-case, but something to be aware of if excluding the `<body>` tag, and possibly a bug in `<await-reorderer/>`.  <!--- Provide a general summary of your changes in the Title above -->
## Description

<!--- Describe your changes in detail -->

Updates old references of `htmlparser2` to `htmljs-parser`. Adjusted some of the wording in the overview doc to try and adapt the text to v3.
 [![Coverage Status](https://coveralls.io/builds/8271931/badge)](https://coveralls.io/builds/8271931)

Coverage remained the same at 83.972% when pulling **4e7c519f523a36045f5fbd14e64c0bec47453b78 on yomed:overview-docs** into **4646eef0389088df617dd87ac730186334f0efbf on marko-js:master**.
 [![Coverage Status](https://coveralls.io/builds/8271931/badge)](https://coveralls.io/builds/8271931)

Coverage remained the same at 83.972% when pulling **4e7c519f523a36045f5fbd14e64c0bec47453b78 on yomed:overview-docs** into **4646eef0389088df617dd87ac730186334f0efbf on marko-js:master**.
  Hi guys!
This template engine is Awesome! Thanks for your hard work! :+1:  

**One question, exist any tuto to use with Express?**

Sorry for this bad issue, Nicholls
 Guys check an issue please!

![express](https://cloud.githubusercontent.com/assets/2154886/19223435/77eb70e4-8e35-11e6-8fe7-938e6225a373.png)

My Express route is:

```
var express = require('express');
var router = express.Router();
var template = require('../views/index.marko');

/* GET home page. */
router.get('/', function(req, res, next) {
  res.marko(template, { title: 'Express' });
});

module.exports = router;
```
 Hi Patrick, thanks for your quickly response my friend! üëç 

Can I use your '**require('marko/node-require').install();**' line in **'./app.js'** or is required to use in every Express route? I'm using the **Express generator**.

Regards, Nicholls
 What do you think to add your example into **README** file? Maybe it's very useful for others!
  [![Coverage Status](https://coveralls.io/builds/8573081/badge)](https://coveralls.io/builds/8573081)

Coverage increased (+0.008%) to 83.969% when pulling **2b4116b9e01fc1c9129139ba2e6ba3b70262484f on await-error-events** into **d25c5ceedfc44859972980812cdd6b6d116f8818 on v3**.
  ## Description

Adds concise syntax example to README.md for applying rendering logic with separate tags.
## Motivation and Context

To make sure the concise syntax is really equivalent to the HTML template I ran this example. I think it makes sense to include it for other new users as another quick introduction to the Marko syntax and the alternative way of applying rendering logic. I would have found it helpful.
## Checklist:
- [x] My code follows the code style of this project.
- [x] I have updated/added documentation affected by my changes.
- [x] I have read the **CONTRIBUTING** document.
- [ ] I have added tests to cover my changes.
- [x] All new and existing tests passed.
 [![Coverage Status](https://coveralls.io/builds/8184714/badge)](https://coveralls.io/builds/8184714)

Coverage remained the same at 83.997% when pulling **995aaa3288b9e382d745c3632d294dff512cd483 on JonasHavers:master** into **cca2b0a452b23dcb79c1d80632c1fa59e3586705 on marko-js:master**.
  `while` was introduced in v3, but was missing from the docs. I copied this from the "what's new" page, and then modified it to the same format as the `for` loop documentation.
 [![Coverage Status](https://coveralls.io/builds/8143951/badge)](https://coveralls.io/builds/8143951)

Coverage remained the same at 83.997% when pulling **44d98f1490952cb8847696f9337f438d1835d603 on yomed:while-docs** into **a819ba3816dfeb21eb5acccd77cd0ec2fc470d8b on marko-js:master**.
  Sorry if this is answered somewhere (I couldn't find it), but can you do custom attributes without creating a custom tag? I'm curious if we can do something similar to what Angular has where you can create directives for attributes, not just tags.

As an example, lets say I wanted to provide an alternate "src" attribute (my-src) for the img tag so I could rewrite the URL before rendering. Is this possible? Or do I have to write a custom image tag and handle the src attribute that way? The docs weren't clear on this point. They mention custom tags AND attributes, but I only see examples for tags.

BTW, I'm currently using the component directory set-up, not a marko.json. 
 Thanks for the quick response, appreciate it. I'll have a look at the link you provided.
 Thanks, Patrick! I'll need to digest this a bit but it's much appreciated! I assume that you must use a marko.json to accomplish this, instead of the components directory?
  ## Bug Report
### Context

<!--- Provide a more detailed introduction to the issue itself, and why you consider it to be a bug.  How has this bug affected you? What were you trying to accomplish? -->

When Marko renders a template using `marko/express`, and there are no differences, it still sends the page over with a 200 HTTP status code.
### Expected Behavior

If no differences are detected, `marko/express` should send a 304 to avoid extra data being sent.
### Actual Behavior

Currently, no matter what, `marko/express` will send the template over with a 200 HTTP code.
### Possible Fix

Store an in memory hash of the previous render and check if it matches the current render; if they match send a 304 concluding nothing has changed.

<details><summary>

Additional Info</summary>


### Your Environment
- Version used: 3.9.4
- Environment name and version (e.g. Chrome 39, node.js 5.4): Chrome 52, node 6.3.1
- Operating System and version (desktop or mobile): Mac OS X 10.11.6
### Steps to Reproduce
1. Install Marko within an Express project.
2. Require `marko/express`
3. Use `res.marko` to compile a template and send it to a client
4. Look at the response status headers and see that Express is responding with a 200 HTTP code

</details>
 That is what I thought, but if I use pug (jade), templates will render, and if not changes are detected, express will emit a 304. With Marko, it will always send a 200, and force the client to download the entire page.
 Although you would have to store a lot of data in memory if you wanted the page controller to calculate it without a rendered template to cross check it with. One way or another the data needs to be verified, and I do agree with not wanting to waste CPU cycles if data hasn't changed.

Does anyone have any ideas that would be efficient? I'm thinking of generating hashes from the data here, but that seems like a waste of CPU cycles itself.
 Sadly I have not had any time to work on this feature as of yet.
  The current marko atom packages should use a more unique identifier in their package names.
When searching for "marko" in atom the packages appear in this order:
- language-marko (5th in list)
- autocomplete-marko (17th)
- hyperclick-marko (23rd)

This makes it difficult to find all available marko packages in a single search.
### Solution

Change the package name from `marko` to something like `markojs` or `marko-js` to make it easier to find all of the packages.

Thanks!
  How would that work with event handlers?

In [`react-templates`](https://github.com/wix/react-templates#event-handlers) for example you can assign events using the same properties React uses.
 What is the expected performance impact, if there is any at all?
  As services like https://zeit.co/now become more ubiquitous, and writing to disk in an app server becomes less kosher, this seems like a better option.

I'm having to manually load/pass-through my includes right now just so I can set writeToDisk to false, and having to set writeToDisk adds a bit more noise to my code.

My 2c. :)
 @patrick-steele-idem Do we have to compile `marko` files first in order to serve them dynamically?
 @patrick-steele-idem I see, thanks.
 @patrick-steele-idem I think I'm in favor of making `false` the default. The compiled output is extremely useful for the things you mentioned and many others, but 98% of the time it just wastes disk I/O (which is a very bad thing if you develop on cloud storage or flash drives - which I do).

On the other hand, it's extremely easy to *en*-able `writeToDisk` when you need to debug something (not as convenient as having the file already there, but still super easy), and anyone concerned with start-up time should really just pre-compile everything in their build step and never `require()` the compiler at all during production. FWIW the surprise appearance of the compiled template as a `.js` file can disrupt the typical file watching/rebuild patterns in dev environments by firing off a misleading file/directory change event. This is another thing that is easy to fix (set ignore rules), but... Indeed, in dev you probably don't even want compilation caching to happen at all (requiring even more little fixes), and you'll have to add `marko.js` files to your `.gitignore` sooner rather than later...

Easy fixes, but now a little pile of them :)

All that said, Marko is awesome and I think helping new users to avoid these surprises can only be a good thing.
 @mlrawlings I completely agree that the `*.marko.js` files are essential for debugging, but in my opinion it's already easy enough to generate them when desired with `./node_modules/.bin/markoc ./path/to/template.marko`, or even `require('marko/compiler').defaultOptions.writeToDisk = true;` for those who don't need to worry about unnecessary disk writes.

Writing out on error may be more convenient, but it would also result in files sometimes appearing with little or no explanation and littering the project folders, which could confuse new users even more.

I would be very interested in source maps, though I vaguely remember seeing discussion in an issue somewhere about them being too difficult to implement. @mlrawlings I really like the idea of using an environment variable, especially since the output files are only really used for production and debugging, and anyone worried about production start-up time should probably be compiling during a build step instead.

And I'd love to see the compiler keep better track of where the code came from. That might also help with things like #247. The environment variable might have too great an effect. My personal primary use case is inspecting the generated file of only the template I'm working with. The environment variable feature would generate *all* files in the project, wouldn't it? @mindeavor I'm thinking the environment variable would probably just switch `writeToDisk` on, which is currently Marko's default behavior.

If you need to compile only a specific template, you can either execute 
```sh
./node_modules/.bin/markoc ./path/to/template.marko
```
in a shell, or toggle `writeToDisk` on while loading that template for the first time:
```js
require('marko/compiler').defaultOptions.writeToDisk = true;
var template = require('./path/to/template.marko');
require('marko/compiler').defaultOptions.writeToDisk = false;
```

I'm not aware of any hooks or methods in the API to write a specific template to disk, but that's probably worth considering even if the default value of `writeToDisk` doesn't change. Something like `Template.prototype.writeToDisk()`, perhaps? I might look into implementing that sometime if I get the chance. I see. Personally I think it'd be great if you could add something to the code like:

```js
<script>
module.exports = {
  debug: true,
  onInput(attrs) {
    // ...
  }
}
</script>
```

where `debug` can be `true` or, if need be, an options object like `{ writeToDisk: true }`. I would find that to be really handy :) @patrick-steele-idem That's exactly what I was just thinking. Perhaps this would be a good first use case for the `<debug>` tag that was being discussed not too long ago, like `<debug write-to-disk=true />`? Yes, now that you mention it, a tag would be better. That way you can debug whether or not you have a `<script>` tag.  <!----------------------------------------------------------------------
  |     IF FEATURE SUGGESTION (skip to next section for bug reports)    |
  ---------------------------------------------------------------------->
## Custom root path for views
### Description

Sometimes, we want to use `require('marko/node-require').install(options)` to the third-part package.

But it will set the views dir to package's dir. so should need an option to set root path.
 ## example

https://github.com/trekjs/views/blob/master/packages/marko/index.js

``` js
/**
 * Install marko
 *
 * @param {Object} options
 */

function install (options) {
  require('marko/node-require').install(options)
}

/**
 * Stream render view
 *
 * @param {String} view
 * @param {Object} state
 * @return {Stream}
 */

function render (view, state) {
  return require(view).stream(state)
}

module.exports = {

  install,

  render

}
```

https://github.com/trekjs/examples/blob/next/template-marko/app.js

``` js
const path = require('path')

const Engine = require('trek-engine')

const marko = require('trek-view-marko')

marko.install()

const app = new Engine()

app.use(({ res }) => {
  res.send(200, marko.render(path.join(__dirname, './index.marko'), { name: 'Trek Engine' }))
})

app.run(3000)
```
 > Maybe something along the lines of this.

Nice work. Thanks.

> However, I would recommend having your render function take the loaded template as a parameter:

If we have many templates (> 15 pages) that not good way.
  ## Hot reload of .marko.xml not implemented
### Context

Support for XML templates in _.marko.xml_ files have some (quite good) support in runtime and tools but hot reloading remains unsupported.
### Possible Fix

Currently, the code in https://github.com/marko-js/marko/blob/master/hot-reload/index.js#L136 looks like 

```
if (path.endsWith('.marko') || path.endsWith('.marko.html')) {
            // Uncache just the modified template
            delete require.cache[path];
            delete require.cache[path + '.js'];
        }
```

A fix could be 

```
if (path.endsWith('.marko') || path.endsWith('.marko.html') || path.endsWith('.marko.xml')) {
```
 This is a though problem since we are restricted to what `require()` CAN do and not what we WANT to do.

Personally, I favor composite extensions such as `.marko.html` and `.marko.xml` since they essientially still are html and xml and thus wont break my tooling (lint, syntax hl etc).
`require()` on the other hand has no sympathy for composites and will treat `.marko.xml` as any `.xml`.

Some observations:
- a replacement api for `require('./some.marko')` isnt feasible, since `require()` is the only viable api that has the much needed implicit dependency to the module variable `__dirname` required for resolving the full path.
- hot reloading in marko is actually more of a _hot unloading_ (https://github.com/nodejs/node/blob/ebc8c37f70a84a64851b440493f3441eb9f70fdb/lib/module.js#L436)

So, a possible solution to this is to alter the semantics of install.

Consider

```
install({
    extension: '.marko.xml'
})
```
- Make the implementation of `require('marko/hot-reload').handleFileModified(<path>)` aware of the full extension, `.marko.xml`.
- Alter the `require.extensions` mapping using the effective extension, in this case `.xml` (https://github.com/marko-js/marko/blob/master/node-require.js#L76)

My guess is that this is an addition rather than a breaking change since composite extensions currently has no effect (at least not the intended) on `install()`.

Unfortunately, I have little time for this at the moment, mainly since I work full hours in windows environments which doesnt support symlinks used in the tests.

@patrick-steele-idem , let me come back on this, perhaps I dust of my old McBookPro in the weekend...
  I want a package, just dependent on marko and not modify it.
Is it ok under MIT for package?
 Thanks.
So, It's ok under MIT.
 Cool! Thank you! üçª
  Safari is waiting the completion of the first await tag

When i try to render async fragment (await tag)

**In Chrome without client-reorder**
1. Outer html rendered
2. First await tags rendered
3. Second await tag rendered
_With client-order same except order of await tags like expected._

**In Safari without client-reorder**
1. Not render outer html until all await tags done
2. All html rendered together

**In Safari with client-reorder**
1. Safari is waiting until first await tag done
2. Outer html and first await tag rendered
3. Second await tag rendered
 Hi @patrick-steele-idem my safari version is 9.1.2 (11601.7.7) on OSX El Capitan and same issue on https://github.com/llambda/koa-boiler.
 I found solution! it was happen because i run server under browser-sync proxy.
  I'd like to start by saying awesome concept, finally a library which puts performance first.

Now, I've just come from an AngularJS/Gulp development background so I'm new to the whole JavaScript bundlers concept.

I'm trying to wrap my head around how the recommended file structure should look like on bigger projects. I've been downloading and testing out the samples (awesome) but I haven't been able to stitch them together. I also had a hard time understanding how client side rendering with marko works, server side wasn't too hard to figure out, coming from Handlebars it really wasn't that much different.

Tbh I think explaining from scratch for beginners who have just come from i.e. jQuery how marko works will draw _a lot_ more attention to it.

After looking at the following repos I've sot of come up with the following file structure.

```
/project/src/client.js    <---    
https://github.com/marko-js-samples/marko-widgets-client-rendering
/project
/project/build    <---    what is this directory for?
/project/node_modules    <---    no brainer, npm modules
/project/src    <---    dev files
/project/src/marko.json    <---    Haven't understood this file yet
/project/src/client.js    <---    Haven't understood why this file is here?
/project/src/common    <---    I'm guessing this is for files that all pages or components share
/project/src/common/browser.json    <---    lasso needs this to compile correctly (code splitting etc.)
/project/src/common/common.css    <---    css styles when a page/component includes the "common" package? (overrides?)
/project/src/common/common.js    <---    same as .css but with JS
/project/src/componenets    <---    Holds marko-widget reuseable componenets
/project/src/componenets/my-widget    <---    Is a marko-widget reuseable componenet
/project/src/componenets/my-widget/index.js    <---    [What does this do and what should be in it?](http://markojs.com/docs/marko-widgets/get-started/#split-renderer-and-widget-1)
/project/src/componenets/my-widget/renderer.js    <---    [What does this do and what should be in it?](http://markojs.com/docs/marko-widgets/get-started/#split-renderer-and-widget-1)
/project/src/componenets/my-widget/widget.js    <---    [What does this do and what should be in it?](http://markojs.com/docs/marko-widgets/get-started/#split-renderer-and-widget-1)
/project/src/componenets/my-widget/style.css    <---    Holds the style for the component (overrides?)
/project/src/componenets/my-widget/template.marko    <---    Holds the html markup for the component
/project/src/pages    <---    Holds marko template pages
/project/src/pages/home    <---    Holds the home marko template page
/project/src/pages/home/browser.json    <---    lasso needs this to compile correctly (code splitting etc.)
/project/src/pages/home/client.js    <---    Whats the difference between this and index.js?
/project/src/pages/home/index.js    <---    Whats the difference between this and client.js?
/project/src/pages/home/style.css    <---    Holds the style for the component (overrides?)
/project/src/pages/home/template.marko    <---    Holds the html markup for the page
/project/src/pages/home/template.marko.js    <---    auto-generated
/project/static    <---    This is the directory which should be served publicly (lasso bundles end up here)
/project/.cache    <---    Used by lasso for quicker bundling?
```

I am also wondering how does one create a template which nests another template? I would like to pass data as well.

Also tags vs. widgets?

I think being able to explain this structure well for newcomers will increase their chance of using marko. Personally I would like to see an example project which touches all areas so I can see how they could be fit together, right now I'm shooting in the dark!

As stated before client marko rendering (both non widget and widget) is still unclear to me. I tried bundling with webpack etc. however it wasn't until I looked at lasso I realised that lasso is actually needed. I think this should be more clear in the marko & marko-widgets documentation when talking about client side rendering.

Also thumbs up to upgrading to ES6 syntax (import/export). I want to completely stop writing CommonJS and starting writing just offical JS.

I probably have more questions, will take them later! :)
 Thanks for this information. But I still have a doubt. All content that are inside `src` folder, is focussed only in the modularization of client side, right? 
 @mlrawlings Brilliant example! I have another question. I've been reading and haven't found an answer to it yet. The code below you pass item.name to the tempalte. Is it possible to pass a JSON object instead?

```
<ul for(item in data.items)>
    <include('./item.marko') name=item.name />
</ul>
```
 I am having too many components in on folder  /project/src/componenets .
Whats the way of grouping components pages wise ?  http://markojs.com/docs/marko/koa/

```
require('marko/node-require').install();

var koa = require('koa');

var app = koa();

app.use(function *() {
    this.body = template.stream({
            name: 'Frank',
            count: 30,
            colors: ['red', 'green', 'blue']
        });
});

app.listen(8080);
```

However it states at http://markojs.com/docs/marko/javascript-api/#streamtemplatepath-templatedata--streamreadable

```
stream(templatePath, templateData) : stream.Readable
Deprecated. Do not use.
```

So, use stream or not? Feels like you guys should have one place for information on usage. This is confusing!
 Apologize.

http://markojs.com/docs/marko/javascript-api/#streamtemplatedata--streamreadable

Was looking at the wrong method!
  [![Coverage Status](https://coveralls.io/builds/7528756/badge)](https://coveralls.io/builds/7528756)

Coverage increased (+0.04%) to 84.316% when pulling **bd488be54823b88eaa736fd25da3fec0a9ac0a2b on issue-357** into **78a73e573e60b7d076ca51d4cc94c0b85a0150fd on master**.
  Is it possible to see a workaround for this outside of 

``` js
<script marko-init>
var empty = require('marko/helpers/empty');
var notEmpty = require('marko/helpers/notEmpty');
</script>
```

I'm using:

```
<if(data.commits && data.commits.length)>
  ...
</if>
```
   [![Coverage Status](https://coveralls.io/builds/7345040/badge)](https://coveralls.io/builds/7345040)

Coverage remained the same at 84.163% when pulling **7a53328bf02c0668ba42558a500fd2c3f868a2b9 on sdepold:patch-1** into **8017e1485d0c4f1110fe2cb089760e19fa8f0dd2 on marko-js:master**.
  [![Coverage Status](https://coveralls.io/builds/7328873/badge)](https://coveralls.io/builds/7328873)

Coverage decreased (-0.01%) to 84.163% when pulling **b1b59be5cbd62fba678b799f08f8b4adffbfefd3 on attr-empty-string** into **8382d4ce02f740c73ac6f0e9057654ace3a32719 on master**.
  Not sure if this is a problem with released artifact or not
 Seems to only affect marko even on version 3.8.1

```
robinanil 17:32:16 :~/work/admin/consumer$ npm uninstall marko
- app-module-path@1.1.0 node_modules/app-module-path
- async-writer@1.4.2 node_modules/async-writer
- browser-refresh-client@1.1.4 node_modules/browser-refresh-client
- char-props@0.1.5 node_modules/char-props
- htmljs-parser@1.5.13 node_modules/htmljs-parser
- object-assign@4.1.0 node_modules/marko/node_modules/object-assign
- property-handlers@1.1.1 node_modules/property-handlers
- raptor-args@1.0.3 node_modules/raptor-args
- raptor-async@1.1.3 node_modules/raptor-async
- lasso-caching-fs@1.0.1 node_modules/lasso-caching-fs
- lasso-package-root@1.0.0 node_modules/lasso-package-root
- raptor-polyfill@1.0.2 node_modules/raptor-polyfill
- deresolve@1.1.1 node_modules/deresolve
- raptor-regexp@1.0.1 node_modules/raptor-regexp
- raptor-stacktraces@1.0.1 node_modules/raptor-stacktraces
- raptor-logging@1.1.2 node_modules/raptor-logging
- raptor-strings@1.0.2 node_modules/raptor-strings
- raptor-json@1.1.0 node_modules/raptor-json
- raptor-util@1.0.10 node_modules/raptor-util
- raptor-promises@1.0.3 node_modules/raptor-promises
- strip-json-comments@2.0.1 node_modules/strip-json-comments
- try-require@1.2.1 node_modules/try-require
- marko@3.8.1 node_modules/marko
robinanil 17:33:11 :~/work/admin/consumer$ npm install 
consumer@1.0.0 /Users/robinanil/work/admin/consumer
‚îî‚îÄ‚î¨ marko@3.8.1 
  ‚îú‚îÄ‚îÄ app-module-path@1.1.0 
  ‚îú‚îÄ‚îÄ async-writer@1.4.2 
  ‚îú‚îÄ‚îÄ browser-refresh-client@1.1.4 
  ‚îú‚îÄ‚îÄ char-props@0.1.5 
  ‚îú‚îÄ‚îÄ deresolve@1.1.1 
  ‚îú‚îÄ‚îÄ htmljs-parser@1.5.13 
  ‚îú‚îÄ‚î¨ lasso-package-root@1.0.0 
  ‚îÇ ‚îî‚îÄ‚îÄ lasso-caching-fs@1.0.1 
  ‚îú‚îÄ‚îÄ object-assign@4.1.0 
  ‚îú‚îÄ‚îÄ property-handlers@1.1.1 
  ‚îú‚îÄ‚îÄ raptor-args@1.0.3 
  ‚îú‚îÄ‚îÄ raptor-async@1.1.3 
  ‚îú‚îÄ‚îÄ raptor-json@1.1.0 
  ‚îú‚îÄ‚î¨ raptor-logging@1.1.2 
  ‚îÇ ‚îî‚îÄ‚îÄ raptor-stacktraces@1.0.1 
  ‚îú‚îÄ‚îÄ raptor-polyfill@1.0.2 
  ‚îú‚îÄ‚îÄ raptor-promises@1.0.3 
  ‚îú‚îÄ‚îÄ raptor-regexp@1.0.1 
  ‚îú‚îÄ‚îÄ raptor-strings@1.0.2 
  ‚îú‚îÄ‚îÄ raptor-util@1.0.10 
  ‚îú‚îÄ‚îÄ strip-json-comments@2.0.1 
  ‚îî‚îÄ‚îÄ try-require@1.2.1 

robinanil 17:33:36 :~/work/admin/consumer$ ls node_modules/marko/runtime/
deprecateHyphens.js helpers.js          loader.js           loader.js.orig      loader_browser.js   marko-runtime.js    package.json
robinanil 17:34:06 :~/work/admin/consumer$ 
```
 3.6.1 does not have this issue

```
robinanil 17:35:52 :~/work/admin/consumer$ npm install
npm WARN deprecated minimatch@0.2.14: Please update to minimatch 3.0.2 or higher to avoid a RegExp DoS issue
consumer@1.0.0 /Users/robinanil/work/admin/consumer
‚îî‚îÄ‚î¨ marko@3.6.1 
  ‚îî‚îÄ‚î¨ minimatch@0.2.14 
    ‚îî‚îÄ‚îÄ lru-cache@2.7.3 

robinanil 17:36:13 :~/work/admin/consumer$ ls node_modules/marko/runtime/
deprecateHyphens.js helpers.js          loader.js           loader_browser.js   marko-runtime.js    package.json
robinanil 17:36:19 :~/work/admin/consumer$ 
```
  [![Coverage Status](https://coveralls.io/builds/7292035/badge)](https://coveralls.io/builds/7292035)

Coverage increased (+0.02%) to 84.152% when pulling **0521933c99754fe18959f22fc77fe594f35c92d5 on issue-345** into **d433ac25aa2b428b4b46060e310c55a00183ff18 on master**.
  [![Coverage Status](https://coveralls.io/builds/7291326/badge)](https://coveralls.io/builds/7291326)

Coverage increased (+0.03%) to 84.129% when pulling **94eafb7bd6bd100bc5a722e9a8388ced1c044f87 on issue-344** into **7e76972737843b3614520242cee9a3ca2fa728c5 on master**.
  ### Description

Currently marko-widgets allows to define a UI component's renderer as `require('marko-widgets').defineRenderer({...});`. I would like to propose a similar, but simpler:

`require('marko').defineRenderer({...});`
### Context

Building our project, we've defined custom taglibs that export the simplest "components" to more complex components. For simple componets (server-rendered only, no state, little to no client behavior), our approach to custom taglibs has been to export in index.js a function that takes an `input` and then calls template.render.

```
module.exports = function(input, out) {
    template.render(input, out);
}
```

Unlike defineRenderer, this does not export a `render` function similar to defineRenderer. We could set `exports.render` or use `createRenderFunc` from `raptor-renderer`, however I would like to propose a `defineRenderer` in `marko`, with similar (but much simpler) life cycle events.

```
module.exports = require('marko').defineRenderer({
    template: require('./template.marko'),
    getTemplateData: function (input) {
        input.time = Date.now();
        return input;
    }
});
```

The added benefit (and why this beats `exports.render` or `createRenderFunc`) is that if the simple component takes on a more, complex role, adding `-widgets` + any extra lifecycle event methods is straightforward and painless.

Thanks!
 üëç  I always thought this API difference between marko and marko-widgets was a bit strange.
 üëç  totally agree here.
  ## Bug Report
### Context

I have a project where we embed another templating language inside of a marko template. Because of this, there are cases where we need to disable Marko's parsing for sections of HTML, so that Marko does not try to parse foreign template syntax that may throw errors. We use the marko-body="static-text" attribute to disable Marko parsing. 

HTML snippets that causes parser error:

Example 1:
`<div marko-body="static-text">
    <div>Content Goes Here</div>
</div>`

Example 2:
`<section marko-body="static-text">
        <div>Other Content</div>
    <section>Content Goes Here</section>
</section>`

Note that the element type of node with marko-body attribute must match some element within it. 
### Expected Behavior

The output should be:

Example 1:
`<div>
    <div>Content Goes Here</div>
</div>`

Example 2:
`<section>
        <div>Other Content</div>
    <section>Content Goes Here</section>
</section>`
### Actual Behavior

Example 1: Parser error - 'The closing "div" tag was not expected'
Example 1: Parser error - 'The closing "section " tag was not expected'
### Possible Fix

<!--- Not obligatory, but suggest a fix or reason for the bug -->

<details><summary>

Additional Info</summary>


### Your Environment
- Versions used:
- Marko 3.8.1
- Lasso 2.5.5
- Lasso-Marko 2.0.7
- Operating System and version (desktop or mobile): Ubuntu 14.04
- Link to your project: (eBay Internal)
### Steps to Reproduce

Input either of these pieces of code on http://markojs.com/try-online/

`<div marko-body="static-text">
    <div>Content Goes Here</div>
</div>`

`<section marko-body="static-text">
        <div>Other Content</div>
    <section>Content Goes Here</section>
</section>`
### Stack Trace

Example 1: Parser error - 'The closing "div" tag was not expected'
Example 1: Parser error - 'The closing "section " tag was not expected'

</details>
 A custom tag would be great! Another huge benefit of a custom marko-parser tag (versus attribute on a rendered tag) is that it can act a non-rendered parser directive, resulting in no additional HTML output/DOM structure change. 

Background: When I used the existing version of this marko-body attribute, I wanted to be able to ignore a block of HTML (which contained non-marko compatible AngularJS syntax in it), but not result in a new non-functional node that wraps the content (which can potentially affect animation and browser compositing performance depending on the kind of operations you perform on your DOM elements). I ended up attaching the marko-body attribute to each HTML element, but had to be careful of the same element type within to prevent this gotcha. 
  [![Coverage Status](https://coveralls.io/builds/7094318/badge)](https://coveralls.io/builds/7094318)

Coverage increased (+0.003%) to 84.041% when pulling **2cdc18afc52665e75a235a32932942b7147d5fd9 on exclude-dir-fix** into **f2116dc44d032bc56bb762a2e577c28fb8233004 on master**.
 [![Coverage Status](https://coveralls.io/builds/7094851/badge)](https://coveralls.io/builds/7094851)

Coverage increased (+0.06%) to 84.095% when pulling **adea7ca0a06d5cc29d9fe36a9fc0eb0f5ee81ded on exclude-dir-fix** into **f2116dc44d032bc56bb762a2e577c28fb8233004 on master**.
 [![Coverage Status](https://coveralls.io/builds/7094932/badge)](https://coveralls.io/builds/7094932)

Coverage increased (+0.06%) to 84.095% when pulling **5e070d61251b27d614cacf4ad9aa8c58d5e79bb7 on exclude-dir-fix** into **f2116dc44d032bc56bb762a2e577c28fb8233004 on master**.
  [![Coverage Status](https://coveralls.io/builds/7059387/badge)](https://coveralls.io/builds/7059387)

Coverage increased (+0.04%) to 84.038% when pulling **4f43e93da4b825136f83d914b712a3f5cf76331d on autodiscover-components** into **213e65241898b19f853f704d8e8bbca2a06c1465 on master**.
  I'm fairly new to Marko and I'm having some difficulties handling errors gracefully when rendering templates (on the server). Initially I structured my app to pipe the render stream straight to the response:

``` js
const marko = require('marko')

const template = marko.load(filename, {
  buffer: false
})

return (req, res) => {
  ...
  return template.render(data, res)
})
```

But when the rendering process errors (E.G. attempting to access an undefined property) this results in an unfinished response.

Preferably I'd like to catch the error, log it and fail more gracefully, even it means taking a small perf hit:

``` js
// with callback
return (req, res) => {
  ...
  return template.render(data, (err, data) => {
    if (err) {
      log(err)
      res.send(500).end()
    } else {
      res.send(data)
    }
  })
})

// or with streams
return (req, res) => {
  ...
  return template.stream(data)

  stream.on('data', data => { output.push(data) })

  stream.on('error', err => { errors.push(err) })

  stream.on('end', () => {
    if (errors.length) {
      log.apply(null, errors)
      res.send(500).end()
    } else {
      res.send(output.join(''))
    }
  })

  return stream
})
```

However neither the streaming nor callback interface are currently able to catch such an error, with the effect of potentially crashing the process.

Are you able to recommend a strategy whereby templates can fail more gracefully at render time?
 Thank you for your fast response @patrick-steele-idem - I actually read the article you linked to before posting my question, too üòÅ

I'd also tried promises (for the implicit try/catch) but I'd made the mistake of _returning__ the result of the render method - thanks to your example I'll continue with that path.

A promise based API sounds like a very good idea to me üëç 
  I'm trying to pretty-print some JS that comes from CoffeeScript's `compile()` and  using a [compile-time tag](https://github.com/marko-js/marko/blob/master/docs/compile-time-tags.md) like so:

`marko.json`:

``` js
{
  "<coffee-script>": {
    "code-generator": "./lib/tags/coffee-script",
    "body": "static-text",
    "preserve-whitespace": true,
    "@bare": "boolean"
  },
  "<stylus-css>": {
    "code-generator": "./lib/tags/stylus-css",
    "body": "static-text",
    "preserve-whitespace": true,
    "@compress": "boolean",
    "@paths": "array"
  }, ...
}
```

`coffee-script.coffee`:

``` coffee
'use strict'

{compile} = require('coffee-script')

module.exports = (el, generator) ->
  {builder} = generator
  bare = el.getAttributeValue('bare') or yes
  print = (process.env.npm_lifecycle_event is 'standard')

  js = compile(el.bodyText, {bare, print})
  console.log js

  return builder.htmlElement 'script', {}, [
    builder.text builder.literal(js)
  ]
```

`stylus-css.coffee`:

``` coffee
'use strict'

stylus = require('stylus')

module.exports = (el, generator) ->
  {builder} = generator
  compress = (process.env.npm_lifecycle_event is 'optimized')

  css = stylus(el.bodyText)
    .set 'compress', el.getAttributeValue('compress') or compress or no
    .set 'paths', el.getAttributeValue('paths') or []
    .render()

  console.log css

  return builder.htmlElement 'style', {}, [
    builder.text builder.literal(css)
  ]
```

Sample console output (js):

``` js
var clickDefault, collapseFormat, initLayer;

initLayer = function() {
  screenad.hide('self');
  screenad.setSize('600', '250');
  screenad.setAlignment('banner', 'banner');
  screenad.setOffset(-300, 0);
  screenad.setSticky(true);
  screenad.setZIndex(100000);
  return screenad.position();
};

collapseFormat = function() {
  screenad.event('user_close');
  return screenad.hide();
};

clickDefault = function() {
  return screenad.click();
};

var init_layer;

init_layer = function() {
  screenad.hide('self');
  screenad.setAlignment('banner', 'banner');
  screenad.setSticky(layer.sticky);
  screenad.setSize(layer.width, layer.height);
  screenad.setOffset(layer.x, layer.y);
  screenad.setZIndex(layer.z);
  screenad.position();
};
```

Sample console output (css):

``` css
body {
  background-color: #000;
}
#closebutton {
  background-image: url("close.png");
  bottom: 0px;
  cursor: pointer;
  height: 20px;
  position: absolute;
  right: 0px;
  width: 90px;
  z-index: 110000;
}
#closebutton:hover {
  opacity: 0.8;
}
#wrap_bg {
  background-image: url("backup-layer.jpg");
  background-repeat: no-repeat;
  cursor: pointer;
  height: 100%;
  width: 100%;
  z-index: 100010;
}
```

Sample compiled html (notice the output between `<script>` and `<style>` tags):

``` html
<!DOCTYPE html>
<html lang="en">
  <head>
    [...]
    <script>
      var init_banner; init_banner = function() { screenad.setAlignment('banner', 'banner'); screenad.setSticky(banner.sticky); screenad.setSize(banner.width, banner.height); screenad.setOffset(banner.x, banner.y); screenad.setZIndex(banner.z); screenad.position(); };
    </script>
    <style>
      body { font-family: "Trebuchet MS"; text-align: center; } #content { height: 100%; width: 100%; } #container { background-color: #fff; z-index: 1000; } #clicktoexpand { background-color: #fff; background-image: url("clicktoexpand.png"); background-repeat: no-repeat; bottom: 0px; cursor: pointer; height: 23px; left: 0px; position: absolute; width: 170px; z-index: 10000; } #clicktoexpand:hover { opacity: 0.8; }
    </style>
    <script>
      var _autoExpand, _click, _expandType, clickDefault, ignite, init, showLayer, start; _click = 'click'; _expandType = _click; _autoExpand = false; ignite = false; init = function() { screenad.event(screenad.deviceType); if (!ignite) { screenad.onSync = start; ignite = true; } }; start = function() { if (_expandType === _click) { document.getElementById('container').addEventListener(_click, clickDefault); } if (_autoExpand && ignite) { showLayer(); } screenad.setSize('300', '250'); screenad.setAlignment('banner', 'banner'); screenad.setOffset(0, 0); screenad.setSticky(true); screenad.setZIndex(100); screenad.position(); }; showLayer = function() { screenad.event('expand'); screenad.show('all'); }; clickDefault = function() { screenad.click(); };
    </script>
    [...]
  </head>  
  <body onload="init_banner()">
    <script>
      window.banner = {"width":320,"height":240,"sticky":true,"x":0,"y":0,"z":1,"libraries":["//media.adrcdn.com/scripts/external/velocityjs/1.2.3/velocity.min.js","//media.adrcdn.com/scripts/external/velocityjs/1.2.3/velocity.ui.min.js"]};
    </script>
    [...]
  </body>
</html>
```

Expected output:
I would like the js whitespace to be preserved whenever `process.env.npm_lifecycle_event === "standard"` (i.e. when `npm run standard` is run) and minified whenever the same env var is set to `optimized`. Is there a way to accomplish this?
 @mlrawlings perfect! I should've looked at `builder.text` instead of `builder.literal` first‚Ä¶ Thanks!
  HTH
  HTH
  Marko is not showing any error related to unexpected characters / invalid JSON config.

Invalid json config - browser.json :

`[
 {
            "type": "js",
            "url": "https://cdnjs.cloudflare.com/ajax/libs/select2/4.0.3/js/select2.min.js"
        },
]`

Error shown after some time : 

`Error: Async fragment failed (lasso-slot:head). Exception: Error: Async fragment (lasso-slot:head) timed out after 30000ms`

I believe a parsing error can be thrown right away if browser.json or any other config file is invalid and marko is unable to parse such file.
  [![Coverage Status](https://coveralls.io/builds/7034622/badge)](https://coveralls.io/builds/7034622)

Coverage remained the same at 83.998% when pulling **fd9e5413ab812d38072ffbe3f763e3cf2321a91e on contributing** into **207102bccab3566ebc8cab1212744e0340cb71c2 on master**.
  It seems like there are a lot of other pieces where we have convention with the additional option of providing your own. E.g. `renderer.js` will be found automatically, but you can specify your own renderer naming if desired. Might be more consistent to apply that to custom tag discovery as well, so that we look for `components/` by default, but allow customization if needed. This would mean that the name `components/` can't be used for anything else though.

Practically speaking, my `components/` folder is not usually completely flat, so my nested components would need the discovery path in marko.json anyway.
 @mlrawlings I see, although in my case I don't normally need an entire new `components` folder for my sub components, so it would be like

```
/
 ‚§∑ src/
    ‚§∑ components/
        ‚§∑ some-component/
               ‚§∑ some-subcomponent/
               ‚§∑ another-subcomponent/
           ‚§∑ index.js
           ‚§∑ template.marko
```

So if this change was made it would mean that my small projects wouldn't need a `marko.json` file, while my larger projects would have one string removed from the config lookup array.
  The `alt` attribute has a few scenarios where it should be an empty string, particularly when used on decorative images: https://developers.whatwg.org/embedded-content-1.html#a-purely-decorative-image-that-doesn%27t-add-any-information

In marko v3, rendering `<img alt="">` will become `<img alt>`. Haven't checked the exact output in v2, but I believe the issue is there too. Is there a workaround to get empty strings to show up? I imagine there might be similar cases out there for other attributes, but maintaining a list of exceptions would be unfortunate.
 There are probably cases where people rely on empty string not rendering the attribute, as in `<div class=${data.someClass}>` when `data.someClass` is an empty string. Technically it wouldn't break anything to have it output as `<div class="">`, but that's probably worse off than before. Maybe it's worth it to maintain the exceptions?
 @mlrawlings This came up in a PR recently where using an a single space alt was the best solution we could come up with, but stood out as a clear hack. Apparently alt is "required no matter what" (probably due to screen reader behavior?) which then leads to weird cases where the official suggestion is to have `alt=""`.

I haven't tried any exhaustive testing to clarify the differences between `alt` and `alt=""`, but since the latter seems to be recommended, I imagine they're treated differently by screen readers.
 But it's an officially sanctioned hack! üòÜ 
 I'm not sure, in that case I think I'd personally prefer leaving it as-is. Empty string is a nice shortcut to avoid rendering an attribute, and it's only wrong in this one case.
  ## Summary

Adding type annotations to JavaScript in order to get compile-time guarantees has become popular with tools like [TypeScript](https://www.typescriptlang.org) and [Flow](https://flowtype.org/). Would it be feasible to get the same benefits in Marko template files?
## Rationale

View engines that are "just JavaScript" like React can easily be type-checked (both TypeScript and Flow actually have out-of-the box support for React).

When working with templates though, you loose the benefit of type-checking as soon as you cross the boundary into the template file. In a type-checked project, this can make refactoring trickier, for example you rename a property but forget to update the template.

On the other hand, templates have the advantage of compile-time optimizations (ex: [ server-side rendering performance](http://markojs.com/blog/announcing-marko-v3/#compile-time-optimizations)). Being able to have type-checked templates could be a big win. I don't think this has been done yet in the JavaScript community.

Note: My knowledge of compiling templates or type-checking is close to none, so I don't even know if this is feasible :) This issue is intended to start a discussion.
## What it could look like

(I'm using TypeScript in my examples but this could very well be translated to Flow.)

Say I have declared these types:

``` typescript
// types.ts

export interface Cat {
  name: string;
  meow: string;
}

export interface Dog {
  name: string;
  woof: string;
}
```

A TypeScript file would immediately tell me if I'm accessing wrong properties:

``` typescript
// test.ts

import { Cat, Dog } from "./types";

function run(cat: Cat, dog: Dog) {
  // Error: Property 'woof' does not exist on type 'Cat'.
  console.log(cat.name, cat.woof);
  // Error: Property 'meow' does not exist on type 'Dog'.
  console.log(dog.name, dog.meow);
}
```

But a Marko template wouldn't:

``` html
<!-- templates/animals.marko -->

<div>
  <h3>${data.cat.name}</h3>
  <p>${data.cat.woof}</p> <!-- cat.woof is undefined -->
  <h3>${data.dog.name}</h3>
  <p>${data.dog.meow}</p> <!-- dog.meow is undefined -->
</div>
```

What if I could declare the type of the data my template expects?

``` html
<!-- templates/animals.marko -->

<script marko-import>
  import { Cat, Dog } from "../types";

  interface TemplateData {
    cat: Cat;
    dog: Dog;
  }
</script>

<div>
  <h3>${data.cat.name}</h3>
  <p>${data.cat.woof}</p>
  <h3>${data.dog.name}</h3>
  <p>${data.dog.meow}</p>
</div>
```

And tell Marko to generate type-annotated files?

``` bash
$ markoc templates --types=typescript
```

The TypeScript compiler would then catch the errors on the generated JavaScript:

``` typescript
// templates/animals.marko.ts

import marko from "marko";

import { Cat, Dog } from "../types";

interface TemplateData {
  cat: Cat;
  dog: Dog;
};

function create(__helpers) {
  var str = __helpers.s,
      empty = __helpers.e,
      notEmpty = __helpers.ne,
      escapeXml = __helpers.x;

  return function render(data: TemplateData, out) {
    out.w("<div><h3>" +
      escapeXml(data.cat.name) +
      "</h3><p>" +
      // Error: Property 'woof' does not exist on type 'Cat'.
      escapeXml(data.cat.woof) +
      "</p><h3>" +
      escapeXml(data.dog.name) +
      "</h3><p>" +
      // Error: Property 'meow' does not exist on type 'Dog'.
      escapeXml(data.dog.meow) +
      "</p></div>");
  };
}

let template: MarkoTemplate;
template = marko.c(__filename)).c(create);

export default template;
```

And as I use the template in my type-checked project I would get auto-completion and type errors:

``` typescript
// render.ts

import template from "./templates/animals.marko";
import { Cat, Dog } from "./types";

let cat: Cat;
cat = {
  name: "Felix",
  meow: "Meow!"
};

let dog: Dog;
dog = {
  name: "Rex",
  woof: "Woof!"
};

// Error: Argument of type '{ cat: Dog; dog: Cat; }' is not assignable to parameter of type 'TemplateData'.
//  Types of property 'cat' are incompatible.
//    Type 'Dog' is not assignable to type 'Cat'.
//      Property 'meow' is missing in type 'Dog'.
var html = template.renderSync({
  cat: dog,
  dog: cat
});
console.log(html);
```
## Open questions
- Source-maps & errors: If a runtime error occurs in the generated JS, can we show the line in the `.marko` file that caused it?
- Editor integration: A nice feature of TypeScript is the auto-completion and real-time type-checking. Would it be feasible to have that directly in the the `.marko` file?
## Relevant links
- https://github.com/Microsoft/TypeScript/issues/5151
- Original discussion: https://twitter.com/MarkoDevTeam/status/748638615937245185
 @patrick-steele-idem @mlrawlings I haven't gotten a change to explore this much, but I saw that Marko v4 is just around the corner (congratz btw! üòÑ). I definitely don't expect this to make it to v4, but I did want to see if there were any changes in v4 that would make it hard to add TypeScript support in the future (should we want to of course), without any breaking changes.

I've quickly put this together: https://github.com/nicolashery/explore-marko-typescript

You can take a look at how I had to change the original Marko output ([src/components/search-results-item.marko.js](https://github.com/nicolashery/explore-marko-typescript/blob/master/src/components/search-results-item.marko.js)) to make it useful with TypeScript ([src/components/search-results-item.marko.ts](https://github.com/nicolashery/explore-marko-typescript/blob/master/src/components/search-results-item.marko.ts)).

There are a couple things in there, but the main one that caught my attention is probably Marko's `class` tag. It is rather prescriptive and also the JS seems to get parsed, so I can't use TypeScript syntax (like I can in Marko's `static` tag). I also can't use an ES6 class (which reminds me of React switching from `React.createClass()` to standard ES6 class).

Off the top of my mind, one option could be for the `class` tag to be an actually ES6 class. Or it could be a `component` tag instead, that works more like the `static` tag (i.e. allows any text assumed to be valid JavaScript, and that JS should evaluate to a valid Marko component). Thoughts?

Of course I don't want to distract, I know you guys are focused on shipping v4 and that's the most important. But I thought it could be worth thinking about this now, even if just a little bit. Thanks @mindeavor, I hadn't seen that. From skimming through it, I think this will help with the question of editor integration (ex: [VSCode Angular Language Service](https://github.com/angular/vscode-ng-language-service)). I looks like it's been open for a while though.

What I had in mind as a first step is more along the lines of [Angular's Ahead of Time (AOT) compilation](https://angular.io/docs/ts/latest/cookbook/aot-compiler.html), which outputs TypeScript code that can be used when type-checking the whole app (business logic code + templates):

```
$ markoc src/ --typescript
Compiling:
  Input:  src/components/search-results-item.marko
  Output: src/components/search-results-item.marko.ts

Compiled 1 templates(s)

$ tsc
src/components/search-results-item.marko.ts(98,26): error TS2339: Property 'pric' does not exist on type 'SearchResultsItem'.
``` I haven't looked closely, but looks like the plugin support released in [TypeScript 2.3](https://blogs.msdn.microsoft.com/typescript/2017/04/27/announcing-typescript-2-3/) may be of help for type-checking `.marko` files, and more generally providing editor tooling for Marko (autocompletion, etc.). Here is an example [plugin for the Vue.js framework](https://github.com/octref/vetur/).  [![Coverage Status](https://coveralls.io/builds/6826187/badge)](https://coveralls.io/builds/6826187)

Coverage remained the same at 83.885% when pulling **32c820fe8f194975b69648b0adec732740cb7f53 on patrick-steele-idem:markoc-tests** into **4e9a6b108c5f4b633dcd2590df8dc7ef447f9fcc on marko-js:master**.
  Hello,

while trying out Marko I tested how it's autoescaping works in different contexts.

The contexts I tested it in:
- inside html tag
- inside html attribute
- inside html script tag

In first two Marko correctly detected context and chose proper escaping functions (I saw escapeXml and escapeXmlAttr in compiled templates), but in the last one I was able to do XSS.

You can replicate it on http://markojs.com/try-online/

marko template

``` html
<p onclick='alert("${ data }")'>${ data }</p>
<script>var x = "${ data }"</script>
```

data

``` js
"\"; alert('xss');\""
```

HTML output

```
<p onclick="alert(&quot;&quot;; alert(&#39;xss&#39;);&quot;&quot;)">"; alert('xss');"</p>
<script>
    var x = ""; alert('xss');""
</script>
```
 @patrick-steele-idem thanks for the detailed reply,

Is it really inherently unsafe to put user data in script tag? Even if you escape all characters like `>` into unicode? This seems to be what some template engines are doing.

Some provide escapejs filter - https://docs.djangoproject.com/en/1.9/ref/templates/builtins/#escapejs
Some even do this automatically by detecting context where variable is used https://latte.nette.org/en/#toc-context-aware-escaping

But you seem to be much more knowledgeable about this topic than me, so I am not sure if these filters catch 100% of XSS attackers inputs
 @patrick-steele-idem With this fix in place, is there still any reason to avoid putting data in inline scripts? The strategy of using empty dom elements with data-attributes always seemed strange to me.
  -use retina image for logo
-center logo with html
-move "Try Marko Online" to first paragraph
-move badges below first paragraph

The only way to reliably test this was by putting it on my fork master, so you can see here https://github.com/yomed/marko. Spacing is a bit worse on mobile, but there's only so much customization you can do before github takes over. Let me know of any concerns.

Desktop:
<img width="1044" alt="screen shot 2016-06-28 at 7 25 02 pm" src="https://cloud.githubusercontent.com/assets/3595986/16438603/1b3e4486-3d66-11e6-986c-dbac05f89c0d.png">

Mobile (iPhone 6 size):
<img width="403" alt="screen shot 2016-06-28 at 7 26 11 pm" src="https://cloud.githubusercontent.com/assets/3595986/16438612/363d35e4-3d66-11e6-8fa2-be0c4b3be95f.png">
 [![Coverage Status](https://coveralls.io/builds/6793825/badge)](https://coveralls.io/builds/6793825)

Coverage remained the same at 83.872% when pulling **c15c11329325566fe61fa8184dafd1b0aba245a7 on yomed:master** into **f6feffcef06e6a55dbaa208d006304febf957977 on marko-js:master**.
  ‚Ä¶ configuration variable. If files are hot reloaded, we should never assume that they are up to date.

Fixes issue #319
 [![Coverage Status](https://coveralls.io/builds/6770368/badge)](https://coveralls.io/builds/6770368)

Coverage remained the same at 83.872% when pulling **c76ffa2382e9544f57fbb3445d76ba04efa1faec on ianvonholt:ISSUE_319** into **fd318a8621ae7418a4b805f24c9f4ec01403c8ce on marko-js:master**.
  When using includes or layouts while setting writeToDisk to false, Marko still writes the JS rendered files for these.

Is this a bug? Or is there a way to disable this as well?
 Hi @patrick-steele-idem ,

I just tested the compilation process again. I'm running Marko 3.7.1 only (no other versions or duplicates are installed). For some reason the includes still write a separate JS file.

For what it's worth, I'm using Brunch in combination with https://github.com/thomastorfs/static-marko-brunch

Any ideas?
 I have having a problem with this bug as well.
 Hey Patrick, I'm also seeing this now where layout-use(template) is generating a file system compile of the template, while all other templates are not written to disk. Let me see if I can put a simpler demo together for you. 
 Ok, here's the simplest project I could make that shows the issue. When you first run this, it will create a layout.marko.js, but not a template.marko.js. It shouldn't create either, the compiler option is set to 

``` javascript
{ 
   compilerOptions: { 
         writeToDisk: false
   } 
}
```

https://github.com/jasonmacdonald/layout_generates_file
 @patrick-steele-idem I've managed to trace it back to requireResolve method in CompileContext but can't seem to understand where to go from there. It seems memberExpression() constructs a call combining require and resolve, but I can't really see what it's doing that would bypass the 'marko/node-require' which should see the flag for writeToDisk.
 Ok, further digging it seems layout.html in my example gets loaded by a helper, which uses loader/index files loadFile() method which does not get passed the options we passed in through require('marko/node-require').install({config...});. It only sees options that were set using the markoCompiler.defaultOptions.

Looking in the helper, the only thing the helper passes to load is the path, no options. 

I confirmed that switching to setting global.__MARKO_CONFIG does stop layout.html from being written to disk.

So it seems the bug is only when you set compilerOptions via the config on node-require.

My suggestion would be to have the install(config) on node-require actually set the global.__MARKO_CONFIG so it acts as expected in all loading scenarios. Just my $0.02.
 @patrick-steele-idem I figured as much, it was more just to test if that would work. :)
  [![Coverage Status](https://coveralls.io/builds/6730864/badge)](https://coveralls.io/builds/6730864)

Coverage increased (+0.06%) to 83.527% when pulling **7b1bbf3ed817964a8952d2a7d236c0f52e317097 on issue-314** into **74120dbbbea4a92be055f63d10b54804134c613e on master**.
 [![Coverage Status](https://coveralls.io/builds/6730864/badge)](https://coveralls.io/builds/6730864)

Coverage increased (+0.06%) to 83.527% when pulling **7b1bbf3ed817964a8952d2a7d236c0f52e317097 on issue-314** into **74120dbbbea4a92be055f63d10b54804134c613e on master**.
  Good idea! I need it.
 If there's enough interest, it would be fairly simple for `<await>` to also accept streams - though as Michael pointed out, it would need to buffer the stream until it was finished, so I'm not sure how useful that would be.

Alternatively, most streams can simply be converted to Promises with something like
```js
new Promise(function(resolve, reject) {
    var buffer = [];
    stream.on('error', reject);
    stream.on('data', function(data) {
        buffer.push(data);
    });
    stream.on('end', function() {
        var result = Buffer.concat(buffer).toString();
        resolve(result);
    });
});
```

Hopefully this weekend I'll get the chance to play with the `<on>` tag a bit, looks awesome! @patrick-steele-idem If `<await>` was to handle multiple-flush streams / event emitters (which I don't believe it should), I would prefer something similar to "deferred.progress()"; perhaps a separate await-specific nested tag, like `<await-on-data>`.

Though here's another thought that just popped to mind: What about something like that for the `<on>` tag? For example...
```
<ul on(streamOrEventEmitter)>
    <li on-data(result)><!-- maps to ".on('data', ...)" -->
        ${result}
    </li>
</ul>
```
...as an alternate syntax to allow binding to events other than just 'data'? On second thought, something like this might be better instead:
```
<ul>
    <li on(var1, var2 from 'eventName' of emitter)>
        ${var1 + ', ' + var2}
    </li>
</ul>
```
('from' and 'of' are just what came off the top of my head, it may need re-wording) (Just noticed the original post had an example of using a generic EventEmitter which accomplishes basically the same thing as my previous post, not sure how I missed that a few days ago.)

Hmm... Rather than starting with standard streams and adding different syntaxes to support non-standard use cases, what if we looked at this the other way around? We could start by exposing the generic behavior:
```
<ul>
    <li on(user from 'data' in data.usersStream) repeat=true>
        ${user.name}
    </li>
    <li on('end' in data.usersStream)>
        <button>load more</button>
    </li>
</ul>
```
Then add convenience syntaxes for the most common uses:
```
<ul>
    <li on(user from data.usersStream)>
        ${user.name}
        <on-finish>
            <li><button>load more</button></li>
        </on-finish>
    </li>
</ul>
```
Note that `<on(user from data.usersStream)>` and `<on-finish>` are just syntactic sugar for `<on(user from 'data' in data.usersStream) repeat=true>` and `<on('end' in data.usersStream)>`, respectively. @patrick-steele-idem - this sounds good to me. Looks lot cleaner! @patrick-steele-idem @mlrawlings - will <awaits> accept event emitter going forward. right now, its not supporting event emitter. i think its essential to support that with respect to streaming I can't think of any reason not to. Just one question: If the object has both `.on()` and `.then()` methods, should it be treated as an emitter or a thenable? (I'm leaning toward emitter, but that *might* be considered a breaking change...)

Also, a few more ideas:
* `<await(data.userStream until 'finished' or 'cancelled')>`
* `<on(user)>` (defaults to 'data' event)
* `<once(...)>` @mlrawlings @austinkelleher @patrick-steele-idem 

any tips and tricks for applying infinite scrolling with marko?  [![Coverage Status](https://coveralls.io/builds/6656558/badge)](https://coveralls.io/builds/6656558)

Coverage increased (+0.3%) to 83.728% when pulling **b3c3c564a46534b6972c3af0eae44d9b12b5d9ca on mlrawlings:await-tag** into **74120dbbbea4a92be055f63d10b54804134c613e on marko-js:master**.
 When I read `await theUserDataProvider as user`, I thought I am creating an alias `user` for `theUserDataProvider`, where as `await user from theUserDataProvider` seem to make the intent clear.
 [![Coverage Status](https://coveralls.io/builds/6679660/badge)](https://coveralls.io/builds/6679660)

Coverage increased (+0.3%) to 83.728% when pulling **ef294526d15e6e48ad20b46098584da4a533752f on mlrawlings:await-tag** into **74120dbbbea4a92be055f63d10b54804134c613e on marko-js:master**.
 [![Coverage Status](https://coveralls.io/builds/6679660/badge)](https://coveralls.io/builds/6679660)

Coverage increased (+0.3%) to 83.728% when pulling **ef294526d15e6e48ad20b46098584da4a533752f on mlrawlings:await-tag** into **74120dbbbea4a92be055f63d10b54804134c613e on marko-js:master**.
 [![Coverage Status](https://coveralls.io/builds/6679660/badge)](https://coveralls.io/builds/6679660)

Coverage increased (+0.3%) to 83.728% when pulling **ef294526d15e6e48ad20b46098584da4a533752f on mlrawlings:await-tag** into **74120dbbbea4a92be055f63d10b54804134c613e on marko-js:master**.
  So I used a progressive rendering demo and changed `addEventListener` to `w-onClick`. Now header widget reacts on clicks only after rendering is finished. Problem appeared after upgrading Marko 2 to 3.

Demo here: https://marko-progressive-bug.herokuapp.com

Forked repo to show a bug: https://github.com/darkwebdev/marko-progressive-rendering

Commit with changes: https://github.com/darkwebdev/marko-progressive-rendering/commit/afe5c03567b77b641d54404ee2eac7243b417661
  Documented exclusion of folder or node module from marko.json autodiscovery;
 Just an excuse in advance:
I'm rookie in open-source contribution and my english is not a native language. So any blame is accepted. :-)
 [![Coverage Status](https://coveralls.io/builds/6590782/badge)](https://coveralls.io/builds/6590782)

Coverage remained the same at 83.464% when pulling **748c5d7643cfdc9b114823a4e23077d35e0af7fd on oxala:feature/exclude** into **117be25411bd4ee595c5f8d6c03d2947a8eef4bc on marko-js:master**.
  Hey Patrick,

I will bother you again with specific folder/package exclusion from the automatic marko.json search.
Since we finally moved to marko3, i've reimplemented that functionality here as well.

Below you will find:
- Actual functionality implementation;
- Updated tests to cover the implementation;
 [![Coverage Status](https://coveralls.io/builds/6587535/badge)](https://coveralls.io/builds/6587535)

Coverage increased (+0.02%) to 83.445% when pulling **f8c8b5f3319b5e5b8d32aeaf7baa4b831442f07d on oxala:feature/exclude** into **9f240e7bea17116a05a9e961c14d52dab735d292 on marko-js:master**.
 No worries, thank you for accepting. Sure, i'll update the docs: https://github.com/marko-js/marko/pull/310
  [![Coverage Status](https://coveralls.io/builds/6581856/badge)](https://coveralls.io/builds/6581856)

Coverage remained the same at 83.42% when pulling **01f8a24dc04867d3d2a51907a7c4b2fb1ab08657 on mlrawlings:shorthand-classes** into **a60d0078b97c42f6c0ee85894428f808cddefa9e on marko-js:master**.
  Given:

``` html
<input type="text"
           name="username"
           placeholder="username"
           spellcheck="false"
           autocomplete="off"
           autocorrect="off"
           pattern="[\w0-9]+">
```

Marko will fail with an error:

> Error(s) in template:
> 1) [templates/views/askForUsername.marko:16:20] Invalid string ("[\w0-9]+"): SyntaxError: Unexpected token w

This is "fixable" by `pattern="[\\w0-9]+`, but that doesn't follow the HTML spec -- https://html.spec.whatwg.org/multipage/forms.html#attr-input-pattern . In other words, the value should be a regular expression that can be directly substituted into a JavaScript regular expression literal, e.g. `/[\w0-9]+/`.
 I understand the underlying issue. But my opinion is that when writing HTML within the template we shouldn't have to remember "no, this isn't really HTML, it's an escaped JavaScript string."

I think a solution to this, and probably other cases, would be to have a `<raw></raw>` Marko directive.
 I suppose if extra syntax is added, what about something closer to what is already present for skipping HTML escaping?

``` html
<input#foo class=${a: true, b: false} pattern=!"[\w0-9]">
```

It has the bonus of being _almost_ like a CSS attribute selector.
 My point is "who knows?" Anyone can stick pretty much anything they want in a `data` attribute. And future spec graced attributes could have anything as well.

My use case is a simple fix on my end (other than remembering when I come back to the project in 6 months why there is an extra `\`). I just think that it would be wise to provide a template language specific method for dealing with such scenarios so that someone who knows the language can read the intention.
  [![Coverage Status](https://coveralls.io/builds/6522068/badge)](https://coveralls.io/builds/6522068)

Coverage increased (+0.003%) to 83.434% when pulling **5c7eb271dc376e2393752110014e1ae243abcdea on mlrawlings:asyncfragment-info** into **06f6e37fdc0ed18d1684b779a01c06f87026ed9c on marko-js:master**.
  I was running karma + PhantomJS on some Marko Widgets with async-fragments, I got the following error:

```
Running "karma:test" (karma) task
     Saving optimization output to: ./.test/static
START:
PhantomJS 2.1.1 (Mac OS X 0.0.0) ERROR
  SyntaxError: Unexpected token '>'
  at /Users/isuhardi/works/feproject/.test/static/index/marko$3.4.4/taglibs/async/async-fragment-tag-transformer.js:28
```

This is due to arrow syntax at async-fragment-tag-transformer, which PhantomJS cannot run due to lack of ES6 support.
  Nice PR @mlrawlings! Did you consider using `--include-all-sources` in the istanbul command for  coverage against the whole codebase?
  Ideally, all our errors in generating code would be developer friendly and added through `context.addError`, however, not every case is covered currently.  

This pull request catches errors from code generators, adds context about the node (including line number in the template when available), and rethrows the error while maintaining the original stack trace.

In the ideal case it looks something like this:

```
Error: Something Happened! -- Generating code for <custom-tag> tag (test/autotests/render/error-thrown-in-generator/template.marko:2:4)
```

Even in cases where we don't have the line number, you at least have a better idea of what might be causing the error.  The following is what the error @seangates encountered earlier would have looked like:

```
Error: 
Unexpected token ): (+)
                      ^ -- Generating code for <assign> tag
```

_Note: I'm actually not quite sure why the node doesn't have the line number attached in this case - I may look into this at a later point in time._

For non-html nodes, the type of node is listed (and will list line number if available):

```
Error: some error message -- Generating code for ForEach node
```
 @mlrawlings Wonderful! Thanks!
  I'm probably doing something really stupid but with the following code I can't get Marko to recompile the template when I make a change directly to the template file. Can anyone tell me what mistake I'm making?

```
'use strict';
process.env.MARKO_CLEAN = true;
require('marko/node-require').install();

require('marko/compiler').defaultOptions.checkUpToDate = true;
require('marko/compiler').defaultOptions.writeToDisk = true;
require('marko/compiler').defaultOptions.preserveWhitespace = true;
require('marko/compiler').defaultOptions.assumeUpToDate = false;

const Hapi = require('hapi');
const server = new Hapi.Server();

server.connection({ port: 4000 });

server.start((err) => {
    if (err) {
        throw err;
    }
    console.log('Server running at:', server.info.uri);
});

server.route({
    method: 'GET',
    path: '/',
    handler: function (request, reply) {
        var template = require('./template.marko');

        console.log('Render Template');
        template.render({ name: 'Frank', count: 30 }, function(err, output) {
                if (err) {
                    console.error('Rendering failed');
                    return;
                }

                return reply(output);
            }
        );
    }
});
```
 @patrick-steele-idem perfect! Thanks a ton, I knew I had to be missing something. I'm not sure how I missed the hot-reload options.
   @patrick-steele-idem @mlrawlings - Pls review, if this change makes sense.
    I'm adding some more detail to this, mostly so I don't forget: The issue is seen in v2, not sure if it is also an issue in v3.

The template that calls `<include template="./deferred.marko" template-data="data" />` is being rendered **client side**.  The widget **is** registered, but for the first render it does not call any of the [rendering methods](http://markojs.com/docs/marko-widgets/component-lifecycle/#rendering-methods), nor is the state properly set.  We can access the widget through `element.__widget`, and calling `setStateDirty()` does cause a re-render in which the rendering methods **are** called, but then the widget (which gets its contents from state) is empty because the state is not set from the first render.
    Hi,
I am using Marko v3 and facing the following issue.

An error occurred while trying to compile template at path "D:\Projects\Test\Test\views\admin\Dashboard.marko". Error(s) in template: 1) [views\admin\Dashboard.marko:1:25] Invalid string ("./browser.json"/>): SyntaxError: Unexpected token / in JSON at position 16 

```
Error: An error occurred while trying to compile template at path "D:\Projects\Test\Test\views\admin\Dashboard.marko". Error(s) in template:
1) [views\admin\Dashboard.marko:1:25] Invalid string ("./browser.json"/>): SyntaxError: Unexpected token / in JSON at position 16

    at Compiler.compile (D:\Projects\Test\Test\node_modules\marko\compiler\Compiler.js:124:25)
    at Object.compileFile (D:\Projects\Test\Test\node_modules\marko\compiler\index.js:91:25)
    at loadFile (D:\Projects\Test\Test\node_modules\marko\runtime\loader.js:116:34)
    at load (D:\Projects\Test\Test\node_modules\marko\runtime\loader.js:157:16)
    at Object.load (D:\Projects\Test\Test\node_modules\marko\runtime\marko-runtime.js:296:33)
    at exports.DashboardPage (D:\Projects\Test\Test\controllers\admin\Dashboard.js:2:26)
    at Layer.handle [as handle_request] (D:\Projects\Test\Test\node_modules\express\lib\router\layer.js:82:5)
    at next (D:\Projects\Test\Test\node_modules\express\lib\router\route.js:100:13)
    at Route.dispatch (D:\Projects\Test\Test\node_modules\express\lib\router\route.js:81:3)
    at Layer.handle [as handle_request] (D:\Projects\Test\Test\node_modules\express\lib\router\layer.js:82:5)
```

My template is as below

``` xml
<lasso-page package-path="./browser.json"/>
<!DOCTYPE html>
<html ng-app="MyPortal" lang="en">
  <head>
    <title>${data.title}</title>
    <meta charset="UTF-8" />
    <meta content='width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no' name='viewport'/>      
    <link href="${data.CDNUrl}/stylesheets/style.css" rel="stylesheet" type="text/css" />
    <lasso-head/>
  </head>
  <body >
    <div style="border:1px solid;border-color:#595959;width:100%;height:100%;">
      <table style="width:100%;height:100%;border:0px solid;border-collapse:collapse">
        <tr>
          <td style="height:120px;margin:0;padding:0px">
            <table style="width:100%;border:0px solid;border-collapse:collapse">
              <tr style="height:80px;background-color:#e9eaed">
                <td>
                  <a href="/">
                    <img src="${data.CDNUrl}/images/Logo.png" alt="" />
                  </a>
                </td>
              </tr>
              <tr style="height:40px;background-color:#333">
                <td>
                  <a class="link" href="/Admin/Dashboard">Dashboard</a>
                </td>
              </tr>
            </table>
          </td>
        </tr>
        <tr>
          <td style="background-color:white;margin:0;padding:0px">

          </td>
        </tr>
        <tr>
          <td style="height:50px;margin:0;padding:0px">

          </td>
        </tr>
      </table>
    </div>
    <lasso-body/>
    <init-widgets/>
    <browser-refresh/>
  </body>
</html>
```

Can you tell me what is the wrong with the template?
 Hi @sanjeevashrivastava, is it possible that the JSON in your `browser.json` file is malformed?
 content of browser.json is as below

{
    "dependencies": [
        "style.css"
    ]
}
 I am using htmljs-parser@1.5.12
 I am not using npm-strinkwrap.json
 at position 16 / is in `<lasso-page package-path="./browser.json"/>` of package-path attribute
 i also noticed that if template is in views folder then it is working and if this template is in views/admin folder then it is throwing this error
 If I put space after second " in `<lasso-page package-path="./browser.json" />` it is throwing following error

Lasso page result not found for slot "head". The <lasso-page> tag should be used to lasso the page.

Error: Lasso page result not found for slot "head". The <lasso-page> tag should be used to lasso the page.
    at render (D:\Projects\Test\Test\node_modules\lasso\taglib\slot-tag.js:51:15)
    at render (D:\Projects\Test\Test\node_modules\lasso\taglib\head-tag.js:10:5)
    at render (D:\Projects\Test\Test\views\admin\Dashboard.marko.js:20:5)
    at Object.Template.render (D:\Projects\Test\Test\node_modules\marko\runtime\marko-runtime.js:193:9)
    at exports.DashboardPage (D:\Projects\Test\Test\controllers\admin\Dashboard.js:4:14)
    at Layer.handle [as handle_request](D:ProjectsTestTestnode_modulesexpresslibrouterlayer.js:82:5)
    at next (D:\Projects\Test\Test\node_modules\express\lib\router\route.js:100:13)
    at Route.dispatch (D:\Projects\Test\Test\node_modules\express\lib\router\route.js:81:3)
    at Layer.handle [as handle_request](D:ProjectsTestTestnode_modulesexpresslibrouterlayer.js:82:5)
    at D:\Projects\Test\Test\node_modules\express\lib\router\index.js:234:24

and FYI I am using lasso@2.3.4
and using same browser.json in admin folder
 [Dashboard.marko.txt](https://github.com/marko-js/marko/files/254175/Dashboard.marko.txt)
[Home.marko.txt](https://github.com/marko-js/marko/files/254176/Home.marko.txt)

if you go with above files. both files are same but Home.marko is not working while Dashboard.marko works fine.
 [Home.marko.txt](https://github.com/marko-js/marko/files/255408/Home.marko.txt)

I have tried htmljs-parser separately using the following code with attached file. it is throwing same error.

```
var parser = require('htmljs-parser').createParser({
    onText: function (event) {
        // Text within an HTML element
        var value = event.value;
    },

    onPlaceholder: function (event) {
        //  ${<value>]} // escape = true
        // $!{<value>]} // escape = false
        var value = event.value; // String
        var escaped = event.escaped; // boolean
        var withinBody = event.withinBody; // boolean
        var withinAttribute = event.withinAttribute; // boolean
        var withinString = event.withinString; // boolean
        var withinOpenTag = event.withinOpenTag; // boolean
        var pos = event.pos; // Integer
    },

    onCDATA: function (event) {
        // <![CDATA[<value>]]>
        var value = event.value; // String
        var pos = event.pos; // Integer
    },

    onOpenTag: function (event) {
        var tagName = event.tagName; // String
        var attributes = event.attributes; // Array
        var argument = event.argument; // Object
        var pos = event.pos; // Integer
    },

    onCloseTag: function (event) {
        // close tag
        var tagName = event.tagName; // String
        var pos = event.pos; // Integer
    },

    onDocumentType: function (event) {
        // Document Type/DTD
        // <!<value>>
        // Example: <!DOCTYPE html>
        var value = event.value; // String
        var pos = event.pos; // Integer
    },

    onDeclaration: function (event) {
        // Declaration
        // <?<value>?>
        // Example: <?xml version="1.0" encoding="UTF-8" ?>
        var value = event.value; // String
        var pos = event.pos; // Integer
    },

    onComment: function (event) {
        // Text within XML comment
        var value = event.value; // String
        var pos = event.pos; // Integer
    },

    onScriptlet: function (event) {
        // Text within <% %>
        var value = event.value; // String
        var pos = event.pos; // Integer
    },

    onError: function (event) {
        // Error
        var message = event.message; // String
        var code = event.code; // String
        var pos = event.pos; // Integer
    }
});
var fs = require('fs');

fs.readFile('./views/Home.marko', 'utf8', function (err, contents) {
    parser.parse(contents);
});
```

So it is confirmed that the issue is in htmljs-parser. Please try to debug it. FYI I am using Windows OS.
 Thank you very much. New version htmljs-parser@1.5.13 fixed the issue.
  Hi! After upgrade nodemon, node and migrating from marko 2.x to 3.x version i getting next problem:
**Node.js version: 6.0.0**

```
npm start

Appname@1.3.0 start /home/baddad/Projects/Appname
NODE_ENV=development nodemon app.js -e js,marko,json --trace-sync-io --verbose

[nodemon] 1.9.2
[nodemon] to restart at any time, enter rs
[nodemon] ignoring: .git .nyc_output .sass-cache bower_components coverage /home/baddad/Projects/Appname/node_modules/\*/
[nodemon] watching: .
[nodemon] watching extensions: js,marko,json
[nodemon] starting node app.js --trace-sync-io
[nodemon] child pid: 20375
[nodemon] watching 2,134 files
[nodemon] files triggering change check: application/frontend/home/home.marko.js
[nodemon] matched rule: \*\/.\*
[nodemon] changes after filters (before/after): 1/1
[nodemon] restarting due to changes...
[nodemon] application/frontend/home/home.marko.js

[nodemon] starting node app.js --trace-sync-io
[nodemon] child pid: 20383
[nodemon] files triggering change check: application/frontend/home/home.marko.js
[nodemon] matched rule: \*/.\*
[nodemon] changes after filters (before/after): 1/1
[nodemon] restarting due to changes...
[nodemon] application/frontend/home/home.marko.js

[nodemon] starting node app.js --trace-sync-io
[nodemon] child pid: 20391
[nodemon] files triggering change check: application/frontend/home/home.marko.js
[nodemon] matched rule: \*/.\*
[nodemon] changes after filters (before/after): 1/1
[nodemon] restarting due to changes...
[nodemon] application/frontend/home/home.marko.js

[nodemon] starting node app.js --trace-sync-io
[nodemon] child pid: 20399
[nodemon] files triggering change check: application/frontend/home/home.marko.js
[nodemon] matched rule: \*/.\*
[nodemon] changes after filters (before/after): 1/1
[nodemon] restarting due to changes...
[nodemon] application/frontend/home/home.marko.js
```
 @patrick-steele-idem Thanks you very much! All works fine :) :+1: But in previous version(2.x) i did not see this problem.
  Adds a submodule (`marko/express`) that provides an `injectInto` method that will add a `marko` method to the express response prototype.  We get access to express locals, and it automatically sets the content type of the request.
 This latest update removes the need to pass `express` to the submodule.  It is required from the parent module's context.  Test coverage has been increased as well.
  We need a way to disable `client-reorder` on all `<async-fragment>` tags.  This will be useful when serving content to bots/crawlers and users that might have js disabled.
  the if="conditional" attribute syntax is deprecated in v3
  #281 
  Hi,

I have a project where part of the content is inserted on a database using a CMS. That content sometimes have paragraphs. I tried to replace `\\n` (and others) with `<br>`, but then Marko replaces the `<` whit `&lt;` for security reasons I guess. How can I avoid that at least with some tags?
 For example:

**_data_**

``` json
{
    "name": "<br>Markojs"
}
```

**_marko template hello.marko_**

``` html
- Hello ${data.name}!
<span>Other text</span>
```

**_output html_**

```
Hello &lt;br>Markojs! <span>Other text</span>
```

> Hello &lt;br>Markojs! Other text

By default, all special HTML characters will be escaped in dynamic text to prevent Cross-site Scripting (XSS) Attacks. To disable HTML escaping, you can use $! as shown in the following sample code:
**_data_**

``` json
{
    "name": "<br>Markojs"
}
```

**_marko template hello.marko_**

``` html
- Hello $!{data.name}!
<span>Other text</span>
```

**_output html_**

```
Hello
<br>Markojs! <span>Other text</span>
```

> Hello
> Markojs! Other text

Ref: [Language Guide // Marko](http://markojs.com/docs/marko/language-guide/#text-replacement)
 Thanks a lot, I remembered to have read it somewhere but I couldn't find it.
  Adding some files to npmignore which are not required to be published to npm registry
  I am using Jade doc as a reference at the moment, they suggest using html tag directly for inline tags, does marko recommend the same strategy or does it have a better solution? eg.

```
p - hello there, <strong>username</strong>.
```

A demo on http://markojs.com/try-online/ would help. Currently the only demo with inline tags are using macro. I think it's an overkill to do this with macro.
 Ah interesting, so whitespace demo does sort of address my question, not quite sure what `---` stands for though.

http://markojs.com/try-online/#Whitespace_Simple
 Closing this as the answer is:

```
p
  - hello there,
  strong - username
  - .
```
  @patrick-steele-idem - Note, the error is misleading, as I just modified the existing template, however the hot reloader module, somehow looks for new compiled templates.

`Error: ENOENT: no such file or directory, open '/Users/prashjain/projects/xonyx/node_modules/lasso/head-116-3-26-29630-12vpaz3.marko'
   at Error (native)
   at Object.fs.openSync (fs.js:549:18)
   at Object.fs.readFileSync (fs.js:397:15)
   at loadFile (/Users/prashjain/projects/xonyx/node_modules/marko/runtime/loader.js:82:23)
   at load (/Users/prashjain/projects/xonyx/node_modules/marko/runtime/loader.js:124:16)
   at Object.load (/Users/prashjain/projects/xonyx/node_modules/marko/runtime/marko-runtime.js:295:33)
   at Object.marko.load (/Users/prashjain/projects/xonyx/index.js:21:18)
   at Object.Template.(anonymous function) [as renderSync] (/Users/prashjain/projects/xonyx/node_modules/marko/hot-reload/index.js:67:48)
   at Object.LassoPageResult.getHtmlForSlot (/Users/prashjain/projects/xonyx/node_modules/lasso/lib/LassoPageResult.js:111:25)
   at Object.LassoPageResult.getSlotHtml (/Users/prashjain/projects/xonyx/node_modules/lasso/lib/LassoPageResult.js:150:21)
   at renderSlot (/Users/prashjain/projects/xonyx/node_modules/lasso/taglib/slot-tag.js:35:36)
   at render (/Users/prashjain/projects/xonyx/node_modules/lasso/taglib/slot-tag.js:57:9)
   at render (/Users/prashjain/projects/xonyx/node_modules/lasso/taglib/head-tag.js:9:5)
   at module.exports.t (/Users/prashjain/projects/xonyx/node_modules/marko/runtime/helpers.js:284:13)
   at render (/Users/prashjain/projects/xonyx/src/pres/layouts/ryp/desktop/ryp-layout.marko.js:44:5)
   at Object.Template.render (/Users/prashjain/projects/xonyx/node_modules/marko/runtime/marko-runtime.js:192:9)
   at Object.Template.(anonymous function) [as render] (/Users/prashjain/projects/xonyx/node_modules/marko/hot-reload/index.js:72:34)
   at render (/Users/prashjain/projects/xonyx/node_modules/marko/node_modules/marko-layout/use-tag.js:14:20)
   at module.exports.t (/Users/prashjain/projects/xonyx/node_modules/marko/runtime/helpers.js:284:13)
   at render (/Users/prashjain/projects/xonyx/src/pres/pages/ryp/desktop/ryp-page.marko.js:40:5)
   at Object.Template.render (/Users/prashjain/projects/xonyx/node_modules/marko/runtime/marko-runtime.js:192:9)
   at Object.Template.(anonymous function) [as render] (/Users/prashjain/projects/xonyx/node_modules/marko/hot-reload/index.js:72:34)
`
  It's now out as "stable," and will be the LTS release come October. So here's a fun one:

``` bash
% npm test                                                                                                           

> marko@3.0.2 test /Users/jsumners/Projects/marko
> npm run init-tests && node_modules/.bin/mocha --ui bdd --reporter spec ./test && node_modules/.bin/jshint compiler/ runtime/ taglibs/


> marko@3.0.2 init-tests /Users/jsumners/Projects/marko
> ./test/init-tests.sh

/Users/jsumners/Projects/marko/node_modules/property-handlers/lib/index.js:21
                throw cause;
                ^

Error: Error while handling properties for <assign> tag in /Users/jsumners/Projects/marko/taglibs/core/marko.json: Error while applying option of "code-generator". Cause: TypeError: Path must be a string. Received undefined
    at assertPath (path.js:7:11)
    at Object.dirname (path.js:1324:5)
    at /Users/jsumners/Projects/marko/node_modules/raptor-modules/resolver/lib/serverResolveRequire.js:27:65
    at Object.find (/Users/jsumners/Projects/marko/node_modules/raptor-modules/resolver/lib/search-path.js:14:31)
    at serverResolveRequire (/Users/jsumners/Projects/marko/node_modules/raptor-modules/resolver/lib/serverResolveRequire.js:18:29)
    at Object.TagHandlers.codeGenerator (/Users/jsumners/Projects/marko/compiler/taglib-loader/loader-tag.js:175:20)
    at invokeHandlers (/Users/jsumners/Projects/marko/node_modules/property-handlers/lib/index.js:66:29)
npm ERR! Test failed.  See above for more details.
```
  I've created a few prototypes:
- Core marko generator project [link](https://github.com/BryceEWatson/marko-js-generator)
- Atom marko generator project [link](https://github.com/BryceEWatson/marko-js-generator-atom)

Having a separate core project allows use to centralized set of layout templates for ui components, and later, entire projects. The core is generic and doesn't contain any logic related to atom, but contains the templates (see example [here](https://github.com/BryceEWatson/marko-js-generator/tree/master/templates/ui-component)) and the logic needed to copy them to any destination path.

The atom project contains all the logic needed to surface the proper menu items, etc, and has the core project as a dependency (not implemented yet, need to npm publish).

Curious what everyone thinks of this approach, I think the core library starts to allow us to branch into other frameworks like yeoman, sublime, etc.
 @patrick-steele-idem Good points. I agree that the prototype is too rigid in enforcing .less, etc. Maybe we could add an option (to both core & atom projects?) to save a new template directory. The option could be surfaced in the atom in the right click menu, allowing the user to right click a module and select "Save as template". I'm not sure how simple this would be in practice, as dynamic data for module name would need to be included.

Also, yes I avoided yeoman this time. The last time we went down the yeoman path it became very tightly coupled to the framework. It's worth exploring a generic solution that uses atom-yeoman instead of ejs.

I also like the generic Generator option. This goes beyond simple marko support, and might overlap with some existing solutions. Will need to research this further.

Thanks for the feedback!
 I think it would be nice to make something like https://github.com/dsandstrom/atom-double-tag and highlight of closing tags for marko.
 @patrick-steele-idem thank very much now i am happy like a child :) for this features even vodka is not enough! Also i see some colors in syntax highlighting are changed for example < > and now it's much better. Good job!
 Didn't find such issue for Visual Studio Code, do you have any plans for it?
 @mlrawlings oh no what did I `commit` to ;)
  The only item from that list that I've found myself actively missing is "click to go to tag definition" (i.e. jump to custom tag template file) but the others would be great too!
 Many fullstack engineers use IntelliJ, so such a plugin would definitely make sense.
 Autocompletion of `${data.something}` would be great. Hopefully the tag attributes would autocomplete layout elements.
 Yes please! Also a default widget component files generator via right-click would be nice.
 Any update on this?
 Official website lists Webstorm integration, but link points to textmate:

http://markojs.com/docs/editor-plugins/
 Given the complexity of implementing this, anyone interested in such a plugin should also login to JetBrains's issue tracker and vote for the issue https://youtrack.jetbrains.com/issue/WEB-20821 Done  I am not sure what is this supposed to be: http://markojs.com/docs/marko-widgets/get-started/#widget-state

in the `getTemplateData` function there is an assignment to nothing to `style`:

```
getTemplateData: function(state, input) {
        var style = ;

        return {
            name: state.name,
            color: state.selected ? 'yellow' : 'transparent'
        };
    },
```
 https://github.com/marko-js/marko-widgets/pull/132 done
  Would it be better if the macro file: `helpers.marko` could be included in other files ? `custom-taglibs` is a little complicate for the beginners, IMO.
 Cool, this is more easy to understand than the doc. Thanks a lot.
  Example:

`<mywidget w-preserve-attrs="style,class" />`

Will result in the template compiler throwing the following error:

``` javascript
/webapp/node_modules/lasso/lib/dependency-walker.js dependency.getPackageManifest failed: Error: An error occurred while trying to compile template at path "/webapp/src/code/components/cover-profile/index.marko". Error(s) in template:
1) [src/code/components/cover-profile/index.marko:25:8] Unsupported attribute of "data-w-preserve-attrs" found on the <tinput> custom tag.

    at Compiler.compile (/webapp/node_modules/marko/compiler/Compiler.js:124:25)
    at /webapp/node_modules/marko/compiler/index.js:84:41
    at tryToString (fs.js:414:3)
    at FSReqWrap.readFileAfterClose [as oncomplete] (fs.js:401:12)
```
  This is my template:

```
<!DOCTYPE html>
    <html lang="en"> 
        <head>
            <title>Estimake.co</title>
            <include template="./partials/includes.marko" />
            <link rel="stylesheet" type="text/css" href="editProject.css">
            <script src="editProject.js" type="text/javascript"></script>
        </head>
        <body>
            <include("./partials/menu.marko", data)/>
            <include("./partials/footer.marko")/>
        </body>
    </html>
```

This is what I am getting when the template is rendered in v3.

`<Ôªø<!DOCTYPE html>><html lang="en"> <head> <title>Estimake.co</title> ... </body> </html></Ôªø<!DOCTYPE>`

Any idea why I have the 'strangeness' with the DOCTYPE?
 Ok, thanks. I tried yours and got the same issue 

'<Ôªø<!DOCTYPE html>></Ôªø<!DOCTYPE><html lang="en">'

but there must be something wrong with my installation, because apparently the original file should not have even compiled.

I take it from your answer that with 3.0 indention is now significant like with the Jade engine even with the HTML approach?
 Let me play around with my installation first. I won't to make sure I am not doing something stupid before I bug you about it. I am not sure how the first template compiled given the error in indention.

Thanks for your quick response.
    Howto reproduce:
1. Open the online "try-out" "Simple" example at http://markojs.com/try-online/ 
2. Modify the line 3rd line to add an attribute
`<li data-bind="\$foo" for(color in data.colors)>`
3. The expected output for the above is `<li data-bind="$foo">` but instead a syntax error occurs.

It works if the dollar-sign isn't escaped at all.
`<li data-bind="$foo" for(color in data.colors)>`

In marko-js pre v3 this worked as expected...
 Worth to mention is that the migration tool translates attr="\$foo" into attr="\$foo" which is not what is expected... 
 The migration script translates \$foo into double \ $foo

Since I'm using knockout js some special variables need to be prefixed with $, luke $parent and such. In this case the output needs to be attr="$parent" without any \
 Great, I will try it out in a couple of days!
 Thanks, the solution worked!
  when using the `require('marko').install()` the compiled files seem to cut the .marko extension from all require.resolve() calls.

When i have compiled using `$ markoc master.marko` my output contains:

```
navigation_template = loadTemplate(require.resolve("./components/navigation/template.marko"));
```

but when i have installed the node-require module, and simply required the template with 
`require('./src/master.marko')` the same line is:

```
navigation_template = loadTemplate(require.resolve("./components/navigation/template"));
```
 Sweet. As soon as that work as expected i think i have a functioning pull
request for markoify.

On 11 April 2016 at 16:41, Patrick Steele-Idem notifications@github.com
wrote:

> Thanks for reporting the problem. I'm looking into it.
> 
> ‚Äî
> You are receiving this because you authored the thread.
> Reply to this email directly or view it on GitHub
> https://github.com/marko-js/marko/issues/262#issuecomment-208379670
 Ok, i will see if i can recreate it again.

On 11 April 2016 at 17:37, Patrick Steele-Idem notifications@github.com
wrote:

> @lohfu https://github.com/lohfu I was not able to reproduce the problem
> using a fresh npm install. I tried to recreate your setup and the
> template is compiling as expected:
> 
> function create(__helpers) {
>   var str = __helpers.s,
>       empty = __helpers.e,
>       notEmpty = __helpers.ne,
>       escapeXml = __helpers.x,
>       loadTemplate = __helpers.l,
>       navigation_template = loadTemplate(require.resolve("./components/navigation/template.marko"));
> 
>   return function render(data, out) {
>     navigation_template.render({}, out);
>   };
> }
> 
> (module.exports = require("marko").c(__filename)).c(create);
> 
> ‚Äî
> You are receiving this because you were mentioned.
> Reply to this email directly or view it on GitHub
> https://github.com/marko-js/marko/issues/262#issuecomment-208405916
 Hey Patrick,

Yes i was. I created a repository at https://github.com/lohfu/marko-test.
Simply running `node server/server.js` will create a master.marko.js with

```
navigation_template =
loadTemplate(require.resolve("./components/navigation/template")),
```

On 17 April 2016 at 00:08, Patrick Steele-Idem notifications@github.com
wrote:

> Hey @lohfu https://github.com/lohfu, just wanted to check in and see if
> you were able to reproduce. Thanks.
> 
> ‚Äî
> You are receiving this because you were mentioned.
> Reply to this email directly or view it on GitHub
> https://github.com/marko-js/marko/issues/262#issuecomment-210913456
  - Added ability to exclude specific node_module from marko-taglib.json lookup;
- Added tests for excluding specific directory and specific node_modules from marko-taglib.json lookup;
  Steps to reproduce
1. `require('marko/compiler').defaultOptions.writeToDisk = false;`
2. `require('marko/node-require').install();`
3. Create a custom tag that includes an instance of itself.

```
<li class=[data.page.name, data.currentPage.path === data.page.path && 'current']>
    <a href="${data.page.path}"><span>${data.page.title}</span></a>

    <if(data.page.pages)>
        <ul>
            <for(page in data.page.pages)>
                <navigation-item({ page: page, currentPage: data.currentPage })></navigation-item>
            </for>
        </ul>
    </if>
</li>
```
  I'm trying to do something very simple but I can't seem to get it to work. I have a basic template like this...

`<div>
   <customTag></customTag>
</div>`

And in custom tag's template I include another custom tag...

`<div>
    <customTag2></customTag2>
</div>`

And then finally, customTag2's template simply renders.

`I'm custom tag 2`

When I render all this, I end up with 

`<div>
   <div>
      <customTag2></customTag2>
   </div>
</div>`

It never renders customTag2. And I know the tag lib is found becuase if I go to my main template and include both custom tags, they both render, but not if they are nested. 

Am I doing something wrong? Or is including one custom tag in another's template not supported? Do I have to do the Parent/Child thing? I'd rather not since the child tag is intended to be used in many places.
 Sure, it's a pretty simple set-up.
- tags
  - customTag1
    - template.marko
  - customTag2
    - template.marko
- template
  - mainTemplate.marko
- Index.js
- marko.json

Here, the index file is rendering the ./template/mainTemplate.marko. The marko.json is as follows

`{
    "tags-dir": "./tags/"
}`
 No, sorry that's just my bad typing here. I fixed the above example.

It is strange because as I said, if I include both custom tags in the root template, they both render, it's only if one is nested inside the other that the inner template does not render.
 You are right, that works. It must be something with my set-up. I'll close this for now, since it is possible to do it, and I'll try to figure out where I messed up. :) Thanks for all the help!
   I feel there is not enough awareness out in the community about Markojs, nor is there a curated list of examples, articles, and good libraries from around the net. May there should be one ...
 I agree with this. For example, I think it would be really cool if there was an article showing how eBay leverages Marko for their main site 
 Since I suggested this, I really should join in the fun; I will be submitting libs, components, etc as I make them over the next couple of weeks. I will do my best to get some articles out about Markjs on my Medium blog.
 love it, will commit something when you define a format
 +1 I have been looking for UI kits such as vuematerial.github.io, vuetifyjs.com for marko but haven't found any so far. An awesome-marko repo would be very helpful to group all available resources under one page  In some of the custom elements I've written, I want to use different root elements based on the context. I want to put `w-bind` on these root elements. The content inside these root elements is the same across variations and I would like to use a macro to avoid repetition. However, when I try to use `w-body` in the macro, I get an error saying that w-body can only be used inside a element with w-bind. This prohibits my ability to use a macro to render the content.

What is the best way to pass a rendered body to the macro?
 Thanks for the suggestion. I'll try it.
 @mlrawlings I tried the technique you suggested and the element renders correctly. However, the new element is not bound. 

With this template:

```
<${data.tag} class=data.classes w-bind >
  <div class="content">
    <invoke data.renderBody(out) />
    <div class="sub header" if(data.subheader)>${data.subheader}</div>
  </div>
</>
```

I get:

```
<h2 class="ui-heading" w-bind>
<div class="content">My Header</div>
</h2>
```

And when I use `w-body` instead of `<invoke data.renderBody(out) />` I still get a compile error complaining about w-body without w-bind.

Let me know if I missed something that enabled the suggestion to work.
 Works like a charm. Thanks!
  I just migrated to v3 and now only custom taglibs in the same directory as the page are resolved.

Here's a sample of the directory structure:

```
root
   package.json
   marko.json
   node_modules
   plugins
      components
         my-hello
             template.marko
      pages
         test
            page.marko
```

`marko.json` has:

```
{
  "tags-dir": [
    "./plugins/components"
  ]
}
```

I can get the `my-hello` custom tag to render in `page.marko` only when it and marko.json are located in `/plugins/pages/test`.

I believe related to this issue, `<init-widgets/>` and `<browser-refresh/>` don't render either. They appear as tags in the outputted page. 

It was my understanding that marko would walk up the directory tree from the page to the project's root looking for marko.json. Once found, it would use marko.json to pull in any custom tag definitions. I'm not sure what changed with v3.
 Walking up the directory tree from plugins/pages/test, I only have package.json at the root. Some of the other plugins have a package.json file but they are not parents of the test page. 

Did this behavior change between v2 and v3? I ask because in the v2 version of the repo I‚Äôm working on I have a page directory with a package.json and everything is working fine.

From:  Patrick Steele-Idem notifications@github.com
Reply-To:  marko-js/marko reply@reply.github.com
Date:  Sunday, March 20, 2016 at 1:40 PM
To:  marko-js/marko marko@noreply.github.com
Cc:  Todd Bashor tbashor@gmail.com
Subject:  Re: [marko] Custom taglibs not found after migrating to v3 (#252)

@tbashor by any chance, do you have any intermediate package.json files? The taglib finder stops when it gets to the "root" of the package? The root of the package is determined by looking for a package.json file with a "name" property. I suspect that the search for taglibs is being ended prematurely due to the root directory not being as expected. FYI, here is the code that is used to discover taglibs for marko: https://github.com/marko-js/marko/blob/master/compiler/taglib-finder/index.js

Please let me know if that is the case. Thanks.

‚Äî
You are receiving this because you were mentioned.
Reply to this email directly or view it on GitHub
 @patrick-steele-idem You were right that there was a package.json stopping the lookup. I'm still having trouble getting the lasso tags to resolve, but I think that has to do with my particular setup. Thanks for your help.
  Currently rendering a template returns an `AsyncWriter`, it would be handy though if when a callback is omitted that templates render function returned a promise.

``` js
var template = require("template.marko");

template.render({ hello: "world" })
    .then(function (html) { ... })
    .catch(function (err) { ... });
```

If you're using promises already it makes using marko a bit easier.
 You can use temporarily **bluebird** module.

```
let Promise = require('bluebird');
let EntryCommentsMarkup = require('./views/EntryComments.marko');
Promise.promisifyAll(EntryCommentsMarkup);
```

then in routing we invoke **renderAsync** method:

```
app.get('/example', function(req, res) {
    let Data = { ... };
    return EntryCommentsMarkup.renderAsync(Data)
        .then((markup) => res.status(200).json({ markup: markup }))
        .catch((error) => res.status(400).json({ message: error.message }));
});
```
 A bit late, just throwing this out there: The Promises/A+ specification requires that if the result is an `object` or `function` with a `then` method, it _must_ be treated as a "thenable". In other words, this solution is explicitly permitted by the specification, and any `Promise` library which doesn't handle this correctly is - by definition - "broken". That's all, carry on. :)
  This pull request fixes a case wherein if `renderSync` receives no context then it will still render the template. Currently, if you don't supply at least an empty object (`{}`) then `renderSync` bombs with an error like:

```
Debug: internal, implementation, error 
    TypeError: Uncaught error: Cannot read property '$global' of undefined
    at Object.Template.renderSync (/some/project/node_modules/marko/runtime/marko-runtime.js:109:17)
    ....
```
 Excellent. Thank you.
  I am building a reusable component "data grid" using marko templates.

The component renders set of passed data in html `<table>`. The component internally supports couple of cell renderers which injects content inside `<td>`.
1. Text - for displaying paragraph of text/ list of links
2. Image - for displaying an image

I would also like to allow clients to configure custom cell renderers if you they choose to implement something on their own.

I don't see a way to invoke templates dynamically. As expected `<include>`  directly invokes the template and don't execute the renderer.

Am I missing something?

 **P.S:** I am using marko-v2 and this component is server side rendered.
 :+1: 

Thanks @patrick-steele-idem.
 üëç Looking forward to Marko v4.
  `<invoke console.log(someData)/>`

This is good, but it could be much better. :smile: 

Some thoughts on creating a debugger:
- Pretty printing to the browser
- Additional information about the data (object type, length of the data)
- processing time
- the template path in which the debugger it's called
- limiting the debugger to only show in non-prod environments (don't know if this is possible, but ... would be nice)
- etc.
 I've seen at least a few other major projects add HTML comments like that to their output for various reasons, including debugging. Angular even uses a similar syntax to bind code to the DOM (`<!-- ngRepeat: post in posts -->`). On the other hand, element attributes might provide some benefits that comments couldn't, especially within the parser/compiler/renderer, as they would be assigned directly to the relevant AST nodes - though the idea of using element attributes (which are usually supposed to affect something) to display debug information (which is never supposed to affect anything) is a bit unnerving.

What about something in-between? Throughout the parsing/compiling/rendering process the debug information could be stored in a property on the relevant AST node - or _maybe_ in a parent node similar to an HtmlComment element, or perhaps even some combination of the two - then eventually rendered as HTML comments like in the example above. Then tools could be written to simply hook into the property/node to extract debug information during the compiling and rendering processes, and there would also be helpful HTML comments in the final output.

Special debugging tags and attributes could also be added, like `debug=true` to toggle verbose debugging on specific element trees, `debug-render-time` to track and report how long nodes take to render, and _maybe_ even something like `<observe(someData)>` to watch an object for changes, just to name a few. If all of this was handled by the special debug property/node, and only when some special flag (like `DEBUG=marko` or `--debug`) is detected, I would think this could be implemented without too many side effects. Thoughts?
  # Example

## Install hapi and marko

```
[sudo] npm install hapi --save
[sudo] npm install marko --save
```

## _directory structure:_

```
‚îú‚îÄ‚îÄ hapi-marko/
‚îÇ   ‚îú‚îÄ‚îÄ public/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ assets/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ css/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ js/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ img/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ resources/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ errors/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ     ‚îú‚îÄ‚îÄ 404.marko
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ partials/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ     ‚îú‚îÄ‚îÄ aside.marko
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ     ‚îú‚îÄ‚îÄ footer.marko
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ     ‚îú‚îÄ‚îÄ header.marko
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ template/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ     ‚îú‚îÄ‚îÄ master.marko
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ index.marko
‚îÇ   ‚îú‚îÄ‚îÄ index.js
‚îÇ   ‚îú‚îÄ‚îÄ package.json
‚îÇ   ‚îú‚îÄ‚îÄ README.md

/public/assets
Web resources that are publicly available (css, js, img, fonts)

/public/resouces
Server and browser-side templates

index.js
Application entry point
```

## Server side rendering

**_index.js_**

``` js
const Hapi = require('hapi'); 
// The following line installs the Node.js require extension
// for '.marko' files. Once installed, '*.marko' files can be
// required just like any other JavaScript modules. 
require('marko/node-require').install();

// If true(the default)then compiled templates will be written to disk. If false,
// compiled templates will not be written to disk (i.e., no '.marko.js' file will
// be generated)
require('marko/compiler').defaultOptions.writeToDisk = false;

const server = new Hapi.Server();
server.connection();

//Load template
const index = require('./public/resources/index.marko');

server.route({
    method: 'GET',
    path: '/',
    handler: function (request, reply) {

        index.render({'message': 'hello world!'}, reply);
    }
});

server.start( () => {
    console.log('Running at:' + server.info.uri);
});
```

**_index.marko_**

``` html
<layout-use template="./template/master.marko" show-header="$true">
    <layout-put into="content">
       <div >${data.message}</div>
       or
       <div >$data.message</div>
    </layout-put>
</layout-use>
```

**_master.marko_**

``` html
<!DOCTYPE html>
<html lang="es">
    <head>
    </head>
    <body>
        <div id="layout">
            <aside>
                <include template="../partials/aside.marko"/>
            </aside>
            <section class="section">
                <layout-placeholder name="content" />
            </section>
        <footer class="footer">
                <include template="../partials/footer.marko"/>
        </footer>
        </div>
    </body>
</html>
```

**_header.marko_**

``` html
<div>header content</div>
```

**_aside.marko_**

``` html
<div>aside content</div>
```

**_footer.marko_**

``` html
<div>footer content</div>
```

### execute

```
node index.js
```

### Open your browser and visit http://localhost:8000

#### gives the following output

```
aside content
hello world!
or
hello world!
footer content
```

### Clone the example

[example-hapi-marko](https://github.com/davidenq/example-hapi-marko)
 I'm agree. I'll work on a new tutorial. Have a great weekend!
 If you want to adjust the response type:

``` javascript
server.route({
    method: 'GET',
    path: '/',
    handler: function (request, reply) {

        reply(index.stream({'message': 'hello world!'})).type('text/html');
    }
});
```
 Both `.render` and `.stream` are very useful, However they are deprecated. Is it OK to still use them with hapi? Is there a better option?
 No, they aren't.

http://markojs.com/docs/marko/javascript-api/#streamtemplatedata--streamreadable
is not
http://markojs.com/docs/marko/javascript-api/#streamtemplatepath-templatedata--streamreadable
 FYI -> https://github.com/hapijs/vision/pull/111  `<marko-compiler-options>` shouldn't add a newline to rendered output because it's an option to the compiler, not part of the template at all. So it shouldn't cause any side-effect in the output.

I was about to submit a PR with a fix, but @patrick-steele-idem said in gitter:

> The marko compiler allows certain nodes/tags to be marked as "noOutput" so that they get ignored when applying whitespace removal rules. We probably just need to set that flag for the <marko-compiler-options> tag. We should add a test case to verify.

So that's a better solution. I was also trying to provide a PR for this, but i have no idea about how to do it.

I was about to add `el.noOutput = true;` below line 138 in [Parser.js](https://github.com/marko-js/marko/blob/master/compiler/Parser.js#L138), but i think the PR shouldn't/wouldn't be accepted like that.
  Somewhat related to #235, what do you think about defaulting to a template file without the name `template.marko` if it is the only one in that directory level?

Currently I avoid naming my templates `template.marko` because file navigation is much quicker if I name it after the component. So my component naming tends to have some duplication (`component.marko` `component.js` `component.less`) but allows me to easily jump to files without having to type `component/template.marko` in navigation commands.

However, I end up having to copy paste tons of `index.js` files like so:

``` js
'use strict';

var template = require('./component.marko');

module.exports = function render(input, out) {
    template.render(input, out);
};
```

It would be nice if marko could discover these automatically since it is the only template there anyway.
 Yep, that's exactly what I do. So in my case, matching the directory name would be enough. I actually only follow this convention for my own personal projects. For larger projects with more people, I follow the standard convention for the reasons you mentioned - while suffering through slower file navigation.

It's fairly simple to work around this, but I think it would be nice if marko was slightly less opinionated on file names. Looking for `template.marko`, then `dir-name.marko`, before finally looking through the templates in the directory, might be a nice way to optimize for the primary cases. I guess it depends how much magic we want vs. config.
 That's true on the first point. Since about half my components have renderers and half have templates, I set them all up as renderers for "consistency," although it could really go either way. 

When I used Atom, I did notice that the fuzzy autocomplete was pretty good. But for a bunch of other reasons, I've gone back to Webstorm for now. Webstorm isn't as good with directory matching and I would to type `full-directory-name/t` to get to the template.

Regarding the `js` naming - my own personal convention is to use marko defaults when needed on the server like `index.js` `renderer.js`, but to use component name for client side js - `component.js`. You're right that having a lot of index files is a bit awkward considering my other file names, but that's more part of node.js than Marko. This convention does help me differentiate server/client a bit better.

On the last point, I'm not sure. I think as long as Webstorm autocomplete stays the way it is, it is significantly faster for me to keep my current naming conventions. If I move back to Atom, then the point is moot. Sucks to make IDE-specific decisions, but I just really hate typing out long directory names, and the other benefits of Webstorm over Atom (in my opinion) keep me there.
 Wanted to add that in playing around with this some more, you do have to type the `/` but not the entire folder names in Webstorm. So it's not quite as bad. I still think some flexibility might be nice here regardless.
 I've since moved to generic file names in components (and haven't had any issues with quick navigation in VS Code). We can close this, unless you were still considering expanding auto-discovery.
  In one of my projects, I use `short` and `long` for property names in objects (I didn't realize these were technically reserved). It turns out that these fail in Marko v3 when used as `${data.short} and ${data.long}` in a template. It's worth noting that this is server-only since I'm not using marko widgets in this case.

Apparently, these two keywords, along with a host of others, are no longer reserved as of ES5. So if that's all it is I'm happy to submit a quick PR to update https://github.com/marko-js/marko/blob/master/compiler/util/javaScriptReservedWords.js to the ES5 list. Just wanted to check if there were any concerns in doing that, or if you prefer to keep pre-ES5 list.

If this is intentional (and that we're also intentionally disallowing property names as reserved keywords for IE8 support in case the template goes to the browser), maybe we should have an option to disable such behavior.
  For custom dynamic tags, I have a function using the `try-require` module that works as follows:

```
function loadRenderer(path) {
    var renderer = rendererCache[path];
    if (!renderer) {
        renderer = rendererCache[path] = tryRequire(path) || 'not-found';
    }
    return renderer;
}
```

I then use this to determine whether to require a renderer or a template:

```
    if (!isWidget && !widgetId) {
        module.type = 'renderer';
        module.renderer = loadRenderer(path.join(modulePath, 'renderer.js'));
        if (module.renderer === 'not-found') {
            module.template = loadRenderer(path.join(modulePath, 'template.marko'));
            module.type = 'template';
        }
    }
```

This works fine normally, but in functional tests through karma, it looks like the runtime is attempting to resolve `not-found` to a module. This results in the following error:

```
Cannot find module "not-found" from "/$/marko/runtime"
    require@.../.test/static/node_modules/lasso/node_modules/raptor-modules/client/lib/raptor-modules-client.js:568:52
    instanceRequire@.../.test/static/node_modules/lasso/node_modules/raptor-modules/client/lib/raptor-modules-client.js:113:75
    load@.../.test/static/node_modules/marko/runtime/loader_browser.js:21:19
    load@.../.test/static/node_modules/marko/runtime/marko-runtime.js:295:39
    l@.../.test/static/node_modules/marko/runtime/helpers.js:197:36

```

I tried setting renderer to a handful of other types based on the relevant marko code, but ran into different issues each time. Do you know how I could effectively make this a no-op? Or if there is a better way to achieve the same thing?
 I think you're right - and I think it's because of https://github.com/marko-js/marko-widgets/issues/130
Looks like I might need to artificially require everything that goes through `dynamic-tag`
  If you don't have an `index.js` file, it defaults to the template. But it should search for other possible renderers, such as a `index.coffee.js` file before defaulting to the template.
  Cool concept @patrick-steele-idem 

I think it greatly improves the expressiveness of Marko templates.
Love the idea that you can make a very generic template more 
specific by importing it into another template and giving it an alias!
So yeah, I would love to have them.

Just some thoughts:
1. Function wise, nothing is added - basically one could do the same
by simply using the name of the custom tag as it has been done until know (probably surrounded
by a `<if>` clause) - the dependencies would be resolved by lasso and the compiled 
code for both templates would be available in the client package...
The difference here is compile time; right? - anything else to differentiate (probably from a user perspective)?
2. Is there a specific reason not to use a syntax like:
`<import-tag componentA="component-a">`

Great concept!
 In my case I have 15 components which I want to call dynamically. When there were only a few components, just using `<if>` works fine. But with a large list, it becomes pretty tedious. I don't think this is too far out of an edge case, since we are encouraging the use of lots of small components.

So I ended up invoking renderers directly and then passing them through a `<dynamic-tag>` component, which cleans up the `marko` files quite a bit, but also leaves implementation to the user (handling templates, renderers, widgets without ids, widgets with ids, etc., all of which marko should already know how to do). But applying that case here, I'm not sure this new feature helps too much. It would mean 15 lines of importing components directly by name.

Can we ever resolve the tags later to be fully dynamic?

```
<import-tags "data.tags" as data.names>

<for each="name in names">
    <invoke-tag(name, { name: 'Frank', count: 30 })/>
</for>
```
 I think we could implement this and #172 with a similar syntax:

``` xml
<import(<tag-name> from './component')/>
```

Then just use it:

``` xml
<tag-name/>
```

And for es2015 style inputs (#172):

``` xml
<import({ dedupe } from './utils')/>
```

And they'd look slightly nicer without the argument parentheses:

``` xml
<import <tag-name> from './component'/>
<import { dedupe } from './utils'/>
```
 @philidem I've been playing with the parsing, from here it should be pretty trival to generate the necessary AST nodes: https://tonicdev.com/mlrawlings/573b709ca492941100e1140e
 As Yoni mentioned, the real value in this is to have something like:

``` html
<for(card in model.cards)>
  <${card.name} model=card />
</for>
```

I would think the name could be resolved and the component found from the `marko.json` file. Are there any major issues with that I'm missing?
  Awesome! :tada: 
  Hi all,

It seems that after a few different implementations of basic w-onClick, it does not work on mobile or tablet devices at all; the event/function attached to it simply does not fire at all. I'm not really sure what else to put here, other than to try it yourself and see the issue firsthand :+1: 
 This probably relates to how mobile browsers detect clickable elements. For example, iOS Safari has some quirks:
https://developer.apple.com/library/ios/documentation/AppleApplications/Reference/SafariWebContent/HandlingEvents/HandlingEvents.html
http://www.quirksmode.org/blog/archives/2014/02/mouse_event_bub.html

I wonder if marko-widgets should try to handle this at all.
 Related: https://github.com/facebook/react/issues/134
  It is my understanding that should be able to change the tagName of an element at the transform stage and have it trigger a code-generator/renderer at the generate stage, but this does not appear to be the case.  Am I doing something wrong? Is this expected behavior? A bug?

NOTE: This is on the lastest version of the `htmljs-parser` branch.
# Setup

_index.js_

``` javascript
require('marko/node-require').install();
require('./test.marko').stream().pipe(process.stdout);
```

_marko-tabglib.json_

``` json
{
    "<new>": {
        "code-generator":"./test-generator"
    },
    "<*>": {
        "transformer":"./test-transformer"
    }
}
```

_test-transformer.js_

``` javascript
module.exports = function transform(el, context) {
    console.log('CALLED TRANSFORM')
    if(el.tagName !== 'new') {
        if(el.getAttributeValue('transform')) {
            el.setTagName('new')
        }
    }
}
```

_test-generator.js_

``` javascript
module.exports = function codeGenerator(el, codegen) {
    console.log('CALLED GENERATOR')
    el.removeAttribute('new')
    return el
};
```
# Test 1, unexpected

Rendering the following template:

_test.marko_

``` html
<div transform=true />
```

I get the **output**:

```
CALLED TRANSFORM
<new transform></new>
```

But I'm **expecting**:

```
CALLED TRANSFORM
CALLED GENERATOR
<new></new>
```
# Test 2, working as expected

If I change the template to use the `<new>` tag initally I do get the expected output:

_test.marko_

``` html
<new transform=true />
```

**output**:

```
CALLED TRANSFORM
CALLED GENERATOR
<new></new>
```

The node still goes through the transform function, but it is not touched.  I'm guessing this is the difference.
 Makes sense.  Thanks for clarifying, and the `replaceWith` method is much appreciated!
  ```
exports.taglibs.registerTaglib(require.resolve('../taglibs/core/marko-taglib.j
                                       ^
TypeError: undefined is not a function
```

Code snippet from `marko/compiler/marko-compiler`:

```
exports.TemplateCompiler = require('./TemplateCompiler');
exports.taglibs = require('./taglibs');
exports.taglibs.excludeDir(nodePath.join(__dirname, '../'));

exports.taglibs.registerTaglib(require.resolve('../taglibs/core/marko-taglib.json'));
exports.taglibs.registerTaglib(require.resolve('../taglibs/html/marko-taglib.json'));
exports.taglibs.registerTaglib(require.resolve('../taglibs/caching/marko-taglib.json'));
exports.taglibs.registerTaglib(require.resolve('marko-layout/marko-taglib.json'));
exports.taglibs.registerTaglib(require.resolve('marko-async/marko-taglib.json'));
```

While doing: 

```
browserify --node -t reactify -t markoify -o dist/server.js build/source/server.js
```
 I don't want any external npm packages hanging out on an application server.
 Is there a way to exclude the marko-compiler from being bundled? Can I only bundle the Marko-runtime, and precompile the Marko templates in Gulp or something?

Here is my implementation:

```
import Marko from 'marko';

...
...

app.use((req, res) => {
    Marko.load('./views/index.marko', { writeToDisk: false }).stream({
        props: JSON.stringify(props),
        reactOutput,
        title: 'Site Title Here',
    }).pipe(res);});
});
```
  ```
Error: Cannot find module './raptor-logging-impl'
    at Function.Module._resolveFilename (module.js:336:15)
    at Function.Module._load (module.js:278:25)
    at Module.require (module.js:365:17)
    at require (module.js:384:17)
```

Offending code snippet:

```
module.exports = stubs;

if (!process.browser) {
    var implPath = './raptor-logging-impl';
    require(implPath);
}
},{}],497:[function(require,module,exports){
(function (__dirname){
```

Here is my build script:

```
browserify -t markoify --node -t reactify  -o dist/server.js build/source/server.js
```

Dependencies in `package.json`:

```
"dependencies": {
    "browserify": "^12.0.1",
    "browserify-shim": "^3.8.11",
    "bunyan": "^1.5.1",
    "bunyan-request-logger": "^1.0.2",
    "express": "^4.12.4",
    "markoify": "^1.1.2",
    "react": "^0.14.0",
    "react-dom": "^0.14.5",
    "react-tools": "^0.13.3",
    "reactify": "^1.0.0"
  },
```
 @patrick-steele-idem awesome, thanks. Browserify supports building server-side modules, it just requires some clever configuration, which is actually not fully adopted by browserify but seems to work for most applications.

My motivation here is to bundle all of my server side code to one file to make deploys easier, and save space on hosting instances.
 Fixed, but spawned this issue:

https://github.com/marko-js/marko/issues/213
  Is there clamoring for jade-like syntax? I guess the current HTML-like syntax makes marko somewhat opinionated, but I didn't think that was problematic.
 I agree with your main points - I think as long as the new parser is generic enough to easily support multiple syntaxes, neither fragmentation nor maintenance costs should really be an issue. `jarko` sounds funny too, so that's a plus.
 I dunno. Back in my day we didn't need these newfangled languages to write HTML. We wrote our `<blink>` tags uphill both ways and we never complained about it. :stuck_out_tongue: 

In all seriousness though, the development cost of supporting another dialect is something that should be well considered. I'd really hate to see Marko development slowed or delayed due to the support of a (fringe) dialect. Yeah, I said it.

Also, consider that Marko is already an HTML-_like_ syntax, and it sounds like you'd be creating a "jade-_like_" syntax. Since Marko is an abstraction of HTML, and Jade is _already_ an abstraction of HTML, Jarko would therefore be an abstraction of an abstraction. Talk about fringe.

Sass (or Less) is a good example of a useful abstraction‚Äîthe benefits of using Less or Sass to write CSS are huge (variables, nesting, extensions, modularization)‚Äîand they are still mainly pure CSS at their core. But with Jade, you're basically just talking about laziness and simple dialect. I don't see the benefit beyond the popularity/adoption points. Just my 2¬¢.
 +1 [Btw the name Jade is changing to Pug with v2](https://github.com/pugjs/jade/issues/2184) so jarko might not be a good idea. Also I think this concise syntax is a lot different from Jade (better in that sense), so it shouldn't be named after it, it should have its own identity. "concise-marko" sounds perfect. or if it's too long, maybe "cmarko"?
 .pugo

Just kidding. Mug is better.
 Following the discussion, I want to add a few pros/cons I have found... (some are already mentioned)

Pros:
1. Gain additional attraction from the dev community; Everything that looks familiar will improve the adoption rate of Marko - as Marko is still growing, this is important
2. Makes life easier by putting over legacy code written in Jade; we all know that putting something over without changes seldom works flawlessly... but it should be less work than porting over existing markup into Marko v3....
3. Easy to get started for people who worked already with Jade... similar to point 1.

Cons:
1. "Readability" While Jade offers a sparse syntax, I do not really think it offers much more "readability" than Marko v3... I think template statements do not really "raise from the environment"; it makes it really hard to see what is really going on without looking at it in detail... on the other hand, Jade might reduce "noise" by having less stuff that has to be written ("<", ">"...) - it both has its advantages...
2. "Fragmentation" what are the examples written in - with JavaScript server and client side we left the times when there were different languages (and the mental overhead between switching between them). Now with different template languages we kinda "sacrifice" that...
3. Implementation (+ testing) overhead + maintenance... strongly depends how it is implemented... I am confident that the Marko devs can do a great job here.... but it should be considered nevertheless....

Marko v3's main selling point is "as close to HTML" as possible... one could ask if this is really "enough" to have it... why not consider Jade-like as the only template syntax? If there will be a way to easy auto-convert Marko v3 into Jade (and back?) why not have jarko the only syntax and allow people to auto convert over Marko v2 into Jarko (if compatibility is an issue)?
 > why not consider Jade-like as the only template syntax?

Please, no. Abstraction languages come and go‚Äîthey are in a sense fads. HTML is universally known and familiar to most developers.
 I'm with @danrichman. I think ditching the proper HTML-like syntax all together would be a mistake, at least at this stage. That said, I'm all for giving the jade-like syntax a go. If you can bake both of them into a universal Marko compiler, I think it's going to be a really great move @patrick-steele-idem. Let people decide how they want to use Marko.

There are some drawback's you guys might want to consider though:

(1) As Marko matures and the user base grows, the ambiguity of questions online could get quite confusing for developers. Consider someone researching how to do something in Marko, and they scour through StackOverflow, videos, blog posts etc... 50% of answers with one syntax, 50% with the other syntax. People are going to end up with some kind of psuedo marko language in their app, where they have a mixture of the compact syntax and traditional syntax. That's a bad experience for everyone.
(2) More documentation, and it's going to have to be really well written to avoid confusion.
(3) Ultimately there's probably going to have to be two seperate docs - one for traditional Marko, the other for compact.

I think you can get around both of those issues with really well defined documentation, and pushing out the message early on that there's two syntax options with Marko. But for that to happen, we all need to be up for that challenge. Personally I hate Jade syntax with a passion, but damn, it's 2016. I'll willing to give new things a try.
 Just to be clear:

Having Jade-like (jarko/mug) as the default would mean to prepend every plain text with a specific well-defined symbol (e.g. a dot)... otherwise plain text would be mis-interpreted as a tag (original Jade uses pipes for plain text)

Regular HTML like syntax would of course be allowed as well (and mixed in within jarko):

```
. This has to be prefixed
<div>
  No worries here
</div>
```
 Jade is a rabbit hole. Could be a third-party option, but as a core feature? I dunno. One of the selling points of Jade, according to [its own website](http://jade-lang.com) is...

> Jade is a terse and simple templating language with a strong focus on performance and **powerful features**.

This is a good reason to _avoid_ Jade actually. Something more powerful is always coming along. Why would we want more powerful features if Marko is intentionally trying to adhere to the _Rule of Least Power_?

> **The Rule of Least Power**
> http://www.w3.org/2001/tag/doc/leastPower
> 
> When designing computer systems, one is often faced with a choice between using a more or less powerful language for publishing information, for expressing constraints, or for solving some problem. This finding explores tradeoffs relating the choice of language to reusability of information. The "Rule of Least Power" suggests choosing the least powerful language suitable for a given purpose.
> 
> [...]
> 
> **Good Practice:** Use the least powerful language suitable for expressing information, constraints or programs on the World Wide Web.

I was under the impression that Marko was designed to adhere to the _Rule of Least Power_. By promoting Jade, it's no longer adhering to that rule.

See also:
- [We need less powerful languages](http://lukeplant.me.uk/blog/posts/less-powerful-languages/) by [Luke Plant](http://lukeplant.me.uk/)
- [In Defense of Templates](https://www.youtube.com/watch?v=VY-r7Ac06ho&feature=youtu.be&t=498) (YouTube clip) by [Tom Dale](http://tomdale.net/)
 @patrick-steele-idem Isn't there more to Jade than that? Conditionals, extends, etc. Wouldn't Jade developers just end up demanding those more powerful features?
 I meant that by supporting the Jade syntax, you're going to open yourself up to demands for supporting the specific (less clean) Jade-forms of those and other features‚Äîparticularly as Jade becomes more complex over time. I don't know how this would be avoided. At some point, you know someone is going come along and demand more support for the Jade syntax to trigger those various features.

As in..

> Hey Patrick, if would be great if the Jarko syntax could do XYZ just like in Jade.

It's a slippery slope. Where do Marko devs draw the line? Can I get a nickel for each such request? :)
 Just chiming in.. Please avoid overcomplicating marko at all costs, keep the core simple then allow extension if desired. I won't be using any of the html-like syntax anyway, in our environment the users specify mark-up over which we have no control, we will just be exposing widgets for them to hook into using attributes.
 For what it's worth, some opinionated Angular devs seemed to be¬†largely against the idea of using Jade in Angular. For starters, they say mixing the two syntaxes in Angular documentation, examples, and in templates is _way_ more confusing than the simplicity that the syntax is supposed to provide in the first place.

See: [What's the use of Jade or Handlebars when writing AngularJs apps](http://stackoverflow.com/questions/18174856/whats-the-use-of-jade-or-handlebars-when-writing-angularjs-apps)

> **Q:** "...As far as I can tell, it would make most sense to create the templates in Angular using proper HTML...The reason for this confusion is that a lot of the examples I find on GitHub make use of Jade, and it seems counter intuitive for me."
> 
> **A:** Those who _unquestioningly_ favour Jade in an Angular environment fail to understand that view logic belongs on the client, and business logic on the server, just as the OP commented.
> 
> _Don't do it unless you have a very good reason to do it_. In engineering, a system with fewer moving parts is a more reliable system, and a system where interface boundaries (client/server) are respected is more maintainable over the long term, so default to the simplest architecture and clean division of labour if possible. If you have overriding reasons, do what you must, but _caveat emptor_.
> 
> Recently I reviewed some code where straight Angular templating would have done a far better job than mixing in Jade, just through maintaining simplicity.
> 
> Aside from template extension, Jade brings nothing worthwhile to the table that Angular doesn't already supply. Let's be honest: Using the sound principle of "favour composition over inheritance" (i.e. partials), you shouldn't ever need template extensibility. Jade is hardly "easier to parse" than HTML. They are but _trivially_ different, while Jade adds another level of indirection - best avoided.
> 
> There is one valid, specialised case for server-side templating: Optimisation, remembering that premature optimisation is generally a Bad Thing. Where performance is truly at issue, and you have the server capacity to spare to handle this, server side templating can assist. This applies to products like Twitter and Basecamp, where the cost of doing a lot of server side work is offset by the gains of reduced requests to the server.
 I just wanted to chime in on our team and experience with marko. We like marko and what it offers, but we were definitely _not_ a fan of the syntax when we started using it. I think it would be a much more enjoyable experience to have the concise syntax, as you are putting it.

I also don't think it would be a slippery slope to supporting all jade features. The biggest gripe is that it is a pain to write in and look at, especially as files grow in size and complexity. That is why languages like jade and haml are so popular. I don't think I've used marko and ever thought "this could use some more features from _x_ language". I have thought, however, that the template looked cluttered and hard to read/scan. But then again, I've used haml and jade for years, so the HTML like syntax seems like a step backward to me.
 @patrick-steele-idem  :+1:  thanks for experimenting with real-world examples! Curious about the outcome.
 Here's the rub.. Less and Sass are similar abstractions of CSS. Yet, [neither abstraction is a core plugin of Lasso](https://github.com/lasso-js/lasso#available-plugins) despite the fact that every front-end developer will tell you that Less and Sass make CSS so much easier to manage. And it's not a problem since any developer can just install [lasso-sass](https://github.com/lasso-js/lasso-sass) or [lasso-less](https://github.com/lasso-js/lasso-less)....or [lasso-jade](https://github.com/lasso-js/lasso-jade) (for JS) if they prefer.

So, why would Jade for Marko be any different? Why not just make it a third-party plugin? (If it becomes crazy popular, then maybe one day it becomes a core plugin).

If Jade were a core feature (never mind it's an added layer of architecture to maintain), then the question is where does that leave all the documentation, tutorials and shared examples? Do you have a competing ecosystem of documentation?

> I'm starting to feel that the concise syntax is something that can grow on you, but that most people (me included) initially dislike it

I think this is probably the key point here, if anything. Anything distasteful will grow on you, eventually. Jade is being added to make Marko more accessible _to the Jade crowd_.

But, by making it a core feature, the risk is perhaps making Marko initially disliked by the majority of non-Jade users, which would be counterproductive. I suppose Jade could be generally avoided in the documentation, but then what's the point of having it be a core feature in the first place?

If the only reason for adding Jade-like syntax is to appease the population of Jade developers, then that implies that Jade would make a very good non-core plugin. Wouldn't that make everyone happy? People who want Jade can easily install the plugin and people who don't just follow the documentation and the HTML they are familiar with (without the mysterious `.` before lines of text to turn off the seemingly non-essential Jade syntax).

If the Jade-like syntax were the _de facto_ syntax, then that would imply that the documentation, tutorials and shared examples would all be in the Jade-like syntax or some confusing mixture of the two. But, of course, doing so would turn off all the people who dislike Jade at first glance (yourself included). Is it worth it to make it a core feature then? I dunno. Seems like a third-party plugin to me, just like [Less or Sass is for Lasso](https://github.com/lasso-js/lasso#available-plugins).
 @danrichman I like that idea. If templating syntax can be abstracted out into a plugin, then marko could ship with the `html-syntax` plugin by default. Developers could install `jade-syntax` which would be responsible for its own documentation and maintenance. Plus, there is some room to experiment with new syntaxes in the future.

Eventually you need to consider what plugins should be moved to core, but it seems like we're pretty far from that point right now.
 Seems like it could be risky to get married to a particular syntax in the core when, for all we know, a more popular or easier abbreviated HTML syntax might come along 2 or 3 years from now and make Jade obsolete. For instance, [some people prefer Slim syntax over Jade](http://vschart.com/compare/slim-lang/vs/jade-template-engin) because [Slim is less cryptic](http://slim-lang.com). By making Jade core, nobody gets to use Slim.

In 2006 Sass was the ultimate CSS abstraction. But then Less was released in 2009 and of course now there is a choice between the two and people [have their opinions about each language](https://css-tricks.com/sass-vs-less/)‚Äîeven though they are nearly identical in almost every way and their syntaxes are only trivially different from CSS. 

@patrick-steele-idem maybe there's a way to keep it more separated within projects. Could there be a flag at the top of individual templates to enable such an optional Jade-like syntax, for those who want it? Or is it just all or none?
 Very sorry to be such a downer here :smile: but thought of another issue.

The tendency to mix Marko syntax within a large company, like eBay, could add significant risk.

Since Jade is an _individual_ preference, this can cause issues to develop over time within a large team or organization using Marko. For instance, someone in one area of a large team or company (say eBay) prefers Jade and then they leave the company or go on vacation. A non-Jade employee‚Äîperhaps even days, months or even years later‚Äîmight have to jump into those Jade files at any given time and be able to quickly troubleshoot them. A critical fix that should've taken minutes to troubleshoot ends up dragging out into far longer (perhaps hours) because the next employee to open up the files isn't familiar with the Jade syntax and can't get the complex files to build properly. In that case, the benefit of saving a few keystrokes became a liability for that company. It's a barrier to code completion, for a templating language that was intended to tear down barriers.

Actually, the same is true even within a small team, but if it's risky to mix a template syntaxes within a large company then one solution is to force all eBay developers to learn and use Jade in all of the codebase and documentation. But then the idea of it being optional would be an illusion.

As teams then attempt to avoid those inconsistencies and inevitably make team-wide standardizations to Jade, it ends up being a distasteful barrier to entry (newcomers and new hires getting up to speed, for instance) as well code sharing and information sharing. It promotes a lack of standardization because the standard _would actually be Jade_ with documentation, tutorials and examples pretending it's HTML. 

As an aside, I went to the [Jade playground](http://jade-lang.com) and tried pasting in a chunk of deeply nested/indented HTML code and I still can't get it to render the same HTML using their `.` or `|` syntax. Can we see an example of a chunk of nested HTML-preserving Jade? My initial experience suggests that this move to Jade may lead to _lower_ adoption rates once people realize that Marko v3 is really Jade disguised as HTML. I would point out that even Jade contributors [admit that Jade often makes a bad first impression](http://webapplog.com/jade/).
 > The tendency to mix Marko syntax within a large company, like eBay, could add significant risk.

@danrichman Agreed, but to use an earlier example, I think no more risk than an online newspaper using Markdown to collaborate on articles. One tech savvy journalist could start off by using HTML to draft the document with, while another journalist with no HTML experience could come along and feel inclined to either a) use HTML also, or b) use Markdown and we end up with a psuedo document.

Either way, this I think the arguments currently being presented are _internal_ issues and beyond the scope of what Marko should have to consider.

> Jade is being added to make Marko more accessible to the Jade crowd.

There also seems to be a general misconception (I think) that the Marko Concise option is being added purely for Jade user's. I think that's wrong. I hate Jade, but I feel as if I would at least give the concise option a legitimate chance - maybe even using it often in cases where I need to draft HTML quickly (in front of a client, or scaffolding for instance).

If we add this, _I think_ it has to be shipped together under the same file name and no additional plugins required.
 @adammcarth Well, if a journalist messes up a Markdown tag, the worst thing that happens is the text looks a little funny‚Äîit's one of the features of Markdown (looks publishable as-is, as plain text, without looking like it‚Äôs been marked up with tags or formatting instructions) and the CMS prevents them from doing any real damage to the site. If you mess up the Jarko syntax, the code fails.

Markdown isn't cryptic like Jade is. Markdown is purposefully readable as is. Jade's cryptic syntax is [why some people prefer Slim over Jade](http://slim-lang.com/about.html).

Technically, the Markdown comparison is the opposite of what's being proposed here with Jade. When mixing Markdown and HTML, you have to _opt-in_ to Markdown. You write standard HTML and if you want to use Markdown, you just start using the Markdown tags and enable a Markdown attribute. Easy peasy. Markdown doesn't interfere with your ability to write HTML. That really does make everyone happy.

For example...

```
# Heading 1

<div class="something" markdown="1">
  ## Heading 2
  Some **bold** text. Some <em>emphasis</em>.
  <div class="something-else">
    This is easy. I don't have to change my habits.
  </div>
</div>
```

The `markdown="1"` attribute is how you _opt-in_ to Markdown when you want to use Markdown tags within an HTML tag. Everything is treated as plain text if you forget that attribute. **HTML is a first-class citizen in Markdown**.

With Jade, it's the other way around. Should you want to indent your HTML or plain text, you'll need to _opt-out_ of Jade.

For example...

```
.  <div class="something">
.    <h2>Heading 2</h2>
.    Some <b>bold</b> text. Some <em>emphasis</em>.
.    <div class="something-else">
.      Why do I have to put
.      periods everywhere?
.    </div>
.  </div>
```

If you want to wrap that chunk of indented HTML with a Jade-generated `<div></div>` tag, you have to indent your periods like this.

```
#container.col
 .  <div class="something">
 .    <h2>Heading 2</h2>
 .    Some <b>bold</b> text. Some <em>emphasis</em>.
 .    <div class="something-else">
 .      Why do I have to put
 .      periods everywhere?
 .    </div>
 .  </div>
```

Feels almost like we're being punished for using HTML.
 @patrick-steele-idem Whew. Yes! That does look good. Sorry, I was really getting worried after trying to paste HTML into the [Jade playground](http://jade-lang.com) and coming up with nothing but errors. :sweat_drops: 

However, to allay further fears, can you show us how the top pure HTML would look if someone should choose to wrap it in a Jade-generated `<div>` tag, like `#another-div`?

Would the periods be necessary then?

The reason I ask is because just like a mixed HTML/Markdown example, someone may want to come along and insert HTML inside someone's `#another-div` Jade tag. And I don't understand how they could allow Jade to wrap their chunk of nested HTML without using periods. Thanks so much.
 @patrick-steele-idem Fantastic. I don't know how you did it, but you've managed to create something _way better_ than Jade. Awesome job.

Ok. I'm on board. :+1:

Sorry for all the frenetic comments above. I had mistakenly gotten the impression that we were bastardizing HTML. Clearly that's not the case. I'm impressed.

The real beauty of your example is that it actually allows people to slowly dip their toe into the concise syntax‚Äîit's the best of both worlds. I can start with a single line and wrap all my HTML with it. And then I can use that single line to tip-toe into another line, and another if I please.. and so on. It‚Äôs really hard to dive into the whole Jade syntax at once. But you‚Äôve managed to make it seemingly painless. 

> If we get this right then I see no reason why anyone would want to use Jade.

Yup. Completely agree. This looks awesome. Carry on.
  Current template:

``` javascript
<if test="Array.isArray(data.author) and data.author.length ne 1">
    <if test="data.author.length == 1">
        <dc:creator id="creator">${data.author}</dc:creator>
        <meta refines="#creator" property="role" scheme="marc:relators">aut</meta>
    </if>
    <else>
        <for each="author in data.author" status-var="loop">
            <dc:creator id="creator${loop.getIndex()+1}">${author}</dc:creator>
            <meta refines="#creator${loop.getIndex()+1}" property="role" scheme="marc:relators">aut</meta>
            <meta refines="#creator${loop.getIndex()+1}" property="display-seq">${loop.getIndex()+1}</meta>
        </for>
    </else>
</if>
<else>
    author is not array.
</else>
```

This object is being passed into the template:

``` javascript
{author: ['Author One', 'Author Two', 'Author Two', 'Author Two']}
```

Output:

``` xml
<dc:creator id="creator1">Author One</dc:creator><meta refines="#creator1" property="role" scheme="marc:relators">aut <meta refines="#creator1" property="display-seq">1<dc:creator id="creator2">Author Two</dc:creator><meta refines="#creator2" property="role" scheme="marc:relators">aut <meta refines="#creator2" property="display-seq">2<dc:creator id="creator3">Author Two</dc:creator><meta refines="#creator3" property="role" scheme="marc:relators">aut <meta refines="#creator3" property="display-seq">3<dc:creator id="creator4">Author Two</dc:creator><meta refines="#creator4" property="role" scheme="marc:relators">aut <meta refines="#creator4" property="display-seq">4

```

The `</meta>` closing tags are not appearing, what is Marko doing?
 It completely slipped my mind that I was expecting XML, I'm quite used to template engines supporting both HTML and XML.

Changing the extension completely breaks the code (`<if>` and `<for>` tested so far, all breaking)

``` javascript
test.marko.xml:1
(function (exports, require, module, __filename, __dirname) { <if test="Array.isArray(data.author) and data.author.length ne 1">
                                                              ^

SyntaxError: Unexpected token <
    at exports.runInThisContext (vm.js:53:16)
    at Module._compile (module.js:373:25)
    at Object.Module._extensions..js (module.js:404:10)
    at Module.load (module.js:343:32)
    at Function.Module._load (module.js:300:12)
    at Module.require (module.js:353:17)
    at require (internal/module.js:12:17)
    at Object.<anonymous> (/home/george/coding/marko-playground/index.js:8:16)
    at Module._compile (module.js:397:26)
    at Object.Module._extensions..js (module.js:404:10)

```
 Bump for those who still faces this problem...

For me things start to work when I do

```
require('marko/node-require').install({ extension: '.xml' })
```

My guess is that internally `require('some.marko.xml')` looks for loader associated with '.xml', which is more in line with `require('path').extname('some.marko.xml')`

#363 adresses an issue with xml and `marko/hot-reload`.
  It seems like http://markojs.com/docs/marko/get-started needs some improvement.

Angular 2's use of file name labels on their code samples is helpful here: https://angular.io/docs/ts/latest/quickstart.html  You see this a lot throughout the community.   It's a nice way to help people get their head around the setup process quickly so they can get down to learning the syntax and API and also building something.
  I need it, so I believe I can implement this feature.
I can make fork, pull test, develop  & pull request.

Before I am going deeply in the source code, can you give me some direction where you think is the best place to implement it? (links to files&lines&functions will be appreciated) 
 I prefer sandbox via vm or vm2 (https://github.com/patriksimek/vm2).
Regular VM, of node can make the entire process not responding `while (true) {}`.
 static code analysis never can be perfect, and in case of break, it is a backdoor to entire server. That why we must choose sandbox:
https://nodejs.org/api/vm.html
https://github.com/patriksimek/vm2
 We only talking about server side. web worker, is mostly for client side. 
 Out-of-process will make all global variables not works. It is break-change. Can we do that kind of break change to Marko?
 Just to clarify. For securing client side, all we need to do is use XSS library. (https://www.npmjs.com/package/xss). We are only talking about securing server side code executing
 I believe that to not break current code using global variables, we have to add it as an option.
Maybe like this:

```
require('marko').load(src,{secure:true})
```

http://markojs.com/docs/marko/javascript-api/#loadtemplatepath-templatesrc-options--template
 The problem is that maybe there are user that now using templates, that running insecure code, but this is what they want. We cannot make break change to community project.
 we can simply use child_process.spawn (or fork), and send data between the process.

A question There is any timeout for async function loading in Marko? 
We don't want that a template that contain a infinite loop, will work forever.
 @patrick-steele-idem . That what I mean it will be opt-in only
 So, we have to add timeout, (default: 1 min)

```
require('marko').load(src,{secure:/* true/false  */, timeout: /*in ms*/ }
```
 Maybe the timeout need to be in the render function (not at template loading time)
 It is supported for vm2. 
`options={timeout:1000}`
 Maybe it is possible to add modules to VM2 context using the sandbox option, instead of requiring it:

```
sandbox={marko: require('...'), `marko-async`:require('marko-async')}
```

What do you think/
 For timeout, You can do

```
vm.call('setTimeout(function(){process.exit()},60000)')
```

It will stop the vm, after 1 minute
 Anyway Maybe it be easier to implement it simply, using `child_process.spawn` that run native vm module.

and not be depended on other modules. vm2 not giving as so much.

I think, that child_process can give us, secure way of running things, and vm module, can give as "javascript from text " compiler.

In short:
1. We will create a short JS file, that render templates in native vm.
2. We will run this js file as spawned process.
  Maybe try add the creator of vm2, to the conversion...
 The problem is, that today, I can use helper, with extenal data.

var y=3
templateDat={
my_helper:function (x) {return x*y}
}

If we use vm2, or out-of-process rendering, the `y` variable will not available.
  So, there is any solution how to to stop vm2, in case of infinite loop
  I think a folder within `node_modules` is a very sound place to compile templates to _by default_. Reference the full path to a compiled file if an error occurs, and the person can easily navigate their way to the destination for further inspection.

I know it's awesome and cool to see the Javascript that is compiled from `.marko` syntax files, but I stand by my opinion that they serve quite literally no real purpose besides debugging and, for a lack of a better term, pure self-interest in how Marko works. In either case, at no point should these files need to be visible in a project. You don't edit or make changes to compiled Marko files, and they shouldn't ever need to be included in version control.

The `node_modules` folder ticks as a solution to all these boxes. PLUS the fact it's already checked out of version control in 99% of projects means compiled files are hidden straight away, instead of realising down the track and needing to add line(s) to your `.gitignore` file.
 Hey @patrick-steele-idem! Sorry I missed your reply to this :(. Better now than never though, I guess.

Hmmmm. That's a tricky one. In regards to your second use case, I still stand by the fact that even if you did decide to delete your original Marko templates as some kind of release process - you'd probably be doing more harm than good. Unless you have some incredibly unique situation where storage space is an issue, what would deleting the originals and keeping the compiled achieve? You'd have compiled Marko templates that would serve literally no purpose to anyone except the process workers, right? I guess if it was part of some kind of testing environment I could see the use for that though. That kind of makes sense, but I don't see any real advantage of that over the files being in a seperate directory.

As for not using the `node_modules` folder - I think that's a fair enough reservation to have. Something like `.mark-compiled` would work well, if you were going to go down the whole, _compiling-to-a-different-directory_ path.

Let me know what you decide on anyway. Glad to see v3 is gradually getting rolled out, keep up the good work mate :+1: 
 It would be very nice to be able to supply an alternate directory. It could be the case that the user running the application doesn't have write permissions to `node_modules`, but does have write permissions elsewhere.
 +1 for `.marko-compiled` (or `.marko-cache`) on the root, in a similar way as Sass does.
 The compiled template location is handled on lines `38` and `92` of `node-require.js`: . Right now they just append '.js' to the end of the source template's filename. I've hacked on my local copy a bit and added new compiler options for defining the source and cache directories, and it works perfectly under ideal circumstances.

The problems I'm looking at now are ensuring that the requested template is actually _below_ the given source directory (which I suppose could be handled by throwing an error if `path.relative(<src-dir>, <filename>).startsWith('..')`) and that the target cache directory exists before trying to write to it (ideally without too much extra code or pulling in another dependency like `mkdirp`). I'll try to poke at this a bit more tomorrow if I get the chance, but I'm running out of time for today.

EDIT:
The reason for worrying about the path relative to the source directory is that otherwise it just dumps everything in the same place, which is fine until you start having name collisions. The only other option I can think of would be naming the files by some kind of unique hash, but that would make debugging a nightmare.
 It seems this isn't quite as simple as I'd thought. After posting I noticed the comment above about it only storing in the alternate location for reference purposes, and it seems that is what's happening. It also doesn't seem to affect layouts. I'll still try to poke at this a bit when I get the chance, but disregard my previous post as premature optimism.
 I did some more digging and found that `node-require.js` isn't the only place that is hard-coded to simply append '.js' to the source filename. I'm seeing 3 more such lines in `runtime/loader/index.js`. Fortunately the line always seems to be basically the same thing, `var targetFile = templatePath + '.js';`, sometimes with different variable names. I'll keep poking at this whenever I get the chance.

In the meantime, regardless of the solution, we'll still need to ensure that the target directory exists. My first idea was to use the `mkdirp` module, but that would mean adding another dependency. Any thoughts or suggestions?
 I tested every scenario I could think of, and it _appears_ to work perfectly except for two things:
1.) I got a "Cannot find module" error when trying to use a component, though that's _probably_ the result of my being lazy and hard-coding some of it just to see if this was even viable.
2.) I _think_ with the current setup, if the source template has been deleted, moved, or renamed, it falls back to require()'s built-in behavior of attempting to append '.js' to the end of the filename. This is probably an easy fix.

To anyone who would like to put my research into practice:

Step 1: Edit lines `38` and `92` of `node-require.js`, and lines `55`, `82`, and `92` of `runtime/loader/index.js`(marko v3.10.1); They should all look something like `var targetFile = templatePath + '.js';`. You'll want to modify them to point to wherever you want the compiled templates to be cached (+1 to the previous suggestion of using `.cache/marko` by default). You could probably implement a new compiler option for users to specify the source and cache directory paths, both modules already have access to markoCompiler.defaultOptions.

Step 2: Ensure valid file paths; All sources should be below `src/`, all compiled templates should be below `.cache/marko/`, and the target directory should exist before attempting to write to it - for example, `.cache/marko/layouts/main/` must exist before attempting to write `.cache/marko/layouts/main/layout.marko.js` - ideally without adding too much extra code or another dependency.

Step 3: Make sure components work correctly. The error I saw may just have been a fluke, or it may be a quirk in how components are loaded as opposed to layouts (which did work correctly for me).

Step 4 (optional): Modify the require() extension to check for an existing compiled version of the requested template even if it can't find the source file.

I apologize for the length and number of my posts. I'm not sure if or when I'll get around to forking or initiating a pull request, so I want to make sure that if anyone wants to finish what I've started they'll have as much information as possible.
   Working great! Thanks. Do you know off-top if there are any other places that scan node_modules where this check would be necessary?
  Hi,
Just to let you know there seems to be a problem with npm installing dependencies for the 'marko' package (in particular I noticed marko-layout wasn't being installed). I made sure 'marko-layout' wasn't installed in the main projects package.json file. Tries a clean uninstall of all npm packages, npm cache clean, and then install and still no joy. I think it is linked to the version on npm.
I managed to resolve this by 'cd' into node_modules/marko and running npm install there.

Hope it helps someone.
 Thanks this solved it. Was pulling my hair out. Would be good to get this in the marko docs, maybe in a section about moving an app to production. 
What I actually did was stop grunt from copying the 'template.marko.js' files to the build so they were generated again on the server. Is that a suitable way of doing it?
  I have a marko tag with the following marko-tag.json:

```
{
    "@class" : "string",
    "@items <item>[]": {
        "@wallpaper <wallpaper>": {
            "@class": "string"
        },
        "@panel <panel>": {
            "@class": "string"
        },
        "@someProp": "string"
    }
}
```

And the following index.js:

```
module.exports = require('marko-widgets').defineComponent({
    template: require('./template.marko.html'),
    getTemplateData: function(state, input) {
        input.items = input.items || [];
        var items = [];

        for (var i = 0; i < items.length; i++) {
            var item = items[i];

            var wallpaper = (item.wallpaper || {renderBody:''}).renderBody;
            var panel = (item.panel || {renderBody:''}).renderBody;
            var someProp = item.someProp || 'default';

            items.push({
                wallpaper: wallpaper,
                panel: panel,
                someProp: someProp
            });
        }
        return {
            items: items
        };
    }
});
```

Attempting to use it in the following way doesn't seem to work:

```
<img-carousel>
  <img-carousel.item someProp="someValue" for="item in data.items">
    <img-carousel.item.wallpaper>
      <img alt="${item.img.alt}" src="${item.img.src}">
    </img-carousel.item.wallpaper>
    <img-carousel.item.panel>
      <p if="item.text">$!{item.text}</p>
    </img-carousel.item.panel>
  </img-carousel.item>
</img-carousel>
```
  Hey all.

So at the present, Marko doesn't have a uniform way of defining configuration options when first initializing the library in your project. For example, setting the `writeToDisk` option (which prevents templates from compiling to the file system) is achieved with:

``` javascript
// Current configuration method
require("marko/compiler").defaultOptions.writeToDisk = false; // what if more config options arise?
require("marko/node-require").install();
```

It works for now, but it's not ideal - particularly with the future in mind where configuration could play a bigger role with Marko. Here are some alternatives for defining configuration that have been suggested so far...
#### 01. Configuration File

This solution is probably the most promising on this list. Essentially, the idea is that you can create a file in the base directory of your project that Marko will read and pull configuration options from. A potential name for the file might be `.markoc` (a hidden file, standing for 'marko config')...

``` javascript
{
    "writeToDisk": false,
    ...
}
```

One debate that does arise from this is whether your _Marko Tag Lib_ should also be defined here with the compiler configuration, or if it should still be kept in a seperate `marko-taglib.json`. My personal opinion is that all Marko configuration should be defined from a central place to make life easier, but the argument for keeping the `marko-taglib.json` seperate from compiler configuration is that it's less complex. My question to that response is, how often do we intend to add/update component directories? If it's very infrequently (as I suspect), then I just don't see why it needs its own file. Just my $0.02 on the matter though. Please share your own thoughts.
#### 02. Pass Configuration Block To Installer

An idea I had was to potentially pass in a configuration object when Marko is required...

``` javascript
// Example
require("marko/node-require").install({
    writeToDisk: false,
    ...
});
```

It's certainly a more traditional solution, but this approach is not ideal given the way the Marko runtime is loaded by Node.js so this one is not recommended.
#### 03. ???

If you've got any ideas or suggestions for alternative ways that configuration could be defined for Marko, please share it with us below. I think it's important that we have this discussion now so that more default configuration options can be introduced by the community down the track. If we can agree on a standard now, we can start exploring other potential config for Marko. Please share any thoughts you have :)
 I agree with @philidem. I think a centralised configuration file in the project root for all default Marko settings, and the name `marko.json` gets my vote so far. Good point about the potential hidden file issue with Unix based systems.

Do you want to elaborate more on why you would want to keep the Marko Taglib seperate @patrick-steele-idem?
 I would prefer being able to pass a configuration object into some sort of `require('marko').config()` method. I don't like the idea of messing with Node's `require` function, so I don't use `marko/node-require`. I use `marko.load()` for loading templates.

I normally write my applications to look for an application specific configuration file, or have one fed to it. The application then uses the properties of that configuration file to initialize any modules it uses that could potentially need some configuring. I don't really want to edit multiple configuration files for one application.
 My statement about the require patching was in response to idea 2 in the original post. It proposes passing the configuration in during the install of the require patch. I was merely pointing out that not everyone uses that aspect of Marko. I understand that it is a convenience method, and that Marko is really just compiling the HTML based language into JS. It doesn't matter to me if Babel or other things also patch the require method -- I don't use any of them.
  Hey team.

Are there any plans on the roadmap for an Express JS rendering plugin for Marko? Currently we render templates with...

``` javascript
require("marko/node-require").install();
var app = require("express")();
var template = require("./hello.marko");

app.get("/hello", function(req, res) {
    template.render({
        name: "Adam",
        fruits: ["Apples", "Oranges", "Grapes"]
    }, res);
});
```

But what about a plugin that leverages Express's built-in render helper?:

``` javascript
var app = require("express")();

var Marko = require("marko-express"); // example lib name
app.engine("marko", Marko({ fabulous: "options" }));
app.set("view engine", "marko");

app.get("/hello", function(req, res) {
    res.render("hello", {
        name: "Adam",
        fruits: ["Apples", "Oranges", "Grapes"]
    });
});
```

Is something like this on the cards, or did you avoid it because of performance reasons/Marko best practices or something? I guess one of the advantages of initializing Marko as an express app engine (like above) is that  you can pass options to Marko, such as `writeToDisk`, in a far nicer way than currently available. It also means we can set a base directory to reference `.marko` templates relative from, and not need to have an extra line to load the template into a variable before rendering content.
 Thanks for the response @patrick-steele-idem. That blog post you wrote pretty much cleared everything up for me - seems like using the built-in express renderer can indeed be quite harmful in some cases.

I'm interested in making my apps more modular. I like the structure you use for basic apps...
- pages/
  - home/
    - index.js
    - style.css
    - template.marko
  - login/
    - index.js
    - style.css
    - template.marko

...but I'm wondering how that idea gets applied, to, say - a blog post? Would you opt for something like?:
- pages/
  - posts/
  - post_show/
  - post_edit/
  - post_update/

Just trying to get the Marko concepts down-pat. Thanks for all your help :)
 Cheers mate, wonderful.
  @patrick-steele-idem Is it possible to add js and less file to the components/taglibs? 

I've tried `<lasso-page name="hello" package-path="./browser.json"/>` and someway similar to it, I found that only one `lasso-page` tag would be work. 

is that a possible way to get `lasso` and `marko taglib` working together to support the dependencies which would be required by the component/taglib itself?
 @patrick-steele-idem sure
  Would be useful to be able to tell from reading the first paragraph of the readme whether mark is server, client side or both. I guess it's both, but if it was mentioned I would feel more confident trying marko out
 Excellent - thanks. So far, after 1 evening, I'm a big marko fan - the most comprehensible compiled templates I've ever come across - great for debugging
  Given this template

``` html
<p>Author ${data.author.name}</p>
```

this data:

``` js
template.render({});
```

I get this error

```
      escapeXml(data.author.name) +
                           ^
TypeError: Cannot read property 'name' of undefined
```

Is this normal behavior ? Does marko handle properties on undefined paths or am I missing something ?
 thanks @patrick-steele-idem that's what I did (lodash).

On the other hand, wouldn't it be interesting to have that handled by marko ? It seems most template engines have such a feature. 
 I see what you mean.

As for offering  `get` as builtin helper, one can use lodash as you suggested. May be it's good to keep the library as slim as possible by not providing extra features, until there's sufficient demand for it by the community?
   Hey @patrick-steele-idem, I see, absolutely!
Thank you for brilliant template engine and very interesting test harness created for it.
  Excuse me, I'm newbie to marko. I'v tried the hello-world example on koa.js with a stream via pipe proccess.stdout. So first time in template all was OK written as must to be. Via console terminal all was also fine, it's work but when I opened the file next morning I'v seen that marko engin rewrite the file of  his own way with helper's javascript functions, but my  Hallo ${data.name}!   is gone, simple disapeared. What I'v wrong made? Or all that features must be by default?

``` javascript
var fs=require('fs')
var  duf=''
require('marko/node-require').install();
//two ways at once
//first way:
var template=require('./views/hello-world.marko');
template.render({name:"Bob",colors:["yellow","red","brown"]},function(err,output){
    if(err) console.log('error :',err);
    console.log('output :',output)
})
//2th way:
var das=template.stream({name:"bobika"});
das.on('end',function(){console.log('\nDAS END DAS END!!! ON END!!\n')})
das.once('end',()=>console.log('\nDAS Once END ONCE END!!!\n'))
das.on('finish',()=>console.log('\r\nDAS ON FINISH!!!\n'))
das.on('error',(e)=> console.log('\n DAS ERROR!!!! :',e))
das.on('data',(c)=> console.log('DATA!!! :',c.toString()))
das.on('readable',()=> {var buf;while((buf=das.read())!==null){
    duf+=buf;console.log("\nBUF :",duf)}})
var sis=process.stdin;
var sisout=process.stdout;
process.stdout.on('error',process.exit);
process.stdout.on('exit',function(){console.log('ended')})
sis.pipe(das).pipe(sisout);
```

---

and here my hallo-world.marko in the morning:

``` javascript
function create(__helpers) {
  var str = __helpers.s,
      empty = __helpers.e,
      notEmpty = __helpers.ne,
      escapeXml = __helpers.x,
      forEach = __helpers.f,
      escapeXmlAttr = __helpers.xa;

  return function render(data, out) {
    out.w(' hello ' +
      escapeXml(data.name) +
      '! ');

    if (notEmpty(data.colors)) {
      out.w('<ul>');

      forEach(data.colors, function(color) {
        out.w('<li style="color: ' +
          escapeXmlAttr(color) +
          '">' +
          escapeXml(color) +
          '</li>');
      });

      out.w('</ul>');
    }
    else {
      out.w('<div>no colors!</div>');
    }

    out.w(escapeXml(data.bazar) +
      '<b>simka: </b>' +
      str(data.simka));
  };
}
(module.exports = require("marko").c(__filename)).c(create);
```
 In the file hierarchie must be two files? One for hello-world. marko and one compiled  hello-world.js???
is that by default? Hmm. The server must be restart to keep changes in the template file every time. So bad and slowly for a site developing. Is it true?
In docs about marko.js said nothing about that. About files structure and about server restarting.
 In a hello-world example for colors /li produces extra empty li pairs. Why? When you delete last /li, so ok. Is a bug?  I try in for="color in data.colors - 1" produces NaN. Is there a way write data.colors.length?
 Only opening tags are modified for conditionals and looping???
  Hi Patrick,

We are using Marko JS on our application. Below is the GitHub URL:

https://github.corp.ebay.com/OCS-Dev/webforms/tree/rti

One of our component we provide dependency: 
https://github.corp.ebay.com/OCS-Dev/webforms/blob/rti/src/components/email-form/browser.json

{
  "dependencies": [
    "require: ./index",
    "src/ds3/browser.json",
    "src/third-party/jquery.js",
    "require: src/components/call-me",
    "require: src/components/submit-button"
  ]
}

Relative path is not getting resolved in On Windows environment(working expected on MAC though). I see below exception in browser console when I hit our page: 

http:/localhost:8080/email/compose/AQABAAAC0CtGM/B68cFDXP472Z5EMUy3itN2JRaj564KXegqAHIAcDOylgBccNyhrWzcCHXX8kyHd81d6zeVrAZ5NEj0cUgs9X3aPVuBb0a7nf45lhmYUUZQTFGsjCbg408mqCvMT4NheESGWhArH+yzWgabsk4+fav0SAH3OpnVL5D2FBxkkBKbKx/7aa/AmDwMgronfRfDBJQued354L337awe7pBXlXHA6BO7ThumDHPch6n6qwytqQ4oEnaKoCcCgYO/d+/5TjiCWbo3FhQNzjicgj1z6Zm7OX4RkbfY5nJpdixp3JJzaKLtmyxp24cLy1SY+8ckVqdOvEPfPJyspLxkixDHQXqRyEi7/vJ7dAhbPACJ8Msr6bfMxg+geA15ei7D0n+JY5sMnqm/IM7A7oH5hvmhs0p3DHRzLcNPNOB9ieI1Em0KpQaTzyLdP+7XKK9ExgVSkK+IRBrey6NXwf4gFo3KJsDkzKYUJ/qMZjZdsAwpxXmRTLbJzMx8CqxEVz54R/H6OQTOHHksx1Jnyq9UzuNw/1UVFa3NkdDvVnN/mHtBeMWrJmWBqpMhzAoXsgi5btfDRIj6TLSKDQP4/7h5diDcRtdIt3ZRsOl6KvabSx8X0HnAljzE0M7AzO2BK50+76RtzAor2mc4wqv/TYYfk5EOfoXTIP5Xu2i+oRDP8EnaYR2pM5jaJn8m4V8Iz3XHt1Cr7qEuCep4q0gKUtxIRrXSxoqYKzJtbjryfnEkNTDXVX2YirAyeOtITN1QJHtv/GPaE09NGCcxvuJz51fPkBpVWa9WS5YaYXo5px6svVnCXWt8ip+yhhDjA28Hgepjy9oqoMaexfKBtnecoOJp0+8/xJPWUT6RlZDnMMraDgCfqBfHtuVnl5kMbZbAmuWVKI2n+ddhg/GaT23NQ6IATuv3XoZ1KCJu9JKgIbo9ULEgb1fnQVnYmDWPuVXAA5qIDg==

Cannot find module "..\call-me" from "/src/components/email-form"

Basically the generated Marko.js file creates the dependencies like below: (template.marko.js) 

  ___call_me_index_js = __renderer(require("..\call-me")),
      ___submit_button_index_js = __renderer(require("..\submit-button"));

Any pointer would be helpful.

Thanks
Rajesh
  Travis upgraded its infrastructure which allows CI tests to be ran in docker containers. The result is faster tests. 

To use it you just have to specify `sudo: false` in the travis CI.
 @patrick-steele-idem which build? The only thing that I saw that has failed recently was a rebuild that triggered on my PR after it was merged (which failed because the git ref that PRs point to are deleted after merge). 
  It might not be as simple as this, but one can hope, right?

The purpose of this change is to allow this to be written in the renderer

``` javascript
module.exports.tag = { name: "my-tag-name" }
```

That would result in the template being named to whatever was specified.
 So I'm looking for the proper location to place the renderer fixture that I use for the test. Should it just go in `test/fixtures/taglib`? Also, any preferred name for it?

**Edit**: It seems like there are no tests for renaming tags through `marko-tag.json` either. This PR would likely be a good place to go ahead and add that test as well. 
 I definitely still think it has value. I try to put as little as possible in `marko-taglib.json` or any `marko-tag.json`. With that being said I think basing it on the folder name that it's inside is a valid compromise. 

Ultimately if you keep the ability to set it in the `marko-tag` I think this PR should happen. If not, then it likely shouldn't. 

It's just nice to me:

``` javascript
export default defineComponent({
  name: 'gh-notification',
  template,
  ...
});
```
 Sounds good.
  The below line is not working in marko5 and I have tested the `$(document).append()` in some other pages and It is working fine . I think Marko interrupt this append method. Kindly let me know If you have any idea about this issue.

Testing append method:-

``` javascript
$(document).append($('<script>alert("")</script>'));
```

In js code:-

``` javascript
$(document).append($(response.inlineJs));
```
 The below function loads the inline js in the page and it is wrapped with script tag.
The below code is inside widget.js file .

``` javascript
loadInlineJs: function(response) {
        if (response && response.inlineJs) {
            $(document).append($(response.inlineJs));
        }
    }
```

eg:-

``` javascript

<script>(function(){})();</script>
```

It was working fine with marko4 and It is not working with marko5.
 ![image](https://cloud.githubusercontent.com/assets/286382/10465666/e5b2df4e-71a4-11e5-8b5a-680a647ca947.png)
  I want to use custom images in marko templates. But not able to find any documentation related this.
 Use just regular html tags 

`<img src="http://i.imgur.com/L7TM5P1.jpg">`
 That's great and totally makes sense for local images.

On a side note for lasso-image - Would be also great if it would deliver webp images if the browser supports it. Conversion might be too expensive ... just an idea.
  https://nodejs.org/api/globals.html#globals_require_extensions

Given that this method is deprecated, we might want to look into requiring .marko files differently. Maybe by handling compilation separately and then `require('template.marko.js')` instead?
  Hi:

I know that Marko "avoids evil global variables and global helpers", but I think I have a situation where they could be useful:

I'm using Marko in a Koa app. This app uses koa-locale which provides two methods: `this.__(key)`, which looks for the translated text by key, and `this.__getLocale()` which returns the selected language from URL, cookie, HTTP header, sub-domain, etc. So, I have a layout like this one:

```
<!doctype html>
<html lang="${out.global.__getLocale()}">
    <head>
        <meta charset="utf-8"/>
        <meta content="width=device-width" name="viewport"/>
        <link rel="stylesheet" href="styles.css"/>
        <title>${out.global.title}</title>
    </head>
    <body>
        <layout-placeholder name="content"/>
    </body>
</html>
```

With a view like:

```
<layout-use template="./boilerplate.marko">
    <layout-put into="content">
        <h1>${out.global.__('Welcome!')}</h1>
    </layout-put>
</layout-use>
```

And I use them as follow:

```
this.response.body = require('../templates/index.marko').renderSync({
    $global: {
        __: this.__.bind(this),
        __getLocale: this.__getLocale.bind(this),
        title: this.__('Welcome!')
    }
})
```

Of course, I don't want to pass `this.__()` and `this.__getLocale()` in every router, so I'm wondering if there is a better way to accomplish this.
 Currently I'm using `.renderSync()` just because I'm learning Marko. I plan to start rendering to an HTTP response directly. In any case I think my problem is that koa-locale does its work automatically.
In the first case, if I understand well, you pass the complete output to a helper that replaces some text with its translated version. As far as I know I can't do that because `__(key)` only receives the key to be replaced.

In the second case you are referring to require a JavaScript module, aren't you?

```
<require module="./util" var="util" />
```

The problem with that is that koa-locale receives the app instance as an argument and I don't see a way to do that inside a .marko file.

That's why I was wondering if there's is a a way to pass helpers to the compiled `__helpers` object, maybe before calling `.install()`.
 @patrick-steele-idem thanks for the transformer example!
 Hi again @patrick-steele-idem,

Thanks for your example, it makes things clearer, but you are still passing `i18n` to `$global` every time you render a template and that's why I'm trying to avoid because I'm pretty sure I will do that everywhere. Anyway I think it's just a minor drawback.
 Here must be some middleware for koa. Some thing like this:
https://gist.github.com/Globik/d612dce121de3e1cd996
For a global access to this.state. Any use for every global dynamic stuff like configurable menus, rubricas, categories etc
 @patrick-steele-idem I like your proposal of `i18n-var` so I tried to move it into my `tags-dir` without success:

`Error: Error while handling properties for /app/src/marko-taglib.json: Error while applying option of "tags-dir". Cause: Error: Invalid tag file: /app/src/components/i18n-var/marko-tag.json. Neither a renderer or a template was found for tag.`

marko-tag.json

```
{
    "@name": "identifier",
    "transformer": "./transformer.js"
}
```

This is the same definition [here](https://github.com/marko-js-samples/marko-koa-i18n/blob/master/src/marko-taglib.json#L3) - so shouldn't it work the same?
 Hi @patrick-steele-idem. Sorry for the delay and thanks for the input. Just for future reference in case someone has the same doubt: In the end I followed @Globik's advice. I have developed two projects using Koa and Marko in this way and I'm pretty happy with the result.
  This should resolve issues with circular dependency rendering. Previously, whenever this function was called, it would throw an error because `typeof renderFunc` was always `undefined`. With this fix, `rendererFunc` will (in valid cases) be a function.
  How do you envision this? I assume it would automatically
1) transform if/else/for syntax in all files
2) transform syntax for all custom tags
2) remove attribute references in marko-taglib.json files
4) delete marko-tag.json files

Anything else?
  Please review and merge :)
 Test pass locally :)
 Alright, will do :)
 Whenever I use expected and actual, I always end up in this strange situation:

``` sh
  1) render unless-else:
     Unexpected output for "/Users/kristianmandrup/repos/markoa/marko/test/fixtures/templates/unless-else/template.marko":
EXPECTED (/Users/kristianmandrup/repos/markoa/marko/test/fixtures/templates/unless-else/expected.html):
---------
B , A , A , <div>A</div>

---------
ACTUAL (/Users/kristianmandrup/repos/markoa/marko/test/fixtures/templates/unless-else/actual.html):
---------
B , A , A , <div>A</div>
```

I even copy paste the actual into expected, and still the same error! Must be a whitespace issue?
 I also get this warning

``` sh
    ‚úì if-else
WARN marko/runtime/helpers: data.invokeBody() deprecated. Use data.body instead. Error
    at Object.data.invokeBody (/Users/kristianmandrup/repos/markoa/marko/runtime/helpers.js:326:89)
    ‚úì include
```

From `include-nested-content.marko`

```
    <p>
        ${data.invokeBody()} <!-- deprecated -->
    </p>
```
 Yup exactly! Using Atom, haha :P Thanks for the tip. Now it works ;)
I recommend you enhance your string compare to trim trailing whitespace or at least have it as an option.
 Really, hmm... that was not my intention. Guess I made a Markdown error of some sort. 
I only inserted a few more examples in the relevant section. I'll fix that shortly.
 I just reviewed my changes and reverted what I think you call "stylistic changes". If you are still not happy, please edit as you like. I tried my best to improve the docs while keeping with the original intent and styling.
  Marko + koa currently misbehaves due to errors thrown during template stream rendering are uncaught, leading to hard crashes of node.

The sample code below illustrates a very simplied setup, and this patch ensures that errors during template rendering are indeed picked up by the koa error handling system.

```
// Simplified koa usage
app.use(function * () {
  this.type = 'text/plain'
  this.body = require('template.marko').stream({...})
})

app.on('error', function (err) {
  log.error(err) 
})
```

Thanks for an awesome piece of work. Marko+koa is my bread and butter...
 @patrick-steele-idem, I get your points regarding V8. 
The more idiomatic use of `render()` works well with Koa too, as in

```
app.use(function * () {
  template.render({...}, this.res)
})  
```

A simple change for me and I accept that as an answer :)

I think I have spotted an edge case here. Everything that goes down to Async-Writer/async-fragment seems to work super nice, It's just the initial synchronous invocation that needs some loving care. 
I'm still rather dependent on streams in some peculiar situations, so I will try to make a better PR respecting performance and also covering asynchronous situations.

Feel free to discard this PR ;)
  Would help clean up conditionals a lot :) 

`if='!loop.isLast()'` is kinda ugly and hard to notice those `!` exclamation marks.

``` jade
  for(each='item in data.list; status-var=loop"' if='data.list')
    ui-button(attrs='item')
    div(class='or' if='data.or' data-text='$data.or' unless='loop.isLast()')
```
 My PR has been merged! Thanks guys :)
  I was wondering if it is possible to load custom functions or even set one or more globals, such as `lodash` or `underscore` before "running" all the custom tags, in order to make these globals available for tags to use if needed (load once, use anywhere). 

Must be a very common use case ;) 
Thanks. 

In my case, I would like the following to be generally available for many of my tags:

``` js
String.prototype.capitalizeFirst = function() {
    return this.charAt(0).toUpperCase() + this.slice(1);
}
```
 Hi Patrick, thanks for your response. I was just curious if there was a way. Kind of like a base class or decorator for all renderers to leverage common functionality. So far I've been using `require` but can feel like duplication and I like to keep my prod code super slim and DRY. 
I guess I will just introduce a "compile step" of some sort to prepend or inject whatever code I want according to some global rules...
  Per email thread:

We probably need to look into a better way to prevent the same taglib from being loaded multiple times, but currently the Marko compiler walks up the directory tree to find taglibs and will happily load the "same" taglib multiple times if it is found multiple times in the search path. The marko-widgets taglib being loaded multiple times is causing the same template to be transformed multiple times and that is resulting in unexpected behavior. De-duping taglibs by module name would solve the problem.
 +1 facing the same issue
  Would really like if we had the ability to use the index on iteration somehow...
Here using the imaginary `index='pos'` `for` attribute (default `index='index')

``` jade
ui-grid(ui='inverted')
  ui-row(ui='green' list='data.users.header')
  for(each='item in data.users.list' index='pos')
    ui-row(ui='silver' attrs='item' if='pos % 2 == 0')
    ui-row(ui='blue' attrs='item' if='pos % 2 == 1')
```
 Sweet :) Learning every day...
  to allow for dynamic runtime tag name transformation :)

This will enable my https://github.com/kristianmandrup/marko-dynamic-tag to work :)
And loads of other powerful use cases...!!!
 Awesome :) I sure don't mind!!!
 Would it also be possible to dynamically decide which component (function I assume) to call using a similar approach?
 BTW: On the PR, all the tests passed on my local machine running `mocha`, so I was surprised to see it fail on Travis CI. 
 Exactly what I was thinking!!! :)
 In my scenario I would have an incoming list with varying types of data (ie. some attributes undefined)...
Depending on the data I what to render an appropriate tag, such as icon-item if it has an icon, link-item if there is a link and so on. Of course I could have a "catch all" item, but it would have to contain loads of conditional logic... the dynamic tag would come in very handy to make for a more elegant solution :)
Cheers!
 An example:

Here I decide whether to render a checkbox as a `toggle`, `slider`, or a normal `checkbox`. 
Not very elegant, but gets the work done :P

``` jade
ui-toggle(attrs='data' if='data.toggle')
ui-slider(attrs='data' if='data.slider')
div(class='$data.field field' body-only-if='!data.field' if='data.default')
  div(class='ui $data.ui checkbox' body-only-if='!data.ui')
    input.hidden(type='checkbox' name='$data.name' checked='$data.checked' tabindex='$data.tab')
    label(if='data.label') $data.label
```
 Sweet :) Thanks for the tip. Didn't even know you could do complex conditional logic inline like that :)
I agree, those tasks are way more important for now than these obscure bonus features!!!
Good job :) Looking better every day and every week :D
  I have the following template

``` html
<div class="ui list">
  <for each="item in data.list">
    $item.ui
    <icon-item attrs="item">
      <div tag-body="item.body" class="description"></div>
    </icon-item>
  </for>
</div>
```

with the following data"

``` js
[ { ui: 'large orange',
    icon: 'user',
    label: 'kmandrup',
    body: 'I DREAM in CODE' },
  { ui: 'large blue',
    icon: 'user',
    label: 'isaura',
    body: 'I LOVE web DESIGN' } ]
```

It correctly prints `large orange` and so on for `$item.ui` but for `<icon-item attrs="item"` no attributes are passed to the custom tag `icon-item`. Why is that?

In the docs for `attrs` it is used on a normal `div` tag, but I would have assumed I could also use this technique for custom tags??? Otherwise tag maintenance will quickly become very "fragile" IMO.

Even more convenient would be if I could somehow list the attributes I wanna transfer, then have marko use the schema to transfer and type convert values accordingly:

`use-attrs="item:name,icon,label"`
 Sweet :)
  With the coming standard ES6 loader support currently implemented in [SystemJS](https://github.com/systemjs/systemjs) & [jspm](http://jspm.io/) having a MarkoJS plugin would be great! Using the [SystemJS Handlebars](https://github.com/davis/plugin-hbs) plugin as a starter might be a good idea: 

**PS:** Since AMD support was [dropped](http://psteeleidem.com/announcing-marko/#switched-to-commonjs-modules-for-compiled-templates) by switching to CommonJS, I'm just wondering what's the currently recommended (non-Browserify!) recipe for using MarkoJS with AMD/RequireJS (including bundling/compiling) :question:
 10x for your detailed answers. So ... no easy AMD/RequireJS MarkoJS integration here :worried: 
Anyhow, I'm currently looking into the maturing SystemJS/jspm since aside of supporting any module format (AMD, CommonJS, global, ES6, System/register) and native-transpilers (TypeScript, Babel, Traceur) it is future-proof being the (single AFAIK) reference implementation/polyfill of the ES6 module loader. 
If time permits I'll look into creating a **plugin-marko** plugin & bundler for MarkoJS integration.
 I've been mulling over which cool new thing to ditch from my project: jspm or marko. 

Marko wins :+1: (i.e. it's not getting ditched)
  It works just fine, except html equality test breaks even though I copy paste `actual.html` and `expected.html` to match!?. 

See `test/fixtures/templates/tag-body`
 Awesome! Much better :) Thanks a lot! 

Of course this solution is just excellent! I learned a lot from my experiments, and this little helper lib you made clearly demonstrates how to enhance Marko in an elegant way!!! 

Have a nice evening @patrick-steele-idem  :)
 Cool :) Yeah, next step IMO is to improve the documentation some more. 
Perhaps by going away from having everything in one huge README? A github "blog/page" or wiki?
 On another note, I was wondering if there is a way to dynamically generate the tag name, such that:

``` html
h1(class='ui header' tag-body='data.label' if='data.lv == 1')
h2(class='ui header' tag-body='data.label' if='data.lv == 2')
h3(class='ui header' tag-body='data.label' if='data.lv > 2')
```

Could be rewritten something like

``` html
<dynamic-tag tag-name='h${data.lv}' class='ui header' tag-body='data.label'/>
```

Would love to have another small lib like the one you created for this use case :)
 I would think I could achieve this something like this?

``` js
module.exports = function transform(node, compiler, template) {
    var name = node.getAttribute('tag-name');
    if (name != null) {
        node.removeAttribute('tag-name');
        var tagNode = this.compiler.createNode(name, node.getAttributes());

        node.parentNode.replaceChild(tagNode, node);
        node.forEachChild(function(child) {
          tagNode.appendChild(child);
        })
    }
};
```
 Fuck, I spent all morning trying to figure out how to evaluate an expression :P
Like trying to find a needle in a haystack... and looks like I don't have the data on the template at this stage?
I think the "replace tag name" should be done in the `doGenerateCode` somehow in order to have access to template data? I'm lost again...

I get this: If only I could substitute the template data on this string as a "template" and write it to `out`.

`<h$data.lv>hello world</h$data.lv>`
  I have an accordion tag like this `<div w-body="" class="ui $data.ui accordion"></div>`

When I use it like:

``` html
    <ui-accordion>
      <acc-block active="true" label="Yeah" text="hello world"></acc-block>
    </ui-accordion>
```

It compiles to:

``` js
function create(__helpers) {
  var str = __helpers.s,
      empty = __helpers.e,
      notEmpty = __helpers.ne,
      escapeXmlAttr = __helpers.xa;

  return function render(data, out) {
    out.w('<div w-body class="ui ' +
      escapeXmlAttr(data.ui) +
      ' accordion"></div>');
  };
}
(module.exports = require("marko").c(__filename)).c(create);
```

and so, renders:

`<div w-body="" class="ui  accordion"></div>`

I would have thought the compiler would use `w-body` attribute to understand, that the (internal) body tags of the accordion tag should be inserted as children to the container tag to build up the accordion?

``` js
    /// accordion start tag
    if (input.renderBody) {
        input.renderBody(out);
    }
    /// accordion end tag
```
 oh, I thought w-bind was only required for widgets? This is just a custom tag
 With `w-bind` I get:

``` js
  return function render(data, out) {
    out.w('<div w-body w-bind class="ui ' +
      escapeXmlAttr(data.ui) +
      ' accordion"></div>');
  };
```

So this only works for widgets then?
 why not enable `w-body` for tags? why have two different ways of achieving the same?
 Great! it works :) But then the marko docs need to be updated to reflect this.

https://github.com/marko-js/marko/#tag-renderer
 Why not make some kind of convenience attribute or tag like w-body for this common use case at least? 
<tag-body>
 Fx `<tag-body/>`, which simply calls `<invoke function="data.renderBody(out)" if="data.renderBody"/>`
 Trying to patch this fix in marko

`core-tag-transformer.js`

``` js
var BodyNode = require('./BodyNode');
...
    [
        'tag-body', function(attr, node) {
            console.log('tag-body attr');
            var bodyNode = this.compiler.createNode(BodyNode, {
                    renderBody: true,
                    pos: node.getPosition()
                });
            node.parentNode.replaceChild(bodyNode, node);
            bodyNode.appendChild(node);
        }
    ],
```

`BodyNode.js`

``` js
'use strict';
function BodyNode(props) {
    BodyNode.$super.call(this, 'tag-body');
    if (props) {
        this.setProperties(props);
    }
}
BodyNode.prototype = {
    doGenerateCode: function (template) {
      template.statement('').indent(function () {
          this.generateCodeForChildren(template);
      }, this).line('');
    }
};

module.exports = BodyNode;
```

`accordion-tag.marko`

``` html
<div class='container' tag-body=''>
</div>
```

`accordion-tag.js`

``` js
var template = require('./accordion-tag.marko');

exports.renderer = function(input, out) {
  console.log('accordion input', input);
  template.render(input, out);
};
```

`accordion-tag.json`

``` js
{
    "renderer": "./accordion-tag.js"
}
```

`marko-taglib.json`

``` json
...
        "test-accordion": "taglib/accordion-tag.json",
```

``` html
<test-accordion>
  <h3>I'm your Buddy</h3>
</test-accordion>
```

What am I missing? I really don't like the idea of having to pollute my tags 
with `<invoke` everywhere...

It generates this:

``` js
  return function render(data, out) {
    __tag(out,
      ______taglib_accordion_tag_js,
      {},
      function(out) {
        out.w('<h3>I\'m your Buddy</h3>');
      });
  };
}
```

So I guess I just need to make the inner body output function self-calling!?
 And I even try this, trying to simply wrap the InvokeNode invocation directly...

``` js
var InvokeNode = require('./InvokeNode');

function BodyNode(props) {
    console.log('BodyNode', props);
    return InvokeNode({function: "data.renderBody(out)", if: "data.renderBody"});
}

module.exports = BodyNode;
```
 Yeah, I know, but still... I'm just trying to understand some of the marko internals. 
Why won't this work?

``` js
'use strict';

var InvokeNode = require('./InvokeNode');

function BodyNode(props) {
  console.log('BodyNode', props);
  InvokeNode(props);
}

module.exports = BodyNode;
```

Looks like a pretty logical way to wrap `<invoke>` tag to me...

``` js
        'tag-body', function(attr, node) {
            var bodyNode = this.compiler.createNode(BodyNode, {
                    function: "data.renderBody(out)",
                    if: "data.renderBody",
                    pos: node.getPosition()
                });
            console.log('bodyNode', bodyNode);
            node.parentNode.replaceChild(bodyNode, node);
            bodyNode.appendChild(node);
        }
```
 Thanks ;) I give up for now... tried all the ways I could think of.
 Haha ;) As always, when I finally gave up a saw the light, and now I got it working in elegant fashion, exactly  like wanted to :)

Pure and simple!

``` js
    [
        'tag-body', function(attr, node) {
            // node.setAttribute('renderBody', true, false);
            var invokeNode = this.compiler.createNode(InvokeNode, {
                    function: "data.renderBody(out)",
                    if: "data.renderBody",
                    pos: node.getPosition()
                });
            node.appendChild(invokeNode);
        }
    ],
```
 My only problem is the test:

``` sh
  1 failing

  1) render tag-body:
     Unexpected output for "/Users/kristianmandrup/repos/markoa/marko/test/fixtures/templates/tag-body/template.marko":
EXPECTED (/Users/kristianmandrup/repos/markoa/marko/test/fixtures/templates/tag-body/expected.html):
---------
<div class="container"><h3>I'm your Buddy</h3></div>

---------
ACTUAL (/Users/kristianmandrup/repos/markoa/marko/test/fixtures/templates/tag-body/actual.html):
---------
<div class="container"><h3>I'm your Buddy</h3></div>
---------
  Error: Unexpected output for "test/fixtures/templates/tag-body/template.marko":
  EXPECTED (test/fixtures/templates/tag-body/expected.html):
  ---------
  <div class="container"><h3>I'm your Buddy</h3></div>

  ---------
  ACTUAL (test/fixtures/templates/tag-body/actual.html):
  ---------
  <div class="container"><h3>I'm your Buddy</h3></div>
  ---------
      at EventEmitter.<anonymous> (test/util.js:72:27)
      at testRender (test/util.js:90:14)
      at Context.<anonymous> (test/util.js:116:13)
```

Very strange!?
  I'm writing a huge set of taglibs to wrap all of Semantic UI. 
Problem is that if I/when make any mistake, no taglibs seem be loaded and no errors are shown in the console either. 

I'm trying to heavily leverage taglib imports:

``` js
{
  "tags-dir": ".",
  "taglib-imports": [
    "./list/marko-taglib.json"
  ]  
}
```

In my real scenario, there would be ~20 taglibs imported.
Is there a way to turn on some kind of debugging, logging of how marko resolves the taglibs and where it gives up? This is becoming a real PAIN to me :(
Thanks :)
 I tried cloning marko, npm linking it and then inserting debug statements...

``` sh
Marko appplication ready on port 4000
[browser-refresh] Server is ready. Watching files for changes.
[browser-refresh] Triggering refresh of client pages...
[browser-refresh] Refresh triggered
page state { title: 'Repo manager',
  header: 'Repo manager',
  content: 'Hello',
  lists: { users: [ [Object], [Object] ] } }
template data { title: 'Repo manager',
  header: 'Repo manager',
  content: 'Hello',
  lists: { users: [ [Object], [Object] ] } }
rendering template: /Users/kristianmandrup/repos/test123/repo-manager-v3/apps/index/page/index.marko
state: { title: 'Repo manager',
  header: 'Repo manager',
  content: 'Hello',
  lists: { users: [ [Object], [Object] ] },
  '$global': 
   { menus: { main: [Object], session: [Object] },
     lists: { repos: [Object], teams: [Object], users: [Object] },
     feeds: { activity: [Object] },
     appName: 'Repo Manager v3' } }
loadTagLib /Users/kristianmandrup/repos/markoa/marko/taglibs/core/marko-taglib.json
loadTagLib /Users/kristianmandrup/repos/markoa/marko/taglibs/html/marko-taglib.json
loadTagLib /Users/kristianmandrup/repos/markoa/marko/taglibs/caching/marko-taglib.json
loadTagLib /Users/kristianmandrup/repos/markoa/marko/node_modules/marko-layout/marko-taglib.json
loadTagLib /Users/kristianmandrup/repos/markoa/marko/node_modules/marko-async/marko-taglib.json
```

But my own custom taglibs are NEVER loaded it seems?

``` js
    tagsDir: function(dir) {
        // The "tags-dir" property is used to supporting scanning
        // of a directory to discover custom tags. Scanning a directory
        // is a much simpler way for a developer to create custom tags.
        // Only one tag is allowed per directory and the directory name
        // corresponds to the tag name. We only search for directories
        // one level deep.
        var taglib = this.taglib;
        var path = this.path;
        var dirname = this.dirname;
        // TAGLIB DIR
        console.log('tagsDir', dir);
        if (Array.isArray(dir)) {
            for (var i = 0; i < dir.length; i++) {
                scanTagsDir(path, dirname, dir[i], taglib);
            }
        } else {
            scanTagsDir(path, dirname, dir, taglib);
        }
    },

    taglibImports: function(imports) {
        // The "taglib-imports" property allows another taglib to be imported
        // into this taglib so that the tags defined in the imported taglib
        // will be part of this taglib.
        //
        // NOTE: If a taglib import refers to a package.json file then we read
        //       the package.json file and automatically import *all* of the
        //       taglibs from the installed modules found in the "dependencies"
        //       section
        var taglib = this.taglib;
        var dirname = this.dirname;
        var importPath;
        var resolveFrom = require('resolve-from');
        // ITERATE
        console.log('imports', imports);
        if (imports && Array.isArray(imports)) {
            for (var i=0; i<imports.length; i++) {
                var curImport = imports[i];
                // CURRENT
                console.log('import', curImport);
                if (typeof curImport === 'string') {

                    } else {
                        importPath = resolveFrom(dirname, curImport);
                        // ADDED
                        console.log('taglib.addImport', importPath);
                        taglib.addImport(importPath);
                    }
...
```

Please provide much better documentation on this feature and guidance on how to debug issues with resolution of tags and taglibs.  
 I simply don't understand how to interpret the documentation on this. Does marko ONLY use the first `marko-taglib.json` it encounters as it travels up the path, or does it resolve all taglibs that it finds on its way? What if multiple taglibs import the same other taglibs? etc. etc?

In my scenario I have the following structure:

``` sh
apps
  /_global
    /components
      /list
        /ui-list (tag)
          template.marko
          ...
       marko-taglib.json `tags-dir: '.'`
    marko-taglib.json `taglib-imports: [ './list/marko-taglib.json', ...]`
 marko-taglib.json `taglib-imports: [ './components/marko-taglib.json']`  

  /index
   /components
     ...
    /page
     index.marko (references `ui-list` tag)
   marko-taglib.json `tags-dir: './components'`
```

Should I also reference the global taglib from the index taglib, or will it auto-resolve as it goes up?
I had it working until I introduced the extra level in the components folder in order to group tags by type/category. Why!? Im lost...
 Looks like the problem is in part caused by using `browser-refresh` :O
With some more debugging in the taglibs compiler (which is in BIG NEED of REFACTORING!!!)

``` sh
taglib lookup: buildLookup /Users/kristianmandrup/repos/test123/repo-manager-v3/apps/_global/components/icon-item
tryDir /Users/kristianmandrup/repos/test123/repo-manager-v3/apps/_global/components/icon-item/marko-taglib.json
tryDir /Users/kristianmandrup/repos/test123/repo-manager-v3/apps/_global/components/marko-taglib.json
tryDir /Users/kristianmandrup/repos/test123/repo-manager-v3/apps/_global/marko-taglib.json
tryDir /Users/kristianmandrup/repos/test123/repo-manager-v3/apps/marko-taglib.json
tryDir /Users/kristianmandrup/repos/test123/repo-manager-v3/marko-taglib.json
tryDir /Users/kristianmandrup/repos/test123/marko-taglib.json
tryDir /Users/kristianmandrup/repos/marko-taglib.json
tryDir /Users/kristianmandrup/marko-taglib.json
tryDir /Users/marko-taglib.json
tryDir /marko-taglib.json
taglib lookup: buildLookup /Users/kristianmandrup/repos/test123/repo-manager-v3/apps/_global/components/ui-icon
tryDir /Users/kristianmandrup/repos/test123/repo-manager-v3/apps/_global/components/ui-icon/marko-taglib.json
tryDir /Users/kristianmandrup/repos/test123/repo-manager-v3/apps/_global/components/marko-taglib.json
tryDir /Users/kristianmandrup/repos/test123/repo-manager-v3/apps/_global/marko-taglib.json
tryDir /Users/kristianmandrup/repos/test123/repo-manager-v3/apps/marko-taglib.json
tryDir /Users/kristianmandrup/repos/test123/repo-manager-v3/marko-taglib.json
tryDir /Users/kristianmandrup/repos/test123/marko-taglib.json
tryDir /Users/kristianmandrup/repos/marko-taglib.json
tryDir /Users/kristianmandrup/marko-taglib.json
tryDir /Users/marko-taglib.json
tryDir /marko-taglib.json
```
 My conclusion so far: You can only import at ONE level. You CANNOT currently have a taglib which imports a taglib which imports yet another taglib. But WHY this LIMIT!? Is just a basic recursive model...
 By going through the code I can see that it seems it is not currently setup to allow this. It assumes any imported taglib is a "leaf" taglib apparently...

``` js
exports.loadTaglib = function(path) {
    console.log('loadTagLib', path);
    var taglibProps = taglibReader.readTaglib(path);

    var taglib = new Taglib(path);
    taglib.addInputFile(path);
```

I'm completely baffled!!! This ruins my whole design... I simply can't believe it. Please help me resolve this bug ASAP. Thanks :)
 Was a hunch. But no. However I ran into a caching issue as well. If I had a taglib, importing another taglib which referenced a tag dir, the final taglib did not resolve until I inserted a space in that taglib and saved.
 Thanks :) Please make a test case to cover my issue. I would love to help out myself. This is bugging me down...
 I just sent you a zip with a fixture for this scenario.
 and here my attempt at testing taglib imports (currently NO test coverage)

`taglib-imports-test.js`

``` js
'use strict';
var chai = require('chai');
chai.Assertion.includeStack = true;
require('chai').should();
var expect = require('chai').expect;
var nodePath = require('path');

describe('taglib-lookup' , function() {

    beforeEach(function(done) {
        for (var k in require.cache) {
            if (require.cache.hasOwnProperty(k)) {
                delete require.cache[k];
            }
        }

        done();
    });

    it('should lookup taglibs with nested-import', function() {
      var taglibLookup = require('../compiler').taglibs.lookup;
      var lookup = taglibLookup.buildLookup(nodePath.join(__dirname, 'fixtures/nested-import'));
      console.log('lookup', lookup);
      // NOT SURE WHAT TO TEST FOR FROM HERE
    });
});
```
 Awesome! I can hardly believe it :) Thanks a million @patrick-steele-idem :)
 Would be even better if there was a way to add some kind of basic logging for taglib and tag resolution somehow ;) 
 I tried it out. Still doesn't work. In my case, for some reason it never even calls `handleImports`.
I added a console log directly to the `node_modules/marko/compiler/taglibs/taglib-lookup.js`

Seems like marko "stalls" before ever starting to resolve even my first taglib, never ever calling `tagDir` for some reason :( And this stalling only occurs when I have nested taglibs like in the example I sent. Strange indeed!
 Thanks. Just tried it. Still same problem.
 I have the exactly the setup I described above.

A page `index.marko` referencing a tag `icon-list`
Then a `marko-taglib.json` in parent folder referencing "internal" taglib to the page via `tags-dir`, then one level further up, a taglib, importing the global components via `taglib-imports`. From here it gets tricky. 
In `global/components/marko-taglib.json`, if I only use `tags-dir` everything "just works". However if I use `taglib-imports`, the lookup only looks up the pre-registered taglibs and never even attempts to find my own taglibs.

``` js
function buildLookup(dirname) {
  var taglibs = taglibFinder.find(dirname, exports.registeredTaglibs);
  ...
```

Never goes beyond `exports.registeredTaglibs` for some reason!?

``` js
    var lookup = lookupCache[lookupCacheKey];
    if (lookup === undefined) {
          // do your magic
```

For some reason `lookup` is NOT undefined!? in this case or what? hmm...
 Not crashing, just never trying to resolve any tag libs not pre-registered. 
PS: How would I preregister my own taglibs? Perhaps better/easier to use the `package.json` import strategy? They are global components after all...
 no, all is local. I'm using latest master. `buildLookup` is never called. What is the entry point?

``` js
function buildLookup(dirname) {
    console.log('buildLookup', dirname);
```

TemplateCompiler never called either? Something is VERY fishy!

``` js
function TemplateCompiler(path, options) {
    this.dirname = nodePath.dirname(path);
    this.path = path;
    this.taglibs = taglibs.buildLookup(this.dirname);
```
 Yeah, I run with `MARKO_CLEAN=true node .` each time. Neither `compile` nor `compileFile` of `marko-compiler.js` are being called :P
 But when I move my `icon-list` tag up to the next level of tag libs (ie. not nested anymore) - everything works again, template is compiled etc:

Problem is when I put my template at `apps/_global/components/list/ui-icon/template.marko`
ie. inside `list` folder. I wonder if somehow list is a reserved name or sth very strange?!

``` sh
createCompiler /Users/kristianmandrup/repos/test123/repo-manager-v3/apps/_global/components/ui-icon/template.marko
TemplateCompiler path /Users/kristianmandrup/repos/test123/repo-manager-v3/apps/_global/components/ui-icon/template.marko
buildLookup /Users/kristianmandrup/repos/test123/repo-manager-v3/apps/_global/components/ui-icon
lookup /Users/kristianmandrup/repos/test123/repo-manager-v3/apps/_global/components/marko-taglib.json,/Users/kristianmandrup/repos/test123/repo-manager-v3/apps/marko-taglib.json,markoa-skeleton-app,browser-refresh-taglib,marko-core,marko-html,marko-caching,marko-layout,marko-async { merged: 
   { path: '/Users/kristianmandrup/repos/test123/repo-manager-v3/node_modules/marko/node_modules/marko-async/marko-taglib.json',
```
 How can we make a test for this?
 ``` js
if (process.env.MARKO_CLEAN === '' || process.env.MARKO_CLEAN === 'true') {
    defaultOptions.checkUpToDate = false;
}
```

So the problem could be in this "up to date" logic I guess?
 It operates on taglibs to determine if they have been updated...

``` js
exports.getLastModified = function(sourceFile, taglibs) {
    var statSource = fs.statSync(sourceFile);
    var lastModifiedTime = statSource.mtime.getTime();
    var taglibFiles = taglibs.getInputFiles();

    ...
    // Now check if any of the taglib files have been modified after the target file was generated
```

I think this is a naive check, and that is the problem. Only checks first level taglibs, again not recursive :P
 Yes, NO templates are compiled when I have nested taglibs for some strange reason... trying to figure out why/where it decided to skip this step.
 Doesn't even call `checkUpToDate` :O

``` js
 checkUpToDate: function(targetFile) {
    console.log('checkUpToDate', targetFile);
```
 What is top level entry point to start compilation or decide whether to compile template?

`module.exports = function load(templatePath) {` in `loader.js` perhaps?
 Thanks for all your assistance :)
  In the `marko-widget` docs, you use the following to indicate the placeholder for contained body content:

`<span w-body></span>`

"used to determine the nested external content that is to be injected into the body of the UI component (to support transclusion). The actual injection point is determined by the `w-body` attribute."

Can I use this for regular tags as well? If so, please document use in this project as well ;)
What is a valid attribute value for `w-body` if one must be provided for whatever reason?
 Answer from https://github.com/marko-js/marko-widgets

If it helps, an attribute with no value is equivalent to an attribute with a value of an empty string:

`<span w-body></span> === <span w-body=""></span>`

The purpose of the `w-body` attribute is to support transclusion. If the user of a custom tag nested content inside the custom tag then that content will get injected into the output HTML relative to the `w-body` marker. In addition, if the widget rerenders then the body content will be preserved (since that content is external to the widget). For example, below is the usage of a custom tag with nested content:

``` html
<my-awesome-component>
    This is nested content that will be injected into the `w-body` element.
</my-awesome-component>
```
 Yeah, was a way to add docs via a FAQ entry using an issue :P

Please make a note in tag-renderer section that the `w-body` attribute can be used in the marko template for the same effect as `renderBody(out)`. That would connect the dots I think. 
Thanks :)
 @kristianmandrup please see the PR if it fits your needs....
    Fixes https://github.com/marko-js/marko-widgets/issues/64
 fixes: https://github.com/marko-js/marko/issues/15
   thanks. happy to be part of a great team!
  I pass an array of the form:

``` js
[
{label: 'my label', icon: 'users'},
{label: 'extra', icon: 'feed'},
]
```

`index.marko`

``` html
<icon-list items="${data.items}"/>
```

`icon-list.marko`

``` html
<for each="item in $data.items">
  $item.label
</for>
```

But when I debug, I get a strange '*': entry as my first key!? WTF!?

`list { '*': { items: [ [Object], [Object] ] } }`

Looks like it should be `data` in this case (`for each`) without the `$` sign. 
Not clear from the docs IMO.

``` html
<for each="item in data.items">
  $item.label
</for>
```

Now we get an error about some strange error, 'unexpected token {'  Damn!
 Thanks, I figured that was the issue, since I had seen a brief mention somewhere about the `@*` being a "catch all" in your docs about the schema. But wasn't really clear that not declaring the schema value would cause this kind of problem. I guess when you go beyond strings, you currently have to specify the schema carefully in order to make marko understand. Kinda makes sense. I posted my solution/suggestion for proposal #90 which would make it awesome!!
  I think it comes down to a missing dependency or something, but would be nice with a clearer error message than this:

the `marko-taglib.json` it complains about.

``` json
{
    "tags-dir": "./_global/components"
}
```

Confusing error message:

``` sh
Error: Error while handling properties for /home/isaura/tecla5/repo-manager-v2/apps/marko-taglib.json: Error while applying option of "tags-dir". Cause: SyntaxError: Unexpected token }
      at Object.parse (native)
      at scanTagsDir (/home/isaura/tecla5/repo-manager-v2/node_modules/marko/compiler/taglibs/taglib-loader/scanTagsDir.js:66:27)
      at Object.TaglibHandlers.tagsDir (/home/isaura/tecla5/repo-manager-v2/node_modules/marko/compiler/taglibs/taglib-loader/loader-taglib.js:134:13)
      at invokeHandlers (/home/isaura/tecla5/repo-manager-v2/node_modules/marko/node_modules/property-handlers/lib/index.js:66:29)
      at Object.exports.loadTaglib (/home/isaura/tecla5/repo-manager-v2/node_modules/marko/compiler/taglibs/taglib-loader/loader-taglib.js:257:5)
```
 Awesome :) Gracias amigo! When do you expect a Marko Widgets 5.0 release? 1wk, 2wks, more?
  It keeps downloading the file. this is the gist of my code.

``` js
'use strict';
let koa    = require('koa')
let app    = koa()
app.use(function* () {
    this.body = require('marko').load(require.resolve('./views/index.marko')).stream()
    this.type = 'type/html'
})
app.listen(3000);
```

Whenever I navigate to localhost:3000/, it downloads a file with "hello" in it. I have no idea what's happening or what I'm doing wrong.

views/index.marko is just 

``` html
hello
```

right now.
 No, that. was a good thought, but unfortunately that did not solve my problem. It is still just downloading the file.
 omg...I hate when it's a stupid error like this...had to change `type/html` to `text/html`

Thanks for your help!
 So is correct: this.type = "html";
 Your marko is "simple" enough, but how do I build a binary tree with marko? In ejs template I can just like so using pure javascript write helper functions for a tree hierarchy inner <% functinon buildTree(root){ var html="blablabla"; return html;}%> <%- buildTree(someRoot)%>. But with marko I don't understand how to do it like this. Where is marko's tutos can i find?
 Many, many thanks, it's just incredible!
  Hello team,

I was wondering if there is any way to access messages set with flash using the following api.

``` javascript
req.flash('success', 'Account Created Successfully!');
```

is it `${flash}`? or something else within a `.marko` file?

Thank you.

Deep
 Thank you! That worked!!

Now I have a debug question. I am getting a 500 error when trying to do the following:

`<require module="../private_libraries/globals_v1.js" var="globals"/>`
`<if test="!globals.isEmpty(data.messages)">Not Empty</if>`

```
// globals_v1.js
exports.isEmpty = function (obj) {
for(var prop in obj) {
    if(obj.hasOwnProperty(prop))
        return false;
}

return true;
};
```

where data.messages is being passed in as the flashMessage. isEmpty is a function that runs through that object to make sure nothing is contained in that data.messages object, but I'm getting a 500.

Any ideas on how to resolve and/or better yet, debug that 500? there are no messages that get spit out besides the 500 error result.

Thank you.

Deep
 Hello Patryk, will comment here because I have a related question.
What if the flash messages are sent before a

```
res.redirect('/');
```

?

In this case how can I pass the parameter to the .marko layout since I am not calling the render method?
  The utility function `getLength()` for loop status variables was previously undocumented.
  I tried to add:

``` json
 "marko": {
  "extends": "html"
}
```

but no luck...
  I'm planning to leverage Jade to make it easier/faster to write the marko templates...

So far I've uncovered the following special marko and lasso tags:

```
<if
<include
<require
<var
<assign
<with
<else-if
<else>
<for
<def
<invoke
<layout-placeholder
<layout-use
<layout-put
<lasso-page
<lasso-head
<lasso-body
```

Am I missing any important pieces? Looks like [pencil](https://www.npmjs.com/package/pencil) would make it pretty easy to add such custom tags to Jade and then I can have a `gulp watch` task auto-compile to marko. Sweet :)
    es6 template strings use the format ${expression}

I was wondering if marko can handle this (apparent) conflict? Sorry if I missed something in the docs.
 Great. Thanks for the response!
  Please add a way to programmatically add specific folders to perform `Taglib Discovery` in order not to be forced to rely on node default search strategy. Something like:

`marko.taglibs.discovery([myTaglibsPath, myOtherTaglibsPath, ...]);`

Thanks :)
 Thanks :) Trying to make sense of this...

Various "clever" ways for using taglibs:

``` js
{
    "<my-hello>": {
        "renderer": "./hello-renderer",
        "@name": "string"
    }
}
```

Importing other taglibs :)

``` js
taglibImports: function(imports) {
    // The "taglib-imports" property allows another taglib to be imported
    // into this taglib so that the tags defined in the imported taglib
    // will be part of this taglib.
    //
    // NOTE: If a taglib import refers to a package.json file then we read
    //       the package.json file and automatically import *all* of the
    //       taglibs from the installed modules found in the "dependencies"
    //       section
```

The "normal" way

`importPath = resolveFrom(dirname, dependencyName + '/marko-taglib.json')`

Trying to combine local with global/shared taglibs

``` js
{
  tagsDir: './my-tags',
  taglibImports: ['../../package.json']
}
```

// package.json

``` js
{
  dependencies: {
    // how does the import expect to find taglibs from external module??
    // what are the conventions in this case!?
    'my-global-taglib': 'x',
    ...
  }
}
```

Another proposal - direct require (why traverse all dependencies?)

``` js
{
  tagsDir: './my-tags',
  // refers to a package in my package.json
  // why not require module directly? (ie. not local since not prefixed by ./ )
  taglibImports: ['my-global-taglib', 'my-other-shared-taglib-module']
}
```
 Hi, 

I'm trying to use the `taglib-import` feature as I really need it now. I think I understand the `package.json` mechanism, but not sure about the `else` part, line `176`. What should be at `./_global/components/menu` for this to work? I assume resolveFrom it just a special wrapper for node `require` using `curImport` as the base path?

``` js
else
  importPath = resolveFrom(dirname, curImport);
  taglib.addImport(importPath);
```

``` json
{
    "tags-dir": ".components",
    "taglib-imports": [
      "./components/menu",
      ...
    ]
}
```

My target file structure

``` sh
/components
  /my-comp
  /menu
    /other-comp
```
 I got it, must be `"./components/menu/marko-taglib.json"`, however why not assume that by default given a path without it? At least it works for me now. So cool :)
  i make layout file

``` html
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<%@ taglib prefix="sec" uri="http://www.springframework.org/security/tags" %>
<%@ taglib prefix="spring" uri="http://www.springframework.org/tags" %>
<%

%>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title></title>
</head>
<body>

</body>
</html>
```

and run `marko`

this is result

``` html
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<%@ taglib prefix="sec" uri="http://www.springframework.org/security/tags" %>
<%@ taglib prefix="spring" uri="http://www.springframework.org/tags" %>
<% %>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title></title>
</head>
<body>


</body>
</html></%></%@></%@></%@>
```

i want to ignore the tag ( `<%`, `<%@` ). Is there a possibility that does not analyze the specific tag?
 Thank you very much~~ :+1: 
  unless i'm missing something, it seems all compiled files are created in the same directory / path as the template sources.

this means having additional complex rules for `.gitignore` in cases where `.marko` is not used as the extension!

would be a lot simpler to store all compiled files (under the same directory tree) starting a temp root path, that can be easily cleared / deleted as needed, and can be simply ignored from the project/repository version control. 
 > the Marko compiler puts the compiled templates next to the original template because the Node.js module loader is context aware and we want the stack traces to match up with location that the Node.js module loader associates with the loaded compiled template

fully agree with this _(just wanted to be clear)_

> While we could place the compiled template at a different location on disk, we would need to change how the relative require paths are generated. 

I have not looked at the internals _\- yet -_, but in theory, should be done in such a way that changing the `cwd` or `root` would be sufficient. 

your example is exactly what I'm interested in. but I would also add that each module (and module maintainer, whether internal or external) should be free to determine the best setup for that module.

I'm guessing your basing your use-case on a hierarchy of modules used within one system, but the moment you go out of the scope of the one system then the module wouldn't know where to look for its compiled templates.

so it's best to keep the separation between modules to ensure true portability of the module itself.

that of course would become complicated if you're doing template dependencies between modules, but rather than solve that problem a better pattern would be to have only the main / root module be responsible for compiling, and if there are dependant module templates, they are simply pointed to, and the compiled output is stored elsewhere.

###### example

for this module, the package maintainer chooses to store in a folder `.marko-compiled-location-a`, this is only relevant when that module is used on its own.

```
my-installed-module/
    .marko-compiled-location-a/
        foo/
            template.marko.js
        bar/
            template.marko.js
    foo/
        template.marko
    bar/
        template.marko
```

but when the module is used as a dependency of another system, the dependant chooses where the final compiled files should live:

```
my-app/
    .marko-compiled/
        foo/
            template.marko.js
        bar/
            template.marko.js
        .marko-dependants/
            foo/
                template.marko.js
            bar/
                template.marko.js
    foo/
        template.marko
    bar/
        template.marko
    node_modules/
        my-installed-module/
            foo/
                template.marko
            bar/
                template.marko
```

again, not sure what the best path design here would be, but, with the current setup, it makes it very noisy (for simple usage like static site building) and cumbersome with server-side live systems, especially if you're doing live reloading of the application, your template changes may not get refreshed.
 yes indeed this does satisfy the ask here :+1: 

wish there was a cleaner way to set this option though ..
 I have to play around with it more first ... I'm thinking this should be done on the main include:

``` js
var marko = require('marko')
marko.compiler({
  ...
})
```

or 

``` js
marko.compilerConfig = {
  ...
}
```

etc ..
 @ahmadnassri If you're using Express JS, there could be a cleaner way to define configuration with an API similar to what I've proposed in #165. If there was a Marko Express plugin, when initializing the engine you could pass configuration options to Marko similar to how defined them above...

``` javascript
var Marko = require("marko-express"); // example lib name
app.engine("marko", Marko({ writeToDisk: false }));
app.set("view engine", "marko");
```
 not using express for this particular project (It's a static site builder, no server required), though that example makes sense.
  I am creating `grunt marko plugin'
https://github.com/thomasJang/grunt-ax-marko

i have question. can i change marko-taglib.json path?
i know marko-taglib.json is same template path
 i'm sorry @patrick-steele-idem 
can be changed to another location, not the position determined the location of a file
 There is no big problem.It can be used now as.

However, if you want to place the resources and content, such as preferences for `java` project to another space may become a problem.
Also, in the case of the I, as follows, when you try to be able to set the location of each of the environment file it seems to be a problem.

https://www.npmjs.com/package/grunt-ax-marko#overview

``` js
grunt.initConfig({
    ax_marko: {
        default: {
            options: {
                preserveWhitespace: true // expected output whitespace 
            },
            files: [
                {
                    src: "test/fixtures/*.html",
                    global_data: { // append data 
                        layout_path: "../layouts/basic.marko" // src relative path 
                    },
                    lang: {
                        ko: "test/lang/ko.json",
                        en: "test/lang/en.json"
                    },
                    dest: "test/expected",
                    output_extension: "html"
                }
            ]
        }
    },
});
```

Have met in such highly-level project is sincerely happy.
I is JSUI developers. Opportunity I want to make even UI in which the `marko` to base if.
  i try 

``` js
tmpl.render(data, function(err, output){
    if(!err)
        grunt.file.write(dest, output);
    else
        grunt.log.error(err);
});
```

output is

``` html
<!DOCTYPE html> <html lang="en"><head><meta charset="UTF-8"><title></title></head><body><h1>My Page</h1>Hello World! <ul><li style="color: red">red</li><li style="color: green">green</li><li style="color: blue">blue</li></ul></body></html>
```

Is there a way, get output with `\n` 
plz help me
 and i'm sorry i can't speak english
 thank you very much ~ marko perfect : )
  I might be doing something wrong, but whenever my express app hits the `var template = require('./hello.marko');` a `hello.marko.js` file is created alongside the original file.  Is there a way to render marko templates from node without this filesystem dependency?

Thanks.
 One of the main benefits of Marko is that templates are compiled to javascript so that they can be executed on both client and server. Theoretically, you could compile to the javascript API and handle it yourself - see the bottom of this section: https://github.com/raptorjs/marko#template-compilation). Is there a particular reason that you're trying to avoid compilation?
 I don't have any problem with a compilation step, most templating systems behave similarly.  I'm just wondering if it's required to compile to the filesystem as opposed to having a purely in-memory compilation.
 Sorry I missed your part about the template-compilation with Javascript API.

I attempted using compileFile but the source that is returned is in the format of a common js module, which still isn't of much use unless it gets written to a file.  I was kind of hoping to somehow get back a compiled template function that can be instantly ran, similar to https://lodash.com/docs#template
 Thanks for the relevant issue, I searched but did not find that somehow.  That answers my question.
  Hi again,

I've been working on a large Koa server project where we want to allow mounting of multiple SPAs using Marko. Each SPA is a separate Node package (module).
It would be really nice if we could specify the root common templates folder for each page. 

The following should give an idea of my ideal application layout, split into a module for each SPA.
The `app.js` is the main app, which contains shared layout and partials for all SPAs to leverage.

``` sh
app.js
: require koa-server.js
  - default-layout.marko
  - partials
    - _header.marko
    - _footer,marko

index.je
: require app.js
  - index.marko
  - index-layout.marko

live.js 
: require app.js
  - live.marko
  - live-layout.marko
```

Alternatively I would have a `common.js` module, with the templates, layouts and partials common (shared) across multiple SPAs.

``` sh
common.js
  - partials
    - _header.marko
    - _footer,marko

live.js
: require app.js
: require common.js
  - live.marko
  - live-layout.marko
```

How would I conveniently reference such shared templates locations in other node modules, without hard coding a long ugly path such as `./node_modules/common/partials/_header`?
Would this be a feature enhancement/request?

Any ideas or recommendations greatly appreciated. Thanks ;)
 Awesome! Thanks a lot Patrick! Will start switching to Custom Tags for more awesome power and flexibility.
  Is this all it takes? => https://github.com/tj/consolidate.js/pull/158/files
 @patrick-steele-idem Do you happen to know if we can disable cache (aka the generated .js files) when using `consolidate.js`?

I am interested in this because I use marko as a template language for static site generator `metalsmith`, but because marko is smart enough to generate js files, it prevents us from using a watcher to reload template just by running the build process again on template change.

Is there a solution for that?

ref:
- https://github.com/FWeinb/metalsmith-watch @patrick-steele-idem Thx I did enable `invalidateCache`, it doesn't appear to find the right entry in `require.cache` to delete though. I need to figure out [why](https://github.com/FWeinb/metalsmith-watch/issues/36)...  We initially tried to use 

`<include name="xyz.marko" data="${data}"/>`

but this is (obviously!) a terrible idea whioch doesn't work. What is the recommended pattern, besides copying down each specific value which the partial is depending on, which can quickly make for tight coupling in the hierarchy!!

`<include name="xyz.marko" page="${data.page}" providers="${data.providers}"/>`
 We have this problem 

views/layouts/default-layout.marko:
 ....  <include template="./../partials/header/header.marko" menu_items="$data.globals"/>

views/partials/header/header.marko:

<p>${data.menu_items}</p>

and is empty data
  When `<include>` is given a hard-coded path, it can be relative, as said in the docs, or absolute. However, when it is given a variable path, as in `<include template="$data.templatePath" />`, it must be absolute (it will error out if relative).

**Works**

``` html
<include template="../relative/path/to/template.marko" />
```

**Works**

``` html
<var name="templatePath" value="'/absolute/path/to/template.marko'" />
<include template="$templatePath" />
```

**Works**

``` html
<include template="/absolute/path/to/template.marko" />
```

**Does Not Work**

``` html
<var name="templatePath" value="'../relative/path/to/template.marko'" />
<include template="$templatePath" />
```

It seems as if the issue is that hard-coded paths are `require.resolve`'d, while variable paths are not. Also, the docs could use an update, since it says that the template path must be relative, even for hard-coded paths.
  I would like to determine which custom tags get called via my renderer.js

So in the renderer, something like this:
`data.details=['d1','d2','d3']`

And then in template.marko (which doesn't work):
`<for each="detail in data.details">`
&nbsp;&nbsp;&nbsp;&nbsp;`<${detail} />`
`</for>`

One solution would be to explicitly call out tags conditionally:
`<for each="detail in data.details">`
&nbsp;&nbsp;&nbsp;&nbsp;`<if test="detail==='d1'">`
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`<d1 />`
&nbsp;&nbsp;&nbsp;&nbsp;`</if>`
`</for>`

But is there any other way to accomplish this?
 Thanks Patrick, that seems to work well. Do you know how I might include w-id in this case?

So that 

```
<detail w-id="detail[]" />
```

would become something like this...

```
<invoke function="renderer(data, out)" w-id="detail[]" />
```
 Ok thanks. That would be great if this could be supported.
  Custom Attributes is a great functionality. But current implementation does NOT support attribute value to come from a object.

Following statement is currently supported. but what if class name is coming dynamically from the JavaScript object.

<div class="{?data.active;tab-active}"></div>


Support for following is needed

<div class="{?data.active;data.model.class}"></div>


Also there is inconsistency across marko for defining JavaScript expression. Some places its using ${}, some places it dosent needs ${} and here its using {?condition;value} (WITHOUT $ sign)
 Thank you Patrick I didnt knew about attrs attribute, I have to finish up reading entire doc :)

On the second note It would be helpful if we can unify conditional statements as well for example below dosent with with `<assign>` but works with `<html class={?}>`
`<assign var="viewDetailsClass" value="{?data.listingModel.bin.binAction;btn;btn btn--primary}"/>`

May be using just using javascript inline if statement everywhere can solve the problem.
  I was working on creating reusable helper utility which will add _sp, class and id to any element when passing a common data model. After alot of try and error with variables, functions and ${} and without ${} I finally concluded that it may not be supported.

Support for calling a Helper Utility to render anything within the HTML element is desired.

Currently Marko supports calling JavaScript expression on right hand side after = sign (as below)

However following is not supported. hello

I have created a sample to explain the same.
https://github.corp.ebay.com/sugurnani/marko-dynamic-attributes/tree/master
 Thank you @patrick-steele-idem 

I was saw the documentation for defining custom tags but was unable to find info about creating custom attributes. Can you please point me to that doc?
  How about any JavaScript Object and JavaScript Arrays ?

my-component dynamic-int="${1==1? 25 : 26}" 
 I think it's a good idea to remove the noise of extra files. Making this part of the (marko-)html makes sense. 
:+1:

@SunnyGurnani I assume that should also work as Patrick mentioned support for the ${...} syntax.
 If you want to consider attribute value as JS expression, would you also support calling functions?

``` HTML
<my-component count=results.count() />
```
 Hi,
maybe it's worth considering the upcoming ES6 Template-Strings.
https://babeljs.io/docs/learn-es2015/#template-strings

If the proposal is a thought about getting the parser more towards js, the following:

``` html
<my-component dynamic-string='hello ${name}'/>
```

would lead towards:

``` html
<my-component template-string=`hello ${name}`/>
```

(yes, the backticks) if I got it right.
Not to talk about multiline strings.
And we'll be able to omit string-concatenation

``` html
<my-component string-concatenated=("hello "+name)/>
```

or am I completely wrong
greets Achim
 @patrick-steele-idem, I understand the migration-argument completely. For me as a total marko-noob, my thoughts were totally js-driven. It's the language I'm most familiar with, loving the new possibilities
and features of the upcoming es6. And with something like these...

``` html
<my-component string-concatenated=("hello "+name)/>
<my-component complex-function-call=(data.foo() + data.bar())/>
```

...I have to leave my way of js-thinking towards some marko-specials. If everything after the "=" is familiar js I don't have to think about marko. It just works.
Maybe this kind of thinking is too naive.
 My Suggestion would be to allow all javascript expression in ${} only to avoid any confusion.

With proposed method it would be very confusing for anyone who is new to Marko to figure out which is plain text and which is javascript expression.
 As i think more about it, i think what @SunnyGurnani proposed makes more sense and less confusing.

Few things to consider:
1. 'hello ${name}' is not a valid JS expression
2. If you want to actually have a string "[1, 2, 3]" as attribute value in mystring=[1, 2, 3] then it would have to be encoded which would make it look odd, otherwise it becomes array value.
 :+1:
 Thanks @pswar and @patrick-steele-idem 

JavaScript has given us the freedom from Classes and Types with current proposal we are taking away all that beauty and simplicity. I personally would prefer simplicity ${} for all expressions and let library handle the rest.

Current proposal suggest different implementation based on individual Types as following. However in JavaScript we never define type in the parameter or declare variable with type.

For dynamic string use ES6 strings
component attribute=`hello ${name}' 

Single function don't use anything
component attribute=data.foo()

For Multiple Functions use ()
component attribute=(data.foo() + data.bar())

For Object use {}
component attribute={hello: 'world'}

For Array use []
component attribute=[1,2,3]

@pswar I don't see any problem in following expression. Hello is static and ${name} is JavaScript expression. Please correct me if I am wrong?
component attribute="hello ${name}" 
 I was following up until the proposal that ${...} only be allowed within backtick-quoted attribute values, which would be a significant BC break.  I understand the desire to simplify, but that seems a step too far to me vs retaining the existing behavior where quoted attribute values are scanned for ${...} replacements.
 @patrick-steele-idem I understand where you're coming from, and in the end either way will work.  I guess the way I was looking at the interpolation within quoted attributes question was that it's simple to think of replacement working the same way there as it does within CDATA sections, since they're both "text" parts of HTML.

One question this does bring up is how the different quoting styles in the template would affect the quoting in the generated HTML.  For example, does this:

```
<my-component foo=`Hello ${data.name}`/>
```

compile to:

```
<my-component foo="Hello Dan" />
```

or:

```
<my-component foo='Hello Dan' />
```

or something else?
 I got your point @patrick-steele-idem 

I think then it would help to remove/depricate ${} from the language.
is there a need to use ES6 backticks ? Cant we just use following ? 
my-component string-concatenated=("hello "+name)

This would avoid confusion and make Marko much easier to learn for people new to language.
 @patrick-steele-idem So are we considering this just got custom tags or more generally?  My gut reaction would be that the syntax for custom tags should be as similar to "normal" tags as possible, which is where my (admittedly rushed) example came from, thinking about these template semantics in terms of defining attributes on regular tags.
 Coming from JSX-land, I suggest:

``` xml
<my-component foo={`Hello ${data.name}`} />
```

It would be great to have more overlap between the two standards. Many of us using marko on the back will be using Angular 2 or React/JSX on the front. I personally render React components and inject them into marko templates. 
 For conditional operators, how about something like this: 

```
<div if(x > 5)>
   Do something
</div>
```

instead of 

```
<div if=(x > 5)>
   Do something
</div>
```

For iterators, 

```
<ul>
   <li for(color in colors)>
       ${color}
   </li>
</ul>
```

instead of 

```
<ul>
    <li for="color in colors">
        ${color}
    </li>
</ul>
```
 @patrick-steele-idem 
I think the suggestion needs to be fixed to 

```
<div if(x > 5)>
   Do something
</div>
```

I see an '=' after the if, in the suggestion. 
 My gut reaction to this proposal was: "OH NO, NOT ANGULAR 2 SYNTAX!!!"

But reading a bit further on, I fully understand the reasoning. More power, less limits!!!
However I don't think it should be "all or nothin", breaking existing templates etc. 
My proposal: 
Allow the HTML "flavor" described above, but also allow/enable it while keeping in full HTML attribute compatibility mode, ie `x="y"`.

`<div x=(5-2*sqr(2))/>`

AND

`<div x.e="(5-2*sqr(2))"/>`

Where the `.e` means that the internals should be _evaluated_ as pure javascript and returned as:

`<div x=(5-2*sqrt(2))/>`

Then evaluated as javascript to finally render `<div x="12"/>`

It think this combines the best of both worlds (and would allow me to keep using jade to marko compilation!). The same principle would apply for string interpolation etc., ie. simply having `.e` attribute name postfix means a first "compilation" phase, basically just stripping the `"`s and understanding the intention as javascript evaluation :)
 Looks very cool :) Good job!!!
 Hi @philidem, 

When can we expect to begin experimenting with this or contribute? 
How do we hook the parser into markojs to replace the default Parser? 
Please add usage/install instructions. Cheers :)
 re: multiple variables, I don't know. I think most javascript styles these days prefer writing out one variable per line anyway.
 @patrick-steele-idem Sure, and it isn't necessarily bad to support multiple styles, it's just additional things to maintain, document, etc.

re: conditionals - I actually think that looks better. It is uglier, but it's standard js.
 Regarding conditionals, depending on how a falsy value is handled for the class attribute, the following would work... and it looks quite nice.

``` html
<div class=(data.isActive && 'active')>
```
  I suggest a new major version which uses Angular 2's new template syntax. Like Marko, this extends HTML well. I think this would quickly attract a wide set of people to the project!
  Might be able to close this per http://markojs.com/docs/syntax/#dynamic-attributes  With a marko page like this:
`<include template="./header.marko"/>`
`${data.bodyText}`
`<include template="./footer.marko"/>`

The rendered result is:
header content
footer content
body content

The expected result is:
header
body
footer
 Thanks for creating that.  This has to be my misunderstanding of what include would do.  Stripping the extra code from my header and footer I found the issue was if I have an open tag in the header (i.e. a `<body>` tag) and a closing tag in the footer (`</body>`), Marko adds a closing tag to the header and drops the closing tag from the footer.  

So it seems each included template has to be a stand-alone template, not depending on HTML tags opened or closed outside of that template.  Is that correct?
  Hi,
How can query params be added to a url when rendering a template `template.render({}, res);` so they can be accessed from the url e.g. http://domain.com/book?id=123 ?
 Assuming you have a request object like Express provides:

```
template.render({id: req.query.id}, res);
```

Then in the template:

```
<a href="http://domain.com/book?id=${data.id}">click</a>
```
 Thanks. I want to be able to append it to the url so I can then parse the URL for the page to access all the params via JS. I understand I can render a `<script>` tag in the template with the values but it would be a better solution to parse the URL in this case.

Is this possible do you know?
 I'm not sure that I follow what you're asking to be honest.  If you just want to access the query params from js in the browser you can do that without marko involvement at all by parsing `window.location.search` with client-side js. If you want to use marko to pass any requested params back to the template you could stick the entire `req.query` object into `data` like:

```
template.render({query: req.query}, res);
```

Then:

```
<script>
  var query = $!{JSON.stringify(data.query)};
</script>
```
 I've not explained this great. I'll have another go. 
(using Express + Marko)
Say I have a form submitted to '/book/:id' route, this is handled by a controller which saves the book to the DB. Once the book is saved I render a template '/book/complete'. But instead of the url being '/book/complete' I want it to be '/book/complete?id=123' (123 being the last ID added to the DB).
My problem is rendering the query string onto the URL on page load.

Your second solution makes sense but having script tags could get unwieldy across pages.

Does that explain it any better?
Thanks for persevering. 
 Honestly this doesn't sound like a marko issue at all, the URL in the browser isn't related to the name of the template.  If you want to have the browser show that URL you'll need to add a GET route for it and at the end of your POST handler use a redirect to make the browser load the desired URL.

```
return res.redirect('/book/complete?id=' + new_id);
```
 Couldn't see the wood for the trees! Thanks @DanCech.
  This tightens the entity matching regular expression to explicitly handle numeric and hexadecimal entities separately from named entities.  It also adds a simple test that entities are being properly matched.
  I didn't get how is it possible to render a template from string. Is it possible at all?

Thanks.
 Doesn't work in browser using browserify. I am getting
`require.resolve is not a function`
on

`exports.taglibs.registerTaglib(require.resolve("../taglibs/core/marko-taglib.json"));`
 Thanks for the directions, but I have already switched to another template engine, too much hassle for such a simple thing. As for me marko.load should be able to work with a raw template string or there should be any other method do this job in one line as it is in the most of the template engines.
Anyway thanks for your help.
 @patrick-steele-idem of course I agree with you. But I bet you will not notice a difference in case of simple templates between precompiled and compiled in browser. I am actually doing a simple Chrome extension and don't need 60 fps. Another thing is that usually you want to make it workable asap and after that do the optimizations so it is usually very handy to just have a single method for a single render operation to see it right away.
 Hi, I'd like to add a use case for client compilation.
We're currently not using nodejs on the server (but a CMS system) and would like our users to add their own custom templates to a "templates library". We don't mind if this means a second or two delay compiling the template before its pushed to the library. These templates are then used in the main app.
Unfortunately at the moment it seems templates have to be pushed by the development team with access to a node environment. 
  It seems like the layout-put tag is not working as expected anymore. The test confirms this:

```
4) render layout-use:
     Error: Unexpected output for "/marko/test/fixtures/templates/layout-use/template.marko":
EXPECTED (/marko/test/fixtures/templates/layout-use/expected.html):
---------
<div>BODY CONTENT</div>FOOTER CONTENT<h1>HEADER CONTENT</h1><div>BODY CONTENT</div>FOOTER CONTENT<h1>VALUE HEADER</h1><div>BODY CONTENT</div>FOOTER CONTENT<h1>DEFAULT TITLE</h1><div>BODY CONTENT</div>FOOTER CONTENT
---------
ACTUAL (/marko/test/fixtures/templates/layout-use/actual.html):
---------
<div></div><h1>DEFAULT TITLE</h1><div></div><h1>DEFAULT TITLE</h1><div></div><h1>DEFAULT TITLE</h1><div></div>
---------
```

Instead of using the content from layout-put it falls back to the default if available.

Any idea what's wrong here?
 That is strange. If I checkout the latest version with a blank npm install ... it's still failing. 

I'm using node 0.10.36.

Any idea how I could triage this issue?
 Did the same on a different machine. Everything went fine without issues. Most likely it's just a problem with my machine. 

Let me know if you have any idea how I could isolate this issue.

Thanks
-Vivian
 Yes, did that without success.

Anyhow, found the issue.

There was a node_modules directory in a parent directory by accident. So for some reason it interfered with that and caused these errors.

Thanks for your quick help!
-Vivian
    The parser seems to be converting strings to logical values, for example 'and' is getting converted to '&&', and 'or' to '||'. It seems to be linked to the way html elements are nested. The text is being used in a <layout-put into="body"> tag.

Here is some html that breaks it:
`<div class="c c2 span-8-collapse">
                    <div class="c-inner">
                        <dl class="summary-list">
                            <dt>
                                <h3>Intuitive Features Wrapped Up In a Smart Interface</h3>
                            </dt>
                            <dd>
                                <p>Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.</p>
                                <span class="blue">&#9656; </span><a href="/features">Explore the Features</a>
                            </dd>

```
                        <dt>
                            <h3>Pay-as-you-go + Monthly Plans Available</h3>
                        </dt>
                        <dd>
                            <p>Whether you're publishing lots or publishing little we have a plan that's great value and can scale up/down as your needs do, and you're free to cancel anytime.</p>
                            <span class="blue">&#9656; </span><a href="/pricing">Choose a plan that's right for you</a>
                        </dd>
                        <dt>
                            <h3 class="green">Start Now - No Obligation 14 Day Free Trial</h3>
                        </dt>
                        <dd>
                            <p>We don't expect you to make a decision before you've kicked the tyres and shown your boss so we offer a no obligation 14 day free trial to everyone.</p>
                            <span class="green">&#9656; </span><a href="/features#analytics" class="green">Bored of reading and want to try it for yourself? Start your free trial now</a>
                        </dd>
                    </dl>
                </div>
            </div>`
```
 I'm using the 'view-engine' and 'view-engine-marko' modules. I think the dependencies are well out of date. Is this still supported: https://github.com/patrick-steele-idem/view-engine-marko.git?
  I created a custom tag component, app-fieldset, which can include other custom tags, eg. app-text-field.
It works fine if the inside custom tag are other types, but I get error if it refers itself.

Template.marko in app-fieldset:

`...
<if test="fType === 'text'">
    <app-text-field viewModel="field" />
 </if>
 <else-if test="fType === 'fieldset'">
   <app-fieldset viewModel="field" /> //refers self 
 </else-if>
`

The error in console is:
Thu, 30 Apr 2015 04:14:22 GMT uncaughtException Invalid tag handler: [object Object]
Error: Invalid tag handler: [object Object]
    at Function.deferredRenderer.renderer (...../node_modules/marko/runtime/helpers.js:35:19)
    at deferredRenderer (..../node_modules/marko/runtime/helpers.js:27:26)
    at module.exports.t (..../node_modules/marko/runtime/helpers.js:181:9)
    at ..../src/components/app-fieldset/template.marko.js:59:15

I used the latest version of marko: "2.3.2" per https://github.com/raptorjs/marko/issues/66
but seems not work for this case.

Thanks,
Sara
 Hi Patrick,

Yes, it has renderer.js and use option 1.

Thanks,
Sara

From: Patrick Steele-Idem <notifications@github.com<mailto:notifications@github.com>>
Reply-To: raptorjs/marko <reply@reply.github.com<mailto:reply@reply.github.com>>
Date: Thursday, April 30, 2015 8:06 AM
To: raptorjs/marko <marko@noreply.github.com<mailto:marko@noreply.github.com>>
Cc: sara xu <lijxu@ebay.com<mailto:lijxu@ebay.com>>
Subject: Re: [marko] Custom tag self reference does not work (#69)

Hi Sara,

Does your <app-fieldset> custom tag have a renderer.js? If so, which syntax of the following does your renderer.js use?

Option 1:

exports.renderer = function(input, out) { ... }

Option 2:

module.exports = function renderer(input, out) { ... }

If you have a circular dependency you need to use Option 1 since it allows for a partially loaded module to be returned. It is recommended that you always use the syntax shown in Option 1. If you do not have a renderer.js then I'll probably need more details to reproduce the problem.

Thanks,
Patrick

‚Äî
Reply to this email directly or view it on GitHubhttps://github.com/raptorjs/marko/issues/69#issuecomment-97830257.
  Proposal #61 suggests some solution to simplify "parent/child relationships". I'm trying to understand how conceptually we are selling this solution to the end user. We are telling that user should "connect" parent and child tags, but maybe user does not need child tags? Maybe he just needs a way to express complex `input` object using declarative markup.

If we step back and overview tags again, we can say that tag is a function with the following signature:

``` js
var customTag = function(input, out) {
    // ...
};
```

Instead of calling it directly in the code, we found a way to "call" it declaratively with the following markup:

``` html
<custom-tag title="Hello" href="/some/url" />
```

Naive equivalent of the above declarative "call" is the following function call:

``` js
customTag({ title: "Hello", href: "/some/url", renderBody: function() {} });
```

It means that declarative `<custom-tag />` is used to define the shape of the `input` object for `customTag` function. Nothing new here, this is just an introduction.

But you can notice, that declaratively you can define only first-level properties or functions of the `input` object. 
### Alternative definition of the problem

In proposal #61 idea was to simplify parent/child relationship. But maybe we can solve the same problem if declarative "call" would support definition of complex `input` objects. Actually, the notion of the `target-property` suggests us that we are really looking to support complex `input` object, not just single-level attributes.

Sometimes we really would like to call our tag function with complex `input` object. In JavaScript this is really simple and straightforward:

``` js
appTabs({
    orientation: "vertical",
    tabs : [
        { label: "Tab 1", renderBody: function() { return "Content for Tab 1" } },
        { label: "Tab 2", renderBody: function() { return "Content for Tab 2" } }
    ],
    renderBody: function() { ... }
};
```

Today we cannot easily do the same declaratively. We can pass `orientation` attribute, but we cannot pass `tabs[]` array. Proposal #61 tries to solve this, but conceptually it is a bit complex, because it requires to introduce another tag that is defined separately from the `attributes` attribute in `marko-taglib.json`, while still attaching to the `input` object with the help of `target-property`. I see mismatch here: from one side we have independent child tag, from other side we are trying to embed it to our parent's `input` object.

What if the problem can be defined as the following: _how can we make declarative "call" of tag function that accepts complex `input` objects?_ This definition of the problem is differ from the current problem: _how can we simplify parent/child relationships?_
### Proposal for `marko-taglib.json` syntax

If our tag function can accept complex `input` objects then shape of such object should be defined inside `attributes`, where we currently have support for only first-level attributes. Here is a possible definition of `app-tabs` taglib:

``` js
{
    "attributes": {
        "orientation": "string",
        "tabs": {
            "type": "object[]",
            "implicit": true,    // only one attribute can be implicit (more about this below)
            "attributes": {
                "label": "string"
            }
    }
}
```
### Nested tags vs. nested attributes

Nested tag is a complete Marko tag which is nested to another tag and can be reused. Nested attributes can look like ordinary Marko tags, but they cannot be reused outside of the root tag.

In the following example, `<app-panel />` is a nested tag, while `<app-tab />` is a nested attribute of `<app-tabs />`:

``` html
<app-tabs orientation="vertical">
    <app-tab label="Tab 1">
        <app-panel title="Title" />
    </app-tab>
    <app-tab label="Tab 2">
        Content for Tab 2
    </app-tab>
</app-tabs>
```

We cannot reuse `<app-tab />` outside of the root `<app-tabs />`. That is why this is a nested attribute. But we can reuse `<app-panel />`, because this is a nested tag.

Important part of this proposal is a proposal to treat nested tags differently from the nested attributes.
### Proposal for the syntax of nested attributes

There are several possible ways to express nested attributes. First possible way is to use `tag-name.property` notation:

``` html
<app-tabs orientation="vertical">
    <app-tabs.tab label="Tab 1">
        <app-panel title="Title" />
    </app-tabs.tab>
    <app-tabs.tab label="Tab 2">
        Content for Tab 2
    </app-tabs.tab>
</app-tabs>
```

The following `input` object will be created (renderBody etc. are omitted):

``` js
{
    "orientation": "vertical",
    "tabs": [
        { "label": "Tab 1" },
        { "label": "Tab 2" },
    ]
```

I saw such notation in the [XAML](https://msdn.microsoft.com/en-us/library/ms788723%28v=vs.110%29.aspx?f=255&MSPPError=-2147217396) language:

``` xml
<Button Text="Save">
  <Button.ContextMenu>   <!-- nested attribute -->
    <ContextMenu>     <!-- nested tag -->
      <MenuItem Header="1">First item</MenuItem>
      <MenuItem Header="2">Second item</MenuItem>
    </ContextMenu>
  </Button.ContextMenu>
  Right-click me!
</Button>
```

Second possible way is to use some special `param` tag, like in [Google Closure Templates](https://developers.google.com/closure/templates/docs/commands#param):

``` txt
{template <template_name>}
  {@param <param_name>: <param_type>}
  {@param? <optional_param_name>: <param_type>}
  ...
{/template}
```

In case of Marko it can be `<@param attribute1="value" attribute2="value" />`, although I also don't like special symbols (maybe simple `<param ... />` is enough):

``` html
<app-tabs orientation="vertical">
    <@tab label="Tab 1">
        <app-panel title="Title" />
    </@tab>
    <@tab label="Tab 2">
        Content for Tab 2
    </@tab>
</app-tabs>
```

Marko already has special syntax for string interpolation: `${value}`, `$!{value}` and `${value}`. Maybe it still worth to add another special syntax for nested attributes: `<@name />` or any other.

I'm not voting for any particular syntax, my idea is to evaluate problem that we are trying to solve from different angle (from declarative definition of complex `input` objects). I'm sure that together we can find a better syntax.
#### 

In my comment to #61 I asked about support for more than one level of nested tags with the following use case:

``` html
<sidebar-navigation>
    <sidebar-navigation-section title="Software">
        <sidebar-navigation-item href="/linux" title="linux"/>
        <sidebar-navigation-item href="/windows" title="Windows"/>
    </sidebar-navigation-section>
    <sidebar-navigation-section title="Devices">
        <sidebar-navigation-item href="/ipad" title="iPad"/>
        <sidebar-navigation-item href="/xbox" title="Xbox"/>
    </sidebar-navigation-section>
</sidebar-navigation>
```

When looking on this template, can you answer on what tags are "nested tags" and what are just "nested attributes"? It is hard to answer on this question without reading `marko-taglib.json`. If we can find a way to differentiate tags from attributes, it can be expressed in the following way (using some of the proposed syntax):

``` html
<sidebar-navigation>
    <@section title="Software">
        <@item href="/linux" title="linux"/>
        <@item href="/windows" title="Windows"/>
    </@section>
    <@section title="Devices">
        <@item href="/ipad" title="iPad"/>
        <@item href="/xbox" title="Xbox"/>
    </@section>
</sidebar-navigation>
```

Definition of this tag in `marko-taglib.json`:

``` js
{
    "attributes": {
        "orientation": "string",
        "sections": {
            "type": "object[]",
            "implicit": true,    // only one attribute on the same level can be implicit 
            "attributes": {
                "title": "string",
                "items": {
                    "type": "object[]",
                    "implicit": true,   // only one attribute on the same level can be implicit 
                    "attributes": {
                        "title": "string",
                        "href": "string"
                    }
                }
            }
        }
    }
}
```

`implicit` flag means that we can assign value to this property using shorter notation. Instead of this (technically valid):

``` html
<sidebar-navigation>
    <@sections>
        <@section title="Software" />
    </@sections>
<sidebar-navigation>
```

 We can write it in the shorter form:

``` html
<sidebar-navigation>
    <@section title="Software" />
<sidebar-navigation>
```

In XAML this flag is named [`ContentProperty`](https://msdn.microsoft.com/en-us/library/windows/apps/windows.ui.xaml.markup.contentpropertyattribute.Aspx).
#### Conclusion

This is just a proposal. You probably see much more corner stones than I am. 

Thank you!
 It might be possible sidestep the tag-name issues and instead define a new marko-tag like `<attribute name="X">value</attribute>`, which would set an attribute on the parent tag.  In this use-case the markup for the tabs might look something like:

```
<app-tabs>
    <attribute name="tab">
        <attribute name="label">Tab 1</attribute>
        Content for Tab 1
    </attribute>
    <attribute name="tab">
        <attribute name="label">Tab 2</attribute>
        Content for Tab 1
    </attribute>
</app-tabs>
```

This scheme could potentially be used for defining attributes on regular html tags as well as on our custom taglib tags too, though I have no idea how much complexity that would add to the parser.
 Interesting, I didn't know about <attr>.  Is that something that's intended to be documented and officially supported?

I think the colon approach will result confusion since the `app-tabs` "namespace" wouldn't actually be declared, and could cause problems for people trying to use marko to generate xml.

The . or - separated syntax seems cleanest, if a little repetitive.  The ability to just declare arbitrary subtag names in the taglib definition could result in some interesting use-cases and has the potential to make the template markup more "semantic", which is a pretty big pro in my book.
 > I'm in favor of supporting the dot-notation for using nested tags in your HTML. 
> A short-hand of only using something like <.tab> would be great too if we can 
> tweak the HTML parser.

Because you are already planning to use `@` symbol for attributes, maybe it makes sense to introduce `@<nested-tag />` notation, instead of `<.nested-tag />` and `<@nested-tag />`:

``` html
<app-tabs>
    @<tab label="Tab 1">
        Content for Tab 1
    </tab>
    @<tab label="Tab 2">
        Content for Tab 2
    </tab>
</app-tabs>
```

It seems that in this case we shouldn't worry about HTML parsers and all editors will work fine with this syntax.

As a side note, we also can continue to use `$` symbol for this and do not introduce new symbol:

``` html
<app-tabs>
    $<tab label="Tab 1">
        Content for Tab 1
    </tab>
    $<tab label="Tab 2">
        Content for Tab 2
    </tab>
</app-tabs>
```

Mnemonic is the following: when `$` is in front of open curly bracket (`{`), you are going to evaluate JavaScript expression. When `$` is in front of open tag (`<tag>`), you are going to decoratively define  sub-property. 

But I agree that `@` is suited better for attributes...
  Hi,
Is there a way to make a variable available to all layouts templates without having to pass it in every template.render()?
For example, i'm using <layout> and have a <app-nav> component in that layout. I want to be able to render/not render certain navigation elements depending on whether the suer is logged in or not. At present I have to pass a variable in every controller like this:
`$global: { env: locals.env, user: locals.user }`
but I have to do that in every controller ( where I call template.render() ) e.g. login, signup etc etc. Is there any way to make variable available to all templates/components rather than sending the data each time in template.render()?

Thanks,
Pat
  This proposal looks really nice! Just trying to understand how flexible it is. First thing that come to my mind is about more than one level of hierarchy. How can be the following tag described in `marko-taglib.json`:

``` html
<sidebar-navigation>
    <sidebar-navigation-section title="Software">
        <sidebar-navigation-item href="/linux" title="linux"/>
        <sidebar-navigation-item href="/windows" title="Windows"/>
    </sidebar-navigation-section>
    <sidebar-navigation-section title="Devices">
        <sidebar-navigation-item href="/ipad" title="iPad"/>
        <sidebar-navigation-item href="/xbox" title="Xbox"/>
    </sidebar-navigation-section>
</sidebar-navigation>
```

And there are use-cases for unlimited hierarchy (though very uncommon):

``` html
<menu-widget>
    <menu-item title="Help">
        <menu-item title="About" />
        <menu-item title="FAQ" />
    </menu-item>
    <menu-item title="File">
        <menu-item title="Save" />
        <menu-item title="Open with">
            <menu-item title="Sublime" />
            <menu-item title="VIM" />
        </menu-item>
    </menu-item>
    <menu-item title="View" />
</menu-widget>
```

Will it be possible to describe such nesting? If we'll go with the proposed way, we need to define taglib inside taglib inside taglib :) 

Here is an example for the `sidebar-navigation` shown above:

``` js
{
    "attributes": { },
    "taglib": {
        "tags": {
            "sidebar-navigation-section": {
                "target-property": "sections[]",
                "attributes": {
                    "title": "string"
                },
                "taglib": {
                    "tags": {
                        "sidebar-navigation-item": {
                            "target-property": "items[]",
                            "attributes": {
                                "href": "string",
                                "title": "string"
                            }
                        }
                    }
                }
            }
        }
    }
}
```
  In the latest Marko versions and in some cases `and` words in templates are replaced with `&&` symbols. 

For this template:

``` html
We're young.
<div>
    You and me are friends and teammates.
</div>
```

The following `*.marko.js` file will be generated:

``` js
out.w('We\'re\' \'young. <div>You && me are friends && teammates.</div><div style="color:blue">You '
```
## Necessary Conditions
1. You should use `marko-layout` module.
2. You should have unpaired `'` symbol in your template.

There are probably other conditions, when this issue happens, but I know only one set of conditions.
## Minimal project

Here I prepared a minimal project that will help to reproduce this issue:
https://github.com/schetnikovich/marko-substitution-poltergeist
# Reasons

I don't know actual reason of this problem, but for the end user this is because of `'` symbol, that
makes all subsequent `and` words be replaced by `&&` symbol.

If you'll "close" single quotes, i.e. `We'are' young` - everything will be correct.
# Workaround

Replace all single quotes with the following:

```
$("'")
```
 Thank you very much for so quick fix! Issue disappeared. 
  I have three points regarding progressive rendering of marko templates.
1. As out of order rendering requires JS on the client side, the docs should mention that as well (including the impact this has on on things like progressive enhancement etc.) The only mention of this that I have found is on the ebay tech blog article about progressive rendering. I might be missing something here; I made some thoughts, if out of order rendering could be achieved without the need of client side JS... unfortunately I did find a way to do so.... is this a point of interest for marko?
2. I wonder, if google does correct indexing with out-of order rendering, as A) JS is required and B) the initial HTML is rendered into a hidden div. Point A might be a no-issue, since google (and others?) now performs JS when requesting pages. If not, point B is critical because hidden content could be ignored/identified as lower priority (less relevant to a page) so pages might not be correctly indexed. If google runs JS and considers the page when it is fully loaded, point B might be a no-issue. Please provide some thoughts/practical experiences regarding A and B.
3. When running the examples on https://marko-progressive-rendering.herokuapp.com/?renderMode=progressive-in-order&jsLocation=middle everything is fine until you reload the iframe (hitting the inner refresh button on the page) in the chrome browser. Strangely, progressive rendering of async-elements only works when you move the mouse after refresh - Safari and Firefox render every chunk as soon as it arrives. Reloading the entire page in chrome shows the same effect while running the example in a separate window works fine (most of the time). I tested the behaviour with a bigger first chunk (additional textual data) but the data refuses to render until you move the mouse. It seems, that the browser ignores chunked responses and renders the content like a single chunk. I see the same behaviour on Mac and Linux. Does somebody know the reason and if this is a known/intended behaviour or a bug on the marko/chrome part?
 hi @patrick-steele-idem thanks for looking into the issue - I am fine with closing it - if something pops up again, I will create a new issue.

Sadly, I have not done any further investigation towards indexing but as soon as I get more information, I will share it.
  Hi,
I have a problem with components having their HTML tags closed, incorrectly, by the compiler. For example if I have the following components and html content (shown simplified):
<app-header> (components/app-header/template.marko)
HTML content: `<div class="wrapper"><div class="content">`

<app-footer> (components/app-footer/template.marko)
HTML content: `</div></div>`

index.js
HTML content: `<app-header></app-header><div>content here</div><app-footer></app-footer>`

I can see the problem. The `<app-header>` component's compiled .js file has added the closing 'div' tags automatically, which breaks the layout as the 'wrapper' and 'content' elements are now closed, when they should be left open to contain the main page content.

Is there any setting to prevent this or a different way of laying out the pages?

Thanks,
Pat
 Ok, that makes sense. Once again thanks for the quick response and easy to understand explanation - it really makes a difference.
Thanks,
Pat
  Hi,
Whats the best way to pass data to components. At present it appears you have to pass data from every template to the components e.g. in index.marko you would have
`<app-header title="$data.title" env="$data.env" csrf="$data.csrf"></app-header>`

I can then access the data from the component e.g.
`<if test="data.env == 'development'">`

If I try to access data.env without passing the data in from index.marko I get an error. Doing it this way if I want to pass new data into the app-header component in the future I would have to change ALL templates. 
Is there a better way of doing this?

Thanks,
Pat (new to Marko and Node)
 Wow, exactly what I needed, and fast! I can get on with a productive day, much appreciated.
  ![marko0](https://cloud.githubusercontent.com/assets/8730277/6872950/1f4f32d8-d4ad-11e4-9edd-4718197d4ba5.png)
 ![marko1](https://cloud.githubusercontent.com/assets/8730277/6872952/2807186e-d4ad-11e4-8d85-26981939383d.png)
 :D these are the '< >'  it all can be customised I have .ai files saved
 Dumb, but worth the "idea".
![marko-logo](https://cloud.githubusercontent.com/assets/105656/6873249/9affb1fc-d474-11e4-8e5f-65e7e15a4aa5.png)
 ![marko3](https://cloud.githubusercontent.com/assets/8730277/6873580/9f302990-d4b1-11e4-8c19-1c3eadfd3823.png)
 @philidem Yeah, I saw that as soon as I made it, but said, "What the heck? Worth a post."
 ![marko2](https://cloud.githubusercontent.com/assets/8730277/6876374/2dc9b080-d4c7-11e4-8832-5a4347acf696.png)
Since Marko is a dudes name I gave him some personality
 ![marko4](https://cloud.githubusercontent.com/assets/8730277/6876740/de88c28c-d4ca-11e4-990f-ca09efb4e3d9.png)
Some Urban Style.
 Alright time to leave Illustrator. Good night Gentleman!, I will be bugging you tomorrow since I haven't implementetd optimizer yet ;)
 ![screen shot 2015-03-27 at 2 47 34 pm](https://cloud.githubusercontent.com/assets/7464488/6877671/72464764-d490-11e4-83b9-8d8fc7aedd66.png)

Maybe you could play around with the color... 
 ![marko3](https://cloud.githubusercontent.com/assets/6454552/8861384/755b9178-318a-11e5-967a-4b8990787b94.png)

Some thoughts (additional love to detail required): 
- the brackets at the end should appear 3D "stacked"; meaning: tags can be wrapped... forming components... the "k" and the first bracket form the letter "o"
- the font should appear dynamic, "agile", quick and nice
- the sub text describes marko as template engine with binding (behavior) and gives an insight about how marko components are written
 Lol how about some fancy..

${marko}

   Ryan Pavely
    Net Access
    http://www.nac.net/

On 8/5/2015 1:53 PM, Patrick Steele-Idem wrote:

> Accidentally pressed the wrong button... Comment updated with link to contest. Thanks.
> 
> ‚Äî
> Reply to this email directly or view it on GitHub https://github.com/marko-js/marko/issues/54#issuecomment-128090635.
 haha had a funny idea.... marko and an abstract grining face

![marko_face](https://cloud.githubusercontent.com/assets/6454552/9115315/b139b948-3c5e-11e5-9edd-0ec5a9e25110.png)
 Well deserved, congrats Marko!
  `c-input` works well for nested tags, but there are times when we need to pass down extra information from the parent tag, like this:

```
<tagname c-input="data.someObj" attribute="test"/>
```

Examples include when the parent contains the loop and we might need an index in the nested tag, or if parent tag-level logic affects a child tag. 

This should also include support for passing a conditional, or at least a variable (that we can set with a conditional earlier in the file).

Thanks!
 Yes to @patrick-steele-idem and thanks!
  Removing the else if block in order to allow complex var names on the left hand of the assignment.
 Funny, because I did the edits directly in Github. :-)

## 

Sean Gates
Sent from my iPhone

> On Mar 18, 2015, at 5:15 PM, Phillip Gates-Idem notifications@github.com wrote:
> 
> Please fix the jshint error so that the build will pass. Also, jshint plugins/packages for your code editor are really helpful if you don't have one installed.
> 
> See https://travis-ci.org/raptorjs/marko/jobs/54955691
> 
> ‚Äî
> Reply to this email directly or view it on GitHub.
 You bet!

## 

Sean Gates
Sent from my iPhone

> On Mar 18, 2015, at 6:15 PM, Phillip Gates-Idem notifications@github.com wrote:
> 
> Published marko@2.1.4
> Thanks Sean!
> 
> ‚Äî
> Reply to this email directly or view it on GitHub.
  Usecase:

We would like to add a library of components. The path would be:
/node_modules/component-library/node_modules/custom-component/lib/

If the rendered template is somewhere else then this path won't be discovered. 

Suggestion:

Add a way to add paths to the [discovery feature](https://github.com/raptorjs/marko#taglib-discovery)
 That would be great. 
  Especially with regards to breaking changes and feature deprecations.

It will help us make informed decisions about if/when to upgrade and what app-changes we need to make to stay up to date with the latest and greatest.

We have gotten ourselves into trouble a few times with mismatched versions between marko and supporting modules. I think having an accurate Changelog on each module would be hugely helpful in tracking down where we went awry.

Thanks!
 Thanks @philidem -- That sounds like it would be a big help!
 Hi @patrick-steele-idem,

I think the Marko ChangeLog was a bit out of date when I opened this issue, but it seems to be all caught up now.  Thanks for that!  (Or, I may just be crazy ...)

Upgrade guides are definitely fantastic help, and much appreciated.

It seems some supporting modules don't have ChangeLogs, however, and that's what I was trying to get at in my initial message.  Here are a few, as examples: raptorjs/optimizer, raptorjs/optimizer-marko, raptorjs/optimizer-less.

Maybe it wouldn't be practical or helpful to have Changelogs for each .. I'm not sure.  As a Marko-user, it's probably easier to have a single ChangeLog/Upgrade guide to follow.  But the interdependencies between modules complicates things.

I like @philidem's suggestion of having some runtime detection of incompatibilities.

Meanwhile, I'm using 'npm shrinkwrap' to freeze my module versions so that any future upgrades are deliberate and that is a working solution for me, for now.

Thank you for the great project!

-Ben
  Hello,
is there a way to work with marko and webpack, a marko-loader perhaps ?
Thanks
 Thanks, i will try !
 @maxwarch Hi! Have you succeed with webpack and marko? I'd tried it and encountered the problem that webpack 'Cannot find module 'raptor-logging-impl''. Direct installation of 'raptor-logging-impl' doesn't help. Will be nice to get your feedback. Thanks!
 @KateKate hi, unfortunately i haven't the time to try this. I hope i will have !
 @patrick-steele-idem thank you for your feedback.
 It's a bit of a hack, but if a module uses `process` and it's bundled by webpack then webpack (and browserify) sets `process.browser: true`. So if the try/catches in raptor and marko's src are only there for the benefit of browserify then replacing them with `if(!process.browser)` would mean the code compiles properly in webpack too @patrick-steele-idem 
 I've found, and found a potential workaround for, another bug in webpack.

Because, I guess, it places a higher importance on loading files with extensions other than `.js` webpack tries to load `mypartial.marko` rather than `mypartial.marko.js` when using `<include` in any template. The workaround I found is to compile `<include` to e.g. `__loadTemplate(require("../../components/nav/tpl.marko.js"), require)` instead of `__loadTemplate(require.resolve("../../components/nav/tpl.marko"), require)`

Whether this breaks anything else I don't know. If it does I'll have a go at writing a marko loader for webpack, though it wouldn't surprise me if the use of `require.resolve` instead of a plain `require` is still   a problem
 On investigating, this would involve a change to TypeConverter. Is this something you'd consider?
 I tried with transform-loader and the markoify. It worked for me, but webpack does not track any changes in templates, so I just wrote no-brainer marko-loader for webpack, which solves this problem.

``` js
var marko = require('marko/compiler');

module.exports = function (source) {
  if (this.cacheable) this.cacheable();

  return marko.compile(source, '.', {
    writeToDisk: false
  });
};
```
 @sergiirocks I'm using your loader but getting this error when building:

> the request of a dependency is an expression

Any idea what might be happening?

Do you have an example on how to use it in `webpack.config.js`?
 @patrick-steele-idem I have created this test project.

https://github.com/PierBover/markojs-webpack-test

You just need to `npm install` and then `webpack` to reproduce the error.
 Awesome @patrick-steele-idem !
 It does work, although I'm still getting Webpack warnings:

> WARNING in ./~/marko/runtime/stream/index-browser.js
> Critical dependencies:
> 6:17-40 the request of a dependency is an expression
> 10:13-32 the request of a dependency is an expression
>  @ ./~/marko/runtime/stream/index-browser.js 6:17-40 10:13-32
  Hello,

is there a way to use marko with webpack ?

Thanks
  Please, please please :) Anything we can do to help. Any sample repo to use as reference?
Cheers!
  I started writing some code that I was really hoping would work but it doesn't seem to. I was wondering if self-nested taglibs would be possible because it would be extremely handy for my use case:

``` json
{
  "tags": {
    "mytag": {
      "renderer": "./mytag",
      "attributes": {
        "data": "string"
      },
      "body-function": "getChildren(__children)",
      "import-var": {
        "children": "__children"
      }
    }
  }
}
```

``` js
exports.render = function(input, out) {
  var children;
  if (input.getChildren) {
    children = [];
    input.getChildren({
      addChild: function(child) {
        children.push(child);
      }
    });
  }
  if (input.children)
    input.children.addChild(/* implementation detail */);
  else
    out.write(/* something utilizing children */);
};
```

``` html
<mytag data="a">
  <mytag data="b" />
  <mytag data="c" />
</mytag>
```

So basically my question is whether or not it is somehow possible to include both "body-function" and "import-var" on the same tag and self-nest them. When I try this I get an error that __children is undefined. Is there a way to achieve this currently?
 I actually solved my problem for now with a hack of using `"import-var": { "children": "arguments[1] }`, but obviously it would be much better if `children` existed in the compiled template and was null.
 Ah yeah that makes sense. I've replaced my hack with that and it's working great now. Thanks so much!
 Ok cool, I'm still trying to figure out exactly how this all works. I have a little ways to go I think but so far so good. I started looking through the tests and have modified my taglib to use `"var": "children"` now and I've removed `body-function` in favor of using `renderBody(out, {...})` in my renderer. It's working perfectly now. Although I don't feel like I can be completely confident that I'm doing everything correctly because the documentation is a little lacking in this area at the moment, but I'm sure that'll change in the future.

FYI I'm building a simple taglib to render React components and it's actually working great. Maybe I'll publish it on npm if I get some time.
  - https://github.com/raptorjs/marko/issues/28
  This is not supported 

``` javascript
template.renderSync({
  $global: {
    foo: "foo!"
   }
});
```

But this is (as seen in https://github.com/raptorjs/marko/issues/16)

``` javascript
template.render{
  $global: {
    name: 'Frank'
  }
}, res);
```

The issue seems to be that `$global` processing is missing from the `renderSync` function.

https://github.com/raptorjs/marko/blob/master/runtime/marko-runtime.js#L65-L72

``` javascript
Template.prototype = {
   renderSync: function(data) {
       var out = new AsyncWriter();
       out.sync();
       this._(data, out);
       out.end();
       return out.getOutput();
}
```

But can be found in the `render` function.

https://github.com/raptorjs/marko/blob/master/runtime/marko-runtime.js#L84-L126

``` javascript
 render: function(data, out, callback) {
      ...
       var $global = data.$global;
       if ($global) {
           extend(out.global, $global);
       }
```
  I am trying to target IE browsers with some simple IE conditionals, but it seem to fail in marko template.

My template has these simple conditionals, but its not getting targeted properly. I don‚Äôt see the classes being added. (works however in plain html)

&#x3C;!--[if lt IE 7]&#x3E; &#x3C;html class=&#x22;lt-ie9 lt-ie8 lt-ie7&#x22; lang=&#x22;${locale}&#x22;&#x3E; &#x3C;![endif]--&#x3E;
&#x3C;!--[if IE 7]&#x3E; &#x3C;html class=&#x22;lt-ie9 lt-ie8&#x22; lang=&#x22;${locale}&#x22;&#x3E; &#x3C;![endif]--&#x3E;
&#x3C;!--[if IE 8]&#x3E; &#x3C;html class=&#x22;lt-ie9&#x22; lang=&#x22;${locale}&#x22;&#x3E; &#x3C;![endif]--&#x3E;
&#x3C;!--[if !IE]&#x3E; --&#x3E;&#x3C;html lang=&#x22;${locale}&#x22;&#x3E;&#x3C;!--&#x3C;![endif]&#x2014;&#x3E;

anything to do with the HTML comment‚Äôs?
 Hey @patrick-steele-idem, not a big deal, but you may want to update your code sample above to use `renderBody(out)` instead of `invokeBody()`
 I had noticed that even though they are preserved, variables weren't output correctly. I didn't dig into it too much, but I saw this issue and liked your `app-html` better anyway so I went with that.

So for example:

```
<!--[if IE 9]>
<html class="ie9" lang="$data.language"> <![endif]-->
<!--[if gt IE 9]><!-->
<html lang="$data.language">
<!--<![endif]-->
```

Would end up as:

```
<!--[if IE 9]>
<html class="ie9" lang="$data.language"> <![endif]-->
<!--[if gt IE 9]><!-->
<html lang="en">
<!--<![endif]-->
```
  Any value under the `value` attribute are referenced to marko `objects` but the same is not true for custom tags.

```
<assign var="options" value = "util.getOptions(options, pattern)" />
```

Custom Tag only accepts `$DATA` 

```
<ebayui-refit-itemgrid-pattern viewModel = $grid options = $options />
```

The below code will through an error in marko

```
<ebayui-refit-itemgrid-pattern viewModel = "grid" options = "options" />
```

Marko should promote one way of passing variables to support consistency.
  We are getting errors similar to what we see below, it will be great to get the entire stack trace here so we know what line has is the problem.

```
ERROR r1coltv/src/controllers/dealsHub: { '0': [TypeError: Cannot read property 'left' of undefined] } bad error
```
 Try accessing a property of an object which doesn't exist in the `renderer.js`. @patrick-steele-idem 
 ```
ERROR r1coltv/src/controllers/dealsHub: { '0': [TypeError: Cannot read property 'a' of null] } bad error
```

try running the code below

renderer.js

```
module.exports = function render(input, context) {
    var t = null;
    var a = t.a;
    console.log("asdasd", a);
    var model = getTemplateModel(input);
    if (model) {
        if(model.options.mode === 'large'){
            largeTemplate.render(model, context);
        }else{
            template.render(model, context);
        }
    }
};
```
  Hey,
This might be a hard thing to integrate, but I'd like to discuss it, maybe you will find it useful.
What want to accomplish is to load a component dynamically. Instead of using a html tag, I want to load it through a dedicated attributes value, lets say 'taglib'-attribute.

``` html
<div for="item in data.components" taglib="$!{item.component}-component" model="$!{item.value}">
```

or

``` html
<div for="item in data.components" taglib="item.component" model="$!{item.value}">
```

The problem is, if we'd like to be able to use every template available, we would need some sort of index with template names and their relative path. Alternatively, we could scope the available templates to only a certain directory, which would be easier, but not as clean. 

This would require us to have a compiled template like this.

``` javascript
templates = { "component-one": "./components/component-one/template.marko" };
return function render(data, out) {
      out.w('xxx');
      forEach(data.components, function(item) {
       __helpers.l(require.resolve(templates[item.component])).render({"value": str(item.value)}, out);
      });
    out.w('xxx');
  };
```

or

``` javascript
templates = {
            "component-one": __helpers.l(require.resolve("./components/component-one/template.marko"))
        };
return function render(data, out) {
      out.w('xxx');
      forEach(data.components, function(item) {
          templates[item.component].render({"value": str(item.value)}, out);
      });
    out.w('xxx');
  };
```

Of course we could check, if array contains element etc. This is just a dirty example. I know that this adds a bit of an overhead to the lightweight templates, especially if you got lots of components, but I couldn't think of any different/better way of doing this without sacrificing client-side compatibility. What do you think?

I could integrate it, though it will take me some time to dive into the code. A few hints where I find the responsible bits would surely help me.
 @philidem This is a nice approach, unfortunately not what I'm looking for.

Thanks to both of you for taking the time to respond in such detail., this helped me understand marko more. And sorry for apparently not explaining my issue properly, when re-reading the docs I found a great solution already in place: the `include`-tag. It seems to do all the required stuff like loading and rendering.

```
<include template="app/components/$!{item.component}/template.marko.html" value="$!{item.value}">
```

This will help me get started for now!

I will add .marko.html support to optimizer-marko in the next days.
  Let's introduce a new tag attribute that will do the same thing as `body-only-if`.
Most of the time the intention is to skip the container and the focus is less in the body.

``` html
<a href="${data.linkUrl}" body-only-if="!data.linkUrl">
    Some body content
</a>
```

Can get changed to:

``` html
<a href="${data.linkUrl}" render-tag-if="data.linkUrl">
    Some body content
</a>
```
 I think you had a good point. The meaning of `body-only-if` is more clear than `render-tag-if`, because, like you said, the condition is relative to the content in the tag, not to the tag itself. 
 Not really important but "body-only-if" confused me at first since it could be read as "render body, only if condition", instead of "render body only, if condition". May be changing to "only-body-if" could make it clearer...?
 Good suggestion, `only-body-if` seems much clearer to me. I was also confused when I first used this feature.
 I would add to this that maybe `only-body-when` or `only-body-if` make sense :)  Maybe the current wording comes off a bit strange because it intends to group the words "body only," but "only if" is already a phrase (as in "if and only if").  the Html color highlighting is not good enough for marko template files in Sublime, it will be great if we can create one for Marko templates
 Hey guys, I just started working w/ Marko recently and found this thread.

I've ported your Atom grammar file to a Sublime/Textmate format.  I've also ported the snippets as sublime completions.  Should be handy for us ST fans.

https://github.com/merwan7/sublime-marko

I've currently got a [PR](https://github.com/wbond/package_control_channel/pull/4652) to get this into the Package Control default channel.  Will update the readme once it gets merged.
 @patrick-steele-idem. Sure thing!  I will update that section as soon as it's added to the package control channel.

I couldn't find a tool to convert the grammars in that direction (atom->tm) so I wrote a little script which I am still working on, actually (will add to github soon).  There was some manual effort involved, too :)
 Not to toot my own horn here, but I ported @merwan7's Sublime syntax package to VS Code :). For anyone needing this, check it out here:
https://github.com/pcanella/vscode-marko
  There are several use-cases where you‚Äôd want .html files instead of .marko files. So I‚Äôve added support for ‚Äû.marko.html‚Äú files.
 Hey, thanks for the quick reply, I've refactored the code as requested, it should be all fine now. The tests do pass.
  I was struggling with this issue for an hour until one of our coworkers told me how to do it.
Please add it to the documentation. ( to reassign a value to an existing variable we need to use assign)

```
<assign var="itemModel" value="items[itemIndex]" />
```
  Yes please :)
  Is it possible to programmatically call taglibs?

Currently we can do the following when including template fragments:

```
<include template="src/modules/${module.alias}.marko"/>
```

I can include a different template based on the value of "module.alias".

I'd like to be able to have the same logic with taglibs. Something like this:

```
<var name="path" value="data.type" />
<app-test-${path} attr1="${data.attr1}" attr2="${data.attr2}" attr2="${data.attr2}"/>
```

Currently I can do the following:

```
<if test="data.type === "a">
    <app-test-a attr1="${data.attr1}" attr2="${data.attr2}" attr2="${data.attr2}"/>
</if>
<else-if test="data.type === "b">
    <app-test-b attr1="${data.attr1}" attr2="${data.attr2}" attr2="${data.attr2}"/>
</else-if>
<else>
    <app-test-c attr1="${data.attr1}" attr2="${data.attr2}" attr2="${data.attr2}"/>
</else>
```

This would work but I'd like to avoid having to copy over the same parameter code.
 This will work. Thanks.
  ```
<my-first-tag>
<my-second-tag>
```

The new line between these two custom tags should be preserved.
  Hi,

I need to define my custom tags using `marko` node module but not using JSON files described [here](https://github.com/raptorjs/marko#marko-taglibjson).

Maybe there is something like that?

``` javascript
var marko = require('marko');

marko.defineTag('my-hello', {
  renderer: require('./hello-renderer'),
  attributes: {
    name: 'string'
  }
});
```
 Thank you, @philidem! 
Looking forward to use this feature in my project.
 I agree with you, this is right decision in this case.

But in my situation I need to integrate Marko into my framework. It means I need to register some module-wrappers as custom tags and it is needed to do before calling `compile` method.

Actually, this is not a big problem for me because I have simplified stream-based HTML parser for using these module-wrappers as custom tags. I just wanted to remove my implementation and replace it with Marko functionality.

Thank you, anyway.
  I really like the idea of html templating, but I discovered an issue when I tried to use it in my usual dev flow.

As I understand: 
now the require-able templates are made possible through a temp file

```
fs.writeFileSync(tempFile, compiledSrc, {encoding: 'utf8'});
fs.renameSync(tempFile, targetFile);
return require(targetFile);
```

and although you can bust template cache with `unload(templatePath)`, this doesn't clear node's module cache. So every time you `require(targetFile)` it will return the same compiled template regardless your meddling with marko's cache. 
It's possible to clear node's cache with `delete require.cache["absolutePath"]` though, but manually it would be tedious to track every unneeded compiled template.

The problem this makes is during development when a file changes, I want to clear the cache so the engine can re-render the template, or refresh the browser for instance. 

I think writing the compiled template to disk should be a feature, or an option, rather than a byproduct of rendering. 

Is there a way not to write the compiled template directly to disk, but rather keep it only in memory?
I think it would be useful in development.

Thanks in advance!
 Yes, restarting the whole process is a way. But it takes a little more time than just letting a few templates re-render. And updating templates is a fairly frequent occurrence sometimes.

About the hackery: once I saw a method where a module was loaded from raw string and executed. I think it's a way of instantiating modules on the fly. 
...
Ah, there, I found it: http://nodejs.org/api/vm.html
But it's not really module loading/creating though.
 Well first, I really appreciate the detailed response.
Indeed you can clear node's require cache, I thought about that too. A bit hacky for my taste, but that's just me. 

As for the template loading for disk: I see, a sound reason. I've always missed the ability to debug templates (easily). Although I have to admit, it feels clutter to generate a script for each template, but it might just take some getting used to. I see the benefits however.

And thank you for the resources, I'll check them out soon. 
 Have to said that I'm really interested in this issue but I can't get it to work.

My workflow

adding this to the top of app.js

``` javascript
var marko = require("marko")
require('marko/browser-refresh').enable()
require('marko/hot-reload').enable()

require('fs').watch('web/marko', function (event, filename) {
  if (/\.marko$/.test(filename)) {
    require('marko/hot-reload').handleFileModified(filename);
  }
});
```

At this point starting my app with iojs app.js doesn't serve the template anymore and got TypeError: Cannot read property 'pipe' of undefined, 

Then I npm install browser-refresh and browser-refresh-taglib and add <browser-refresh enabled="true" /> to my layout

``` javascript
var server = app.listen(3000, function() {
    var host = server.address().address
    var port = server.address().port

    console.log('App listening at http://%s:%s', host, port)

    if (process.send) {
      process.send('online');
      console.log('Sending online message')
    }

})
```

Inside the listen of app.

Finally launching the command with browser-refresh 

```
[browser-refresh] App started (pid: 7888)
[browser-refresh] Waited 1500ms without receiving "online" from child process. Page refresh triggered over WebSockets co
nnection.
App listening at http://:::3000
Sending online message
[browser-refresh] Server is ready. Page refresh triggered over WebSockets connection.
::1
TypeError: Cannot read property 'pipe' of undefined
    at E:\JS.Next\app.js:71:27
    at Layer.handle [as handle_request] (E:\JS.Next\node_modules\express\lib\router\layer.js:82:5)
    at next (E:\JS.Next\node_modules\express\lib\router\route.js:110:13)
    at Route.dispatch (E:\JS.Next\node_modules\express\lib\router\route.js:91:3)
    at Layer.handle [as handle_request] (E:\JS.Next\node_modules\express\lib\router\layer.js:82:5)
    at E:\JS.Next\node_modules\express\lib\router\index.js:267:22
    at Function.proto.process_params (E:\JS.Next\node_modules\express\lib\router\index.js:321:12)
    at next (E:\JS.Next\node_modules\express\lib\router\index.js:261:10)
    at E:\JS.Next\node_modules\express-stormpath\lib\stormpath.js:171:7
    at E:\JS.Next\node_modules\express-stormpath\node_modules\async\lib\async.js:254:17
```

Also require('marko/browser-refresh').enable() is already calling hotreload.

I'm not sure where I miss the point in the setup ! 

HotReload is called in the debugging and here's how I called my template

``` javascript
var formulaTemplate = marko.load(require.resolve('./web/marko/formula.marko'))
app.get('/formula', function(req, res) {
  formulaTemplate.stream().pipe(res)
})
```
 It's a whole new project all packages are up to date on Windows.
Replacing pipe() with the direct rendering solved the problem.
All is working now, it's great to play like this to better understand Marko.

Also I supposed that browser-refresh called 'node' cmd and no more 'iojs', is there a way to tune this ?

Thx Patrick !
 Hi Patrick, here's another beginner question,

I have a fragment that render properly when directly called.

For testing purpose I only use this code :

Hello ${data.name}!

<ul if="notEmpty(data.colors)">
  <li style="color: $color" for="color in data.colors">
    $color
  </li>
</ul>

<div else>
  No colors!
</div>

This fragment is then included in the main layout but when I render a page
that extend the layout the
$data fields are no more presents and the resulting html is different from
a direct call. How is that possible ?
  A couple minor fixes.
