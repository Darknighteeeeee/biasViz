  As discussed in #1247, the fact that `Endpoint` has default values of `.get` & `.requestPlain` can be a point of confusion when users are creating their own Endpoints. This is cool, thanks @SD10! Did you also check Demo project/Docs if it needs updating anywhere? @sunshinejr I meant to check the docs and forgot. I will shift this to WIP and take care of it. About the demo app -- I'm guilty of not even thinking about that. I will do this too üòÖ  No worries! We have 2 projects right now that we have to check whenever developing stuff so it happens often, to me as well. We should take care of consolidating them (#891) in the near future so it is easier for us.  ### Changes:

**Adds:**
`MoyaError.parameterEncoding(Swift.Error) case`

**Refactors:**
`urlRequest` -> `urlRequest()` (now throwing)

### Summary of Pull Request:

As discussed in #1247 I saw that it would be really easy to pass on the errors thrown when attempting to encode `URLRequest` parameters.

All that had to be done is convert `Endpoint`'s `urlRequest` property to a throwing function and pass the error to the `.failure` closure in `MoyaProvider.defaultRequestMapping`.

Personally, I'm not too fond of having to call `try` now when accessing an `Endpoint`'s `urlRequest`. Therefore, I mostly consider this "research" unless any of you think there's value in it.   @Legoless The parameters get applied inside of the provider's `requestClosure`. 
It is set to [`MoyaProvider.defaultRequestMapping`](https://github.com/Moya/Moya/blob/master/Sources/Moya/MoyaProvider%2BDefaults.swift) by default. 
It does this by calling the [`urlRequest`](https://github.com/Moya/Moya/blob/master/Sources/Moya/Endpoint.swift) property on `Endpoint`. @Legoless this is a great idea. In fact, I think we should remove all default parameters from `Endpoint.init` as all of them might get confusing. Would you be up for a PR maybe? :)

It will be a breaking change, but I think this is for a good cause. I agree, let's remove them so no one else faces this issue. @Legoless Thanks for the feedback and sorry for the confusion! @sunshinejr Do you think there's any value in making the `urlRequest` property throwing and then propagating the parameter encoding errors? 

Since `defaultRequestMapping` just converts a `URLRequest` to a `Result<URLRequest,Error>` we can pass on this information quite easily here. Just on my mind from looking at this part of the code.

If `urlRequest` is used frequently outside of this context -- having to use it with try could be too annoying ü§î  @SD10 seems like it would be quite helpful! If you have some free time to research this one I think it would be a great update of our error handling üëç  Closing this in favor of #1249  Hey @gumnym, thanks for the issue. However, this one is rather a Mapper problem, see this one here: [Mapper#105](https://github.com/lyft/mapper/issues/105) (probably `null` in your JSON payload). You can bump this issue so the creators of Mapper know that this is still a valid problem.

I'm gonna close this one, but if there is something else to it please don't hesitate to reopen it again üëç   I look at coverage
I do not see test on uploading multipart data, so I make one like I make the others
I do not know if there is a better place for this

I upload file and data to httpbin.org
And check the JSON data returned by the server. I see one think about multipart data
`MoyaProvider.performRequest` could do execute an `fatalError`

If I provide an empty array of multipart data. A test maybe could be done  a simple test for upload using httpbin.org website

see #1115 Thanks for the fixes, @phimage! Would you be up for cleaning the swiftlint warnings as well (I mean without warnings that require huge refactor like lines of code etc.)? Would be awesome. Any reason to not add swiftlint in project build phrase?
 



 @phimage I think we just didn't think about it, but one thing to keep in mind is that Carthage needs special settings for that phase so that lint does work only for our development phase and not in users projects. For reference, you can look at [Quick#693](https://github.com/Quick/Quick/issues/693), [Quick#694](https://github.com/Quick/Quick/pull/694) and [Nimble#409](https://github.com/Quick/Nimble/pull/409)

If you want to take a stab at it, go ahead :)  Fixes #1206. These aren't perfect, but I think this is good enough for now. Should cover most of current behaviors if not all of them. 

**Edit:** Woah, first time above 80% code coverage in at least half a year! üéâ   The [`Package.swift`](https://github.com/Moya/Moya/blob/9.0.0-dev/Package.swift) will need to update its [API](https://github.com/apple/swift-package-manager/blob/swift-4.0-branch/Documentation/PackageDescriptionV4.md). Changes to the Package should also be reflected in the Readme.  Removed Swift 2 and added Swift 4. :)

Closes #1186  Hey @BasThomas, how are we with the updates? üòâ  I'll take a look later today! @sunshinejr - is this what you meant? If not, I don't really know what should be done further... let me know :) This is good, thanks, @BasThomas! What we should do next, I think, is that we should check whether `3.*` is true for all 3.0 Swift versions that we have in this table. So I've imagined that if there is a problem with 3.0, we would have 2 rows: one for 3.0 (with Moya versions that are working for Swift 3.0) and one for 3.1-3.2 Swift (with Moya versions that work for Swift 3.1-3.2). Does it make sense?  That does make sense. I *think* that all versions should work fine with all `3.x` versions though. Why do you think they might not be? Oh, I was pretty sure that there was some issue that not all version were working correctly. So maybe let's just double check if it works? Will you have time to do that maybe, @BasThomas? Unfortunately not. Think that would involve downloading old versions of Xcode as well, right? :( I'm currently using Xcode 8.2.1 for 2.3 project, but it has probably 3.0.2 Swift and I can use 3.1.1 Swift toolchain there as well. On the other hand 3.2 & 4.0 Swift can be checked on Xcode 9.0 beta I think. This is unfortunately time consuming and I'm not sure when/if I can do it, so maybe someone with more free time could pick this one, @Moya/contributors?  So I've noticed that today the builds were failing for lack of AppleTV simulator. I've connected the dots and quickly found out it was a problem with new Xcode beta being rolled out on CircleCI. I've made a bug-report and already got an answer (more [here](https://discuss.circleci.com/t/xcode-9-beta-6-lacks-apple-tv-simulator/15643/2)).

TL;DR Xcode didn't include some simulators in the new beta so they have to rebuild an image, which will take some days. We just have to wait until its done. I'll leave this issue until its fixed, so we can point out from PRs that it is in fact our CI issue. **Update:** AppleTV with iOS 11 simulator probably won't be available in this beta for us, maybe we will get iOS 10.2 instead, I will remove AppleTV for now from Rake since we need tests working, when new simulator is added I will add it back.  The object is accessible, why not receive it.
At completion, some information into `Progress` object could be very useful  Awesome, thanks @karthikdash! üôå
Congratulations on your first contribution üòÉ PR looks good, thanks @karthikdash! You also did it to 9.0.0-dev branch, that's awesome too! üéâ 

However, I'm not sure whether it resolves the issue. From the conversation in the issues referenced I'm not sure what the Carthage installation step should look like. I guess that it was connected to Moya/Reactive extensions versions? ü§î Could you make a short description/todo-list in the issue, @BasThomas?  I *think* the issue has to do with incompatible Moya / ReactiveSwift versions; so it is kind of unrelated - meaning we can leave the issue open (awaiting user feedback) when this is merged.

I am now going to the process of setting up an app with Moya via Carthage to check if everything works as expected. Thanks a lot for contributing to Moya! I've invited you to join the Moya GitHub organization ‚Äì no pressure to accept! If you'd like more information on what that means, check out our [contributor guidelines](https://github.com/Moya/contributors) and feel free to reach out with any questions.  Hey @JeanVinge, thanks for the issue!

This is actually how multipart file uploads are encoded (details [here](https://www.w3.org/TR/html5/forms.html#multipart/form-data-encoding-algorithm)). And even if it weren't, we can't change it really as Alamofire (our dependency for doing network requests) does it for us [here](https://github.com/Alamofire/Alamofire/blob/5bd458ca09a57fb2999772745d6438585f5140a7/Source/SessionManager.swift#L666) - just before sending the upload request and after our request setup (thus changing the request in Moya won't do anything).

Let me know if you have more questions around this topic!

**Edit:** Closing this one, but please don't hesitate to reopen in case you have more questions.  Alamofire provide also `Progress` for `DataRequest`.

Any reason to not use it? _Maybe not available when implementing the new progress callback in Moya_

This PR is for 9.0.0-dev ask requested #1232

---

`Progress` could be also provided at the end with response
phimage/Moya@c13fcd6
I will PR that after the merge of this PR
 Changelog updated Need to merge my commit into one to keep git history clean or this is good for you? @phimage Nah, not needed, thank you very much for this PR! üéâ  Thanks a lot for contributing to Moya! I've invited you to join the Moya GitHub organization ‚Äì no pressure to accept! If you'd like more information on what that means, check out our [contributor guidelines](https://github.com/Moya/contributors) and feel free to reach out with any questions.  Hey @neoD1, thanks for the issue. I guess you are right - we cannot support Swift 4.0 with RxSwift and Moya 9.0. This is because we probably gonna release it before Swift 4.0 and RxSwift 4, and after the new releases we will update our extensions. 

Right now we offer Moya core working with Swift 4.0 (on branch `9.0.0-dev` for a while yet) or Moya with Swift 3.2 that should work correctly with RxSwift 3.3+. Sorry for the inconvenience! 

If you have any more questions, let me know.  Alamofire provide also `Progress`for `DataRequest`.
Any reason to not use it? Maybe not available when implementing the new progress callback in Moya

Following that `Progress` could be also provided at the end with response
https://github.com/phimage/Moya/commit/c13fcd6ded55309cd6cf5e6d789f50420fedd04d @phimage Thank you for the PR üéâ I've only skimmed the changes but I know this will conflict with changes made to `TargetType` from #1147 in the `9.0.0-dev` branch. If we move forward on this PR, maybe you could submit your work to `9.0.0-dev`? Ok I can redo my commits for 9.0.0-dev 
and use my fork until release

PS: Any reason to not have swiftlint in build phase of xcode targets. I think I have added some trailing whitespaces  Hey @jdeanwaite, thanks for taking the time to come back and share the solution. This may be useful to other users üëç   This PR adds tests for Single+Response (for RxMoya), fixing issue #1227. 

This PR also:

- Wraps Test Helpers converting Response to Single/Observable under `RxTestHelpers.swift`.
-  Moves Test Helpers related to generating Test Images to `TestHelpers.swift`.
- Reorganize `TestHelpers.swift` with some `MARK`s and sectioning of helper methods / classes. Updated the Changelog and also did a "Build without Cache" for good luck üçÄ  @freak4pc I just cleared the cache and triggered a rebuild.
Anyways, thanks for taking care of this so Swiftly üòÜ There's some nice cleanup in there. Thanks for the review! @SD10 
I'll wait for CI to clear and @sunshinejr to review this and feel free to merge whenever üëç  By the way this "cache" issue is probably the fault of `scripts/bootstrap-if-needed.sh` ...  It looks like your program crashed at breakpoint, can you share what was outputted in the console? @xumoyan Sorry I don't exactly understand what you're trying to convey in your last message. The output you've posted looks like the result of setting a breakpoint. If there is a crash unrelated to the breakpoint, would you be able to provide us with the console output?    `Supporting files` directory included prints a warning and I get an error from not including `Foundation` in these two files, so this should fix it ü§û 

Also, we might need to add compatibility checks on our CI soon. Yikes ü§¶‚Äç‚ôÇÔ∏è 

> Module compiled with Swift 3.1 cannot be imported in Swift 3.2: /Users/distiller/Moya/Carthage/Build/tvOS/Alamofire.framework/Modules/Alamofire.swiftmodule/x86_64.swiftmodule
 Same error recently happened to me. I think @sunshinejr fixed it by clearing the build cache ü§î This error is gonna haunt me forever. Not sure why I always need to rebuild without cache. How does it get this old cache? Anyone has an idea? ü§î  First time i'm seeing CircleCI and can't say it feels very reliable thus far ü§î  Seems like you can just add a post hook to manually clear the cache. But still super annoying: https://circleci.com/docs/1.0/how-cache-works/#clearing-cache Clearing cache is not something I would pursue, since building dependencies each time might be too painful. I'm thinking if this is a temporary problem, since on master we have this old cache with 3.1, and on 9.0.0-dev we have new cache with 3.2. Maybe new PRs are getting cache from master and that's the problem? ü§î  Yeah that makes total sense, since I imagine the entire project reuses some of the same caches/machines? I guess we can "wait the pain out" until 9.0.0 is out next month, right? :)  Yeah that makes sense the docs updates / gardening of master matches the inconsistency of the error.
Next month?! üò± We're so close!!  Yeah, let's just wait that out until we merge it for next version (which should be a lot faster than one month üòÑ)  Hey @nhantrivinh,

There is a method on Moya response which you can use to filter a specific status code:
```Swift
    public func filter(statusCode: Int) throws -> Response
```
Let me know if this helps.
 The approach is up to you :)
If you want to catch the error, then maybe want to push a uialercontroller onto the view hierarchy?
Another option could be to try re-trying the request  @nhantrivinh Glad you were able to work this out üòÉ   @danwey We're working on it. Moya `9.0.0` will support Swift 4 and should be released soon. Hey @danwey. As @SD10 said we are working on it, in fact it is already done and is waiting for a release. In the meantime you have 2 workarounds (until we release next version of Moya):
1. You can use Swift 3.2 in Moya but 4.0 in your project (see more about it [here](https://github.com/Moya/Moya/issues/1189))
2. You can use our `9.0.0-dev` branch which should have Swift 4.0 support already, but bear in mind that it is our development branch and it is not the safest one (I would advise against using this one in production). 

Please let us know if you have some more questions around it :) @danwey do you use `swift4.0` branch of `RxSwift` in your `Podfile`? I'm not sure I understand you correctly, @danwey, but if you still want to use Swift 4.0 version of Moya and RxSwift, you should use our `9.0.0-dev` branch and RxSwift's `swift4.0` branch:
```rb
pod 'Moya/RxSwift', :git => 'https://github.com/Moya/Moya.git', :branch => '9.0.0-dev'
pod 'RxSwift', :git => 'https://github.com/ReactiveX/RxSwift.git', :branch => 'swift4.0'
```

Please keep in mind that these are both prerelease branches and might expect difficulties/bugs.  Hey there :)

I‚Äôve looked through the code and noticed that for some reason the RxSwift implementation creates an Observable using `Observable.create` and then uses `asSingle()` to convert it, instead of just using `Single.create` to begin with, so pushed this quick commit. 

There should be zero impact, as it's just an implementation detail. Sorry about the incorrect branch here ;) It auto-selected and I missed it. @sunshinejr 

*edit*: was sure a close & open of the PR would trigger a rebuild. ü§î  All green. Do we want a Changelog entry for this ? @sunshinejr  Just an internal fix without impact, don't think it needs a Changelog entry. :) Thanks a lot for contributing to Moya! I've invited you to join the Moya GitHub organization ‚Äì no pressure to accept! If you'd like more information on what that means, check out our [contributor guidelines](https://github.com/Moya/contributors) and feel free to reach out with any questions. That was my thought as well. Thanks !  Thanks for cleaning up my mistake @freak4pc üôà Haha, no worries. My pleasure @AndrewSB üíØ   There were a few issues regarding multipart upload with parameters and how to do it (e.g. #1209). I feel like this is a good time to add an example to our [docs/Examples](https://github.com/Moya/Moya/tree/master/docs) directory, especially having a new release in place. What I'm thinking about is a document with one (or more) examples, but the one we need for sure is an image upload with additional parameters.

Let me know if something is not clear üëç  Hey @nhantrivinh! I can't remember if I saw a full example out there, so I'm gonna try to give it here. Basically you need to pass parameters only in `MultipartFormData` of a `task` property (if these aren't url parameters). 

For instance, if you want to pass gif data and `description` parameter, you would combine these like:

```swift
let gifData = MultipartFormData(provider: .data(data), name: "file", fileName: "gif.gif", mimeType: "image/gif")
let description = MultipartFormData(provider: .data("description of a gif".data(using: .utf8)!), name: "description")
let multipartData = [gifData, imageWidthData]
```

Now, you would just wrap it in the `task` property, like:
```swift
extension Giphy: TargetType {
    public var task: Task {
        switch self {
        case let .upload(data):
            let gifData = MultipartFormData(provider: .data(data), name: "file", fileName: "gif.gif", mimeType: "image/gif")
            let description = MultipartFormData(provider: .data("description of a gif".data(using: .utf8)!), name: "description")
            let multipartData = [gifData, imageWidthData]
            return .upload(.multipart(multipartData))
        }
    }
}

```

For Moya 9 the return type would be a little bit different (as the API is more verbose now):
```swift
return uploadMultipart(multipartData)
```

And that new API we would like to have in our docs. 

Hope it helps!   This should fix #1217. By mistake, new file was added to `Moya` target rather than `RxMoya`. Can you confirm, @Dschee, that it works on this commit?   I'm using the most current commit of the 9.0.0-dev Branch and I'm not using any reactive libraries. Since updating the dependency from my own fork (commit 4bcac8144fd438b9b93c2a9907a8581dfd899278) to commit 0c25037dcf2a4213124fe0a423656b14ee0209d4 I'm seeing the following error when building:

```
dyld: Library not loaded: @rpath/RxSwift.framework/RxSwift
  Referenced from: /Users/JamitLabs/Library/Developer/CoreSimulator/Devices/98DE006C-DE6C-45D2-9A42-4440CFD6DA9C/data/Containers/Bundle/Application/F1A76703-C1FA-4236-AD1B-7167A09B72F6/TreasuryManager.app/Frameworks/Moya.framework/Moya
  Reason: image not found
```

I have not included the RxSwift library into my project, but I don't want to since I'm not using reactive Moya. The inclusion is done via the current Carthage version. I would expect that error to not appear so I don't have to include RxSwift like it always worked before. Are you sure it worked before? I think there's no option to get an equivalent to the "subspecs" in CocoaPods, so you'd have to download everything. That should still not show the library not loaded error, though. ü§î, interesting. Check the PR (#1218) that was just opened.  No problem, thanks to you for testing 9.0.0-dev on Carthage so we have a feedback and we can fix bugs faster üôá 

Also, gonna close it in favor of #1218 then.  @ivangodfather The `stubClosure` argument for the `MoyaProvider` initializer is a closure that takes in a `TargetType` and returns `StubBehavior`. You can pass it a custom closure that switches on the cases of the target and returns the respective stub behavior that you'd like. Is this what you were looking for?

Example:
```Swift
let stubClosure = { (target: TargetType) -> Moya.StubBehavior in 
    switch target.path {
    case "endPointThatShouldReturnAStub404":
        return .immediate
    default:
        return .never
    }
}
``` @ivangodfather Sorry, I think I understand better now. The example was just that -- an example üòÑ.
What's wrong with your current approach? @ivangodfather Are you calling `setProvider()` before every request? @ivangodfather I think there may be some issues with the initialization of the `MoyaProvider`. 
```Swift
// Here when you're passing the new endpointClosure you're not giving it stubBehavior
// it defaults to `.never`
provider = MoyaProvider<TWApiProvider>(endpointClosure: endpointClosure)

// I think it should be
provider = MoyaProvider<TWApiProvider>(endpointClosure: endpointClosure, stubClosure: MoyaProvider.immediatelyStub)
```
Sorry I wasn't able to help but I will check back later üòû Let me know if you resolve this. @ivangodfather Did you see the edit in my most recent comment? It looks like you're overwriting the stub behavior you provided in the first initialization of `MoyaProvider`. @ivangodfather Can you see if this documentation helps? [Providers.md](https://github.com/Moya/Moya/blob/master/docs/Providers.md#advanced-usage)

Basically, your `stubClosure` handles the mapping of a `(TargetType)` -> `StubBehavior`.
This allows the MoyaProvider to have different stub behavior based on the target.

Similarly, the `endpointClosure` handles the mapping of a `(TargetType)` -> `Endpoint`.
This allows the MoyaProvider to have different endpoints based on the target.
You need this because you want to return a *404* response for some targets.

It looks like you will need both a custom `stubClosure` and `endpointClosure` to achieve the behavior you want. Am I making sense? 

My final recommendation is to maybe do your tests in a Unit Test Target. Then create a mock provider solely for testing in the `XCTestCase`.
  @ivangodfather I'm trying to tell you that you're not receiving the sample response closure because your `MoyaProvider` is defaulting to a stubBehavior of `.never`.

```Swift
// This line of code will not stub requests. It defaults to `.never`.
// This is why you are receiving an actual request and not stubbing.
provider = MoyaProvider<ApiProvider>(endpointClosure: endPointClosure)

// You need to provide a stub behavior to receive the sample response
provider = MoyaProvider<ApiProvider>(endpointClosure: endPointClosure, stubClosure: MoyaProvider.immediatelyStub)
```

Am I making sense? Nice to hear you've resolved the issue, and thanks for providing your implementation! üëç  This is in favor of #1172 and related to #1214.

I've added the `AuthorizationType` enum, updated the existing tests, and added a new one for `.basic` authorization.

### Thoughts:
The old implementation of `AccessTokenAuthorizable` added an authorization header of "Bearer" to all target types by default. We need to determine which authorization type we're going to default to - if any. The current tests represent defaulting to the case `.none` -- no headers added. This would be a breaking change to the current and default expected behavior.

What do you guys think?  It looks like the build error is from compiling the project in Xcode 8? Admittingly, I haven't been using Xcode 9 beta enough üòÖ  We've changed Xcode on CI from 8.3.3 to 9.0.0 and the there is still cache built with 8.3.3. I re-triggered your build without cache, @SD10, and it seems fine :)

About the PR - looks really nice! We don't really default to anything - if you don't implement the protocol and do not specify what `AuthorizationType` you need, you won't get any headers added. This is a breaking change, yes, but in different way. People now do not decide whether they want authorization or not, but rather if they want authorization, they need to specify which one. @sunshinejr I made the requested `tokenClosure` changes. If anyone else has any other changes or feedback just let me know. Once the implementation is agreed on I'll:
- [x] Update Docs
- [x] Add a CHANGELOG entry
- [x] Do you want me to add something in the MigrationGuide.md? üëç Code-wise seems good to me :) @sunshinejr I updated the documentation and the `CHANGELOG.md`. Let me know how those look. 
Also, let me know if you want me to write something in `MigrationGuide.md`. Yeah, I feel like we should add something to the `MigrationGuide`, especially if we have this file already created. I didn't closely check the PR, but from the brief overview it looks great üëç 

Also, now that I think about it, we should add few lines about migrating to new reactive APIs, but thats another issue.  @sunshinejr Done. Sorry for all the push spam. My rebase attempt failed so I just took care of the CHANGELOG conflict with a commit.

What do we need to add the the MigrationGuide.md for the Reactive API's? Just the fact that they're in the `reactive` and `rx` namespaces? I can add this in another PR. No problem, @SD10 üëç Is this PR still `WIP`? If you feel like this is ready for a review, we can remove the prefix so people can chime in :)

About migration guide and reactive providers - you are correct. We should stop using reactive providers and use `rx` and `reactive` namespaces instead. We could also point to this [PR from Ash in Eidolon](https://github.com/artsy/eidolon/pull/669), that covers migration from subclassing to composition.  @sunshinejr Yeah, I removed the WIP tag. I'll open a PR to work on the MigrationGuide for the reactive API sometime later today. @pedrovereza Changes made. Thank you for jumping in and giving me your review! Those were some great suggestions üòÉ   This was discussed in #1020, but I think it wasn't added yet. I found this one out by playing with new API and I certainly would love these to be in the next release (having to add `asObservable()` and loose all the nice `Single` API would be really sad).

Also, I've read that @AndrewSB wanted to do a generic protocol of some sort, I also thought about it, but I don't think there is an easy/clean way to do that. `RxSwift` uses similar approach to this one in PR (see [here](https://github.com/ReactiveX/RxSwift/blob/1314805175263ad8141054f6be21f6bbef224d2c/RxSwift/Traits/PrimitiveSequence.swift#L464-L475) for instance) üëã

Thanks for doing this @sunshinejr, let's also remove the functions that are on `ObservableType`, since the ones you've added on `PrimitiveSequence` should work for both `Single`s and `Observable`s Hmm, are you sure that it works for both @AndrewSB? I don't see it in code, but I might be missing something. From my understanding, observables are primitivetypes, but I'm not sure
either

I'll take a look soon
On Fri, Aug 11, 2017 at 10:33 AM ≈Åukasz Mr√≥z <notifications@github.com>
wrote:

> Hmm, are you sure that it works for both @AndrewSB
> <https://github.com/andrewsb>? I don't see it in code, but I might be
> missing something.
>
> ‚Äî
> You are receiving this because you were mentioned.
> Reply to this email directly, view it on GitHub
> <https://github.com/Moya/Moya/pull/1213#issuecomment-321873359>, or mute
> the thread
> <https://github.com/notifications/unsubscribe-auth/ADo1dAq7ukf9591S5C_7WkJpsuXxRY23ks5sXJBrgaJpZM4O02ym>
> .
>
 https://github.com/ReactiveX/RxSwift/blob/master/RxSwift/Traits/PrimitiveSequence.swift#L60

It looks like PrimitiveSequence conforms to ObservableConvertibleType... so I was wrong, we need to keep the operators duped between Observable & Primitive :/ 

sais la vie Oh, you are right. Maybe we will get something better in the future, doesn't seem too clean to me as well. 

Nonetheless, thanks for the CR, @AndrewSB ‚ù§Ô∏è   Solves #1203. Also:
- Removed mentions of `RACSignal` - we removed in version 7.0.0
- Fixed some places where we were using `onNext` event instead of `onSuccess` for `Single` replacement in RxSwift
- Improved descriptions of RxSwift & ReactiveSwift in Readme

I wanted to bring back RxSwift examples as well, but these needs updating first. So we will add it later üëç For now I removed urls to them in `docs/Examples/Readme.md`, since these are not there anymore üòÑ 

Cheers! Thank you for the CR, @pedrovereza! ‚ù§Ô∏è   Hey @swordjoy. The code you posted is good for multipart uploading. If you want to add text to it, you should add it to the multipart data as well. For instance, if you wanted to add `width` parameter to the request, you would do:
```swift
mutDatas.append(MultipartFormData(provider: .data("100".data(using: .utf8)!), name: "width"))
```

Let me know if it resolves your issue or if you have some more questions around this topic :)  @riyanpratama Let me preface this by saying I don't know much about Carthage.
It looks like you're using `ReactiveSwift 1.0.0` and `DateScheduler` was added in version [1.1.0](https://github.com/ReactiveCocoa/ReactiveSwift/releases/tag/1.1.0).

I think that Moya `8.0.5` has a minimum ReactiveSwift requirement of `1.1.0`.

Let me know if this helps. You have a dependence on `ReactiveSwift` 1.0.0, but `Moya` needs 2.0.0. Did you add `github "ReactiveCocoa/ReactiveSwift" "1.0.0"` for a reason? I don't know why you get the error of the renamed `MoyaError` in the availability file. Which Swift version are you using? And which version of Xcode?  Hey @aelam,
The current documentation is representing Moya [v9.0.0-alpha.1](https://github.com/Moya/Moya/releases/tag/9.0.0-alpha.1). If you want to continue using Moya `8.0.5` you will need to use the `RxMoyaProvider`. Let me know if this helps üòÉ  Exactly what @SD10 said. You can browse the `8.0.5` documentation here: https://github.com/Moya/Moya/tree/4512a2a4bc8019cf006434378ac6a0640f34f35f/docs  We might need to check if our documentation is up-to-date (in branch 9.0.0-dev) with the changes to parameters/parameterEncoding/task from #1147. 


If someone is up for this task, please assign yourself so we won't dup our work. Cheers! üòâ  Documention Affected:
- [x]  [Basic.md](https://github.com/Moya/Moya/blob/4207ead20f3da590194b1be1d64d409316c083cf/docs/Examples/Basic.md)
- [x] [Targets.md](https://github.com/Moya/Moya/blob/4207ead20f3da590194b1be1d64d409316c083cf/docs/Targets.md)
- [x] [Endpoints.md](https://github.com/Moya/Moya/blob/4207ead20f3da590194b1be1d64d409316c083cf/docs/Endpoints.md)
- [x] [ArraysAsRootContainer.md](https://github.com/Moya/Moya/blob/aa33a0466d7333516691b3e5212c5acb41990928/docs/Examples/ArrayAsRootContainer.md)
- [x] [Providers.md](https://github.com/Moya/Moya/blob/4207ead20f3da590194b1be1d64d409316c083cf/docs/Providers.md)
- [x] [OptionalParameters.md](https://github.com/Moya/Moya/blob/4207ead20f3da590194b1be1d64d409316c083cf/docs/Examples/OptionalParameters.md)
- [x] [Assets.md](https://github.com/Moya/Moya/blob/aa33a0466d7333516691b3e5212c5acb41990928/docs/Examples/Assets.md)

It's important to know that a great deal of these has already been taken care of in #1147 so that should be the basis for which docs still need updating. 

If I can check any of these off the list when I have time I will.
  Thanks a lot for contributing to Moya! I've invited you to join the Moya GitHub organization ‚Äì no pressure to accept! If you'd like more information on what that means, check out our [contributor guidelines](https://github.com/Moya/contributors) and feel free to reach out with any questions.  What is your current Moya version? You can check in the `Podfile.lock`. And can you maybe also share the contents of your Podfile itself? I just set up a fresh projects and everything builds fine. Moya is using `8.0.5` there.  Hey @i-schuetz. Thank you for writing a complete guide how to fix the issue you encountered! :D This surely will help people with similar problems in the future, so again thank you for doing this.  Hey @edopelawi. Thank you for your really well written description of the issue! Glad you figured this out. üòâ   @ondev Have you been able to find any useful documentation? 
I recommend reading [Targets.md](https://github.com/Moya/Moya/blob/master/docs/Targets.md) and [Basic.md](https://github.com/Moya/Moya/blob/master/docs/Examples/Basic.md). 

The `MoyaProvider` is generic over an object conforming to the `TargetType` protocol. 
Your `MoyaProvider` instance can make any number of requests to the underlying `TargetType`.  Nice one, @yangcaimu! Would you be able to remove these from Tests as well? Would be awesome :) Thanks a lot for contributing to Moya! I've invited you to join the Moya GitHub organization ‚Äì no pressure to accept! If you'd like more information on what that means, check out our [contributor guidelines](https://github.com/Moya/contributors) and feel free to reach out with any questions.  Hey @xumoyan. Thanks for the issue! However, this is a duplicate of #1189. Please see it as there is more info about this and current workaround. Basically you created a Swift 4.0 project, and we currently do not support it. You need to change Swift version of Moya to 3.2, or wait for 9.0 release (after #1193 merges).

Let me know if it resolves your problem :)  Hey @xavierXing. You would have to use your own `manager` in `MoyaProvider` for that one. You would then configure your certificate handling in it. You can see how we use it in our `defaultAlamofireManager`:
```swift
public final class func defaultAlamofireManager() -> Manager {
    let configuration = URLSessionConfiguration.default
    configuration.httpAdditionalHeaders = Manager.defaultHTTPHeaders
    
    let manager = Manager(configuration: configuration)
    manager.startRequestsImmediately = false
    return manager
}
```

Of course this one doesn't have certs handling in it. But you can just use the same setup as for self-signed certs in Alamofire.

Let me know if you have any more questions about it :) @xavierXing Hey, I have a [demo project that shows how to use self-signed certificates with Moya](https://github.com/pedrovereza/SelfSignedMoya). Let me know if you have any questions :wink:

Edit: You can also find more details in #992  Hey @xavierXing. Please post your code and we will try to help you :)  Right now #1193 will update our Swift support to Swift 3.1, 3.2 and 4.0. While it is awesome, we should do some checks to make sure we do not break these unintentionally. We can do builds for all of them, but I think checking for 3.2 & 4.0 compatibility should be enough. What do you guys think? I think those two would be enough. Then in September we can drop Swift 3 tests. **Update:** So I tried the new workflows API from CircleCI, but [seems like macOS is not yet supported there](https://discuss.circleci.com/t/os-x-macos-ios-support-on-circleci-2-0/16430). Thus, we probably need to fallback to rake.

**Edit:** I'm gonna unassign myself from that one for a while, if anyone have more free time to do it, feel free to assign yourself.  In this PR I've updated `NetworkLoggerPlugin` as it was the only reason Swift 4 compiler was having troubles with moya. I've also updated our CI to use Xcode 9. In the future we should look to support 2 builds - with Swift 3.2 & 4.0. 

Right now, with this changes, 9.0.0 release should support:
- Swift 3.1
- Swift 3.2
- Swift 4.0

I've tested it locally and it seems to be working correctly.

**Edit:** Oh, and also I've created a new **9.0.0-dev** branch.  Sure! Good catch, @pedrovereza, PR updated :)  @alfian0 How about using the case `statusCode(Response)` from the `MoyaError` enum? 

You can then get the `statusCode` property by extracting the associated value of `Response`. 
Let me know if this helps üëç

In Moya `9.0.0` (which should be released soon) you will also receive the response (if any) in the `.underlying` case. @alfian0 Unfortunately, if you need the `statusCode` in the `.underlying` error case, you'll have to wait for the Moya 9.0.0 release. Sorry :( This is possible with Moya [9.0.0-alpha.1](https://github.com/Moya/Moya/releases/tag/9.0.0-alpha.1) but keep in mind this version is still a pre-release. It will have official support in Moya `9.0.0` which is soon to come.  Hey @plam4u. Thanks for an issue!

I must admit that this is the first time I'm seeing this error and so my comment may not be useful at all. But, from my googling, I found 2 projects that use this error log and both use really similar codebase ([there](https://github.com/apigee/apigee-ios-sdk/blob/master/source/Classes/Services/ApigeeNSURLConnectionDataDelegateInterceptor.m) and [there](https://github.com/xplatsolutions/iOS-Network-Interceptor/blob/master/NetworkInterceptor/NetworkMonitor/XplatNSURLConnectionDataDelegateInterceptor.m)).

Are you sure these errors are from Alamofire? I'm not seeing  anything like that in their sources but maybe I just didn't search enough üòÑ   Hey @wz1383691. This is a duplicate of #1189. Basically we don't really have a Swift 4.0 support right now. Please head to #1189 for more info.  We should do that for our 9.0.0 release, gonna make sure people will have a clear view as of which version they can use for their app. Thanks for reporting, @Coeur üëç  ‚úÖ `8.0.5` with Xcode `8.3.3`
‚úÖ `8.0.5` with Xcode `9.0` (opened with the previous project)
‚ùå `8.0.5` with Xcode `9.0`
‚ùå `8.0.5` with Xcode `8.3.3` (opened with the previous project and Deployment target reset to `10.3`

So the first point should be OK: Swift 3.2 works on Xcode 9.  Can you update the Demo's Podfile.lock as well? Just can do so by running `pod update` in the `Demo` directory. Thanks üëç Awesome, thanks @larryonoff! :) Good job, @larryonoff! However, we might want to wait with this one after the #1181 merge, since there are multiple changes to reactive providers. If you could it would be awesome üëç  Thanks a lot for contributing to Moya! I've invited you to join the Moya GitHub organization ‚Äì no pressure to accept! If you'd like more information on what that means, check out our [contributor guidelines](https://github.com/Moya/contributors) and feel free to reach out with any questions.  Hey @lhalcyon. It seems like we don't have that option right now, but to allow this behavior we could just add another parameter in [NetworkActivityClosure](https://github.com/Moya/Moya/blob/master/Sources/Moya/Plugins/NetworkActivityPlugin.swift#L12), from:
```swift
(_ change: NetworkActivityChangeType) -> Void
```
to
```swift
(_ change: NetworkActivityChangeType, _ target: TargetType) -> Void
```

and this way you could make conditional statements based on `TargetType`. Also, I think this would be a valuable addition to our codebase, so maybe you would you be up for a PR? üòâ   Hey @larryonoff! Your proposal is just in time for our 9.0.0 version üòÑ I think this one can get in as well, what do you guys think, @Moya/contributors?  Sounds good to me!
On Sat, Jul 22, 2017 at 3:35 AM ≈Åukasz Mr√≥z <notifications@github.com>
wrote:

> Hey @larryonoff <https://github.com/larryonoff>! Your proposal is just in
> time for our 9.0.0 version üòÑ I think this one can get in as well, what
> do you guys think, @Moya/contributors
> <https://github.com/orgs/Moya/teams/contributors>?
>
> ‚Äî
> You are receiving this because you are on a team that was mentioned.
> Reply to this email directly, view it on GitHub
> <https://github.com/Moya/Moya/issues/1182#issuecomment-317174538>, or mute
> the thread
> <https://github.com/notifications/unsubscribe-auth/ADo1dFjjCxZclQaRMAkGpxoyNoOk9ZR4ks5sQdB3gaJpZM4OgHcz>
> .
>
 Cool! I think we should do it after #1181 merges onto master since there are many changes already.

Also, maybe you would be up for doing PR with the update, @larryonoff? üòâ  @larryonoff `carthage bootstrap`  Hey guys! üéâ 

I'm really excited to say that we are almost there! Just need to double check if this merge got everything we need for 9.0.0. This is a really long one, but don't be scared! Most of that codebase was reviewed in multiple PRs so this is just a final check to see if it's alright. Even if its not, we still got alpha/beta tests so no worries.

Cheers!

**Edit:** Also, related: #1075  Good ones, @pedrovereza! Updated both `Changelog` & comment for `headers` in `TargetType` üëç  Okay, I also fixed most of the issues from SwiftLint. The rest is either from Demo (which we might update as well, in another PR) or from things we know exist but we need time to refactor (like long `MoyaProviderSpec`) Hey @Moya/contributors, just a reminder that we'd love it if we could get another pair of eyes on that one. Pushing an alpha release this week would be üíØ  Thank you, @SD10! @pedrovereza, do you feel like you'd have time to validate this one as well? :)  Thank you so much, y'all! üéâ   Hey @dindonkey. You can use it the same way as any other `Observable`. Below is the simple test taken from `RxSwift` repository:
```swift
func testSequenceOf_complete_immediate() {
    let scheduler = TestScheduler(initialClock: 0)
    let res = scheduler.start {
        Observable.of(3, 1, 2, 4)
    }
    
    XCTAssertEqual(res.events, [
        next(200, 3),
        next(200, 1),
        next(200, 2),
        next(200, 4),
        completed(200)
    ])
}
```

This code above is a simple test from `RxSwift ` using `TestScheduler`. What you want to do is to replace `Observable` in `scheduler.start` method and then assert whatever you like:

```swift
    let res = scheduler.start {
        provider.request(target).observeOn(scheduler)
    }

    XCTAssertEqual(res.events, [
        next(200, response),
        completed(200)
    ])
```

This code above might not compile since I didn't try this one out, but the idea should be precise. Also don't forget to manipulate `stubClosure` in your tests üòÑ 

Let me know if it helped or if you have more questions about it üêº   This is a little gift, because I always need to implement my own function/extension that creates `URL` from `TargetType`. I figured that other people might find it useful too üòÑ  Would it not make more sense to make the `private` func public? Having this extension on `URL` feels a bit weird / hard to discover. Hmm, you might be right and it might be hard to discover manually. But I think you will find it from the docs anyways. But I'm open for a change üòÑ  I like the `URL` init over having to access a class method on `Endpoint`. It feels right.

I guess this raises the question of providing these kinds of utilities in Moya, considering I think we haven't extended Apple's frameworks thus far?

From [Targets.md](https://github.com/Moya/Moya/blob/master/docs/Targets.md):
```Swift
extension String {
    var urlEscaped: String {
        return addingPercentEncoding(withAllowedCharacters: .urlHostAllowed)!
    }
}
```
I believe there also use to be one like this: 
(which I'm thankful is removed because it confused me when starting out and not seeing the bottom)
```Swift
extension String {
    var utf8StringEncoding: Data {
        return data(using: String.Encoding.utf8)!
    }
}
```

Just my two cents, to say we discussed it in the case someone adds another extension and tries to point to this as justification.
 Good point @SD10! I think that it might be a rare case that we extend Apple framework, but if we do, I feel like it has to be something unique to Moya. In this case, we are creating `URL` from a `TargetType`, which is only viable for `Moya` codebase. This way users shouldn't get confused since the type accepted by this `init` is important only for Moya users. In case of these other two extensions you showed, they may seem like standard library methods üòÑ  > I think that it might be a rare case that we extend Apple framework, but if we do, I feel like it has to be something unique to Moya.

This sounds like a good precedent üëç. Where to document it? Endpoints.md?

Endpoints.md...

----

The first might resemble the following:
```diff
let endpointClosure = { (target: MyTarget) -> Endpoint<MyTarget> in
+   let url = URL(target: target).absoluteString
    return Endpoint(url: url, sampleResponseClosure: {.networkResponse(200, target.sampleData)}, method: target.method, parameters: target.parameters)
}
```

This is actually the default implementation Moya provides. If you need something custom, like if your API requires custom parameter mapping, or if you're creating a test provider that returns non-200 HTTP statuses in unit tests, this is where you would do it.

```diff
+ Notice the URL(target:) initializer, Moya provides a convenient extension to create a URL from any TargetType.
```

...

 Yeah, I think `Endpoint` is the place where we use this extension and where you would need it for a basic implementation. Would you be up for updating the docs in another PR? :) Yeah @sunshinejr I'll take care of it tomorrow afternoon üëç What do you think about it, @BasThomas? :) üëç  Hey @mrachid. This is not the easiest thing to do, so I understand your pain. 

Could you please share what have you tried? The best would be code that you wrote with comments around places you had problems with. This way we could figure out the easiest way to help you in your specific scenario (configuration, abstraction layers etc.) @mrachid this conversation may help https://github.com/Moya/Moya/issues/748#issuecomment-260059360  Hey @zichenJack. Thanks for detailed explanation. This should be a fairly easy fix. As error says, the problem is because both `Moya` and `Swift` use type name `Error`. Having imported `Moya`, the compiler just gets confused as to what type do you really want. To make sure it gets a `Swift` one, just prefix the type with `Swift.`, like `Swift.Error`:

```swift
    func webView(_ webView: UIWebView, didFailLoadWithError error: Swift.Error) {
        print("UIWebView Error")
    }
```

and it should resolve the issue. I've tested it on a clean project using Moya 8.0.5 and Swift 3.1 and it worked correctly, but if you still encounter the issue, please let us know! üëç   Hey @GTMYang thanks for reporting this. Can you provide us with any more information?
i.e) Specific compile errors, your Swift version, Moya version Also, we'd be open to a PR that fixes the breakages üòÑ  @GTMYang Are you sure this is an issue with Moya? I can't find any reference to it in the error output.  Hey @ArthurAlvarez. This is a good one!

I must say that there is no _easy_ way to do it right now. We have an [AccessTokenPlugin](https://github.com/Moya/Moya/blob/master/Sources/Moya/Plugins/AccessTokenPlugin.swift), but it doesn't allow to change the token or refresh it easily.

I really like your solution though! What I could add to that is to save token duration and if you know it expired, just send a request for token and then a normal request. This way you can avoid 1 request that shouldn't be needed.

I feel like it could even be a good CocoaPod out of it - one that handles full OAuth in Moya. Many people implement their own at some point in time. I was thinking about plugin, but not sure we can do it with current plugin limitations. @ArthurAlvarez this conversation may help https://github.com/Moya/Moya/issues/748#issuecomment-264572164  So this should be a final step to merge queues (#762). I've moved the docs from `Readme.md` to its own `Threading.md` + added examples for both normal usage and `ReactiveSwift`. 

Also, I've checked the docs but didn't found anything on `queues` I needed to change, so it should be all set üëç  I like the content of `Threading.md`. Let's also add a link to it in the docs/README.md? 
Possibly right after the RxSwift & ReactiveSwift sections since it builds on them. Good catch, @SD10! Added this one as well.  Hey @yar1vn, thank you for the PR! Seems like a good idea of introducing Basic auth. Although, we might want to add this one to  our existing [AccessTokenPlugin](https://github.com/Moya/Moya/blob/master/Sources/Moya/Plugins/AccessTokenPlugin.swift). Because right now this plugin is not really flexible - you can't use both OAuth & Basic on different endpoints (sometimes it happens) - you either use it or not. 

I'm thinking about updating the `AccessTokenAuthorizable` protocol so it would look like:

```swift
enum AuthorizationType {
    case None
    case Basic
    case OAuth
}

public protocol AccessTokenAuthorizable {

    /// Declares whether or not `AccessTokenPlugin` should add an authorization header
    /// to requests. If it should, what type of authorization does this request need?
    var authorizationType: AuthorizationType { get }
}
```

And then it would be easy to append header based on the type specified:
```swift
    public func prepare(_ request: URLRequest, target: TargetType) -> URLRequest {
        guard let authorizable = target as? AccessTokenAuthorizable, authorizable.authorizationType != .None else {
            return request
        }

        var request = request
        switch authorizable.authorizationType {
            case .OAuth:
                request.addValue(authVal, forHTTPHeaderField: "Authorization")
            case .Basic:
                // add Basic header
        }
        return request
    }
```

This makes it really flexible to use and also this way we can really cover most of the use-cases in the networking layer with auths.

What do you think about it, @yar1vn?
 @yar1vn I believe @sunshinejr was just trying to mock up a good way to add this functionality considering the state of Moya's current API. 

The code he provided in the comment is a rough draft and may not even compile due to the switch statement not being exhaustive. There may be other things to implement such as updating docs/tests.

Maintaining a project requires a large effort and we're always encouraging new contributors. Small contributions have a snowball effect and save maintainers a great deal of time. 

Would you be interested in moving this forward? @yar1vn Sorry I'm not an expert in this area. Could we just switch on the `authValue` property to provide a different value based on the case of `AuthorizationType`? What I meant was to update what we have with `Basic` authorization on top of it. We can name it `Bearer` type, instead of `OAuth`, to describe it properly. We would just send a `Bearer` or `Basic` token in the header, so it makes sense to name it that way. And also, as @SD10 mentioned, to that we would also need to add tests, `Changelog` entry (with a breaking change) and check docs/update them accordingly.

Would you be up for that one, @yar1vn? Check out https://github.com/Moya/Moya/blob/master/docs/Development.md :)

And let us know if you need any help! Hey @yar1vn! Just a heads-up that we just released 9.0.0-alpha.1 version of Moya. We would be up for taking your PR in the next release, so if you'd have time to implement it in the near future it would be awesome üëç Thanks for taking this one!  Sure, @yar1vn. Thanks for your response. üêº  

Please let me know if you'll be able to do it this week, would be awesome! Otherwise we might just help you out since this is a breaking change and is a perfect fit for a new major release we are planning. This shouldn't take that long to make the changes to sources, tests, and docs.

@yar1vn If you end up not being able to get around to making the changes this weekend, would you like me to take care of it for you?

I'm not trying to rush you but it's always great to bundle as many breaking changes in a major release üòÖ  We don't want you to feel pressured to do this, @yar1vn, since nothing good happens from it. Thus, I think, that we should just take it from here and you can always contribute in the future when you have more free time. We will always have some tasks for starters, so don't worry about that :) Thanks for the initiative and your time spent on this one! üôá 

@SD10 could you please create an issue and then we can move there and close this one? :) Moving this to #1214.  Hey @Marcopohlo, thanks for the issue! 

Basically, what you want to accomplish doesn't really benefit from the fact you are using reactive provider (besides `retry`). You are transforming your `Signal` to a simple closure callback, where the whole point is to keep this object and make plethora of operations on it. If you want `ReactiveSwift` just for Moya and this adapter, I'd say that you should leave it and do something similar to our [current wrapper](https://github.com/Moya/Moya/blob/master/docs/Examples/WrappingInAdapter.md) (without reactive provider).

Although if you are using ReactiveSwift in your project quite extensively, I would suggest you take a different approach, a more reactive one. Please take a look at our [subclassing example](https://github.com/Moya/Moya/blob/master/docs/Examples/SubclassingProvider.md). This is in RxSwift, but conversion to ReactiveSwift should be pretty simple (`RxMoyaProvider` -> `ReactiveSwiftMoyaProvider`, `Observable` -> `Signal`/`SignalProducer`). 

This is also a subclassing example, but you could go with composition instead (especially because in Moya 9.0.0 we are deprecating reactive providers). A simple pseudo-code that would cover what I have in mind would be:

```swift
final class Networking<T: TargetType> {

    let provider: ReactiveSwiftMoyaProvider<T>
    
    init(provider: ReactiveSwiftMoyaProvider<T>) {
        self.provider = provider
    }
    
    func request(target: T) -> SignalProducer<Response, MoyaError> {
        return provider.request(target) // here you could add some logic for retrying/handling global errors etc.
    }
}
```

Also, if you'd do it, you could make a PR with example using ReactiveSwift - we would gladly take that one üòÑ 

Let me know if you still have some questions about it :) No problem, happy to assist! Did you have some more troubles there, @Marcopohlo?  Hey @sandeepbol. This is a good question!

Unfortunately, we do not have such solution built-in Moya core. This might change when we migrate to Swift 4, in fact there are already plans on implementing such functionality (#1135, #1147). For now you would have to do the object mapping to JSON manually. However, there are libraries out there that can help with that, like [Wrap by John Sundell](https://github.com/JohnSundell/Wrap) - you could give it a try.

Please let me know if you have any further questions regarding this topic!  Setting `parameterEncoding` in `endpointClosure` (first option) was an option long before `parameterEncoding` in `TargetType` (second option). The first one is more generic - you can have one closure that handles multiple providers/target types (so you can setup one encoding for an entire API or for some part of the endpoints), where the second one is more `TargetType` specific (sometimes you just want different encoding for one endpoint, not for a whole API, thus this option).

Also when you use both methods at the same time, the `endpointClosure` one will override the `TargetType` one, since it is executed after.

But both of them are setting the `ParameterEncoding`, which is the same functionality, but for kinda different use-cases. Also, because I think your issue is resolved for now, I'm gonna close this issue. If you find yourself getting more questions about Moya, don't hesitate to open a new one!   Thanks a lot for contributing to Moya! I've invited you to join the Moya GitHub organization ‚Äì no pressure to accept! If you'd like more information on what that means, check out our [contributor guidelines](https://github.com/Moya/contributors) and feel free to reach out with any questions.  ### Please don't merge until we create the backing label for this.

This fixes the problem where issues aren't being closed due to our previous label 'no recent activity' containing spaces. 

I literally set the label to `stale` but if someone would prefer another name discuss it here.

i.e) `no_recent_activity` or `no-recent-activity`  Hey @abeintopalo, thank you so much for this detailed explanation! Really awesome of you.

About the problem - yeah, we got 4 schemes and each one is gathering coverage data. It _should_ work just fine with _MoyaTests_ doing that, we gotta see and test. Would you be up for doing a PR? You would have to branch from `9.0.0-dev` and target that one in the PR, though. Thank you @abeintopalo! I'll try to get to it & test it whenever I have some free time. Maybe someone else will be free to check it before me, though! Also, from the PR it seems like codecov integration didn't break (I think), so it is a good sign üòÑ  I'm gonna close this one and we will focus on this matter in the PR @abeintopalo created (#1169). üëç     In this PR:
- [x] Updated tests for reactive extensions that were introduced here, #1153. Basically just updated the syntax and used `MoyaProvider`, but in `ReactiveSwift` extension I decided to leave tests that were subclassing `ReactiveSwiftMoyaProvider` or testes `TestScheduler` that we do not provide in new APIs.
- [x] Fixed a bug that was happening in RxSwift as well - double response for `requestWithProgress` in `ReactiveSwift` extension. Also added test so we do not miss it again üòÑ 

As always let me know what do you guys think!  Removed all the deprecated methods/types from Moya 8.0.0 Could anyone take a look at this one, @Moya/contributors? üêº  Wow, that was quick! Thanks guys!  So setting the `closeComment` variable to false had no effect. This leads me to believe we have a different problem. I took a look at the source and this is the method that gets the stale issues:

```javascript
  getStaleIssues() {
    const labels = [this.config.staleLabel].concat(this.config.exemptLabels);
    const query = labels.map(label => `-label:"${label}"`).join(' ');
    const days = this.config.days || this.config.daysUntilStale;
    return this.search(days, query);
  }
```

It looks like when it creates the `query` it wraps the label in quotes. Since the current `stale.yml` already provides these quotes I think it results in an invalid query. I suggest we remove them with this PR and see if it has any effect. Sorry for the PR spam üòì  I think, at this point, we might be better off opening an issue over at Stalebot, instead of doing this hit-and-miss approach. üòê  @BasThomas I agree, this was my last idea. I already have an open [issue](https://github.com/probot/stale/issues/43).   @pedrovereza What about setting `closeComment` to false to test if this problem is comment related or if we have another problem? I think the effects should be applied immediately if the PR is a success. @SD10 sounds good to me, let's see if it works now üòÖ   Related to #1071, #1157 and #1158.

Stale-bot is still not closing stale issues. I'm guessing this could be related to having markdown in the close comment ü§î.

Also confirmed that having `closingComment: false` worked on a test repo (https://github.com/pedrovereza/stale-bot-test/issues/1)  @pedrovereza I did find repos using both emojis and markdown inside of the `markComment`. None inside of the `closeComment` but I would assume the behavior would be similar.

[babel](https://github.com/babel/babel.github.io) uses emojis.
[hubotio](https://github.com/hubotio/hubot-redis-brain) uses markdown.

I created an issue [here](https://github.com/probot/stale/issues/43) in the stale repo asking for some troubleshooting support.

Nonetheless, let's give this a try. I think when updating the `stale.yml` file the changes should be applied immediately by `probot`.  @pedrovereza per your recommendation I've removed the emojis from the `stale.yml` configuration. I've been able to find other GitHub repos with the close comment feature working as of 3 days ago, but none containing emojis.

My only other concern would be the link inside the comment because of the colon.  I found [babel](https://github.com/babel/babel.github.io) is using emoji literals in their stale comments. 
Possibly writing üëç as `:+1:` could have thrown it off? I'm not too convinced.
I was skeptical of all colons (like the one in the link) but [hubotio](https://github.com/hubotio/hubot-redis-brain) is using links in their comments. I'll have to sleep on this and see if any thing has taken effect by morning.  ![screen shot 2017-07-03 at 2 14 49 pm](https://user-images.githubusercontent.com/7445580/27805395-02a22a70-5ffa-11e7-93b2-6e9dcde1ae5b.png)

I'm not sure if the discoloration in the syntax highlighting is what is causing `stale` to not close issues. I've compared our `stale.yml` to other projects and this is the only difference. Removing the emojis could work too. I think we will have to wait about an hour+ to see if Probot makes any changes. It might be good to open an issue over at Probot as well, to get them in the loop? https://github.com/probot/probot/issues @BasThomas Great idea, I just want to get a better handle on the problem before opening a premature issue. I'm not sure if it's the emojis or just any colon in the message body -- or even something else üòÖ   Hey @ledikari, this feature is planned to be release on Moya 9.0. See #993 :wink:  Hey @ledikari. @pedrovereza is right, in 9.0.0 the `underlying` case would be getting response as well, but right now you can just cast error to `Moya.Error` and parse the response data:
```swift
.catchError { error in
    if let error = error as? Moya.Error, body = error.response?.mapJSON() {}
}
```

the syntax might be off since I'm writing this from the bus, but the idea should be alright. üòÖ

Let us know if it helped! @ledikari Do you know which case the `MoyaError` is? 
You can use `errorResponse?.errorDescription` if you'd like.

The reason I'm asking is the `MoyaError.underlying` and `MoyaError.requestMapping` return nil for the `response` property. @ledikari It looks like you're receiving a `MoyaError.underlying`, so the response property will be `nil`.
You can view the output for `MoyaError.errorDescription` [here](https://github.com/Moya/Moya/blob/master/Sources/Moya/MoyaError.swift).  @ledikari I don't believe so üò≠. As others have mentioned this feature will be available in Moya 9.0.0. Yes, we are sorry about that - just the `underlying` error & `body` needed in it was so uncommon we didn't really think about it till few months back. But we are closing in for the 9.0.0 version so please take a look at it once it is shipped. Sorry again for the inconvenience üò•  @ledikari @jeryRazakarison Yes, you can use the version of Moya that is under development if you'd like. I'd only suggest that you fork the repo and point to your own fork instead of relying on our `9.0.0-dev` branch as we can't guarantee it will *always* be stable :wink: @ledikari Not sure, we are tracking progress in #1075, but slowly getting there. I didn't recommend using our `9.0.0-dev` since there might be some breaking changes in the near future, so please use it at your own risk üëç   I somehow broke @MrAsterisco PR, really sorry about that. This is his PR from #1151. I also fixed the indentation.

<img width="350" alt="zrzut ekranu 2017-06-30 o 19 48 22" src="https://user-images.githubusercontent.com/5232779/27747803-1b0dba5e-5dcd-11e7-9415-a5309db9453f.png">

**Edit:** I've also invited you to the org @MrAsterisco, since our bot probably won't catch that specific case üòÑ   Hey @MrAsterisco. This is a very good question. Usually, I have a `refresh` observable that would cover that for me. So my usual stack would be somewhat similar to:
```swift
final class TestViewModel {
    
    let refresh: Observable<Void>
    let items: Observable<[Item]>
    
    private let provider: RxMoyaProvider<GitHub>
    
    init(refresh: Observable<Void>, provider: RxMoyaProvider<GitHub>) {
        self.refresh = refresh
        self.provider = provider
        
        self.items = refresh
            .flatMapLatest { [unowned self] in
                return self.provider.request(.zen)
                    .catchError() // logic for error catching here
            }
            .map(toArray: Item.self)
    }
}
```

This way every time `refresh` observable produces next element, my items refresh with it. This `refresh` observable might be also `Subject` or `Action`, whatever works for you. 

Let me know if it helped üëç  Hey @MrAsterisco. Yeah, it is one of the most common usages of reactive extensions. You don't necessarily need to make a `Variable`, you want to refresh your items based on some sort of event. This event could be passed to the view model from view controller and thus could trigger the refresh. E.g. you can pass observable that on each button click it refreshes the items:

```swift
let viewModel = TestViewModel(refresh: refreshButton.rx.tap.map { _ in })
```

However your idea could work as well. You could make your own subclass of MoyaProvider that covers a function of `repeatLastRequest()`, but it would require saving state in the normal, overridden `request` function. It could be tricky (probably needs some locks), but it should work. Of course! üëç  Let me know if I can be any help.  Related #963. This is a reimplementation of #1140. 

To-do:
- [x] Update documentation.
- [x] Tests.
- [x] Moya.xcodeproj fix.

To avoid code duplication I've created internal requests that are used by both reactive providers and new `rx.` & `reactive.` API. Although I'm not sure how we should go about testing this one. We still have tests for reactive providers that cover most of it I believe.

Please let me know what do you guys think!  Interesting idea ‚Äì I like it a lot. My only hesitation is that that some users (including myself) subclass the existing reactive subclasses (subclassing `RxMoyaProvider`) to introduce custom behaviour within the `request` methods. This implementation wouldn't allow for the same mechanism to be used, so we'd need to find some alternative. 

My gut says composition would be a good idea (so, instead of subclassing a provider, we would recommended containing it within a sort of provider-provider). If that's acceptable, we would just want to make sure that we have a migration guide before releasing 9.0. Happy to assist with any of this. This is a great idea. I'd love it if you could help with migration guide, @ashfurrow. Especially because we will only deprecate providers, without removing them, we might get more feedback on the change as well (and thus we could see what features are really used in Moya). Well, [Eidolon](https://github.com/artsy/eidolon) has become a sort of go-to implementation for how to do Rx with Moya. Why don't I migrate that over this week, and we can refer to the actual PR from the migration docs. It'll likely be a few days before I get to this, but I'll follow up üëç Great! Thank you, Ash üéâ Thanks guys for the review! The migration in Eidolon looks like was easier than expected - and that's awesome. I've committed some changes you guys requested - please take another look in your spare time üòÑ  Btw. anyone have an idea why is CI failing? ü§î  Hmm not sure what's going on. Can you test locally to see if it passes from within Xcode? From the command line with `rake test`? Ok I think, I fixed it (it actually passed from the state it was stuck on üòÑ ). There was a problem with project (I had to regenerate it using `framework-generate`. I'll bring that up in another issue) + problem with Carthage deps.  Thank you guys so much for the reviews and help! Thanks for picking this up, @sunshinejr!  Hey @codwam. Please let us know the details of your issue. For example it could be your `TargetType` setup, what are you trying to achieve and what is happening. For now we can't really help you with that info, unfortunately.  @codwam to make your request multipart-friendly, you need to have a `multipartBody` that is not empty and your `method` in `TargetType` must be one of the following:
```swift
.post
.put
.patch 
.connect
```

If you specify the following correctly, there should be no issue on our side. 

From the code you posted it seems like your backend wants `multipart` request on given endpoint, but you are just doing a `request` in case of no image - thus server does not allow the request. 

One of the fixes would be to just switch from optional `UIImage?` to just `UIImage`:
```swift
enum Router {
    case test(account: String, image: UIImage)
}
```


Let us know if it helped! Can you post the logs from Charles? Like the whole request you see? (headers, method, body)? It is not a must, @codwam, but having this check should help users when making a mistake by not specifying `multipartFormData`. If you really want to send an empty data, you could try with:
```swift
return .upload(.multipart([MultipartFormData(provider: .data(Data()), name: "serviceImg")]))
```

Let me know what you think :) Glad it helped! üéâ   Hey @MrAsterisco, thank you so much for this PR. üéâ  This is a really nice idea, however, from the user perspective, I often need this plugin to tell me exactly what is the body of a request I send to the API. So for me it would be not-so-obvious that Moya is doing some kind of decoding under the hood. 

Maybe we can figure out a way that user can opt-in (like parameter?) for that feature. Do you have any idea how we can achieve that? ü§î Looks good, @MrAsterisco! I've fixed some indentation in your PR, so now we need only 2 more things:
- [ ] Add `Changelog.md` entry
- [ ] Add a test case.

About `Changelog.md` entry, just need to add a new item in the `Next` column with the change you implemented. Example [here](https://github.com/Moya/Moya/pull/1020/files#diff-9b8fab691c00b9e5380b19ce882f3271) (it is not a breaking change, so without that **breaking change** label).

About test case, you can take a look how it is done for [formatting response data here](https://github.com/Moya/Moya/blob/master/Tests/NetworkLoggerPluginSpec.swift#L76-L85) and make something similar.

Let me know if it looks good for you. Also, do not hesitate to ask for help If you have any troubles with the above. We will try to assist with whatever you want. Seems good! Indent is quite off though, could you take care of that? :) AFAIK it's 4 spaces. :)  Thanks a lot for contributing to Moya! I've invited you to join the Moya GitHub organization ‚Äì no pressure to accept! If you'd like more information on what that means, check out our [contributor guidelines](https://github.com/Moya/contributors) and feel free to reach out with any questions.  Please look at my [comment here](https://github.com/Moya/Moya/pull/1147#issuecomment-312091964). Because of that and because we may have too many PRs opened at the same time and we want to make it easier for our contributors to find the ones that matter the most right, I'm gonna close it for now. We will continue the discussion later on.  I will go ahead and say we might not want to add it to 9.0.0 release since we have many breaking changes already (and few big ones). To make transition smoother we may just hold onto this one till after the release. This is a really big change and a great amount of work from @Dschee, so it would be awesome to get some feedback from @Moya/contributors in the meanwhile.

This PR helps with a lot of undefined behavior but from the user perspective it might look messy. We may need to think about this one a little bit more:
```swift
return .request(.parameters(["test1": "test", "test2": "test"]))
```
Looks kinda uncomfortable at first glance. And especially because it is the default use-case, we may think of a cleaner solution. Would one enum instead of 3 help? Not sure. Opinions? I looked this over and it seems to make sense to me.

I agree with @sunshinejr that it gets a lot more verbose at the call site... definitely not great. I'm wondering if instead of associating the new `RequestDataType` with the request enum case, we can extend the number of enum cases? like `requestWithData`, `requestWithParameters` etc?  I left you comments around most issues @Dschee. For flattening I agree we would need to flat upload & download types as well. I think we might do it in the same PR since naming convention in this one would be similar. 

Anyhow, I like the direction that this PR has taken. Keep it up :) Hey @Dschee, just a heads-up. I'll try to get to it ASAP and edit this comment. Thank you for the constant work on this one. üëç  Thanks, @Dschee! I'd love to have it, but we are still without tests and I'm not the only one to decide such things. Would love to get some feedback on it from @Moya/contributors, since it is almost finished now.

Also, sorry that I didn't mentioned it earlier, but would you rebase it to `9.0.0-alpha.1` branch, please?  I just barely got to skim this over but will take an in depth look this weekend. 
Some really cool work going on here! üòÉ Also, could you check CI, @Dschee, please? Seems like it is failng. We still need to update `docs/Examples/Basic.md` and possibly more in the examples section. While the examples are not pure documentation, `Basic.md` is a very important reference file. I'm actually not sure about `ArrayAsRootContainer.md` but it looks like more of a specialty example, so if it wasn't updated before a release I wouldn't mind too much. My biggest concern was `Basic.md` considering it is our `#1` most viewed documentation file. Thanks for taking care of this!    @Dschee I think what you've listed is fine. We don't need to add `unavailable` attributes to specific cases in the enum. The migration guide will cover this. Amazing work everyone, @Dschee especially! üí™  Oh no, I've meant that someone else should take a look at it as well :D Also, I'm not sure how can we test this one, since it is on a branch that does not belong to Moya, but to you. Thanks a lot for contributing to Moya! I've invited you to join the Moya GitHub organization ‚Äì no pressure to accept! If you'd like more information on what that means, check out our [contributor guidelines](https://github.com/Moya/contributors) and feel free to reach out with any questions.  When something changes in the `Sources` directory, there's a good possibility of us having to update or add a test in `Tests` as well. Giving a warning via Danger might be a good way to get a nudge in that direction if it's forgotten.

The [Dangerfile](https://github.com/Moya/Moya/blob/master/Dangerfile) should give you a good idea on how to add this. Fixed in #1146  I guess we could, but it would be a hassle that's not really worth it. Thanks for mentioning it though; I've added a check to see if a migration guide would be necessary for 9.0: https://github.com/Moya/Moya/issues/1075#issue-227035119 Yep, definitely. Although deprecating / making methods or variables unavailable and providing useful error messages goes a long way, too. :)  See https://github.com/Moya/Moya/pull/1142#issuecomment-310930345 Any idea as to what to call the "others"? I thought about it for a while, but couldn't get anything good enough. I came to a conclusion that we can just move `CommunityProjects.md`, `Development.md` & `Releasing.md` from `docs/` into the root directory for now (like with everything else that does not touch Moya usage itself). This idea is also supported by GitHub (they expect `Code of Conduct` & `Contributing` to be in the root dir as well).  Closes #1141  This is great idea, thank you, @BasThomas! Although, maybe rename it do something more verbose about it being in the "development" phase, rather than testing in Moya itself (`sampleData`, `stubbing` etc.)? Like `Development.md`? These are the steps that we can really use for development as well :D 

Also maybe we need to split documentation on usage of Moya and everything around it (like Community, Code of Conduct, Development, Releasing etc.)? ü§î  Both seem like a great idea. I'll create another issue for your second point! :)  Supersedes #963. (cc @kemchenj)

Also fixes #1144. Targeted this at the `master` branch by accident, changing the base branch to `9.0.0-dev` adds a bunch of commits. ü§î Also, from #963:

> Then let `MoyaProvider` conform to `ReactiveCompatible` and `ReactiveExtensionsProvider`, then we could change our code like this:

It seems like we can't use both of these protocols, seeing how they are implemented ([ReactiveCompatible](https://github.com/ReactiveX/RxSwift/blob/0b66f666ba6955a51cba1ad530311b030fa4db9c/RxSwift/Reactive.swift#L38); [ReactiveExtensionsProvider](https://github.com/ReactiveCocoa/ReactiveSwift/blob/master/Sources/Reactive.swift#L9)). Or at least, I don't really see how to do so. Am I missing something there? Interesting CI failure:

```
‚ùå  /Users/distiller/Moya/Tests/ReactiveSwiftMoyaProviderTests.swift:190:92: argument 'stubScheduler' must precede argument 'stubClosure'

                provider = MoyaProvider<GitHub>(stubClosure: MoyaProvider.immediatelyStub, stubScheduler: testScheduler).reactive
                                                ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
```

It seems like the parameter order differs from `ReactiveSwiftMoyaProvider` and `MoyaProvider`. üòØ @BasThomas you probably just need to extend `Reactive` (`RxSwift.Reactive` & `ReactiveSwift.Reactive`) and then we can skip using other providers and provide `request` method. @sunshinejr I've been trying to update the tests and verify if everything is working locally, but can't seem to get the tests running. For this I think I need to do a `swift build` and `swift test`, right? Problem is, `swift build` errors:

```bash
bas$ swift build
warning: refname '4.5.0' is ambiguous.
warning: refname '4.5.0' is ambiguous.
HEAD is now at 7fe7b91 Added release notes to the CHANGELOG and bumped the version to 4.5.0.
Resolved version: 4.5.0
warning: refname '1.1.3' is ambiguous.
warning: refname '1.1.3' is ambiguous.
HEAD is now at 92d73573 1.1.3
Resolved version: 1.1.3
warning: refname '3.2.3' is ambiguous.
warning: refname '3.2.3' is ambiguous.
HEAD is now at c844618 3.2.3
Resolved version: 3.2.3
/Users/bas/Documents/Programming/iOS/Moya/Packages/RxSwift/Package.swift:5:36: error: use of unresolved identifier 'ProcessInfo'
let RxTestIsTarget = buildTests || ProcessInfo.processInfo.environment["TEST"] == "1"
                                   ^~~~~~~~~~~
Foundation.NSProcessInfo:1:14: note: did you mean 'NSProcessInfo'?
public class NSProcessInfo : NSObject {
             ^
ApplicationServices.ProcessInfoRec:1:15: note: did you mean 'ProcessInfoRec'?
public struct ProcessInfoRec {
              ^
error: exit(1): /Library/Developer/Toolchains/swift-DEVELOPMENT-SNAPSHOT-2016-05-31-a.xctoolchain/usr/bin/swiftc --driver-mode=swift -I /Library/Developer/Toolchains/swift-DEVELOPMENT-SNAPSHOT-2016-05-31-a.xctoolchain/usr/lib/swift/pm -L /Library/Developer/Toolchains/swift-DEVELOPMENT-SNAPSHOT-2016-05-31-a.xctoolchain/usr/lib/swift/pm -lPackageDescription -target x86_64-apple-macosx10.10 /Users/bas/Documents/Programming/iOS/Moya/Packages/RxSwift/Package.swift -fileno 3
```

Any idea? Is this an `RxSwift` issue? AFAIK, `NSProcessInfo` was renamed to `ProcessInfo` in Swift 3 an thus shouldn't error. @BasThomas We don't support `swift test` yet, it is on my todo list to make it work some day and there is an issue for that as well (#894). Right now we can use Carthage for it (`carthage update --platform iOS` should be fine) and then open Moya.xcodeproj and run the tests in. Should work fine, but if you encounter any issue let me know üëç 

**Edit:** About the `swift build` command, do you have an old toolchain somewhere? Maybe old Xcode? This command _should_ work ü§î  Interesting, I had two *really* old snapshots, though Xcode was just using the one bundled with Xcode; I wonder how it used one of those other snapshots when running `swift build`. ü§∑‚Äç‚ôÇÔ∏è Testing via Carthage works; I've created #1141 to make a short `.md` to document this. Added a DNM, as we would need to merge this into `9.0.0-dev`, not `master`, which seemed to cause [some issues](https://github.com/Moya/Moya/pull/1140#issuecomment-310914884) when trying to do so. woah, I just switched the base from master to 9.0.0-dev, and it looks like 9.0.0-dev is in dire need of a rebase :octocat:  Yeah, that's what I saw when switching the target branch as well. ü§î somebody's who's familiar with the recent commits on master should run
```
git checkout 9.0.0-dev
git rebase master
git push 9.0.0-dev
```

and the unrelated commits should disappear from this PR

On Mon, Jun 26, 2017 at 10:10 AM Bas Broek <notifications@github.com> wrote:

> Yeah, that's what I saw when switching the target branch as well. ü§î
>
> ‚Äî
> You are receiving this because you commented.
> Reply to this email directly, view it on GitHub
> <https://github.com/Moya/Moya/pull/1140#issuecomment-311122243>, or mute
> the thread
> <https://github.com/notifications/unsubscribe-auth/ADo1dERsXlpMpGdSYGGLQJFTDxp11mTfks5sH-YQgaJpZM4OEqVD>
> .
>
 I did the rebase on 9.0.0-dev and fixed conflicts on this branch, should be alright. In case something is wrong, I've got the copy of the 9.0.0-dev branch so it's all good üëç  And how are we with that extension change to `ReactiveCompatible`s, @BasThomas? What do you think? Kinda got buried in the process of this PR, so it is hard to follow the conversation :D Will take a look! I've just updated to use `ReactiveExtensionsProvider` and `ReactiveCompatible`. The build is expected to fail - I haven't updated all tests yet, and the extensions don't implement the `request()`. method yet.

Does anyone else want to look into that? As I don't have too much experience with Reactive, I feel some of you might be better for that job. :) Also, might both these extensions creating a type of `Reactive<MoyaProvider<Target>>` cause a problem somewhere? ü§î @BasThomas I might do one commit that will show what I had in mind, what do you think? In case something went wrong we can just remove it :D Definitely, go for it! I've done another update to the docs, meanwhile fixing #1144 as well. I did some work on that and it seems like we would need to add a protocol for `MoyaProvider` to make extensions happen, because we can't still do something like: 
```swift
extension Reactive where MoyaProvider {}
```

And also we would need to get rid of overriding `stubRequest` in `ReactiveSwift` provider - but I think that we established that queues are gonna implement it. I just made a comment on queues PR for that to make sure we do not forget about it. 

Due to it being a bigger change than 1 commit + a lot of discussion happened there, I think we should do another PR with clear state. What do you think, @BasThomas? Yeah, sure! @BasThomas @sunshinejr Should this closed in favor of #1153? ü§î  Yep!  Hey @syegin, just checking if everything is alright. Let me know if you need some help or you just don't have time to do it right now.  It is not yet merged, @codwam. I can take it from here (filling the tests & changelog), if @syegin won't in the near future.  @dangthaison91 It might be the case that this PR won't make it into 9.0.0 release, since we are in the middle of changing the `parameters/encoding/Task` in #1147. Basically the API will be more verbose and you would specify what to do based on a task.  This can be closed as #1147 is merged into 9.0.0-dev and will be into the new release soon. Thanks for your time, @syegin!   Hey @ercancelik. You are right - you cannot do it in `TargetType` _yet_. This is in our planned 9.0.0 release. Right now you can do it in `endpointClosure` (more details [here](https://github.com/Moya/Moya/blob/9.0.0-dev/docs/Endpoints.md#from-target-to-endpoint)), and after the release you can switch to the new parameter `headers` in `TargetType`.

Let us know if it helped!  Can someone confirm this as a bug?

If so, @syegin, would you be willing to do a PR to fix this? :) Hey @syegin, thank you for the issue. Seems like what you're saying might be the case - upload doesn't take parameters, just data, so in case of an `Endpoint`, we just add parameters and not append the data. Was trying to think of a fix and it seems like adding parameters from endpoint to the multipart data [here](https://github.com/Moya/Moya/blob/master/Sources/Moya/MoyaProvider%2BInternal.swift#L90-L92) might be sufficient. Also, we would need to add a test that covers this situation (probably asserting the data). 

Let us know if you want to take a stab at it, @syegin - we will try to help you in any way we can :) Now that I think about it, this fix will now transition from ignoring `parameters` in multipart upload to adding them to the request as well. But in normal upload `parameters` will still be ignored. This makes a lot of kinda-undefined behavior. But that's another problem (and I will open a new issue for that). I think we may accept it as a bug fix and release a 8.0.6 for now if needed.

About this changes - seems like a way to go! Please make a PR so we can discuss the implementation details üëç  This is being worked on at #1139, so I'm closing this one.  I think we can close this one in favor of #1147. Exactly what I was thinking üëç   First of all, thanks for looking into this! It seems like `JSONEncoder` returns `Data` and not `[String: Any]`, so I am not sure how we could use the encoder for parameters in that case; we really need a `[String: Any]` for parameters.

Also, I am not quite sure what `RequestData` would do over `parameters` and `parameterEncoding`?Does it offer anything other than combining these two?

Keep us updated on your progress, we'd love to see the possibilities. You might want to consider forking Moya and don't be afraid of trying things out there. üòÉ  Hey guys. I must admit I didn't read the whole conversation, but I'd suggest that we wait a little bit with planning this one. We are still focusing on releasing 9.0.0 first. Additionally, we build Moya on top of Alamofire, and these guys could also implement some `ParameterEncoding` interop with `Encodable` & `Decodable`, thus making our life easier (they change `ParameterEncoding` a lot). Swift 4 has a long way to go and time may play on our side. Although if we don't get any new API, enum idea with some tweaks seems good for me :) Swift 4 will probably be released around September, which means we still have a two+ months to go, during which Swift will still be in development and will have some fixes and improvements.

Once it is released, the transition to Swift 4 will probably be pretty fast indeed, so I think we should aim to support Swift 4 sometime in September / October. Earlier is better, and having a beta period would be great, so we can release a non-beta once Swift 4 is out of beta.  Actually, we have some undefined behavior in Moya already, so maybe we can start implementing the changes you talk about right now (and then add `Encodable` later for Swift 4.0). Because there is a problem between `task` & `parameters` & `parameterEncoding` (especially in upload, `parameters` & `parameterEncoding` do nothing in it), maybe we can merge it and create a room for `Encodable` in the future? I imagine something like this (while removing `parameters` & `parameterEncoding` properties):

```swift
enum Task {
    case request(RequestType) // that's new
    case download(DownloadType)
    case upload(UploadType)
}

// this whole enum would be new
enum RequestType {
    case data(Data) // may be used with Encodable later or/and maybe we can add .encodable case too
    case parameters([String: Any])
    case encoded(parameters: [String: Any], encoding: ParameterEncoding)
    case composite(urlParameters: [String: Any], bodyParameters: [String: Any])
}

// expanded current DownloadType a little
enum DownloadType {
    case destination(DownloadDestination)
    case parameters(DownloadDestination, parameters: [String: Any])
    case encoded(DownloadDestination, parameters: [String: Any], encoding: ParameterEncoding)
}

// this could stay the same as it is
enum UploadType {
    case file(URL)
    case multipart([MultipartFormData])
}
```
This is just expanding our current `Task` API to cover more cases. We could also merge it into one `enum` making it kinda more easy to use (just make sure the most common use-case, request, would be easy to use). The problem would be with `endpointClosure` - what would adding the `parameters` & `parameterEncoding` mean for `upload` & `uploadMultipart`? 

What do you think guys? The cases are:
1. I was thinking of producing a default parameter encoding to make it easier to use (most of the time you use one specific encoding), maybe it can be customizable in `MoyaProvider` like `provider.defaultParameterEncoding`, or maybe we should just use `URLEncoding.default` like it is in `endpointClosure` by default right now.
2. In the other two cases you can also specify parameters in your download requests. Download request is almost the same as normal one that doesn't save anything to disk, so we might also add these options to them if needed.
3. Yeah, this is the trickiest one - we probably need this parameter encoding there too.

So about PRs - I'm thinking about one big PR that we can target in the smaller PRs. This is because we probably can't do few PRs without breaking a build for some time. 

Also, I would love to hear feedback from more @Moya/contributors since it is kinda big change, and if we agree on something, we may want to implement it in 9.0.0 as well.  We forgot to change the documentation around new `RequestClosure` in some places. We need to double-check where we are using it, but for sure we have to update it in [Authentication.md](https://github.com/Moya/Moya/blob/master/docs/Authentication.md#oauth). Transition is rather simple, you can take a look at our tests [here](https://github.com/Moya/Moya/blob/aa33a0466d7333516691b3e5212c5acb41990928/Tests/MoyaProviderSpec.swift#L262-L270) to see how it is used now. [This](https://github.com/Moya/Moya/blob/master/docs/Endpoints.md#request-mapping) can be useful in case of explaining how the closure works nowadays.

Also, I think this might be good idea to introduce #starter-task (stolen from IGListKit üòÑ, thanks guys!), so I've added the label here.   I think making issues like these is a really good idea, so thanks for that! Also love the `starter-task`, but we already have the `good first step`. Should we remove that and start using `starter-task`? Also, although this is a nit, let's call it `starter task` to be in line with our other labels? We might want to see what "good first step" is used for, but for me it would be slithly different. E.g. I would use it for an idea that I have and that need improvements, where "starter task" would be rather concrete specification of what's needed, how to achieve that and possible caveats. 

Also, I'm in for changing "starter-task" to "starter task" to keep consistency üëç This issue has been marked as stale because it has not had recent activity. It will be closed if no further activity occurs. 
 This issue has been auto-closed because there hasn't been any activity for 59 days. However, we really appreciate your contribution, so thank you for that! üôè Also, feel free to [open a new issue](https://github.com/Moya/Moya/issues/new) if you still experience this problem üëç.
 I'm sorry mr. stalebot, but we have to do this sometime in the future so I'm gonna reopen this. Maybe we should add `starter-task` to labels ignored by `stalebot`? ü§î  @sunshinejr What about adding the `documentation` tag instead? In case of documentation we use additionally `chore` tag which is ignored by `stalebot`. That leads me to a reason why this was closed by our bot üòÑ I'm gonna add labels where needed, right now I think all starter tasks are docs, so we should be fine for now.  Hey @bfjfm2. Thank you for bringing that up. I think we somehow missed updating some docs regarding this matter in some places, like [here](https://github.com/Moya/Moya/blob/master/docs/Authentication.md#oauth).

But our main [docs](https://github.com/Moya/Moya/blob/master/docs/Endpoints.md#request-mapping) should be up-to-date, so please take a look at them. You can also take a look at our tests that use this new closure [here](https://github.com/Moya/Moya/blob/aa33a0466d7333516691b3e5212c5acb41990928/Tests/MoyaProviderSpec.swift#L262-L270). Basically you can now specify if you want to pursue the request using `.success` case of `Result` type, or to fail the request using `.failure` case and passing the error down.

Let us know if it helped!

**Edit:** Also, because we need to update our docs around it, I've opened an issue #1134. If you resolve your problem and want to take stab at it, feel free to do so :) Glad it helped! üéâ  Hey @leo-lp, I'm assuming this is a mistake-PR so I'm gonna close it. If it's not, please describe what was your intention here and we will work things out üëç  Hey @XavierDK. You can create your own `Manager` and pass it to the `MoyaProvider`:
```swift
let configuration = URLSessionConfiguration.background(withIdentifier: "com.example.app.background")
let manager = Manager(configuration: configuration)
```

Let us know if it helps!

**Edit:** Also, see how the default `Manager` is created [here](https://github.com/Moya/Moya/blob/aa33a0466d7333516691b3e5212c5acb41990928/Sources/Moya/MoyaProvider%2BDefaults.swift#L24-L31). Glad it worked! üéâ   Hey @ranayahya - it doesn't seem like you're using Moya, right? ü§î
 In that case I am going to close this issue, as it is not related to Moya. What seems to be going wrong is that you are unwrapping (`!`) an optional value, which is `nil`. Check in Xcode on what line this happens (probably this one: `var request = URLRequest(url : URL(string: API)!)`?) If that's the case, it seems like the URL is invalid, in which case `URL(string: url)` returns `nil`.  Hey @BasantAshraf. Use `URLEncoding(destination: .queryString)` as your `parameterEncoding` and add `userName` & `password` as your parameters. Let us know if it worked!  We might want to add a custom ParameterEncoding example. See #1119 I think we could just point to [Alamofire docs](https://github.com/Alamofire/Alamofire#custom-encoding) instead ü§î  Yep, that'll do as well, I think. üòÉ  For sure! Still, I think that `ParameterEncoding` using some specific `Moya` configuration would be awesome as well.  Fixes #1110.

Was there a reason this was not enabled before?  When doing a search, it does seem like a lot of people just `return Data()`: https://github.com/search?q=%22var+sampledata%22+language:Swift+extension:.swift&type=Code&utf8=%E2%9C%93.

On it being a breaking change: we're releasing `9.0` soon, and with Swift 4 around the corner, there will probably be room to include this in `10.0` in the near future if we want to go this way. What do other @Moya/contributors think? Yup, makes sense to me.  Sounds good to me.

If we decide to make the change, I think we should make it part of `9.0` (even if it delays the release a bit), since we already included breaking changes in `TargetType`. @Dschee We are using [milestones to keep track](https://github.com/Moya/Moya/milestone/7?closed=1), but I'm not sure of the benefits GitHub Projects would give us (feels more like a kanban thing).

We are using branch `9.0.0-dev` for breaking changes going out in 9.0, and we basically rebase the changes on top of `master` from time to time, which will make the merge from `9.0.0-dev` to `master` easier when we decide to release it. PR #1124 was opened just to let more people double check that the rebase was good before pushing it to `9.0.0-dev`.

We should probably continue this discussion in a separate issue (if needed) so we don't hijack this one üòÖ  Anyone up for a PR? @SD10 We've had conversations about providing default implementations for common things, but in the end we agreed that, as a rule of thumb, we'd rather have the user explicity define (and understand) the behavior instead of relying on default implementations provided by us.

More in https://github.com/Moya/Moya/pull/1067#issuecomment-298128123 and #861 üòâ  @SD10 
> It's a large read but my takes from it are:
Forcing people to implement sampleData makes it harder to get Moya up and running
 sampleData is required prematurely (long before unit tests are written)
 Having sampleData in the TargetType bloats the file, especially with a complex API

I agree with all these points, but I don't think that defaulting `sampleData` is the best solution. I think that it should be removed from `TargetType` completely :wink:  Are there any dependency problems? What would the benefits of having a separate repository be for each submodule? I think having a separate repository per submodule introduces quite some challenges without solving any problems. 

On `Moya/ReactiveCocoa` and `Moya/ReactiveSwift`: yes, it might be time to remove the `ReactiveCocoa` subspec. It has been left after the rename for compatibility with Podfiles using `Moya/ReactiveCocoa`. The only downside is that we can't really inform those users that there is a new subspec name, and I am not sure how big the impact could be. They would basically get stuck at a maximum library version when we would remove it, without being warned of any new versions in any way.  A similar discussion happened in #345.

Couple of quotes:
https://github.com/Moya/Moya/issues/345#issuecomment-183493154
 > The only "real" fix for this is to have separate repos but we decided to not go that way in the past since it adds a lot of complexity for 2 extra files.

https://github.com/Moya/Moya/issues/345#issuecomment-183494797
>  we tried multiple repos but it got out of hand, quickly.

But I'm interested to hear what kind of dependency problems you're referring to.
 @Huang-Libo I can see the benefits it would bring for Carthage users, but I still agree with the conclusions from #345: the complexity it would add on maintenance side is too big. (more context in #215 and #169).

@Moya/contributors Thoughts?
  Yeah, same. Separate repos would help Carthage users but introduce a tonne of complexity for contributors. From my perspective, I would prefer to keep contributing to the library as easy as possible.

If we do decide to change the infrastructure of the project, I'm happy to help in any way I can. Just let me know;. I am going to close this for now as per the above comments, but thanks for bringing this up @Huang-Libo!  I merged changes from master into 9.0.0-dev, but there were some conflicts and I would love if you guys could take a look at it and make sure everything is okay :D

> Conflicts:
> - Cartfile.resolved
> - Demo/Podfile.lock
> -	Package.swift
> -	Tests/ErrorTests.swift
> -	Tests/MoyaProviderIntegrationTests.swift
> -	Tests/RxSwiftMoyaProviderTests.swift
> -	Tests/TestHelpers.swift
> -	docs/Examples/AlamofireValidation.md @sunshinejr Last time we rebased `9.0.0-dev` with `master`, which I feel may be easier ü§î
 @pedrovereza Yeah, I did that as well, but didn't push to the branch itself, but created a new one and did a PR since it was a big merge and wanted to make sure I didn't break anything. Also, this problem with Changelog is strange since there was no conflict in it ü§î @sunshinejr Oh I see, let's go ahead and just make a commit fixing the changelog then üòÑ  Fixed `Changelog.md` & `Package.swift` - thanks @pedrovereza! Also, I've checked once again and it _seems alright_, but another look wouldn't hurt :D  Hey all! I'm here to present my idea of improving Plugins and continue (kinda deadly) discussion from #985. 

Right now plugins:
- Are limited to one base type that has many functions that are not used and most of the time empty (but still executed).
- Are hard to expand (as a result of point above).
- Have limited functionality (as a result of points above).
- Do many things that `endpointClosure` & `requestClosure` do as well - making it ambiguous for users to use & for us to recommend a good practice.

Below is my proposition on to how make all of the above go away. Main idea is to remove `closures`, `manager` etc. from `MoyaProvider` and replace it with plugins. The first version may just introduce everything we need to a migration and then expand it as we go. Maybe we can even extract something from `TargetType`? ü§î 

### Types

```swift
// Base type

public protocol Plugin {}
```

```swift
// Current plugin methods extracted into Plugin types

public protocol RequestDelegatePluginType: Plugin {
    func willSend(_ request: RequestType, target: TargetType)
    func didReceive(_ result: Result<Moya.Response, MoyaError>, target: TargetType)
}

public protocol ResponseProcessingPluginType: Plugin {
    func process(_ result: Result<Moya.Response, MoyaError>, target: TargetType) -> Result<Moya.Response, MoyaError>
}
```

```swift
// `endpointClosure` & `requestClosure` & `stubbingClosure` into Plugin types

public protocol EndpointPreparingPluginType: Plugin {
    func prepare<T: TargetType>(endpoint: Endpoint<T>, target: T) -> Endpoint<T>
}

public protocol RequestPreparingPluginType: Plugin {
    func prepare(_ request: URLRequest, target: TargetType) -> URLRequest
}

public protocol ResponseStubbingPluginType: Plugin { // we may also remove this one and try to change `ResponseProcessingPluginType` a little bit to allow stubbing behavior :)
    func stubBehavior<T: TargetType>(_ target: T) -> StubBehavior
}
``` 

```swift
// Authentication moved from Request to Plugin type too

public protocol AuthenticationPluginType: Plugin {
    func authenticate(usingCredential credential: URLCredential) -> Self
}
```

### Migration from current closures
We could persist current closures as a default plugins, e.g. this `DefaultEndpointClosure` translated:
```swift
class DefaultEndpointPreparingPlugin: EndpointPreparingPluginType {
    
    func prepare<T>(endpoint: Endpoint<T>, target: T) -> Endpoint<T> where T: TargetType {
        return Endpoint(
            url: URL(for: target).absoluteString,
            sampleResponseClosure: { .networkResponse(200, target.sampleData) },
            method: target.method,
            parameters: target.parameters,
            parameterEncoding: target.parameterEncoding
        )
    }
}
```

### Problem - How to store plugins?
We might want only one plugin for some types (e.g. `ResponseStubbingPluginType`) and unlimited for other types (e.g. `RequestDelegatePluginType`). Having multiple of stubbing plugins or request/endpoint preparing plugins creates undefined behavior. I thought that we may use a type for storing it (we would then have some sort of value dependent types):
```swift
final class PluginsConfiguration {
    
    let endpointPreparation: EndpointPreparingPluginType?
    let requestPreparation: RequestPreparingPluginType?
    let stubBehavior: ResponseStubbingPluginType?
    ...
    
    init(stubBehavior: ResponseStubbingPluginType? = nil, endpointPreparation: EndpointPreparingPluginType = DefaultEndpointPreparingPlugin()...) {}
}
```

But even tho it gives us comfort with multiplicity of plugins for now (and who knows what the future holds :D), this is not scalable. Let's say I would have one plugin having implementation of three protocols - I would have to type it 3 times. Now let's say we want to expand with plugins - we may end up with 20 properties and counting.

The second solution would be just having an array of `Plugin` type in `MoyaProvider.init`. Now we can choose to e.g. make `asserts` in code to only have X number of plugins with given type. This is not the best, but this way we are sure we do not end up with undefined behavior.

If you guys have any other ideas it would be great to hear them. Also, if you are still reading this, thank you! This might be a big change, so I'd love every feedback I can get. If the whole idea is just not the right one for your taste - just say it. 

/cc @Moya/contributors 

Cheers! üéâ  Cool topic, thanks for bringing it up @sunshinejr!

I have a few things I'd like to bring up:

* I'm a bit concerned that the base protocol of plugins is empty. I'd rather have a protocol that explictly exposes what it can be used for, or no base protocol at all.
* Maybe as a symptom of the above, all plugins you used as example define different contracts. for instance, what do an `EndpointPreparingPluginType` and `ResponseStubbingPluginType` have in common? What's the benefit of having both as `Plugin`?
* Not sure about the second storing options. Having an array of `Plugin` would probably force us to know the exact type of plugin before using it, making the `Plugin` abstraction not so useful.

I think we first need to have a clear vision of what exaclty is a plugin for Moya. Is it something external to the core API, similar to our current `PluginType`, which deals only with request/response? Or is it something capable of changing the internal behavior of the framework (like `EndpointPreparingPluginType` and `RequestPreparingPluginType`)? Or both? Thank you so much for the feedback, @pedrovereza üëå 

About empty base protocol - it would be needed if we wanted to go with solution 2 to the problem - array of plugins. For the first solution it would be possible to avoid the base protocol if there wouldn't be a reason for keeping it.

About different contracts - I agree that these are different. But [we already have different contracts in our current PluginType](https://github.com/Moya/Moya/blob/master/Sources/Moya/Plugin.swift#L10-L22) and I've just built on top of that. Maybe we need to think if we still want multiple contracts, but I believe that it would open more possibilities, like e.g. eliminating closures.

About second option to storing problem - we would need to have collections/properties of given plugins anyways, because we need to know which plugin to invocate, e.g. before firing up the request, we could invocate some plugin type that can decide if the request should use network or use stubs.

And the last but not least - what should our `Plugin` be? Given the fact how we use it right now (both delegation and modification of some objects), I wouldn't shrink the capabilities, rather stick to them (or stretch if needed). This way we would be able to reduce some responsibilities of Moya core and extract them into plugins. We might need to be circumspect in selecting which plugins we can add and which we cannot, though. @colinta you could use one plugin that implements few protocols, or just use multiple plugins - your choice. The point of this idea was to refactor plugins to have the same functionality as now, but also be easily expandable to features like `endpointClosure` & `requestClosure` or authentication/stubbing/inflights. 

Protocols in my example are just stubs for what we can really do - the `endpoint` function could get the parameter from the other plugin that makes an `Endpoint` from `TargetType`.

Nonetheless, If anyone have a different idea I'd love to hear it. Because of scale of this improvement and lack of feedback/better alternatives, I'm closing this one. Maybe we will revisit it some time in the future.  ~~Thanks for noticing, @LeonardoCardoso! @Moya/contributors, should we release `8.0.6` to support this for version 8 still, or do we want to hold off on this for v9? Not sure if this would break anything?~~ @devxoul By using `~> 3.0` we are saying we can take anything from `3.0` up until `3.9`. The problem here is that our minimal version should be `3.5` now. 

We would still want to use `~> 3.5`, as `>= 3.0` means we could take, for example, version `4.0`, which would include breaking changes that we may not be ready to take. ~~This confuses me every time. Why does `3.5` not work at this point, then? `3.5` is in the range of `3.0` and `4.0`, so that should work? ü§î~~ @LeonardoCardoso, I just set up a test project and it seems to work fine with RxSwift. Alamofire seems not to be updated yet, though, and causes an error.

Have you tried `pod update`? A fresh install uses RxSwift 3.5. ```bash
$ pod install
Analyzing dependencies
Downloading dependencies
Installing Alamofire (4.4.0)
Installing Moya (8.0.5)
Installing Result (3.2.3)
Installing RxSwift (3.5.0)
Generating Pods project
Integrating client project
``` @BasThomas @LeonardoCardoso  Yea, just double checked that I have a dummy project that is using RxSwift 3.5 as well.

@LeonardoCardoso If `pod update` doesn't solve it for you, could you share the content of your `Podfile` and `Podfile.lock`?  target.baseURL.appendingPathComponent will convert '?' to '%3f'. 'urlQueryAllowed' will be perfect
eg."http://cdn2.jianshu.io/assets/default_avatar/13-394c31a9cb492fcb39c27422ca7d2815.jpg?imageMogr2/auto-orient/strip|imageView2/1/w/240/h/240" -> OK 
"http://cdn2.jianshu.io/assets/default_avatar/13-394c31a9cb492fcb39c27422ca7d2815.jpg?imageMogr2/auto-orient/strip|imageView2/1/w/240/h/240"  ->404 I was given a strange url  "https://www.XXX.net/buildAction.do?mbGetIndexJson&city=370200"
"/buildAction.do?mbGetIndexJson" -> path . The path contain '?'  

 @SD10 I know how to avoid this problem.
If  don't change the methodÔºåI must put "https://www.XXX.net/buildAction.do?mbGetIndexJson" as baseUrl. There is no 'path', there is no sense to use moya for network.
So I put forward this problem Can you share the code where you expect a `?` instead of `%3f`? The example URLs in your initial message are both the same and work fine. @SD10 @BasThomas  a sample  Demo [demo](https://github.com/GuiFoA/moyaDemo.git) @SD10  Good ideaÔºåthanks  When doing a POST request, we should use `URLEncoding.queryString` instead of `URLEncoding.default` (as explained by @sunshinejr in [#1119](https://github.com/Moya/Moya/issues/1119#issuecomment-307929162))  Moya Version - 8.0.5

When I create a string for my path like:

```
"/id/?access_token=ACCESSTOKEN"
```

The '?' gets converted to '%3F' in the url which is sent and the server can't read this. Is there a way to send the '?' rather than the encoded unicode?

**What I want to send as the URL:**

```
https://api.test.co.uk/v1-dev/test/3?access_token=e02fkjhbjb4faf363jn0bcbeca0fad4aff
```

**What is actually sent as the URL:**

```
Moya_Logger: [12/06/2017 11:31:20] Request: https://api.test.co.uk/v1-dev/test/3%3Faccess_token=e02fkjhbjb4faf363jn0bcbeca0fad4aff
```
 What's your `parameterEncoding`? @BasThomas The parameterEncoding is 

> URLEncoding.default

@haritowa The server needs the access token and limits to be in the url. Would using params allow for this? @pete183 Yes, `URLEncoding.default` will put your parameters in the url :wink: @pedrovereza @haritowa Thanks for the help, it works now! Just to add to it: `URLEncoding.default` will behave differently in `GET` and `POST` requests. In `GET` method you will, in fact, get parameters in URL, @pete183. In `POST` on the other hand, you will get parameters in body. You can specify if you want it all the time in the URL or body using different properties of `URLEncoding` - more on the matter [here](https://github.com/Alamofire/Alamofire/blob/master/README.md#parameter-encoding). @sunshinejr Please check #1120 üòÖ  @sunshinejr Does Moya have an easy way to send two parameters one in the URL and one in the body using a POST request? We don't have a method exclusively for this behavior, but you can use custom `ParameterEncoding`, that would decide whether the parameter should be in body/url/header. You can find instructions on creating your own encoding [here](https://github.com/Alamofire/Alamofire/blob/master/README.md#custom-encoding).

**Edit:** Now that I think about it, that would be a good addition to our examples. If you, @pete183, or someone else end up doing their own `ParameterEncoding`, we would love to have it added to our examples directory. @sunshinejr 

I think something like this would work:

```swift
public var parameters: [String: Any]? {
    var params:[String: Any] = [:]
    params["query"] = ["access_token":getAccessToken()]
    params["body"] = ["user_name":"Pete"]

    return params
}

public var parameterEncoding: ParameterEncoding {
    return CompositeEncoding()
}


struct CompositeEncoding: ParameterEncoding {
        
    public func encode(_ urlRequest: URLRequestConvertible, with parameters: Parameters?) throws -> URLRequest {
        guard let parameters = parameters else {
            return try urlRequest.asURLRequest()
        }
            
        let queryParameters = (parameters["query"] as? Parameters)
        let queryRequest = try URLEncoding(destination: .queryString).encode(urlRequest, with: queryParameters)
            
        if let body = parameters["body"] {
            let bodyParameters = (body as! Parameters)
            var bodyRequest = try JSONEncoding().encode(urlRequest, with: bodyParameters)
                
            bodyRequest.url = queryRequest.url
            return bodyRequest
        } else {
            return queryRequest
        }
    }
}
``` Yeah, I was thinking about something similar. Unfortunately, this way you have to remember about 2 root keys being kinda instructions for sub dictionaries. We can improve it a little bit making these dictionary keys static in the `CompositeEncoding`:

```swift
struct CompositeEncoding: ParameterEncoding {
    enum Keys {
        static let query = "query" 
        static let httpBody = "httpBody"
    }
    
    ...
}

public var parameters: [String: Any]? {
    return [CompositeEncoding.Keys.query: ["access_token": getAccessToken()],
            CompositeEncoding.Keys.body: ["user_name": "Pete"]]
}
```

Would you want to make a PR with this, @pete183? It would require adding this example to `docs/Examples` and linking it in the `docs/Examples/Readme.md`. During the next couple of days I'll have a look into this! Great, thank you! üéâ  @sunshinejr 

There's an issue when you want to provide an array of parameters in a url like this:

```
/user/17?access_token=8312961fdgdgfmwe3r4f&fields=account_id,photo
```

It actually gives you:
```
/user/17?access_token=8312961fdgdgfmwe3r4f&fields%5B%5D=account_id&fields%5B%5D=photo
```

Here is the swift code for loading the parameters into the url query:
```swift
params[ParamKeys.query] = ["fields": ["account_id", "photo"], "access_token":getAccessToken()]
``` I am not sure if this is supported. Take a look at the discussion in #597, specifically [this](https://github.com/Moya/Moya/issues/597#issuecomment-244824456) comment. Does that work? @BasThomas 

When implementing this url param
```
["fields": "[\"account_id\", \"photo\"]", "access_token":getAccessToken()]
```
It gives me this:

```
/user/17?access_token=2db2sdfnkjnefw334819fa&fields=%5B%22account_id%22%2C%20%22photo%22%5D
```

Rather than:
```
/user/17?access_token=2db2sdfnkjnefw334819fa&fields=account_id,photo
```
 @pete183 This is the expected behavior from Alamofire. From [URLEncoding docs](https://github.com/Alamofire/Alamofire/blob/c8700ac7ea6b7efa7200e2920bf528e88b4dbee6/Source/ParameterEncoding.swift#L67):
> Since there is no published specification for how to encode collection types, the convention of appending `[]` to the key for array values (`foo[]=1&foo[]=2`), and appending the key surrounded by square brackets for nested dictionary values (`foo[bar]=baz`).

In order to achieve the format you want, you'd have to implement your own `ParameterEncoding`
 @pedrovereza 
Is it possible to tell URLEncoding to stop encoding a comma?

I've got the url to this at the moment:
```
/user/7?access_token=60323354sgnsldjnfs85a&fields=account_id%2Cphoto
````

And I need
```
/user/7?access_token=60323354sgnsldjnfs85a&fields=account_id,photo
```` @AkhilDad 

In the end I wrote a custom composite encoding. This allows for `,` to not be encoded. Within Moya, you will then need to choose this custom encoding: 

```swift
/// parameterEncoding: ParameterEncoding
/// - OAuth: URLEncoding.default
/// - Default: CompositeEncoding
public var parameterEncoding: ParameterEncoding {
    switch self {
        case .OAuth:
            return URLEncoding.default
        default:
            return CompositeEncoding()
    }
}
```

```swift
public struct CompositeEncoding: ParameterEncoding {
    
    public func encode(_ urlRequest: URLRequestConvertible, with parameters: Parameters?) throws -> URLRequest {
        guard let parameters = parameters else {
            return try urlRequest.asURLRequest()
        }
        
        let queryParameters = (parameters[ParamKeys.query] as? Parameters)
        
        var queryRequest = try URLEncoding(destination: .queryString).encode(urlRequest, with: queryParameters)
        
        if let body = parameters[ParamKeys.httpBody] {
            let bodyParameters = (body as? Parameters)
            var bodyRequest = try URLEncoding().encode(urlRequest, with: bodyParameters)
            //var bodyRequest = try JSONEncoding().encode(urlRequest, with: bodyParameters)
            bodyRequest.setValue("application/x-www-form-urlencoded", forHTTPHeaderField: "Content-Type")
            bodyRequest.url = queryRequest.url
            
            return bodyRequest
        } else {
            return queryRequest
        }
    }
}




// MARK: URLEncoding
/// Creates a url-encoded query string to be set as or appended to any existing URL query string or set as the HTTP
/// body of the URL request. Whether the query string is set or appended to any existing URL query string or set as
/// the HTTP body depends on the destination of the encoding.
///
/// The `Content-Type` HTTP header field of an encoded request with HTTP body is set to
/// `application/x-www-form-urlencoded; charset=utf-8`. Since there is no published specification for how to encode
/// collection types, the convention of appending `[]` to the key for array values (`foo[]=1&foo[]=2`), and appending
/// the key surrounded by square brackets for nested dictionary values (`foo[bar]=baz`).
public struct URLEncoding: ParameterEncoding {
    
    // MARK: Helper Types
    /// Defines whether the url-encoded query string is applied to the existing query string or HTTP body of the
    /// resulting URL request.
    ///
    /// - methodDependent: Applies encoded query string result to existing query string for `GET`, `HEAD` and `DELETE`
    ///                    requests and sets as the HTTP body for requests with any other HTTP method.
    /// - queryString:     Sets or appends encoded query string result to existing query string.
    /// - httpBody:        Sets encoded query string result as the HTTP body of the URL request.
    public enum Destination {
        case methodDependent, queryString, httpBody
    }
    
    // MARK: Properties
    /// Returns a default `URLEncoding` instance.
    public static var `default`: URLEncoding { return URLEncoding() }
    
    /// Returns a `URLEncoding` instance with a `.methodDependent` destination.
    public static var methodDependent: URLEncoding { return URLEncoding() }
    
    /// Returns a `URLEncoding` instance with a `.queryString` destination.
    public static var queryString: URLEncoding { return URLEncoding(destination: .queryString) }
    
    /// Returns a `URLEncoding` instance with an `.httpBody` destination.
    public static var httpBody: URLEncoding { return URLEncoding(destination: .httpBody) }
    
    /// The destination defining where the encoded query string is to be applied to the URL request.
    public let destination: Destination
    
    // MARK: Initialization
    /// Creates a `URLEncoding` instance using the specified destination.
    ///
    /// - parameter destination: The destination defining where the encoded query string is to be applied.
    ///
    /// - returns: The new `URLEncoding` instance.
    public init(destination: Destination = .methodDependent) {
        self.destination = destination
    }
    
    // MARK: Encoding
    /// Creates a URL request by encoding parameters and applying them onto an existing request.
    ///
    /// - parameter urlRequest: The request to have parameters applied.
    /// - parameter parameters: The parameters to apply.
    ///
    /// - throws: An `Error` if the encoding process encounters an error.
    ///
    /// - returns: The encoded request.
    public func encode(_ urlRequest: URLRequestConvertible, with parameters: Parameters?) throws -> URLRequest {
        var urlRequest = try urlRequest.asURLRequest()
        
        guard let parameters = parameters else { return urlRequest }
        
        if let method = HTTPMethod(rawValue: urlRequest.httpMethod ?? "GET"), encodesParametersInURL(with: method) {
            guard let url = urlRequest.url else {
                throw AFError.parameterEncodingFailed(reason: .missingURL)
            }
            
            if var urlComponents = URLComponents(url: url, resolvingAgainstBaseURL: false), !parameters.isEmpty {
                let percentEncodedQuery = (urlComponents.percentEncodedQuery.map { $0 + "&" } ?? "") + query(parameters)
                urlComponents.percentEncodedQuery = percentEncodedQuery
                urlRequest.url = urlComponents.url
            }
        } else {
            if urlRequest.value(forHTTPHeaderField: "Content-Type") == nil {
                urlRequest.setValue("application/x-www-form-urlencoded; charset=utf-8", forHTTPHeaderField: "Content-Type")
            }
            
            urlRequest.httpBody = query(parameters).data(using: .utf8, allowLossyConversion: false)
        }
        
        return urlRequest
    }
    
    /// Creates percent-escaped, URL encoded query string components from the given key-value pair using recursion.
    ///
    /// - parameter key:   The key of the query component.
    /// - parameter value: The value of the query component.
    ///
    /// - returns: The percent-escaped, URL encoded query string components.
    public func queryComponents(fromKey key: String, value: Any) -> [(String, String)] {
        var components: [(String, String)] = []
        
        if let dictionary = value as? [String: Any] {
            for (nestedKey, value) in dictionary {
                components += queryComponents(fromKey: "\(key)[\(nestedKey)]", value: value)
            }
        } else if let array = value as? [Any] {
            for value in array {
                components += queryComponents(fromKey: "\(key)[]", value: value)
            }
        } else if let value = value as? NSNumber {
            if value.isBool {
                components.append((escape(key), escape((value.boolValue ? "1" : "0"))))
            } else {
                components.append((escape(key), escape("\(value)")))
            }
        } else if let bool = value as? Bool {
            components.append((escape(key), escape((bool ? "1" : "0"))))
        } else {
            components.append((escape(key), escape("\(value)")))
        }
        
        return components
    }
    
    /// Returns a percent-escaped string following RFC 3986 for a query string key or value.
    ///
    /// RFC 3986 states that the following characters are "reserved" characters.
    ///
    /// - General Delimiters: ":", "#", "[", "]", "@", "?", "/"
    /// - Sub-Delimiters: "!", "$", "&", "'", "(", ")", "*", "+", ",", ";", "="
    ///
    /// In RFC 3986 - Section 3.4, it states that the "?" and "/" characters should not be escaped to allow
    /// query strings to include a URL. Therefore, all "reserved" characters with the exception of "?" and "/"
    /// should be percent-escaped in the query string.
    ///
    /// - parameter string: The string to be percent-escaped.
    ///
    /// - returns: The percent-escaped string.
    public func escape(_ string: String) -> String {
        let generalDelimitersToEncode = ":#[]@" // does not include "?" or "/" due to RFC 3986 - Section 3.4
        let subDelimitersToEncode = "!$&'()*+;="
        
        var allowedCharacterSet = CharacterSet.urlQueryAllowed
        allowedCharacterSet.remove(charactersIn: "\(generalDelimitersToEncode)\(subDelimitersToEncode)")
        
        var escaped = ""
        
        //==========================================================================================================
        //
        //  Batching is required for escaping due to an internal bug in iOS 8.1 and 8.2. Encoding more than a few
        //  hundred Chinese characters causes various malloc error crashes. To avoid this issue until iOS 8 is no
        //  longer supported, batching MUST be used for encoding. This introduces roughly a 20% overhead. For more
        //  info, please refer to:
        //
        //      - https://github.com/Alamofire/Alamofire/issues/206
        //
        //==========================================================================================================
        if #available(iOS 8.3, *) {
            escaped = string.addingPercentEncoding(withAllowedCharacters: allowedCharacterSet) ?? string
        } else {
            let batchSize = 50
            var index = string.startIndex
            
            while index != string.endIndex {
                let startIndex = index
                let endIndex = string.index(index, offsetBy: batchSize, limitedBy: string.endIndex) ?? string.endIndex
                let range = startIndex..<endIndex
                
                let substring = string.substring(with: range)
                
                escaped += substring.addingPercentEncoding(withAllowedCharacters: allowedCharacterSet) ?? substring
                
                index = endIndex
            }
        }
        
        return escaped
    }
    
    private func query(_ parameters: [String: Any]) -> String {
        var components: [(String, String)] = []
        
        for key in parameters.keys.sorted(by: <) {
            let value = parameters[key]!
            components += queryComponents(fromKey: key, value: value)
        }
        #if swift(>=4.0)
            return components.map { "\($0.0)=\($0.1)" }.joined(separator: "&")
        #else
            return components.map { "\($0)=\($1)" }.joined(separator: "&")
        #endif
    }
    
    private func encodesParametersInURL(with method: HTTPMethod) -> Bool {
        switch destination {
        case .queryString:
            return true
        case .httpBody:
            return false
        default:
            break
        }
        
        switch method {
        case .get, .head, .delete:
            return true
        default:
            return false
        }
    }
}



extension NSNumber {
    fileprivate var isBool: Bool { return CFBooleanGetTypeID() == CFGetTypeID(self) }
}
``` @AkhilDad This is to send it as a path, it's just that in Alamofire, they call it parameter encoding. If you give me a sample of the path which you would like to send data too, I could create it.  Hmm, this is an interesting one. Not sure what to think of it yet. Thanks for the issue, @SD10 - this is a really good idea. Having standardized encoding/decoding by Swift standard library, I think it is natural for us to implement a basic map method that would cover this behavior. However, for now we don't have any Swift 4.0 branch and we are in the middle of Moya 9.0 release, so we might want to wait with that implementation.  Thanks for taking the initiative @SD10! That sounds great, we'll update this issue once we cut a 9.0 release üòÑ   Continues #762 

Hopefully I didn't miss any `queue` üòÑ  üëèüëç  Hey @k8mil. You are right - by default `POST` method would add parameters to the body. But there is an option to brute-force it in the query string: you would have to use `URLEncoding(destination: .queryString)` as your `parameterEncoding`. More on this matter you can find [here](https://github.com/Alamofire/Alamofire/blob/master/README.md#parameter-encoding).  Hey @KieSun. This is really strange. [We have tests around progress](https://github.com/Moya/Moya/blob/master/Tests/MoyaProviderSpec.swift#L700-L742), but if you found an edge case which our tests do not cover - please let us know with more detailed description. Even better if you could write a test for that. Right now, I can't really help you based on this information. This issue has been marked as stale because it has not had recent activity. It will be closed if no further activity occurs. 
 There is no test about upload progress, only download progress 

But I made an unit test on httpbin and we receive progress info
https://github.com/phimage/Moya/commit/765113a198d3058235a2197b9c5f9757cdc72aa5 Hey, thanks @phimage! Can you open a PR so we can add that test? That'd be awesome! Yes I will do it
I have 3 commits, maybe 3 or 2 PR to do, and all about "progress", so potentially a lot of conflicts if I do not make it one after another.
First one is #1232, I must convert it for 9.0.0-dev  In this PR:
- Added Assets setup (all credits goes to @scottrhoyt, from #968).
- Added two examples that weren't in the Readme (Alamofire automatic validation & Creating an authorization plugin)
- Removed unnecessary **Advanced** prefix - we weren't consistent with it and it is hard to judge what is advanced and what is not - let's just stay with one "Basic" example.

As always, let me know what do you guys think. Cheers! üéâ   Thanks a lot for contributing to Moya! I've invited you to join the Moya GitHub organization ‚Äì no pressure to accept! If you'd like more information on what that means, check out our [contributor guidelines](https://github.com/Moya/contributors) and feel free to reach out with any questions.  Hey @mrfarukturgut , `JSONResponseDataFormatter` is not part of Moya. We have the function [implemented in our Demo app](https://github.com/Moya/Moya/blob/5678a4c66ad779b15173315b0c2e300d0e3d9ba9/Demo/Shared/GitHubAPI.swift#L6), you'd need to implement the function on yours :wink:  I think we should be able to add this in Moya. I'll take a look. Thanks for bringing this to our attention! I've opened #1127.  Hey @eliacamposilvan. Thanks for filling in an issue.

Is this issue happening on other versions of Moya as well? Can you use our `NetworkLoggerPlugin` in your `MoyaProvider` or any other tool like `mitmproxy` to make sure it's Moya issue, not a server issue? Logs from that would be really helpful. It would be even better if you could prepare demo project where this issue exist so I can investigate more. Don't worry about it, glad you figured it out! üéâ  Also, from the logs it seems like there is no body in the response, might want to check that out as well. 

Please feel free to reopen if you find something that might be a Moya problem anyways.   This is great üëç Also, can we maybe make a Danger rule to avoid `=====` & `------` and use `#` in .md files? ü§î 

**Edit:** I see your üëç , does it mean you're gonna do this in this PR @BasThomas? :D or let's just do another one? Let's open a separate one for that. üòÉ I'd need to dive into SwiftLint for that though, so if you'd like to do that, feel free. Does SwiftLint actually work with non-`.swift` files? üòÆ Haha, probably not, I've meant Danger but well, that happened üòÖ Hah, of course. Let me think of a nice way to check.  So I was doing a release today and found out that the instructions weren't as clear as I thought it would be. I've added some examples, note for `ZSH` users & format it a little bit. 

[Preview](https://github.com/Moya/Moya/blob/releasing-patch/docs/Releasing.md) ü§î, never saw this, but it seems like we're using `----` style and `#` style headers all around the place. I can open  a PR soon changing these all to the `#` notation? That, at least to me, is a bit cleaner. Thoughts? Yeah, good idea. Let's make it consistent :)  Last few PRs were to the Tests directory and thus our MoyaBot reminded me that we need to take care of this directory with SwiftLint as well. Of course, these are test cases, so the rules in this directory might been a little bit loosen up. That's why I've added another config file with less strict rules in there. If you don't agree with (not) having some rule on the list, let me know. 

I've also fixed most of the errors, but there are 2 left. These are about file length & type length, but I believe we don't need to exclude these rules. I'm more keen to refactor a bit `MoyaProviderSpec`, because there is a room for that.  What is it exactly where you encounter an error? Can you clarify what doesn't work as expected?  Rationale: #1071. 

~~(I'm gonna comment in the PR my opinions, bear with me for a sec :D)~~
**Edit:** Finished my feedback, I'd love to hear your opinion on this! Maybe not for now, but I was thinking: can we lock issues with x comments after being closed? Looking at the [lib file](https://github.com/probot/stale/blob/master/lib/stale.js), I think there is no `lock()` method and any other that are needed for this to happen. Although I love the idea and we can try to add an Issue or PR if someone is more skilled in .js than me üòÖ  @BasThomas read my mind. Locking would be awesome, let's create that issue üòÑ  GitHub apparently doesn't support locking (yet)... https://github.com/probot/stale/issues/16#issuecomment-291862121 ... but there seems to be a plugin that *does* work? I can't really find out how this would work: https://github.com/lee-dohm/lock. Thanks for all this work though, @sunshinejr! This seems like a great addition. üéâ I've updated the PR:
- Added `confirmed bug` & `chore` in exempt labels.
- Renamed stale label to `no recent acitivity`
- Changed the comments for marking & closing.
- Added days we waited for the response in an issue.

Let me know what do you guys think :)
 Fair trade :D Should be good to go üëç   As per title. Nimble introduces version 7.0.0 with new Predicate API. Additionally, thanks to this update, we've got a little nicer error messages üêº 

from:
> Assertions: expected to match, got <imageMapping(Status Code: 200, Data Length: 0)>

to:
> Assertions: expected to <jsonMapping(Status Code: 200, Data Length: 0)>, got <imageMapping(Status Code: 200, Data Length: 0)>

(also I've updated the Cartfile to match Nimble 7.0.0) (Don't worry about this SwiftLint warnings: I've got a next PR lined up, with all fixes. Just need to do some gardening before :D)  Hey @longshihua, this is a good one. Testing is our top priority, so we should've better documentation around that. We are working on it, but in the meantime... 

If we are talking about testing with `sampleData` in unit tests, [you can see it in our tests how we do it here](https://github.com/Moya/Moya/blob/master/Tests/MoyaProviderSpec.swift#L15). Basically we use `stubbingClosure` and check the data from the response. If we are talking about testing without using any stubbing option built in in Moya, we have these as well. For that purpose we use [OHHTTPStubs](https://github.com/AliSoftware/OHHTTPStubs), you can see how we do it [here](https://github.com/Moya/Moya/blob/master/Tests/MoyaProviderSpec.swift#L711).

Hope it helps!  This issue has been marked as stale because it has not had recent activity. It will be closed if no further activity occurs. 
 This issue has been auto-closed because there hasn't been any activity for 59 days. However, we really appreciate your contribution, so thank you for that! üôè Also, feel free to [open a new issue](https://github.com/Moya/Moya/issues/new) if you still experience this problem üëç.
  It would be really cool if we could create a Playground / Playground Book to guide new users through the library. Doing this via Playgrounds allows us to easily guide the user along the process with live examples and inline comments.

Is this something people would like to see? Good idea. I really like the way RxSwift did its [Rx.playground](https://github.com/ReactiveX/RxSwift/tree/master/Rx.playground). We could use our documentation & examples to create some chapters (initial idea): Setup -> Basic usage -> Closures -> Stubbing -> Tests -> Plugins -> Advanced usage.

But then, having in mind we wanted to make a website(#1079), having also docs with examples, we would have to find a way of maintaining it all, or choose something we actually can maintain ü§î  That'd be awesome, @SD10!

On maintaining everything: yeah, this will definitely be some more work. But as @SD10 brought up, having "compiling documentation" makes it easier to spot errors and fix them.

I am also still not sure about the website, but let me comment about that in its ticket. This looks cool, @SD10! Made two comments in there, other than that I love it. I think there should be a fine line between reusing existing docs and making the walkthrough feel more like a learning process.  As per #1094. This bug should be fixed, I've also added a test case to check correct number of events.  Hey @Re-cover! Thank you so much for filling in an issue.

I'm investigating it and seems like a problem on our end. I have a fix for that already, just need to write some tests. Gonna reference it here once I do the PR.  I've made a PR with the fix, #1095. I'm gonna close this one in favor of this PR. If you'd still have the problem after this PR is merged, please reopen this issue. Thanks again!  In this PR:

1. Add .git suffixes. Rationale: [Stencil#84](https://github.com/kylef/Stencil/pull/84) and [Stencil#101](https://github.com/kylef/Stencil/issues/101). Basically really similar situation in our case. `ReactiveSwift` has `Result` as a dependency with `.git` suffix in `Package.swift`, and we also have `Result` dependency - but without `.git` in `Package.swift`. It might also resolve our problem in [SPM-compat](https://github.com/apple/swift-source-compat-suite/pull/35).
2. Add `Package.pins` to `.gitignore`, as per [SPM docs](https://github.com/apple/swift-package-manager/blob/master/Documentation/Usage.md#automatic-pinning). Nice! Could this also fix #1072 / https://github.com/apple/swift-source-compat-suite/pull/35? Seems like this might have been the issue there.  It _might_, we will have to test it once this is merged.  Should we also add the git suffix to the Readme SPM instructions for Moya itself? Other than that, this LGTM. Oh, right! Thanks, I'm on it.  Done üëç   Hey guys! In this PR:

- [x] Fix error that wouldn‚Äôt build MultiTarget Demo.
- [x] Remove warnings and unnecessary optionals in MultiTarget Demo.

Cheers! üéâ   Hmm, that is a vital PR not only in fixing typos, but finding out that our tests needs linting as well. Gonna do it in the next PR.   Hey @ZHDeveloper. I'm not sure if I understood your question correctly: you want to access request parameters after getting the response? If yes, it should be possible, but not so easy. 

Our `Response` object has a `request` property that contains a `URLRequest` object in it. Now, depending on the parameter encoding, you would have to extract the parameters yourself: get parameters from the `request.url` if the request was using `URLEncoding`, maybe access the `request.httpBody` if it was using `POST` method. 
Below is a snippet how to get to `request` property from firing up the Moya request:

```swift
func downloadZen() {
    provider.request(.zen) { result in
        if case let .success(response) = result {
            let request = response.request // now do some logic with `URLRequest` object
        }
    }
}
```

However, you may try to get your parameters _just before the request_. We have a `requestClosure` that does the mapping from `Endpoint` to `URLRequest` and you can extract them from this place as well. An example of that is in our tests, [here](https://github.com/Moya/Moya/blob/dfa3568fd7727c99feeebb8156a53a915844ee72/Tests/MoyaProviderSpec.swift#L556-L575).

Hope it helps! Let us know if something wasn't clear or you need more help on that matter.  Can you post your code where this error is shown? How did you end up solving the problem?  Hi @longshihua,

you have a few options here. The way I usually do is to create a static function on property that returns a provider to me. I usually do this in a separate `struct` or `class` in way that I can have a separate implementation for tests if necessary.

Something like this:

```swift
struct HTTPServiceProvider {
    static var shared:  RxMoyaProvider<HTTPService> = {
        let endpointClosure = { (target: HTTPService) -> Endpoint<HTTPService> in
            let defaultEndpoint = MoyaProvider.defaultEndpointMapping(for: target)
                return defaultEndpoint.adding(newHTTPHeaderFields: ["Accept":"application/json"])
            }
        provider = RxMoyaProvider<HTTPService>(endpointClosure: endpointClosure)
    }()
}
```

But I suppose you can also use your `setupProvider` making it static in the struct above and call it from your view controller. 

A third option would be to have the `setupProvider` as a function in an `extension` of `UIViewController`, but I would not recommend this one as it's the least clear IMHO. On a side note, dealing with header fields will (hopefully) be easier in `9.0.0` (see #1067) :wink: I'm gonna close this issue for now, but if you'll have more questions about this topic, please feel free to reopen it whenever üëç    Thanks again, keep it up!   üòçüôå Btw, our 100th member of Moya organization! üéâüéâüéâ Haha, membership in the best community out there :>  Thanks a lot for contributing to Moya! I've invited you to join the Moya GitHub organization ‚Äì no pressure to accept! If you'd like more information on what that means, check out our [contributor guidelines](https://github.com/Moya/contributors) and feel free to reach out with any questions. Thank you, @jawwad! üéâ   Hi, @Deniallugo!

Have you tried using one of the authorization plugins? Maybe that would be easier. You can find the [documentation here](https://github.com/Moya/Moya/blob/master/docs/Authentication.md). @Deniallugo I'm gonna close this. Feel free to reopen if you're still having problems with it.  As per #1078. Name **Community.md** is taken in our root directory so I didn't want to pick the same (the distinction might be key). Right now I've chosen **CommunityProjects.md** but I'm open to suggestions. 

Also I wasn't sure how can we word/point from **Readme.md** to **CommunityProjects.md**, so if you have any suggestions, please also let me know.

I've also added NetClient project from @alexruperez as a first Library üéâ 

Cheers!  I think this is a good first step, we can take improvements (if any) in PRs.

Thanks for the work @sunshinejr!  Do you think we, @Moya/contributors, can create a Vision document? This would help us create some clear goals for the project as well as giving the community and users a better idea of what we expect of this project going forward.

What do you think? And more concrete: what should be in it?

FAQ: 
Separating subspecs into repositories
Model decoding: soon with Apple's APIs
https://github.com/Moya/Moya/issues/1126#issuecomment-312125039 üëç 

We could start with maybe using something we already have. I think the first paragraph of our Readme (till the **Sample Project**) with some changes could be a good start. I think we should prioritize Vision document, as it will be really helpful in reviewing new features/ideas for contributors as well as making sure that idea someone has is a good fit for Moya. 

Pinging you, @ashfurrow, as your contribution here would be invaluable. Could any of you guys start this one and we can go from there in a PR?  Cool cool ‚Äì I've got some time this weekend, I'll see what I can do üëç Hey ‚Äì still haven't gotten around to this. Requires some dedicated thinking time. Will do my best üëç No problem Ash, please take your time. And thanks for letting us know üëç  This totally fell off my radar ‚Äì going to prioritize it this weekend.   Hey @iOSUser110. Is this JSON you provided your response, or do you want to construct a request with these parameters in it? It is really strange, could you give us the specific code for `parameters` that you return, @iOSUser110 ? @iOSUser110 what do you have set on your `parameterEncoding`? This situation described by @mpsnp only makes sense to me if you're using `URLEncoding`. @iOSUser110 I don't think it's advised to use `URLEncoding` for complex data types like this one. If you're able to change it to a `POST` with `JSON` format it would be much better. I'm not sure how I would do a workaround to make it work with `URLEnconding`. This issue has been marked as stale because it has not had recent activity. It will be closed if no further activity occurs. 
 This issue has been auto-closed because there hasn't been any activity for 59 days. However, we really appreciate your contribution, so thank you for that! üôè Also, feel free to [open a new issue](https://github.com/Moya/Moya/issues/new) if you still experience this problem üëç.
  Hey guys! In #1078, @orta made a good point that maybe we should think about a website for Moya. What do you think about it, @Moya/contributors? ü§î 

Personally, I don't have much experience with that, so we would need to have someone taking care of that project.

 What would be the advantage compared to a list in the repo? Or maybe: what would we want to get out of a website apart from just a list of project built with / on top of / extending Moya? Also, as @juliengdt mentioned, I think doing so with Jekyll would be pretty nice, as I think most of us (?) already have some experience with it. I think we don't have to constraint it only to the community around Moya (projects/extensions/etc), but we can also show examples/tutorials/documentation there as well. We could also show how we do open source or how to start contributing. We'd have everything in docs, but website may be an alternative way of presenting the important stuff. But that makes me wonder, can we connect the website with our markdown docs fairly easy? Would it be time-consuming to maintain it?  I've helped out with similar sites like this one: https://github.com/RxSwiftCommunity/rxswiftcommunity.github.io Jekyll is great, Middleman is also great. Whatever people are familiar with sounds good to me.  Great! I think we can start with a skeleton in Jekyll as a first step. Does anyone here want to take a stab at it?  Hey all! Recently there was a PR #1065, where @alexruperez wanted to let the world know his library is compatible with Moya. Personally, I think this is awesome, but unfortunately it was listed against "Community Extensions" in our Readme. There are many awesome projects around Moya, which may or may not be "an extension" (which can also be arbitrary). Can we do something about it, @Moya/contributors? My few propositions:

1. Leave the sections as it is, but accept everything related to Moya.
2. Change the name of the section to some more generic one and accept PRs accordingly. 
3. Make a new doc with everything around Moya (extensions/libraries compatible with Moya/abstractions/projects(?)) and link it from Readme.
4. Maybe use wiki [like Quick does it](https://github.com/Quick/Quick/wiki)?
5. Let's just stay with what we've got, no need for a change.

I think the goal is to make people know that we ‚ù§Ô∏è all the work around Moya and make them feel appreciated in some way or another. The question is how to do it? ü§î Great idea, thanks for some initial thoughts @sunshinejr!

1. Seems OK, but might grow a bit big long term.
2. Seems even better than `1.`, without any downsides.
3. This seems like a great option to me. Easily expandable, and when linking from the Readme, it's also easily accessible.
4. I have a feeling wikis are not often used nor seen. I can't remember the last time I've looked a wiki for anything else than documentation (for reference, I used it when browsing [Freddy](https://github.com/bignerdranch/Freddy/wiki) documentation).
5. I think the other options are all better, so let's change things for the better. üòÉ  Thanks for starting the discussion @sunshinejr üôå 

I vote for 3. I like the idea of 3! üôå  I'm in for 3 Great, seems like another doc is a way to go :) Thank you all for the feedback! Gonna tackle that one later today. Let me know if I can help in any way :) Seems like a good idea! I'm gonna open a new issue for that as well. Closing in favor of #1082.  Fixes #1070.  Mentioned in #1070

Makes Danger `warn` about missing changelog entry instead of `fail` (which causes the build to fail and can be confusing  to new contributors)
  After #762 is ready and merged, we should look at releasing `9.0.0`! üéâüöÄ

- [x] Queues (#762)
- [x] `rx.request` / `reactive.request` (#1140, #1153, #1163)
- [x] Removing deprecated methods/types from 8.0.0  (#1162)
- [x] Check 8.0 -> 9.0 migration with an old project and check if the fix-its work as expected / there is need for a migration guide
 I think it is time to focus more on this release in the near future. There were multiple issues regarding our new introductions in 9.0.0 and Swift 4 is on the horizon. I'd love to have queues changes (#762) in, and if we can, `rx.request` & `reactive.request` from #963 and `sampleData` from #1126 as well. These are quite big breaking changes so I think we could try and wait for that, but we might want to just go without them if it takes too much time. What do you guys think? Yeah, I think we should try to get 9.0.0 out of the door soonish, also to avoid having 10.0.0 being around the corner immediately.

I feel like the queue changes are first priority. `rx.request` and `reactive.request` are not that difficult to implement (I think?). As both are breaking changes, it would be nice to have them both in one release.

I think the `sampleData` is a little less of a priority, and we might want to put that into 10.0.0 if it takes too long. Exactly my point of view as well. Let's just try and finish queues, then pursue `rx.request` & `reactive.request` (which shouldn't be hard to implement, but if it turns out there is something in the way, we might want to skip it as well). If we can get `sampleData` PR in the meantime - great. If not, we may release 9.0.0 anyways. I was thinking of a migration strategy to go from `RxMoyaProvider` to `MoyaProvider.rx` and from `ReactiveSwiftMoyaProvider` to `MoyaProvider.reactive`, but couldn't think of any where we can have a fix-it. Then I thought of something else. What we **can** do, is deprecate `RxMoyaProvider` and `ReactiveSwiftMoyaProvider`'s `init`s and make them private in 10.0.0, therefore having a more user-friendly migration as well as a transition with deprecation. Yeah, that's a good idea, let's do it üëç  I'm thinking of merging `9.0.0-dev` into master after we merge queues & removing deprecations. What do you guys think? @sunshinejr I think that's a good idea. #1126 SampleData still needs some time and I think there are enough changes in 9.0 as is. I recommend we move it to 10.0 to not hold up this release.  Removed sample data from the todo-list and checked availability point since it has been recently merged. ~Only queues left (which probably needs a double-check only)~ and a final check for the entire release.

I also think it might be a good idea to do a beta release before the official one. Seems like quite a lot has changed! üòÑ 

**Edit:** Queues merged! Now we need to merge changes from master & 9.0.0-dev. I will try to do it on the weekend! Update! üéâ 
 
I've managed to merge changes from master & 9.0.0. I Must say it wasn't _that_ easy, but I think I've got everything in the end. I'm gonna make a PR in a sec, because it would be awesome to double check we got everything. Especially reactive providers with tests, since we had 2 PRs side by side, with one being in master and second one in 9.0.0-dev, so I had to merge them manually.

Also, I think that we should do alpha release instead of beta first. Why? There is this PR #1147, it progressed really fast from zero to almost ready state. I'm not sure if we can squeeze this one in 9.0.0, we gotta think about it for sure, but making an alpha release gives us more flexibility. +1 on the alpha.  We can also think about adding Swift 4.0 support. From what I've seen we just need to change `NetworkLoggerPlugin` init, because it uses `fileprivate` method as a default parameter, thus Swift 4 compiler complains. Simple fix would be to use optional `output` parameter with `nil` as a default argument and in case `nil` is passed, use `NetworkLoggerPlugin.reversedPrint`. This way compiler shouldn't complain anymore üòÑ 

This might be a good idea just after an alpha merge since we probably don't want to mess with that PR anymore üòÑ  Seems like a great idea, especially when it would be that simple. No reason to make it another major version bump just for Swift 4.  Okay everyone, alpha is merged. I'm gonna do a release in a bit üéâ  Thanks for all the hard work you've been putting into this, @sunshinejr! üí™ 9.0.0-alpha released! Thanks to everyone involved üí™üí™üí™

We can try to focus on the next release now üòÑ Apart from bugs/patches we'd need to do, we could:
- Update `NetworkLoggerPlugin` to make Moya compatible with Swift 4.0
- If we update our codebase to support Swift 4.0, we shoud update our CI setup to build both 3.X version and 4.0.
- Add #1147 (+ documentation/tests).
- Update AccessTokenPlugin to accept `Basic` or `Bearer`. This should be covered by @yar1vn from #1172.

What do you think guys? Something to add, something to remove?  @sunshinejr When referring to the next release, are you talking about `9.0.0-beta` or `10.0.0`? Oh, I mean in 9.0.0 context - beta.1/alpha.2, depends how we feel about what we can still add to the pile. On availability / fix-its: check https://github.com/Moya/Moya/pull/890. Example: https://github.com/Moya/Moya/issues/888#issuecomment-270004469 We are closing in for the next release! üéâ  I think the last PR that is needed (from the code perspective) is #1241. We've come really far with this one! 

The only question I'm having is whether we should release `alpha.2` or `beta.1`? Do we have more breaking changes that we want to include in this release? ü§î  @sunshinejr Thanks for taking care of those unit tests üí™ I think we should go with `beta.1`. I don't have any more breaking changes personally and I don't think we should hold up the release for much longer. There's been more issues regarding Swift 4 recently and people looking to use some of the changes made in `9.0.0`. That's what I was thinking as well! We need to speed up with the process a little bit, we can add more breaking changes in the 10.0 from now on. Thanks for the input, @SD10!

So, we've got tests merged in (we've got a lot of improvement lately thanks to @phimage), I'm gonna release `beta.1` in a while! üéâ  Beta 1 released! Thanks to everyone that played even a small part in it! üéâ üéâ üéâ 

Now it's time to make sure it is all working well before final release. üòÑ  Thanks for all the effort, everyone - and @sunshinejr in particular. üôå Thank you for all your hard-work @sunshinejr @BasThomas üç∫ üéâ  Thank you all to review my PR and for the hard-work

> to make sure it is all working well

To achieve this I make a new PR about multipart part upload ;)  Can you post an example of your use case? I think - but I can't find it right now - we are using `NSError`s on purpose. Maybe someone of the @Moya/contributors knows or can point to a discussion on that?

If we do indeed want to end up changing this, It'd be awesome if we can take this with us in the `9.0.0` release. I think I was implementing this one and I'm also positive there was a reason for `NSError`, but I don't remember right now and I don't see any downsides as well. Thus I think we can try changing it to just an implementation of `Error` type. At least we can do a PR and see what happens. Especially with 9.0.0 version that is in the making. Do you want to take a stab at that, @Zeeker?  Possibly related: https://github.com/Moya/Moya/issues/437#issuecomment-198780649 and https://github.com/Moya/Moya/issues/478 Oh right, I was talking about this one for sure! Thanks, @pedrovereza. 

However, I was mistaken, this is a different error here. The problem was with underlying error in request/response, here is a problem with sample response. However, it is kinda similar problem, because normally this should be an underlying `NSError` (a network error)... 

Now that I think about it, maybe we can go with `MoyaError` here? Moya has an `.underlying` error already, which takes an `NSError` if needed. Although how would we go about custom errors? ü§î This issue has been marked as stale because it has not had recent activity. It will be closed if no further activity occurs. 
 This issue has been auto-closed because there hasn't been any activity for 59 days. However, we really appreciate your contribution, so thank you for that! üôè Also, feel free to [open a new issue](https://github.com/Moya/Moya/issues/new) if you still experience this problem üëç.
  yup, that would be awesome! Do you want try to make a pull request against apple's repository?  Thanks for looking into this, @aksswami! üòÄ  This has been merged on Apple's side. @aksswami, thank you so much for picking this up! @BasThomas so it was, in fact, this `.git` suffix bug? Maybe we should let the world know somehow, this was found by an accident ü§î  I think so? Maybe better to ask over at https://github.com/apple/swift-source-compat-suite/pull/35; @lplarson fixed it (by updating just the hash as far as I understand, so I think the `.git` suffix did the trick. Huh, now where should we raise an issue, on SPM or SPM-compat? ü§î  Good question. I'd just start from the Compat PR, and go from there? Or going straight to the mailing list is also an option. Right, gonna just comment on the PR what was wrong in our project then. :+1:  I recently saw @KrauseFx's talk on scaling open source communities (great talk, I'd recommend it to everyone who's doing anything at all in open source). https://news.realm.io/news/tryswift-felix-krause-scaling-open-source-communities-github-management

One of my big take aways was fastlane's fastlane-bot. Which would automatically follow up with issues and close them if there was no response.
Right now, a couple of contributors have been manually doing that, but I think it would be awesome if we could add some of fastlane-bot's functionality to our bot so we don't have to politely close stale issues

Any thoughts from other contributors? Does anyone want to take a shot at implementing that for MoyaBot? I really like this - though looking at fastlane-bot's [repository](https://github.com/fastlane/issue-bot), I have no idea how it would work implementing it. Does anybody have an idea, or should we go ahead and file an issue there? We can wait for [Peril](https://github.com/danger/peril) from @orta. It looks really promising. It is not fully stable yet, but it can already post on issues AFAIK. Peril does look really nice, let's wait for that to be usable Just came across this: https://github.com/probot/stale ü§î  This one is really cool! I think we can try to do it. What do you think, @Moya/contributors?

**Edit:** Also, can we do it using MoyaBot? Sure, this would be really nice! Re: MoyaBot: I think you should ping @ashfurrow to ask if that's possible. :) Ye, and this one is looking cool. The question is if we want/can use MoyaBot for that. Also, we would need someone to do a PR with config. Let's just start with something and we will adjust values in a PR if needed. üòÜ
I'm happy this is happening! I was talking with Ash and we've figured that MoyaBot would need a write access so it would be better to use different bot or someone else's access token. Thus, it might be better just to install this stale bot and go from that. I'm gonna do a PR with some default values for config so we can discuss it there üëç  Awesome! üëä I've opened a PR#1101 with the config, please let me know what do you guys think!

What we need to get this bot running:
- [x] #1101 merged.
- [x] Re-visit issues that might have need a label to not flag it.
- [x] Install the bot & iterate with the feedback.

Is there something I didn't think about? ü§î  That sounds good to me. Thanks for figuring this out!!

On to-do 2, let's wait to add labels until we've iterated on the bot, just
in case we end up not liking it
On Thu, May 25, 2017 at 8:21 AM ≈Åukasz Mr√≥z <notifications@github.com>
wrote:

> I've opened a PR#1101 with the config, please let me know what do you guys
> think!
>
> What we need to get this bot running:
>
>    - #1101 <https://github.com/Moya/Moya/pull/1101> merged.
>    - Re-visit issues that might have need a label to not flag it.
>    - Install the bot & iterate with the feedback.
>
> Is there something I didn't think about? ü§î
>
> ‚Äî
> You are receiving this because you authored the thread.
> Reply to this email directly, view it on GitHub
> <https://github.com/Moya/Moya/issues/1071#issuecomment-304037990>, or mute
> the thread
> <https://github.com/notifications/unsubscribe-auth/ADo1dFodJSG0iR_dKP_AKOVN3RAbcAP6ks5r9Zx2gaJpZM4NQHMU>
> .
>
 I've revisited some issues anyways - I've flagged most of documentation ones to leave it as it is, because it is important that we have these open and add it in the future. If you guys want to make last review, I'm gonna try to launch the bot tomorrow morning or so. @sunshinejr thanks for taking the time! ‚ù§Ô∏è  Bot added - let see how it goes :D Wanted to make a quick summary after a month, but seems like our bot is stuck? Maybe wrong configuration? Anyone sees something strange [here](https://github.com/Moya/Moya/blob/master/.github/stale.yml)? Because in issue like #1056, label was added 28 days ago, which means 14 days ago it should be closed, but it is still open ü§î  @sunshinejr The configuration looks correct to me. Do you think its a permission issue considering it can comment on issues but not close them? 

The link in the `closeComment` looks like it causes a different syntax coloring -- could this be an issue?

EDIT: I created #1157 in case üëç nice catch, @SD10. Can you take care of that issue and see if this PR helped? Because from the permission side it looks like it has everything it needs:
<img width="781" alt="zrzut ekranu 2017-07-03 o 22 23 23" src="https://user-images.githubusercontent.com/5232779/27806997-41992dac-603e-11e7-8be5-e9e05e303948.png">
 @sunshinejr Thanks for checking the permissions. This change is already merged in. It may take some time to determine if this changes anything. There's little and no official documentation on _when_ probot will scan the issues. Some info [here](https://github.com/probot/stale/pull/41) if anyone is interested.

I'll continue watching this until it's resolved. Great, thank you Steven! üçª  I think the problem is with our label having spaces. 
The method used to grab stale issues at probot/stale doesn't wrap the label in quotes when performing the search query to find closable issues. I created a [PR](https://github.com/probot/stale/pull/44) at stale to fix this (if it is the problem üòÖ). @SD10 That's exactly what I was testing https://github.com/pedrovereza/stale-bot-test/issues/2 üòÑ @pedrovereza You read my mind! I was going to ask you to please test this there üëç  @pedrovereza What do you think about changing our label to one without spaces? The support at stale looks limited. I don't think they'll be merging that PR anytime soon. @SD10 I'm ok waiting a bit longer for them to take a look at the PR. But if we decide to change the label, we need to revisit [all the ones currently marked by the bot](https://github.com/Moya/Moya/issues?q=is%3Aissue+is%3Aopen+label%3A%22no+recent+activity%22).

@sunshinejr @AndrewSB @BasThomas thoughts? üòÑ  This should be as easy as changing the name of one label & updating the StaleBot config, correct? If so, and if its gonna fix the bot, I am up for the change üëç I also don't mind waiting few days before we make a change, but seeing from the Issues/PRs it might be quite some time before they merge it. @sunshinejr We would probably have to resolve all the current issues manually. 

Updating a label is an action that will update the last modified date of an issue. Issues that are currently marked as `no recent activity` won't get marked with the new label until 45 days after they were marked with the first label üòê

It would work immediately for all issues not already marked. But if we rename the label to something without spaces, then the update date shouldn't change (since it is the same label object but a different name) and if we change name of the label in the config, the bot should catch that one as well, right? 

For instance, we could change label name to `no-recent-activity` or `no_recent_activity` in both Issues & bot config (until they fix the issue). Or am I missing something obvious here? üòÑ  The API has an "[updated_at](https://developer.github.com/v3/issues/#list-issues-for-a-repository)" for issues. This *might* (?) be updated when a label changes? I'm not sure. We can try changing the label name and bot config, worst case we'll have to close them manually (which was the original plan anyway) üòÑ  Well, we can (probably) make sure it will work! üòÑ 

I've just tested it on my [test repo](https://github.com/sunshinejr/IssuesTest). My steps to reproduce:
1. Create a new label with space, `"new label"`
2. Create an issue with this label.
3. Check `updated_at` field (since from [here](https://github.com/probot/stale/blob/master/lib/stale.js#L41) I understand that it queries based on `updated_at` field). Date: `2017-07-10T15:05:36Z`
4. Rename the label to a label without space, `"new_label"`.
5. Check `updated_at` field again. Date: `2017-07-10T15:05:36Z`, which is the same as before.

_(Note: I was using this [request](https://api.github.com/repos/sunshinejr/issuesTest/issues) to test it.)_

So if the data is correct and I didn't miss anything, whenever we change the label, the `update_at` field of the issue is not updated. Therefore, we can assume we won't need to take care of all the issues above. 

That was fun! üòÑ  I actually think it does the query using the `updated` search qualifier:
i.e) `is:issue is:open updated:>2017-07-10`

I think that PR should've taken effect immediately, so I'm thinking there's a stateful issue.
Regardless, I think that was the right step so let's see how the next marked issue is handled. It looks like probot has stopped slacking off üòÖ. 
I don't know if we want to keep this issue open to discuss the merit of this automation tool or close it now that the bot has completed a full cycle. I'm up for closing this issue now that the bot is finally working :tada:

We originally wanted @MoyaBot to do the job, but I don't think the effort to deploy our own bot is worth it.

@MoyaBot: nothing personal ‚ù§Ô∏è  The issue was created to integrate the bot, and because it is both integrated and working now, there is a reason to close it üòÑ We can create another issue for things related to this bot if something pops up.  

Thanks everyone for feedback & help! üéâ  I saw that over at Fastlane, there's actually another step locking an issue some time after an issue has been closed. Would it be possible to add this as well? And then maybe add another comment before locking that asks to create a new issue? Is that also using probot/stale, @BasThomas? I think we had this conversation here at #1101 and it wasn't possible, but using another plugin could work (though I don't know if we can do it without deploying it). Ah. No, it uses their Fastlanebot. Let's hold off on this for now then; not that important   Hey @zhaoyunyi. Is it still happening? If yes, please provide more code to us. Most valuable would be your `endpointClosure`, `requestClosure`, `plugins` and `.customAlamofireManager()`. Or if you have time, it would be awesome to have a test demo project that this behavior occurs at. I can't say what's wrong without more context, sorry. This issue has been marked as stale because it has not had recent activity. It will be closed if no further activity occurs. 
 This issue has been auto-closed because there hasn't been any activity for 59 days. However, we really appreciate your contribution, so thank you for that! üôè Also, feel free to [open a new issue](https://github.com/Moya/Moya/issues/new) if you still experience this problem üëç.
  Implements #1046 (and #1058).

How to add header fields to a request is a question that shows up in issues every once in a while (e.g. #510, #1003, #208). The answers always mention a custom `endpointClosure` to add the fields to the header request. In fact, [this is suggested in the docs as well](https://github.com/Moya/Moya/blob/master/docs/Endpoints.md#from-target-to-endpoint).

However, having the header fields specified in the `TargetType` makes the whole process easier (and more obvious). Which raises a couple of questions: 

1. Is there any reason for us not to specify header information inside `TargetType`?
2. Is the usage of headers not as common as I think it is and it's better to leave the `endpointClosure` as the official way? Assuming most people don't need to specify headers at all, adding it to `TargetType` just forces an implementation of headers that would return `nil`. 

If we decide to go forward with the change, we still need to:

- [x] Update Changelog
- [x] Update documentation @Moya/contributors Let me know what you think :wink: Loving it, seeing as I've implemented this like, 8x in different projects. Should we add a default of `nil` to the `TargetType`? I think that would make sense, given that most requests currently don't implement this. @justinmakaila Yea, having it defaulting to `nil` makes sense to me. I actually tried that at first, but was having some trouble overriding the value in the tests. Probably missed something, will give it another try üòÑ  ü§î, I remember that we actually didn't want to implemented / default this ourselves. @BasThomas I'd be interested in re-hashing that discussion here; I've had to implement this myself a handful of times and it's particularly annoying. I think it's save to say that MOST private APIs will require some sort of authentication and it seems a little ridiculous to have the `Endpoint` initializer be considerate of state, given that most of the state is already incorporated in `TargetType`. @justinmakaila I think @BasThomas was talking about whether or not we should default `headers` to `nil` üòÑ 

@BasThomas I think the discussion happened in #861 @pedrovereza @BasThomas Ahh, sorry, I misunderstood. I remember the no defaults conversation... I mean, I guess this will get wrapped up in 9.0, so breaking changes are legit... I just got excited and wanted to start using it immediately :) @pedrovereza: love this change, I've also overrode the endpointClosure multiple times for HTTP auth stuff. so I think adding it is a great change

I am against providing a default implementation though, I think it's important forcing consumers of Moya to implement every part of the protocol. Not doing so obfuscates the simplicity of creating a provider (being confused on how to get started with headers, for example).

Even if one isn't planning to use headers (or sampleData, as was mentioned in #861), I think a consumer should still have to explicitly decide what should be returned from them Great, so I think we all agree having no default is better üôå  üëçüèª
On Fri, Apr 28, 2017 at 21:19 Pedro Vereza <notifications@github.com> wrote:

> Great, so I think we all agree having no default is better üôå
>
> ‚Äî
> You are receiving this because you were mentioned.
> Reply to this email directly, view it on GitHub
> <https://github.com/Moya/Moya/pull/1067#issuecomment-298138033>, or mute
> the thread
> <https://github.com/notifications/unsubscribe-auth/ABkCVIW-_GgCRLoLceRrh4B-fEcSnJwmks5r0pAQgaJpZM4NJexz>
> .
>
 why has danger been failing so often on PRs? @AndrewSB We configured it to [fail on missing changelog entries](https://github.com/Moya/Moya/blob/master/Dangerfile#L18) @pedroverrza: can we set danger to have a more descriptive failure?
Or add it as a separate integration, not through circle ci? So danger &
tests can run and be seen independent of one another?
On Sat, Apr 29, 2017 at 4:31 AM Bas Broek <notifications@github.com> wrote:

> *@BasThomas* commented on this pull request.
>
> We should update the docs as well.
>
> ‚Äî
> You are receiving this because you were mentioned.
> Reply to this email directly, view it on GitHub
> <https://github.com/Moya/Moya/pull/1067#pullrequestreview-35494761>, or mute
> the thread
> <https://github.com/notifications/unsubscribe-auth/ADo1dJZf14ZqxPgLMFnbbSxk7Cd6OiPPks5r0x-DgaJpZM4NJexz>
> .
>
 It's possible to run Danger on a separate CI, but Danger also posts a comment using the @MoyaBot with a description of what went wrong (it updates that comment on subsequent runs). Customizing the error message is totally doable, let me know if I can help.  I think I made all the updates needed in the docs. Can someone double check? :wink:  Hey @ivanmkc. I've just tested a similar case, using `RxMoyaProvider`, upload task and `endpointClosure` without any conditional statements, and seems like every time Moya is adding correct parameters. By the code there is also no difference whether you are using `upload` or `request` task, our `request` method will just get the endpoint from `endpointClosure` if there is any. 

I'm gonna close this issue for now, however, if you are certain that this issue exist, please create an example project that I can test against, and reopen the issue.   Just my own opinion: I don't think it's an `extensions` for Moya, it's just a library `Compatible with Moya`. I don't think it's a right place for it. But good work anyway. What does NetClient do? I took a look at the README, but I had trouble seeing why I'd use it over just Alamofire or just Moya. Maybe a section saying "Why would someone use this over just Alamofire"

It seems like a nice piece of work though üëç  I also think this is not an extension to Moya, so unfortunately I'm gonna close this PR. 

However, it doesn't mean we can't include your library in our Readme. Maybe we need to rethink how we promote libraries/extension that work with Moya? For now we have only extensions, how about libraries, projects, abstractions? For instance, [Quick uses wiki](https://github.com/Quick/Quick/wiki), and other libraries may have some ideas for this kind of promoting.

I'm gonna open an issue for that, we'd love it if you could help us with that matter, @alexruperez. Thanks again for the nice work!   Hey, I think what you need was added in #993. The change is targeted to be released in version 9.0 :wink:  @iOSUser110 We still don't have an estimate for when 9.0 will be released, as we're still including some breaking changes to it.

What you can do is use a fork of the Moya repo with a branch pointing to a3f0c526ddaf9c10b8044e5121f6272e06e31c27. You can then update your dependency to use your fork and branch:

Cocoapods:

```ruby
pod 'Moya', :git => 'https://github.com/iOSUser110/Moya.git', :branch => '<your branch>'
```

Carthage:

```ruby
github "iOSUser110/Moya" "<your branch>"
```

Please don't point directly to our `9.0.0-dev` as this branch is under active development and is being constantly rebased (which will change commit hashes and may be not be always stable) @iOSUser110 First you need to fork Moya repo and fetch it locally. Then run these commands inside your fork of Moya:

```
git checkout -b temp a3f0c52
git push origin temp
```

The name of the your branch in this case is `temp`, feel free to name it as you like  @konnorbeard: which error? Did you forget to paste in the message? @konnorbeard Could you try using 7.0.4 and see if the issue still happens? ü§î  @konnorbeard Hm, that's weird. I know you mentioned you're on Swift 2.3, but can you confirm that 7.0.1 won't work as well because it's targeted as 2.2? @konnorbeard Did you find a fix for this? I'm gonna close this issue due inactivity, feel free to reopen with new info. No problem @konnorbeard! Thank you for taking your time to explain what was wrong. It can help someone in the future :)  Hi @geraldeersteling, sorry for the late response. Moya depends on Alamofire in terms of pinning, more on the matter you can see [here](https://github.com/Alamofire/Alamofire/blob/master/README.md#security). After the manager setup you have to assign correct `SessionManager` to the `MoyaProvider` initializer.

Apart from that we have some methods you might be interested in, in [Plugin type](https://github.com/Moya/Moya/blob/master/Sources/Moya/Plugin.swift#L15). If there is nothing you are interested of, maybe you have an idea how to add it to Moya? If yes, please let us know, maybe we can work something out.

Cheers! Wow, thank you for detailed explanation, @geraldeersteling. Glad you figured it out. Good job! üí™  Hey @gmoalvarez. That is a really interesting question. What you can do is to make also one wrapper-class around all the tasks in the pipeline before parsing response. In your case it would be:

```swift
func request(target: Target) {
    return provider
        .request(target)
        .take(1)
        .filterSuccessfulStatusCodes()
        .retry(2)
}
```

and then create multiple classes that do the request & mapping like your `MyClient` class does. It would be then useful in case you want to expand your preparation to request, or tearDown after. E.g. you can see how we can use a quite powerful wrapper with token extractor [here](https://github.com/Moya/Moya/blob/master/docs/Examples/SubclassingProvider.md).

Hope it helps!  I'm declaring a `TargetType` extension. I'm providing parameters for all the items in the enum, but for one of the items, I need the parameters to be return as an array, not a dictionary.

This might explain better:
````swift
var parameters: [String: Any]? {
    switch self {
    case .doSomething(let ArrayOfStrings):
        return ArrayOfStrings
    }
}
````

I'm using `JSONEncoding` and I need to be able to return an array. @gmoalvarez No, I need to return an array, but the variable will only let me return a dictionary object. For example, look at the input that the GitHub API needs: https://developer.github.com/v3/issues/labels/#add-labels-to-an-issue But those are not parameters, right? That's just the URL. @BasThomas Well, if I use `JSONEncoding` for ParameterEncoding, wouldn't the parameters be sent as JSON? Maybe, I'm incorrect. @gmoalvarez Awesome, but just to make sure, if I'm just using dictionary objects rather than an array, can I use JSONEncoding? I think you can use `JSONEncoding` for your parameters in that case, yep!  @jayesh15111988 Yes, let's continue the discussion in #1046 :wink:  Hey @Blackjacx. `NetworkLoggerPlugin` uses `request.debugDescription()` to print the given request. This function is using headers from `request.allHTTPHeaderFields`, but also configuration headers from current Alamofire session. To get them as well, just use the line below:
```swift
let configurationHeaders = provider.manager.session.configuration.httpAdditionalHeaders
let additionalHeaders = response.request?.allHTTPHeaderFields
```

Hope it helps! Yeah, that seems correct. I think we can improve that one. Would you be up for making a PR? :) This issue has been marked as stale because it has not had recent activity. It will be closed if no further activity occurs. 
 This issue has been auto-closed because there hasn't been any activity for 59 days. However, we really appreciate your contribution, so thank you for that! üôè Also, feel free to [open a new issue](https://github.com/Moya/Moya/issues/new) if you still experience this problem üëç.
  @GTMYang: In our implementation, `[String: Any]?` is equivalent to a json array. What type did you want to pass in instead? This issue has been marked as stale because it has not had recent activity. It will be closed if no further activity occurs. 
 This issue has been auto-closed because there hasn't been any activity for 59 days. However, we really appreciate your contribution, so thank you for that! üôè Also, feel free to [open a new issue](https://github.com/Moya/Moya/issues/new) if you still experience this problem üëç.
  Let's get the linting issues fixed, and maybe write some tests. 

Then we can merge this into `optional-response-thread-param`, and continue the discussion on which queue/scheduler primitive to use in #762 Cool, it would be awesome to get those RxSwift tests then! Maybe someone else can add them for ReactiveSwift later.

Things pending before we merge to `optional-response-thread-param`
- [x] write tests for RxSwift
- [x] fix the overriding initializer and change the `MoyaProvider` initializer to take a queue as well So I'm trying to understand... this is the queue that will be used by Alamofire for callbacks as a hook back into Moya, whereas the remaining Scheduler property is in place for delivery of whatever reactive abstraction you use? That's correct @justinmakaila. So then if you're using the vanilla `MoyaProvider`, you pass a thread. But if you're using an `RxMoyaProvider`, you'd pass in the Rx abstraction of a thread - a scheduler, and we want to implement whatever the equivalent is for ReactiveSwift as well.

For rationale and example usage, check out #762 Let's re-examine that assumption: that you can't get a queue from a scheduler.
Schedulers internally use DispatchQueues to do their work ([here's](https://github.com/ReactiveX/RxSwift/blob/master/RxSwift/Schedulers/MainScheduler.swift#L23) how the MainScheduler uses a queue).

Let's make an issue on RxSwift's repo asking if theres any way to grab it, since right now, it is private Yeah I agree. The queue passed to Alamofire doesn't necessarily have to be the same one as our Reactive `Scheduler`, all that really matters is that we provide this init option so people can move their request building/handling off of the main queue and into a dedicated background queue (if desired). @haritowa: yeah, CI failed because there's no changelog for this. We're working on making that more clear to contributors.

For now, can you just add an entry to the changelog, and then we can see how the tests do? I got really busy with work, sorry about that @haritowa!  I'm wondering whether the parameter name `queue` isn't too vague and if e.g. `callbackQueue` wouldn't help with recognizing for what exactly is this queue used. Thoughts?  Cool! What do you guys think @AndrewSB, @justinmakaila? Yes, I think `callbackQueue` is a better name. It takes away any ambiguity.

@haritowa, do you think we can improve the `queue` parameter in the `request` method as well? What do you think is a better option? The CI failure is legit, seems like `RxSwiftMoyaProviderTests`needs a second review üòÑ  that was broken by me -- I'll fix it now. Sorry!

I prefer callbackQueue too Seems like @AndrewSB fixed the build! Now the only things to do before the merge: 
- Fix the **Chanelog.md** conflicts (basically add the new line to **Next** column instead of **8.0.4**, because **8.0.4** was released)
- Change the name of `queue` to `callbackQueue` (wherever we can)

Does that seem right? üòÑ yup, that does! Then we can figure out docs and usage instructions in #762  @haritowa Are these two points, that I wrote above, something you have time to do in the near future? If not, I might try to help :) @sunshinejr @AndrewSB @haritowa I fixed the conflict in the changelog (used Github web interface to do it, that's why the commit message is bad üòï )

Does it make sense to merge this PR into `optional-response-thread-param` and take the `queue` renaming (and docs) in #762? ü§î  I think so üëç Probably in another PR tho, that would point to `optional-response-thread-param`. But I'm in. Yeah, lets merge this into `optional-response-thread-param`, and then do another PR also targeted to `optional-response-thread-param` that handles the renaming and docs üëå  Thanks a lot for contributing to Moya! I've invited you to join the Moya GitHub organization ‚Äì no pressure to accept! If you'd like more information on what that means, check out our [contributor guidelines](https://github.com/Moya/contributors) and feel free to reach out with any questions.  Hey @balancin, this looks like more of an [`Argo`](https://github.com/thoughtbot/Argo) question, asking the people over at [`Moya-Argo`](https://github.com/wattson12/Moya-Argo) may also yield good results.
Sorry I can't be more helpful! I haven't used Argo for a while üòï  Fixes #1049 

When a `TargetType`'s `path` is empty, `URL.appendingPathComponent` may introduce trailing `/`, which may not be wanted.

From the [docs](https://developer.apple.com/reference/foundation/url/1780239-appendingpathcomponent): 
> This function performs a file system operation to determine if the path component is a directory. If so, it will append a trailing /. If you know in advance that the path component is a directory or not, then use func appendingPathComponent(_:isDirectory:).

Using `appendingPathComponent(_:isDirectory:)` doesn't seem to solve the problem (note `somepath/?`)

```swift
import Foundation

let urlString = "https://google.com/123/somepath?X-ABC-Asd=123"
let url = URL(string: urlString)!

url.absoluteString //"https://google.com/123/somepath?X-ABC-Asd=123"
url.appendingPathComponent("").absoluteString //"https://google.com/123/somepath/?X-ABC-Asd=123"
url.appendingPathComponent("", isDirectory: false).absoluteString //"https://google.com/123/somepath/?X-ABC-Asd=123"
```

I think that having an empty `path` is not usual, but as seen in #1049 it may be necessary. These changes shouldn't cause side effects for non-empty `path`s. awesome job @pedrovereza üòÑ  Wouldn't this be a breaking change? @BasThomas Feels like a bug fix to me. I think the expectation when `path` is empty is that the `baseURL` will be used unchanged (which was not happening).

Do you feel it's a breaking change? If so, why? Yes, it's a bugfix, but the "buggy" behavior may be (?) expected. And if that would be the case, this would change that expectation. I see, you're saying that someone may be relying on this buggy behavior for something. But I'd say there are probably workarounds to avoid the issue ü§î 

I'd still not call it a breaking change as the API contract has not changed, and the current behavior seems odd and probably is not expected.

@AndrewSB @sunshinejr thoughts on that? I'd say not breaking. It's a bug fix

On Mon, Apr 17, 2017 at 7:31 AM Pedro Vereza <notifications@github.com>
wrote:

> I see, you're saying that someone may be relying on this buggy behavior
> for something. But I'd say there are probably workarounds to avoid the
> issue ü§î
>
> I'd still not call it a breaking change as the API contract has not
> changed, and the current behavior seems odd and probably is not expected.
>
> @AndrewSB <https://github.com/AndrewSB> @sunshinejr
> <https://github.com/sunshinejr> thoughts on that?
>
> ‚Äî
> You are receiving this because you were mentioned.
>
>
> Reply to this email directly, view it on GitHub
> <https://github.com/Moya/Moya/pull/1053#issuecomment-294496325>, or mute
> the thread
> <https://github.com/notifications/unsubscribe-auth/ADo1dBfs_efXVlVvG6cW74L0tqBCyUOGks5rw3eugaJpZM4M-fqL>
> .
>
 Sure, let's treat this as a bugfix then. üòÉ  I'm trying to create an `TargetType` extension, but I keep getting an error: `Use of undeclared type 'foo'`

````swift
extension GitHub: TargetType {
}
```` I forgot about declaring the enum.  Can you run it on a simulator? If you can, can you check if other projects run on your iPhone? @myafer: line 19 that's highlighted in your project doesn't show up in our Repo (`NetworkTarget` doesn't exist, [here's](https://github.com/Moya/Moya/blob/8.0.3/Demo/Demo/ViewController.swift#L15) that file on our repo). Maybe you added that line by mistake?

I'd recommend
1. deleting derived data
2. deleting the Moya/ directory and recloning from GitHub Since there is no activity in that matter, I'm gonna close this issue. Feel free to reopen if this error occurs again.  It's possible in theory. We'd need to implement what people talked about in #556: basically abstract out the network engine to not just use Alamofire

We'd be open to a PR that does this, and theres a chance some other contributors might be interested in helping out üòÑ   Hey @k8mil, can you check if it works as expected when you change your `baseURL` to be just https://google.com and `path` to return `/123/somepath?X-ABC-Asd=123`? Hey @k8mil thanks for the detailed explanation and examples üëç 

I think I have a fix in #1053, care to take a look? üòâ  Very interesting use case. Thanks for implementing this @pedrovereza üòÑ   Hey @haritowa: I'm not sure I totally understand your question, but it sounds like youre looking for something similar to #1032. If that's the case, we have #762, and we'd love your help üòÑ  That all sounds good to me @haritowa: it makes sense to be able to do that on a `provider`-basis and `request`-basis üòÑ 

You're right, we need to add this to both RxMoya & ReactiveMoya.

Scheduler is an Rx concept, its just an abstraction on queues and (for all intents and purposes here) can be thought as equivalent to queues.


I'd be more than happy to review a PR üëç this is something I've wanted for a while too No worries @haritowa - take your time. üòÉ   Hey @douglastaquary thanks for sharing your solution, this may be useful for others as well!

Cheers from Brazil üòâ   @EvilNOP Thanks for raising the idea üôå  I've created #1067 with an initial implementation for `headers` inside `TargetType`. Feel free to review it and let us know what you think üòâ   Implemented in #1067  Thanks a lot for contributing to Moya! I've invited you to join the Moya GitHub organization ‚Äì no pressure to accept! If you'd like more information on what that means, check out our [contributor guidelines](https://github.com/Moya/contributors) and feel free to reach out with any questions.  Nice! That was easy. Can you add this to the Changelog as well?

By the way, thanks for the really clear description. Greatly appreciated! :) ü§î, you should change the initializer as well, I think. Why are we targeting this at `9.0.0`, actually? Is this breaking in any way? @AndrewSB @juliengdt Well, it seems like it *is* a breaking change (see failed tests). Could you update them as well, @juliengdt? It technically is breaking though, is it not? The `Response` class is not private and can be instantiated by the user (just like we did in the tests). Yep, as @BasThomas said, it is a breaking change, thus making it obvious in Changelog would be awesome :) Agreed on tagging this as a breaking change

@juliengdt Good job and thanks for the contribution! Thanks a lot for contributing to Moya! I've invited you to join the Moya GitHub organization ‚Äì no pressure to accept! If you'd like more information on what that means, check out our [contributor guidelines](https://github.com/Moya/contributors) and feel free to reach out with any questions.  This attempts to fix #1039 

Let's see if CI passes on this commit Getting different errors! This looks like progress.

It seems as if Swift 3.1 the _non breaking_ update, broke our tests. Right now, I can see that our `NetworkLoggerPlugin.init` calls in our tests are broken.

<img width="1403" alt="screen shot 2017-04-03 at 5 59 59 pm" src="https://cloud.githubusercontent.com/assets/3814772/24637615/618865fe-1897-11e7-8dfa-54ec6824ed03.png">

The compiler error looks like it's related to the `output` param in the initializer.

```swift
public init(verbose: Bool = false, cURL: Bool = false, output: @escaping (_ separator: String, _ terminator: String, _ items: Any...) -> Void = NetworkLoggerPlugin.reversedPrint, responseDataFormatter: ((Data) -> (Data))? = nil) {
        self.cURL = cURL
        self.isVerbose = verbose
        self.output = output
        self.responseDataFormatter = responseDataFormatter
}
```

The definition says its expecting `output: @escaping (_ separator: String, _ terminator: String, _ items: Any...) -> Void`, but our initializer is just taking one param (`printing` in the screenshot), from the closure, and incorrectly not handling the other ones.

Does anyone who's more familiar with the `NetworkLoggerPlugin` or these tests know why that may be?

Feel free to take a shot at adding a commit onto this branch if you know how to fix the tests üòÑ
Make sure you're running Xcode 8.3! @AndrewSB Good job! I almost got it right in https://github.com/Moya/Moya/commit/eefcf600139ed8fb787d5c936c0277fc024902ad, but only updated the dependencies I thought were causing the issue üòÑ 

And I'd say we can skip the unused arguments in the closure. Actually, I was hopping that `_, _, printing` would do the trick, but [it didn't](https://circleci.com/gh/Moya/Moya/1338) and I'm not sure why ü§î  That was a good move @pedrovereza

Yeah, I thought that was really strange too- why weren't we `_, _`ing those params previously?

I just don't know much about that piece of the codebase, so I was hoping another contributor could jump in and enlighten us üòõ @AndrewSB Ok, so it seems like `printing` actually groups all arguments

![image](https://cloud.githubusercontent.com/assets/1916041/24640599/8abbe40a-18ce-11e7-8c6e-daa2e470f9ac.png)

In fact, the `Any...` argument is accessed as `printing.2` in the test. I didn't know it was possible and (in the very quick search I did) could not find references about this feature.

Doesn't fix the problem but at least we know why it worked üòÑ 
 Maybe a stupid question, but how do I run the tests from Xcode now? Can't seem to do so from the Demo project, and opening the framework's `xcodeproj` complains of `Alamofire` missing (which makes sense, right?) Also, though this should probably be tackled in another PR, updating the dependencies causes a bunch of warnings in the Demo project. Pedro: what scares me is that previously we just had `printing`, and from what I can infer from the contents of the test, it looks like it was an array, not a tuple (with three elements).
I'll do a git blame and figure out who wrote those tests when I'm back on a computer tonight- to ask the OG author what they think we should do


Bas: command-U when you're on one of the Moya targets should run the tests > and from what I can infer from the contents of the test, it looks like it was an array, not a tuple (with three elements).

I think it was a tuple ü§î 

```swift
 let stringArray: [String] = printing.2.map { $0 as? String }.flatMap { $0 }
```
Isn't `printing.2` returning the third argument (the array of `Any`)?

But you're right, if we can find who wrote the test just to confirm the intention it'd be better üëç  Ohh, I missed that.

If that's how the tests are, then I feel pretty confident with just
continuing as we were
I wonder why the tests regressed with swift 3.1 then ü§î
On Tue, Apr 4, 2017 at 2:14 PM Pedro Vereza <notifications@github.com>
wrote:

> and from what I can infer from the contents of the test, it looks like it
> was an array, not a tuple (with three elements).
>
> I think it was a tuple ü§î
>
>  let stringArray: [String] = printing.2.map { $0 as? String }.flatMap { $0 }
>
> Isn't printing.2 returning the third argument (the array of Any)?
>
> But you're right, if we can find who wrote the test just to confirm the
> intention it'd be better üëç
>
> ‚Äî
> You are receiving this because you were mentioned.
> Reply to this email directly, view it on GitHub
> <https://github.com/Moya/Moya/pull/1043#issuecomment-291633764>, or mute
> the thread
> <https://github.com/notifications/unsubscribe-auth/ADo1dPI8DCIbGqSG-7nfLOUE0za4HRi_ks5rsrKLgaJpZM4MyPC7>
> .
>
 @AndrewSB: Ah, but that is then complaining of Alamofire not being there. Which gives me an error, and cancels the tests. @BasThomas what's the complaint? Saw this PR had been sitting here for a bit, so I tried to see if I could help out.

Currently the syntax looks like this:
```swift
plugin = NetworkLoggerPlugin(verbose: true, output: { printing in
  let stringArray: [String] = printing.2.map { $0 as? String }.flatMap { $0 }
  ...
})
```
To reach the same functionality this will work:
```swift 
plugin = NetworkLoggerPlugin(verbose: true, output: { (_, _, printing: Any...) in
  let stringArray: [String] = printing.map { $0 as? String }.flatMap { $0 }
  ...
})
```
Hope this helps! @BenEmdon Awesome! I totally missed the `printing:` part üòÑ 

Do you feel like pushing a commit with this fix on branch `fix-carthage-ci-fail`? üòâ  @pedrovereza sure! üôåüëè great teamwork, thanks for the fix!  ### Resolves the following SwiftLint issues:

<img width="798" alt="screen shot 2017-04-03 at 1 40 47 pm" src="https://cloud.githubusercontent.com/assets/11095731/24622503/43d87522-1873-11e7-9e80-fa3cf0f17b25.png">

Just thought Id clean it up because it's spamming everyone's PRs üòÑ  This change doesn't affect any functionality. Does something still need to be added to the changelog? Nah, I think you're good @BenEmdon. Thank you again! üéâ 

**Also,** sorry @sendyhalim for clicking on you, didn't see that _"reviewers suggestions"_ popup before üòÖ  Fixes link to [`Code of Conduct.md`](https://github.com/Moya/contributors/blob/master/Code%20of%20Conduct.md) by replacing the spaces in url with [url encoded characters](https://www.w3schools.com/tags/ref_urlencode.asp). Hey @BenEmdon! Thanks for the changes! üéâ
These warnings do not have anything to do with this PR so I'm gonna merge this anyways :) Thanks a lot for contributing to Moya! I've invited you to join the Moya GitHub organization ‚Äì no pressure to accept! If you'd like more information on what that means, check out our [contributor guidelines](https://github.com/Moya/contributors) and feel free to reach out with any questions.  This seems like a good idea to me @juliengdt! Do you want to try branching off `9.0.0-dev` and implementing the change? No pressure if you're not comfortable with that üòÑ 

The two potential hurdles I see are
1. We're currently grabbing the `URLResponse` from Alamofire, does Alamofire expose a `HTTPURLResponse` as well?
2. Some small difference b/w URLResponse and HTTPURLResponse that makes the latter unusable for some reason we haven't thought off yet

We can get a couple of reviewers on the PR to validate that its a good idea, and if they agree, we'd be more than happy to merge this in üëç  Seems like Alamofire does give us an `HTTPURLResponse`. üòÉ https://github.com/Moya/Moya/blob/master/Sources/Moya/MoyaProvider.swift#L147 üëä
Awesome!
On Tue, Apr 4, 2017 at 2:20 AM JulienGdt <notifications@github.com> wrote:

> I edit the issue + did the PR.
>
> ‚Äî
> You are receiving this because you commented.
> Reply to this email directly, view it on GitHub
> <https://github.com/Moya/Moya/issues/1040#issuecomment-291442898>, or mute
> the thread
> <https://github.com/notifications/unsubscribe-auth/ADo1dFQDo2gyamQ09CE1zGIYc8nqEmFvks5rsgtagaJpZM4Mxspi>
> .
>
 As it has been implemented, yep!

Thanks again :)  If you initialize your `NetworkLoggerPlugin`, its `cURL` flag is set to `false` by default. Initializing it like `NetworkLoggerPlugin(cURL: true)`, `willSendRequest` should print the `cURL`. Does that help? Cool, thanks @BasThomas I'll close the issue :wink:   I don't think Moya can build on Linux, even the Alamofire can't build yet. https://github.com/Alamofire/Alamofire/issues/1935 Because there is no official network request framework for swift in Linux yet. The swift server-side group still not coding anything yet.  Hey @LarsJK! Thanks for the changes! üéâ 
These warning doesn't have anything to do with this PR so I'm gonna merge this anyways :)  Thanks a lot for contributing to Moya! I've invited you to join the Moya GitHub organization ‚Äì no pressure to accept! If you'd like more information on what that means, check out our [contributor guidelines](https://github.com/Moya/contributors) and feel free to reach out with any questions. Nice, thanks @LarsJK!  Hey @Blackjacx, awesome to see that you're thinking about doing some local validation before hitting the network üëå

I've used www.GitHub.com/Ben-G/Validated in the past to great effect. Basically I create a `PhoneNumber` type and I change my parameter type to be a `PhoneNumber` (`case validatePhoneNumber(number: PhoneNumber)`)  Hey @lizhihui0215 , unfortunately Swift enums do not support inheritance. From [the docs](https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Inheritance.html#), highlight by me:

> A class can inherit methods, properties, and other characteristics from another class. When one class inherits from another, the inheriting class is known as a subclass, and the class it inherits from is known as its superclass. **Inheritance is a fundamental behavior that differentiates classes from other types in Swift**.

[This answer on StackOverflow](http://stackoverflow.com/a/40823730) that may be helpful @lizhihui0215: yes, but its not the most user friendly. Check out this issue on Result: https://github.com/antitypical/Result/issues/76, and make sure you also read the discussion they link off to in `LlamaKit`.

Come back here if you're still trying to figure out how to compose your own error type that augments `MoyaError` I think this should be resolved, if there are still questions about this topic, please feel free to reopen whenever.  So happy you've made this issue! This is a feature we were looking to implement for RxMoya. Here's the pull request: https://github.com/Moya/Moya/pull/762

Let me know if you have any other questions, or if you're interested in implementing the functionality we're missing üòÑ  Let's continue discussion for this on #762, closing this for now  - Convert project to single schema target.
- Update deps for better swift 3.1 support.

Fix #818 What does this do over #967? @BasThomas theoretically not much, the purpose is the same, but in this case i converted manually, without script.

Also i updated the dependencies for better compatibility with Swift 3.1 and remove some deprecation warnings... Demo was updated too.

This PR is target to 9.0.0 I think we can take the deprecation warning in master, as it's not a breaking change. We actually have #1027 to do it :wink:

I also think that converting to a single scheme is not a breaking change and we should take it in master (which makes me think that we should continue #967 instead).

The dependencies update is good, but is it a breaking change? If not, I'd vote for merging into master so we can release it before 9.0 Closed in favor of #967   Hey @iballan could you provide more details on how you're encoding the parameters in the URL? Are you trying to send parameters in the URL and in the request body as well?

It'd be great if you could share some code that illustrates the issue :wink: @iballan Can you change your implementation of `path` to be:

```swift
 var path : String {
        switch self {
        case .products(let id_category): 
            return "products"
        }
    }
```

and `parameterEncoding` to:

```swift
var parameterEncoding: ParameterEncoding {
	    switch self {
	        case .products:
	            return URLEncoding.default
	        default:
	            return JSONEncoding.default 
	    }
    }
```

These changes will leave your code similar to the example we have in the [docs](https://github.com/Moya/Moya/blob/master/docs/Examples/Basic.md) on how to send parameters in the URL when doing a POST request (see `.updateUser`)

 This issue has been marked as stale because it has not had recent activity. It will be closed if no further activity occurs. 
 Hey @iballan, we recently noticed that the documentation I pointed you to was wrong (we fixed in #1120). üòÖ 

Could you try using `URLEncoding.queryString` instead of `default`? I have set up an [example on how to send parameters in the URL using POST](https://github.com/pedrovereza/MoyaCarthage/blob/master/MoyaCarthage/ViewController.swift). Can you try this one out and make sure it works for you? ü§î   Are you implementing an optimistic UI (i.e. you're going to show an update has _succeeded_ before it actually comes back from the network)? If so, moving your network requests into a separate queue will make it very hard to tie back server validation/network failures back to the original callee (from my experience, YMMV).

I'd recommend instead when your user edits/adds item A, you do

```swift 
func updateA(newA: AType) -> Observable<AType> {
  return Observable.concat([
    saveDataToRealm(newA),
    saveDataToNetwork(newA)
  ])
}
```

and what will happen is, first your data will be saved to Realm, on completion of that, you'll get a `.next` even from your `updateA()` observable, and simultaneously your network request will kick off. At this point, you can update your UI to be optimistically successful. (hundreds of) Milliseconds later you should get back the second network request, which will show itself is a `.next`and `.complete`, where you can now make the optimistic success an actual success.
Also, if there was an error, you'd be able to handle the error at the callsite, instead of trying to associate it back to the callsite from your queue

So you call `updateA()`, you get
```
.next(realm)
.next(network)
.complete
```

There is the chance for a race condition though, but you should be returned the latest model from the network in `updateA()`. So as long as your UI uses that as the source of truth, your user will be able to see the race condition and fix it

So, I'm not sure this was the answer you were looking for, just another approach Hmm, yeah, if I understand what you're doing, yes. More or less.

What I would do is just mark that entity as having a pending sync in Realm, (and then have a background process that periodically goes and tries to upload pending syncs), like you said üòÑ 

If you save that request (in memory) to a list of requests to be retried once the network has been established, you may run into some non deterministic behavior, either by sending the sync multiple times (one from the realm background process, another from the in memory queue waiting for network reconnection), or risk dropping the queue from in memory if the app is quit before you persist to realm.

I'd recommend just going the persistent save + background processing route, and maybe even building a custom `OfflineSync` class that handles all your network requests if your app relies heavily on offline syncing  üòÑ  Hey @camcoding, take a look at #980. @scottrhoyt gave some ideas on how to change the `baseURL` dynamically @camcoding My first impression was that you could use the basic logic of #980 to achieve what you need, because in #980 the steps are:

1 - Make a request to a `baseURL`
2 - Extract the next `baseURL` from the response of the first call
3 - Use the extracted url as `baseURL` for the second request

And this could go on for several requests.

For your scenario, I'm assuming you can first try the local home address (which should fail when the user is remote):

1 - Make a request to `baseURL` using the local address
2 - If the request fail, switch `baseURL` to the remote address and make the request again

Once you know where the user is (home vs remote), you could probably store this information in your app and avoid making two requests every time if they are remote, and just make it once a while to check if they changed location.

Does that make sense in your case? @camcoding Can you  write a custom provider that subclasses `RxMoyaProvider`  and implement the logic in the custom provider? ü§î 

I'm not too familiar with RxSwift, but if this approach is not too complicated (or impossible), you'd get the logic nicely wrapped in a single place :wink:  In #978 you can see some ideas to have dynamic urls... I made a quick poc with the subtarget protocol and the dynamic provider... Maybe we can integrate that functionality in 9.0.0... WDYT? Yup, #978 should have a solution, if you're still having issues @camcoding, reopen this and we'd be happy to help üëç   Fixes #1018 

Our podspec claims we can take any version of ReactiveSwift equal or greater than 1.0. 
ReactiveSwift deprecated `DateSchedulerProtocol` in 1.1, which caused warnings when linting our pod.

Output of `pod lib lint`:

```
    - WARN  | [Moya/ReactiveCocoa,Moya/ReactiveSwift] xcodebuild:  Moya/Sources/ReactiveMoya/ReactiveSwiftMoyaProvider.swift:9:32: warning: 'DateSchedulerProtocol' is deprecated: renamed to 'DateScheduler'
    - NOTE  | [Moya/ReactiveCocoa,Moya/ReactiveSwift] xcodebuild:  Moya/Sources/ReactiveMoya/ReactiveSwiftMoyaProvider.swift:9:32: note: use 'DateScheduler' instead
    - WARN  | [Moya/ReactiveCocoa,Moya/ReactiveSwift] xcodebuild:  Moya/Sources/ReactiveMoya/ReactiveSwiftMoyaProvider.swift:15:60: warning: 'DateSchedulerProtocol' is deprecated: renamed to 'DateScheduler'
    - NOTE  | [Moya/ReactiveCocoa,Moya/ReactiveSwift] xcodebuild:  Moya/Sources/ReactiveMoya/ReactiveSwiftMoyaProvider.swift:15:60: note: use 'DateScheduler' instead
````

This PR replaces the usage of `DateSchedulerProtocol` with `DateScheduler` and bumps the minimum version of ReactiveSwift to 1.1

I wasn't sure if this requires a change in `Package.swift`, as I feel that adding a `minorVersion` would pin the dependency to that minor (as in, not as a minimum version, but that version exactly). Is that correct? ü§î 
 @pedrovereza from [swift.org](https://swift.org/package-manager/#example-usage):

```swift
import PackageDescription

let package = Package(
    name: "DeckOfPlayingCards",
    targets: [],
    dependencies: [
        .Package(url: "https://github.com/apple/example-package-fisheryates.git",
                 majorVersion: 1),
        .Package(url: "https://github.com/apple/example-package-playingcard.git",
                 majorVersion: 1),
    ]
)
```

> Each dependency specifies a source URL and version requirements. The source URL is a URL accessible to the current user that resolves to a Git repository. The version requirements, which follow Semantic Versioning (SemVer) conventions, are used to determine which Git tag to check out and use to build the dependency. The version requirements, which follow Semantic Versioning (SemVer) conventions, are used to determine which Git tag to check out and use to build the dependency. For of both the FisherYates and PlayingCard dependencies, **the most recent version with major version equal to 1 (for example, 1.0.0) will be used.**

That being sad I think it is safe to assume we don't _need_ to update our Package.swift file.  @sunshinejr thanks for merging! Also, we're having some issues with the build, check #1039 :wink:  Can you give us a code example? @Moya/contributors, can anyone take a look at this? Might this be a bug with our Reactive implementation?  Can you please post your Podfile and its [dependency graph](https://github.com/CocoaPods/CocoaPods/issues/3611#issuecomment-106081707)? What if you only add `pod Moya`, removing Alamofire? Alamofire is included with Moya. And what is your deployment target in Xcode?  Could you provide an api sample? Closing this due to inactivity, please come back if you're still having issues @iOSUser110! We'd love to help get this working for you üòÑ   Yes, that's possible! Have a look at the [providers docs](https://github.com/Moya/Moya/blob/cb99411423b6e9b292f9f238bef1969f406793ff/docs/Providers.md#providers):

> That's it! The `request()` method returns a `Cancellable`, which has only one public function, `cancel()`, which you can use to cancel the request. @nguyentrai2011 You could store the request_1 like
```swift
let request_1 = MoyaRequestXXXXX
```
then before you call request_2 call, just call `request_1.cancel()`. 
You also can add the request into an array. Then before you make new request, just use `requestArray.forEach({ $0.cancel() })`. @BasThomas Is the SessionManager can make a better solution for this situation? Unfortunately, I don't know. If you need it rather universal, meaning that at any moment in the app, only 1 request can be fired up at once, you would need to implement your own logic for that, using e.g. `OperationQueue`. 

However, if you want it for only one, special case, you could make use of `requestClosure`. You could fire up `request_1` in that closure with a check that you are firing `request_2`. Now based on the response from `request_1`, you can decide whether `request_2` should be performed or not using [this closure](https://github.com/Moya/Moya/blob/master/Sources/Moya/MoyaProvider.swift#L34). Unfortunately this way you probably can't propagate the response from `request_1` easily and thus this is a workaround.  Would you like the user of your app to retry the request? You can show an alert for them to do so yourself when a request has failed. Also, if you're using ReactiveMoya/RxMoya, they both include built in ways of retry failed requests You should be able to use Reactive / Rx just for the retrying part, no need to use it in your app as a whole. :)  change from
```swift
let WebServiceProvider = MoyaProvider(plugins: [NetworkLoggerPlugin(verbose: true, responseDataFormatter: JSONResponseDataFormatter)])
```
to
```swift
let endpointClosure = { (target: ShopperPlusAPI) -> Endpoint<ShopperPlusAPI> in
    let headers = [] // change this as you need
    let defaultEndpoint = MoyaProvider.defaultEndpointMapping(for: target)
    return defaultEndpoint
        .adding(newHTTPHeaderFields: headers)
}
let WebServiceProvider = MoyaProvider(endpointClosure: SPProvider.endpointClosure, plugins: [NetworkLoggerPlugin(verbose: true, responseDataFormatter: JSONResponseDataFormatter)])
```
 I'm gonna close this issue due to inactivity, but feel free to reopen whenever.  Continues #1016 as we had some issues merging the original branch with `9.0.0-dev` @AndrewSB Is it worth adding in the changelog that we bumped the minimum version of RxSwift to 3.3? ü§î  Yeah, I guess that wouldn't hurt. I went ahead and added it. @BasThomas Thanks! üëç  Ugh, that Swiftlint issue... what's their reasoning behind that? I think `let _ =` is better than `!= nil`. Thoughts? Doing `let _ =` is just a way to check if an `Optional` value is `nil` or not. I personally prefer `!= nil` because the check is obvious.

This is not a strong opinion so I'm ok with whichever we agree to use :wink: ü§î. I think both are equally obvious, and like `let _ =` for looking cleaner (imho). Let's deal with it later. Don't think its that important right now. FWIW, the Swiftlint rule is `unused_optional_binding`. Once again thanks for fixing the merging issues @pedrovereza! üéâ Yeah, thanks a bunch @Pedrovereza!
On Fri, Mar 24, 2017 at 8:27 AM Bas Broek <notifications@github.com> wrote:

> Once again thanks for fixing the merging issues @pedrovereza
> <https://github.com/pedrovereza>! üéâ
>
> ‚Äî
> You are receiving this because you were mentioned.
> Reply to this email directly, view it on GitHub
> <https://github.com/Moya/Moya/pull/1020#issuecomment-289055097>, or mute
> the thread
> <https://github.com/notifications/unsubscribe-auth/ADo1dLLl3Onm14sXQFTCxDgQu7PBK5YWks5ro-DrgaJpZM4MlpGj>
> .
>
 @pedrovereza thanks for this! I think maybe this extension also has to be modified? https://github.com/Moya/Moya/blob/master/Sources/RxMoya/Observable%2BResponse.swift @scottrhoyt I think you're right ü§î 

@AndrewSB Did we miss the extension @scottrhoyt pointed out or is there a reason to keep returning `Observable`? @scottrhoyt: thanks for catching that!

Here's what I think: the functions in `Observable+Response.swift` are extensions on any type of `Observable<Response>`. I think it's totally valid to have a producer that sends multiple `.next` events to an `Observable<Response>` (for example, I could have a request processor, which is of type `Observable<Response>`, through which I pass every single response that goes through my client).

I thought it best not to assume that _every_ `Observable<Response>` should be constrained to `Single`, and that's a choice a consumer of this library should make, by doing `.asSingle()` after using one of the operators Ok I understand that intention. Should we duplicate this as an extension on `PrimitiveType` too so that users can still do something like:

```swift
provider.request(.myRepos)
  .filterSuccessfulStatusCodes()
  .subscribe()
  .disposed(by: disposeBag)
```

Or would the recommended approach be to do:

```swift
provider.request(.myRepos)
  .asObservable()
  .filterSuccessfulStatusCodes()
  .asSingle()
  .subscribe()
  .disposed(by: disposeBag)
```

? I see your pain point. We should also probably extend Single to have the same functions. I wonder if theres a common superclass/protocol we could extend? I'm not sure how the Rx project does it.

I'll look into doing a common extension tomorrow, but feel free to give it a shot as well üòÑ  Oh, just noticed that you know what the superclass is - `PrimitiveType`

Yes, lets make them functions on that  Thanks a lot for contributing to Moya! I've invited you to join the Moya GitHub organization ‚Äì no pressure to accept! If you'd like more information on what that means, check out our [contributor guidelines](https://github.com/Moya/contributors) and feel free to reach out with any questions. Thanks! üéâ  @evermeer Thanks for pointing that out! We'd be happy if you could send us a PR with the fix :wink: I'll hit it, it's a two second fix @pedrovereza @evermeer Pulling master from here and using the specified dependencies via the Cartfile and Podfile, I'm seeing that we're not using a version of ReactiveSwift that has the `DateSchedulerProtocol` deprecation. Are you perhaps pointing to the master of ReactiveSwift? @justinmakaila running `pod lib lint` shows the warning for me.  We had an acidental merge of `9.0.0-dev` into `master`, which caused #993 to be merged in `master` (see #1013). However, as #993 had to be reverted in `master` (#1015), merging `master` into `9.0.0-dev` takes the revert of #993 as well.

This PR is the result of merging `master` into `9.0.0-dev`, cherry-picking 249e436ab1c32f212a195afbe411fe5234aba81f and fixing the entry in the changelog. Thanks for fixing this, @pedrovereza. This looks good. Thanks @pedrovereza  Implements #1011, and changes the signature of RxMoyaProvider.request to return a `Single<Response>` instead of an `Observable<Response>`.

cc/ @andreyfel @damienrambout: would love both of you to sign off on this before it's merged in This is breaking and should go in `9.0.0` and not master, right? Also, some Cocoapods package versions don't match up with Cartfile anymore. @BasThomas: In its current state, it is breaking, retargeted to `9.0.0-dev`. Can you match the Cocoapods package versions that I missed?

@andreyfel: I don't know if adding another choice to a very simple module is a smart idea long-term. I feel as though we should either stick with Observable and not make this change, or embrace RxSwift's new semantics and publish Single. But not try to solve both inelegantly
After understanding the change, the easy path to migrate to the new RxMoya syntax will simply be for a consumer to extend `RxMoyaProvider` and supply a method that returns an `Observable<Response>`, which `.asObservable()`'s the new `RxMoyaProvider.request` I think we should first deal with #1013 (which is also reverting #993) @AndrewSB please rebase @AndrewSB can you rebase against `9.0.0-dev` and reapply your changes? (See #1017) :wink: All rebased! cc/ @gperdomor can you approve?
Also, @andreyfel, if you have any thoughts following up on what I said above , that would be awesome

I need to fix a couple tests to get CI passing, working on them soon üòÑ  #993 is still reverted in this PR @gperdomor @AndrewSB Hey, I fixed the branch by cherry-picking all changes on top of `9.0.0-dev`: https://github.com/Moya/Moya/commits/observable-single-9.0

We can:

1 - Open a new PR from that branch
2 - Push force to `observable-single`, meaning everyone will have to delete the branch locally and fetch again (but we keep this PR)

I'm ok either way üòÑ  Option 1 is more cleaner i guess I'm not a user of RxSwift, but just cruising through their API (you know, trying to form an educated opinion), it looks like `Single<MoyaResponse>` IS the most analogous structure to represent a network request, unless the request is repeating, in which case, `Observable` would make sense. In the case of a repeating request however, it should be on the developer to format their signal in that way.

Realistically, I don't think we should not embrace this change just because our API already utilizes `Observable`, but rather note it as a breaking change and release.

Forcing people to make changes to existing code bases to implement the best practices from one of our dependencies for a new version should be expected, and as @AndrewSB mentioned, you can just add `asObservable()` if you're a client who wants to continue to use `Observable`. Thank you for sharing your thoughts @justinmakaila!

@pedrovereza: I'm lazy, and I don't see the harm in #2, but feel free to go ahead with whichever one makes you more comfortable @BasThomas @AndrewSB @gperdomor @justinmakaila @andreyfel 
Hey I created #1020 to avoid more branch issues. Please continue the discussion in that PR and use branch `observable-single-9.0` for new additions. I'll delete `observable-single`to avoid confusions :wink: Thanks Pedro üòä
On Wed, Mar 22, 2017 at 11:34 AM Pedro Vereza <notifications@github.com>
wrote:

> Closed #1016 <https://github.com/Moya/Moya/pull/1016>.
>
> ‚Äî
> You are receiving this because you were mentioned.
> Reply to this email directly, view it on GitHub
> <https://github.com/Moya/Moya/pull/1016#event-1011047362>, or mute the
> thread
> <https://github.com/notifications/unsubscribe-auth/ADo1dLgc60B1bdVsvKubatVJR95BZ8QDks5roWmggaJpZM4MfFHB>
> .
>
  Reverts accidental merge of branch `9.0.0-dev` into `master`.
See #1013

This reverts commit 23be21483154bfed6b2a851cee8c6eb0ea66212f, reversing
changes made to 4ac60f04c4771375a77069ef06f8655cde12975d. Thanks @pedrovereza!   Not sure if it was intentional, but 23be21483154bfed6b2a851cee8c6eb0ea66212f merged branch `9.0.0-dev` into `master`. If that's correct, we can delete branch `9.0.0-dev` ü§î  Wow, that was a conflict GitHub wanted to resolve on this PR. Didn't mean to do that... üòî @BasThomas No worries, #1015 should undo it :wink: Ok, the changes from #993 are already in `master` but reverted in #1015, that's why git won't try to apply #993 again. I think we have to merge this as-is an reapply 249e436ab1c32f212a195afbe411fe5234aba81f on `9.0.0-dev`  Hey @moto0000. Unfortunately, this is something we didn't introduce yet in our API. Upload especially is something we are still working on. However, I think this would be a nice feature. Would you be up for doing the PR with implementation? :) This issue has been marked as stale because it has not had recent activity. It will be closed if no further activity occurs. 
 This issue has been auto-closed because there hasn't been any activity for 59 days. However, we really appreciate your contribution, so thank you for that! üôè Also, feel free to [open a new issue](https://github.com/Moya/Moya/issues/new) if you still experience this problem üëç.
  Feel free to take a stab at implementing this! Would this be a breaking change or would/should it coexist with the `Observable`-implementation? `Single<>` sounds incredible! I brought something similar up as an issue a few months ago, I'm so excited they implemented something that solved the same problem.

I'll take a shot at this üòÑ  Implemented in #1020  See #966 for details.  Great question @PMExtra üòÑ 

First, you wouldn't be disposing the `RxMoyaProvider` as a whole, you'd dispose a (or a number) of subscriptions created by the `RxMoyaProvider` which represent pending network requests. More of a naming issue, but it could cause a misunderstanding with what you're actually doing.

So you should dispose subscriptions when you're no longer interested in them. In your case, thats when you'd no longer like to send heartbeats to your server.
If you only want to send heartbeats when a specific view controller is alive, then you should add it to the vc's dispose bag, otherwise you should add it to a long living disposeBag, maybe of a class that belongs to your AppDelegate (like your `NetworkManager`, or something like that)

Let us know if you have any other questions about this üëç   no, you not need create a provider for each request... You need only one provider :D...   **Version** `8.0.2`

I feel kinda stupid to be asking the seemingly simple question, but I simply can't figure it out.

I need to post some JSON to an API endpoint, where some values need to be `nil`. Here's an example:

```json
{
    "key1": "someString",
    "key2": null
}
```

However, the `parameters` property of the `TargetType` protocol only accepts `[String, Any]?` and not `[String, Any?]?`, so how do you achieve this? Thanks @vzsg. But I'm curious as to why you need to use some old `NSObject` subclass in a Swift dictionary, when we have optionals?

Also, what is the easiest way to unwrap the optional values when constructing the `parameters` dictionary then? Let's say I have an object
```swift
struct LineupPlayer {
    let id: Int
    let user : User?
}
```
doing the following
```swift
extension LineupPlayer : ParameterRepresentation {
    var representation: [String : Any] {
        return ["id": id, "user": user?.representation ?? NSNull()]
    }
```
results in a compile error `Generic parameter 'T' could not be inferred`, since the nil-coalescing operator tries to operate on two different types.

How would you recommend to do this? Doing

```swift
extension LineupPlayer : ParameterRepresentation {
    var representation: [String : Any] {
        return ["id": id, "user": (user?.representation as? Any`) ?? NSNull()]
    }
```

compiles, but now I get [this error](https://github.com/Alamofire/Alamofire/issues/1693#issuecomment-285937335) üôÑ  I'm so confused! It's just a `protocol`

```swift
protocol ParameterRepresentation {
    var representation : [String : Any] { get }
}
```

Because the API only accepts `null`, not `{ }`, when there is no value @jessearmand. I got it working now. Thanks everyone üôè  Great! Could you post your fix to the problem here as well, @philipengberg? Might be helpful for other people in the future.    Oh hai it's me again.

So, we have a few fixes that could be released already:

- #966 fixed the Swift 3.1 compatibility, and [some people are already trying XCode 8.3 beta](https://github.com/Moya/Moya/issues/952#issuecomment-284999253).
 **This fix is not listed in the changelog**, I think it should be. (Changelog entry added in #1010)

- #979 fixed the output of `reversedPrint`

- #1002 fixed a memory leak when stubbing

cc. @Moya/contributors  also, this changes needs to be integrated in 9.0.0 branch... @gperdomor I think that when we decide to release 9.0, we will merge the branch with master, so 9.0 will have everything until 8.x, plus the breaking changes for 9.0. Does that make sense?

EDIT: Oh, think I get what you mean. Have this changes in 9.0 branch so we develop on an up-to-date branch üëå  Yes... On the other hand, do that, reduce the possibility of conflicts, we don't know how many PR will merge to master or 9.0.0, but eventually this could produce more conflicts depending on how many breaking changes was introduced in 9.0.0
 @soundbites I think we just need to get #1010 merged and we should be good to go. @pedrovereza, is it intentionally a tag and not a release? @BasThomas The release script first creates a tag and then a release. It takes a while and is still running üòÉ 

Edit: https://github.com/Moya/Moya/releases/tag/8.0.3    @jorgelp94 you can use a endpoint closure. Check [Endpoints.md](https://github.com/Moya/Moya/blob/master/docs/Endpoints.md)

> You can add parameters or HTTP header fields in this closure. For example, we may wish to set our application name in the HTTP header fields for server-side analytics.

```swift
let endpointClosure = { (target: MyTarget) -> Endpoint<MyTarget> in
    let defaultEndpoint = MoyaProvider.defaultEndpointMapping(for: target)
    return defaultEndpoint.adding(newHTTPHeaderFields: ["APP_NAME": "MY_AWESOME_APP"])
}
let provider = MoyaProvider<GitHub>(endpointClosure: endpointClosure)
```
In your case you need use RxMoyaProvider instead MoyaProvider  Seems like the `request` for plugin in stub mode never complete so just cancel it. It fix the memory leak issue. Related to https://github.com/Moya/Moya/issues/1000  Thanks a lot for contributing to Moya! I've invited you to join the Moya GitHub organization ‚Äì no pressure to accept! If you'd like more information on what that means, check out our [contributor guidelines](https://github.com/Moya/contributors) and feel free to reach out with any questions.  @hartbit  Were you not able to find the [docs](https://github.com/Moya/Moya/blob/master/docs/Providers.md#stubclosure)? It's pretty clear on how to stub the requests.

When you create an instance of the `MoyaProvider`, add `stubClosure:`.
`let provider = MoyaProvider<MyTarget>(stubClosure: MoyaProvider.immediatelyStub)`

It might be a good idea to make finding these things easier. I can see why this is confusing. There doesn't seem to be a centralized section for testing. It's scattered among providers, basics, etc. 

I'll see what I can do to improve this but I'm guessing it's a week before I'll be able to do a write up. I'm assigning this issue to myself but if anyone can complete it before me - feel free.  I think you will have better luck if you make the `language` and `sort` query parameters constants in the `parameters` return as opposed to hard coding them in the path. That way they don't escaped as you are seeing. Let us know if that works for you!  You should pass a `stubClosure` to `MoyaProvider` on instantiation. There are some default ones:

* `neverStub` (default)
* `immediatelyStub`
* `delayedStub`

e.g.

```swift
let provider = MoyaProvider<MyApi>(stubClosure: MoyaProvider.immediatelyStub)
``` @sevrazzmatazz Hey, the usage is actually on the docs ([here](https://github.com/Moya/Moya/blob/master/docs/Providers.md#stubclosure)). Any ideas on how we could make this easier to find? ü§î  @Moya/contributors Issue #1001 also discusses the difficulty of finding the docs on stub closures. I'm going to close this.  Handling object deserialization in general has been discussed, but currently is on the roadmap per se. So I don't think deserializing XML and parsing that into an RSS model is in the near future.

That being said, I took a look the library you referenced and I don't think it would be terribly hard to port it to Moya. 90% of the code would be reusable--you would just need to write the extensions for `Moya.Response` which should be pretty straightforward. I think if you were interested in that, it could be a very valuable addition to our community extensions.

Another option you have is to extend Alamofire with ReactiveSwift--I'd be surprised if such a library doesn't already exist. That also should be straightforward, especially since Alamofire already uses a `Result`-like pattern. I'm gonna close this issue due to inactivity, but feel free to reopen whenever.  This reverts commit ca5c9fed3a6ad4bb8be9a5d882bb202782910ac1, reversing
changes made to 4160bb6a1611386a469e9b2b0d2a07fe1ef9c461. @BasThomas, @ashfurrow, @scottrhoyt:

I can't possibly believe that this is correct; the Cartfile is totally wrong. I ran the command I posted in #996: `git revert -m 1 ca5c9fe` and popped this onto a branch... any ideas?  @Moya/owners 

Can someone help me undo the latest commit to master? I can't force push to a protected branch, wondering if there was some other way than manually undo-ing it, which I'm open to because I messed it up.

ü§¶‚Äç‚ôÇÔ∏è  @Moya/contributors as well I'm trying to use `git revert`, but I'm not entirely familiar. The `... reset` `... push -f` didn't work I ran `git revert master -m 1`, but haven't pushed it yet because i don't want to undo the wrong stuff. A revert generates a new commit, to be safe it'd be best to put that commit in a PR, if that works for you? I'm happy to do it but I'm away from a computer right now.  Hey @justinmakaila, are you familiar with how to generate a reverse commit? As @ashfurrow mentioned, you should be able to push that to `master` without force pushing anything. If you need any help or would like me to do it,  post the hash of the commit you want reversed and I can do it. Thanks! I would think this concerns `ca5c9fed3a6ad4bb8be9a5d882bb202782910ac1`, right @justinmakaila? Exactly, @BasThomas. 

@scottrhoyt, @ashfurrow, I'm fine with PR'ing it, I just wanna make sure the command I'm running is legit.

Quick patch: Is there any reason we allow direct pushes to master? I know, realistically, I should have watched what I was pushing to, but is there anyway we can protect against this in the future? Yup, cool so on a branch you do `git revert ca5c9fed3a6ad4bb8be9a5d882bb202782910ac1`, save the default commit message, and then push your branch to do a PR as usual.

We allow pushes to master because the release script, which modifies the changelog and podspec, commits and pushes. With this being automated, maybe there's an opportunity to change that. 

Let me know if I can help or further clarify anything üëç @ashfurrow Well here's the fun part... `ca5c9fe` is actually a merge commit... I had my own fork of Moya with tweaks for whatever version of ReactiveSwit I was using. I pulled in `upstream` (this repo), and merged, then, thinking I was pushing to my branch, accidentally typed `git push upstream master` which pushed whatever just got merged in with whatever out of date changes I had.

The parents of the commit are  `4160bb6` + `b0a70e2`, where `b0a70e2` is the commit that I want to revert master back to (i.e. undo whatever was merged in from `4160bb6`.

I believe the proper revert command would be `git revert -m 1 ca5c9fe`, which gives me the message:
```
Revert "Merge in master"

This reverts commit ca5c9fe..., reversing changes made to 4160bb6...
```
I'm a little tentative to pull the trigger right now, seeing as I've already ruined our history a bit ;).

I'm going to create a new fork (I don't trust the history of my old one anymore...), create a new branch, run the revert command above, and then file a PR. Try diffing the branch with the reverted commit against the last commit before your accidental one. Yikes, I've never successfully reverted a merge commit except through the GitHub UI. Hmm. Any advice here would be welcome. @Moya/contributors after further review, it looks like my branch was used as the base, and the "merge" was really just a fast forward, that looks weird because my branch was used last the base.

I changed one of my projects to point to master, and have been using it with seemingly no issue. Ultimately, I think this demonstrates that we need to lock down the master branch and ensure that the only code that can get into master is via PR and approval from the organization. I agree with Justin about locking down master, especially since the Moya
organization is huge, which introduces more potential points of failure. Is
the release script the only consumer committing directly to master? Can we
have it make a Pull Request instead?

On Fri, Mar 3, 2017 at 3:03 AM Justin Makaila <notifications@github.com>
wrote:

> Ultimately, I think this demonstrates that we need to lock down the master
> branch and ensure that the only code that can get into master is via PR and
> approval from the organization.
>
> ‚Äî
> You are receiving this because you are on a team that was mentioned.
> Reply to this email directly, view it on GitHub
> <https://github.com/Moya/Moya/issues/994#issuecomment-283788926>, or mute
> the thread
> <https://github.com/notifications/unsubscribe-auth/ADo1dKXew-BYKg2aq7F5ck9pDwXDw5_8ks5rhzW0gaJpZM4MPIc3>
> .
>
 GitHub's control over branch protection looks fairly granular ‚Äì we we automate the release, get @ashfurrowbot or @moyabot or someone's bot to push, and whitelist them as having direct push access. We've been discussing automating our release process a bit in https://github.com/Moya/Moya/issues/983 but could someone open a new issue for just it? Yeah, if we can do releases via @moyabot, that'd be awesome! There may be a complication using @moyabot actually. It's purposefully not a member of the org because it has its personal access token to access repos public (it _has no repos_ to access, so it's fine). It needs this for Danger integration. Hmm. I can't really use @ashfurrowbot either for the same reason. Not sure about next steps. Well, I suppose on the other hand, as long as we can't force push, then we won't be able to do anything absolutely irreversible. It just might be a major pain to do so... Yeah, we'd have to modify our deploy script because it currently updates the changelog and podspec, commits those changes, and pushes. If we did something else like using PRs for those changes, and then tag post-merge, then CI can just push to CocoaPods and make a GitHub release. Sounds like a plan to me! Alternatively, we could use deploy keys instead of using personal access tokens; it's more involved but we can automate away the PR process. 

@scottrhoyt would you be interested in making those changes? Happy to help but I'm also keen to see the project grow on its own, without me :smile: Sure, @ashfurrow. My other workload has picked up a bit, so it might be a few days before I can look at this, but happy to give it a go. Cool cool, much appreciated. No pressure remember!  Does anyone have an idea on how to revert the accidental push? I think that would be good to figure out as well. @BasThomas The issue (I believe) was that I was running my own fork, and my own version of master, so when I went to merge in, it used my branch as the base, and merged in this repo's master, which pretty much just merged my four month old commits into the history.

I attempted to use the standard suggested `git revert` and whatnot, but since my branch was the base for the merge, it was threatening to undo months of work on this branch.

Given that context, if anyone who understands git a little better has an idea, it should be pretty easy to drop those commits from the history (I was literally just tweaking the Cartfile to match ReactiveSwift with the version of ReactiveCocoa I was using), then that would provide a more accurate representation of development over time, but I'm not sure if it's necessary, given that all of the files I edited were definitely manipulated and changed since I last touched them. Yeah, I didn't notice any file changes in the project itself, so it should be fine. I think this should be resolved, so I'm gonna close it for now.  I tried to solve #975 

 @BasThomas Done! üëç  @scottrhoyt, in the branch / PR, this has already been done, right? https://github.com/gperdomor/Moya/blob/1ac84d7387703d552f51ac41e9d0c7c16cb577c2/Sources/Moya/MoyaError.swift#L32
Not sure why you are referring to the main repo? Oops. Thanks @BasThomas. I missed it. Sorry @gperdomor. Looks good! We should also not forget to update the docs to reflect this change, although I think we can do so in another PR.  **DON'T MERGE YET**... I forgot test the Demo, i don't know if runs or not... But i can't do it now... i will do it tonight @scottrhoyt I update the docs and integration tests... The Demo works without changes Hmm we might want to start a separate changelog section for 9.0.0 instead of making it seem like this change is on `master`. But this PR is target to 9.0.0 branch, not to master, so everything in Next section is obviously referent to 9.0.0, at least for me can we merge this?... I propose create a milestone for the `9.0.0` Thanks a lot for contributing to Moya! I've invited you to join the Moya GitHub organization ‚Äì no pressure to accept! If you'd like more information on what that means, check out our [contributor guidelines](https://github.com/Moya/contributors) and feel free to reach out with any questions. @nikans Moya has been around almost as long as Swift has been public, our error handling as evolved as Swift's has :wink:   I could be wrong, but I believe this is more of an App Transport Security issue. Have you tried searching for information/solutions regarding that? Hmm. Well, I'm not sure I can think of where Moya might be interfering with this. Moya runs network requests through Alamofire which in turn uses `URLSession`. I believe this is a configuration that should be happening at the `URLSession` level, but possibly there is something to do at the Alamofire level. [Here is a link](https://github.com/Alamofire/Alamofire#security) to Alamofire's security section that covers some ATS and common issues with self-signed certificates. @camcoding You can use `ServerTrustPolicyManager` from Alamofire:

```swift
let serverTrustPolicies: [String: ServerTrustPolicy] = [
    "your host exactly": .disableEvaluation
]

let manager = Manager(
    configuration: URLSessionConfiguration.default,
    serverTrustPolicyManager: ServerTrustPolicyManager(policies: serverTrustPolicies)
)

let provider = MoyaProvider<YourService>(manager: manager, plugins: [NetworkLoggerPlugin(verbose: true)])
```

The only problem is that `ServerTrustPolicyManager` doesn't take wildcards in the policies, meaning that you would need to specify the host, which is fine when you're testing locally but won't work for your users.

From `ServerTrustPolicyManager` source code:

```swift
    /// Returns the `ServerTrustPolicy` for the given host if applicable.
    ///
    /// By default, this method will return the policy that perfectly matches the given host. Subclasses could override
    /// this method and implement more complex mapping implementations such as wildcards.
    ///
    /// - parameter host: The host to use when searching for a matching policy.
    ///
    /// - returns: The server trust policy for the given host if found.
    open func serverTrustPolicy(forHost host: String) -> ServerTrustPolicy? {
        return policies[host]
    }
```

What you can do to disable certificate validation is to subclass `ServerTrustPolicyManager` and return `.disableEvaluation` for all hosts:

```swift
class CustomServerTrustPoliceManager : ServerTrustPolicyManager {
    override func serverTrustPolicy(forHost host: String) -> ServerTrustPolicy? {
        return .disableEvaluation
    }

    public init() {
        super.init(policies: [:])
    }
}
```

and the usage becomes:

```swift
let manager = Manager(
    configuration: URLSessionConfiguration.default,
    serverTrustPolicyManager: CustomServerTrustPoliceManager()
)

let provider = MoyaProvider<YourService>(manager: manager, plugins: [NetworkLoggerPlugin(verbose: true)])
```

Let us know if this solves the problem for you :wink: @camcoding Oh, right. Forgot to mention you also need this in your Info.plist:

![image](https://cloud.githubusercontent.com/assets/1916041/23478752/100d924a-fea1-11e6-968e-5b0f3c38c984.png)
 @camcoding I created a simple project using Moya to access a website that uses a self signed certificate: https://github.com/pedrovereza/SelfSignedMoya. 
There is also a branch that uses `RxMoyaProvider`: https://github.com/pedrovereza/SelfSignedMoya/tree/rxExample

Both use the `CustomServerTrustPoliceManager` described above, plus the entries in the Info.plist.

Can you confirm this project works for your endpoints as well?  What are you referring to exactly? Where do you get an error? Also, which dependency manager are you using? This looks like an old release, hopefully everything should be fixed in our latest. Please reopen if you're still having issues @coderRMS!    Changed `Moya.Error` in [Basic](https://github.com/Moya/Moya/blob/master/docs/Examples/Basic.md) to `MoyaError`. Changed `verbose` in [Plugins](https://github.com/Moya/Moya/blob/master/docs/Plugins.md#built-in-plugins) to `isVerbose`. Thanks @dannymout !  I'm making a request in Moya, I'd like to see the request URL, is this possible? Do you mean logging it to the console? If so, checkout `NetworkLoggerPlugin`. @scottrhoyt If you don't mind answering, how would I use `NetworkLoggingPlugin` to do what I need to do? Sure, you just initialize a `NetworkLoggingPlugin` and pass it to the `plugins` parameter of your `MoyaProvider` initializer. (e.g. `plugins: [NetworkLoggerPlugin()]`). @scottrhoyt @gperdomor Perfect. Didn't know that is how it worked, thanks.  This issue has been marked as stale because it has not had recent activity. It will be closed if no further activity occurs. 
 This issue has been auto-closed because there hasn't been any activity for 59 days. However, we really appreciate your contribution, so thank you for that! üôè Also, feel free to [open a new issue](https://github.com/Moya/Moya/issues/new) if you still experience this problem üëç.
  Thanks for the contribution @yanamura3!

I have to think about this one for a second. Something feels a little off about transforming an `AFError` into a `MoyaError` like this. I don't know that it is a bad approach, it just feels unique as to how we handle other underlying errors. Also, having it depend on `validate` and possibly not doing the transform if a response doesn't exist feel a bit too non-deterministic.

On the other hand, this is a clever way to get the changes necessary for #975! It is technically a breaking change, though. If someone wrote code that looks for the a `AFError. responseValidationFailed` embedded in a `MoyaError.underyling`, their code will break with this update. Worse, it would probably be silent--no compiler error.

In the light that it would be a breaking change, I'm leaning towards it being better to just add an optional `Response` value to `MoyaError.underyling`, but that's not a strong opinion.

Would love to hear what other @Moya/contributors think of this approach. @scottrhoyt check  #993 please, i add the response to `MoyaError.underyling` @yanamura3 this was solved in #993 :D  Nitpicking üôà Just saw all the issues you closed, really nice work @scottrhoyt üëå  I would like to set up CircleCI to automatically deploy prebuilt frameworks for Carthage on tagged released. I haven't done so for CircleCI yet, but I'm quite familiar with the process on Travis. I believe Circle build tagged releases, correct? Do any @Moya/contributors think this is a bad idea?

In order to execute this I believe I will need a OAuth token with permissions to modify releases. @Moya/owners or @ashfurrow do you think you could assist with this? I'm okay with automating things, that's a bit distinct from releasing prebuilt libraries. I've avoided them until Swift has ABI stability but it's definitely up for discussion. @scottrhoyt I've added you as an owner of the Moya org so you should be set to handling setup yourself. Let me know if I can help ‚Äì I've been stepping back gradually but I'm happy to help where I can! Thanks @ashfurrow! I share your concerns for Swift ABI compatibility, which is why I introduced a PR for Carthage to only use prebuilt binaries when they are compatible with your local version of Swift (https://github.com/Carthage/Carthage/pull/1755). This is has been merged and will deploy soon with the next Carthage release. With this feature, a Carthage consumer of Moya will at worst have the same behavior as current (building Moya), but may also benefit further from a prebuilt binary.  @iShawnWang thanks for reporting this and creating a repro project. I can confirm that I experienced the same compiler crash from that project. I haven't had a chance to look into it much further, however, because these sorts of compiler crashes can take a while to debug üòû . In the past when I have experienced this it has been related to issues with generics (many times having to do with generics and inheritance). I don't know if that is the issue here or not though, but it's my first guess. Have you had a chance to see if this behavior is the same when compiling with Swift 3.1? Thank you for your help, @hugweb! üëç I think this should be resolved, so I'm gonna close it. If you still have questions about this topic, @iShawnWang, please feel free to reopen whenever.  This was introduced recently in f90429587b92a57d33ed7019fc80b5a082aac7b2.

@BasThomas Any reason why we'd want to keep them separated in the instructions? ü§î  I think it may have just been a copying error from the Cocoapods instructions. @scottrhoyt Yea, that may be the case. Just wanted to double check with him because these changes normally come after a PR/issue and maybe there was a discussion we don't remember. I think I misunderstood the instructions and made an error here. Thanks for fixing this, @Lutzifer! üôå Thanks a lot for contributing to Moya! I've invited you to join the Moya GitHub organization ‚Äì no pressure to accept! If you'd like more information on what that means, check out our [contributor guidelines](https://github.com/Moya/contributors) and feel free to reach out with any questions.  The main issue for you is to solve having a `TargetType` with a dynamic `baseURL`. Some ideas on how to do this are covered in #978. For the purposes of this example I am going to assume you have a `struct MooApi: TargetType` that takes a `URL?` to use as it's `baseURL`. If given `nil` it  has access to a default `URL`. Then it would look something like this:

```swift
struct MooApi: TargetType {
  let defaultURL = < defaultURL >
  let url: URL?

  var baseURL: URL { return url ?? defaultURL }

  /* TargetType */
}

let provider = MooProvider<MooApi>(token: accessToken)

func followTheURLs(url: URL? = nil) -> Observable<JSONDocumentManyObjects<LibraryItem>> {
  return provider.request(MooApi(url: url))
    .filterSuccessfulStatusAndRedirectCodes()
    .mapObject(type: JSONDocumentManyObjects<LibraryItem>.self)
    .flatMap { jsonDocumentManyObjects in
      if let url = jsonDocumentManyObjects.nextURL {
        return followTheURLs(url: url)
      } else {
        return Observable.just(jsonDocumentManyObjects)
      }
    }
}

followTheURLs()
      .subscribe { event in
        switch event {
        case .next(let element):
          print("next: \(element.url)")
        case .error(let error):
          print("error: \(error)")
        case .completed:
          print("completed")
        }
      }
      .addDisposableTo(disposeBag)
```

Now a couple of points:
  * If your `MooApi` has different endpoints then you'll need an additional strategy here. Look at #978 for ideas.
  * I'm not exactly sure about how this recursive flat mapping will propagate errors. You'll want to test that.
  * It might be possible to instead do this with an Observable of Observables, but I'm not sure it would be much simpler.  @jessearmand you can tag your PRs with `#trivial` to not trigger this Danger warning. However, I think a nice fix like this should be in the Changelog. If you look at the document, the top heading is "Next". This is the space for changes the currently only exist on `master`. Currently, there are none, but you can go ahead and make the first entry! Thanks! And thanks for the contribution! Thanks a lot for contributing to Moya! I've invited you to join the Moya GitHub organization ‚Äì no pressure to accept! If you'd like more information on what that means, check out our [contributor guidelines](https://github.com/Moya/contributors) and feel free to reach out with any questions.  @gregpardo you can treat the `baseUrl` like the other parameters and use a switch statement to load it. It would look something like this:

```swift
enum MyApi: TargetType {
  case login(baseUrl: URL)

  var baseUrl: URL {
    switch self {
    case let .login(baseUrl):
      return baseUrl
    }
  }

  /* TargetType implementation */
}
```

But if you know the other base URL's at compile time, I would recommend using a separate `enum` to drive those:

```swift
enum Server {
  case northAmerica
  case europe
  
  var baseUrl: URL {
    switch self {
    case .northAmerica:
      return <north america URL>
   case .europe:
      return <europe URL>
    }
  }
}
enum MyApi: TargetType {
  case login(server: Server)

  var baseUrl: URL {
    switch self {
    case let .login(server):
      return server.baseUrl
    }
  }

  /* TargetType implementation */
}
```

Does that answer your question? @gperdomor maybe I can help you further if I understand a bit more about your use case. If you don't know the `URL`s at compile time, how do you retrieve them? Ah, I see, so then I think the singleton idea make a lot of sense.

Another idea that would be slightly more complicated but eliminate the need for a singleton:

```swift
struct DynamicTarget: TargetType {
  let baseURL: URL
  let target: TargetType

  var path: String { return target.path }
  var method: Moya.Method { return target.method }
  /* ... */
}

class DynamicProvider: MoyaProvider<DynamicTarget> {
  let baseURL: URL

  // add initializer to take `baseUrl` and call super with the rest of the arguments

  func request(_ subTarget: TargetType, completion: ((Result<Response, MoyaError>) -> Void)? = nil) {
    let dynamicTarget = DynamicTarget(baseUrl: baseUrl, target: subTarget)
    super.request(dynamicTarget, completion: completion)
  }
}
```

Does that make sense? That way you initialize the provider once with the URL and from there you can just pass regular `TargetType`s to it. Another option is to create a `protocol` that has all the properties of `TargetType` except a `baseUrl`, you could then use that in this structure and avoid needing to put garbage `URL`s in for all the regular `TargetType`s.

```swift
protocol SubTarget {
  var path: String { get }
  var method: Moya.Method { get }
  /* ... */
}

struct DynamicTarget: TargetType {
  let baseURL: URL
  let subTarget: SubTarget

  var path: String { return subTarget.path }
  var method: Moya.Method { return subTarget.method }
  /* ... */
}

class DynamicProvider<Target: SubTarget>: MoyaProvider<DynamicTarget> {
  let baseURL: URL

  // add initializer to take `baseUrl` and call super with the rest of the arguments

  func request(_ subTarget: Target, completion: ((Result<Response, MoyaError>) -> Void)? = nil) {
    let dynamicTarget = DynamicTarget(baseURL: baseURL, subTarget: subTarget)
    super.request(dynamicTarget, completion: completion)
  }
}
```

There are a number of variations around this idea, but `struct` `TargetType`s would be the key. `let baseURL: URL` should satisfy a protocol requirement of `var baseURL: { get }`. I used it in such a way [here](https://github.com/Moya/Moya/blob/sh_targettype_defaults/Source/Target.swift#L44).

(there are some small mistakes in my example like `baseUrl` instead of `baseURL` that you will need to fix, but the concept works) There is some similar functionality in `MultiTarget` and I proposed another idea that has some overlap, but that wasn't accepted. In neither case would it have solved this issue. In general I would say most users of Moya are interacting with a single `baseURL` per target, so I don't think there is a ton of need for this to be native. But if we continue to get requests like this, we can consider adding it. @gperdomor yes, I have used something similar to the singleton method in some of my projects. It has worked quite well.

The `SubTarget` protocol definitely adds some maintenance overhead, but I believe it to be pretty small. If those maintenance concerns are bigger to you than having a garbage `URL` in the code, then you could easily do something like this:

```swift
protocol SubTarget: TargetType { }

extension SubtTarget {
  var baseURL: URL { return URL(string: "http://YouShouldNeverUseThisURL.com/")! }
}
``` No, not directly I believe, but maybe you can provide a `fileprivate` protocol extension in the test file that overrides all `TargetType` `sampleData` (haven't tried that). What I do is provide an override for the endpoint closure that provides data only in testing. The advantage to this approach to is that you can simulate different responses per test and even simulate things like different HTTP status codes or network errors.

I generally simplify this by creating a testing subclass of `MoyaProvider` that takes a `responseClosure` which maps the `Target` to a `EndpointSampleResponse`, then I construct the `EndpointClosure` with this. It looks something like this:

```swift
class TestProvider<Target: TargetType>: MoyaProvider<Target> {
  init(responseClosure: ((Target) -> EndpointSampleResponse)? = nil) {
    var endpointClosure: EndpointClosure
    
    if let responseClosure = responseClosure {
      endpointClosure = {
        target in

        let sampleResponseClosure: Endpoint<Target>.SampleResponseClosure = {
          return responseClosure(target)
        }

        return Endpoint(
          url: target.baseURL.absoluteString,
          sampleResponseClosure: sampleResponseClosure,
          method: target.method,
          parameters: target.parameters,
          parameterEncoding: target.parameterEncoding,
          httpHeaderFields: nil
        )
      }
    } else {
      endpointClosure = MoyaProvider<Target>.defaultEndpointMapping
    }

    super.init(endpointClosure: endpointClosure, stubClosure: MoyaProvider.immediatelyStub, plugins: [])
  }
}
```

**Note this also stubs immediately and makes no attempts to put anything into the HTTP header fields, so change that behavior as necessary.**

The usage then looks like this:

```swift
  enum TestTarget: TargetType {
    case success, failure

    // Implement TargetType
  }

  let responseClosure: (TestTarget) -> EndpointSampleResponse = {
    target in

    switch target {
    case .success:
      return .networkResponse(200, fixture("ApiSuccess"))
    case .failure:
      return .networkResponse(400, fixture("ApiFailure"))
    }
  }

  let provider = TestProvider<TestTarget>(responseClosure: responseClosure)
```

**Note I am using a helper function here `fixture(_:)` that loads sample data from fixture files.**

Let me know if that helps. Unfortunately, I have only used this method in closed source projects, so I am unable to provide a link.

For the approach I outlined above, you wouldn't need a new `TargetType` for each endpoint, you would just need a new `responseClosure` anytime you want to change the behavior of sample data. In essence you achieve very similar results to `OHHTTPStubs` but you can utilize the `enum` semantics of the `TargetType` itself to write more declaratively. That being said, I know many people that use `OHHTTPStubs` and have good success with that route. There are a number of ways to do it. You could create a `responseClosure` for successes and one for failures. Or you could create a function that returns a `responseClosure` based on a `successful` flag if you need more control over the failure case. Here is what 2 separate closures looks like:

```swift
  let successfulResponseClosure: (Session) -> EndpointSampleResponse = { target in
    switch target {
    case .login:
      return .networkResponse(200, fixture("LoginSuccess"))
    case .tokenRefresh:
      return .networkResponse(200, fixture("TokenRefresh"))
    case .logout:
      return .networkResponse(200, fixture("Logout"))
    }
  }

  let successfulProvider = TestProvider<Session>(requestClosure: successfulResponseClosure)

  /* ... Run Your Success Tests ... */

  let failedResponseClosure: (Session) -> EndpointSampleResponse = { _ in
    return .networkResponse(404, fixture("BadRequest"))
  }

  let failedProvider = TestProvider<Session>(requestClosure: failedResponseClosure)

  /* ... Run Your Failing Tests ... */
``` It looks like that solved your problem @gperdomor, let us know if you still need any help with this! Closing for now üòÑ   As noticed in #957  @shuijinliuxi, you have 2 options for getting to the `URLRequest`:

* Utilize a custom `RequestClosure` in your provider to construct the request with any modifications needed.
* Create a `PluginType` that uses the `prepare` method to make any modifications to the `URLRequest` and add that to your provider.

Also if you need to modify the caching policy, you can construct an `Alamofire` `SessionManager` with a custom `URLSession` using a `URLSessionConfiguration` that modifies the caching policy to your liking. This can then be given to a `MoyaProvider` to use instead of the default. But you might be fine with the defaults as well.  Maybe @scottrhoyt can help you with this one.  @mrtj unfortunately I don't have any easy answers for you on this one. Using Alamofire's validation takes a lot of control out of Moya's hands. The way I see it, you have a couple of options, but they aren't simple.

1. Modify Alamofire's validation error to also expose the response. This could be via filling an issue/PR with them or creating your own fork.
2. Modify Moya's `TargetType.validate` property to return an optional integer range to validate with. A `nil` value indicates no validation while a range is forwarded to Alamofire's `validate(statusCode:)` that would go around [this section](https://github.com/Moya/Moya/blob/master/Sources/Moya/MoyaProvider+Internal.swift#L200-L216). This would require you to fork Moya.
3. Build request retrying functionality into Moya.

Option 1 would probably be valuable to the wider Alamorefire community, but I think it might be hard to get a breaking change like that through in any reasonable timeline for you. You would also have to maintain separate forks of both Alamofire and Moya.

Option 2 is the quickest and easiest for you, and you could submit a PR back to us for consideration. However, I don't personally love the solution for Moya in general because it's going to help propagate this pattern of spreading out error handling between Alamofire, Moya, and the dependent application. It feels like a bad separation of concerns to me, but other's may feel differently about that.

Option 3 would be the hardest but of possibly the most value to the Moya community. We go through some lengths to hide Alamofire from end users. If we can eliminate one more use case--and a big one at that--for users to dig into Alamofire and deal with the attendant consequences, I think that would be a big win. I'm sorry @mrtj, I mistakenly assumed that at that point Alamofire was just returning a `AFError. responseValidationFailed(reason: . unacceptableStatusCode(Int))`. If it is also returning a response with data then indeed you could modify `MoyaError.underlyingError` to have an optional `Response` parameter that can be forwarded to custom error handling.

Why don't you give that a try and report back your findings? We can open up a PR as well, but since this would be a breaking change, it might be a bit before we can include it upstream. FWIW, I think in this case it should definitely be corrected to also include `data` in Moya, and we should consider releasing a `9.0` for it. What would be the downsides of doing it this quick after `8.0`? I don't see there being a ton @BasThomas. If this were a bigger breaking change I would say the downside would be forcing user's to deal with breaking changes to receive future fixes, but in this case the fix would be pretty minor and maybe not even affect a large portion of users. If we go that route I would propose we start a pre-release cycle for 9.0 so that @mrtj and others with this use case can get support quickly while we work out what other things--if any--should go in 9.0. How about we open another issue to discuss? üëç great idea  @mrtj @BasThomas, I just created the `9.0.0-dev` branch so we can accept PRs there. @mrtj, if you have gotten the solution above to work, would you mind submitting a PR to that branch so we can get your work included in the next major release of Moya? üëç  Solved in #993 so this can be closed  Hey @shuijinliuxi, can you test if the parameters are valid before making the request? Something like:

```swift
if (parameterAreValid(key, id: consId) {
  provider.request ... // Make request here
}
else {
  //show alert
}
```  Hey @albertml, if I understood correctly, you want the parameters to be sent as JSON instead of having them in the URL. Is that correct?

If so, you should use `JSONEncoding.default` as your `parameterEncoding`, e.g.:

```swift
public var parameterEncoding: Moya.ParameterEncoding { return JSONEncoding.default }
```  I noticed this when reading #970   You beat me to it, @bjarkehs. üòÖ ü§î, `7.0.4` actually targets Swift 2.3. I think the documentation over at https://github.com/Moya/Moya/tree/7.0.1 is better for Swift 2.2. Go ahead and update to Swift 3. You won't regret it. In the meantime, you could of course use an older version of the Object Mapper as well, such as [v1.0.5](https://github.com/AvdLee/Moya-SwiftyJSONMapper/releases/tag/1.0.5) of the SwiftyJSONMapper?  Hi guys i have this response from my call (using latest moya) . this only happened in GET i already encoded my string to make sure the url escaped but why the url response in the log keep using percent ? anyone can give any solutions ?

i want to made this %3F into ? , i already set in the APIProvider to removingpercentencoding but keep happening..

```
"Moya_Logger: [16/02/2017 13:01:16] Response: <NSHTTPURLResponse: 0x60000022ad80> { 
URL: https://someurl.com/v1/presets%3Funflatten=1

```
Thanks Done, solved by myself by edit the url endpoint... @Ank49 cool man.. sorry just read it.. My approach little bit different. I edit the urlendpoint something like this
```

//setting the header
        let endpointClosure = { (target: API) -> Endpoint<API> in
            let url = target.baseURL.appendingPathComponent(target.path).absoluteString.removingPercentEncoding!
            let defaultEndpoint = Endpoint<API>(URL: url, sampleResponseClosure: {.networkResponse(200, target.sampleData)}, method: target.method, parameters: target.parameters)
            return defaultEndpoint.adding(httpHeaderFields: ["Accept": "application/json", "Content-Type" : "application/json", "Authorization" : token!, "X-Fingi-Signature":authSign], parameterEncoding: JSONEncoding.default)
        }
        
```  Thanks for the PR @fjcaetano! I'm going to pull the discussion into this PR.

Before I address some of the questions you have in #959, can you walk me through the use case you are trying to solve that doesn't lend itself to using `DownloadDestination` to declare where you want your file downloaded to? What do you think about having your `TargetType` case take a parameter on where to store the resulting download? Then you can construct the `DownloadDestination` in the `task` computed property. That way you would declaratively tell the request where to store the downloaded file and capture that location in your response closure (which is likely near the call site that you supplied the destination URL). Yeah, I don't think what you are proposing is unreasonable at all @fjcaetano. I just want to explore what is possible currently before considering expanding the API surface area. Thanks for walking me through your use case.

I don't think constructing the destination `URL` for the downloaded file outside of `TargetType` is necessarily a problem. In some cases it might be the right way to do it. You could certainly still construct the `URL` inside of `TargetType` as well, but having the capability to pass the destination `URL` to `TargetType` is a more general solution.

So in your use case, how do you plan on specifying that the files should be downloaded to the Documents directory? And how do you specify what the file should be named in the documents directory? In other words, how do you figure out the `URL` that would eventually be in the proposed `destinationURL`? Ah, I see. Thanks for sharing.

So, I do think that the question of whether or not to include a `destinationUrl` needs further consideration, and I would love to get the opinions of other @Moya/contributors.

On the other hand, for your particular use case, I might recommend a different architecture. Because the location of these files needs to be deterministic, I think that recommends specifying the destination `URL` declaratively even more. Having access to this `URL` would serve useful for other things like checking whether or not the file has already been downloaded before downloading it again. You could extract this from the asset `URL` as you say, or you could just construct the remote `URL`s differently. I imagine something like this:

```swift
fileprivate static let assetDir: URL = {
  let directoryURLs = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask)
  return directoryURLs.first ?? NSTemporaryDirectory()
}()

enum Assets: TargetType {
  case star
  case checkmark

  var baseURL: URL { /* ... */ }

  var assetName: String {
    switch self {
    case .star: return "star.png"
    case .checkmark: return "checkmark.png"
    }
  }

  var path: String {
    return "/assets/" + assetName
  }

  var localLocation: URL {
    return assetDir.appendingPathComponent(assetName)
  }

  var downloadDestination: DownloadDestination {
    return { _, _ in return (self.localLocation, .removePreviousFile) }
  }

  var task: Task {
    return .download(downloadDestination)
  }

  /*
    Rest of TargetType
  */
}

class AssetLoader {
  let provider = MoyaProvider<Assets>()

  init() { }

  func load(asset: Asset, completion: ((Result<URL, MoyaError>) -> Void)? = nil) {
    if FileManager.default.fileExists(atPath: asset.localLocation.path) {
      completion?(.success(asset.localLocation))
      return
    }

    provider.request(asset) { result in 
      switch result {
      case .success:
        completion?(.success(asset.localLocation))
      case let .failure(error):
        return completion?(.failure(error))
      }
    }
  }
}
``` @fjcaetano üëç. I think that refactor sounds like a good idea because then you can centralize the responsibilities of managing assets into a single object--and I like that separation of concerns. I could see it also being beneficial to you if decide to do asset preloading, batch downloading, etc. It could really be a nice replacement for ODR.

Let's keep this PR open though and see if we can get more feedback on this for other use cases, and thanks again for your contribution! I'm gonna close this one due to inactivity. Thank you for taking your time for this PR though, @fjcaetano. 

To give my opinion about this one, I'm not sure `destinationURL`, which is `nil` most of the time (for normal `request` & sample data), is the best way to implement it. Maybe an enum property that would be having special metadata based on the task type would be better? Not sure. What i know for sure is that this example with assets by @scottrhoyt should be added to our examples. 

**Edit:** I've added a PR with new example, #1113.  Based on the discussion in #818 I have finally converted `Moya.xcodeproj` to use a single target for all platforms. The idea comes from the people over at PromiseKit, they even published a [blog post about converting to a single scheme](http://promisekit.org/news/2016/08/Multiplatform-Single-Scheme-Xcode-Projects/).

I've been working on scripting the ideas from the post above using [`xcodeproj`](https://github.com/CocoaPods/Xcodeproj) and the results can be seen in the tool I created called [framework-generate](https://github.com/petester42/framework-generate). I used `framework-generate` to generate a new `Moya.xcodeproj` file by using a specification that can be found [here](https://gist.github.com/petester42/7ad0312dd1c1dcff780f2f95936200ea). 

I wasn't sure if I should add a dependency to Moya for `framework-generate` and the specification file. So let me know what everyone thinks about the change to single target for all platforms and also adding `framework-generate` as a dependency.

 @aaroncrespo @petester42 , code coverage is being tracked. The shortcut for testing is nice to have. Anyway to bring that back? First error is just that you need to put an entry in the `CHANGELOG`.

Second error is probably getting confused with the new project structure, thinking dependencies have changed the libraries are no longer in the "Linked Libraries" section but instead are found via a platform specific framework search path.

First warning won't go away because of the # of lines changed in the PR, that's fine.
Second warning is a reminder to add some documentation for big new features, but this doesn't warrant that.

So basically just worry about the `CHANGELOG`. Now, in general, I love this idea and want to see it happen. But I have to confess I'm a novice with this sort of conversion.

Some of my questions:
 * Will this work with both Carthage and Cocoapods? And have both been tested?
 * Does this method work with Carthage prebuilt binaries incase we want to introduce that for Moya?
 * Are there any other downsides to this?
 * This won't be breaking for anyone will it?
 @scottrhoyt: I'm not an expert, but I think it **should** just make maintaining the Moya.xcodeproj a lot easier.

> Will this work with both Carthage and Cocoapods? And have both been tested?

It works fine with Cocoapods & Carthage ([PromiseKit](https://github.com/mxcl/PromiseKit/tree/swift-3.0) has one target and they support both + SPM). 

> Does this method work with Carthage prebuilt binaries incase we want to introduce that for Moya?

I'm not sure about this one. I think it should - since all we're doing is merging the targets, which should just mean we need to build the one target for each device type - but we should test before merging.

> Are there any other downsides to this?

Just that what we're doing isn't officially supported by Apple. http://promisekit.org/news/2016/08/Multiplatform-Single-Scheme-Xcode-Projects/ is a great resource on this idea

> This won't be breaking for anyone will it?

Not to my knowledge Thanks for your thoughts @AndrewSB! I definitely like the maintenance reducing-nature of this. I'd like to see us get a prebuilt binary out (opened #983 to address), but if that is incompatible with this, I think I would rather have this. Especially since build caching and "only rebuild on change" behavior is in the near term Carthage pipeline, so prebuilt frameworks will lose a certain amount of their benefit. @petester42 I'd love to get this merged in. Do we just have those three issues left?

> ‚åò + U for the targets
> Code coverage is now enabled again
> Carthage framework copy script is now part of the source control. So after rebasing this & fixing CI, this should be ready to go. 

If no one else has taken a stab at resolving conflicts by tomorrow, I'll give it a shot and add some contributors as reviewers for this before we merge in üòÑ  I rebased, but we were still having a conflict, so I merged Podfile.lock. Going to get this CI passing and then we should be good to go üòÑ  Apparently something is wrong with Danger, but it looks like a nonsensical error. The Dangerfile on this branch matches the one on `master`. Can a @Moya/contributors who's familiar with Danger try to debug this? Thank you everyone for your work! I'm excited that we got this merged in üòÅ  Closes #952   Just to clarify @ftp27, what version of Moya are you using? The behavior for plugins to modify requests was introduced in 8.0.0. Also, a couple of other things to check. Are you using an endpoint closure or request closure to modify the request at all? Is there any chance that middleware on your server might be stripping the authorization headers? Thanks for the information @ftp27. If you aren't using anything but this code, then you don't have to worry about the closures I mentioned.

I can confirm that plugins do work with GET requests. However, if you can share a project that reproduces this problem, I would be happy to help you debug. @ftp27 Hey, I tried the project locally and it seems to work fine ü§î 

This is the request log in [Charles](https://www.charlesproxy.com/): 

```
GET /api/v1/services/book HTTP/1.1
Host	tcars.indev-group.eu
Connection	keep-alive
Accept	*/*
User-Agent	moyaTest/1.0 (eu.indevgroup.moyaTest; build:1; iOS 10.2.0) Alamofire/4.3.0
Accept-Language	en;q=1.0
Authorization	Token eb1b505e8634d19a2ece786274bdfbe23925d223
Accept-Encoding	gzip;q=1.0, compress;q=0.5
```

The output from `NetworkLoggerPlugin` is similar to one you shared (includes the Authorization header).

Do you think it could be something with wireshark itself? @ftp27 Ugh, that's weird. Can you confirm the same thing happens with other header fields? Something like:

```swift
request.addValue("Token " + token, forHTTPHeaderField: "TestHeader")
```

I'm not sure why it would be different, but I'm running out of ideas. I can attest to plugins being able to insert authorization headers for GET requests because I'm using it for that in production.

Perhaps Wireshark is filtering Authorization headers for some reason? Can you try inspecting the request via another method (like Charles)? @scottrhoyt Yep, [we tried that](https://github.com/Moya/Moya/issues/965#issuecomment-279696119). I was also able to reproduce the issue of not seeing the Authorization header in Charles, even though I saw it on my first attempt.

I still think that the header is being sent in the request and not showing up in wireshark/Charles for some reason. Sorry ü§¶‚Äç‚ôÇÔ∏è . Should have read better!

@pedrovereza I agree. I'm running out of other ideas. Can we look at the server logs themselves to check? Or change the url to https://httpbin.org/get and see what it sends back? @scottrhoyt Good idea on using https://httpbin.org üôå 

As seen in Charles:

```
REQUEST CONTAINING AUTHORIZATION

GET //get HTTP/1.1
Host	httpbin.org
Connection	keep-alive
Accept	*/*
User-Agent	moyaTest/1.0 (eu.indevgroup.moyaTest; build:1; iOS 10.2.0) Alamofire/4.3.0
Accept-Language	en;q=1.0
Authorization	Token eb1b505e8634d19a2ece786274bdfbe23925d223
Accept-Encoding	gzip;q=1.0, compress;q=0.5
```

And response from https://httpbin.org/get
```json
{
	"args": {},
	"headers": {
		"Accept": "*/*",
		"Accept-Encoding": "gzip;q=1.0, compress;q=0.5",
		"Accept-Language": "en;q=1.0",
		"Authorization": "Token eb1b505e8634d19a2ece786274bdfbe23925d223",
		"Host": "httpbin.org",
		"User-Agent": "moyaTest/1.0 (eu.indevgroup.moyaTest; build:1; iOS 10.2.0) Alamofire/4.3.0"
	},
	"origin": "201.47.197.212",
	"url": "https://httpbin.org/get"
}
```

I could not reproduce the case of not seeing the field in the request but seeing it in the response.  I think I probably don't need this method But if I deleted he appears does not conform to the protocol 'TargetType' if you don't delete I don't know how to implement the method
![Uploading 3.43.47.png‚Ä¶]()

 Hey, what method is it you are talking about? It seems like your image didn't get uploaded. For `task`, you normally return `.request`: https://github.com/Moya/Moya/blob/master/docs/Examples/Basic.md#basic-usage Not awkward at all! Did that resolve your issue? :)  Hey, would something like this work for you?

```swift
extension MoyaProvider {
    class func withDefaultPlugins() -> MoyaProvider<Target> {
        return MoyaProvider<Target>(plugins: [NetworkLoggerPlugin(verbose: true)])
    }
}
```

Usage:

```swift
let provider = MoyaProvider<MyService>.withDefaultPlugins()
``` @kemchenj Oh, I see.

So, would moving the extension to `RxMoyaProvider` be enough?
```swift
extension RxMoyaProvider {
    class func withDefaultPlugins() -> RxMoyaProvider<Target> {
        return RxMoyaProvider<Target>(plugins: [NetworkLoggerPlugin(verbose: true)])
    }
}
```
Or do you need `withDefaultPlugin` available for both `MoyaProvider` and `RxMoyaProvider`?

*Not saying that your changes are good/bad, just trying to understand the use case* üòÑ
 @kemchenj no problem, don't worry about that. About your idea with conforming to protocols: I love it. Would you be up for doing the PR with this idea implemented? :)

About `final` on `MoyaProvider` - I'm not sure about that. People may rely on subclassing it. I also really like `.rx` and `.reactive`! Okay, @BasThomas took a stab at it, I'm gonna close this one then. Thank you so much @kemchenj for you work, we really appreciate it! üôá   According to the [changelog](https://github.com/Moya/Moya/blob/master/Changelog.md), there were slight changes made to the capitalization of `newHttpHeaderFields`. I've updated the docs to reflect the change.

Solves #961 Thanks a lot for contributing to Moya! I've invited you to join the Moya GitHub organization ‚Äì no pressure to accept! If you'd like more information on what that means, check out our [contributor guidelines](https://github.com/Moya/contributors) and feel free to reach out with any questions.  Thanks a lot for contributing to Moya! I've invited you to join the Moya GitHub organization ‚Äì no pressure to accept! If you'd like more information on what that means, check out our [contributor guidelines](https://github.com/Moya/contributors) and feel free to reach out with any questions.  @fjcaetano, I am having a bit of a hard time wrapping my head around the use case and implications of introducing this since I don't normally use download tasks in Moya. If the solution is pretty straightforward, what do you think about opening up a PR with the feature to further discussion? Closing this one in favor of #968.  Hey @moonorblue. It would be unlikely that your data was base64 encoded unless you explicitly put it that way. I think what you most likely want is:

```swift
let string = String(data: data, encoding: .utf8)
```

Alternatively you can put a helper function in `TargetType` for that. You can check out how that was done in this PR: #881. Oh, yeah @moonorblue. Sorry, disregard what I said about the `String` transform. My head was stuck in my own project. You just need to return the `Data` so just use `Data(contentsOf:)`. Copy and pasting that code from the PR should work fine for you.  Did you add an `EndpointClosure` or `ResponseClosure` to the provider that might be adding these? Is the original logging output you show from your server? Is it possible that your server is mapping those extra fields? It could be happening in middleware somewhere. Your `curl` is url encoding the parameters instead of submitting them as JSON in the body though. Could that make a difference? Well, I'm still not sure that it is on the client side. For one, I don't know where that `authentication` key would even be coming from. My guess is that the server is using some middleware to create an `authentication` object based on what is in the body of the request.

You can try this theory out by using Alamofire against your own server to see if you see the same behavior.  The POST example in `Basic.md` currently sends the parameters encoded in the URL. I don't think this is the most common way of sending parameters in a POST request ü§î  

I believe the usual case is to send parameters in the request body as JSON. Having this in the most basic example may be more helpful to people using Moya for the first time. @vzsg Good question! 

What are the most basic (and common) cases that we should cover in this example? We don't have a GET with URL query parameters as well ü§î  This example you've added is good, but we could also add the basic `URLEncoding` below/above the example with `JSONEncoding`, imho. @sunshinejr You mean adding just a note on how the POST request would look like if `URLEncoding` was used instead? I was thinking about doing one more request with different type of encoding, maybe just below the one with user, and then make a comment how would it look like. But your suggestion works as well, make a comment how could it look like with `URLEncoding`. @sunshinejr Doing another request feels more complete üëç 

Added a new endpoint to update a user passing the parameters in the URL, let me know what you think (cc. @vzsg) Should be good now üòÑ   Your `ParameterEncoding` for `.login` should be `JSONEncoding.default`:

```swift
public var parameterEncoding: Moya.ParameterEncoding {
    return JSONEncoding.default 
}

```  Thanks for bringing that up though! We should put that on our radar for Swift 3.1 release @Moya/contributors. This is true indeed; Swift 3.1 should be source compatible with 3.0. @ened as long as we can verify that doing so still offers the fix-its when trying to use the renamed methods, I think that is reasonable. Thanks everyone. PR inbound. This fix has not been included in a release yet, right @scottrhoyt?  I think [Artsy's Eidolon](https://github.com/artsy/eidolon/blob/master/Kiosk/App/Networking/ArtsyAPI.swift) should give you an idea of how it looks like in a real product. [Here](https://github.com/artsy/eidolon/blob/master/Kiosk/App/Networking/ArtsyAPI.swift) is where their API is defined using Moya. That's the approach I use as well. In order to keep the boiler plate down in the many `TargetType`s that I create, I also introduce some defaults for `TargetType` as seen in #861.  Yep. Just drop something like [this](https://github.com/Moya/Moya/blob/e1eda4b5d637f8a4bba1519f2f3176fb2bc508fb/Source/Target.swift#L32) in.  Heads-up in the meantime - you can highlight the syntax in the code snippets with ```swift at the start. :) Interested to hear what other @Moya/contributors think about this.

I would still lean towards saying that unless Moya gets in the game of deserializing objects, this is the purview of Moya Extentsions. This could be added via an extension on `MoyaProvider`. However, an approach like this does have the advantage of creating a common interface for extension providers, and, thus, allows them to standardize their own interfaces.

I think one reason this hasn't been a bigger issue is that I think a large percentage of the user base is using the reactive providers, which already provide a cleaner interface for response handling and object deserialization through Moya extensions. There's also probably some legacy reasons since the current callback pattern aligns closely with Alamofire's. I still don't have a position on this matter.

My first thought was to agree with @scottrhoyt:
>I would still lean towards saying that unless Moya gets in the game of deserializing objects, this is the purview of Moya Extentsions. 

Extended support for parsing feels a bit outside the scope of Moya, which is nicely pointed in the Readme: 
>  So the basic idea of Moya is that we want some network abstraction layer that sufficiently encapsulates actually calling Alamofire directly.

On the other hand, if you check all plugins listed in the Readme, only MoyaSugar is not about JSON serialization:

>Moya-ObjectMapper - ObjectMapper bindings for Moya for easier **JSON serialization**
Moya-SwiftyJSONMapper - SwiftyJSON bindings for Moya for easier **JSON serialization**
Moya-Argo - Argo bindings for Moya for easier **JSON serialization**
Moya-ModelMapper - ModelMapper bindings for Moya for easier **JSON serialization**
Moya-Gloss - Gloss bindings for Moya for easier **JSON serialization**
Moya-JASON - JASON bindings for Moya for easier **JSON serialization**
Moya-JASONMapper - JASON bindings for Moya for easier **JSON serialization**
Moya-Unbox - Unbox bindings for Moya for easier **JSON serialization**
MoyaSugar ‚Äì Syntactic sugar for Moya
Moya-EVReflection - EVReflection bindings for Moya for easier **JSON serialization** (including subspecs for RxSwift and ReactiveCocoa)
Moya-Marshal - Marshal bindings for Moya for easier **JSON serialization**

Is this an indication that we should be giving better support for JSON serialization? Why does everyone feel like they have to build their own? 

This can be seen as a missing feature, but also as *flexibility*: parsing can be done in several ways and you can pick the one that fits your app better. A while ago I was trying to make something similar (make an option to `TargetType` that can map the response), but given tools of Swift 2.2 I wasn't satisfied with any of my results. 

Unfortunately with your proposition and passing parser to request function it makes _me_ responsible for remembering how should I parse the response every time, so I still need some abstraction layer over Moya to get what I want (thus I don't see much pros in this one). Although as @scottrhoyt said, this have an advantage with option to make a standard protocol for object parsing. @pedrovereza 

I think the quantity of JSON parsing extensions is just representative of how many popular JSON deserialization libraries there are. That is indicative of how for a while no single best practice had emerged in crossing the weakly typed/strongly typed gap. It seems now that a single pattern has emerged in multiple libraries.

Actually, what I would like to see is a Swiftier implementation of `NSCoding` that all these libraries could leverage or perhaps interface directly with `JSONSerialization`. It would be great to have better basic language support for object serialization that cares at least as much about JSON as PLIST.

As for better support of object serialization in Moya, that would mean either:
1. Writing our own JSON deserialization
2. Including one of more of the current JSON libraries as dependencies

It's hard for me to argue for 1 when we haven't written our own Alamofire. And doing 2 would come with the responsibility of recommending a best choice of library(s). I don't know if there is one right now. The last time I made this choice, I just picked the one that was already in my dependency graph. As an aside, it is interesting that the highest level of abstraction in this stack is really the Moya extension you choose for JSON deserialization. Drop that in your Cartfile/Podspec and you get everything else you need. My thoughts: https://xkcd.com/927/
On Wed, Feb 8, 2017 at 9:39 AM Michael Sanderson <notifications@github.com>
wrote:

> The idea is to take Moya the last mile, so clients don't have to do
> parsing in their completion blocks at the call site. I think @pedrovereza
> <https://github.com/pedrovereza> 's comment that's what nearly all the
> extensions do reflects that. In this generic solution, since there's no way
> through Swift's type system to have enums vend closures returning different
> types, the call site still needs to know which parser to use. Putting the
> parser in the function signature removes one concern from the completion.
>
> (This is obviously less of a concern for the reactive variations that use
> lenses throughout their entire structure. Of course it could be moved up
> for them as well.)
>
> As @scottrhoyt <https://github.com/scottrhoyt> said allowing extensions
> to standardize their own interfaces would be a benefit and allow better
> integration. Because of generics this needs to be done carefully, as the
> generic function parameters func request(TargetType, (Response) -> T,
> completion (T) -> Void)don't hold up when passed a generic
> function--legitimately, because all type information is gone. Typing the
> completion block only sometimes fixes this.
>
> Actually, browsing through the extensions it seems like all of them work
> by requiring T to conform to some protocol -able for the library, usually init(_
> json: JSON)? Assuming the compiler could be instructed what the type is,
> it would be possible to have a protocol init(from response:
> Moya.Response) throws and put the requirement in the generic function
> constraint.
>
> However, maybe it's my experience parsing terrible JSON but I would be
> against creating the expectation that JSON parsing can be accomplished
> automatically from endpoint-magic-object. There's a gap between
> endpointJSON and model, that clients need to be explicitly and consciously
> bridge. The place to do that is the TargetType, but that was a dead end for
> enums.
>
> In the case of completion blocks it makes sense that the knowledge of how
> to get the response into the app domain should have been made as part of
> the call. Baking *the option* to provide a parser of choice -- an option,
> because this would be able to live alongside the existing method and
> immediately use into it -- would make Moya more end-to-end by covering the
> final distance.
>
> ‚Äî
> You are receiving this because you are on a team that was mentioned.
> Reply to this email directly, view it on GitHub
> <https://github.com/Moya/Moya/issues/950#issuecomment-278202738>, or mute
> the thread
> <https://github.com/notifications/unsubscribe-auth/ADo1dCOtObOkVw2WqdCSy7OdpQJyvrHmks5raRzJgaJpZM4L2xjp>
> .
>
 > I love XKCD, and assume people are taking the moment to laugh at this classic.

@michaelsand Yes, I was honestly laughing at the comic itself, no intention to make fun of your proposal. Apologies if it sounded that way.
 I was just happy that I wasn't the only one laughing about the state of JSON deserialization in Swift! :) Your ideas are truly welcome @michaelsand. This is what pushes the project forward. @michaelsand I'm sorry about how l made you feel by posting a comic. I had no intention of disrespecting you, or the proposal you clearly have put a lot of thought into.

I'm not working right now, so I haven't been spending as much time keeping up with the project, when I glanced at your issue in an email it was the first thing my mind jumped to.
I should have provided substantive feedback, and put greater thought into how simply posting a comic would have come across in this situation.

I hope I haven't tainted your opinion of this community and that you're still excited to contribute to this project. I'm still 100% against Moya taking an opinionated stance on how to handle responses. It's easy for us to extend the `Response` type with more properties from the `NSURLSession` or even the `NSHTTPResponse`, but it gets incredibly nasty when we start saying "this is how you really wanted the data to be" and start adding all sorts of JSON/XML/(insert response format here) parsers and types for handling those. The worst thing we can do, by providing a native parser, is force it on our users, thus removing the flexibility of the library and introducing some wild wild west for working around such an opinion.

As @sunshinejr mentioned, there's still going to be some abstraction implemented. With the reactive providers, you can easily extend the reactive types to process the response, and I think that consumers of the default `MoyaProvider` should be doing the something similar.

One implementation suggestion is to provide serialization closures, which get passed to the `MoyaProvider`:
```swift
func zenResponseHandler(result: Result<Moya.Response, Moya.Error>) {
  /// Handle the zen response
}

provider.request(.zen, completion: zenResponseHandler)
```
Another suggestion would be to extend the `MoyaProvider` and implement your own `request` methods:
```swift
extension MoyaProvider {
  func requestZen() -> Result<MyResponse, MyError> {
    return provider.request(.zen) { result in
      /// Process the response
    }
  }
}
```

I completely understand the motivation, but what I've found in the multiple projects and applications I've built that use Moya is that there is no single one-size-fits-all solution. Never have I pulled a serialization layer from a previous project and used it in a future project.

*EDIT:*
As OP mentioned, wouldn't it be possible to just extend the `Response` type to provide custom mapping functions to transform to custom types?
```swift
extension Response {
  func mapObjects<T>() -> throws [T] {
    guard let myResponseType = MyType(data) else { throw .mapError }
    return myResponseType
  }
}
``` FWIW, my perspective is that of a `ReactiveMoya` user. I guess the way I'm viewing Moya is that it takes in a `TargetType` and it gets you a `Response`. I get the response, check it for errors, map it into some result and send it on it's way.

Taking on @colinta's challenge for a dissenting opinion:

```swift
public func authenticate(type: AuthType, username: String, password: String) {
    provider.request(.auth(type, username: username, password: password), completion: { result in
        do {
            let response = try result.dematerialize()
            let authToken = try response.mapAuthenticationResponse()
            /// Store the auth token
            /// Update the UI
        } catch let error as AuthenticateError {
            /// Show an alert
            self.showAlert(title: error.title, message: error.message)
        } catch {
            /// Handle other errors
        }
    })
}

extension Moya.Response {
    func mapSwiftyJSON() throws -> JSON {
        let json = try mapJSON()
        return JSON(json)
    }
    
    func mapAPIResponse() throws -> MyAPIResponse {
        let json = try mapSwiftyJSON()
        return MyAPIResponse(json: json)
    }
    
    func mapAuthenticationResponse() throws -> String {
        do {
            let response = try mapAPIResponse()
        } catch {
            throw AuthenticateError.underlying(error)
        }

        if response.isError {
            /// Parse and throw an Authenticate Error
            throw AuthenticateError.invalidPassword("Password is invalid")
        }
        
        if let authToken = response.data["authToken"] {
            return authToken
        }
        
        throw AuthenticateError.invalidToken("Could not find valid auth token")
    }
}

enum AuthenticateError {
    case invalidToken(String)
    case invalidUsername(String)
    case invalidPassword(String)
    case underlying(MoyaError)
    
    var title: String {
        return "Uh-oh"
    }
    
    var message: String {
        switch self {
        case let .invalidPassword(message):
            return message
        case let .invalidUsername(message):
            return message
        }
    }
}
```

The more I look into this, the more I realize that this is just a recreation of what the reactive users already have (in terms of [this](https://github.com/Moya/Moya/blob/master/Sources/ReactiveMoya/ReactiveSwiftMoyaProvider.swift#L26-L34)).

I think this is mostly an improvement for the users who don't use any of the extensions. I like the opt-in/opt-out functionality, and the non-breaking aspect of it. I guess my main point is that this functionality is currently achievable by extending the `Response`, though it's not immediately obvious.

*Edit*
Updated to reflect concerns from @michaelsand regarding throwing errors of certain types... I really dislike the concept of `throw`ing in Swift because, in most cases, you have to have domain information to know what kind of Error the function is going to throw, given the fact that the `Error` type isn't dictated in the method signature. We've bumped up against the limit of what is possible with generics in Swift. The compiler needs type information sooner or later. IMO the safest and DRYest way to do that is to wrap the provider in an object that provides type information and deserialization. I know it doesn't feel as nice as we'd like it to, but neither does the unconstrained polymorphism of the other options or creating one `TargetType` per return type. The above options can help you write that wrapper, but I would say a better separation of concerns is to put the extension on the response deserializer itself by allowing it to ingest `Data` and then pass it `Response.data`. Alternatively you could just use the output from `mapJSON`, a dictionary that nearly all the libraries support.

As an aside, I assumed that the reason we don't see `dematerialize` used more often was that we were using `Alamofire.Result` and not `Result.Result`. [I see I am wrong](https://github.com/Moya/Moya/blob/master/Sources/Moya/MoyaProvider.swift#L2). We should probably add that to our Cartfile explicitly instead of relying on it being there (from ReactiveSwift, I think). I'll open up a PR for that. @scottrhoyt Comment on your aside regarding Result: We need to be mindful about the version numbers. Since ReactiveSwift also relies on it, we need to keep that in sync with their version, especially for the users that are using the binary distribution (i.e. me). @michaelsand I agree with a lot of what you said, especially around the free-floating `AuthenticateError`. However, I don't think calling the other functions is a deal, particularly because the `Error` stays as a `MoyaError` until you hit the `mapAPIResponse()`.

 As I mentioned, it's not the prettiest in regards to error handling, but that could easily be changed to work like so (this is untested sudo-code, my brain compiler gives it the üëç):
```swift
extension Response {
  func mapAuthenticationResult() -> Result<String, AuthenticateError> {
    do {
      let authToken = try mapAuthenticationResponse()
      return .success(authToken)
    } catch error as AuthenticateError {
      return .failure(error)
    } catch {
      return .failure(.underlying(error))
    }
  }
}

```
IMO, the most valuable part of the `parser` function is the type information that can be provided.

That said, since we would be changing the call site to pull the correct parser and apply it, I'm leaning with @scottrhoyt that we should just wrap the provider and modify it to work accordingly with completion blocks.

Wrapped Example:
```swift
struct NetworkProvider {
  struct Parsers {
    static func authentication(type: AuthType) -> ((Moya.Response) -> String) {
      return { response in
        /// Transform response
      }
    }
  }

  var provider: MoyaProvider<MyAPI>
  func request(target: MyAPI, parser: (Moya.Response) -> T, completion: Result<T, MoyaError>) {
    provider.request(target) { result in
      do {
        let response = try result.dematerialize()
        completion(.success(parser(response)))
      } catch {
        completion(.failure(.underlying(error)))
      }
    }
  }
}

let provider = /// Create some provider
let networkProvider = NetworkProvider(provider)

networkProvider.request(.auth(.signIn, username, password), NetworkProvider.Parsers.authentication(.signIn)) { result in
  /// TODO: Handle the result
}
```
In-line Example:
```swift
public func authenticate(type: AuthType, username: String, password: String) {
    let parser = Parsers.authentication(type)
    provider.request(.auth(type, username: username, password: password), completion: { result in
        do {
            let response = try result.dematerialize()
            let authToken = parser(response)
            /// Store the auth token
            /// Update the UI
        } catch let error as AuthenticateError {
            /// Show an alert
            self.showAlert(title: error.title, message: error.message)
        } catch {
            /// Handle other errors
        }
    })
}
``` Thank you @michaelsand for the thoughtful idea and discussion. I personally would love to have you contribute to Moya wherever/whenever you'd like! I'm gonna close this one for now since there is no activity, but feel free to reopen it whenever.  Cool project! Thanks a lot for contributing to Moya! I've invited you to join the Moya GitHub organization ‚Äì no pressure to accept! If you'd like more information on what that means, check out our [contributor guidelines](https://github.com/Moya/contributors) and feel free to reach out with any questions.  I share your desire to find a way to inject return type information into the `TargetType`s themselves, @michaelsand. This is definitely a creative approach to doing so within the constraints that Swift gives us. On the other hand, it adds considerably complexity. What I would ask is do you think this system of callbacks is better than injecting the type information in a wrapping layer? Something like this:

```swift
class GitHubClient {
  let provider = MoyaProvider<GitHubApi>()

  func getZen(completion: (Result<String, Error>) -> Void) {
    provider.request(.zen) { completion(parseString($0)) } // using your `parseString` function
  }
}
```

I understand this approach is removing the return type information from the `TargetType` by a degree, but I think the advantage is a simpler `TargetType` set up and simplicity at the call site while not expanding the API surface area. The other advantage to the wrapper approach is that the pattern is compatible with `RxMoyaProvider` and `ReactiveMoyaProvider`. It is hard for me to see the direct analog for the callback solution you proposed. That is an interesting idea. However, if the `parseAndComplete` `completion` isn't strongly typed, then you still need to supply the type information for the response deserialization at the call site with no compile-time guarantees. In general, that is a similar situation as we are in right now when using the Moya extensions for object deserialization. 

Also, while it is a natural extension to have a `TargetType` provide information on what return type is expected, I think it might be going too far to have `TargetType` also provide the information on how to deserialize a `Response`. Right now `TargetType` knows nothing about how requests are processed, and this proposal would suggest that it become aware of at least `Response` and the mechanisms used to deserialize it (likely a 3rd party library). This responsibility seems better placed at the `MoyaProvider` layer or above.

The proposal then comes down to:
1. Establish a way to document what return type is expected in `TargetType`
2. Provide better completion handler usability for `MoyaProvider` when both the return type and method of deserialization are known

I think 1 can be accomplished in any number of ways. I would say 2 is up to the creators of Moya extensions since I don't see any reason why they can't create a similar extension on `MoyaProvider`.

Because of the impedance mismatch between a weakly typed internet and a strongly typed Swift, it will always be incumbent on the developer to introduce the specific knowledge necessary to resolve that discrepancy. I sadly don't see a way of ever providing a generic construct for that if the tool is an `enum`.  As discussed in #946 Now we're at it, how do the Reactive extensions work with SwiftPM? I think we can keep it as `pod 'Moya'` (we always want people to be using the latest version, I feel) Yeah, that might be even better. Does SwiftPM work like that as well? It seems like we need to at least provide a `majorVersion` [there](https://github.com/apple/swift-package-manager/blob/master/Documentation/Reference.md#package-dependency).  Fixes #942  Good point @bjarkehs; we actually rely on Alamofire 4.1 (https://github.com/Moya/Moya/pull/797) Changes seem good üíØ 

Should we plan a new release or is it too soon? Makes sense to do a patch release I think üëç  Seems like a problem with these lines in Podspec:
```
ss.dependency "RxSwift", "~> 3.1.0"
ss.dependency "Alamofire", "~> 4.2.0"
```

change to `~> 3.0` and `~> 4.0` accordingly, could fix the problem, but there might be a reason why we have it this way (I'm out of the loop lately). Because of this we should discuss the fix with @Moya/contributors first. We could just higher up the versions of pods as well. Let's see if we can update our dependencies. It would actually be really nice to have some sort of dependency update check somewhere to keep us up to date. What do you think, @Moya/contributors? Should I create a separate issue? Or we should do what @sunshinejr suggested, using just `~> 3.0` and `~> 4.0` respectively. Not sure what is the best option here. I would go with @sunshinejr's suggestion for the time being. @andreyfel Moya 8.0.2 was release and should fix your problem. Can you please update and let us know if you still have issues? :wink:  Fixes #811 

@ashfurrow [gave us the answer](https://github.com/Moya/Moya/issues/792#issuecomment-262812613) in #792: the semver regex should accept an optional `-beta.a`.

I didn't hardcode it `beta` to give us the flexibility to go with `alpha`, `rc` or whatever makes sense in future versions.  Nice! üôå  This looks pretty interesting @migue1s. Do you think it's related to #819 as well?

It would be really awesome if you'd make a Pull Request with your change, so people can discuss your solution, and we can get your bug fixed! @migue1s, @vaunus the problem with double `onNext` event after `filterCompleted` should be resolved after #1095. We still need to find the issue with hanging in the progress. If any of you guys have time and want to help us, PR would be greatly appreciated. This issue has been marked as stale because it has not had recent activity. It will be closed if no further activity occurs. 
 This issue has been auto-closed because there hasn't been any activity for 59 days. However, we really appreciate your contribution, so thank you for that! üôè Also, feel free to [open a new issue](https://github.com/Moya/Moya/issues/new) if you still experience this problem üëç.
 Hey @PatrickSCLin, do you still encounter double `onNext` event? What version of Moya do you use? Is it with RxSwift? Would you be able to make a new test project where this issue happens, @PatrickSCLin?  Thanks a lot for contributing to Moya! I've invited you to join the Moya GitHub organization ‚Äì no pressure to accept! If you'd like more information on what that means, check out our [contributor guidelines](https://github.com/Moya/contributors) and feel free to reach out with any questions.  Since your friend's website builds page URLs using query parameters, you will probably want to use the `parameters` property to supply this information as well:

```swift
var path: String {
  return ""
}

var parameters: [String: Any]? {
  switch self {
    case .index(let page):
      return ["action": "index", "page": page]
  }
```

and make sure you use a `URLEncoding` for `parameterEncoding`. Expanding @scottrhoyt response:

```swift
enum MobileAPI {
    case index(page: Int)
}

extension MobileAPI : TargetType {
    public var baseURL: URL { return URL(string: "http://mobileapi.blah.info")! }

    public var path: String {
        return "/1/"
    }

    public var method: Moya.Method {
        return .get
    }
    
    public var parameters: [String : Any]? {
        switch self {
            case .index(let page): return ["action": "index", "page": page]
        }
    }
    
    public var sampleData: Data { return Data() }
    
    public var task: Task { return .request }
    
    public var validate: Bool { return true }
    
    public var parameterEncoding: Moya.ParameterEncoding { return URLEncoding.default }
}
```

Usage:

```swift
        let mobileAPIProvider = MoyaProvider<MobileAPI>()

        mobileAPIProvider.request(.index(page:1)) { result in
            switch result {
            case let .success(response):
                // do something with response
            case let .failure(error):
                print(error)
            }
        }
```

This produces the request you want:
`["Moya_Logger: Request: http://mobileapi.blah.info/1/?action=index&page=1"]`

Let us know if you have more questions :wink:  Hey @tosbaha, thank you for making an issue üòâ 

I'd recommend starting out by taking a look at #748. I had a discussion with someone else who had a similar questions about Authorization.
After that, take a look at @scottrhoyt's contribution (https://github.com/Moya/Moya/pull/893). It has a plugin for AccessTokens.

For loading a resource with retryability, it's as simple as `.retry(2)` (to retry twice when you're using RxMoya). Moya doesn't offer any custom functionality for retrying, so all of your retrying has to be done through RxSwift. There are some great resources for using RxSwift's retry, that you can find in the first couple resources [here](http://lmgtfy.com/?q=rxswift+retry)

Come back with any lingering questions you have üòÑ 
We'll be happy to help you out Closing this due to inactivity, let us know if you still need help @tosbaha   This is an interesting proposal. I'm curious what other @Moya/contributors think.

My initial reaction is that this decomposition of `TargetType` would only be truly valuable if the separate protocols were useful for something other than being inherited by `TargetType`. If we are saying that all these things are necessary to have a `TargetType` and they aren't useful for anything else, then I maintain that they should be part of the `TargetType` itself.

The primary benefit of this decomposition is to provide a framework for structuring your implementation of `TargetType`, but it is a very loose framework at that since I could also do this:

```swift
extension GitHubUserContent: TargetType, TargetURLType, TargetHTTPMethodType, TargetParametersType, TargetSampleDataType, TargetValidationType {}

extension GitHubUserContent {

  public var baseURL: URL { return URL(string: "https://raw.githubusercontent.com")! }
  public var path: String {
    switch self {
    case .downloadMoyaWebContent(let contentPath):
      return "/Moya/Moya/master/web/\(contentPath)"
    }
  }
}

extension GitHubUserContent {

  public var method: Moya.Method {
    switch self {
    case .downloadMoyaWebContent:
      return .get
    }
  }
  public var parameters: [String: Any]? {
    switch self {
    case .downloadMoyaWebContent:
      return nil
    }
  }
  public var parameterEncoding: ParameterEncoding {
    return URLEncoding.default
  }
}

extension GitHubUserContent {

  public var sampleData: Data {
    switch self {
    case .downloadMoyaWebContent:
      return animatedBirdData() as Data
    }
  }
}

extension GitHubUserContent {

  public var task: Task {
    switch self {
    case .downloadMoyaWebContent:
      return .download(.request(DefaultDownloadDestination))
    }
  }
}
```

And neither of these strike me as having much more benefit than what is possible now:

```swift
extension GitHubUserContent: TargetType {}

// MARK: - URL construction

extension GitHubUserContent {

  public var baseURL: URL { return URL(string: "https://raw.githubusercontent.com")! }
  public var path: String {
    switch self {
    case .downloadMoyaWebContent(let contentPath):
      return "/Moya/Moya/master/web/\(contentPath)"
    }
  }
}

// MARK: - Method and Parameters

extension GitHubUserContent {

  public var method: Moya.Method {
    switch self {
    case .downloadMoyaWebContent:
      return .get
    }
  }
  public var parameters: [String: Any]? {
    switch self {
    case .downloadMoyaWebContent:
      return nil
    }
  }
  public var parameterEncoding: ParameterEncoding {
    return URLEncoding.default
  }
}

// MARK: - Sample Data

extension GitHubUserContent {

  public var sampleData: Data {
    switch self {
    case .downloadMoyaWebContent:
      return animatedBirdData() as Data
    }
  }
}

// MARK: - Tasks

extension GitHubUserContent {

  public var task: Task {
    switch self {
    case .downloadMoyaWebContent:
      return .download(.request(DefaultDownloadDestination))
    }
  }
}
``` If the goal is to decrease the verbosity in a `TargetType` file, my recommendations would be to consider:
* Break up the API into multiple `TargetType`s, separated by file
* Potentially separate large `TargetType`s into multiple files. `parameters` and `sampleData` might be profitable opportunities to introduce another file.
* Use an approach similar to suggested in #861 for defaulting the trivial properties for a specific `TargetType`. Great! Thanks for following up @manas-chaudhari. That's actually an approach I wind up using as well!  Glad to hear. Thanks!  The build badge was reflecting the status of the latest build in Circle CI, which very often is not on branch `master`.

This changes the badge to reflect the status of `master`.

  This pull requests adds a progress parameter to the reactive providers to track progress changes of upload & download tasks. Currently it's impossible to track these changes and to use the same Moya provider for download & upload tasks. Ah indeed, I've fixed that. Also updated for the SwiftLint issue. Two tests seem to be failing:
```
a_subsclassed_reactive_provider_that_tracks_cancellation_with_delayed_stubs__cancels_network_request_when_subscription_is_cancelled, expected to be true, got <false>
```
```
provider_with_SignalProducer__a_subsclassed_reactive_provider_that_tracks_cancellation_with_delayed_stubs__cancels_network_request_when_subscription_is_cancelled, expected to be true, got <false>
``` Hmm, you're right. It's strange though, as it's executing exactly the same request method, only with the progress parameter added.

I'll look into it further tomorrow! Ok, I've fixed the tests, everything seems to be OK now. The only thing I want to discuss here, is that another solution is already available for progress tracking:

```swift
func requestWithProgress(token: Target) -> SignalProducer<ProgressResponse, MoyaError>
```

However, this doesn't really fit in our JSON parsing functionalities and needs some more code to write on our side to make it easy to track progress.

With this pull request we're introducing another way of tracking progress, which is quite more easy to use and feels simpler.

How do you guys think about this?
 The implementation in the PR makes sense to me. I am all for any suggestions to make the progress handling more straight forward in the reactive providers. However, I am not sure this is the right direction to take. A goal of the observer pattern is to replace the callback pattern. So, to have our reactive providers use elements of both the observer pattern and the callback pattern seems muddled to me. This would encourage the propagation of both observables and callbacks in the users' code.

Perhaps we could refine the current approach with `ProgressResponse`? Instead of it being a `struct` with a `Response?` and a `Progress?`, it could be:

```swift
enum ProgressResponse {
  case progress(Double)
  case response(Response)
}
```

That would simplify handling of progress/response emissions. In fact, we could go further and provide reactive operators like `onlyProgress()` and `onlyResponse()` that could flatmap the `Observable<ProgressResponse>` into a `Observable<Double>` and `Observable<Response>`, respectively. This would go further to support separating the flow of progress and response without needing to introduce inconsistent patterns.

While the change to `ProgressResponse` would be a breaking change, we could still provide those operators right now as an easier way to deal with `ProgressResponse` until we migrate to the `enum` approach in 9.0. Oops @leoneparise. I totally missed that we had the `filterCompleted()` and `filterProgress()` operators already. Thanks for pointing that out! I'm not sure the naming is unambiguous though (e.g. RxOptional's `filterNil()` takes optionals out of the observable, we follow the opposite semantics). Good discussion, I agree with the above. We'll look further into implementing it using the suggested methods. Thanks!  Hi guys i am using newest Moya version and swift 3.0
I have question, can we return some values in a function which will call a provider request ?
I need it bcs i will use that values in objective-c bridging, since i will use it for react-native .
The below code i use always return "" instead of dict that will be filled inside provider.request

```swift
public func setupRx() -> Any {
        
        provider = RxMoyaProvider<GitHub>()
        var dict : Any? = ""
        
        provider.request(.bible).subscribe { event in
            switch event {
            case let .next(response):
                //image = UIImage(data: response.data)
                do{
                    dict = try response.mapJSON()
                    try print("Dict is : ", dict)
                }catch {
                    print("Something wrong");
                }
            case let .error(error):
                print("Error : ",error)
            default:
                break
            }
        }
        return dict
}


//BRIDGING CODE in Obj-C for react-native

RCT_EXPORT_METHOD(connectToHub
                  
                  :(RCTPromiseResolveBlock)resolve
                  :(RCTPromiseRejectBlock)reject)
{
    RCTMain * helloWorld = [RCTMain newInstance];
    //call setupRx
    NSString *test = [helloWorld setupRx];
    //always nil never get the value from API that has been called inside setupRx
    NSLog(@"Test Dictionary return : %@", [helloWorld setupRx]);
    [self.bridge.eventDispatcher sendAppEventWithName:@"onHubConnected" body:nil];
}
```
Thank you..
 @vzsg Thank you so much sir.. Your solution using completion block is worked. Now i could get result in my obj-c bridging..  That's a good question, @gunterhager.

Before we investigate making this information available via the request closure, can you see if creating a custom `PluginType` would suit your needs? A `PluginType` has a `prepare` function that is called once the `URLRequest` has been created and is given an opportunity to return a modified request. `prepare` also accepts the target, so I believe you have the information needed there to meet this use case. What do you think? Great @gunterhager! Happy to help.    As seen in #923, some paths are now incorrect, as we changed the project's structure as part of supporting SPM.  Thanks a lot for contributing to Moya! I've invited you to join the Moya GitHub organization ‚Äì no pressure to accept! If you'd like more information on what that means, check out our [contributor guidelines](https://github.com/Moya/contributors) and feel free to reach out with any questions.  Fixes #757

The issue on Circle CI [was fixed](https://discuss.circleci.com/t/os-x-build-image-update-xcode-8-2/9355) :tada:

I had to make a few changes to include not only the device name but also the OS version. Not sure if I took the best approach, suggestions are welcome :wink: Another idea for how to make this run a little smoother is to swap out the `build test` [here](https://github.com/Moya/Moya/pull/922/files#diff-52c976fc38ed2b4e3b1192f8a8e24cffR117) for a `build-for-testing test`. I have noticed better results that way as it delays the call to open the simulator until the test target has already been built. Therefore you are less likely to have a timeout issue.  Hey @Tolriq, this is not a stupid question at all. The behavior you are experiencing is not very well defined. The basic issue is that your `RxMoyaProvider` is being deallocated before the request can be processed. This is because it is a local variable that goes out of scope and the `Observable` it produces does not retain the provider strongly. This is related to #844 and the behavior that was changed in #905.

Since the new behavior hasn't been released yet, try pointing your dependency manager at the `master` branch to see if it behaves how you are expecting it to.

Also, storing a provider locally may not be a bad idea regardless. But instead of dynamically creating a new one each time you call `kodiHostHaveAddon`, can you instead just create a single provider and use it in multiple requests?

 ```ruby
pod 'Moya', :git => 'https://github.com/Moya/Moya.git', :branch => 'master'
``` Glad to hear it worked, @Tolriq! No release date set, but given that this issue has come up a couple of times, I think this could warrant `8.0.1`, what do you think @Moya/contributors? @scottrhoyt 8.0.1 makes sense to me. Should we open an issue to discuss? Yeah, I'd say go for it @pedrovereza. Closing this @Tolriq. Let us know if you have any other issues.  #911 might provide some insight.  Possibly ref #911   I haven't tried this before, but looking [here](https://github.com/Moya/Moya/blob/master/Sources/RxMoya/RxMoyaProvider.swift#L61) it appears the request will be cancelled if the `Observable` is disposed. So can you try disposing the `Observable`? Was that able to help you out @GorbAnthony? If so, can you close this issue please? Thanks.  Good catch! Any idea what's up with [CI failing](https://circleci.com/gh/Moya/Moya/1177?utm_campaign=vcs-integration-link&utm_medium=referral&utm_source=github-build-link)? It seems like the identifiers for the simulators have changed?  Thanks a lot for contributing to Moya! I've invited you to join the Moya GitHub organization ‚Äì no pressure to accept! If you'd like more information on what that means, check out our [contributor guidelines](https://github.com/Moya/contributors) and feel free to reach out with any questions.  > The key deliverable here is the documentation.

Yup, this PR is only docs, which can only really help. I'm going to merge and we can refine later if we add first-class support into the library. Thanks again! Thanks a lot for contributing to Moya! I've invited you to join the Moya GitHub organization ‚Äì no pressure to accept! If you'd like more information on what that means, check out our [contributor guidelines](https://github.com/Moya/contributors) and feel free to reach out with any questions. Cool! I'm happy the community saw value in this. @manas-chaudhari, we'll look for your next PR which implements the documentation we've added üòÑ   As @bjarkehs suggests, writing a custom `ParameterEncoding` could be a great idea. However, I might prefer searching for a `token` parameter to in `parameters` to url encode and then encode the rest as JSON--as opposed to taking the `token` as an initializer argument. However, that's a personal style and use case decision.

Another option would be to create a `PluginType` to do this. It would work similarly to `AccessTokenPlugin` so take a look [here](https://github.com/Moya/Moya/blob/master/docs/Authentication.md#bearer-http-auth) for docs and [here](https://github.com/Moya/Moya/blob/master/Sources/Moya/Plugins/AccessTokenPlugin.swift) for implementation. I'll close this issue since it's been inactive for a while. Feel free to reopen if you still have questions, @kristiyandobrev @kristiyandobrev I think what you're looking for is what @scottrhoyt suggested:

>I might prefer searching for a token parameter to in parameters to url encode and then encode the rest as JSON.

Basically, if you have an endpoint like:

```swift
enum API {
    case example(id:String, name:String, lastName: String)
}
```

In order to make a request to `api/resource/:id` passing `name` and `lastName` as json body, you have to:

* Encode `id` on the url

```swift
    public var path: String {
        switch self {
        case .example(let id, _, _):
            return "api/resource/\(id)"
        }
    }
```

* Pass `name` and `lastName` as parameters

```swift
    public var parameters: [String : Any]? {
        switch self {
        case .example(let _, let name, let lastName):
            return ["name": name, "lastName": lastName]
        }
    }
```

* Encode parameters as json

```swift
    public var parameterEncoding: Moya.ParameterEncoding { 
        switch self {
        case .example:
            return JSONEncoding.default 
        }
   }
``` @kristiyandobrev were you able to make the request as you wanted?   As discussed in #907  I was more concerned with this before RxSwift and ReactiveSwift were reliably offering framework downloads. I think it is less of an issue now. There are still some benefits to not expanding our users' dependency graphs, but I think those are outweighed by the additional maintenance and release coordination headaches that will come will the 3 repo approach. I'd love to see carthage offer an option similar to a subspec (especially since it is possible with SPM), but I recognize that is going against the grain of carthage's simplicity. Yup, I agree with @scottrhoyt, it seems like a non issue now. 

Feel free to re-open if anyone would like to go into this further üòÑ   Hmm, this means we should use:

```
github "Moya/Moya"
```

for Moya,

```
github "Moya/Moya"
github "Moya/RxMoya"
```

for RxMoya, and

```
github "Moya/Moya"
github "Moya/ReactiveMoya"
```

.. right? If that's the case, we might want to add these examples as we did with CocoaPods, to make it even more clear. @BasThomas, in order to do that we would need to pull those out in to separate repos. We've had that discussion before, and we can revisit it. The argument for keeping them all in one place is that it's far easier to maintain. But I'm not doing much maintenance nowadays, y'all are, so we can split them up if that's what the team thinks is right.  It's not an bad idea. At least from the perspective that `RxSwift` and `ReactiveSwift` are heavyweights and allowing our carthage users the choice of whether or not to include them in their dependency graph could be nice. It does create a whole set of maintenance headaches though. üò¨ So it's no clear win. Aye, that's the tradeoff: it's easier for Carthage users but harder for us. Moya's benefited from a tonne of community contributions, and the easier we can make that the better. But I don't like shifting the burden to users either. This could be something to discuss in a Hangout or Skype call, let me know and I can organize it.

EDIT: Though we should take into account the likely shift away from CocoaPods and Carthage towards SPM, which works with the current set up.  I think I'm partial to leaving them as is for the time being. A lot has changed in the structure of this project and we just released 8.0.0. This would mean 9.0.0 right away, and more maintenance. Let's hope that Rx and Reactive continue to provide reliable framework downloads and that we get ABI stability sooner rather than later to ease the burden on the users.

I'm open to changing that opinion though and would be available to do a call as well. As a Carthage user, I'm very fond of switching into two separate repos, but as @ashfurrow mentioned, there's an impending shift towards the native package manager. Any work spent breaking up the repos is likely to conclude with SPM becoming widely adopted.

I'm in favor of keeping it as is, unless there was some tricky configuring we could do with `Cartfile`s in separate repositories.

i.e.:
Moya/ReactiveMoya hosts a repo with a Cartfile that specifies reliance on a specific branch of Moya, which includes a `Cartfile` for those dependencies.

Cartfile in Moya/ReactiveMoya
```
github "Moya/Moya" "reactive-moya"
```

Cartfile in Moya/Moya on "reactive-moya"
```
github "ReactiveCocoa/ReactiveSwift" ~> 1.0
/// ... The remainder of Moya's dependencies
```

However, this feels like it has it's own set of problems I haven't fully considered... Hmm. With regards to the move towards SPM, I just want to make sure we don't put the cart before the horse. There are currently severe limitations to using SPM in building an App for Apple platforms. From what I've read, the story *may* be different come Swift 4.0 in late 2017. Am I missing something? Because it seems like we're the better part of a year and 100,000s of collective builds away from being able to consider being SPM-first. Is there some news I'm not aware of in terms of the SPM roadmap?

BTW, I am guilty of hijacking this PR. Which looks good to me!  üòâ No, we're on the same page. This has been on the table for the better part of a year and a half while I've been contributing.

The only real pain point comes from waiting on Carthage to build dependencies that aren't in use. That can be mitigated (in part) by distributing binary frameworks, but that's always dependent on the build system used at the point of distribution (nothing like waiting 30 minutes for your dependencies to build only to have it fail because a binary distribution was compiled with Swift 3.0 instead of Swift 3.0.2).

it's a tough problem, because it's only relevant to our Carthage users. CocoaPods users have had this ability pretty much since the libraries inception. Any changes that are made for Carthage users can't effect CP users, I learned that the hard way when I came on. One of my first in-depth PRs broke CP support while attempting to address this issue.

We totally hijacked the thread. I think the PR looks good, and is required instruction. I'm good to merge in, and we can open an issue to further this discussion... in fact, I think there already is one somewhere... Thanks a lot for contributing to Moya! I've invited you to join the Moya GitHub organization ‚Äì no pressure to accept! If you'd like more information on what that means, check out our [contributor guidelines](https://github.com/Moya/contributors) and feel free to reach out with any questions. I *am* open for providing multiple repo's to make the users' lives easier. I think SPM will still take a while to catch on, and in the meantime, I think we should consider this. Would gladly join a call to discuss the implications. I feel like keeping them together is the easiest thing to do right now. I've felt bullish on SPM for over 6 months now, but I do know using it is still a ways out.

I'm down for a call as well, but I think we should let this sit until someone else brings it up (unless one of you feel very strongly about making the change to multiple repos). Hopefully then we'll have a more informed perspective on the possibilities of SPM at that point    Hmm. That's interesting. I'm thinking about what should be the correct behavior here.

Maybe the Observable should strongly capture the `RxMoyaProvider`? It seems like the ability to make the request should be tied to the lifecycle of the `Observable`, not of the provider. Any other thoughts @Moya/contributors? This PR makes sense to me, we should probably have been doing this from the start üëç @sadiq81 could you add a changelog entry for us? Thanks for the PR! @sadiq81 Thanks a lot for the pull request! Would you mind adding a note to the changelog?  @sadiq81 In your master branch, add a line to `Changelog.md` at the top that describes the bug you fixed. Commit it and push it up to add it to this PR üëç I think I agree with @scottrhoyt, it doesn't seem best practice to strongly capture the provider when making a request.
The provider should be held on by some other object, and the response should only be acknowledged if the provider is still listening for it.

This may be sort of nitpicky though. Merging this would make the common case simpler (why is my request never responding), but could potentially create memory leaks for more complicated implementations (I set my `provider = nil`, but I can see that it hasn't been deallocated, wut)  Aye. I'm leaning towards merging this, the common case makes sense to optimize for. Let's give it one more day to discuss objections, but I think we've covered everything now.  Thanks a lot for contributing to Moya! I've invited you to join the Moya GitHub organization ‚Äì no pressure to accept! If you'd like more information on what that means, check out our [contributor guidelines](https://github.com/Moya/contributors) and feel free to reach out with any questions.  There are some features in #861 that would make this easier to do with Moya, but we haven't decided on whether to include them or not yet. If you are interested in including it yourself, you can take a look at how `SingleURLTarget` is implemented and can potentially use that in your own code.

Otherwise, I'd say Alamofire is the way to go. @dannymout were you able to solve this? Or should we keep this issue open? @scottrhoyt Well, I eventually figured this out, but if you can get this feature added, it would be useful.  https://github.com/Moya/Moya/issues/888#issuecomment-270403554  I got some feedback about our use of SPM, so I'm updating our package description and readme to reflect those changes. I might not have interpreted the feedback correctly, so feedback would be üëç Specifically:

- SPM ignores directories that start with `.`.
- Our sources are stored in `Sources` so we don't need to exclude `Demo` explicitly.
- `.Target(name: "Moya")` can be replaced with `"Moya"` for succinctness. This is a stylistic choice that's up for discussion.

Also updated our Swift version support matrix to reflect 8.0's final release (üéâ) Hmm, we might want to add a Danger rule to keep CP+Carthage+SPM in sync (as we did in #808).    A little bit of a nitpick üôà, but just updates the build shield to be the same style as the rest.  This adds some documentation around `Endpoint`, `Image`, `Response`, and `MultiTarget`. We might want to unify the header docs at one point just for consistency (only `///` or your approach with `/**`), but lets leave that for another time. Thus far my approach is to use `///` for single line documentation comments and `/**` for multiline documentation comments, but I agree we should make sure it is consistent. I was having trouble getting the markdown (e.g. `- parameters:` to correctly register on multiline with `///`. You might have to use `- parameter name: name does thing` per parameter with `///`: see http://ericasadun.com/2015/06/14/swift-header-documentation-in-xcode-7/. Ah, that might be it then. In that case, I think:

```swift
/**
 function

 - parameters:
    - x: Is an x
    - y: Is a y
*/
```

might be a touch more human readable than

```swift
/// function
///
/// - parameter x: Is an x
/// - parameter y: Is a y
```

Especially for many parameters. But that's just personal preference. I could go either way. I agree, but I think I like `///` above `/**`. üòõ   I think some changes from #884 may have been accidentally dropped in rebasing #880. I re-added the changes (thanks @petripartanen) and added some documentation to the error cases.  Just a small change to `EndpointSpec` to achieve higher test coverage through utilizing the convenience functions.    This is cleaning up a leftover after #885.  Following through with the promise of #813, this PR adds a new `PluginType` called `AccessTokenPlugin`. This plugin can be added to a `MoyaProvider` to add authorization headers of the form:

```
Authorization: Bearer <token>
```

By default, this plugin will add the auth header to all `TargetType`s. However, if you want to control this behavior, you can have your `TargetType` conform to `AccessTokenAuthorizable` and provide `var shouldAuthorize: Bool { get }`.  Good question; the properties of `MoyaProvider` are `let` because Swift encourages properties to be `let` by default. We've never had a reason to make them `var`. If you need to modify the behaviour of the `endpointClosure`, you can use an `if` statement in the closure that checks for a condition to behave one way or another, for example in a variable outside the closure. You can also attach that variable as an associated value on your Target enum class.

Hope that helps! Let us know if we can clarify anything.  Closing due to inactivity. Let us know if you still have questions, @EvilNOP :wink:  This Pull Request has been created for @Moya/contributors to discuss the pros and cons of a 2 xcodeproj vs 1 xcodeproj project structure.

Currently, we have two xcodeproj's in Moya. One, `Moya.xcodeproj` contains our source code and tests, and the other `Demo/Demo.xcodeproj` contains two example projects (`Demo` and `DemoMultiTarget`).

Here's what I think (and what was gathered from the conversation in #885)

### Pros of going one-project
1. Better discoverability of the demo projects - they're right there when you open Moya.xcodeproj and you don't have to dig for them
1. Simplicity of just having one xcodeproj

### Cons of going one-project
1. Having an example/demo project in separate sub folder and project is in line with CocoaPods best practices and most libraries do it this way
2. A higher potential for *.xcodeproj's merge conflicts. Keeping separate projects will allow people to contribute to Demo code and core library code simultaneously with less risk that the Carthage-driving project will get corrupted.

Its also worth noting that making this change will move us to will have the effect of making Moya more of a carthage-first library instead of cocoapods-first library, since the Demo code will by default be working off of a carthage integration and not a cocoapods integration Good notes describing the change ‚Äì my inclination is to move Moya towards being an SPM-first library, does this PR make sense in that context?  @ashfurrow I feel the same way, Carthage affords itself to SPM, and the project structure between the two are almost interchangeable.

Merging this PR would get us closer to that point. The lingering difference to make us truly SPM-first, would be 
1. To finish up #643
2. to use SPM to pull down dependencies ourselves, which we currently aren't doing, mostly because we don't have #643 merged, but also because SPM - as it is now - doesn't build `.frameworks`, it compiles to an executable (`*.build`). Here's what Result looks like compiled, for example 

<img width="881" alt="screen shot 2017-01-02 at 4 59 32 pm" src="https://cloud.githubusercontent.com/assets/3814772/21598197/f8e81fca-d10c-11e6-8ad6-86b03ec6ad41.png">

To be honest, I'm not sure how people are using SPM compiled dependencies for iOS apps, I've seen people that have dragged the `*.swift` files that SPM fetched into their projects, but not the `.build` files.
I don't think SPM is at that point yet, but when it is, we should be ready to go üòÑ  IMO Both directory/project structures are compatible with carthage and SPM. We can make carthage work with either structure and SPM doesn't really care about xcodeproj's. It is driven off of the sub directory structure under Sources and how that translates into modules. I don't think it uses projects at all-it can only generate a simple one if you ask it to.

This change will move us more out of line with CocoaPods standards as mentioned. And we should consider the consequences to testing the cocoapods integration and Demo project build. Changing documentation to instruct users to do a `carthage bootstrap` to try out the Demo project will also make Moya more carthage-first. @scottrhoyt you're right, both layouts are compatible with all 3 package managers. I've been using the word compatible when what I really mean is in the spirit of, which is definitely a matter of opinion, and not right and wrong.

I'm also biased since I've never really used CocoaPods (I started programming a couple months before Swift came out, and other than iOS hello world esque apps, I've always used Carthage). So the upside to have `Demo` in it's own directory is lost on me Thank you for the reviews. Do you want to take a shot at those changes @scottrhoyt? Otherwise I can take care of them some time tomorrow 

What do you guys think? Should we wait a couple days to see what the other contributors think?

As it stands now, this PR is only a matter of preference, it has no functional benefit. Perhaps in the future, when we're using the SPM to generate our xcodeproj, it might. But theres a chance that SPM will change their implementation in the interim, and having only 1 xcodeproj will not matter. Yeah, I totally get that. I haven't been a CocoaPods user in a while. It's been a change for me to work on a library that has--until now--been cocoapods-first.

For me the advantage has less to do with directory structure and more to do with merge conflicts. The rule of thumb is to break up the XML-based files (e.g. xcodeproj's and storyboards) into smaller files to minimize the conflict resolution mess. Gotcha, I do the same thing with my storyboards (the project Im working on now has 9). I hadn't thought of/heard of splitting up xcodeproj's to reduce merge conflicts. I'll look into that @AndrewSB, I can take a shot at those in the next couple of days. I have a couple of other things I am working on at the moment. I also need a bit of a break from making CI changes. Iterating on builds that take 10-20 minutes gets exhausting üò©. So if you'd like to take a stab first, then go for it and shoot me any questions you might have.

One of the things to decide is what the testing strategy looks like here. Previously we were testing that the Demo project built using CocoaPods (implicitly validating our pod). 

With this scheme, if we want to replace that functionality and/or do a carthage integration test as well, then we will need to write some integration tests as you suggested. Such tests probably involve generating a new xcode project for the Demo code on the fly, but there might be something more clever that can be done. I might also consider removing the "PRO" of 

> Swift package manager expects there to be one xcodeproj in the root of the project.

... because I don't think SPM cares about Xcode projects at all. You can have zero or many. It's just going to build what you tell it to in the directory structure and `Package.swift`. People less familiar with SPM might think this is getting us closer to SPM compatibility when we already are compatible and this is more of a stylistic/project philosophy choice.  Haha, I totally understand. Thank you for all you did speeding up CI, its noticeable üòÑ 

Yeah, we do need to rethink our package manager integration tests. 
Lets prioritize the 8.0 release while we wait for a couple more people to give us their thoughts, meanwhile thinking of how to better test.
I'm on a flight on Wednesday, so I can write those tests and validate locally while I don't have internet, and then we can finish this PR up towards the end of the week. I think thats enough time for everyone to give their thoughts.

You're right, I'll move that from the pros üòÑ  ## TODO

- [ ] Update circle.yml to pass, moving the Demo project expectation from `Demo/Demo.xcodeproj` to `Moya.xcodeproj`
- [ ] Write (hopefully parallelized) tests on CI to validate CocoaPods, Carthage & SPM validity (lets make this is **separate PR**)
- [ ] Update docs for new Demo project location & Carthage instead of CocoaPods instructions
 Currently we test the integrity of our CocoaPods integration by compiling the Demo project. By moving the Demo project to the main project, it will no longer be testing any integrations because it will use the local project instead. So if we don't add another integration test to this PR, it will be a regression.

Maybe a good way to break this up into PRs without regressing is to replace the integration test with another integration test and then open up a new PR that is concerned with the other two integration tests and parallelizing them. What do you think about that strategy? If we want to go SPM-first, we might also consider resolving #894. After changing structure to SPM-first, changing project to single target, now we can think about consolidating Demos. How do you feel about it, @AndrewSB? That sounds great! I can finish this up (probably) early next month, but anyone else who's motivated to make this happen should feel free to take charge üòä  This PR implements availability tags for the changed function names from the Swift 2 to Swift 3 migration.

This makes the lifes of users making the switch easier, as the compiler provides fix-its for the functions that need renaming (as seen [here](https://github.com/Moya/Moya/issues/888#issuecomment-270004469))

The tags added are as follows

- [x] Renamed endpointByAdding(parameters:httpHeaderFields:parameterEncoding) to adding(parameters:httpHeaderFields:parameterEncoding)
- [x] Renamed endpointByAddingParameterEncoding to adding(newParameterEncoding:)
- [x] Renamed endpointByAddingParameters to adding(newParameters:)
- [x] Renamed endpointByAddingHTTPHeaders to adding(newHttpHeaderFields:)
- [x] Renamed StructTarget to MultiTarget
- [x] Renamed notifyPluginsOfImpendingStub(request:) to notifyPluginsOfImpendingStub(for:)
- [x] Renamed request(token:) to simply request(:_) (ReactiveSwift)
- [x] Renamed filterStatusCodes(:) to filter(statusCodes:) (and filterStatusCode(:) to filter(statusCode:))
- [x] willSendRequest renamed to willSend
- [x] didReceiveResponse renamed to didReceive
- [x] Renamed ReactiveCocoaMoyaProvider to ReactiveSwiftMoyaProvider

~~The yet-to-be-done functions have been commented out:~~

- ~~`extension ReactiveSwiftMoyaProvider` has a `Use of undeclared type 'ReactiveSwiftMoyaProvider'` error;~~
- ~~`public func filterStatusCodes(range: ClosedInterval<Int>) throws -> Response` has a `'ClosedInterval' has been renamed to 'ClosedRange'` error.~~

~~... and I have no idea how to fix either of these.~~ Cool! Looks great. I'm fine with leaving those commented out for documentation's sake, up to you. Could we provide an empty `ReactiveSwiftMoyaProvider` implementation that's marked as unavailable maybe?  But we **do** [use it](https://github.com/Moya/Moya/blob/ea331f79c534db1334b93b0d5526bfeb5227a6d1/Source/ReactiveSwift/ReactiveSwiftMoyaProvider.swift#L8), and it should not be unavailable, right? And if we do leave them commented out, I'd like to add an explanation for that before merging. It would also be **awesome** if somebody could test this (by converting a pre-8.0.0 project to this branch. Hmm, I suppose we can just fix `public func filterStatusCodes(range: ClosedInterval<Int>) throws -> Response has a 'ClosedInterval' has been renamed to 'ClosedRange' error.` by changing `ClosedInterval` to `ClosedRange`, as the compiler will see that error first (probably?) and the signatures then match. Been able to fix the two remaining functions as well. Imported `ReactiveSwift` et voil√†.

If someone could help me squashing these commits, please let me know. Think it can use some cleanup, but I am not sure how to proceed myself. Welp, CI is failing. @scottrhoyt @AndrewSB any idea why the files can't be found? I get the same error building just the framework locally, using the `Demo.xcworkspace` works fine. I'll take a look, @BasThomas. I think when you merged `master` after #885 (c22ef57f6364a1d0efb304916b2acd3929852319), you resolved the merge conflicts in the Xcode project by inserting the old references back into the project along with the new ones. I think this should branch should be rebased off of `master` resolving those conflicts with the new references. Do you want to give that a try or I can do it if you'd like? Xcode project merge conflicts are üò≠. `Demo.xcworkspace` will still work fine because it uses a cocoapods integration that doesn't rely on the main Xcode project. If you could do so, please go ahead. I'd probably have closed this and started with a clean slate at this point, especially because there's only one file change. üôà

@`Demo.xcworkspace`: thought as much. Surely. I'll probably have that done in ~30 minutes. I will let you know. @BasThomas, I rebased and pushed to `swift3-availability-2` just so you can check to see if it still looks good to you. If it does, I will delete that branch and push here. Sound good? I also fixed some problems with combining Availability info for Moya and ReactiveMoya. Yes, looks good! Thanks for the help @scottrhoyt! I think this should be good to go now.  Oh, one more thing: we might want to move the `Moya.Error` unavailability tag to the `MoyaAvailability.swift` file instead of letting it "linger" in `MoyaErrror.swift`. Can someone review and merge? Also, I think we can release `8.0.0` once merged! üéâ Or we could just keep them. We'll see. :) I agree they will be a great addition for the migration and certainly useful for a while. But when the changes have sat for a while it might be nice to reduce the API surface area (primarily for code completion), reduce instances of `fatalError()` in the code base, and get a percentage point of test coverage back if no one needs them anymore. :)    This PR is meant to aid with #885. Also Closes #870. This is what is does:

* moves `Tests` to root dir
* moves test targets from Demo.xcworkspace to Moya.xcodeproj
* switches CircleCI to run tests from the main project
* adds a CircleCI task to build the Demo project
* greatly speeds up build time by caching carthage builds (~ 50%)
* fixes an error where `rake test:carthage` wasn't actually testing the current commit What I understand from this is 
1. You moved the tests into Moya.xcodeproj
2. You actually got the tests to run & updated Rake things, and cocoapods things, and implemented caching

If we could cherrypick all the` 2` commits from this branch onto `redo-spm-layout`, and then merge this into #885, then we'll have this PR done, and 2/3 of the TODOs on #855 done as well

If you're onboard with ‚òùÔ∏è, then I'll start helping choose which commits are needed, and we can revert/delete the ones implemented in #885 It's a little bit more than that. Let me take a stab at combining them. I know how to make the changes again. I'll push the commits right to your branch. awesome, I'll take a look üëç  I've deleted the branch; please restore if needed! All good. Thanks. Uneeded now.  Picks off where #698 left off. Closes #870.

My concerns:

- [x] **Test to make sure the project is still CocoaPods compatible** I'm not familiar with Cocoapods, so the new layout is done to Carthage & SPM best practices, but it would be awesome to have a cocoapods person test it and make sure everything still woks :)
- [x] **Update README**: I'm sure some of the instructions will have changed, locations of Demos & Tests, pulling down dependencies for Demos, etc.
- [x] **Update CI for new test locations**: The tests are currently failing because the tests CircleCI is expecting are no longer in the same. I also have them setup to pull dependencies down with Carthage instead, so we need to set that up. @BasThomas: I remember you offering to take a look

Future enhancements:
- Use `swift test` once #643 is merged
- [x] Implement the Carthage caching strategy @scottrhoyt & I discussed in #870 Cool. I actually just started a branch to work on the tests portion today. It also included migrating CircleCI to test out of Moya.xcodeproj and speeding up builds by caching carthage and fixing the problem from #870. Take a look and maybe we can figure out how to combine them üëç. Haha, I was actually editing my comment to add that as an enhancement!

I have 3-4 more commits to finish up on this PR, and after which I'll branch off to take a shot at #870. How far did you get? Haha. ü•á Priceless. 

Pretty much done on my end. I had to implement the cache because the builds slow down majorly once we need to use carthage for testing. I was just figuring out how to fix the `rake test:carthage` task so that it also would be speedier. I don't think it is really even doing what is intended right now since it's checking out an old tag instead of building the current commit. Take a look at `sh_move_tests` branch. I've also been testing it with cocoapods to make sure nothing breaks there and I added a new task to build the Demo project just to ensure it builds since nothing else is doing that now. Cool, that sounds great.

I'm going to get the tests building locally, and then I think I'm done with this PR.
I'm seeing a strange error with Result, have you seen anything like it?

<img width="993" alt="screen shot 2017-01-01 at 8 57 23 pm" src="https://cloud.githubusercontent.com/assets/3814772/21584770/f2ae4696-d064-11e6-8d15-b9eb26ce6ab6.png">

I made sure I was using a current version of Result (I have 3.1.0 checked out), I've never seen Result used without an error type specialization No, I haven't run in to that. Just opened up a PR to facilitate comparing and getting this all integrated. Build times are greatly sped up. üòÅ #886  FWIW, check out https://github.com/antitypical/Result/issues/77 for the Result error. Although you're specifying `Moya` here, I think it might still be a failed lookup between `Result` and `Alamofire`'s `Result` type. ü§î @scottrhoyt: sounds great! Oh wow, I just saw all the work you put into #886 üò´ I'm sorry about superseding it!
@BasThomas: thanks for the link, https://github.com/antitypical/Result/issues/77#issuecomment-231423891 was perfect  @scottrhoyt: I think this is ready to go. We just need to deal with the 3 TODOs above, and then add any learnings you have from #886 

For #886: We could either have fewer commits redone here, or you can rebase #886 onto this branch and we can merge it here. What do you think? No worries @AndrewSB. I actually have all 3 of those sorted in #886 already in addition to the cache improvements. Oh awesome! Should I close this then and help review your pull request instead?  Well, I only handled all the concerns on the testing side, I haven't done anything with the rest of the SPM work. So it might be easiest to rebase the rest of your SPM work off of my branch. But another option would be to try and port the other fixes I made to this branch. You started a lot of the SPM work, so I'm good to go either way. I'm just looking forward to faster builds and being able to run tests easier while developing! üëç  That sounds great to me too. Let me give your PR a look over to see what you've implemented so I can try to figure out what we should include from both @AndrewSB I finished combining our work. There were really only two areas where we conflicted:

* I kept the Demo targets where they were instead of moving them into the main Moya library project. If we leave it where it is, I don't think anything in the docs needs to change.
* We don't need to use a `carthage copy-frameworks` to copy the frameworks for test targets. A simple copy files build phase will do.

Let me know if you have a strong opinion on either of those.

All the other commits are just cleaning up, getting CircleCI working, and getting CocoaPods working. I checked again and can't find anywhere in the docs where paths need to be updated--as long as the Demo projects stay where they were. Let me know what you think and thanks for the teamwork! ü§úüí•ü§õ Fixed all the CI errors except this one from Danger:

<img width="2400" alt="screen shot 2017-01-02 at 1 40 14 am" src="https://cloud.githubusercontent.com/assets/4259250/21587050/af4652e0-d08c-11e6-97a5-fc8935679922.png">

Not quite sure what to do about that one. @ashfurrow mentioned [that might be a Danger bug](https://github.com/Moya/Moya/pull/861#issuecomment-269779701).  Just rebased this to fix merge conflicts.

@ashfurrow, do you have any idea on that Danger bug? @scottrhoyt I still have a feeling that an entry in the changelog will fix it ü§î  Thanks @pedrovereza! Let's see if that fixes it. @scottrhoyt this looks really great, awesome to come on and see that the PR's checks are passing üòÑ 

Reviewing code now @scottrhoyt: Really great work. This all looks good to me. 
Only thing that may be nice would be for us to squash some commits

I also saw that you marked README changes as done, but I didn't see any changes. Is that because they weren't required? I remember @scottrhoyt saying somewhere he thought it wasn't needed; can't seem to find it now though. I perused the documentation and have come to the same conclusion.
Well then the only thing left is for @scottrhoyt to squash some of his commits üòÑ then I think we're ready to merge this (assuming Danger is happy, I'm not sure how to see that status) Oh wait, I just noticed one thing: Previously, I had deleted the Demo.xcodeproj and .xcworkspace and moved everything into Moya.xcodeproj (the Demos were put into a Demo group inside Moya.xcodeproj).
Your merge, @scottrhoyt, seems to have undone that. Was that purposeful? Or should I redo the integration of the 2 xcodeprojs? Haha. It is a commit overload üôà. Some of those can definitely get squashed. I will take a look at that shortly.

Yeah, @AndrewSB, keeping the Demo project separate was intentional. There are a number of reason's I think it's good to keep them separate:

* Carthage is driven off of the main Moya.xcodeproj, so I think it's a good idea to keep that as lean as possible.
* Having an example/demo project in separate sub folder and project is in line with CocoaPods best practices and most libraries do it this way, so I think it is more in line with user expectations.
* Merge conflicts are not fun in *.xcodeproj's, so keeping separate projects will allow people to contribute to Demo code and core library code simultaneously with less risk that the Carthage-driving project will get corrupted.

What do you think are the reasons for putting the Demo code in the main project? Building the Demo project is also our current method of checking that CocoaPods didn't break. So if we combine the projects, we might need a different approach to that. Hmm... Having one xcodeproj is a strong opinion that I weakly hold. I'm willing to change, but here's what I think

> Carthage is driven off of the main Moya.xcodeproj, so I think it's a good idea to keep that as lean as possible.

It is, but Carthage only looks at the shared targets inside of Moya.xcodeproj. As long as we don't share the Demo targets, it won't have any impact on Carthage at all.

> Having an example/demo project in separate sub folder and project is in line with CocoaPods best practices and most libraries do it this way, so I think it is more in line with user expectations.

That makes sense for CocoaPods best practice. I wasn't aware of it.
I'm not sure about this, but I think most Carthage-first projects include the Demo within the same xcodeproj, and I think spm is the same way, especially with their `generate-xcodeproj` command. I'll do some research and get back to you

> Merge conflicts are not fun in *.xcodeproj's, so keeping separate projects will allow people to contribute to Demo code and core library code simultaneously with less risk that the Carthage-driving project will get corrupted.

Merge conflicts are a headache, but from my experience they're pretty rare. 
Apart from commits like this where we radically change project layout, most changes to xcodeproj's are just adding or removing a file. Which usually don't conflict, or if they do, are trivial to resolve by setting the merge strategy to union. Your point on validating cocoapods is real though.
Is there any way to validate cocoapods without having a separate xcodeproj?

How important do you think it is for us to run integration tests to make sure we're not broken through our package managers on every `master` commit?
 I've started to feel like it's (at least to some extent) overkill. And its going to be even worse when we're also validating that SPM works on each commit
I'm going to go back and see why we added the Carthage validation on each commit

Update: we added Carthage sanity checking in https://github.com/Moya/Moya/pull/630, and the reason why was because we missed https://github.com/Moya/Moya/issues/629.

What do you think about testing our package managers in parallel? Either on Travis, or telling Circle to perform our tests in parallel with our spm & cocoapods bootstraps We can do a `pod lib lint` to lint it locally (make sure it compiles).  @ashfurrow awesome! So that fixes the validation problem.

@scottrhoyt: RxSwift is the only large project I could find that just has one xcodeproj and includes their Demos & Examples as part of the one project. Some other projects don't include Demos (ReactiveSwift, Result), while Alamofire has a separate xcodeproj. I think RxSwift does an exceptional job with project structure, and that's where my fondness for the one-project-approach comes from I could be misunderstanding how sharing of schemes works, but doesn't unsharing a scheme normally put it in `.xcuserdata` or somewhere else that we normally gitignore?

I would disagree on merge conflicts. I think the majority of the merge conflicts I have solved have been in *.xcodeproj's. It's one of the reasons why bigger tech companies don't use them at all.

`pod lib lint` is an alternative to validating that the pod spec isn't broken. However, it doesn't test that it is complete and the advantage to what we are doing now is that it also validates that the Demo project continues to build correctly from CocoaPods. This means that we can have more confidence in the CocoaPods install being complete and `pod try Moya` is working. For example before #869 MultiTarget.swift was missing from Carthage installs because nothing was testing that it was being included via Carthage and the base project could still build fine without it.

So given that what we have is working correctly and has some advantages, I'm just trying to understand the advantages of changing it to be in one merged project. I definitely understand why we needed to get the tests as part of the main project, but the Demo targets don't seem obvious to me. > I could be misunderstanding how sharing of schemes works, but doesn't unsharing a scheme normally put it in .xcuserdata or somewhere else that we normally gitignore?

Sharing schemes is just checking [this box](https://developer.apple.com/library/content/documentation/IDEs/Conceptual/xcode_guide-continuous_integration/ConfigureBots.html#//apple_ref/doc/uid/TP40013292-CH9-SW3) in the Scheme manager (Carthage talks about it [here](https://github.com/Carthage/Carthage#share-your-xcode-schemes)). Unshared schemes are still totally visible to users, and runnable. Not gitignored 


> I would disagree on merge conflicts. I think the majority of the merge conflicts I have solved have been in *.xcodeproj's. It's one of the reasons why bigger tech companies don't use them at all.

Totally valid. I don't have the experience of working at a large company, so I'm probably not qualified to contribute on the severity of merge conflicts. But, regardless of whether we have one or two xcodeprojs, we're still going to get merge conflicts. Having two xcodeproj's might make the conflicts smaller, or space them out to some extent, but it won't get rid of them #xcodeprojmergeconflictsheretostay üò≠

> For example before before #869 example MultiTarget.swift was missing from Carthage installs because nothing was testing that it was being included via Carthage and the base project could still build fine without it.

Can we write an integration test that verifies that the built targets have all the files we expect it to have? Something that would have caught `MultiTarget.swift` being orphaned?
If there is, I think we should write it, but I don't see how having one or two projects would affect ‚¨ÜÔ∏è

> So given that what we have is working correctly and has some advantages, I'm just trying to understand the advantages of changing it to be in one merged project.

To me there are two benefits
1. Simplicity. 
Even though sharing iOS code is heavy right now (i.e. you cant just throw up a few `.swift` files up on GitHub, you need to deal with an xcodeproj, and targets, etc.) I like being able to see the entire project at once. For a while, I didn't even realize Moya had a Demo or Tests, since they were hidden away somewhere I don't usually look.
That was the same motive you had for moving the tests into the main project, so they're easier to access

2. SPM expects & generates only one xcodeproj per package I don't have anything more to add to the conversation, but wanted to note a) this is a really great discussion, I'm sure other libraries are having similar ones and we should consider writing a blog post about this PR, and b) I'd really like to thank everyone for providing such thoughtful, respectful comments. This kind of conversation makes Moya a joy to work with, and sets a high bar for the rest of the iOS community. Thank you all. Thanks to everyone here! I'm honored to be able to talk with such skilled people at such a high level. Even with some butting of heads, I think we all win in the end. This is a model of how open source iOS can be done! ‚ù§Ô∏è

I'm pretty sure sharing a scheme is more than that check box. I believe it actually moves the scheme from `xcuserdata` to `xcshareddata` (as seen [here](http://mgrebenets.github.io/xcode/2014/05/29/share-xcode-schemes)). Usually `xcuserdata` is completely gitignored. If it is working differently here, then I must be not understanding something. But either way, I think the shared scheme issue isn't a huge deal because right now I think carthage ignores everything except framework targets.

If we move the Demo code into the main Moya project, the Demo code will by default be working off of a carthage integration and not a cocoapods integration, so building it will not have the effect of validating that the Demo project builds via CocoaPods. I think the corresponding changes to configuration and documentation will have the effect of making Moya more of a carthage-first library instead of cocoapods-first. I'm not opposed to that at all, I actually prefer carthage over cocoapods usually (it's how I integrate Moya), but it's a good sized change nonetheless.

I don't think we will be using SPM to generate or build our xcodeproj's any time soon because we need to specifically tailor the xcodeproj to a carthage integration. I don't think that's what you'd get if you let SPM manage it.

Ultimately, despite my defense of the 2 project solution, I'm not stuck in the mud on this one either. And I do love only having one Xcode window open for a project üòÅ. So, what I'm going to propose is since this currently doesn't change the Demo location from where it is in code and documentation, we merge this as is (after some commit squashing). Then we can create another PR around moving the Demo targets if that still seems like a good idea. In that PR we can debate the relative merits and change our testing scheme to better accommodate the decision. This PR is overweight as is and this might be a good way to contain it a bit. What do you guys say to that? Likewise, its a pleasure to work with you guys üòÑ

I have a feeling you might be right about schemes affecting the `xcuserdata` to `xcshareddata`, I'm not totally sure what the implementation details of checking the "Shared" checkbox is either.

That sounds good to me, this PR is starting to get bloated. Lets get this merged and talk about it in another PR. I can create one as soon as we merge this into master Great! Give me 20 or 30 minutes to squash commits where appropriate and then we can get this bad boy approved and merged. I think people will enjoy the quality of life improvements in here. Thanks for your help @AndrewSB! That's a bit more manageable now. Let me know if you think it needs further compacting. That looks great üòÑ 
I'll get started with the `Demo/` PR

EDIT: created #891   FYI, the test code can be found in the Demo dir. Do a `pod install` and open up the Demo workspace to access and run the test code. Yeah, tests don't add a lot here, except maybe for `underlyingError`. And if you're gonna test that, then maybe just include the trivial tests for the others for an easy coverage win? ü§î What do you think? Thanks a lot for contributing to Moya! I've invited you to join the Moya GitHub organization ‚Äì no pressure to accept! If you'd like more information on what that means, check out our [contributor guidelines](https://github.com/Moya/contributors) and feel free to reach out with any questions. Yeah, I suppose we can add some trivial tests to bump the percentage, although, like I said, it's pretty trivial. ü§∑‚Äç‚ôÇÔ∏è  So this one is a pretty big breaking change, and that could be a decent reason to not do it. I figure we should consider it before 8.0.0 though.

There are a number of reasons I think we should do this though:
  * More idiomatic
  * Fixes ambiguities in code completion and semantics with `Swift.Error`
  * No more verbose than needing to namespace `Moya.Error` everywhere
  * Helps to resolve a class of issues where a failure to namespace `Moya.Error` leads to conformance errors or unintended behavior
  * Eliminates the need to namespace `Swift.Error`

Basically, it has been my experience that overloading Swift standard library type names causes extraneous üëø for maintainers and users alike. But I'm curious if others feel that same way enough to justify the big break.

To ease the change I added a type alias to `Moya.Error` and marked it with an unavailable attribute that offers a fix-it to `MoyaError`. And if we do this, I'll volunteer to submit some PRs to Moya extensions to fix them. For what it's worth, I prefer `Moya.Error` to `MoyaError`. 

Having either `MoyaError` or `Moya.Error` be more idiomatic isn't an objective measure, it's just a marker of familiarity with.
Your comment about the confusion between `Swift.Error` and `Moya.Error` is real though, it does make `Error` ambiguous in some cases, and forces one to namespace the error. But, I feel as if that makes sense, you have your module, each with its own kind of error (`Swift.Error`, `Moya.Error`, or `MyApplication.Error`), and each of those define an error (that's what I have, at least).
Then in my `catchError`, I usually switch to pattern match between those three.

It wouldn't be the end of the world if we made this change, I'd be ok with it, but I think having `MyModule.Error` instead of `MyModuleError` is a paradigm shift and I'd like to encourage it for swift. A few years from now I think it would be awesome if the former is the default, idiomatic naming option for Errors in our language üòÑ I can understand that line of reasoning @AndrewSB. I think it would be a reasonable way to go if Swift and SourceKit had stronger support for namespaces. Unfortunately that's not the case yet.

The only objective thing I can say about what is idiomatic or not is that I just scanned through the 10 most starred Swift libraries and I couldn't find any other examples of publicly overloading `Swift.Error`. So I think it would be fair to say that most users familiar with these libraries wouldn't expect it. That's not to say that doing something unexpected in a software library is bad, but there should be some good reasons for it.

Also important to crafting a well written library is consistent reasoning. I think we all can agree it wouldn't be a great idea for us to overload `Swift.String` or `Swift.URL`. I can share some tearful stories of days lost dealing with a library that overloaded `Swift.String` (the punchline is that I wrote some declarations as `let a: String` when they unexpectedly needed to be `let a: Swift.String` üò≠). So if overloading the standard library type names is bad in general, then we need to ask why should `Swift.Error` be the special case? Again, it's not to say having a special case is bad, but it should come with some good reasoning.

Paradigm can be good. But I think they are only good when they make users lives better or easier.

I don't want to rock the boat too much here. I just think if we want to shift the paradigm to a special case that is unexpected, it should come with solid reasoning and make users' lives better. The reasoning for `Moya.Error` doesn't seem robust and I think it actually might makes users' lives a little more difficult--even in writing about this PR we have to explicitly namespace a swift standard library type .

I like your idea of every module exposing a `Module.Error`. It has a lot of appeal to it. If we could get everyone on board with that, having such a standard convention might be all the reason we need. But realistically I don't think it would work because not every library can cleanly fold all of their errors into a single `Module.Error`. For example, a library might be clearer and cleaner with a `JSONError`, `HTTPError`, and `CacheError`. So I'm not convinced that this would work as a widely-accepted standard either.

Sorry for the wall of text. I just think that Moya is so well respected that it helps craft standards, so we need to really think through how we make use of that. As we've seen with [Result](https://github.com/Moya/Moya/pull/885#issuecomment-269935129), I think it might not be a bad idea to go ahead with this and prevent namespacing issues, as well as making room for the use of more than one "Error type". Yeah, I like `Moya.Error` from an idealogical perspective but pragmatically I think `MoyaError` makes more sense. Another solution could be to put the `Moya.Error` type inside the `MoyaProvider` class, since that class is what generates the errors. I'm fine with whatever we decide though, thanks for bringing up the discussion üëç No problem! Thanks for entertaining the idea!

I think embedding it into `MoyaProvider` is an interesting solution, yet I see a number of drawbacks:

* At ~50 lines (without much documentation), folding Error.swift into `MoyaProvider` will be a significant expansion.
* There are other types than `MoyaProvider` that need access to `Moya.Error` (e.g. `PluginType` and `Response`). So embedding it will cause those structures to need more namespacing and is probably a code smell that it shouldn't be embedded.
* It might not be straightforward for people to find `Error` when browsing the source. Cool, let's rename it `MoyaError` then. Like I said, it's not ideologically as awesome but we've got to live/code in the real world üòÑ   As discussed in #861, this PR removes the default implementation for `TargetType`'s `parameterEncoding` to be consistent with current approach for `TargetType`. The default will be reintroduced as part of #861. Oops wait, need to edit the CHANGELOG to mark `parameterEncoding` as a breaking change. Should be good to go now. Oh, didn't notice those were missing too. Just saw the GitHub one and fixed it within GitHub. üôà

Teamwork. üôå  This is meant to address an issue that I have come across in using `sampleData` to return responses of moderate complexity: `TargetType`s quickly get bloated and harder to read. This works against one of the main use cases for Moya: better organization of client API code. This has also popped up in a number of issues/PRs (e.g. #866, #603, #600, etc.).

The solution provided here is to write a helper function in `TargetType` (`stubbedResponse`) to load stubbed responses from a file. The intended usage is:

```swift
var sampleData: Data {
  switch self {
  case .users:
    return stubbedResponse("Users")
  case .profile:
    return stubbedResponse("Profile")
  }
}
```

This is accomplished by assuming that the file exists in the main bundle and that it has a "json" extension, but both of those default values can be overridden at the call site. If the data cannot be successfully loaded, the function will trap in debug mode (via `assert`) or just return an empty data in release config.

I'd love to get feedback in general, but here are some specific things:

* What do you think about the function name? I also considered `bundledResponse` to allow room for it to be differentiated from other ways of finding the stubbed response (e.g. via file URL so that one can avoid bundling test data with a production app).
* What do you think about the `assert()` behavior? I like this because devs will know right away in testing that the stubbed response can't be loaded as opposed to needing to debug a failing test because of a typo or the file being in a different bundle. However, even though it should be fine I am nervous letting an `assert` get into a production app because of high consequence if for some reason it doesn't work correctly. I'm also not sure if this will just hang a CI build or crash the test and cause it to fail. It is also untestable to my knowledge. The alternative I considered was just printing a warning message and returning an empty `Data` always. This is lower risk but possibly harder to debug. It's probably the way to go.

Another thing to consider is if we go further to encourage that test data be stored in files, we bring up some of the concerns in #425. We might want to consider alternatives to encouraging testing that don't require users to bundle production apps with test data/code. I'm a big believer of keeping testing and dev code/data out of production apps. I think it is less clean and the risk of unintended consequences is too high. It would, however, require a change in philosophy from Moya forcing testing to supporting testing. This was also talked about quite a bit in #861.

*Note: I'll add docs and CHANGELOG after incorporating feedback* I went ahead an renamed the function to `stubbedResponse(forFileNamed:)`. What do you guys think? Oops. Messed up a rebase it looks like. Let me retry. Looks good now. FWIW, I can't really think of a *better* function name. About the `assert()`: I think this is the best option here. > I'm also not sure if this will just hang a CI build or crash the test and cause it to fail.

... but we should definitely test this before doing so. I'm pretty sure it will behave the same way as a `fatalError()` but I will open up a test branch here and throw an `assert` in to see what happens. According to [this failed build](https://circleci.com/gh/Moya/Moya/1159?utm_campaign=vcs-integration-link&utm_medium=referral&utm_source=github-build-link) it looks like it behaves the way we want it to. Hmm, does `sampleResponse(forFileNamed:)` make sense for the function name? Maybe it's just me, but does this really belong in Moya? It seems like it's just sugar that could be implemented on a per-client basis. As OP said, this is only really relevant for testing, and this is stuff that should be coming from your network layer, rather than Moya itself. @justinmakaila I agree that point should be discussed. We should consider whether or not Moya needs a rethink on how it handles testing. I think it might.

However, if the current approach holds, then we advocate that test data should be provided by `TargetType`s in production code. Since it's not ideal to provide most real world test data from code, we should provide the tools necessary to load it from files. Sure, it might be pretty trivial stuff, but at least we could update our documentation and/or demos to show how it's likely to look in the real world instead of counting on users to come to this same conclusion. @BasThomas, I'm pretty indifferent to the two names. I still slightly prefer omitting the first argument label, but that's just my personal style. I don't think it's on us to provide tools for loading the sample data in an opinionated format.

For instance, in my most recent networking library, I have this ((pardon the space formatting...):
```swift
var sampleData: Data {
  switch self {
    // ...
      case .verify:
          return try! JSON([
              "isValid": true
          ]).rawData()
      case .graphOperation:
          return try! JSON([
              "data": [:],
              "errors": []
          ]).rawData()
      case .checkProgramCode:
          return try! JSON([
              "isValid": true
          ]).rawData()
  }
}
``` 
I think we're headed down a slippery slope if we're just adding sugar.

The end user of Moya is the one implementing `TargetType`, and should be deciding where and how to load their data for their stubbed responses. If they're not building with tests in mind, they're going to put `return Data()`, and if they are, they probably have some custom way that they're going to serve their responses anyway.

 I don't disagree with you. However, I just think our viewpoint might be in disagreement with the stated goal of Moya:

> Treats test stubs as first-class citizens so unit testing is super-easy.

By forcing `TargetType`s to provide a `sampleData`, it seems we are already on the slippery slope of recommending testing patterns. This PR goes not much further really, as it's just providing an optional tool and there is nothing to say you can't still do it the old way. 

On the flip side, judging by the issues that I referenced above, some users do run into the problem of our documented pattern not going far enough to support testing with real world responses from moderate complexity APIs. The goal of this PR was to prevent all those users from having to write this method themselves, not represent my personal feeling on how testing should be done.

Personally, I think tests data should be in the test target and supplied by the test objects, not bundled with the main app. But that approach has it's own drawbacks, so I respect that Moya is trying to do it differently. But isn't providing `sampleData` and built in mocks/stubbing enough to make it a first class citizen?

API resource models are literally providing their `Data` representation.

I'm just afraid that we'll start adding something like this while everyone has divergent ideas will put us in the same place we were when people started writing JSON extensions and saying "oh well 90% of services deliver data in this form, why don't we build in JSON handling with this provider?". That is fair. To me this is less divergent and more a natural extension of the tools we provide for testing, but I totally understand the pushback for going even a bit further in this direction as it's further promoting a specific testing pattern that doesn't sit well with everyone... including sometimes myself.

This is code that I personally use to reduce the pain of managing complex responses for sample data, but it's not a one-size-fits-all approach. Issues led me to believe others were having the same problems, so I offered my help. We don't have to include it though.

If you had some other ideas on how we could make testing more open and flexible to all approaches (including keeping test data in test bundles) while still keeping it first class, I would love to see that PR come through. üëç  I think the least we can do here (especially since I think @justinmakaila makes a fair point), is to include this snippet in the docs. Just as we did with some of the String extensions. This then is also a reference point for future issues. :) The consensus here looks like this isn't a good idea, so I will go ahead and close this.      This fixed the issue mentioned in #842. Going to close this unless it can be reproduced.  Also renaming the associated files with extensions on MoyaProvider. If we do this, we should probably also rename Moya+RxSwift and Moya+ReactiveSwift. I will do that in a further PR if this gets merged.    Hi there, I took a look and the `requestClosure` looks like it is escaping (see [here](https://github.com/Moya/Moya/blob/1e9a9d16eb61b90910357b770e5e11e080950d97/Source/Moya.swift#L38)). What version of Moya are you using?  @GTMYang: We have some documentation here: https://github.com/Moya/Moya/blob/master/docs/Providers.md#requestclosure

If you have further questions on how to use it after reading that, and the Endpoints documentation, we'd be happy to help! @GTMYang were you able to resolve you issue or do you need any additional assistance? Closing this due to inactivity, please re-open if you're still having issues üòÑ   While trying to figure out some of the codecov problems from #871, I realized that we were incorrectly getting a lot of coverage credit for the testing code itself. I added everything in the Demo and Carthage directories to be ignored.

Unfortunately this means a hit to the coverage metric. üò¢ I am also including a fix to the issue seen in #871 where coverage was reduced due to a file name collision with Alamofire. Looks like the fix worked, so this somewhat mitigates the loss in coverage from not including testing code in the coverage metrics.  After reviewing #869, I realized that MultiTarget wasn't passing it's embedded target's `parameterEncoding`. I fixed this as well as created a `MultiTargetSpec` to get full unit test coverage for `MultiTarget` and cleaned up a little related test code.  Closes #819

Added a test to ensure RxMoyaProvider does indeed emit a `complete`. Did some light house cleaning while I was in there. Hmm, how does this close #819 exactly? I don't think I understand; although bear in mind I'm not that familiar with Rx. I read the issue to mean that the OP didn't think `RxMoyaProvider` emitted a `complete` after a request. So I added a test to ensure it did. I guess I thought that closed the issue from the perspective that the test shows it isn't an issue. But we can leave it open if you think that's a good idea or that the new test doesn't go far enough. Hmm, right. Not entirely sure what OP's issue was then; let us just close it, and we can reopen if needed.   There are a few things in TargetType.swift that I think there might be better locations for. Here are the changes:

* Move the `Method` typealias to the Moya+Alamofire.swift file with the other Alamofire type aliases.
* Extract MultipartFormData to it's own file.
* Move `StubBehavior` to Moya.swift since it has more to do with `MoyaProvider` than `TargetType`.
* Move the extension on `Method` to Moya+Internal.swift where it is used. This could possible also go in Moya+Alamofire.swift.

Let me know what you guys think about this. Hmm... that's odd. Not quite sure why this would reduce test coverage by such a significant amount. I don't really think a changelog entry is needed for a refactor. :) Haha. Yeah, I didn't think so either. But I was a bit unsure because of Danger calling the build failed. I know I could add a #trivial tag to the PR, but this didn't really feel trivial either. Think I should go that route? Hmm, added #trivial in this case just to make Danger happy. Oh well. @scottrhoyt: thank you for doing this üòÑ  No problem! Anyone have any ideas on the test coverage? Ok, so I think I understand a little more about the drop in test coverage. For some reason, [CodeCov is registering](https://codecov.io/gh/Moya/Moya/src/sh_targettype_refactor/Source/MultipartFormData.swift) 285 missed lines for MultipartData.swift even though the file only has 32 lines with 5 lines of executable code. I wonder if it's possible that there is some confusion between Moya's `MultipartFormData` and Alamofire's `MultipartFormData`. These type name collisions are üò©.  Somehow this file got orphaned.  Can you post the code for your `TargetType`? It is an issue with your braces. You put most of the properties inside of the `sampleData` computed property. @dannymout I noticed you deleted that code block. Did that settle the issue for you and can we close this or do you have another question about `TargetType` implementation?  As discussed in #861   I agree it can get ungainly fast. I would recommend loading the data from files instead of including it directly in your `TargetType`. I'm going to work on including some helper functions in `TargetType` for this. Another option you have right now is to put the `sampleData` into a separate file.

For instance, create a GitHub+SampleData.swift that contains just this:

```swift
extension GitHub {
  var sampleData: Data {
    // put your sample data here
  }
}
```

That file would still be pretty ugly, but it would clean up the main API code. Agreed, it can get pretty wild. I store sample response data (JSON mostly) in files and return the contents of those files instead of hard-coding things. Here's an example: https://github.com/artsy/eidolon/blob/bbaa513cc50e6bdfe0aad317ffca1372ecbc8323/Kiosk/App/Networking/ArtsyAPI.swift#L182-L238 Let us know how it goes üëç Closing this now then, let us know if you encounter any issues!    #859 already adds `parameterEncoding` defaulting to `JSONEncoding`. Which version of Moya are you using? Thanks for the suggestion @EvilNOP. That is exactly what was done in #859 with `URLEncoding` being the default. A new release hasn't been cut yet so it is only available on `master` at the moment. Ah right, @scottrhoyt's change has not had a new release yet. Do you think that solves your problem or would your number 3 still be something you'd really like to see? @BasThomas, I think that number 3 is also being done in #859. It looks to just be the change needed to encorporate `TargetType`'s `parameterEncoding` instead of the hard-coded `URLEncoding.default`. Alright, I am going to close this issue then. @EvilNOP, if you feel like something else should still be addressed, feel free to reopen!  The quotes in the JSON aren‚Äôt escaped so the compiler is not interpreting this the way that you want. For `sampleData` this complex, instead of going through and escaping all the necessary characters, I would recommend that you load this data from another file.

> On Dec 25, 2016, at 10:34 AM, Danny M <notifications@github.com> wrote:
> 
> I have a question. I want to make sure I understand the purpose of sampleData. So, is this where examples of the JSON data you'd receive from the API go? If this is the case, I'm having an issue. The documentation for the API I'm using provides examples. I'm trying to use these examples, so I copied and pasted them and put the quotes around the text, but something with the quotes somewhere is messing up making Swift think it's a comment, I need to be able to put this into a string. Here is what's happening:
> 
>  <https://camo.githubusercontent.com/be0f50333832858332202c9880fe94f619d463c8/687474703a2f2f692e696d6775722e636f6d2f315038634939572e706e67>
> Some of it is being picked up as a string, and some of it as a comment. All I did was put quotes around it.
> 
> ‚Äî
> You are receiving this because you are subscribed to this thread.
> Reply to this email directly, view it on GitHub <https://github.com/Moya/Moya/issues/863>, or mute the thread <https://github.com/notifications/unsubscribe-auth/AED9sk_YmhLnaITX_28vWkowci38gMM1ks5rLrczgaJpZM4LVc2W>.
> 

  Not 100% sure this is a great idea, but hopefully this PR can facilitate a discussion. I'll add a CHANGELOG entry and update the docs if we agree on this direction.

## Default `TargetType` Property Implementations And `SingleURLTarget`

### Problem

Currently, if a Moya user wants to make a simple GET request to a new URL (not represented by an existing `TargetType`) they have a couple of options: 

They can create a new `TargetType` which will allow them to keep a consistent networking layer as well as have access to `RxMoyaProvider`, `ReactiveMoyaProvider`, easy response mapping, and 3rd party extensions. However, there is a good amount of boilerplate needed for a simple request and a new type needs to be created even for one-off requests.

Alternatively, they could utilize `Alamofire` or `URLSession` directly, but this would introduce inconsistency into their networking layer and they wouldn't have access to easy reactive extensions and response mapping.

### Solution

Provide default implementations of all `TargetType` properties to represent the most commonly used combination of request settings: a GET request with no parameters.

Additionally, provide a trivial `TargetType` implementation (`SingleURLTarget`) so that users can easily create a `TargetType` that represents a GET request to a single URL with no parameters.

### Usage

```swift
let url = URL(string: "http://api.com")!

// Example 1
MoyaProvider().request(SingleURLTarget(url: url)) {
    result in
    // process result
}

// Example 2
let target = SingleURLTarget(url: url)
MoyaProvider().request(target) {
    result in
    // process result
}

// Example 3
let provider = MoyaProvider<SingleURLTarget>()
provider.request(target) {
    result in
    // process result
}
```

### Tradeoffs

* A reduction in conformance errors that are generated in compilation. These errors are often a source of documentation of available behavior.
* Explicit implementation of all behavior is self documenting and may be easier for developers to reason about.

These tradeoffs can be mitigated by improving the documentation for `TargetType`.

### Alternatives Considered

Provide `SingleURLTarget` without providing default implementations for other `TargetType`s. This would be a good compromise between servicing the specific use case of a simple target without reducing the self-documenting nature of implementing `TargetType`. However, there are other common use cases where other properties like `parameters`, `method`, `task`, or `sampleData` can result in unnecessary boilerplate. I was thinking... should we default everything for `TargetType` as well, or just for your suggested `SingleURLTarget`? I think the latter might be better.

Also, a separate PR for the documentation for `TargetType` would also definitely welcome! Yeah, there are pros and cons to both approaches.

On one hand, you can see even from the sample `TargetType`s in TestHelpers.swift, defaulting for all `TargetType`s helps clean up a decent amount of boilerplate. I like how this makes simple API implementations even more readable.

On the other hand, the lack of default implementation is a powerful means for discovering functionality and ensuring intended behavior. Hmmm

@scottrhoyt I feel as if you're totally right when you say

> lack of default implementation is a powerful means for discovering functionality and ensuring intended behavior

I thought the problem you've noticed is better serviced by something like `NSURLSession` or `Alamofire`. but then I looked around a bit at Moya's documentation, and realized that Moya is supposed to be a completely unified networking layer. If youre using Moya, there should be no need to use Alamofire.
![diagram](https://github.com/Moya/Moya/blob/master/web/diagram.png?raw=true)

So now I'm not totally sure whether or not Moya should integrate your solution. Can you share the code you were working with that led to you seeing the need of a default implementation? So I can see where you're coming from?
The way I've been using Moya is to model all of my API calls. So I look at my API's swagger, and then I convert each operation into a Moya enum case. Moya, for me, has become a way to document how I'm using the provided API. In that paradigm, being able to create a one-off API call has no value, I'd rather have the API call documented in my provider's enum I don't have any personal code to share, unfortunately. What got me thinking about this is when I was thinking through a good strategy for #836. In that case I thought writing all the typical `TargetType` boilerplate to utilize Moya in a simple request was a bit unnecessary, yet using Alamofire felt like going against the idea of Moya in the first place.

That made me realize you'd be likely to run into similar scenarios when utilizing 3rd party APIs in a light way along side your own API client written with Moya. Some examples of this might be adding weather information to an app, using an image API like Flickr, or accessing a Google location API. In these cases you are unlikely to need to fully specify `TargetType`s properties. You may need nothing more than `baseURL`, `path`, and possibly `parameters`.

Also, I find myself breaking up my API client code into multiple `TargetType`s to keep them from becoming monolithic (anything more than a handful of cases with several associated values each and a `TargetType` starts to get less readable IMO). In these cases, I often wind up with `TargetType`s that don't need `method`, `task`, or even `parameters` to be configurable. So I do wind up repeating a decent amount of boilerplate.

Finally, with the introduction of `validate` and now `parameterEncoding` with default values, the case for not providing defaults for the other properties felt a little more diluted to me.

But like said, I definitely see the other side here so I was hoping this proposal would bring out some other opinions. If you do a [search](https://github.com/search?utf8=‚úì&q=language%3Aswift+-filename%3ATarget.swift+TargetType+baseURL+path+method&type=Code&ref=searchresults) for how `TargetType` is used in public GitHub repos, you can see there is a high percentage of cases where the suggested defaults would reduce the amount of code needed. `method`, `task`, `parameters`, and `sampleData` are commonly `get`, `request`, `nil`, and `Data()` respectively. I would think there is some bias in this sample because more complicated API client code is probably more likely to be in a private repository, but it's still an interesting data point. @Moya/contributors Any more thoughts on this? @scottrhoyt what about a subclass of TargetType? `OpinionatedTargetType` or something that gives you nice defaults?
That way one can continue to take advantage of 
> lack of default implementation is a powerful means for discovering functionality and ensuring intended behavior

while removing the need to specify defaults in the simple cases Thanks for the suggestion @AndrewSB! Do you mean a new protocol conforming to `TargetType` and adding default implementations (a sub-protocol, if you will)? I see where you are coming from on that.

It's certainly an option, yet at first blush I'm not in favor. That is primarily because I think making the API surface area larger works counter to the goal of this PR--which is to make Moya easier to use for simple cases. An `OpinionatedTargetType` would require users to read more documentation to confidently use Moya, and that's really the same problem as is introduced by just doing the defaults on `TargetType` except you don't get all the benefits.

At it's heart, this is a philosophical decision for Moya about convention or configuration. I favor convention, and if you look at the defaults provided when you execute `Alamofire.request` or use `URLSession` to process a `URLRequest`, there are similar approaches. If the goal of Moya is to provide a unified networking layer, then I feel we should endeavor to make simple tasks as easy to accomplish with Moya as with the two technologies it replaces. By not doing so, we encourage just a new type of fragmentation of networking code. Even if this causes the self-documenting nature of `TargetType` to not be maximized, it will still be pretty clear to my eyes, and better and more organized than writing an ad-hoc networking layer on top of Alamofire or `URLSession`. Users will still have the option to fully specify the `TargetType` protocol for maximum clarity.

But I really think we need more than just the two of us to weigh in on this, since it is a decision central to Moya's philosophy.
 Yeah @scottrhoyt, I see what you're saying. There are pros and cons, and its definitely central.

Lets wait for some other people to chime in before we do anything here While we are talking about this: we might want to consider removing the [defaults already in place at this moment](https://github.com/Moya/Moya/blob/master/Source/Target.swift) and add the (much) needed (?) documentation for all the options, like was done in this PR, to the options. If we are going to advocate that simple API requests still be handled with Alamofire/`URLSession` then I think we should change the image at the top of the README to this:

![diagram](https://cloud.githubusercontent.com/assets/4259250/21548608/2b57e3b4-cda2-11e6-953c-ea8f53307917.png)

As for `sampleData`, even as an ardent unit tester, I think there is a difference between first-class support of unit testing and first-class forcing people to write testing code. We all know very few projects get started with full test suites in place. If tests do eventually get added, it is often done at a later date (i.e. not much TDD going on). The amount of Moya code that starts off with

```swift
var sampleData: Data {
  return Data()
}
```

considerably outnumbers the amount of code that is using `sampleData` in it's intended fashion. [This search](https://github.com/search?utf8=‚úì&q=language%3Aswift+-filename%3ATarget.swift+TargetType+baseURL+path+method&type=Code&ref=searchresults) backs that up at least for public repos. By adding even a little bit of friction to selecting Moya as your networking layer because of it's verbosity and forcing of unit testing code into your app, we just encourage people to go a different route that will be harder for them to add unit tests once they get to the point that they realize they need it. While it is admirable to say that we can change testing etiquette by forcing people to implement `sampleData`, the reality is that it's still just a--confusing for anyone that isn't familiar with Moya--`Data()` away from being ignored and that is what most people are doing. Changing testing behavior will require a bigger impetus than a single networking library, but every single networking library should still support it in some way. Frankly I think Moya should go further to support testing by providing an easy way for test data to be stored in fixtures because if you want to use real returns from even a moderate-complexity API, the `TargetType` code quickly gets bloated back to unreadable status.

I started off thinking that the verbosity of `TargetType` was a positive because of it's self documenting nature. But I think I have come around to see it differently. When I look at this:

```swift
enum SimpleApi: TargetType {
  case newsfeed, messages

  var baseURL: URL { return URL(string: "http://api.com")! }

  var path: String {
    switch self {
    case .newfeed:
      return "newsfeed"
    case .messages:
      return "inbox"
  }
}

MoyaProvider<SimpleApi>.request(.newsfeed) { //... }
```
  
It is pretty clear to me that what is being executed is a simple GET request with no parameters. That's the same as if I were to see this:

```swift
Alamofire.request("http://api.com/newsfeed") { // ... }
```

That is because pretty much every way that I interact with HTTP (Alamofire, `URLRequest`, curl, wget, Postman, my web browser) defaults to a GET request with no parameters. And the reality is that once your API becomes complicated enough to really worry about whether API specifications are clear in the Moya code, you will have overridden most of the defaults and gotten right back to where we are today, except you'll be glad that you used Moya for even the simple things because now you don't have to go back and figure out how to write unit tests for all the times you fell back to Alamofire. @BasThomas I think we definitely need that documentation if we are going to provide default values. If not, then the documentation is pretty trivial--but probably still a good idea to have the whole surface area of your public API documented. I'll open up a separate PR with some trivial documentation. Do any @Moya/contributors know why Danger might be failing here:

![screen shot 2016-12-29 at 9 16 45 pm](https://cloud.githubusercontent.com/assets/4259250/21560008/3d277f22-ce0c-11e6-8ec6-c3f957bad319.png)
 I *think* it's the ["Any changes to library code need a summary in the Changelog."](https://github.com/Moya/Moya/pull/861#issuecomment-269254867) maybe? No, I think that's a Danger bug. We should try updating to the latest to see if it's been fixed.  I'd love to pick a direction on this one way or another soon. Does anyone else have any opinions on whether or not this is a good fit for Moya?

If we decide to not go this direction, it's not a big deal to me. Other users and I can still add these defaults without much hassle. We can even add a suggestion in the docs. However, I do think it aligns with Moya's stated goal:

> So the basic idea of Moya is that we want some network abstraction layer that sufficiently encapsulates actually calling Alamofire directly. It should be simple enough that common things are easy, but comprehensive enough that complicated things are also easy.

If we decide against defaulting, we might want to revisit whether or not `parameterEncoding` (and possibly `validate`) should have a default before the 8.0.0 release. Hard to say, is defer to whatever is least surprising for users, but that's certainly up for debate in this case. It doesn't sound like there's a tonne of push for it, so it might make sense to hold off for now at least.  Alright. I'm going to leave this PR open for the moment so that others that might be gone for the holidays can consider it when they get back. It can still be done post 8.0.0 since it won't be a breaking change. 

I think we can make the case for providing a default for `validate` since it's suppressing Alamofire behavior and we try to not leak Alamofire where possible. However, I'll open a PR to remove the default for `parameterEncoding` and include that default in this PR. That way we are consistent on the current approach and can decide on providing defaults for `TargetType` as a whole. If no-one has any further thoughts on including this, I will go ahead and close this.  This is to clean up the warnings generated by SwiftLint. Could someone explain what this change does?
From my understanding, `Void` is just a `typealias` for `()`, what is swiftlint's complaint? Yeah, there is nothing functional here. It's purely stylistic. I prefer Void, but if others would like to stay with (), we can silence these warnings by disabling this rule in .swiftlint.yml.

> On Dec 24, 2016, at 4:36 PM, Andrew Breckenridge <notifications@github.com> wrote:
> 
> Could someone explain what this change does?
> From my understanding, Void is just a typealias for (), what is swiftlint's complaint?
> 
> ‚Äî
> You are receiving this because you authored the thread.
> Reply to this email directly, view it on GitHub, or mute the thread.
> 
 Which rule catches functions that return `()`? `void_return`  Closes #858 

This is a simple implementation of allowing the `TargetType` to specify its `ParameterEncoding`. The default implementation specifies `URLEncoding`. Yep! Sure, I went ahead and updated the documentation. Thanks! @scottrhoyt No, thank you. I'm so glad this got done! üíØ   For RxSwift, the favored approach to updating your UI would be to use `bind`. You can find some good tutorials for how to do so via a search. @rlam3 were you able to sort out using `bind` to accomplish what you want? If not I suggest working through [these excellent tutorials](http://www.thedroidsonroids.com/blog/ios/rxswift-by-examples-1-the-basics/) from our very own @sunshinejr. Since there hasn't been any activity on this thread for some time, I am going to go ahead and close it. Please re-open or create a new issue if you would like to discuss further. Thanks.  I've updated the readme to link to [Moya-JASONMapper](https://github.com/AvdLee/Moya-JASONMapper) as this one is being update more often and tries to be in sync with Moya releases. I'm getting the error: 
```
For your GitHub repo, you need to expose: DANGER_GITHUB_API_TOKEN
You may also need: DANGER_GITHUB_HOST, DANGER_GITHUB_API_BASE_URL
```

I've got my token ready, but I'm unable to expose it using the `DANGER_GITHUB_API_TOKEN` key. Anyone available to provide me the needed information to do this? > Suppressing export of environment variables DANGER_GITHUB_API_TOKEN fork PR builds

Not sure why Circle decided to skip this step, but that's what is causing the issue Got it: I had to enable **Pass secrets to builds from forked pull requests** in the settings. We could do that. However, I think it's important that we reference the repo's who are up to date the most. When developing you want to reference up to date repo's as much as possible. I agree with @AvdLee. Maybe @sunshinejr knows about any intended work on the former? > We could do that. However, I think it's important that we reference the repo's who are up to date the most. When developing you want to reference up to date repo's as much as possible.

Agreed, but I don't think that [Moya-JASON](https://github.com/DroidsOnRoids/Moya-JASON) is truly outdated at this point. [It is using Moya version 8.0.0-beta-4](https://github.com/DroidsOnRoids/Moya-JASON/blob/master/Moya-JASON.podspec#L33).

It's true that [Moya-JASONMapper](https://github.com/AvdLee/Moya-JASONMapper) is using 8.0.0-beta-6, but I wouldn't consider this a huge difference.

My suggestion is to keep both listed and let whoever needs a JASON mapper decide which one fits their needs. Woah, that's harsh. Didn't have time to update all the things lately, dunno when will it happen so can't promise anything. I'm gonna leave the decision to you guys. Listing both makes the most sense to me too. Moya has been moving very quickly and making a lot of breaking changes, it makes sense that the community is struggling to keep up. Hopefully things settle down a bit after our 8.0 release.  This is probably a result of the underlying `Alamofire.URLEncoding`. If your API can take parameters encoded as JSON in the HTTP body, I would suggest  switching to `JSONEncoding`. The easiest place to do this would be in the `endpointClosure` when initializing the `Endpoint`. You can now use `TargetType.parameterEncoding` to accomplish this.  Hey @liliah.

I can't say that I know specifically what is going wrong here, but if I had to guess, I would say that there could be a problem with how the authorization header is being encoded and/or how it is interpreted by your API. If you have the ability to change how authorization headers are used by the API, I think you might have fewer issues if you use the standard approach for access-token-based authentication. This is the standard format:

```
Authorization: Bearer <access_token>
```

If you have to use the current approach, I would note that the capitalization of `Authorization` also changed. That may be the source of the different behavior as well.

For debugging purposes, you can also utilize the `NetworkLoggerPlugin`. Turn on the curl output and then you can try the generated requests via CLI for another perspective on what might be going on. Were you able to get this sorted out @liliah? Glad to hear it is working for you! üëç  That is interesting @mihailstumkins. Would you mind opening up an issue to track that? `AccessTokenPlugin` and `AccessTokenAuthorizable` are new additions, so there is a possibility that they contain a bug that is not being tested for.  @shivayogic, in the code you posted, it doesn't look like there are any subscriptions to `rx_getAuthToken`, so the request won't be made. The `do` operator only specifies a side-effect to be performed. Try replacing the `do` operator with `subscribe`. Then uncomment the `expect.fulfill()` and see if this test passes.  Hey, I already updated dependencies in #842, which has yet to be merged. Might be better to update that (`rc.1` to `rc.2`) and update everything at once? :) Closing this, then. :)  You can take a look at #834 to get started, maybe? @rlam3 since you're using Rx, I'd recommend looking at this example in the RxSwift repo: https://github.com/ReactiveX/RxSwift/tree/master/RxExample/RxExample/Examples/GitHubSearchRepositories

It doesn't use Moya, but the GitHub service it uses is similar to a Moya `provider` I really can't say without seeing the rest of your code @rlam3. I'd recommend putting a `didSet` propertyObserver on your `feedItems` property, and either printing out the newValue, or setting a breakpoint so you can see what is mutating the property. It doesn't look like an RxSwift problem to me, I've been able to use standard collection view functions while using Rx üòÑ  @rlam3: I'm going to close this for now, but please do re-open this if you still have questions, it sounds like this is more of a Rx-y question than a Moya question.

RxSwift also has a really friendly slack where people are usually really willing to help out, especially with questions about best practice üòÑ   In this case your best bet is to modify the `httpBody` of the underlying `URLRequest`. You have two choices on where to do this: either in the providers `requestClosure` or by creating a plugin and using the `prepare` function. If you can represent all of your XML data in key/value format, another option would be to create a custom parameter encoder conforming to `ParameterEncoding` and utilize the `TargetType.parameters` property to pass the data. Then in the `endpointClosure` create the endpoint with your custom parameter encoder. You can now use `TargetType.parameterEncoding` to change the parameter encoding, but you would still need to create a custom XML-based `ParameterEncoding`. @k8mil No problem! If you wind up creating a custom XML `ParameterEncoding`, it would be awesome to submit that to Alamofire in a PR. That way we can offer it to all Moya consumers as well.  Alternatively if you want to have the subscription remain there's `.catchError|.catchErrorJustReturn` to handle the error before it disposes. For example:

```swift
provider.request(.token(_,_))
  .filterSuccessfulStatusCodes()
  .catchError() { error -> Observable<Response> in
    // do something to return a new Observable, retry etc.
    
    // ...or pass it along if it's not recoverable
    throw error
  }
  .mapObject(type: MyObjectMap.self)
  .subscribe(onNext:{ object in

    // do something with mapped object 

  })
``` @rlam3, @jonlambert 's suggestion looks like what you are looking for then. Does this resolve the issue for you? Since there hasn't been any activity on this thread for some time, I am going to go ahead and close it. Please re-open or create a new issue if you would like to discuss further. Thanks.   Can this be removed? ü§î We already have that nice Swift -> Moya versions table Agree, that's much better.  Ref #299  Also moved the file to the `.github` folder.  I have an endpoint that‚Äôs timing out when using Moya.
```swift
getApiProvider().request(.getOrder(id: 4))
  .subscribe { i in
    print(i)
  }
```

No errors, just the following in the console: 

```
2016-12-17 12:19:20.223132 TestApp[46055:1474324] [] nw_endpoint_flow_service_writes [3.1 176.34.225.3:80 ready socket-flow (satisfied)] Write request has 4294967295 frame count, 0 byte count
```

I don't see any logs showing this particular request on the server, and other requests from Moya are working fine.

- [Moya configuration code](https://gist.github.com/jonlambert/b6662045f21e849a00899f51deda5b01)  (tidied up to include only the endpoint in question for brevity)
- [getApiProvider() code](https://gist.github.com/jonlambert/b6662045f21e849a00899f51deda5b01#file-networkhelpers-swift)

When I perform an identical request with Alamofire... 

```swift
Alamofire.request(
  "http://localhost:3000/api/v1/assistants/order?order_id=4",
  method: HTTPMethod.get, 
  parameters: nil, 
  encoding: JSONEncoding.default, 
  headers: [ "Authorization" : "Bearer <token>" ]
)
.response(completionHandler: { response in
    print(JSON(data: response.data!))
})
```

...the request completes without issue. 

I'm sure it's likely something simple I'm overlooking - any ideas what may be causing this?
 Thanks for providing all the details. You could try adding the [NetworkLogger](https://github.com/Moya/Moya/blob/master/docs/Plugins.md) plugin to see if that reports anything.
Also, which version of Moya are you using? @BasThomas 
Thanks for your quick reply! `NetworkLogger` doesn't really add anything extra info - in fact at the moment it's not showing any request at all. 

I'm using `Moya/Swift ~> 8.0.0-beta.4` - should I give the latest version a go?

 Although I am not aware of anything that might fix this particular issue, please give it a go :) @BasThomas ah, now I remember why I'm tied to this version: I'm pairing Moya with `Moya-SwiftyJSONMapper` which specifies `beta.4` Hey @jonlambert, `Moya-SwiftyJSONMapper` has been updated for `beta.6`. Could you try with that version and see if that makes a difference? Thanks @BasThomas but I've just updated, no luck I'm afraid! Still getting the same issues. Is my `parameters` property specified correctly? Hmm, I see your API.swift file uses `POST` instead of `GET`, might that cause the issue? @BasThomas ah that was a mistake when I tidied it up! It's specified as `GET` in the actual file. I'll edit the file attached accordingly. Hmm, don't see anything that'd cause it, then. @Moya/contributors, any ideas? @jonlambert it looks to me like an Rx issue. Are you adding your subscription to a disposeBag? @AndrewSB Yep - problem occurs both with and without the subscription being added to a DisposeBag. @jonlambert Any chance you could create a public repo that reproduces the problem? I'd jump in and do some debugging. Also, one thing to note... while your `Alamofire.request` example specifies `JSONEncoding`, you are manually encoding the parameters in the URL. In the Moya instance, these will instead be encoded as JSON in the HTTP body. This might not make a difference depending on your API code. I've actually run into a similar issue, only it's much more spotty than what OP describes... it happens occasionally on my sign in request. I'm using `ReactiveSwift` and `ReactiveCocoa` with `ReactiveMoya`. My network request is wrapped in an `Action<(), String, AuthenticationError>`, and it seems to be invoked, because my button disables properly, but no network requests show up on the server, in the network logger, in my local proxy, or anywhere. I have to leave the app and come back, which for whatever reason, forces the `Action` to send an error.

Typically, this will fix itself with a few tries of leaving the app and coming back.

We've been trying to chase this bug down for MONTHS, but have such a hard time trying to reproduce it. @jonlambert: could it have anything to do with creating a new provider and then immediately using it? Could you try creating your Provider, and then dispatching your network request a second later, as an experiment, to see if it changes anything?

@justinmakaila: sounds like a headache üòï @justinmakaila I've had this issue sporadically too, just this time (luckily or unluckily?) it's consistently failing so I can examine it further.

@scottrhoyt I will certainly try and put together a repro tomorrow (I'm on UK time at the moment). I expect accurately reproducing the server's behaviour might be a bit difficult if it's a server quirk throwing Moya off - but I'll give it a go nonetheless. 
That's a great point about the JSONEncoding. I'll look into that now!

@AndrewSB I've tested that with a 5 second delay to no avail unfortunately. Still the same timeout. üòï @scottrhoyt Just tried your suggestion this morning - that fixed it! 

```swift
let endpoint = Endpoint<ToshiAPI>(
    url: url,
    sampleResponseClosure: {.networkResponse(200, target.sampleData)},
    method: target.method,
    parameters: target.parameters,
    parameterEncoding: target.method == .get ? URLEncoding.default : JSONEncoding.default
)
```

Looks like there's an issue with Alamofire timing out when sending `GET` requests using Alamofire with JSON in the body: https://github.com/Alamofire/Alamofire/issues/1530, https://github.com/Alamofire/Alamofire/issues/1819

If you guys think this use case is common enough then this conditional is fine; perhaps I could add a pointer in the documentation though. 

Otherwise I'd be happy to discuss other ways of handling this automatically when using JSONEncoding üëç (Although perhaps that's an issue for Alamofire itself)

Thank you so much everyone for your help!  Hmm... that doesn't fix it for me. If I get a re-creatable test case, I'll open a new issue. If you get a reproducible error @justinmakaila I'd be interested in following along. I have a feeling this isn't the same bug as the sporadical timeout.  @jonlambert, glad to hear that worked for you! With the introduction of #859, you can now set your `parameterEncoding` directly in your `TargetType`. This change is currently only available on `master`. Reopening issue - it worked in the instance above but I'm getting the same error using it elsewhere in the code. Looks like a similar scenario to @justinmakaila. Sorry to hear the issue is back. My recommendation would be to enable curl output on the `NetworkLoggerPlugin`, add it to your provider, and use the curl output to test the requests from your CLI to diagnose the problem. If you aren't seeing any output from the logging plugin, then something is probably going wrong on the Moya side and might be able to be reproduced in a sample repo for us to debug. @scottrhoyt There's no output from the logging plugin when I make the request - I'll attempt to reproduce the issue as soon as I can!  @scottrhoyt

I have attempted to reproduce the issue, the repository can be found here: https://github.com/jonlambert/MoyaIssue844 @jonlambert I set up a few breakpoints in your project and ran into this curious situation:

<img width="1512" alt="screen shot 2017-01-10 at 17 43 17" src="https://cloud.githubusercontent.com/assets/1638996/21828048/5ae7450c-d75c-11e6-87cc-832991f8c115.png">

it looks like the provider is nil at the point of creating the `Observable`

EDIT (addition?): That's probably due to the fact that the provider is out of scope at the end of `download()` on the view model. I'm going to try keeping the provider around... @jonlambert Updating your view model code to:
```swift
class WelcomeViewModel: NSObject {
    let provider: RxMoyaProvider<API>
    
    override init() {
        provider = RxMoyaProvider<API>(
            endpointClosure:  MoyaProvider.defaultEndpointMapping,
            requestClosure: MoyaProvider.defaultRequestMapping,
            stubClosure: MoyaProvider.neverStub,
            manager: RxMoyaProvider<API>.defaultAlamofireManager(),
            plugins: [NetworkLoggerPlugin(cURL: true)],
            trackInflights: true
        )
        
        super.init()
    }
    
    func download() -> Observable<Moya.Response> {
        return provider.request(.ping)
    }
}
```
Results in expected behavior:
```
2017-01-10 17:48:01.958: WelcomeViewController.swift:39 (viewDidLoad()) -> subscribed
["$ curl -i \\\n\t-H \"Accept-Language: en;q=1.0\" \\\n\t-H \"User-Agent: MoyaIssue844/1.0 (co.evada.MoyaIssue844; build:1; iOS 10.2.0) Alamofire/4.2.0\" \\\n\t-H \"Accept-Encoding: gzip;q=1.0, compress;q=0.5\" \\\n\t\"https://hookb.in/Z6mo35ag/?foo=bar\""]
[["Moya_Logger: [10/01/2017 17:48:16] Response: <NSHTTPURLResponse: 0x608000039320> { URL: https://hookb.in/Z6mo35ag/?foo=bar } { status code: 200, headers {\n    \"Access-Control-Allow-Origin\" = \"*\";\n    \"Cache-Control\" = \"private, no-cache, no-store, must-revalidate\";\n    \"Content-Length\" = 16;\n    \"Content-Type\" = \"application/json; charset=utf-8\";\n    Date = \"Tue, 10 Jan 2017 22:48:17 GMT\";\n    Expires = \"-1\";\n    Pragma = \"no-cache\";\n    Server = nginx;\n    \"Strict-Transport-Security\" = \"max-age=31536000; includeSubdomains; preload\";\n    \"access-control-allow-headers\" = \"Origin, X-Requested-With, Content-Type, Accept\";\n    \"access-control-allow-methods\" = \"GET, PUT, POST, DELETE\";\n    \"x-expires-at\" = \"Tue, 17 Jan 2017 16:25:02 GMT\";\n    \"x-ratelimit-limit\" = 1000;\n    \"x-ratelimit-remaining\" = 999;\n    \"x-ratelimit-reset\" = 3600;\n    \"x-ua-compatible\" = \"IE=Edge,chrome=1\";\n} }"]]
2017-01-10 17:48:18.035: WelcomeViewController.swift:39 (viewDidLoad()) -> Event next(Status Code: 200, Data Length: 16)
Status Code: 200, Data Length: 16
2017-01-10 17:48:18.035: WelcomeViewController.swift:39 (viewDidLoad()) -> Event completed
2017-01-10 17:48:18.035: WelcomeViewController.swift:39 (viewDidLoad()) -> isDisposed
``` Thanks for the investigation @justinmakaila! This is quite related to the issue brought up in #905. Side note: I don't think this is exactly related to the sporadic issue. In fact, while playing with this project, my team reported that they encountered the bug again. Requests began appearing in a proxy they had set up within 15-90 seconds of the initial "stumble". Still trying to dig in. This issue has been marked as stale because it has not had recent activity. It will be closed if no further activity occurs. 
 This issue has been auto-closed because there hasn't been any activity for 59 days. However, we really appreciate your contribution, so thank you for that! üôè Also, feel free to [open a new issue](https://github.com/Moya/Moya/issues/new) if you still experience this problem üëç.
     Yay Danger! :D After this was merged, when I run `pod install` in the Demo directory, I get this:

<img width="1618" alt="screen shot 2016-12-30 at 10 28 29 am" src="https://cloud.githubusercontent.com/assets/4259250/21570495/657af282-ce7b-11e6-829c-f50a488b31aa.png">

<img width="1740" alt="screen shot 2016-12-30 at 10 35 22 am" src="https://cloud.githubusercontent.com/assets/4259250/21570548/b3887c42-ce7b-11e6-9c25-6164c619180a.png">

I'm using the beta of the new cocoapods release because I was having issues with the current release. I think we just need a minor change to the Podfile to support this. Strange; I don't think I have run into any issues myself doing this. ü§î Yeah, I don't know what's going on here. After playing around a bit more, I think it is quite possible it was on my local machine. Running a `pod update ReactiveSwift` and not committing the changes seems to have solved it for me. This is likely some difference between cocoapods 1.1.1 and 1.2.0-beta3.   Hmm... (cc @pedrovereza)

```bash
Downloading CocoaPods master repo from cocoapods-specs S3 bucket...
Uncompressing CocoaPods master repo...
master/.git/objects/pack/pack-35326da53152e3c953d14b6383803365213400d7.pack: gzip decompression failed
tar: Error exit delayed from previous errors.
Download from S3 failed, cleaning up and falling back to standard checkout...

curl -sS https://cocoapods-specs.circleci.com/fetch-cocoapods-repo-from-s3.sh | bash returned exit code 1

Action failed: curl -sS https://cocoapods-specs.circleci.com/fetch-cocoapods-repo-from-s3.sh | bash
```

Let me rebuild. Hmm, interesting. I am not sure. Should we use `verbose` in the initializer, but leaving it `isVerbose` internally? Does that make sense? Then again, you can get the "verbosity status" as it is a pubic `Bool`. ü§î Why are these (read: `cURL` and `isVerbose`) public anyway? They are `let`s, and always configured in the init. Is there a reason they should be accessible? Having it as `isVerbose` internally seems fine. In fact, [Carthage does it](https://github.com/Carthage/Carthage/blob/2808725a6c0cb7ae714b0cad28aeaf97d89064db/Source/carthage/Update.swift#L19), but you set this mode by using `--verbose` not  `--isVerbose`. Agreed üëç. Changed the constructor back to use `verbose` instead of `isVerbose`. @Moya/contributors, any idea as to [this](https://github.com/Moya/Moya/pull/841#issuecomment-267766014)?

> Why are these (read: `cURL` and `isVerbose`) public anyway? They are `let`s, and always configured in the init. Is there a reason they should be accessible?

If that's cleared up this should be good to go. The properties are public because they're passed in as parameters to the initializer, and I [still adhere to API design principles](http://mattgemmell.com/api-design/) that specify all initializer parameters should be accessible after the fact. But that's just me ‚Äì it's totally open for discussion! Yep, great! There's not really a problem keeping them public, so let's keep it this way. üëç   Just saw that in the NetworkLoggerPlugin, there a non `is`-bool (verbose) that should be updated. Let's do that in a separate PR. -> #841   What do you mean exactly?  Circle CI finally rolled it out to everyone :tada:

Fixes #755  There are a couple of things to unpack here. First of all, currently Moya's support for executing simple requests against a single `URL` is pretty light. There are some new features suggested in #861 that would make this easier, but we are still deciding whether or not they agree with Moya's philosophy. If you want to include this in your own code, I'd suggest looking at how `SingleURLTarget` is implemented and possibly include that in your code.

Without a `SingleURLTarget`, I would recommend using Alamofire instead for the dynamic `URL` requests.

The second part is writing a `TargetType` that can accept multiple `baseURL`s and cycle between them. For this I'm inclined to suggest that you create a new `TargetType` that isn't an `enum` (possibly an extended version of `SingleURLTarget`). You can even embed a separate `enum` into this structure to retain some of the `switch` semantics that Moya promotes. You will also want to subclass `MoyaProvider` to contain the state you need (e.g. the index of the `baseURL` to try). You may also want to change the behavior of it's `request` method to emit an error (from `catchError`) when the `baseURL`s have been exhausted.

Beyond that, you should just be able to string the requests together with `RxSwift` similarly to your example. Let me know if that gets you going in the right direction or if you have any other questions! Since there hasn't been any activity on this thread for some time, I am going to go ahead and close it. Please re-open or create a new issue if you would like to discuss further. Thanks.  @nahung89 can you also post your `Cartfile.resolved`? Seems like the same problem as #760, but that hasn't been identified yet. :/ Hmm...
The problem seems to be a bug in Carthage, for some reason Carthage is choosing a really old version of Moya (3.0.0), and you're failing to build because that version is written in an older version of Swift.

A temp fix would be to add a greater than version specifier to your Cartfile, but we should loop in the Carthage maintainers to take a look.

Update your Cartfile to `github "Moya/Moya" >= 8.0`, and let us know if that works  This all seems very strange - Carthage shouldn't be looking at the demo.xcodeproj

Can you also try clearing your derived data and Carthage cache? When I run it with an empty project, I get the following result:

```bash
bas$ carthage update
*** Cloning Moya
*** Cloning ReactiveCocoa
*** Fetching RxSwift
*** Fetching Alamofire
*** Fetching Result
*** Checking out Alamofire at "3.5.1"
*** Checking out Result at "2.1.3"
*** Checking out ReactiveCocoa at "v4.2.2"
*** Checking out RxSwift at "2.6.1"
*** Checking out Moya at "7.0.4"
*** xcodebuild output can be found in /var/folders/ys/z545gl_90v7918jxtvv_2dzm0000gn/T/carthage-xcodebuild.u1E6C9.log
*** Building scheme "Alamofire tvOS" in Alamofire.xcworkspace
*** Building scheme "Alamofire iOS" in Alamofire.xcworkspace
*** Building scheme "Alamofire watchOS" in Alamofire.xcworkspace
*** Building scheme "Alamofire OSX" in Alamofire.xcworkspace
*** Building scheme "Result-Mac" in Result.xcodeproj
*** Building scheme "Result-watchOS" in Result.xcodeproj
*** Building scheme "Result-iOS" in Result.xcodeproj
*** Building scheme "Result-tvOS" in Result.xcodeproj
*** Building scheme "ReactiveCocoa-Mac" in ReactiveCocoa.xcworkspace
--- xcodebuild: WARNING: Unable to open project file '/Users/bas/Documents/iOS/Test/Carthage/Checkouts/ReactiveCocoa/ReactiveCocoa.playground' in workspace '/Users/bas/Documents/iOS/Test/Carthage/Checkouts/ReactiveCocoa/ReactiveCocoa.xcworkspace'.
*** Building scheme "ReactiveCocoa-tvOS" in ReactiveCocoa.xcworkspace
--- xcodebuild: WARNING: Unable to open project file '/Users/bas/Documents/iOS/Test/Carthage/Checkouts/ReactiveCocoa/ReactiveCocoa.playground' in workspace '/Users/bas/Documents/iOS/Test/Carthage/Checkouts/ReactiveCocoa/ReactiveCocoa.xcworkspace'.
--- xcodebuild: WARNING: Unable to open project file '/Users/bas/Documents/iOS/Test/Carthage/Checkouts/ReactiveCocoa/ReactiveCocoa.playground' in workspace '/Users/bas/Documents/iOS/Test/Carthage/Checkouts/ReactiveCocoa/ReactiveCocoa.xcworkspace'.
*** Building scheme "ReactiveCocoa-watchOS" in ReactiveCocoa.xcworkspace
--- xcodebuild: WARNING: Unable to open project file '/Users/bas/Documents/iOS/Test/Carthage/Checkouts/ReactiveCocoa/ReactiveCocoa.playground' in workspace '/Users/bas/Documents/iOS/Test/Carthage/Checkouts/ReactiveCocoa/ReactiveCocoa.xcworkspace'.
--- xcodebuild: WARNING: Unable to open project file '/Users/bas/Documents/iOS/Test/Carthage/Checkouts/ReactiveCocoa/ReactiveCocoa.playground' in workspace '/Users/bas/Documents/iOS/Test/Carthage/Checkouts/ReactiveCocoa/ReactiveCocoa.xcworkspace'.
*** Building scheme "ReactiveCocoa-iOS" in ReactiveCocoa.xcworkspace
--- xcodebuild: WARNING: Unable to open project file '/Users/bas/Documents/iOS/Test/Carthage/Checkouts/ReactiveCocoa/ReactiveCocoa.playground' in workspace '/Users/bas/Documents/iOS/Test/Carthage/Checkouts/ReactiveCocoa/ReactiveCocoa.xcworkspace'.
--- xcodebuild: WARNING: Unable to open project file '/Users/bas/Documents/iOS/Test/Carthage/Checkouts/ReactiveCocoa/ReactiveCocoa.playground' in workspace '/Users/bas/Documents/iOS/Test/Carthage/Checkouts/ReactiveCocoa/ReactiveCocoa.xcworkspace'.
*** Building scheme "RxBlocking-OSX" in Rx.xcworkspace
--- xcodebuild: WARNING: Unable to open project file '/Users/bas/Documents/iOS/Test/Carthage/Checkouts/RxSwift/Rx.playground' in workspace '/Users/bas/Documents/iOS/Test/Carthage/Checkouts/RxSwift/Rx.xcworkspace'.
*** Building scheme "RxBlocking-iOS" in Rx.xcworkspace
--- xcodebuild: WARNING: Unable to open project file '/Users/bas/Documents/iOS/Test/Carthage/Checkouts/RxSwift/Rx.playground' in workspace '/Users/bas/Documents/iOS/Test/Carthage/Checkouts/RxSwift/Rx.xcworkspace'.
--- xcodebuild: WARNING: Unable to open project file '/Users/bas/Documents/iOS/Test/Carthage/Checkouts/RxSwift/Rx.playground' in workspace '/Users/bas/Documents/iOS/Test/Carthage/Checkouts/RxSwift/Rx.xcworkspace'.
*** Building scheme "RxBlocking-watchOS" in Rx.xcworkspace
--- xcodebuild: WARNING: Unable to open project file '/Users/bas/Documents/iOS/Test/Carthage/Checkouts/RxSwift/Rx.playground' in workspace '/Users/bas/Documents/iOS/Test/Carthage/Checkouts/RxSwift/Rx.xcworkspace'.
--- xcodebuild: WARNING: Unable to open project file '/Users/bas/Documents/iOS/Test/Carthage/Checkouts/RxSwift/Rx.playground' in workspace '/Users/bas/Documents/iOS/Test/Carthage/Checkouts/RxSwift/Rx.xcworkspace'.
*** Building scheme "RxCocoa-OSX" in Rx.xcworkspace
--- xcodebuild: WARNING: Unable to open project file '/Users/bas/Documents/iOS/Test/Carthage/Checkouts/RxSwift/Rx.playground' in workspace '/Users/bas/Documents/iOS/Test/Carthage/Checkouts/RxSwift/Rx.xcworkspace'.
*** Building scheme "RxCocoa-iOS" in Rx.xcworkspace
--- xcodebuild: WARNING: Unable to open project file '/Users/bas/Documents/iOS/Test/Carthage/Checkouts/RxSwift/Rx.playground' in workspace '/Users/bas/Documents/iOS/Test/Carthage/Checkouts/RxSwift/Rx.xcworkspace'.
--- xcodebuild: WARNING: Unable to open project file '/Users/bas/Documents/iOS/Test/Carthage/Checkouts/RxSwift/Rx.playground' in workspace '/Users/bas/Documents/iOS/Test/Carthage/Checkouts/RxSwift/Rx.xcworkspace'.
*** Building scheme "RxSwift-tvOS" in Rx.xcworkspace
--- xcodebuild: WARNING: Unable to open project file '/Users/bas/Documents/iOS/Test/Carthage/Checkouts/RxSwift/Rx.playground' in workspace '/Users/bas/Documents/iOS/Test/Carthage/Checkouts/RxSwift/Rx.xcworkspace'.
--- xcodebuild: WARNING: Unable to open project file '/Users/bas/Documents/iOS/Test/Carthage/Checkouts/RxSwift/Rx.playground' in workspace '/Users/bas/Documents/iOS/Test/Carthage/Checkouts/RxSwift/Rx.xcworkspace'.
*** Building scheme "RxSwift-watchOS" in Rx.xcworkspace
--- xcodebuild: WARNING: Unable to open project file '/Users/bas/Documents/iOS/Test/Carthage/Checkouts/RxSwift/Rx.playground' in workspace '/Users/bas/Documents/iOS/Test/Carthage/Checkouts/RxSwift/Rx.xcworkspace'.
--- xcodebuild: WARNING: Unable to open project file '/Users/bas/Documents/iOS/Test/Carthage/Checkouts/RxSwift/Rx.playground' in workspace '/Users/bas/Documents/iOS/Test/Carthage/Checkouts/RxSwift/Rx.xcworkspace'.
*** Building scheme "RxTests-OSX" in Rx.xcworkspace
--- xcodebuild: WARNING: Unable to open project file '/Users/bas/Documents/iOS/Test/Carthage/Checkouts/RxSwift/Rx.playground' in workspace '/Users/bas/Documents/iOS/Test/Carthage/Checkouts/RxSwift/Rx.xcworkspace'.
*** Building scheme "RxCocoa-watchOS" in Rx.xcworkspace
--- xcodebuild: WARNING: Unable to open project file '/Users/bas/Documents/iOS/Test/Carthage/Checkouts/RxSwift/Rx.playground' in workspace '/Users/bas/Documents/iOS/Test/Carthage/Checkouts/RxSwift/Rx.xcworkspace'.
--- xcodebuild: WARNING: Unable to open project file '/Users/bas/Documents/iOS/Test/Carthage/Checkouts/RxSwift/Rx.playground' in workspace '/Users/bas/Documents/iOS/Test/Carthage/Checkouts/RxSwift/Rx.xcworkspace'.
*** Building scheme "RxSwift-iOS" in Rx.xcworkspace
--- xcodebuild: WARNING: Unable to open project file '/Users/bas/Documents/iOS/Test/Carthage/Checkouts/RxSwift/Rx.playground' in workspace '/Users/bas/Documents/iOS/Test/Carthage/Checkouts/RxSwift/Rx.xcworkspace'.
--- xcodebuild: WARNING: Unable to open project file '/Users/bas/Documents/iOS/Test/Carthage/Checkouts/RxSwift/Rx.playground' in workspace '/Users/bas/Documents/iOS/Test/Carthage/Checkouts/RxSwift/Rx.xcworkspace'.
*** Building scheme "RxTests-iOS" in Rx.xcworkspace
--- xcodebuild: WARNING: Unable to open project file '/Users/bas/Documents/iOS/Test/Carthage/Checkouts/RxSwift/Rx.playground' in workspace '/Users/bas/Documents/iOS/Test/Carthage/Checkouts/RxSwift/Rx.xcworkspace'.
--- xcodebuild: WARNING: Unable to open project file '/Users/bas/Documents/iOS/Test/Carthage/Checkouts/RxSwift/Rx.playground' in workspace '/Users/bas/Documents/iOS/Test/Carthage/Checkouts/RxSwift/Rx.xcworkspace'.
*** Building scheme "RxCocoa-tvOS" in Rx.xcworkspace
--- xcodebuild: WARNING: Unable to open project file '/Users/bas/Documents/iOS/Test/Carthage/Checkouts/RxSwift/Rx.playground' in workspace '/Users/bas/Documents/iOS/Test/Carthage/Checkouts/RxSwift/Rx.xcworkspace'.
--- xcodebuild: WARNING: Unable to open project file '/Users/bas/Documents/iOS/Test/Carthage/Checkouts/RxSwift/Rx.playground' in workspace '/Users/bas/Documents/iOS/Test/Carthage/Checkouts/RxSwift/Rx.xcworkspace'.
*** Building scheme "RxBlocking-tvOS" in Rx.xcworkspace
--- xcodebuild: WARNING: Unable to open project file '/Users/bas/Documents/iOS/Test/Carthage/Checkouts/RxSwift/Rx.playground' in workspace '/Users/bas/Documents/iOS/Test/Carthage/Checkouts/RxSwift/Rx.xcworkspace'.
--- xcodebuild: WARNING: Unable to open project file '/Users/bas/Documents/iOS/Test/Carthage/Checkouts/RxSwift/Rx.playground' in workspace '/Users/bas/Documents/iOS/Test/Carthage/Checkouts/RxSwift/Rx.xcworkspace'.
*** Building scheme "RxSwift-OSX" in Rx.xcworkspace
--- xcodebuild: WARNING: Unable to open project file '/Users/bas/Documents/iOS/Test/Carthage/Checkouts/RxSwift/Rx.playground' in workspace '/Users/bas/Documents/iOS/Test/Carthage/Checkouts/RxSwift/Rx.xcworkspace'.
*** Building scheme "RxTests-tvOS" in Rx.xcworkspace
--- xcodebuild: WARNING: Unable to open project file '/Users/bas/Documents/iOS/Test/Carthage/Checkouts/RxSwift/Rx.playground' in workspace '/Users/bas/Documents/iOS/Test/Carthage/Checkouts/RxSwift/Rx.xcworkspace'.
*** Building scheme "RxMoya watchOS" in Moya.xcodeproj
*** Building scheme "ReactiveMoya watchOS" in Moya.xcodeproj
*** Building scheme "Moya watchOS" in Moya.xcodeproj
*** Building scheme "ReactiveMoya iOS" in Moya.xcodeproj
*** Building scheme "Moya iOS" in Moya.xcodeproj
*** Building scheme "RxMoya tvOS" in Moya.xcodeproj
*** Building scheme "RxMoya iOS" in Moya.xcodeproj
*** Building scheme "RxMoya OSX" in Moya.xcodeproj
** BUILD FAILED **


The following build commands failed:
	CompileSwift normal x86_64 /Users/bas/Documents/iOS/Test/Carthage/Checkouts/Moya/Source/Error.swift
	CompileSwift normal x86_64 /Users/bas/Documents/iOS/Test/Carthage/Checkouts/Moya/Source/RxSwift/Moya+RxSwift.swift
	CompileSwift normal x86_64 /Users/bas/Documents/iOS/Test/Carthage/Checkouts/Moya/Source/Image.swift
	CompileSwift normal x86_64 /Users/bas/Documents/iOS/Test/Carthage/Checkouts/Moya/Source/Plugins/NetworkActivityPlugin.swift
	CompileSwift normal x86_64 /Users/bas/Documents/iOS/Test/Carthage/Checkouts/Moya/Source/Response.swift
	CompileSwift normal x86_64 /Users/bas/Documents/iOS/Test/Carthage/Checkouts/Moya/Source/Endpoint.swift
	CompileSwift normal x86_64 /Users/bas/Documents/iOS/Test/Carthage/Checkouts/Moya/Source/Plugins/CredentialsPlugin.swift
	CompileSwift normal x86_64 /Users/bas/Documents/iOS/Test/Carthage/Checkouts/Moya/Source/Plugins/NetworkLoggerPlugin.swift
	CompileSwiftSources normal x86_64 com.apple.xcode.tools.swift.compiler
(9 failures)
/Users/bas/Documents/iOS/Test/Carthage/Checkouts/ReactiveCocoa/ReactiveCocoa/Swift/SignalProducer.swift:1945:69: warning: 'buffer' is deprecated: Use properties instead. 'buffer' will be removed in RAC 5.0
/Users/bas/Documents/iOS/Test/Carthage/Checkouts/ReactiveCocoa/ReactiveCocoa/Swift/SignalProducer.swift:1945:69: warning: 'buffer' is deprecated: Use properties instead. 'buffer' will be removed in RAC 5.0
/Users/bas/Documents/iOS/Test/Carthage/Checkouts/ReactiveCocoa/ReactiveCocoa/Swift/SignalProducer.swift:1945:69: warning: 'buffer' is deprecated: Use properties instead. 'buffer' will be removed in RAC 5.0
/Users/bas/Documents/iOS/Test/Carthage/Checkouts/ReactiveCocoa/ReactiveCocoa/Swift/SignalProducer.swift:1945:69: warning: 'buffer' is deprecated: Use properties instead. 'buffer' will be removed in RAC 5.0
/Users/bas/Documents/iOS/Test/Carthage/Checkouts/ReactiveCocoa/ReactiveCocoa/Swift/SignalProducer.swift:1945:69: warning: 'buffer' is deprecated: Use properties instead. 'buffer' will be removed in RAC 5.0
/Users/bas/Documents/iOS/Test/Carthage/Checkouts/ReactiveCocoa/ReactiveCocoa/Swift/SignalProducer.swift:1945:69: warning: 'buffer' is deprecated: Use properties instead. 'buffer' will be removed in RAC 5.0
/Users/bas/Documents/iOS/Test/Carthage/Checkouts/ReactiveCocoa/ReactiveCocoa/Swift/SignalProducer.swift:1945:69: warning: 'buffer' is deprecated: Use properties instead. 'buffer' will be removed in RAC 5.0
/Users/bas/Documents/iOS/Test/Carthage/Checkouts/ReactiveCocoa/ReactiveCocoa/Swift/SignalProducer.swift:1945:69: warning: 'buffer' is deprecated: Use properties instead. 'buffer' will be removed in RAC 5.0
/Users/bas/Documents/iOS/Test/Carthage/Checkouts/ReactiveCocoa/ReactiveCocoa/Swift/SignalProducer.swift:1945:69: warning: 'buffer' is deprecated: Use properties instead. 'buffer' will be removed in RAC 5.0
/Users/bas/Documents/iOS/Test/Carthage/Checkouts/ReactiveCocoa/ReactiveCocoa/Swift/SignalProducer.swift:1945:69: warning: 'buffer' is deprecated: Use properties instead. 'buffer' will be removed in RAC 5.0
/Users/bas/Documents/iOS/Test/Carthage/Checkouts/ReactiveCocoa/ReactiveCocoa/Swift/SignalProducer.swift:1945:69: warning: 'buffer' is deprecated: Use properties instead. 'buffer' will be removed in RAC 5.0
/Users/bas/Documents/iOS/Test/Carthage/Checkouts/ReactiveCocoa/ReactiveCocoa/Swift/SignalProducer.swift:1945:69: warning: 'buffer' is deprecated: Use properties instead. 'buffer' will be removed in RAC 5.0
/Users/bas/Documents/iOS/Test/Carthage/Checkouts/ReactiveCocoa/ReactiveCocoa/Swift/SignalProducer.swift:1945:69: warning: 'buffer' is deprecated: Use properties instead. 'buffer' will be removed in RAC 5.0
/Users/bas/Documents/iOS/Test/Carthage/Checkouts/ReactiveCocoa/ReactiveCocoa/Swift/SignalProducer.swift:1945:69: warning: 'buffer' is deprecated: Use properties instead. 'buffer' will be removed in RAC 5.0
/Users/bas/Documents/iOS/Test/Carthage/Checkouts/ReactiveCocoa/ReactiveCocoa/Swift/SignalProducer.swift:1945:69: warning: 'buffer' is deprecated: Use properties instead. 'buffer' will be removed in RAC 5.0
/Users/bas/Documents/iOS/Test/Carthage/Checkouts/ReactiveCocoa/ReactiveCocoa/Swift/SignalProducer.swift:1945:69: warning: 'buffer' is deprecated: Use properties instead. 'buffer' will be removed in RAC 5.0
/Users/bas/Documents/iOS/Test/Carthage/Checkouts/ReactiveCocoa/ReactiveCocoa/Swift/SignalProducer.swift:1945:69: warning: 'buffer' is deprecated: Use properties instead. 'buffer' will be removed in RAC 5.0
/Users/bas/Documents/iOS/Test/Carthage/Checkouts/ReactiveCocoa/ReactiveCocoa/Swift/SignalProducer.swift:1945:69: warning: 'buffer' is deprecated: Use properties instead. 'buffer' will be removed in RAC 5.0
/Users/bas/Documents/iOS/Test/Carthage/Checkouts/Moya/Source/RxSwift/Moya+RxSwift.swift:2:8: error: module file's minimum deployment target is OS X v10.10: /Users/bas/Documents/iOS/Test/Carthage/Checkouts/Moya/Carthage/Build/Mac/RxSwift.framework/Modules/RxSwift.swiftmodule/x86_64.swiftmodule
/Users/bas/Documents/iOS/Test/Carthage/Checkouts/Moya/Source/RxSwift/Moya+RxSwift.swift:2:8: error: module file's minimum deployment target is OS X v10.10: /Users/bas/Documents/iOS/Test/Carthage/Checkouts/Moya/Carthage/Build/Mac/RxSwift.framework/Modules/RxSwift.swiftmodule/x86_64.swiftmodule
/Users/bas/Documents/iOS/Test/Carthage/Checkouts/Moya/Source/RxSwift/Moya+RxSwift.swift:2:8: error: module file's minimum deployment target is OS X v10.10: /Users/bas/Documents/iOS/Test/Carthage/Checkouts/Moya/Carthage/Build/Mac/RxSwift.framework/Modules/RxSwift.swiftmodule/x86_64.swiftmodule
/Users/bas/Documents/iOS/Test/Carthage/Checkouts/Moya/Source/RxSwift/Moya+RxSwift.swift:2:8: error: module file's minimum deployment target is OS X v10.10: /Users/bas/Documents/iOS/Test/Carthage/Checkouts/Moya/Carthage/Build/Mac/RxSwift.framework/Modules/RxSwift.swiftmodule/x86_64.swiftmodule
/Users/bas/Documents/iOS/Test/Carthage/Checkouts/Moya/Source/RxSwift/Moya+RxSwift.swift:2:8: error: module file's minimum deployment target is OS X v10.10: /Users/bas/Documents/iOS/Test/Carthage/Checkouts/Moya/Carthage/Build/Mac/RxSwift.framework/Modules/RxSwift.swiftmodule/x86_64.swiftmodule
/Users/bas/Documents/iOS/Test/Carthage/Checkouts/Moya/Source/RxSwift/Moya+RxSwift.swift:2:8: error: module file's minimum deployment target is OS X v10.10: /Users/bas/Documents/iOS/Test/Carthage/Checkouts/Moya/Carthage/Build/Mac/RxSwift.framework/Modules/RxSwift.swiftmodule/x86_64.swiftmodule
/Users/bas/Documents/iOS/Test/Carthage/Checkouts/Moya/Source/RxSwift/Moya+RxSwift.swift:2:8: error: module file's minimum deployment target is OS X v10.10: /Users/bas/Documents/iOS/Test/Carthage/Checkouts/Moya/Carthage/Build/Mac/RxSwift.framework/Modules/RxSwift.swiftmodule/x86_64.swiftmodule
/Users/bas/Documents/iOS/Test/Carthage/Checkouts/Moya/Source/RxSwift/Moya+RxSwift.swift:2:8: error: module file's minimum deployment target is OS X v10.10: /Users/bas/Documents/iOS/Test/Carthage/Checkouts/Moya/Carthage/Build/Mac/RxSwift.framework/Modules/RxSwift.swiftmodule/x86_64.swiftmodule
A shell task (/usr/bin/xcrun xcodebuild -project /Users/bas/Documents/iOS/Test/Carthage/Checkouts/Moya/Moya.xcodeproj -scheme "RxMoya OSX" -configuration Release ONLY_ACTIVE_ARCH=NO CODE_SIGNING_REQUIRED=NO CODE_SIGN_IDENTITY= CARTHAGE=YES clean build) failed with exit code 65:
** BUILD FAILED **


The following build commands failed:
	CompileSwift normal x86_64 /Users/bas/Documents/iOS/Test/Carthage/Checkouts/Moya/Source/Error.swift
	CompileSwift normal x86_64 /Users/bas/Documents/iOS/Test/Carthage/Checkouts/Moya/Source/RxSwift/Moya+RxSwift.swift
	CompileSwift normal x86_64 /Users/bas/Documents/iOS/Test/Carthage/Checkouts/Moya/Source/Image.swift
	CompileSwift normal x86_64 /Users/bas/Documents/iOS/Test/Carthage/Checkouts/Moya/Source/Plugins/NetworkActivityPlugin.swift
	CompileSwift normal x86_64 /Users/bas/Documents/iOS/Test/Carthage/Checkouts/Moya/Source/Response.swift
	CompileSwift normal x86_64 /Users/bas/Documents/iOS/Test/Carthage/Checkouts/Moya/Source/Endpoint.swift
	CompileSwift normal x86_64 /Users/bas/Documents/iOS/Test/Carthage/Checkouts/Moya/Source/Plugins/CredentialsPlugin.swift
	CompileSwift normal x86_64 /Users/bas/Documents/iOS/Test/Carthage/Checkouts/Moya/Source/Plugins/NetworkLoggerPlugin.swift
	CompileSwiftSources normal x86_64 com.apple.xcode.tools.swift.compiler
(9 failures)
```

(Also, my gosh, that took forever)

Cartfile:

```
github "Moya/Moya"
```

Cartfile.resolved:

```
github "Alamofire/Alamofire" "3.5.1"
github "antitypical/Result" "2.1.3"
github "ReactiveX/RxSwift" "2.6.1"
github "ReactiveCocoa/ReactiveCocoa" "v4.2.2"
github "Moya/Moya" "7.0.4"
```

The failing here makes sense, as `Carthage` can't resolve beta tags, and it fetched a Swift 2 release.
Testing with `github "Moya/Moya" >= 8.0` now. With Cartfile

```
github "Moya/Moya" >= 8.0
```

and Cartfile.resolved:

```
github "Alamofire/Alamofire" "4.2.0"
github "antitypical/Result" "3.1.0"
github "ReactiveX/RxSwift" "3.0.1"
github "ReactiveCocoa/ReactiveSwift" "1.0.0-alpha.3"
github "Moya/Moya" "8.0.0-beta.5"
```

... it seems to just work. Not sure what's happening üòï

Output, for reference:

```bash
bas$ carthage update
*** Fetching Moya
*** Fetching RxSwift
*** Fetching Alamofire
*** Fetching Result
*** Checking out Alamofire at "4.2.0"
*** Checking out Result at "3.1.0"
*** Checking out ReactiveSwift at "1.0.0-alpha.3"
*** Downloading RxSwift.framework binary at "Graham"
*** Checking out Moya at "8.0.0-beta.5"
*** xcodebuild output can be found in /var/folders/ys/z545gl_90v7918jxtvv_2dzm0000gn/T/carthage-xcodebuild.5A09ae.log
*** Building scheme "Alamofire macOS" in Alamofire.xcworkspace
*** Building scheme "Alamofire tvOS" in Alamofire.xcworkspace
*** Building scheme "Alamofire watchOS" in Alamofire.xcworkspace
*** Building scheme "Alamofire iOS" in Alamofire.xcworkspace
*** Building scheme "Result-Mac" in Result.xcodeproj
*** Building scheme "Result-watchOS" in Result.xcodeproj
*** Building scheme "Result-tvOS" in Result.xcodeproj
*** Building scheme "Result-iOS" in Result.xcodeproj
*** Building scheme "ReactiveSwift-macOS" in ReactiveSwift.xcworkspace
--- xcodebuild: WARNING: Unable to open project file '/Users/bas/Documents/iOS/Test/Carthage/Checkouts/ReactiveSwift/ReactiveSwift.playground' in workspace '/Users/bas/Documents/iOS/Test/Carthage/Checkouts/ReactiveSwift/ReactiveSwift.xcworkspace'.
*** Building scheme "ReactiveSwift-tvOS" in ReactiveSwift.xcworkspace
--- xcodebuild: WARNING: Unable to open project file '/Users/bas/Documents/iOS/Test/Carthage/Checkouts/ReactiveSwift/ReactiveSwift.playground' in workspace '/Users/bas/Documents/iOS/Test/Carthage/Checkouts/ReactiveSwift/ReactiveSwift.xcworkspace'.
--- xcodebuild: WARNING: Unable to open project file '/Users/bas/Documents/iOS/Test/Carthage/Checkouts/ReactiveSwift/ReactiveSwift.playground' in workspace '/Users/bas/Documents/iOS/Test/Carthage/Checkouts/ReactiveSwift/ReactiveSwift.xcworkspace'.
*** Building scheme "ReactiveSwift-watchOS" in ReactiveSwift.xcworkspace
--- xcodebuild: WARNING: Unable to open project file '/Users/bas/Documents/iOS/Test/Carthage/Checkouts/ReactiveSwift/ReactiveSwift.playground' in workspace '/Users/bas/Documents/iOS/Test/Carthage/Checkouts/ReactiveSwift/ReactiveSwift.xcworkspace'.
--- xcodebuild: WARNING: Unable to open project file '/Users/bas/Documents/iOS/Test/Carthage/Checkouts/ReactiveSwift/ReactiveSwift.playground' in workspace '/Users/bas/Documents/iOS/Test/Carthage/Checkouts/ReactiveSwift/ReactiveSwift.xcworkspace'.
*** Building scheme "ReactiveSwift-iOS" in ReactiveSwift.xcworkspace
--- xcodebuild: WARNING: Unable to open project file '/Users/bas/Documents/iOS/Test/Carthage/Checkouts/ReactiveSwift/ReactiveSwift.playground' in workspace '/Users/bas/Documents/iOS/Test/Carthage/Checkouts/ReactiveSwift/ReactiveSwift.xcworkspace'.
--- xcodebuild: WARNING: Unable to open project file '/Users/bas/Documents/iOS/Test/Carthage/Checkouts/ReactiveSwift/ReactiveSwift.playground' in workspace '/Users/bas/Documents/iOS/Test/Carthage/Checkouts/ReactiveSwift/ReactiveSwift.xcworkspace'.
*** Building scheme "ReactiveMoya iOS" in Moya.xcodeproj
*** Building scheme "RxMoya OSX" in Moya.xcodeproj
*** Building scheme "RxMoya iOS" in Moya.xcodeproj
*** Building scheme "RxMoya tvOS" in Moya.xcodeproj
*** Building scheme "ReactiveMoya watchOS" in Moya.xcodeproj
*** Building scheme "RxMoya watchOS" in Moya.xcodeproj
*** Building scheme "Moya tvOS" in Moya.xcodeproj
*** Building scheme "Moya watchOS" in Moya.xcodeproj
*** Building scheme "Moya OSX" in Moya.xcodeproj
*** Building scheme "Moya iOS" in Moya.xcodeproj
*** Building scheme "ReactiveMoya tvOS" in Moya.xcodeproj
*** Building scheme "ReactiveMoya OSX" in Moya.xcodeproj
``` Tried on the Demo project using `github "Moya/Moya" >= 8.0`, worked fine for me üëÄ 
*using Carthage 0.18.1* Hmm, Carthage is consistently checking out an older versions of Moya (initially `3.0.0`, and `7.0.4`) when one doesn't specify `>= 8.0`.

@BasThomas, @pedrovereza, and I all have it compiling when specifying `>= 8.0`, I'm not sure why you're running into this issue @nahung89. Are you in a Swift 3 project?
What's stranger still, is that your Carthage is trying to build `Moya/Demo/Pods/Pods.xcodeproj `, which shouldn't be seen by Carthage (and isn't seen by the three of us) when the project is being built by Carthage...

I'll go ahead and create an issue on Carthage to see if they know what's happening. Thanks for the additional information @nahung89, we're waiting on https://github.com/Carthage/Carthage/issues/1637 now. Sounds good @nahung89! Matt from Carthage said he thinks it was something wrong with your Carthage cache, if you see this problem again, can you report it?

Thanks!  I usually include the page number as an associated value on the enum, and use that value in the parameters. Does that work for your code?  Hmm, how should we do this? Alamofire has a great explanation on how to add their project as a `git submodule`, which are roughly the same steps needed for `Result` and `Moya`.

I don't think I've captured that the best I could; I'd love some feedback on how to make it better!

Fixes #780  @jaymutzafi: please check if this works for you, and let me know if you have any questions / improvements! `Do the same for Moya` is a little sparse, what if we tried to copy more of Alamofire's docs?

almost exactly all of this, tweaked to work for Moya
<img width="919" alt="screen shot 2016-12-08 at 2 23 18 pm" src="https://cloud.githubusercontent.com/assets/3814772/21030145/e4e13ec2-bd51-11e6-8bbc-2a33b12ae747.png">
 Was considering that. And then make it "compatible" with all three frameworks? (As Alamofire needs just Alamofire, and we need Alamofire, Result & Moya itself) @BasThomas that sounds good to me! Updated them. If someone could try this and provide feedback, that'd be awesome!  Also cleaned it up a bit.

(Yay, working with Moya for the first time üò¨üò¨üò¨) üíØ   As discussed in #824  @manas-chaudhari mentioned something interesting here: https://github.com/Moya/Moya/issues/823#issuecomment-265458718

Let's use this issue to discuss whether we can implement what he was trying to do üòÑ  closing this for now. @manas-chaudhari: please do re-open this if you're interested in getting this added to Moya Sounds interesting @manas-chaudhari, I'm having a little trouble understanding your example though, are you saying that if I wanted to request my user model, for example, I'd do `provider.request<UserModel>(.me, completion...)`? In my opinion, that doesn't add much to `provider.request(.me).map(UserModel.init)`.

Would you like to make a PR to implement your idea? I think starting out by amending the docs would be the easiest way for me to understand what you're suggesting, and for the contributors to talk about (see https://github.com/Moya/Moya/pull/762 for an example of a README-first PR). If we can get enough people saying they like your idea, we'd be more than happy to merge this in üòÑ  Sounds great @manas-chaudhari, looking forward to checking out the updated docs üòÑ  Closing this in favor of #910 üòÑ   Noticed in #827  Thanks!  These changes were already implemented and merged in PR #581.

Brought up in Issue #580, the changes were never added to a Swift 2.2 and 2.3 releases, meaning MultipartFormBody was broken for release 7.x
 Cool, I'd love to get another set of eyes on this, and we can release tomorrow. Thanks for taking this on! Ok, I'll get this released as soon as possible, I'll let you know üëç Okay, this should be up. @mattfxyz can you confirm this works on your end?  @ashfurrow Looks like cocoapods is aware of new version but there isn't a release for it. I can release it if you want.

But I pointed my podfile at the release-7.0.4 branch and everything is working as planned!  Right! I had to release manually instead of using the rake task, if you could create the GitHub release that would be :100: @ashfurrow Release created and our podfile update!  @ashfurrow Release created and our podfile update! I'll close the issue.    Weird, I wouldn't think Danger would complain about that on trivial PRs. Might be worth a change.   I seem to have missed this in #805. üò¨  This renames some functions to better comply with the Swift 3 guidelines, as well as unifying the RxSwift and ReactiveSwift functions Hmm, not sure about the renaming of `filterStatusCodes(:)` to `filterStatusCodes(in:)` quite sure myself, to be honest. I think `filterStatusCodes(0...9)` reads nicer than `filterStatusCodes(in: 0...9)`. Reading the first as "filter status codes zero through nine", which seems more readable. Thoughts? Esp. because this will probably not be called (much) like `filterStatusCodes(in: range)` where `range` is predefined. My understanding after reading the [API design guidelines](https://swift.org/documentation/api-design-guidelines/#argument-labels) is that we should go with `filterStatusCodes(in:0...9)`:

> [...] This guideline implies that if the first argument doesn‚Äôt form part of a grammatical phrase, it should have a label.
 FWIW I think "filter status codes zero through nine" is grammatically correct, and sounds better than "filter status codes in zero through nine" I always thought of `0...9` as an interval ([Apple also calls it closed range](https://developer.apple.com/reference/swift/closedrange)). To me the function, as is, reads "filter status code interval 0 to 9".

But that's not a strong opinion, I'm ok with what makes more sense to us :wink: Yeah, I think if we were to rename it to `filterStatusCodes(in:)`, I'd want to review the `filter` family of functions as a whole. For example, we also have `filterStatusCode(code: Int)`, why not `filter(statusCodes:)`, `filter(statusCode:)`, etc? I don't have an opinion either way, I think either works within the guidelines. +1 for `filter(statusCodes:)`, `filter(statusCode:)`  `willSendRequest` renamed to `willSend`.
`didReceiveResponse` renamed to `didReceive`.
`prepareRequest ` renamed to `prepare`.
`processResponse` renamed to `process`. Totally unrelated, by why is the testing class for the `NetworkLoggerPlugin` called `NetworkLogginPluginSpec`? Seems like a pretty strange typo üò¨. Or am I missing something there? It's common in Ruby to call them `Spec`, probably from there. Either way is fine, most of my projects have both üòÜ Was actually referring to the `Loggin` part. ;) Mmmm, yeah that's probably just a typo ¬Ø\\_(„ÉÑ)_/¬Ø Renaming the file makes sense üëç  

Can we make the change in another PR? Sure, will do! BTW, do we need anything else done in this PR? Or can it be merged? Should be good to go! Thanks @pedrovereza üôå üëä   This would be hard to put in the Moya framework because you'd have to come up with a way to inject a lot of application-domain-specific information into Moya without bloating the API. You'd also lock the consumer into a particular JSON deserialization library which they'd need to adopt in their models.

That being said here are two ways to accomplish this right now:

### Subclass/extend `MoyaProvider`

I override `RxMoyaProvider`s `request` method to handle my object deserialization as well. The signature looks something like this:
```swift
request<T: ModelProtocol>(_ token: TargetType, object: T.Type) -> Obeservable<T>
request<T: ModelProtocol>(_ token: TargetType, array: T.Type) -> Obeservable<[T]>
```

In this example `ModelProtocol` is a protocol that all my models conform to and extends the JSON deserialization protocol of your choice (e.g. `Unboxable` or `Mappable`). You could omit passing the type and instead overload just on the return type. `RxSwift` does plenty of this. Either way you'll have to supply the type info implicitly or explicitly at the call site, and I have a more pleasant experience with autocompletion the sooner and more explicitly I do that.

### Create a `Networking` layer

This is similar to the above but instead of putting that logic in `RxMoyaProvider` or `MoyaProvider`, you put it in a layer that wraps the provider. The nice thing here is that you can supply type information in the function signatures (e.g. `getUsers() -> Observable<[User]>`). But you are adding another layer of abstraction and at this point the primary benefit that Moya would provide is just organization of API information.

Both of these options are also nice because it gives you a spot to put domain specific error mapping and other information. For example, I'm currently using Moya to interact with an app that returns responses with the signature:

```json
{
  "code": "<success or error code>",
  "message": "<message>",
  "data": "<dictionary or array of data>"
}
```

So at this middle layer I can also map to domain specific errors and embed the information that I need to look at the `data` key to map my models.

Hope that all helps. Let me know if you have any other questions. Using `associatedType`s will allow you to inject model type information into the protocol. The problem is that then you can only return one model type for each conformance to `Api`. This forces you to organize your API client code by return type which might not be the ideal organization--particularly since `ModelProtocol` and `[ModelProtocol]` returns would need separate `Api`s.

While Moya was designed with `enum`s in mind for use as `TargetType`s, you can use any data structure to conform to `TargetType`. The nice thing then is that if this makes sense in your situation, you can use `struct`s to conform and add a protocol on top of `TargetType` with your associated types. Then you can subclass or extend `MoyaProvider` to add the deserialization behavior.

I can't speak for all @Moya/contributors, but IMO I don't see model deserialization as being added in the near future. Mainly because doing so would force consumers into a particular convention for their model code and there is no single best practice that has emerged for JSON deserialization--all the libraries have their pros and cons. However, [Moya Community Extensions](https://github.com/Moya/Moya#community-extensions) offer a good way to get this functionality while still being flexible on how you want to do JSON deserialization. @manas-chaudhari yeah, you would have to create a different provider instance for each kind of model that your API calls return. Maybe instead of having `associatedType`s on the protocol, you could pass the types in. Your `call` function would have to then be generic, and your parse function would take the type as an argument.

```swift
static func call<T>(request: Request) -> T? {
        let params = parameters(request: request)
        // Invoke api get result
        return parse(data: Data(), type: T.self)
}

internal static func parse<T>(data: Data, type: T) -> Result? {
        return T.init(data: data)
}
``` 

and you'd probably have to also create a protocol where you can specify that `T` can be initialized with some `Data`, and specify that conformance in your generic, `Mappable`, or `Unboxable`, as @scottrhoyt said.



FWIW It sounds like you want an extremely simple API layer, where a consumer doesn't have the opportunity to mess anything up by putting the wrong type in; somewhat similar to the API layer one might ship in an SDK.
If that is what your goal is, I'd recommend going with @scottrhoyt's `Networking` layer. The `Networking` layer would be the closest thing to what Facebook, or Stripe's SDK vend.
I recently built an SDK, and did the same thing. I had Moya included as a private implementation detail, and I wrote functions for each API call that looked something like 

```swift
static func login(email: String, password: String) -> Observable<User> {
    return Email.validate(email)
        .flatMap { email in networkingProvider.request(.login(email: email.value, password: password)) }
        .mapJSON()
        .do(onNext: saveAuthTokenToKeychain)
        .map(User.init)
}
``` @scottrhoyt https://github.com/Moya/Moya/issues/823#issuecomment-264653488 was **incredibly** detailed. Thank you üôè

Should we create a documentation page for this questions like this issue? Your comment is 90% of the content I think we'd need for that doc page Hmm, I see where you're coming from...

I dont think we'd add it to Moya right now, since it would definitely force us to include (or depend upon) a JSON parsing library, and force all consumers of Moya to use the same.

What about defining another protocol that conforms to `TargetType`?

```swift
protocol DecodableTargetType: Moya.TargetType {
    var modelType: SomeJSONDecodableProtocolConformance.Type { get }
}

// then you'd be able to take your model
struct User: SomeJSONDecodableProtocolConformance {}

// and then convert your `TargetType` enum conformance to `DecodableTargetType`, and add
enum MyAPI: DecodableTargetType {
    ...
    var modelType: SomeJSONDecodableProtocolConformance.Type {
        switch self {
             case .me: return User.self
        }
    }
    ...
```

by doing that, you could have all the functionality you're looking for from Retrofit in Moya.

Your API consumer can be oblivious to the fact that the response is in JSON by defining a `parse` function in your networking stack that `mapJSON`s, and then calls your JSON decode function with the `modelType` of the target; making it look like

```swift
provider.request(.me).decode() // returns Observable<User>
``` I hope it can be eliminated üòÑ But I'm not sure how to. I think we might need to something type-erasurey here. I'm not totally sure, but the goal is to be able to express

```swift
enum MyAPI: DecodableTargetType {
  ...
   var modelType: SomeJSONDecodableProtocolConformance {
     switch self {
       case .upload: return String.self
     }
    }

    func decoded(response: Response) -> Observable<Self.modelType> { // This line doesn't compile üò≠
      // parse things and return the correct modelType
    }

  ...
}
```

Right now, without any type magic, its possible to return `Observable< SomeJSONDecodableProtocolConformance >`. It makes sense that you should be able to return `Observable<String>` (or `Observable<any other modelType>`) because I know how to express that in logic, but I'm not sure how to express it in the Swift type system.
@Moya/contributors: Does anyone more experienced with such problems care to chime in?

I feel as if the answer would be to make each case in the `MyAPI` generic over type `T: SomeJSONDecodableProtocolConformance `, (or give each case an associatedValue of `SomeJSONDecodableProtocolConformance`). But I'm not sure to do that  I think the best bet is to provide a custom wrapper around your provider, similar to the Ello app.

My current implementation, which is built around a GraphQL server:
```swift
struct MyProvider {
    public static var sharedProvider: ReactiveCocoaMoyaProvider<MyAPI>  = WellthProvider.DefaultProvider()
    
    public static func request(_ target: MyAPI, queue: DispatchQueue? = nil, progress: @escaping Progress = { _ in  }) -> SignalProducer<JSON, Error> {
        return sharedProvider
            .requestWithProgress(token: target)
            .mapProgressResponse(progress)
            .mapSwiftyJSON()
    }
    
    public static func graphQL(_ operation: GraphQLType, variables: [String: Any] = [:]) -> SignalProducer<GraphQLResponse, Error> {
        return request(.graphOperation(operation: operation, variables: variables))
            .mapGraphQLResponse()
    }
}
```

At this point, all you have to do is wrap the `Moya` API, and provide the proper extensions to process the request.

Ultimately, I agree with @scottrhoyt that deserialization is beyond the scope of the library. It should be the consumer of the API that maps the response to specific results. 

You can achieve this with protocols and dependency injection:
```swift
protocol MySpecializedProvider {
   func request(target: MyAPITarget) -> SignalProducer<MyModel, RequestError>
}

class MyViewController {
  let networkProvider: MySpecializedProvider

  func refresh() {
    let endpoint = MyAPITarget.doSomething(parameter)
    networkProvider.request(endpoint).startWithResult { (result: Result<MyModel, RequestError>) in
      switch result {
        case .success: /// Handle successful request
        case let .failure(error): /// Handle error
      }
    }
  }
}
``` @manas-chaudhari: I think using an approach like Ello would be best for your use case under the current Moya.

Your point on 
> build[ing] a MoyaProvider variant which does not have a generic `<Target>` parameter

does sound interesting. If its possible for us to make Moya better by implementing that, we should look into it. I've created an issue for you to expand on that idea (https://github.com/Moya/Moya/issues/830).

If you think your initial question was answered, and you're satisfied with the Networking layer, go ahead and close this issue, and we can continue discussion on #830  Your `Podfile` contains `'Alamofire', '4.0'`, which doesn't support iOS 9. Alamofire `4.1.0` and `4.2.0` (which we use) do.  @Ernest-su is the problem that `.complete` is not called? You are getting all the `.next(progress)` events?

If that is the case, I think the way we should fix the bug is by creating a pull request that creates a (currently failing) test in https://github.com/Moya/Moya/blob/master/Demo/Tests/RxSwiftMoyaProviderTests.swift, and then write code to make the test pass.

If you want to take a shot at that @Ernest-su, that would be awesome (no pressure!), if you don't have time right now or aren't comfortable doing that, I'm sure a contributor will look into this soon!

Providing the clarification on the `.next` vs `.complete` would be very useful either way!  Hey all! I was reading https://blog.pusher.com/what-i-learned-building-the-pusherswift-framework/, and one of the first things the author goes into is how the framework they built uses only one target for all platforms. 

Currently Moya has 4 targets for each 3 of our frameworks (12 total), and then 3 for tests.
<img width="175" alt="screen shot 2016-12-01 at 2 39 57 pm" src="https://cloud.githubusercontent.com/assets/3814772/20815764/11cd4af8-b7d4-11e6-9d3c-7a1d801ddc48.png">

I'm not sure how the author was able to make a universal target, but maybe we could do something similar? @petester42 that looks really cool, it would be awesome to have Moya vend through one target as well.
I could take a shot in a PR, but since you've done this before it may be easier for you to do it? Let me know what you think. üíØ

A script that would do this automatically for any project? That... that'd be awesome üò± @aaroncrespo can you give a concrete example? 
I think the issue with bundle ID collisions disappears when you have one universal target, since there is only one target - it can't collide with something that no longer exist.

*sorry if I misunderstood your comment* üòÖ @petester42 I think we should go ahead with this, and we can fix watchOS issues if/when they come up. When you create a PR, can you close this issue?

Thanks üòÑ  @scottrhoyt @BasThomas @pedrovereza: Along the lines of simplifying the project structure in #885, I think it would be really awesome to have this implemented too.

Especially if we can have it in before the 8.0.0 release. Hmm, would this be a breaking change? I agree this would definitely be nice, but I am not so sure if we need it before releasing 8.0.0.  I don't think it would be a breaking change. Oh, you guys are right. It would have 0 effect on the API, it was just related to the new project structure we had Implemented in #967 üòÜ    What do you mean with "standard structure"? That the email and mobile number might not be returned in that order? What is not JSON? What do you get back from the request in your app? So, doing the same request, gives you the following JSON in Postman:

```json
{
  "message": "422 Unprocessable Entity",
  "errors": {
    "otp_code": [
      "The selected otp code is invalid."
    ]
}
```

and

```
{
    email =     (
        "The email has already been taken."
    );
    "mobile_number" =     (
        "The mobile number has already been taken."
    );
}
```

in Swift? Am I understanding this correctly? In that case, I really have no idea what is going on, but it seems related to the backend. Hmm, it doesn't seem like JSONSerialization is failing.

```swift
do {
    let jsonData = try JSONSerialization.data(withJSONObject: value, options: []) as? [AnyHashable : Any]
    print(jsonData) // this is nil
} catch {
}
```

If the jsonData here is `nil`, the casting fails, not the conversion from `value` to `data`. You are trying to cast `Data` to `[AnyHashable: Any]` here, which probably fails. The way your JSON is printed might be confusing, but seems to not be the issue here. The casting does fail, as `Data` can't be cast to `[AnyHashable: Any]`.

I've made a gist, does that clarify? https://gist.github.com/BasThomas/0f894d610f7f24732077fa961a6fc182 So, does that solve the issue for you? :) I am going to close this issue as it is not related to Moya.

The problem again is casting. You are trying to cast `Any` to `Data` here, which is not possible.
What you can do to solve this is the following:

1. Create `Data` from your `Any` response with the `JSONSerialization(withJSONObject:) function`.
2. Create a `JSONObject` / `[AnyHashable: Any]` by using `JSONSerialization(withData:)` on the data you just received.   Failed because of the missing changelog entry, but I'd argue that is not necessary in this case. Ah, I [see](https://github.com/Moya/Moya/blob/master/Dangerfile) we can use `#trivial` in the PR title to prevent this. Neat!    ## Purpose

While the endpoint and request closures are useful for modifying requests, they
provide an inconvenient solution for many use cases--notably authentication--for
a number of reasons:
  * Only one closure of each type can be provided, making it less ideal when
    multiple atomic modifications need to be made to a request.
  * Overriding these closures require duplicating the work that the default
    closures do and knowledge of more internal¬†Moya API.
  * It is sometimes ambiguous as to which closure you should choose for your
    task.

## Solution

Plugins can be extended with ability to modify requests and results. This would
bring the concept more in line with the concept of web framework middleware and
provide a convenient interface for Moya users and 3rd party plugin creators.
Ultimately, the ability to interact with requests and responses will make
Plugins much more useful.

To do this, we can add two functions to `PluginType`:
```swift
func prepareRequest(_ request: URLRequest, target: TargetType) -> URLRequest
func processResponse(_ result: Result<Response, Error>, target: TargetType) -> Result<Response, Error>
```

*Note: function names were chosen to be consistent with existing interface but
there is an opportunity to better conform to the Swift API Guidelines*

These functions are called before `willSendRequest` and after `didReceiveResponse`
respectively. Like the other protocol functions, empty implementations are
provided by default.

## Example

The following is an example of supplying an access token via a plugin and only
authorizing targets that need it.

```swift
protocol AuthorizedTargetType: TargetType {
  var needsAuth: Bool { get }
}

struct AuthPlugin: PluginType {
  let token: String

  func prepareRequest(_ request: URLRequest, target: TargetType) -> URLRequest {
    guard let target = target as? AuthorizedTargetType, target.needsAuth else {
      return request
    }

    var request = request
    request.addValue("Bearer " + token, forHTTPHeaderField: "Authorization")
    return request
  }
}

let provider = MoyaProvider<Target>(
  plugins: [
    AuthPlugin(token: "eyeAm.AJsoN.weBTOKen"),
    NetworkLoggerPlugin()
  ]
)
```

## Alternatives Considered

### *Add another closure for simpler request modification*

While this would solve the problem of request modification not being
straightforward, it still wouldn't be clean to chain modifications together.
Also, there wouldn't be a simple interface to encourage 3rd party plugin creation.

### *Make the existing plugin functions capable of modifying request/results*

This would not be easily possible due to the way the `willSendRequest` abstracts
Alamofire's `Request`. In addition, adding the extra lifecycle calls makes it
easier to create consistent behavior (e.g. always log requests after they have
been modified by plugins).
 This is great! Some questions:

- I don't think this is a breaking change right now, right?
- On the following:
> *Note: function names were chosen to be consistent with existing interface but
there is an opportunity to better conform to the Swift API Guidelines*

Do you have an idea on where we can improve? As we haven't yet released `8.0.0` final yet, we'd love to iron out these Swift 3-issues and names.

- Danger will complain about this in a minute probably, but could you add these changes to the Changelog and maybe add your awesome example to the documentation?

Thanks again for taking this on! No problem!

> *  I don't think this is a breaking change right now, right?

Nope, should be good to go. The behavior of the existing Plugins haven't been modified and default implementations are provided so that Moya-consumer plugins should conform by default.

> * On the following:
> > Note: function names were chosen to be consistent with existing interface but
> > there is an opportunity to better conform to the Swift API Guidelines

Nothing big here. Mostly `didReceiveResponse` and `processResponse` seemed awkwardly named when the first parameter is of type `Result<Response, Error>` and not `Response`. You could consider `didReceiveResult` and `processResult`. Alternatively, a scheme like this could work:

```swift 
prepare(request: URLRequest, target: TargetType) -> URLRequest
willSend(request: URLRequest, target: TargetType)
didReceieve(result: Result<Response, Error>, target: TargetType)
process(result: Result<Response, Error>, target: TargetType) -> Result<Response, Error>
```

I went ahead and made an entry into the Changelog and added the example. Thanks for the changes! @Moya/contributors, do we want to take a look at the function signatures for `8.0.0`? See the above comment by @scottrhoyt. :+1: on the changes and functions renaming.

@ashfurrow thoughts? The idea behind upgrading Plugins is great, and the implementation is üíØ, good job @scottrhoyt! 

However I'm not sure about `prepareRequest`, for some reason it feels like duplicating functionality (`requestClosure`). We might get a lot more questions about what is better for that use case and so on. 

Also, about dropping the `request`, `response` part of the plugin function names - great idea, I'm up for that, but maybe let's do it in another PR to avoid chaos.
 Would definitely do the renaming in another PR, yeah. @sunshinejr , the intention here is to replace the use of `requestClosure` for a large number of use cases. What I'm not a fan of about `requestClosure` is that if you make use of it, you are overriding default behavior and must offer a replacement for that behavior--even if it is trivial. It also isn't very composable with respect to chaining request modifications which discourages creating extensions for Moya to handle common use cases.

My hope is that this helps resolve a lot of the questions like "should this be a `requestClosure` or an `endpointClosure`" by saying that if the intention is to make a modification of a `URLRequest`, it should be a plugin--and maybe that plugin already exists! I think the question is whether or not those closures still would be necessary. Hmm, should we also create some tests around `pluginsWithCompletion`? Not really sure where to start on that myself. The trivial case is tested by default. Testing the non-trivial case should be pretty straightforward. Just add a header to the request/response and then check for it in `willSendRequest` and the `completion` closure respectively. You could go further and test that the order of plugins is preserved, but I don't know if that is necessary unless we are documenting that assurance. I would have written the test, but it doesn't look like the test suite is in this repo? The tests are located in the Demo app, located [here](https://github.com/Moya/Moya/tree/master/Demo/Tests). :-) I wrote some simple tests. Because I'm not that familiar with `Quick`, I put them where was the easiest for me which was where `MoyaProvider` with delayed stubs is being tested. It should probably go somewhere else since you don't need delayed stubs to test this and it's only increasing the test time unnecessarily, but there was already a `TestingPlugin` being used here. I'll leave the rest as an exercise for the reader. I think the biggest considerations here revolve around the API surface area that is being exposed. Once this is in place, it will be a source of future breaking changes that will need to be managed. Also, there is the question of whether or not `requestClosure` and `endpointClosure` should be deprecated or are still useful. I think there are more pros than cons with empowering plugins though. @scottrhoyt love the changes to docs, good job! üôå Thanks a lot for contributing to Moya! I've invited you to join the Moya GitHub organization ‚Äì no pressure to accept! If you'd like more information on what that means, check out our [contributor guidelines](https://github.com/Moya/contributors) and feel free to reach out with any questions.  On the error: am I right you are expecting the error's response data to be in the `NSError`'s `userInfo`? I think that would make sense to do. Well, at least my reading of the docs lead me to believe that I could extract the original response data by casting the `Moya.Error` to an `NSError` and then retrieving its `userInfo["data"]` value. That didn't work for me. Retrieving the response is straightforward the way I mentioned above, it's just different than what the docs say. @scottrhoyt thank you for checking out the README. The issue you ran into with RxMoya not having `Response` defined stems from changes made in https://github.com/Moya/Moya/pull/563.

Previously both RxMoya and ReactiveMoya were *fat* (they also contained all of the `Moya` source code), but this change made them *slim* (they dont contain Moya, so are dependent on Moya being imported as well).

Not updating the README was an oversight, it should have been updated in tandem with #563. We should create a pull request to update that documentation.   Awesome, thanks! Could you update the community guidelines repo as well? Others use it as a reference: https://github.com/Moya/contributors/blob/master/Community.md Done. :)  Awesome :tada:

Thanks for sharing how you fixed it, this may be useful to other people üëç   Fixes #796.

Can we somehow check if this works as intended? I couldn't really find a way to do so.  Looking at the history of Changelog, this seems to be right changes.
Mentioned by @BasThomas in https://github.com/Moya/Moya/issues/792#issuecomment-263544652. üôå   Codecov, please  See #648  If anyone wants / has an idea on how to take [this](https://github.com/Moya/Moya/issues/648#issuecomment-263372164), please do!

> I was thinking we could include it as two subspecs, and deprecate the old one in favour of the new. To avoid repeating ourselves in the podspec, we can have the old deprecated subspec simply have a dependency on the new one. Does that make sense? Could we simply do this? Without needing the `ss.source_files`?

```
s.subspec "ReactiveCocoa" do |ss|
    ss.dependency "Moya/ReactiveSwift"
end
``` The current `podspec` seems to work. Did what [I thought](https://github.com/Moya/Moya/pull/805#issuecomment-263545349) would work. Can anyone confirm? `pod lib lint` runs fine (although it takes a really long time üòÆ) Yup, it takes a long time because it needs to run every permutation of every subspec. This is great, the only change I would add is the modify the Podfile used in the Demo project to reference the new subspec. Great work! Done. üëç  Thanks for catching this, @rlam3!  How does this increase the coverage? ü§î  Hey there @rlam3. You could look up Artsy's [eidolon](https://github.com/artsy/eidolon/tree/master/KioskTests), they are using Quick/Nimble with Moya.  @rlam3 are you interested in testing Moya specifically for authentication?  The solution is to use two different enum cases that return the same `path`. Maybe `fetchZen` and `createZen`. Does that make sense?   Hey @rlam3. We have updated our documentation around the new `ParameterEncoding` type from `Alamofire`, please check it [here](https://github.com/Moya/Moya/blob/master/docs/Endpoints.md#from-target-to-endpoint). Hope it helps! 

Also, whenever you feel like something isn't clear enough, please let us know so we can improve the docs. üëä The `URL` parameter should be `url`.  ^ I've updated the documentation to reflect that in #804. Sorry! @rlam3 it is, it was probably the `URL` renaming to `url` as @BasThomas mentioned. Can you try if it works? @rlam3 it looks like @BasThomas' change should have fixed what you were seeing, please do re-open this if it didn't!

Closing for now üòÑ   Fixes #795  üôå  What is your question exactly? What doesn't work? If using CocoaPods, please post your `Podfile`. :) We support iOS 8 in `beta.4` and `beta.5` :)   @BasThomas this looks good to me (thank you for making it üôÉ), can you run a `carthage update --no-build` to update rxswift in the resolved file, and to make sure everything works? Because we use `4.1.0` via CocoaPods as well. We might be able to up this to `4.2.0`, but let's bump it to `4.1.0` for now to keep them in sync. Hmm, do we want to update both CocoaPods and Carthage to `Alamofire 4.2.0`? Now I've locked Carthage to `4.1.0`, but not really for a reason. This might be confusing in the future? Let me create a new PR for that. Closing in favor of #799 #799 looks good to me üòÑ   Yep, true! @AndrewSB, have you had time to take a look at this?
Otherwise, @ufosky, a PR to update the dependencies would be really appreciated! @BasThomas I haven't really been on my computer this weekend, I can make a PR towards the middle of the week, but Im available to look over a PR today! I've created ~#797~ #799. :)  Ooooh @mrfarukturgut, that's a doozie of a synchronization problem. I, personally, like to model problems with reative programming. Abstracting multiple, potentially concurrent `Request`s that require a common resource (an auth token in this case) as streams allow me to stay sane, and reason about the state of program at any point in time.

I recently had a long conversation with @rlam3 in https://github.com/Moya/Moya/issues/748 where we talked about a similar problem, why don't you give that a read, and then let us know how we can help once you're aware of the Rx/Reactive Moya solution to your problem This issue has been marked as stale because it has not had recent activity. It will be closed if no further activity occurs. 
 sounds good @mrfarukturgut! Let me know if theres anything else we can help with üòÑ 

GCD is a perfectly fine alternative as well you could use a dispatch group to turn the callback into something that blocks the thread. I wouldn't recommend it, but it is doable  Hey @tspecht I'm not too familiar with ReactiveSwift, but this is on [our docs](https://github.com/Moya/Moya/blob/master/docs/ReactiveSwift.md):

> For ReactiveSwiftMoyaProvider, the network request is not started until the signal is subscribed to.

Also, from [ReactiveSwift docs](https://github.com/ReactiveCocoa/ReactiveSwift/blob/master/Documentation/FrameworkOverview.md#signal-producers):
> [SignalProducer] Unlike a plain signal, no work is started (and thus no events are generated) until an observer is attached

Feels like this could explain the problem you're facing. 

But I think @ashfurrow may have a better answer üòâ  @tspecht You should just return the `SignalProducer` from your provider from your `login(_:)` method, and change the signature to `login(token: String) -> SignalProducer<Response, Moya.Error>`.

What you should have is this:
```swift
class APIProvider {
    static let provider = ReactiveCocoaMoyaProvider<MyService>()
    
    static func login(token: String) -> Signal<Response, Moya.Error> {
        return provider.request(token: .login(token: token))
            .filterSuccessfulStatusCodes()
    }
}
```
All that does is creates a `SignalProducer`, or "unit of work" when you call `APIProvider.login("someToken")`. That unit of work still needs a subscriber before it will be invoked. In your view controller, you're going to want to do something like:

```swift
APIProvider.login("someToken").startWithValues { response in
    /// Update the UI with the response.
}
```
If you want the response to be transformed into some new value, you'll have to write extensions on the `SignalProducerProtocol`, i.e.:
```swift
extension SignalProducerProtocol where Value == Moya.Response, Error == Moya.Error {
  func mapLoginResponse() -> SignalProducer<NewValue, Error> {
    return producer
      .map { response -> NewValue in
        /// Transform response to `NewValue` and return the transformed value
      }
  }
}
```
Which will slightly modify your login producer to look like...
```swift
static func login(token: String) -> Signal<NewValue, Moya.Error> {
    return provider.request(token: .login(token: token))
        .filterSuccessfulStatusCodes()
        .mapLoginResponse()
}
``` @tspecht, have you been able to solve your issue with the answers given? Let us know if you have any more questions! @BasThomas I'm just going to go ahead and close this.

@tspecht, Please re-open if your issue persists.  Github updated the markdown parser and we're getting some weird messages from our fellow @MoyaBot.

![image](https://cloud.githubusercontent.com/assets/1916041/20544340/bd2ab4d4-b0f0-11e6-890f-c184a0d80929.png)

A fix was shipped with [Danger 4.0.1](https://github.com/danger/danger/releases/tag/v4.0.1).

The breaking changes on [Danger 4.0.0](https://github.com/danger/danger/releases/tag/v4.0.0) seem ok in my opinion: I personally prefer our messages to not be sticky, but it's totally open for discussion.  The documentation on this has been updated: https://github.com/Moya/Moya/blob/master/docs/Targets.md. Does that answer you question? Hey @rlam3, was the documentation helpful? Do you still have questions regarding the use of `Task`?  Yep, most endpoints probably use `.request`.  Fixes #782  Oh, should we add a note in the changelog as well? Will do, good catch! Another question... it seems like we can drop the deployment target on macOS to 10.10 as well (now 10.11). Do we want to do that as well? That would be lovely! Hmm, I think we need to update the Cartfile and Cartfile.resolved as well? This still points to Alamofire 4.0 / 4.0.1, which does not support iOS 8. @AndrewSB, maybe you can take a look? And is this something we can test to prevent this in the future? @BasThomas taking a look now

For testing in the future, we can create a (or many) test cases that run in parallel with our CI? Maybe using Travis just to check if carthage is still working?

For the test cases, they would just be single view applications that import Moya & Alamofire, each with a different deployment target (test one can be iOS 8, test two can be iOS 10), and the only the thing travis will test is to see if the targets compile.
We could also test cocoapods in the same fashion, same goes for the Reactive & Rx targets

Not sure if this is going overboard though- let me know what you think? > For the test cases, they would just be single view applications that import Moya & Alamofire, each with a different deployment target (test one can be iOS 8, test two can be iOS 10), and the only the thing travis will test is to see if the targets compile.
We could also test cocoapods in the same fashion.

We use cocoapods to install pods in the Demo app before executing tests. Is it fair to say this covers  cocoapods?

I'm not familiar with carthage, but #630 added a step in the build called `rake:test carthage`, which runs `carthage bootstrap --platform 'iOS'`. Doesn't it cover carthage support? 

*Apologies if I miss understood your suggestions* üòÖ  Hmm, strange how CI didn't fail with Carthage then. Because carthage indeed seems te be tested during CI. ü§î You didn't misunderstand them at all @pedrovereza :smile:

The issue is that `carthage bootstrap --platform 'iOS'` would succeed, since Carthage just pulls down the dependencies and builds them, it doesn't test to see if they'd all compile under the same swift or iOS version (like how cocoapods does in it's podspec).

To test `carthage` for iOS 8, we'd need to create an target that targets iOS 8, build dependencies with carthage, `import Moya` & `import Alamofire`, and then try to compile the project.
Do you guys think we should create that project & test for this case? Or is it too much work to maintain for this edge case? @AndrewSB Oh, now I get it, thanks! üëç  What might be a simpler fix is to add a `Danger` rule to check if the `cartfile` / `cartfile.resolved` or ~`podfile` or `podfile.lock` have~`Moya.podspec` has been updated, to then warn to update / check all of these files? Does that make sense? @BasThomas Yea, sounds like a good first step. @BasThomas that sounds like a good first step to me too üôÉ
On Wed, Nov 23, 2016 at 2:58 PM Pedro Vereza <notifications@github.com>
wrote:

> @BasThomas <https://github.com/BasThomas> Yea, sounds like a good first
> step.
>
> ‚Äî
> You are receiving this because you were mentioned.
> Reply to this email directly, view it on GitHub
> <https://github.com/Moya/Moya/pull/787#issuecomment-262628284>, or mute
> the thread
> <https://github.com/notifications/unsubscribe-auth/ADo1dE5gRMStstw_OZlFX8lcOeNLbhGxks5rBKjTgaJpZM4K5qgZ>
> .
>
  Yeah, I will close this one as this is a duplicate of #782, let's track the process there. üëä  So you want to fetch multiple "pages" at once? Most of the time, paging in an API is added to prevent sending too much information at once. I think what you would be trying to do is something that might not be the ideal solution.

That being said, I think "chaining" the requests like you are doing here should be a solution that works just fine.  Heya guys! üëã

So a few months back we introduced the `StructsAPI`(#427), but we didn't really document that nor made a demo. Maybe it was for the better? Because we can use structs really without introducing this API at all. What we couldn't do was to avoid creating multiple providers for multiple targets. 

So I thought about this and came up with an idea. I've renamed our `StructTarget` to `MultipleTarget`, because you can use this with any type you want, that conforms to `TargetType`. Additionally, I've made a new target in `Demo` project, called `DemoMultiTarget`, that shows how you can use any of the network API that we have (`Giphy`, `GitHub` etc.) with just one provider and the `MultipleTarget`. I've made a new target because it would be hard to see through everything that is now in the `Demo` target & VC. That way (with usage of new Shared directory), we can reuse most of the code and make two clear examples of different usages. 

The last thing I did was to make an example file & link it in the Readme.

I think this could help large projects in splitting logic (or at least I'm pretty sure I will use it in my bigger projects) & make it easier to maintain. 

I think that's it! Please comment anything you find strange/bad/superbad in the PR üòà

Cheers! üéâ Thanks Ash! üôá
 Any idea why Danger didn't run here? Only saw the linter issues here: https://github.com/Moya/Moya/pull/787#issuecomment-262306591. (Fixed those in 7d8489f, FWIW)  Does that solve your issue, @ohohco?  Take a look at #639. As Alamofire seems to have lowered their target to 8.0, we can take another look if the other dependencies did so as well, but that was our reason to drop iOS 8 support. 
 Cool! What do you think, @ashfurrow? Seems like we can lower it again.
 Let's do it, I never really liked removing iOS 8 support anyway but we had to because of Alamofire. If they're lowering it, let's do it üëç
 Let's keep this open to make sure we won't forget. :)
  Does that solve your question, @Ernest-su? @BasThomas is that an issue? I'm not that familiar with `DefaultDownloadDestination` Unfortunately, I don't know either. :/ @bchrobot? Anyone else from @Moya/contributors? Thanks, @lulee007! Also, PR #1053 by @pedrovereza should fix this problem as well (released in Moya 8.0.4). Thus I'm gonna close it, but please feel free to reopen whenever.  Due to the dependencies not being included in this repository, I am not sure if this is possible at this moment. Do we want to support this, @ashfurrow? It's never really come up. It'd be pretty tricky to do, since we have a lot of source code hacks to support either CocoaPods _or_ Carthage. I'm not opposed to adding this, but I think linking to a blog post describing (in general) how to install CocoaPods or Carthage libraries without using those tools would probably be the best solution. Thoughts?  @jaymutzafi it is unfortunate that the current package manager landscape on iOS is that unapproachable to new developers üòï.

@ashfurrow I think we've removed most of our hacks to support Cocoapods & Carthage, so it shouldn't be *too* hard to integrate manually (famous last words üòõ)
@ashfurrow is right though, a blog post describing how to do this in general would be better, and more sustainable in the long run, but I can't find one as of now. So I'll just try to help you out here üòÑ 

For a manual integration, all you (should) need to do is drag the source files inside https://github.com/Moya/Moya/tree/master/Source into your xcodeproj. You might want to not drag in the `RxSwift` and `ReactiveSwift` directories, unless you're using those packages in conjunction with Moya.

I haven't tested this, so I may be wrong. Let us know if you have any issues, we'll try our best to get you working with Moya üòÑ  I think you're missing out on all Alamofire code in that case, which would mean that doesn't work? I think you'd have to manually copy Alamofire's code as well.  Oh yup, you're right @BasThomas. Thanks for catching that üíØ

@jaymutzafi you'd also need to include Alamofire in your project, they have manual integration instructions here: https://github.com/Alamofire/Alamofire#manually Hmm, and it seems like we need to add `Result` as well.

... and then it still doesn't work. Removed all `import Result`s, then Xcode started complaining about all `Moya.`-files, which makes sense. Seems like we're going to have a little more work to make this possible.

<img width="1512" alt="screen shot 2016-12-08 at 22 31 46" src="https://cloud.githubusercontent.com/assets/4190298/21028633/5d78c2da-bd96-11e6-9d54-490fb5feb826.png"> It seems like Alamofire's approach (git submodule) might work (?). Yay, got it working using `git submodules`. Let me add a how-to to the readme. :) Thanks for rolling with this @BasThomas!   @BasThomas is this also ready to merge?  Hey there @bchrobot! Thank you so much for the PR üéâ I've only got one comment but other than that it looks üíØ
 Thanks @bchrobot! üôå @ashfurrow Where is @bchrobot invitation to join us?? üòÑ  Thanks a lot for contributing to Moya! I've invited you to join the Moya GitHub organization ‚Äì no pressure to accept! If you'd like more information on what that means, check out our [contributor guidelines](https://github.com/Moya/contributors) and feel free to reach out with any questions. Weird, the webhook delivery failed. Re-delivering the webhook payload seemed to work, thanks for the bump üëç Looks like GitHub was having some trouble yesterday:

![screen shot 2016-11-22 at 11 14 47 am](https://cloud.githubusercontent.com/assets/498212/20531489/eebbe14a-b0a4-11e6-97c6-a0392579cf6c.png)

Looking in my inbox, I got a notification of the error on Heroku, so if it happens again I'll know üëç   Closing this, see https://github.com/Moya/Moya/pull/774#issuecomment-261369545
   Closing this, see https://github.com/Moya/Moya/pull/774#issuecomment-261369545
   Closing this, see https://github.com/Moya/Moya/pull/774#issuecomment-261369545
   Yeah, I saw that. Let me take a look.
 Ah, it seems like in this few changes, I did not yet change `Cancellable`'s `cancelled` to `isCancelled` yet.
 Added the bool renaming to the `CHANGELOG` in d77c261.
 Let me try to combine this PR with #775 #776 and #777 :wink:
 @BasThomas Ok, branch `cleanups` should have all changes. Can you open a new PR out of that branch? I'll close this and the other PRs to avoid confusion üòÑ 
 Done, thanks a lot! üôå
   Oh no, seems like all of these have been commited incrementally... ( #773, #774, #775, #776, #777 )
Any idea how I can fix this?
 No worries, can we just merge them in that order?
 I'll merge this since it's the first one (and the most simple), then we see if the others need to be fixed üòâ 
    üíØ Thanks!
 Thanks a lot for contributing to Moya! I've invited you to join the Moya GitHub organization ‚Äì no pressure to accept! If you'd like more information on what that means, check out our [contributor guidelines](https://github.com/Moya/contributors) and feel free to reach out with any questions.
  @Fredehagelund92 this sounds like an issue at the [Alamofire](https://github.com/Alamofire/Alamofire) level. Moya doesn't actually handle making the request, all of that work is delegated to Alamofire. You may be better suited to asking the folks over there?

*Apologies if I misunderstood your problem, and the issue is actually something related to Moya incorrectly embedding your headers* üòÖ As this seems to be an Alamofire issue, I'll close this for now. Please reopen if not!  @Moya/contributors, can anybody reproduce this bug? Might be good to take a look at this for `8.0.0`. This issue has been marked as stale because it has not had recent activity. It will be closed if no further activity occurs. 
 This issue has been auto-closed because there hasn't been any activity for 59 days. However, we really appreciate your contribution, so thank you for that! üôè Also, feel free to [open a new issue](https://github.com/Moya/Moya/issues/new) if you still experience this problem üëç.
  Can someone review this? I am not sure if the `UserInfo` and `Router` types are purely  made for the example here, or if these are in any way connected to `RxSwift`? I think they're specific to this example, not related to RxSwift for sure. Thanks for updating this üëç
  We could include an example in the example app maybe? Also, we've been considering an [`Advanced.md`](https://github.com/Moya/Moya/issues/718#issuecomment-254076697) file, maybe it would fit there?
 Yes, that'd be awesome!
 I'm not going to worry about our code coverage going down by 0.08%, this looks great, merging üëç
 Thanks a lot for contributing to Moya! I've invited you to join the Moya GitHub organization ‚Äì no pressure to accept! If you'd like more information on what that means, check out our [contributor guidelines](https://github.com/Moya/contributors) and feel free to reach out with any questions.
 Thanks @jeryRazakarison! üòÄ
  Did you mean to make a separate issue for this? (#700)
 Cool, makes sense!
 Fixed by #767.
  It's not straightforward, but definitely possible. Check out the [Endpoint documentation](https://github.com/Moya/Moya/blob/master/docs/Endpoints.md#request-mapping)'s request mapping section, as well as the [overview of how Moya works](https://github.com/Moya/Moya/tree/master/docs#documentation) for more detail, and let us know how it goes üëç
  Thanks a lot for contributing to Moya! I've invited you to join the Moya GitHub organization ‚Äì no pressure to accept! If you'd like more information on what that means, check out our [contributor guidelines](https://github.com/Moya/contributors) and feel free to reach out with any questions.
  Hey, great question. Thanks for taking the time to open an issue. The instructions in the readme are outdated, please try Moya 8.0.0-beta.4 and you should be fine. Please let us know üëç
 Wonderful, glad to hear it! Would you be able to open a pull request updating the CocoaPods readme instructions? No worries if not!
 Well well, thank you!
 This issue has been marked as stale because it has not had recent activity. It will be closed if no further activity occurs. 
 This issue has been marked as stale because it has not had recent activity. It will be closed if no further activity occurs. 
 This issue should be actually closed already by `probot`, so I'm gonna close it for them.  This is based of the conversation on #423, If anyone else wants to take a shot at this, they are more than welcome to! I'll implement it sometime soon, if not üòÑ 

I added some documentation on threading to the Readme, not sure if it should go there or in it's own file in `docs/`

TODO:
- [x] Update the docs
- [x] Do a final check Queue parameters are almost implemented in #1055 so I'm gonna close this one. @sunshinejr: the plan was to merge #1055 into this branch, and then discuss what kind of queue primitive we wanted to use for ReactiveMoya & RxMoya (based on https://github.com/Moya/Moya/pull/1055#issuecomment-294671464) Damn, sorry, my bad. Somehow I've missed branch & this comment. Nevermind, carry on üòÑ haha not an issue üòã Two tasks to go:

- [x] Rename everywhere we mention `queue` to `callbackQueue`
- [ ] Add docs

let's tackle this in another PR! Anyone is free to start it üòÑ 

I'll resolve merge conflicts here rn @pedrovereza did a PR with rename, so the only thing we need right now is a doc update + last check if everything is correct? And a SwiftLint sweep, apparently. üòÅ I think most of the SwiftLint issues on test files were fixed in #1103, they should go away once we rebase our branches against master (`optional-response-thread-param` and `9.0.0-dev`).

The warnings on `ViewController` seem legit, but I'd rather clean them up after we merge this PR against `9.0.0-dev` üòÑ  Yup, completely agree with @pedrovereza. Ah, missed that @pedrovereza. Nice work @sunshinejr :) About the docs: do we want to include this in `Advanced.md` or in `Providers.md`? Not sure where it fits best. I would go with `Threading.md` - this is big enough topic that it should have its own space, in my opinion. Oh! That's perfect, I didn't know we had a threading readme
On Tue, Jun 13, 2017 at 7:34 AM ≈Åukasz Mr√≥z <notifications@github.com>
wrote:

> I would go with Threading.md.
>
> ‚Äî
> You are receiving this because you modified the open/close state.
>
> Reply to this email directly, view it on GitHub
> <https://github.com/Moya/Moya/pull/762#issuecomment-308136080>, or mute
> the thread
> <https://github.com/notifications/unsubscribe-auth/ADo1dECoOTZMEfWrXIMKwM_TtLe6vPaNks5sDp2zgaJpZM4KuD7b>
> .
>
 Haha, we don't - but we should :D üòÇüòÇ
Agreed
On Tue, Jun 13, 2017 at 7:44 AM ≈Åukasz Mr√≥z <notifications@github.com>
wrote:

> Haha, we don't - but we should :D
>
> ‚Äî
> You are receiving this because you modified the open/close state.
> Reply to this email directly, view it on GitHub
> <https://github.com/Moya/Moya/pull/762#issuecomment-308139564>, or mute
> the thread
> <https://github.com/notifications/unsubscribe-auth/ADo1dJiDMa1CdK-L-a93uM0yGm9p2xgtks5sDqAwgaJpZM4KuD7b>
> .
>
 Also, what do you guys think about removing `stubScheduler` from `ReactiveSwiftProvider`? Now that we have unified `queues`, I think we might consider this change. It would also help in transition from multiple providers to `rx.request` & `reactive.request` mentioned in #963. for the uninitiated, what does `stubScheduler` do? Does adding queues already fix it, or do we need to add more functionality? ~~@AndrewSB it is scheduling stubbed data onto scheduler, so queues should resolve this problem. We may need to revisit tests and add few that ensures the data comes on a given queue.~~ Seems like this is a special scheduler, `DateScheduler`, and it is used instead of GCD when dispatching the stubbed data. Any idea why it was used instead of GCD in RAC extensions [here](https://github.com/Moya/Moya/blob/master/Sources/ReactiveMoya/ReactiveSwiftMoyaProvider.swift#L43-L64)? From what I've seen it was implemented by @swizzlr, but maybe someone else remembers the reason? @ashfurrow maybe?

**Edit:** nvm, we can take care of it after the release. If needed, we'll still have `ReactiveSwiftMoyaProvider`. Ok. Final stage of this one I think. Only docs left - make a `Threading.md` with what @AndrewSB wrote + check other docs if there is something we need to change. Anyone up for this one? Let's merge it already üòÑ  Okay, docs are in, @AndrewSB. We just need to check if we have everything we need here. If you could take a look (and other @Moya/contributors to double-check) it would be awesome! alright, I'm happy with this. Let's wait for CI

Can someone who knows what the conflict for this to be merged try to resolve? Was a quick one, refactor by @SD10 from #1149. Fixed it (hopefully üòÑ)! Gonna do another review of the whole PR in a few. üî• once you do that review, if you're happy, go ahead and merge.
Let's land this pull request 8 months in the making

![SHIP](https://media.giphy.com/media/ta83CqOoRwfwQ/giphy.gif) Great job everyone, especially @AndrewSB! This is a huge one! 

Now might be even bigger one: making sure we got everything between 9.0.0-dev and master in the new release üòÖ

Gonna hit this satisfying merge button after CI!

**Edit:** Damn, didn't update tests for stubs. Gonna repair that one.
**Edit2:** Pushed the fix, gonna still wait for the CI, though üòÖ üéâüéâ  This is the readme image, the first point at which people interact with Moya, so it's gotta be awesome. This PR centres the text, aligns the coloured boxes, and gives some whitespace around the images. Nice! üíÖ 
  Can you show us the entire Cartfile that results in that 3.0.0 being resolved? It's possible that there's another dependency you've included that depends on Moya@3.0.0
 @Pr-Chen Any update on this? Would love to figure out the issue.
 Closing this for now @Pr-Chen. Please come back if you're still running into this üòÑ  FYI, this has been resolved in #835 :)  I'll approve after that update üòÑ 
I think you're right about adding other types of tasks making `Basic.md` too complicated
 Not sure if this needs a comment explaining what this is needed for?
 @BasThomas is that because `Task` feels less cut and dry than something like `Method` or `Path`?

I feel as if a user can just deep link into the `Task` type and see the documentation for the type there - if you still think docs in the basic usage make sense, go ahead and add that comment üëå.

I can review and then merge it in after you've made that edit üôÉ
 I think you're right - the documentation on the type should be enough.
 Thanks a lot for contributing to Moya! I've invited you to join the Moya GitHub organization ‚Äì no pressure to accept! If you'd like more information on what that means, check out our [contributor guidelines](https://github.com/Moya/contributors) and feel free to reach out with any questions.
  Does it only come up when building RxCocoa through Moya? Not if you just have a Cartfile with `github "ReactiveX/RxSwift" ~> 3.0`?

If the issue is in fact with RxSwift, then it should be tracked on their library, on the issue @fruitcoder  mentioned https://github.com/ReactiveX/RxSwift/issues/970.
 Can you delete your derived data and try again? 
 Hmm, so it's working on me when I check specify `github "Moya/Moya" "master"`. Testing now with the `8.0.0-beta.2` release.

`master` output:

```
‚ûú  how-carthage-works carthage update --platform iOS
*** Fetching Moya
*** Fetching RxSwift
*** Fetching Alamofire
*** Fetching Result
*** Checking out Alamofire at "4.0.1"
*** Downloading Result.framework binary at "3.0.0"
*** Checking out ReactiveSwift at "1.0.0-alpha.3"
*** Checking out RxSwift at "3.0.1"
*** Checking out Moya at "1b1edcf782bdf9eea0fa0c55c18275904d35d1e6"
*** xcodebuild output can be found in /var/folders/6y/2zb68tcs4nn6v899_jz0nmfr0000gn/T/carthage-xcodebuild.nCphgo.log
*** Building scheme "Alamofire iOS" in Alamofire.xcworkspace
*** Building scheme "ReactiveSwift-iOS" in ReactiveSwift.xcworkspace
--- xcodebuild: WARNING: Unable to open project file '/Users/asb/how-carthage-works/Carthage/Checkouts/ReactiveSwift/ReactiveSwift.playground' in workspace '/Users/asb/how-carthage-works/Carthage/Checkouts/ReactiveSwift/ReactiveSwift.xcworkspace'.
--- xcodebuild: WARNING: Unable to open project file '/Users/asb/how-carthage-works/Carthage/Checkouts/ReactiveSwift/ReactiveSwift.playground' in workspace '/Users/asb/how-carthage-works/Carthage/Checkouts/ReactiveSwift/ReactiveSwift.xcworkspace'.
*** Building scheme "RxBlocking-iOS" in Rx.xcworkspace
--- xcodebuild: WARNING: Unable to open project file '/Users/asb/how-carthage-works/Carthage/Checkouts/RxSwift/Rx.playground' in workspace '/Users/asb/how-carthage-works/Carthage/Checkouts/RxSwift/Rx.xcworkspace'.
--- xcodebuild: WARNING: Unable to open project file '/Users/asb/how-carthage-works/Carthage/Checkouts/RxSwift/Rx.playground' in workspace '/Users/asb/how-carthage-works/Carthage/Checkouts/RxSwift/Rx.xcworkspace'.
*** Building scheme "RxTests-iOS" in Rx.xcworkspace
--- xcodebuild: WARNING: Unable to open project file '/Users/asb/how-carthage-works/Carthage/Checkouts/RxSwift/Rx.playground' in workspace '/Users/asb/how-carthage-works/Carthage/Checkouts/RxSwift/Rx.xcworkspace'.
--- xcodebuild: WARNING: Unable to open project file '/Users/asb/how-carthage-works/Carthage/Checkouts/RxSwift/Rx.playground' in workspace '/Users/asb/how-carthage-works/Carthage/Checkouts/RxSwift/Rx.xcworkspace'.
*** Building scheme "RxCocoa-iOS" in Rx.xcworkspace
--- xcodebuild: WARNING: Unable to open project file '/Users/asb/how-carthage-works/Carthage/Checkouts/RxSwift/Rx.playground' in workspace '/Users/asb/how-carthage-works/Carthage/Checkouts/RxSwift/Rx.xcworkspace'.
--- xcodebuild: WARNING: Unable to open project file '/Users/asb/how-carthage-works/Carthage/Checkouts/RxSwift/Rx.playground' in workspace '/Users/asb/how-carthage-works/Carthage/Checkouts/RxSwift/Rx.xcworkspace'.
*** Building scheme "RxSwift-iOS" in Rx.xcworkspace
--- xcodebuild: WARNING: Unable to open project file '/Users/asb/how-carthage-works/Carthage/Checkouts/RxSwift/Rx.playground' in workspace '/Users/asb/how-carthage-works/Carthage/Checkouts/RxSwift/Rx.xcworkspace'.
--- xcodebuild: WARNING: Unable to open project file '/Users/asb/how-carthage-works/Carthage/Checkouts/RxSwift/Rx.playground' in workspace '/Users/asb/how-carthage-works/Carthage/Checkouts/RxSwift/Rx.xcworkspace'.
*** Building scheme "ReactiveMoya iOS" in Moya.xcodeproj
*** Building scheme "RxMoya iOS" in Moya.xcodeproj
*** Building scheme "Moya iOS" in Moya.xcodeproj
```
 Hmm, I'm definitely seeing the issue on the latest release, but not on `master`. It seems to come and go.

@mobilestar0223 after it fails, can you open the `Rx.xcodeproj` inside `Carthage/Checkouts/RxSwift` and see if you can build the RxCocoa target from Xcode? If not, can you paste your error?
Trying to get a handle on what the issue is.

We may just want to do a new release soon -- not sure if that will fix the problem though, let's investigate it
 I think I've got a handle on the issue - I'm only seeing the `Ld` error from `RxCocoa` if I'm trying to build version `3.0.0-beta.1`, if I checkout `RxSwift` at `3.0.1` instead, I don't get the build failure

So we should release master as a new version ASAP, since our latest release (https://github.com/Moya/Moya/releases/tag/8.0.0-beta.3) points to RxSwift `3.0.0-beta.1`.

@ashfurrow can we do a new release? The `Cartfile` on `master` points to a non-breaking install of RxSwift üòÑ 
 Aye, I'll do a release asap. Thanks for looking into this! 
 All done üëç Released as 8.0.0-beta.4, let us know if this works. I've opened https://github.com/Moya/Moya/issues/759 to decide if we want to release that as a 8.0.0 final.
 Thanks @ashfurrow!

Fix for this issue: target Moya `8.0.0-beta.4`.

If anyone is having issues, please reopen this. Im happy to help!
  Sounds like a custom parameter encoding is what you're looking for. [Here's an example](https://github.com/Moya/Moya/blob/master/docs/Examples/ArrayAsRootContainer.md) of how you might approach that, please let us know if that approach works üëç
 @loryhuz Any luck with this? 
  As discussed in #752 

Tried to make it in a way that it should only affect Circle CI üòâ   You can use a [custom endpoint mapping](https://github.com/Moya/Moya/blob/master/docs/Endpoints.md#from-target-to-endpoint) to return something other than `.sampleData`, one of [these three cases](https://github.com/Moya/Moya/blob/33d1c7ed5e1baaf927bfff412c9cc52d584d0b3a/Source/Endpoint.swift#L5-L15). That should let you return any data, any status code, and possible even a "network not connected" error. Let me know if that answers your question, and also let us know if we can improve our documentation around this. Thanks!
 Could you create a PR with the improvements you proposed? No pressure, I could look into doing that as well. üëç
 Not a problem, thanks for the thoughtful question! 
  Related to #736
  You definitely do need to add your request to a `disposeBag`, start with that. 

On issue 2: I'm going to open source my networking stack so you can see how I inlined my token request into the provider. You don't need to create a second provider for that 
 @rlam3 I changed my mind on the open-sourcing of the networking stack, decided not to make a repo for 2 files of networking code.

Basically, I have a class that wraps my provider called `Networking`, it looks like

``` swift
struct Networking: NetworkingType {
    typealias T = ProxyAPI
    let provider: OnlineProvider<ProxyAPI>
}
```

and `Networking`'s `request` function looks like

``` swift
    func request(_ token: ProxyAPI) -> Observable<Response> {
        let actualRequest = self.provider
            .request(token)
            .filterSuccessfulStatusCodes()
            .catchError(parseMoyaError)

        if token.requiresAuth {
            // makes sure the oauthtoken is fresh
            return OAuthTokenRequest().flatMap { _ in actualRequest }
        } else {
            return actualRequest
        }
    }
```

everything uses this request function. except the OAuthTokenRequest(), which is a function that goes through the provider's request function

``` swift
func OAuthTokenRequest() -> Observable<AuthToken> {
        guard let authToken = AuthToken.local() else {
            return .error(Error(Strings.Error.NotLoggedIn.title,
                                description: Strings.Error.NotLoggedIn.description))
        }

        if authToken.isValid {
            return .just(authToken)
        }

        return request(.refreshAuth(refreshToken: authToken.refreshToken))
            .mapJSON().map(AuthToken.decodeValue)
            .do(onNext: { $0.save() })
    }
```
 Let me know if you have any other questions üòÑ 

Moya really affords itself to solving this problem
 You're welcome üòÑ 

> I understand you wrap your provider in a Networking class/struct. What is NetworkingType though? I'm not understanding what you're subclassing here...

`NetworkingType` is

```swift
protocol NetworkingType {
    associatedtype T: TargetType, ProxyAPIType
    var provider: OnlineProvider<T> { get }
}
```

its a wrapper for the provider (I'm using a custom provider that takes into account the online status, `OnlineProvider` is just a subclass of `RxMoyaProvider`), that has the custom `request` function I was talking about.

> Where would my requestClosure and endpointClosure be? Also in the provider? I need to do be able to modify my request based on its HTTP methods.

The `requestClosure` and `endpointClosure` stay inside the provider.

> Where does Networking's request function exist? Is it in the Networking class/struct?
> If it exists within the same Networking struct/class... what is the _ in front of token? 

Yup üòÑ `Networking`'s `request` function is inside the `Networking` struct.
The `_` in `request(_ token: ProxyAPI)`? That just makes it so you can call `request(.getMyTweets)` instead of `request(token: .getMyTweets)`. It's a swift language feature, just syntactic sugar üòâ

> What exactly are you trying to do here:
> You're calling back on the same provider class and passing a token into the request? Or is it the API enum?

You're right again, `actualRequest` calls the `request` function on the provider, it passes in the OAuthToken in the `flatMap` right after the definition.

> Does OAuthTokenRequest also exist inside of Networking class/structure, or in it's own seperate class?

`OAuthTokenRequest` is a global free function.

> what are the trade offs of using an Observable rather than Endpoints?

Not sure what you mean üòû If you rephrase that, I'm happy to help you understand it further üòÑ 

> If you can't provide the opensource version of it. Could you please provide me with a few gist? Thanks!

[NetworkingType.swift](https://gist.github.com/AndrewSB/4f1f1256a0a35e82ac44cf7d3dba56f0) [OAuthTokenRequest.swift](https://gist.github.com/AndrewSB/f41d5834afc32b284957535192221f38)
 I am indeed wrapping my provider inside this `Networking` struct. I later create an instance of my networking client by 

``` swift
static func newDefaultNetworking() -> Networking {
  return Networking(provider: OnlineProvider(endpointClosure: endpointsClosure))
}
```

`TargetType` comes down from Moya, `ProxyAPIType` (Proxy is the name of the iOS app from which I'm showing you code) is a protocol that defines some additional params that each of my endpoints must provide:

``` swift
protocol ProxyAPIType {
    var parameterEncoding: ParameterEncoding { get }
    var accept: String { get }
    var contentType: String { get }
    var contentLength: Int? { get }
    var requiresAuth: Bool { get }
}
```

So for me, having this `Networking` wrapper accomplishes 2 main things
1. It lets me use the `OnlineProvider` to only send networking requests when Reachability says I have internet connection (watch out for #722, I haven't solved the problem there yet)
2. It allows me to have a custom `request` function ([gist](https://gist.github.com/AndrewSB/4f1f1256a0a35e82ac44cf7d3dba56f0#file-networkingtype-swift-L14)) that reactively injects an OAuthToken to all endpoints that `requiresAuth` from `ProxyAPIType`

Let me know if you have any other questions, I'm here to help üòÑ 
 Associated types work, I'm using this in swift 3, I can show you how I'm doing my OAuthToken expiry, I'll post a gist soon

EDIT: [OAuthTokenRequest gist](https://gist.github.com/AndrewSB/973d81843a834c68c8cfb916830cd92d)
So in my `Networking` struct's `request` function, if the target required authentication, I `flatMap` this `OAuthTokenRequest` into the target, to make sure it's valid and fresh, then I grab it from my persistent storage 
 Closing this for now. Let us know if you still have any questions, @rlam3 :) My AuthToken.swift just holds a model struct, nothing interesting there.
Let me try to illustrate the sequence in which my requests chain through an example

1. I call `Networking.request` for my `.me` endpoint
2. `Networking.request` goes ahead and adds some decoration to the response, i.e. filtering out successful status codes, and parsing the error if there was one (https://gist.github.com/AndrewSB/4f1f1256a0a35e82ac44cf7d3dba56f0#file-networkingtype-swift-L15)
3. `Networking.request` also signs the request with an AuthToken if required https://gist.github.com/AndrewSB/4f1f1256a0a35e82ac44cf7d3dba56f0#file-networkingtype-swift-L20. Since this is a flatMap, it passes control to the OAuthTokenRequest, and only sends the `.me` request after `OAuthTokenRequest()` `.next`s.
4. Looking at `OAuthTokenRequest` (https://gist.github.com/AndrewSB/973d81843a834c68c8cfb916830cd92d), you can see that it either returns a local valid token (in which case the request is signed and it goes out to Alamofire), or does a `Networking.request` to the `.refreshAuth` endpoint, which would repeat steps 1-2, and skip over 3 & 4, since the `.refreshAuth` doesn't `requireAuth`. Once we hear back from the network with a new AuthToken, our `OAuthTokenRequest()` returns the `AuthToken`, we sign the `.me` request, and it goes out to Alamofire

Let me know if I was unclear anywhere, or if you have further questions!

Re the `.error`: which error are you referring to? [This](https://gist.github.com/AndrewSB/4f1f1256a0a35e82ac44cf7d3dba56f0#file-networkingtype-swift-L18) one? can you make your example more concrete? Are you saying your implementation requires two tokens to sign each request? OAuth and something else? I'd add a `requiresCSRF` and a `requiresOAuth` to each your `TargetType` enum, and then do some sort of pattern matching, maybe:

```swift
switch (target.requiresCSRF, target.requiresOAuth) {
    case (false, false): return actualRequest
    case (true, false): return CSRFTokenRequest().flatMap { _ in actualRequest }
    case (false, true): return OAuthTokenRequest().flatMap { _ in actualRequest }
    case (true, true): return Observable.zip([CSRFTokenRequest(), OAuthTokenRequest()]) { _ in actualRequest }
}
```

So yup, you were on the right track! Sorry about that @rlam3! I forgot that `Observable.zip(Array<T>)` expected the array to be an array of one element. Try this instead

```swift
Observable.zip(CSRFTokenRequest(), OAuthTokenRequest()) { _, _ in actualRequest }
``` Hey @rlam3! Sorry about not responding, this must have slipped past me on my notifications!

If your `OAuthTokenRequest` depends on your `CSRFTokenRequest` then you don't want to zip, Zip is good when you have two operations that don't depend on each other you'd like to have completed, (diagram for reference) http://rxmarbles.com/#zip

If your OAuthTokenRequest is dependent on CSRFTokenRequest, you should 

```swift
CSRFTokenRequest()
  .flatMap { csrfToken in OAuthTokenRequest(csrfToken) }
  .flatMap { _ in actualRequest }
``` @rlam3 I renamed this issue to reflect what the discussion turned into, I hope that's alright with you, please let me know if I should change it back or change it to something else üôÉ I'd say (after thinking for about 5 seconds) make your authtoken observable
share replays, that way you'll only have one AuthToken request actually
issued.

You'll also have to handle invalidation of the token somewhere internally,
as soon as the token expires the replay-able event should be dropped so the
next subscription to the observable triggers an actual auth token refresh

While working on this myself, I used http://github.com/Expirable and
thinking of my AuthTokens in that way really helped me

Here if you need clarification!
On Tue, May 23, 2017 at 12:22 AM (Alfred) <notifications@github.com> wrote:

> @AndrewSB <https://github.com/andrewsb> I face a problem when the access
> token expires and multiple requests happen, that all request a new access
> token via the refresh token, at the same time.
>
> I noticed that Ello-iOS is handling multiple unauthorized requests by
> call request/refresh token at a time and waiting for a new token on other
> requests.
>
> I don‚Äôt see the similar feature on Artsy Eidolon. Does your code support
> this?
>
> Does trackInFlights will help. I didn‚Äôt see much information or document
> about it, just read in some related issues/commits?
>
> ‚Äî
> You are receiving this because you were mentioned.
> Reply to this email directly, view it on GitHub
> <https://github.com/Moya/Moya/issues/748#issuecomment-303312259>, or mute
> the thread
> <https://github.com/notifications/unsubscribe-auth/ADo1dFHJvTTo97u-Jt-W6a9DvlzVhNJvks5r8okGgaJpZM4KjFdG>
> .
>
 @AndrewSB think you meant https://github.com/AndrewSB/Expirable :wink: I did, thanks for catching that @pedrovereza!

Also, this thread is becoming awfully long, I'm going to lock it so it doesn't become much longer. @dangthaison91 if you want to follow up on handling multiple unauthorized requests at once, can you create a new issue and mention your earlier comment in it?  @wongzigii: #737 updates the `Cartfile`, not the `Cartfile.resolved`. How does having an outdated `Cartfile.resolved` affect your builds? Are you running `carthage bootstrap`, not `update`?
 Hmm #737 has my carthage install functioning properly, what command are you using to build your dependencies?
 Hmm, when I `carthage update` for `github "Moya/Moya" "master"`, it's checking out and building the latest compatible versions of the dependencies, it doesn't look as if it's pinned to the versions in the `Cartfile.resolved`

```
> carthage update --platform iOS
*** Fetching Moya
*** Fetching RxSwift
*** Fetching Alamofire
*** Fetching Result
*** Checking out Alamofire at "4.0.1"
*** Downloading Result.framework binary at "3.0.0"
*** Checking out ReactiveSwift at "1.0.0-alpha.3"
*** Checking out RxSwift at "3.0.1"
*** Checking out Moya at "1b1edcf782bdf9eea0fa0c55c18275904d35d1e6"
```

Are you seeing anything different?
 It can be updated, but updating it has no effect on usage of the library - it's a build artifact, right?

Are you interested in updating it just for the sake of updating it? Or to solve an issue you've noticed with using Moya?
 Ahh, I understand - I thought you were running into a build problem and I wanted to make sure that wasn't the case üòÑ 
  We piggyback on Alamofire for networking requests, which you can [configure with a custom manager](https://github.com/Moya/Moya/blob/master/docs/Providers.md#manager), so it _should_ work. Let us know üëç
 Awesome, thanks! Do you think we should add any documentation about this? Maybe something to the readme? 
  We've been facing a lot of time-out issues when running `bundle exec pod install` in Circle CI.
This is an attempt to fix it (or at least make it happen less often).

Suggested in https://discuss.circleci.com/t/cocoapods-timing-out/7494
 Thanks for taking care of this!
  Plugins probably aren't the best way to approach this, I'd suggest subclassing either the RxMoyaProvider or ReactiveMoyaProvider and use RxSwift or ReactiveCocoa to `retry` on failures. There is no straightforward approach, I'm afraid. Even if you don't use RxSwift or ReactiveCocoa, I would still recommend subclassing and putting the necessary logic in the `request` function.
 _Edited your comment to enable code highlighting_ :wink:
 This is great, thanks @raphaelcruzeiro! Except for basic HTTP auth, Moya has remained largely agnostic about authentication. Do we think this should go in the library itself or in the documentation?
 Cool do you think this could go into our existing [Examples section](https://github.com/Moya/Moya/tree/master/docs/Examples)? Or do you think it should be separate?
  Does @haydarKarkin's answer solve your problem, @zeew? Let us know it doesn't :)
 Closing this for now @zeew, please re-open this if @haydarKarkin's solution doesn't solve your problem! @mrdaios can you elaborate? You want to have a variable timeout based on the target? For example: you want `.zen` to timeout in 60 seconds, but `.requestSomeThings` to timeout after 45 seconds? Hmm, yeah. That's an interesting question. I don't know if we have a per-target timeout setup yet.

The easiest thing right now, would be to add `var timeoutInterval: TimeInterval { get }` to your enum, and cancel override the `provider.request` function to cancel the request after the `target. timeoutInterval `.

To get a better solution for per target timeouts, creating a new issue is probably the best idea, to get other people's opinions üòÑ    Hmm, I've always been using the `~>` syntax with pods, as per [the guides](https://guides.cocoapods.org/using/using-cocoapods.html). Anybody knows the difference? Should we update the README? @Moya/contributors 
 The `~>` syntax assumes that all versions adhere to semantic versioning, which our betas have not done. So until we release 8.0 I'd recommend to keep the existing readme instructions. 
  Does @WildDylan's answer solve your problem, @wenzhaot? Let us know it doesn't :)
 This should be fixed by #767. I'm going to close, feel free to re-open if the problem persists üëç
  Not sure, it looks like the `\` in the original string are getting escaped ‚Äì sometimes this happens with `print`. I've never used Postman, how are you getting the value returned from `mapString()`? 
 And you're just using `print(about)`? I'm just wondering if it's actually working but `print` is doing something weird. 
 I don't, I'm sure there are solutions to this. [`mapString`](https://github.com/Moya/Moya/blob/bc434f64bf39dc67c1fd73b4968f002dfb92e605/Source/Response.swift#L74-L79)'s source code is pretty straightforward, this could be something with Alamofire. To be honest I'm not sure which direction you should go in, I would look up issues on Alamofire's repository and google how to prevent double-escaping. Sorry for not having a more satisfactory answer, please let us know how it goes üëç
 Glad you got it sorted out, and thanks for following-up with the solution üëç I'm sure it'll be of help to others. 
  Does @fjcaetano's answer solve your problem, @ohohco? Let us know it doesn't :)
 Closing this for now, feel free to reopen when you are still running into this issue!  Updates dependencies to their latest versions, including a final release of RxSwift. See #720 for more info.
 CI errd out for some strange reason, attempting a rebuild
 Attempting another rebuild now that #745 seems to have saved `cocoapods/repo/master`
 And it got past `pod install`. I'm so happy :tada:
  Anyone from @Moya/contributors available to take a look at this PR?
 Is this worth a note in the Changelog?
 Yeah, can't hurt! Thanks! 
 Thanks a lot for contributing to Moya! I've invited you to join the Moya GitHub organization ‚Äì no pressure to accept! If you'd like more information on what that means, check out our [contributor guidelines](https://github.com/Moya/contributors) and feel free to reach out with any questions.
  Merges #674.
  #721 hadn't updated unit tests to refer to new function names, this PR updates the tests. I also restart tests on CI in case they fail the first time (see #725).
  Thanks a lot for contributing to Moya! I've invited you to join the Moya GitHub organization ‚Äì no pressure to accept! If you'd like more information on what that means, check out our [contributor guidelines](https://github.com/Moya/contributors) and feel free to reach out with any questions.
  The closure is called with a `Result`, which is one type. You are now referring to two (`endpoint` and `done`)
  We don't need to use the RC now that it's out officially.
  Really cool project from @devxoul. 
  Great question, we should improve our documentation about this because you're not the first to ask this. 

It's deceptively simple, actually: you need to provide an array of the parameter values. Something like

``` swift
return [
    "status": [ "draft", "live" ]
]
```

Let me know if that works üëç
 The `[]` is standard HTTP way to send an array of parameters, I'm surprised it's not working. I took a look through the documentation and couldn't find the endpoint you're using. Can you point to that documentation?

It's possible to do exactly as you ask, with duplicate status parameter fields, but you'll need a custom parameter encoder. You can see an example of how to use custom param encodings here: https://github.com/Moya/Moya/blob/master/docs/Examples/ArrayAsRootContainer.md
 I see, very interesting! A custom parameter encoding looks like your only option. Using one will be very similar to Alamofire custom parameter encoding. I looked at their issues and found a very similar question here: https://github.com/Alamofire/Alamofire/issues/965 I hope that helps, I'm sure you can do it üëç Once you've figured it out, I'd love to see more documentation in Moya around this, so please consider either posting your solution here or sending a pull request to add it to our docs.
 Hey @tuyendv2, have you ever found a solution for this? Would love to add it to our documentation. :) @tuyendv2 closing this for now, but we'd love to hear back from you! Please re-open this if you found a solution we can add to our docs üòÑ   Thanks a lot for contributing to Moya! I've invited you to join the Moya GitHub organization ‚Äì no pressure to accept! If you'd like more information on what that means, check out our [contributor guidelines](https://github.com/Moya/contributors) and feel free to reach out with any questions.
  You should be able to use rc 1 of RxSwift, we just haven't had a chance to update the readme yet. Let me know if it works üëç
 Yikes! I'm not too familiar with how we work with Carthage. Updating our Cartfile might fix the issue, can you send a PR? 
 Should be fixed by #727. But now we need ti move to their final release (I'll do that now).
  The intermittent CI failure fix from https://github.com/Moya/Moya/pull/723 didn't work, so I need to find out why. Also, according to [this comment](https://github.com/Moya/Moya/pull/723#issuecomment-254607549) we should be filing radars about it with details. Moya's in the distinct position of being fully open source, and we should use that to our advantage and provide lots of details for the Apple developers to fix the underlying issue.
 Same failure occurred in #731, it seems. 
 This should be fixed by #734.
  Hey there @kanishkatn. There was an update for `ParameterEncoding` type in `Alamofire`, so we had to adapt as well. Everything should be clean when you read it [here](https://github.com/Moya/Moya/blob/master/docs/Endpoints.md#from-target-to-endpoint). Basically there is no `enum` anymore, just a protocol that you have to implement. There are also 3 predefined types that you can use:`URLEncoding`, `JSONEncoding`, `PropertyListEncoding`. These you can use by `.default` property, like: `JSONEncoding.default` in your case.

Hope it helps! üëä 
 Closing this for now, please reopen if you run into any issues with @sunshinejr's explanation.   Every time `xcodebuild` is run on CI, there's a chance the simulator won't start ([example build](https://circleci.com/gh/Moya/Moya/709)). Here's the error message:

```
2016-10-17 11:36:18.717 xcodebuild[8123:27968] Connection peer refused channel request for "dtxproxy:XCTestManager_IDEInterface:XCTestManager_DaemonConnectionInterface"; channel canceled <DTXChannel: 0x7fabb343a9e0>
2016-10-17 11:36:18.721 xcodebuild[8123:26958] Error Domain=IDETestOperationsObserverErrorDomain Code=3 "The operation couldn‚Äôt be completed. (DTXProxyChannel error 1.) If you believe this error represents a bug, please attach the log file at /Users/distiller/Library/Developer/Xcode/DerivedData/Demo-eajasjdonmwjombqexluhpxvsaae/Logs/Test/AC08A4B2-3E7C-4F34-9902-1D51939369F7/Session-MoyaTests-iOS-2016-10-17_113457-EHKzKv.log" UserInfo={NSLocalizedDescription=The operation couldn‚Äôt be completed. (DTXProxyChannel error 1.) If you believe this error represents a bug, please attach the log file at /Users/distiller/Library/Developer/Xcode/DerivedData/Demo-eajasjdonmwjombqexluhpxvsaae/Logs/Test/AC08A4B2-3E7C-4F34-9902-1D51939369F7/Session-MoyaTests-iOS-2016-10-17_113457-EHKzKv.log}
** TEST FAILED **
```

We run this kind of command several times on CI, compounding the likelihood that someone has to restart it. So let's automate it :tada:

This PR changes the CI script to look for code 65 and retries a build up to three times.
 On eigen we did - https://github.com/artsy/eigen/blob/master/circle.yml#L36-L39 - which I think has basically negated the problem for us. 

However, I'm totally chill with this too - key to all of it is being extra aware of xcode faffing. 
 Turns out we do have a 15s wait:

```
def open_simulator_and_sleep(uuid)
  return if uuid.nil? # Don't need a sleep on macOS because it runs first.
  sh "xcrun instruments -w '#{uuid}' || sleep 15"
end
```

if it's still being flakey - this is a good call IMO.
 Hmm, doesn't appear to be working:

<img width="649" alt="screen shot 2016-10-18 at 9 03 02 am" src="https://cloud.githubusercontent.com/assets/498212/19478758/c7ba4c70-9511-11e6-8512-9bbcf3160ea2.png">
 Cool, will do @russbishop :+1: I've opened #725 to make sure I don't forget, will likely get to it this weekend. 
  Hmm, not sure where that milestone came from actually. I agree it's time to consider releasing Moya 8.

We're still ironing out regular bugs and other breaking changes for Swift 3, personally I'm fine with keeping it in beta for now. Especially since if we go final with beta versions of RxSwift/RAC, and then there's another RxSwift/RAC beta with breaking changes, then we need to have a new major version to avoid breaking semantic versioning.
 I also think that we should stay in beta as long as our dependencies are. No need to rush and ReactiveSwift isn't even out of alpha. Also, I've removed the milestone to avoid confusion. 
 It's a fair point, thanks for bringing it up. I think a new beta makes at least makes sense, I'll try to get it done today.
 Cool, beta 3 is up and pushed for Carthage and CocoaPods üëç
 RxSwift's updated to 3.0 final, so we're just waiting on Reactiveswift now. ~~I'll open an issue asking for a timeline~~Looks like they only have one issue left and there's [already a PR](https://github.com/ReactiveCocoa/ReactiveSwift/pull/48) so it shouldn't be too long.
 Closing in favor of #759
  Related to #668.
  What a great question! Usually for example URLs that aren't meant to ship, I use example.com ‚Äì this sounds like a good alternative? 
 It would be a can of worms, unfortunately. The trouble is that somewhere ‚Äì either inside Moya or outside ‚Äì someone needs to deal with the fact that a call to `NSURL(string: )` might return `nil`. We've decided it's better to give the user of the library the flexibility to fail as they like, instead of having Moya fail or work unexpectedly.

It's a balance, there are arguments for both approaches. Do you think adding documentation of this rationale might help explain it to other Moya users? Where should we put that documentation? 
 Agreed, Basic Usage is already a large document. 

We could create a new `Advanced.md` file and discuss it there. Could you send a pull request adding it? 
 This issue has been marked as stale because it has not had recent activity. It will be closed if no further activity occurs. 
 This issue has been auto-closed because there hasn't been any activity for 59 days. However, we really appreciate your contribution, so thank you for that! üôè Also, feel free to [open a new issue](https://github.com/Moya/Moya/issues/new) if you still experience this problem üëç.
  Thanks a lot for contributing to Moya! I've invited you to join the Moya GitHub organization ‚Äì no pressure to accept! If you'd like more information on what that means, check out our [contributor guidelines](https://github.com/Moya/contributors) and feel free to reach out with any questions.
  Closes #715

As detailed in #715, the callbacks of the download requests were never being called because the `DownloadRequest` does not inherit from the `DataRequest`.

What was changed was that there is now an different cast for download requests. This is based on the [code that is found in the Alamofire example](https://github.com/Alamofire/Alamofire/blob/master/Example/Source/DetailViewController.swift#L104-L112). The second casts fixes the completion block never getting called issue but the progress is still wrong.

I noticed when trying to write tests for this that the progress object will never have its completed property be true since it requires a response to be present. In all the code for progress tracking a response is never set so what I did is that on request completion update the progress object to have a response. Doing so has the desired effect of having the progress object returning completed.

This also contributes to increasing the code coverage from #668.
 Great PR, thanks! The only feedback I have is in the comment above. If you like, we can address it now, or we can open an issue to address it later. 
 @Ernest-su, what do you mean? Is this a possible bug? If you can create an issue for that, that'd be greatly appreciated!  Not sure, but shouldn't the `.Custom` be `.custom`?
 @shivayogic if you are using Swift 3 version of Moya, there is no `enum` for `ParameterEncoding`. If you want custom one, you need to implement `ParameterEncoding` protocol. More on the topic in our documentation [here](https://github.com/Moya/Moya/blob/master/docs/Endpoints.md#from-target-to-endpoint). Hope it helps! üëä
 @shivayogic usually you don't need to specify custom `httpBody`, parameters do it for you. If you want to add parameters that you want in every request, then `endpointClosure` might be the best way. However if your case is a specific one, you might try to replace the httpBody of a request in `requestClosure`.
  Hey there, great question! 

First, to return empty data you can `return Data()`, which makes things a little easier. 

The data you return should be a response representative of what your API actually returns. For example, if you request a `user` object from a REST API, you should get back some JSON that represents a user (encoded in `Data`). In my apps, I'll store this JSON as files and read them from disk when asked to (note: `sampleData` is not called except when stubbing, so it's not accessed in production).

The reason it's not optional is to force developers to specify something so it's easier to unit test the code that uses Moya. Network call stubs are first-class citizens in Moya, and are as foundational to the library. I understand that not every developer agrees, so `return Data()` is always going to be an option for developers to opt out of this behaviour. But since all network responses _do_ return some data (even if it's empty) then it doesn't make to make the property optional. 

I hope this clarifies things to your satisfaction. We're always looking for ways to improve our documentation, do you have any suggestions where we could add this explanation to help future developers? 
 Ah, you're looking to stub requests locally, to return previous requests? Interesting. I'll have to think about that. 

Having a plugin to record network calls might be cool, too, especially for testing. 
 I agree with @DeepMissea. This should be it's own library, caching is really hard

Plug for a talk my friend gave: https://www.youtube.com/watch?v=8uqXuEZLyUU
He talks about a caching library called Carlos, I haven't tried it, but he makes a good case for using it https://github.com/WeltN24/Carlos

Caching would be a level above Moya though 
You'd probably want to use Carlos from your application level, and Moya (i.e. the network) would be one of the *caches* you could fetch from. @WildDylan can you elaborate? 
Are you saying that you'd like Moya to implement a cache that follows the cache policy you outline? @WildDylan I'm going to close this for now, please do re-open if you'd like to further explore adding a cache!  Hey @zhigang1992! I know the feeling so don't worry about it üëä 

You can extend `TargetType` protocol with `ParameterEncoding` parameter, then in the `endpointClosure` use the `parameterEncoding` from target. [Here](https://github.com/sunshinejr/FlexibleMoya/blob/c33f9b9bbeddab2776de33f08d802660dab3ea4b/FlexibleMoya/Networking/Utils/MoyaUtils.swift#L14) you have example how I did it with `authToken` type, just instead of `authToken` use `parameterEncoding` in the `Endpoint` init. 

More on the `endpointClosure` you can also find [here](https://github.com/Moya/Moya/blob/master/docs/Endpoints.md#from-target-to-endpoint).

Hope it helps! If you have more questions or something is unclear, shoot üôÇ
  What do you mean? I am not sure I understand your question.
 If you look closely at @MoyaBot's message, you can see it is generated by [Danger](http://danger.systems/). :)
  Hey all! üéâ  Due to #681 and new `ParameterEncoding` type, we also have to update our documentation around it. Let me know if there is something to improve! 
  I think a way this can be accomplished now is to create a custom `ParameterEncoding` that searches for the `"key"` parameter makes sure to encode that first. Since there hasn't been any activity on this thread for some time, I am going to go ahead and close it. Please re-open or create a new issue if you would like to discuss further. Thanks.  Hey @lolgear! I believe you're talking about some changes that I made last month.

https://github.com/Moya/Moya/pull/563 is the pull request that suggested those changes, and the comments there go into the rationale behind the choices I made, and how it solves the dependency management mystery üé© 

I'm around if you have any follow up questions, or if you want me to talk about the _tricks_ I'm using in more detail üëä
 Yup, @petester42 is completely right.
By including the line `github "Moya/Moya"` in a Cartfile, it builds all three of the shared targets (Moya, RxMoya, and ReactiveMoya), as well as all of the dependencies, and then you choose which frameworks you want to drag into your linked frameworks
 üëç 
  The backend I'm dealing with is sending custom error code and message in response data in certain situations.
Although it's not the perfectly designed backend, there is no way to change it right now. 

The goal is to transform this response data to a Moya.Error.underlyingError(NSError). This NSError should have a custom domain and the values sent from the server as its userInfo. 
Main reason for that, I'm working on a framework which will be used in an Objective-C project and this Moya integrated framework should return values similar to old Objective-C implementation that the project is using. 
I didn't want to do filtering after each call to request(:) of my providers, so I want to do this in a common place. 

Example response:

```
Http status code: 401
Response data:
{errorCode: 3, errorMessage: "Authorization required"}
```

Current solution: 

``` swift
extension ReactiveCocoaMoyaProvider {

    func customRequest(token: TargetType) -> SignalProducer<Response, Moya.Error> {
        return self.request(token: token).flatMap(.latest) { (response: Response) -> SignalProducer<Response, Moya.Error> in

            let json = JSON(data: response.data)

            // Convert response.data to APIError instance
            guard let apiError = APIError(jsonData: json) else {
                return SignalProducer<Response, Moya.Error>(value: response)
            }

            let userInfo = [NSLocalizedDescriptionKey: apiError.message, "httpStatus": response.statusCode, "areaStatus": apiError.errorCode, "url": response.request?.url?.absoluteString] as [String : Any]
            let mappedError: NSError = NSError(domain: "custom error domain", code: response.statusCode, userInfo: userInfo)

            return SignalProducer<Response, Moya.Error>(error: .underlying(mappedError))
        }
    }
}
```

Then, user of my framework needs to call `customRequest(:)` for each provider call, which is not really nice. Another problem is I can't write a stub for the extension method to test it. 

Nicer solution would be subclassing `ReactiveCocoaProvider` and overriding `request(:) method, but`request(:)`is not defined as open (not like in`MoyaProvider`).

So is it possible to define `ReactiveCocoaProvider.request(:)` as `open`?

In fact, both of these solutions don't seem much convenient. Is there a better solution?

My suggestion would be letting Plugins alter the result by returning the altered result from `didReceiveResponse()` protocol method.
However, there can be multiple protocols which could make this solution complicated. Maybe a single instance plugin with different kind can be used, something like `"ResultTransformerPlugin"`. 
 This issue has been marked as stale because it has not had recent activity. It will be closed if no further activity occurs. 
 This issue has been auto-closed because there hasn't been any activity for 59 days. However, we really appreciate your contribution, so thank you for that! üôè Also, feel free to [open a new issue](https://github.com/Moya/Moya/issues/new) if you still experience this problem üëç.
  What is your `Podfile` like?
 Hey there, can you double-check the installation instructions for CocoaPods [in the readme](https://github.com/Moya/Moya#cocoapods)? Then run `pod update Alamofire Moya` and that should do the trick üëç
  Hmm, what an interesting idea! I think if we were to include `NSURLResponse`, we would want to remove the `Int` status code. Another solution would be to add another `case` to the enum. I think that would make a lot of sense, actually. Want to send a pull request? 
 Adding documentation for this change is definitely appreciated! üòÉ 
  This seems like a great addition! Would you be able to submit a PR implementing this, @jeryRazakarison?
 Closed by #767, thanks @jeryRazakarison! 
  Related to #696 

Currently there's no watchOS test target. Was that an oversight? Should I create one?
 Oh wow üòÇüòÇ
I wonder when Apple will decide that watch apps deserve tests üòõ
 This works with a carthage install, but is completely broken when you're using Cocoapods, and since CI uses Cocoapods as well, CI is reporting ‚úñÔ∏è.

Are there any cocoapods users from @Moya/contributors that have some time to un-break the tests when installing through `pod`?
 Might take a look at this soon. :) Sounds awesome @BasThomas!

I tried rebasing, but I'm not sure what a lot of the changes on `master` have been.
Wasn't sure how to handle this conflict while rebasing

<img width="859" alt="screen shot 2016-12-01 at 12 29 58 pm" src="https://cloud.githubusercontent.com/assets/3814772/20811277/ea6fd65e-b7c1-11e6-9c58-2610f7f77cb8.png">

So I didn't finish the updating this branch. Do you know why those files were changed on master? 
I'm around to fix the conflicts, or you can take a shot if you'd like Hmm, just started "fresh" on this, but Xcode is complaining when moving the `Tests` directory into the root.

<img width="1650" alt="screen shot 2016-12-09 at 19 44 35" src="https://cloud.githubusercontent.com/assets/4190298/21060518/0cd1656e-be48-11e6-97b0-6c95fbbbd6ab.png">
<img width="1650" alt="screen shot 2016-12-09 at 19 44 40" src="https://cloud.githubusercontent.com/assets/4190298/21060520/10558df0-be48-11e6-9e3c-1d56d7bb0bdc.png">
<img width="1650" alt="screen shot 2016-12-09 at 19 44 47" src="https://cloud.githubusercontent.com/assets/4190298/21060531/1b2069ee-be48-11e6-8028-c750376f73cd.png">
<img width="1650" alt="screen shot 2016-12-09 at 19 47 27" src="https://cloud.githubusercontent.com/assets/4190298/21060567/57ec0734-be48-11e6-9b19-d536b57797a8.png">


Not sure how to proceed :/ fresh as in pulling from `master` and manually redoing the work? If that's what you're thinking of doing, I can take the lead instead. I got it working before, so I can probably figure it out again.

Xcode looks as if it's expecting some source files and they're no longer there. Maybe you moved them in the filesystem without updating the xcodeproj? @BasThomas I think I'm just going to redo this PR, that seems easier than managing all the rebase merge conflicts we're going to hit.
I'll do it later today üëç Created #885 to continue this  Hey! Thanks for the PR! Although at the first glance I don't get the error here, so I've made a comment about the line that is confusing me the most. 
 Well, I didn't know about this caveat, not sure if this is intended behaviour of Swift, but glad you discovered it and shared with us! Only one more comment from me and we are ready to merge. Thanks again!
 Thanks a lot for contributing to Moya! I've invited you to join the Moya GitHub organization ‚Äì no pressure to accept! If you'd like more information on what that means, check out our [contributor guidelines](https://github.com/Moya/contributors) and feel free to reach out with any questions.
  Thanks a lot for contributing to Moya! I've invited you to join the Moya GitHub organization ‚Äì no pressure to accept! If you'd like more information on what that means, check out our [contributor guidelines](https://github.com/Moya/contributors) and feel free to reach out with any questions.
 Thanks @Viniciuscarvalho!
  Merges #685 and adds a test for a nil urlRequest.
  Can someone take a look at `From Target to Endpoint` here? Alamofire's encoding has changed, but I am not entirely sure how myself.

https://github.com/Moya/Moya/blob/master/docs/Endpoints.md

This also might mention some incorrect code(?)

https://github.com/Moya/Moya/blob/master/docs/Examples/ArrayAsRootContainer.md
 @nanoxd, any idea?
 Right, closing this in favor of #681.
  As discussed in #684

``` swift
public enum Method: String {

    case options = "OPTIONS"
    case get     = "GET"
    case head    = "HEAD"
    case post    = "POST"
    case put     = "PUT"
    case patch   = "PATCH"
    case delete  = "DELETE"
    case trace   = "TRACE"
    case connect = "CONNECT"
```
 Was just busy doing this, thank god I had a GitHub window open üôà
 @BasThomas Oh, my bad! Totally forgot to mention I was working on it üòÖ 
 No worries!
  Thanks a lot for contributing to Moya! I've invited you to join the Moya GitHub organization ‚Äì no pressure to accept! If you'd like more information on what that means, check out our [contributor guidelines](https://github.com/Moya/contributors) and feel free to reach out with any questions.
  This is a great idea and a swell PR. We (I?) added the IUO because it was easy, but this is definitely the better approach. Thanks!

I've restarted CI, it failed due to a version mismatch in the Podfile.lock. Do the tests pass locally?
 CI is running on https://circleci.com/gh/Moya/Moya/608 , I just had to rerun without the cache. 
 We should add tests to be sure there aren't any regressions as well as document the change and a migration plan for existing users (if any). 
 Agreed, a changelog entry should be sufficient though ‚Äì this isn't any more intrusive than the other breaking changes we've got on master. The tests have been updated, too, so I think it's just the changelog entry that's missing. 
 I should read more closely at filenames üòÖ. 
 This is great, I'll take care of the test and merge :+1:
 In this case, I did the following to resolve the conflicts:

``` sh
git remote add KelvinJin https://github.com/KelvinJin/Moya.git
git fetch KelvinJin
git checkout KelvinJin/master
git checkout -b merge-685
git pull origin/master
```

git resolved the changelog conflicts, I just had to resolve a conflict with a unit test from #688. I did need to run `bundle exec pod update ReactiveSwift`, since CocoaPods was giving an error. Then I `git add . ; git commit` and used the default merge message. 

Let me know if anyone has any questions about this workflow, it might be worth writing up in a blog post sometime. 
 No problem, two different objects can have the same hash value without any major consequences (as long as two equal objects don't have different hash values, it should be fine). 
    Thanks for noticing! I've fixed it now :)
  It looks like Alamofire removed [ParameterEncoding enum](https://github.com/Alamofire/Alamofire/blob/d59ed4f611a447c98881be24764b130e3f7d24bd/Documentation/Alamofire%204.0%20Migration%20Guide.md#parameter-encoding-protocol) for a Protocol of the same name. 

We [typealias locally](https://github.com/Moya/Moya/blob/master/Source/Moya%2BAlamofire.swift#L13) here and use it in [Endpoint](https://github.com/Moya/Moya/blob/master/Source/Endpoint.swift#L23). 

The [docs](https://github.com/Moya/Moya/blob/master/docs/Endpoints.md#from-target-to-endpoint) should be updated to remove the enum values. 

Will the change cause issues with Moya's usage of ParameterEncoding?
 Great question, thanks for linking to relevant code :bow: We definitely need to do something here, at least in docs. I'll take a look later today and see what we can do. 
 Cool, that sounds like a good fix @RamwiseMatt. I think we just need to update our docs then, right? Anyone available for a pull request? 
 Hey @bryanbartow, only typo I found in your code is the `.GET` instead of `.get` enum case, otherwise it should be good to go. I've tested it in the Moya demo and was building correctly. If there are still some errors and cleaning doesn't help, let us know! 

Also I've made a PR with the `ParameterEncoding` changes so I'm gonna close this one in favor of #709. If you guys could chime in there, it would be awesome! üëä
 Oh, I will keep this opened till we resolve the issue then :)
 Closing this now, then. :)
  Missed a codeblock with `URLByAppendingPathComponent` to `appendingPathComponent`
 üôå
  Removes AnyObject casts in TargetType parameter examples
  Currently a WIP to gauge interest. Updates docs to reflect the new Swift 3 interface as well as Moya's interface.
- [x] Update enum usage
- [x] Match Swift 3 interface changes (e.g. NSURLSession -> URLSession)
- [x] Change usage of `AnyObject` to `Any`
- [x] Reflect interface changes in Moya
 YES! Thanks for this :)
 I believe that should be it but I'm sure I missed something üòÖ. 
 Thanks a lot for contributing to Moya! I've invited you to join the Moya GitHub organization ‚Äì no pressure to accept! If you'd like more information on what that means, check out our [contributor guidelines](https://github.com/Moya/contributors) and feel free to reach out with any questions.
  hello lovlies‚Äì‚ÄìI'm trying to update a community library I maintain to support Swift 3 and all, however the `Moya+Alamofire.swift` file is ERROR'ing the lint :( 

here's the output of the `pod lib lint`:

```
‚ûú  Moya-Gloss git:(master) ‚úó pod lib lint

 -> Moya-Gloss (2.0.0-beta.2)
    - WARN  | [Moya-Gloss/Core, Moya-Gloss/RxSwift, Moya-Gloss/ReactiveCocoa, and more...] xcodebuild:  Moya/Source/Moya+Internal.swift:206:16: warning: value 'progress' was defined but never used; consider replacing with boolean test
    - ERROR | [Moya-Gloss/Core, Moya-Gloss/RxSwift, Moya-Gloss/ReactiveCocoa, and more...] xcodebuild: Returned an unsuccessful exit code. You can use `--verbose` for more information.
    - ERROR | [Moya-Gloss/Core, Moya-Gloss/RxSwift, Moya-Gloss/ReactiveCocoa, and more...] xcodebuild:  Moya/Source/Moya+Alamofire.swift:9:46: error: no type named 'StreamRequest' in module 'Alamofire'
    - WARN  | [Moya-Gloss/RxSwift] xcodebuild:  Moya/Source/RxSwift/Moya+RxSwift.swift:31:20: warning: 'init' is deprecated: renamed to 'Disposables.create'
    - NOTE  | [Moya-Gloss/RxSwift] xcodebuild:  Moya/Source/RxSwift/Moya+RxSwift.swift:31:20: note: use 'Disposables.create' instead
    - WARN  | [Moya-Gloss/RxSwift] xcodebuild:  Moya/Source/RxSwift/Moya+RxSwift.swift:57:20: warning: 'init' is deprecated: renamed to 'Disposables.create'
    - NOTE  | [Moya-Gloss/RxSwift] xcodebuild:  Moya/Source/RxSwift/Moya+RxSwift.swift:57:20: note: use 'Disposables.create' instead
    - WARN  | [Moya-Gloss/RxSwift] xcodebuild:  RxCocoa/RxCocoa/Common/TextInput.swift:74:28: warning: 'RxTextInput' is deprecated: renamed to 'TextInput'
    - NOTE  | [Moya-Gloss/RxSwift] xcodebuild:  RxCocoa/RxCocoa/Common/TextInput.swift:74:28: note: use 'TextInput' instead
    - WARN  | [Moya-Gloss/RxSwift] xcodebuild:  RxCocoa/RxCocoa/Common/TextInput.swift:67:29: warning: 'RxTextInput' is deprecated: renamed to 'TextInput'
    - NOTE  | [Moya-Gloss/RxSwift] xcodebuild:  RxCocoa/RxCocoa/Common/TextInput.swift:67:29: note: use 'TextInput' instead
    - WARN  | [Moya-Gloss/ReactiveCocoa] xcodebuild:  Moya/Source/ReactiveCocoa/Moya+ReactiveCocoa.swift:5:45: warning: 'where' clause next to generic parameters is deprecated and will be removed in the future version of Swift

[!] Moya-Gloss did not pass validation, due to 2 errors and 6 warnings.
You can use the `--no-clean` option to inspect any issue.
```

relevant podspec is [here](https://github.com/spxrogers/Moya-Gloss/blob/master/Moya-Gloss.podspec). i ran with the `--verbose` tag and found the **watchOS 2.0 platform** with the **ReactiveCocoa** subspec that failed and building and removing the watchOS deployment target succeeds the lint. 

:/ hoping maybe some other contributors would have some insight, maybe @ashfurrow?
 Are you using a swift-version file? https://github.com/CocoaPods/CocoaPods/blob/master/CHANGELOG.md#110rc2-2016-09-13
 yep! @orta 
 Would recommend using `--no-clean` to take a look a the resulting folder with lint, double check all the versions of alamofire/moya are what you expect them to be - as a [StreamRequest does exist](https://github.com/Alamofire/Alamofire/blob/a946285f1b1efcb7129d546f00c90ae213678185/Source/Alamofire.swift#L438) inside head Alamofire

You can also clean your pod cache for this listing stuff with `pod cache clean`
 right, i found it too which why i thought it quite funky. 

i'll inspect the `--no-clean` output as well as clean the pod cache. 
 @petester42 yep, i am.

so: https://github.com/Alamofire/Alamofire/blob/master/Source/Request.swift#L577-L600 
... line 577 in AF only compiles `StreamRequest` if the os is not watch, explaining why the lint fails when compiling the watchOS platform :| 

i guess this begs the question on how Moya isn't encountering this as well since [it similarly supports watchOS](https://github.com/Moya/Moya/blob/master/Moya.podspec#L18)
 Interesting, watchOS isn't being tested on CI, maybe our watch support has been broken for a while and we've just not noticed until now?

We're not even using the `StreamRequest` anywhere, we should be able to delete [this line of code](https://github.com/Moya/Moya/blob/25b8072a2cffa3baff3aea90ed94afed2c03b076/Source/Moya%2BAlamofire.swift#L9) without any problems. 
 @ashfurrow funny. AF didn't introduce this type until version 4 and i had no issues updating to support Moya 7, so likely not broken for so long :) 

i'll get a PR working and make sure nothing breaks, hopefully not!
 Cool, thanks!
  Hmm, getting a legitimate failure this time, but I don't understand. Your PR is exactly what I would've done, not sure why it's failing. Keep it open and I'll investigate, thanks again!
 That's a good question! @justinmakaila can you chime in on this? 
 For what it's worth, I think @wongzigii has the right idea. We should probably be using the semantic version of a library instead of (basically) a commit hash (in this case `master`).

@wongzigii if you update the tag ReactiveSwift's release to `alpha 2`; confirm that it doesn't break anything in `ReactiveMoya`'s target, and no one from @Moya/contributors has an issue with it, I think it would make sense to merge this in.
 @wongzigii That timeout happens sometimes, I've restarted the build üëç
 Just realized we forgot to merge this, I'll deal with conflicts and merge today, thanks again üëç
 Thanks a lot for contributing to Moya! I've invited you to join the Moya GitHub organization ‚Äì no pressure to accept! If you'd like more information on what that means, check out our [contributor guidelines](https://github.com/Moya/contributors) and feel free to reach out with any questions.
  And Demo file, since they have a release we can reference now: https://github.com/ReactiveCocoa/ReactiveSwift/issues/20
 The readme, needs to use the same Podfile format as the Demo project. A PR would be awesome!
 Cool, thanks!
  This looks good, did you want to re-open it? 
 Sometimes the unit tests fail like that and someone has to restart the build. I've restarted it, if you want to re-open :+1: Thanks!
  I suppose that changelog entry is not needed here. üòâ 
  This has been fixed in #661. @ashfurrow, could a second beta be released for this?
 8.0.0-beta.2 has been pushed, @Tynox can you verify it works? 
  What is you question exactly?
 Does that answer your question, @12207480?
 @wangguangfeng unfortunately, the Swift 3 branch has dropped support for iOS 8. For the reasoning behind this, see #639
  Our code coverage is okay, at a solid 80%. We've held this for a while, but we could do a bit better. Our [current coverage](https://codecov.io/gh/Moya/Moya/tree/master/Source) has some places we could improve:

<img width="1154" alt="screen shot 2016-09-21 at 9 37 47 pm" src="https://cloud.githubusercontent.com/assets/498212/18734570/d21c2478-8043-11e6-8c54-86b7d0d3c683.png">

I'll take a look sometime, this is probably a longer-term task though. 
 Both actually, the graph above is just an outline, you can see individual files' coverage in the link. 
 Hmm. Sounds like it could be a configuration issue, do you have experience with CodeCov? Could be worth a look. 
 Looks like CodeCov can't access file names with + in them, like https://codecov.io/gh/Moya/Moya/src/master/Source/Moya%2BInternal.swift . I've contacted their support team to clear it up. 
 We're in the high 80's, CodeCov seems to be working. Gonna close this, thanks everyone üëç
  Glad you got it figured out! Thanks for posting your answer, I'm sure it'll be of help to someone. 
  Looks great! The CI failure looks unrelated, I'll open another issue to fix. 
 Thanks a lot for contributing to Moya! I've invited you to join the Moya GitHub organization ‚Äì no pressure to accept! If you'd like more information on what that means, check out our [contributor guidelines](https://github.com/Moya/contributors) and feel free to reach out with any questions.
  A PR to add this would be welcome!
  Hey @marcusficner! This is a really good question, I'm not really sure _why_ we don't use it in the `mapJSON()` function, but I would be up for introducing it there! 
 Closing in favor of #664 then!
  ReactiveCocoa -> ReactiveSwift `sendNext(_)`->`send(value:)` and `sen‚Ä¶dFailed(_)`->`send(error:)`
  Hey, check #604
  Fixes Homebrew on CI, updates installation docs, and updates Demo podfile.
 Hmm, seeing the failure locally too. 
 Looks like tests for inflight tracking were actually making network calls instead of stubbing, fixing now. 
 Weird, still getting `fatal: Not a valid branch point` on Danger. 
 Looks like Danger is already tracking this issue: https://github.com/danger/danger/issues/160
  Cool! I'll add corresponding changes for CocoaPods tomorrow (it's going to be a bit tricky).
 Thanks a lot for contributing to Moya! I've invited you to join the Moya GitHub organization ‚Äì no pressure to accept! If you'd like more information on what that means, check out our [contributor guidelines](https://github.com/Moya/contributors) and feel free to reach out with any questions.
  Thanks a lot for contributing to Moya! I've invited you to join the Moya GitHub organization ‚Äì no pressure to accept! If you'd like more information on what that means, check out our [contributor guidelines](https://github.com/Moya/contributors) and feel free to reach out with any questions.
   Okay, so still not working. Getting this error:

```
The bundle ‚ÄúMoyaTests-Mac‚Äù couldn‚Äôt be loaded. Try reinstalling the bundle.
(dlopen(/Users/distiller/Library/Developer/Xcode/DerivedData/Demo-eajasjdonmwjombqexluhpxvsaae/Build/Intermediates/CodeCoverage/Products/Debug/MoyaTests-Mac.xctest/Contents/MacOS/MoyaTests-Mac, 265): Symbol not found: _OBJC_CLASS_$_OS_dispatch_queue
  Referenced from: /Users/distiller/Library/Developer/Xcode/DerivedData/Demo-eajasjdonmwjombqexluhpxvsaae/Build/Intermediates/CodeCoverage/Products/Debug/MoyaTests-Mac.xctest/Contents/MacOS/MoyaTests-Mac (which was built for Mac OS X 10.12)
  Expected in: /usr/lib/libSystem.B.dylib
 in /Users/distiller/Library/Developer/Xcode/DerivedData/Demo-eajasjdonmwjombqexluhpxvsaae/Build/Intermediates/CodeCoverage/Products/Debug/MoyaTests-Mac.xctest/Contents/MacOS/MoyaTests-Mac)
Error Domain=IDETestOperationsObserverErrorDomain Code=5 "Early unexpected exit, operation never finished bootstrapping - no restart will be attempted" UserInfo={NSLocalizedDescription=Early unexpected exit, operation never finished bootstrapping - no restart will be attempted}
```

Has anyone seen this? I'll take a deeper look for it tomorrow. 
 Well this is frustrating. 
 Investigating one last ideal, but I think our best course of action may be to remove the macOS test target. We've done this before with tvOS when those builds were working locally but not on CI. Coincidentally, tvOS builds are now working on CI.
 Tests were passing! But Danger failed because Circle was providing the wrong commit hash. Editing the base of the PR seemed to work, fingers crossed. 
 Only danger is failing, and only because of a Circle issue, gonna merge. 
  The references to podspecs in the Demo app's Podfile are very specific, until ReactiveCocoa and ReactiveSwift have been released, even in alpha form. I'll keep my ear to the ground.
 Huh, with this new ReactiveCocoa split, we only really depend on ReactiveSwift, we can remove ReactiveCocoa as a dependency. Maybe we should rename the subspecs, too. 
 We can change the name in another PR, going to focus on getting this to üìó

Opened https://github.com/Moya/Moya/issues/648 to discuss the rename.
 These are passing locally, can be merged into the swift-3.0 branch even though the PR is üî¥
  @Moya/contributors was thinking of this. Should we add templates for issues / PRs? For example, I noticed some issues with no / incomplete Podfiles / Carthage files, which makes it harder for us to help the person with the question.

I am not sure what exactly should be in them - but they should be able to both help people with questions, as well as the people helping.

Let me know what you think; feedback is definitely welcome!
 I think this is a good idea, what are the most common miscommunications we need to address in issues? 
 Some examples:
- https://github.com/CocoaPods/CocoaPods/blob/master/.github/ISSUE_TEMPLATE.md
- https://github.com/danger/danger/tree/master/.github
 It would also be useful to make users aware of syntax highlighting for code in these templates.
 Closed after #704
 A PR template still has to / can be done maybe?
 @BasThomas you're right, my bad üòÖ 
 I don't see the need to add a PR template right now. If someone does, please reopen or submit a PR :)
  What is your deployment target? It should be iOS 9 or higher. (See #639)
 I'm not entirely sure, but you should only need the following in your Podfile:

``` ruby
pod "Moya/RxSwift", :git => "https://github.com/Moya/Moya", :branch => "swift-3.0"
```

Does that work?
  Does @aamctustwo's answer solve your problem, @Henawey? Let us know it doesn't :)
  Things we're still waiting for:

- [x] Ability to explicitly import Foundation (**pushing this off** for a future PR/release)
- [x] Ability to import libraries through dynamic/static libraries (currently spm doesn't build dependencies, it just embeds the source files in the Moya xcodeproj (**pushing this off** for a future spm release, spm doesn't support this as of now)
- [x] Merging https://github.com/Moya/Moya/pull/698, so Moya has a swift package manager compatible layout
- [x] Alamofire fixing their swift package manager installation (https://github.com/Alamofire/Alamofire/issues/1815) Both ReactiveSwift & RxSwift vend through spm now, trying to see if I can get Alamofire to work, running into some issues related to https://github.com/Alamofire/Alamofire/issues/1544

After that we should be ready to go üéâ

We still can't import `Foundation`, but I think we can go ahead without that for now, until @apple figures out how they want to handle that
 @VivienGiraud still waiting on the folks at Alamofire. 

I opened https://github.com/Alamofire/Alamofire/issues/1815, since they previously closed https://github.com/Alamofire/Alamofire/issues/1544 I'd love to get this working as well. However, short of some fragile hackery, I don't see it as a possibility while SPM doesn't support setting the deployment target and [doesn't support non Mac/Linux platforms or depending on Apple Frameworks](https://github.com/apple/swift-package-manager/blob/master/Documentation/Reference.md#depending-on-apple-modules).

The best long term solution would be hassle the SPM folks to add this in time for the next Swift version.

If SPM support is high priority, the other option is to depend instead on an Alamofire fork with the offending functionality removed (if possible) until the underlying issue in SPM is resolved. This could even be the beginning of replacing Alamofire with a Moya-specific `URLSession` wrapper. That would obviously come with it's own list of pros and cons. @scottrhoyt: I was able to use spm to deploy an iOS app (I only had one private dependency), but it was very similar to using a submodule. `swift package update` pulled down the files and built a binary (that I ignored), and then I dragged the source files into my iOS xcodeproj

not ideal, but it worked Thanks @AndrewSB. That is good to know. Like you said, you were using it very similarly to a submodule. I suspect you could get Moya to build just fine using a similar method. Even though `swift build` might fail, you can drag the resolved dependencies' source files into an Xcode project and build from there. To get `swift build` to work is another matter.

The core of the issue holding up Alamofire seems to be a dependency on a newer version of `Foundation` than the version SPM defaults to. The solution proposed by the Alamofire maintainers is to basically use Xcode configurations to override this behavior. A pure SPM solution would involve being able to depend upon specific Apple frameworks within `Package.swift`--this is what currently doesn't exist.

If the goal of getting SPM working for Moya is to add Linux support (as opposed to another macOS-based dependency manager), then the `Foundation` dependencies within Alamofire will likely only cause even more headaches. This is because of the how `Foundation` is deployed on Linux (bundled with Swift and not available via SPM) and how it is out of sync with `Foundation` on Apple platforms in terms of both API naming conventions and missing functionality. This makes smaller projects a hassle to port to Linux and maintain that support. I can imagine Alamofire would be a much larger undertaking. Hey @AndrewSB, I took a look at this and realized it just needed one small change to build correctly via SPM. Might be a good idea to add an SPM build job to CI to catch these kind of things in the future (could be a separate PR), but this is looking good! üëç  I'm going to retarget this PR to come off #885.
Hopefully we'll have Alamofire cooperating soon so we can merge this in üëå Try a `swift build` with that commit that I pushed. I think it builds fine now. I'll check it out Woah, that was awesome. Cool, I'll cherry pick two commits onto Moya's `master` and we should be ready to go here  Is this issue still present in the latest release, @aphorisme?
 @AndrewSB, any idea if this is still an issue?
 We haven't heard from other users that this is persisting, going to close for now but we can revisit if it comes up again. 
  Take a look at #627. Does that help? :)

You should be able to use the following:

``` ruby
pod "Moya", :git => "https://github.com/Moya/Moya", :branch => "swift-3.0"
```
 Ah, of course. Sorry!
 Great question @juliengdt. The solution is to specify the branch in your Podfile; if you're writing a library that depends on Moya, I'm afraid the best solution is to document that they will need to do that in their own Podfiles. 

I'm reluctant to tag a release because we're just not ready with Swift 3 support yet, especially around our ReactiveCocoa extensions. Does that answer your question?
 Basically yeah, you're basically telling CocoaPods that you want to override that version of B. It's worked for me in the past, if it's a problem we can always tag maybe like an alpha?
 Should be resolved by our new use of a 8.0.0 beta tag, can you verify? 
 Fab, thanks!
  There's been a lot of activity on master while we've been focused on Swift 3.0. Gotta merge 'em in! After making sure I didn't make any mistakes resolving the merge conflicts. 
 Tests are passing locally from the command line, too: 

<img width="1102" alt="screen shot 2016-09-15 at 9 52 02 pm" src="https://cloud.githubusercontent.com/assets/498212/18573116/a9fa0910-7b8e-11e6-9850-4a21e8244da6.png">

Going to try Carthage while I'm at it. CI is üî¥ because of an issue with Circle, I'm waiting on a response in their community forum.
 ![Giphy](http://media0.giphy.com/media/D0WOL0ogZIoG4/giphy.gif)
 <img width="1006" alt="screen shot 2016-09-15 at 23 12 36" src="https://cloud.githubusercontent.com/assets/49038/18574314/eef6a5a4-7b99-11e6-9961-74c80ab623bb.png">

ran it from scratch on a fresh computer - all üëç üçè 
 When I run on my local machine all tests pass too -- I'm currently trying on travis and tests fail however 
  https://github.com/Moya/Moya/pull/608#issuecomment-247292895
 Thanks for the kind words! I dug around the Alamofire repository and found this discussion which includes rationale for their decision: https://github.com/Alamofire/Alamofire/issues/1367 I personally find this regrettable, but there are comments in that issue of using forks of Alamofire that continue to support iOS 8. If you find one that works, I'd be happy to help you use Moya with them.
  This was causing a compiler error on ReactiveMoya for me. Similar to #629 
 Standby, performing the conversion for all 8 Rx & Reactive targets
 that should have done it üòÑ 
  Thanks a lot for contributing to Moya! I've invited you to join the Moya GitHub organization ‚Äì no pressure to accept! If you'd like more information on what that means, check out our [contributor guidelines](https://github.com/Moya/contributors) and feel free to reach out with any questions.
  Ace, thanks! So after merging, we can release like a 7.0.3 that adds Carthage support for Swift 2.3, correct? 
 Yeah, CI wasn't working for me, either. I didn't update it to use Xcode 8, which is probably why. I'll merge + release.
 Thanks a lot for contributing to Moya! I've invited you to join the Moya GitHub organization ‚Äì no pressure to accept! If you'd like more information on what that means, check out our [contributor guidelines](https://github.com/Moya/contributors) and feel free to reach out with any questions.
 @tpesce Can you check that everything works for you with the 7.0.3 release? 
  :100:
 Thanks a lot for contributing to Moya! I've invited you to join the Moya GitHub organization ‚Äì no pressure to accept! If you'd like more information on what that means, check out our [contributor guidelines](https://github.com/Moya/contributors) and feel free to reach out with any questions.
  I think you are still using Swift 2.2, correct? `7.0.2` is a Swift 2.3 release (in which `URLByAppendingPathComponent` _is_ optional. :)
 Use `7.0.0` on Swift 2.2 instead, upgrading to `7.0.2` once you switch to Swift 2.3 :)
 I think you did a pod update before? I don't think `pod install` automatically downgrades to the specific pod version. You should be able to update to `7.0.0` again now, I think?
 @Denis1992 please use specific Moya version, like:

```
pod 'Moya', '7.0.0'
```
 Fixed now? ^^
 üôå
 You are right @v-ken, it should be fixed now. Thanks for mentioning! üôá 
  Hi everyone :wave:,

Great thanks to all the contributors for this awesome project ‚ù§Ô∏è  !

Just found some typos and fixed it üòâ 

What this pull request does:
- Fixes some typos
  - In [`docs/Examples/CustomPlugin.md`: `dont` ‚Üí `don‚Äòt`](https://github.com/Moya/Moya/pull/633/files#diff-97cf7e1f68627a9088db3cbba8828c10R4)
  - In [`docs/Providers.md`: `activitiy` ‚Üí `activity`](https://github.com/Moya/Moya/pull/633/files#diff-f4a748831e283823bcd510bcae06b299R172)
- Uses American spellings (since most of the spellings in this project are in American style)
  - `behaviour` ‚Üí `behavior`
  - `initialisation` ‚Üí `initialization`
  - `customisation` ‚Üí `customization`
- Removes trailing whitespaces
- Fixes invalid links to other `.md` files
  - In [`docs/Examples/RxSwift.md`: `Providers.md` ‚Üí `../Providers.md`](https://github.com/Moya/Moya/pull/633/files#diff-7811fd9d8877f8a5856897e2ba3271f4R5)
  - In [`docs/Examples/ReactiveCocoa.md`: `Providers.md` ‚Üí `../Providers.md`](https://github.com/Moya/Moya/pull/633/files#diff-cafbaa4f5c12f0b68546c28bb2edf88dR5)

Would love to hear you feedback/suggestions, thanks!
 Good job! üëä
 Looking good!
 Thanks a lot for contributing to Moya! I've invited you to join the Moya GitHub organization ‚Äì no pressure to accept! If you'd like more information on what that means, check out our [contributor guidelines](https://github.com/Moya/contributors) and feel free to reach out with any questions.
  See https://github.com/Moya/Moya/issues/541 for a conversation about how to test, specifically around stubbing. We should document the outcomes of that discussions somewhere in the repo. 
 Specifically [this comment](https://github.com/Moya/Moya/issues/541#issuecomment-232428790) makes for a great start for the documentation.  7.0.1 is the last version that is compatible with Xcode 7 / Swift 2.2. Moya 7.0.2 is compatible with Xcode 8 running Swift 2.3. Swift 3 support is still a work-in-progress: #608.
 Does that answer your question, @rlam3? :)
  We should get the CI to keep track of our Carthage support, I debated putting this in danger but it takes a very long time to run, and when I ran it locally Xcode crashed :-/

![screen shot 2016-09-14 at 6 11 16 pm](https://cloud.githubusercontent.com/assets/49038/18531892/acab1520-7aa6-11e6-824f-0a63b47c55a2.png)
 Maybe it'll be better on CI
 Great idea! 
 Dang, an extra 35m to run on each CI run. Wonder if it's worth adding Jenkins _just_ for doing this instead of putting it on the real CI.

Anyway, we _know_ master is broken, this just validates it. Happy to either rebase with master isn't broken.
 I'm not surprised master isn't working, the 7.0.x stuff branched off from the 7.0.0 tag, and all the Swift 3 stuff is in its own branch, so master has been languishing for a bit. 

We could consider only testing one platform with Carthage, instead of iOS, macOS, watchOS, and tvOS. It might be worth the time tradeoff, not sure. What do you think?
 I'd be OK with just doing iOS, if we can - once some of the other PRs are in, I'll look at the docs to see if I can do that
 Great work! I think keeping Carthage support working is an acceptable tradeoff for a slower CI, thanks Orta.
  Sorry you're running into this error, it's possible I made a mistake when releasing 7.0.2 for Swift 2.3. Could someone from @Moya/contributors who is familiar with Carthage take a look and see if 7.0.2, the latest release, works with Xcode 8/Swift 2.3? 
 Ah, interesting! Would you be able to submit a PR against the release-7.0.1-take-two branch? Don't worry about it, though, I can take a crack tomorrow. 
 Wonderful, thanks! 
  Hey @lixingshi! We are currently working hard on releasing Moya for Swift 3.0 in #608. For now you can use Moya with CocoaPods specifying the branch "swift-3.0", like:

``` ruby
pod "Moya", :git => "https://github.com/Moya/Moya", :branch => "swift-3.0"
```

And switch to Moya 8.0 when the release happens.

Hope it helps! 
 This should work:

``` rb
pod "Moya/RxSwift", :git => "https://github.com/Moya/Moya", :branch => "swift-3.0"
```

Let us know how it goes :+1:
 Is there a problem with `Moya` here, or the `RxSwift` branch? @gordoneliel 
 But does that not work? It should point to the / a Swift 3 branch of Rx of course.
 Any idea @sunshinejr?
 Hmm, what is your Podfile @zhaoyunyi? Can you download our Demo and check if it works for you? Because I've downloaded it, and `RxMoyaProvider` works just fine in the Demo. Another idea could be that you maybe forgot importing `RxSwift` at the top of your file along with `Moya`?
  Hey, `7.0.1` is tagged at the same commit as `7.0.0`, but that's was a conscious decision
Details here: https://github.com/Moya/Moya/pull/594#issuecomment-246513882
 Yup, it was caused by a mistake on my part, working to fix it and release Moya with Swift 2.3 compatibility today. 
 This should be fixed now, could you try updating to Moya 7.0.2 and letting us know if it works? 
 Are you using Cocoapods or Carthage? Is the version number `7.0.2`?
 7.0.2 is what you want for Swift 2.3. Try `pod update Moya`, without specifying a version in your Podfile. That should install the latest version, which is 7.0.2. Maybe try deleting the `Pods` directory, if you can, and re-run `pod install`. 
 @dangthaison91 You need to explicitly specify that you want Moya 7.0.0. You can do this like:

```
pod 'Moya/RxSwift', '7.0.0'
```

(you also don't need both `Moya` and `Moya/RxSwift`, because `Moya/RxSwift` has `Moya` in it)

You can check [here](https://guides.cocoapods.org/using/the-podfile.html#specifying-pod-versions) what `~>` means and more in a Podfile. Hope it helps! 
  Hey all! This is the task from the #608 PR. Here I've updated the syntax of tests and it seems that it is building correctly. üéâ Most important notes:
- ~~Only two tests aren't passing. It has something to do with inflight tracking, I'm no expert in that field so could use some help.~~ **All tests are passing as of now!**
- I've commented out ReactiveCocoa tests for now, because we didn't update the code from the extensions yet. 
- The `parameterEncoding` has changed in Alamofire and it was tricky to test (at least for me). What I ended up with was checking if encoded request using encoding from old and new endpoint is the same. Second idea was to switch on type of the `parameterEncoding` and then used specific type to check, but because I didn't see any Equatable operator for any of the types, it was also tricky to differentiate all the types. The first one seemed more "generic", but if anyone has a better idea, I'm happy to hear it!
  You need to create only one Service that manages all endpoints. To better understand how to use Moya see the documentation at:https://github.com/Moya/Moya/blob/master/docs/Examples/Basic.md

If you have further question write here!
  Hey @hewigovens, this is being worked on in #594 :wink:
  Well done! üëç 
 Thanks a lot for contributing to Moya! I've invited you to join the Moya GitHub organization ‚Äì no pressure to accept! If you'd like more information on what that means, check out our [contributor guidelines](https://github.com/Moya/contributors) and feel free to reach out with any questions.
  Thanks a lot for contributing to Moya! I've invited you to join the Moya GitHub organization ‚Äì no pressure to accept! If you'd like more information on what that means, check out our [contributor guidelines](https://github.com/Moya/contributors) and feel free to reach out with any questions.
  I have removed the API key, just to avoid tempering with it.
Next time, you can just leave your issue open after editing its content / title :)
 Also, I am not sure if this is an error. The response is empty, but maybe this is intended? What is the status code returned for the request?
 What is unclear to you? We'd love to help! Please provide more code like how you make the request and more info about the request(address, header, method and so on). Because we can't make sure the issue is cause by your app-side or server-side. This is another question. I reply it in https://github.com/Moya/Moya/issues/1021.  What exactly is your question?
 Ref #620 
  This PR fixes the progress handlers to use Progress instead of the [now deprecated by Alamofire]-style (Int64,Int64,Int64) variant.
 Thanks! 
  Hey there! I'll do my best to help you distinguish them üòâ

`EndpointClosure` defines how to map `TargetType` to `Endpoint`. `RequestClosure` on the other hand, resolves `Endpoint` into `NSURLRequest` (or `Error` if the request shouldn't be performed). You can use them both on the same provider and  `RequestClosure` follows after `EndpointClosure`.

In the `EndpointClosure` you can customize endpoint's `parameterEncoding`, `headers` or additional `parameters` and more if you want. There you can setup things your API needs in the headers or parameters, that should go globally. You can also stub the `statusCode` so it returns errors instead of 200 for testing purposes.

Then, when you have the `Endpoint` created, there is that `RequestClosure`. You are moments before the request. Here you can change things that you want in `NSURLRequest`, but also you can perform asynchronous token fetch, and if it fails you can stop the request as well (and this is the place for it). 

There is also great documentation about the topic [here](https://github.com/Moya/Moya/blob/master/docs/Endpoints.md). If you find something hard to understand, you are more than welcome to make an issue or pull request if you know how to fix it.

Hope it helps! If you have more questions, let us know! üêº 
 Great answer, @sunshinejr. @rlam3 let us know what else we can clarify, we're always looking for ways to improve our documentation!
 Hi @rlam3, thanks for opening the issue. We actually have some auth-specific documentation [here](https://github.com/Moya/Moya/blob/master/docs/Authentication.md) I wanted to make sure you were aware of; the request closure has been specifically designed with OAuth and other forms of asynchronous authentication in mind. If you have any suggestions on ways to improve our documentation, please send a pull request and we can take it from there. 
 You found the code that does the refreshing, further down that file you'll see the code that calls the fetching code: https://github.com/artsy/eidolon/blob/a7bb061c89cd4bed44d956b1376909ca0e72060b/Kiosk/App/Networking/Networking.swift#L87-L94

Basically, the `XAppTokenRequest` function's Observable always returns a valid token (whether it was a cached valid token, or a newly fetched token). Then we use `flatMap` to turn that Observable into one that represents the _actual_ network call we want to make. Does that make sense? 
 Yup, don't need to worry about synchronizing NSUserDefaults manually, it does it for you. And worst case, it looses the token and just fetches a new one. We clear them out just for consistency's sake. NSUserDefaults is just a convenient place to put them. We inject the token here: https://github.com/artsy/eidolon/blob/a7bb061c89cd4bed44d956b1376909ca0e72060b/Kiosk/App/Networking/Networking.swift#L132
 We don't use a JWT in that app, but the principle is the same. That's where you would add any tokens as HTTP headers, or sign the request using Heimdall or whatever for OAuth. 
 Good question; the response object [contains the URLResponse](https://github.com/Moya/Moya/blob/606fd46080ed3e4eabdfa1d50cdbe6b103466c62/Source/Response.swift#L7) which has the headers you can access. 
 Cool! Sounds like your issue was resolved, so I'm going to close this. Please feel free to re-open if that's not the case, thanks again!
  Thanks a lot for contributing to Moya! I've invited you to join the Moya GitHub organization ‚Äì no pressure to accept! If you'd like more information on what that means, check out our [contributor guidelines](https://github.com/Moya/contributors) and feel free to reach out with any questions.
  Thanks! Good job! 
 Thanks a lot for contributing to Moya! I've invited you to join the Moya GitHub organization ‚Äì no pressure to accept! If you'd like more information on what that means, check out our [contributor guidelines](https://github.com/Moya/contributors) and feel free to reach out with any questions.
  Alamofire updated their podspec to 4.0.0 on master which causes errors if we still reference 4.0.0-beta.2
 Tried it out and it seems fine! Thanks! 
  So due to [Alamofire#1455](https://github.com/Alamofire/Alamofire/pull/1455) change, we have to update our progress blocks as well. For now I've just updated the new Alamofire's Progress API to our existing Progress API. If we should update to two blocks instead of one (`downloadProgress`, `uploadProgress`) is eligible for discussion. 

More info #608.

Cheers! üêº 
 this looks great!
 Oh no - alamofire deprecated the Int64 variants for the progress handlers
 sounds like this is definitely a major version bump then üëç 
 I'm working on a PR for this right now. 
 even though 7.0.0 was released recently - does it make sense to move to 8.0.0 as @orta suggests?
 I too think that makes the most sense, yeah.
 I'm testing #618 #613 #608 on my own fork and everything seems to be working smoothly üëç 
 Okay, I think that it can be merged to the main Swift-3.0 repo, and make sure that Moya builds, and if there are any issues about this PR we can make a new one with fixes.
  Two downsides to the approach I went with:
1. Its a breaking change, but that's understandable, given this is a source change
2. In the print output, the items may be printed as an array, instead of a variadic list. Not sure how to get around that, I looked at function currying and partially applying the print function, but it didn't lead anywhere
 Wow, fast! Thanks! Looks fine to me! About that problem with printing array, would it work that instead of using array, make the items parameter the last one in tuple, so it can accept variadic parameter?
 Oh that might! Let me try it
 Yeah, that worked @sunshinejr. Awesome insight!
If this looks good to you, then I think it's ready to merge üòÑ 
 üíØ
  carrying out #609 for the xcodeproj
 Ace.
  since alamofire 4 requires ios 9++ I believe we need to increase the deployment target of Moya to 9.0 as well 
 Makes sense! 
 Thanks a lot for contributing to Moya! I've invited you to join the Moya GitHub organization ‚Äì no pressure to accept! If you'd like more information on what that means, check out our [contributor guidelines](https://github.com/Moya/contributors) and feel free to reach out with any questions.
  Hey guys! üéâ  I tried to update Moya to the latest Swift 3.0 shipped with Xcode GM Seed. As there is work that still needs to be done, I would use some help with:
- [x] `sendAlamofireRequest` method in [Moya+Internal](https://github.com/Moya/Moya/blob/swift-3.0/Source/Moya%2BInternal.swift#L187-L221). (@sunshinejr, PR: #613)
- [x] [NetworkLoggerPlugin](https://github.com/Moya/Moya/blob/swift-3.0/Source/Plugins/NetworkLoggerPlugin.swift). (@AndrewSB, PR: https://github.com/Moya/Moya/pull/612)
- [x] [ReactiveCocoa extensions with Tests](https://github.com/Moya/Moya/tree/swift-3.0/Source/ReactiveCocoa). (@ashfurrow, PR: #647)
- [x] [Tests](https://github.com/Moya/Moya/tree/swift-3.0/Demo/Tests). (@sunshinejr, PR: #625)
- [x] Continuous Integration.
- [x] Any other things you may find.

I think together we can make it better üëäCheers! 
 Will take a look soon!
 Not really sure how to proceed - the build (Demo) fails because of Alamofire, Rx, Nimble, Quick, and does not give me any type information (with alt+click). Am I missing something @sunshinejr?
 Did a little - but couldn't really test. :/
 Looks good! Want to add a changelog entry?
 Done!
 Thanks @sunshinejr @BasThomas, I'm testing pulling this in through Carthage right now üòÑ 
 Hmmm. I got a failure on building `RxMoya iOS`, based off some shell task exiting with error code 65?

<img width="1277" alt="screen shot 2016-09-08 at 12 26 15 pm" src="https://cloud.githubusercontent.com/assets/3814772/18363573/869375e4-75bf-11e6-89af-8b30745e334d.png">

I'm going to try nuking my derived data and trying again
 Ahh, the problem is that the `Cartfile` hasn't been updated to point to swift 3 versions, just the Podfile. I'll make a commit that brings the Cartfile upto speed
 Fantastic work here, everyone! This kind of collaboration is what makes me proud to be a member of this open source community.
 @ashfurrow üòÑ 

Testing this again with the new cartfile
 Created #610, can someone sanity check the PR if it makes sense merge it in?
 Hey again guys! Thanks for helping out so quickly! üéâ  I've added fix to `Podfile` that should fix most of the problems with building. Let's now agree that every new changes to this PR should go in another PR, just to not make any more chaos than needed and not duplicate the code in advance. Thanks again! üôá 
 it seems like there are still a couple of build errors in Moya+Internal and NetworkLoggerPlugin
 @sunshinejr looks great!

Here's what I've uncovered with with `output` in the `NetworkLoggerPlugin`.
Swift 3 removed parameter labels for tuples, making it impossible to create a tuple with a variadic parameter

I think we're going to have to make a breaking change with the `NetworkLoggerPlugin`, and switch from `output: (_ items: Any..., _ separator: String, _ terminator: String) -> Void` to something else. I see two possibilities:
1. remove the variadic parameter of `_ items: Any...`, into`_ items: [Any]`, or `_ items: Any`
2. switch from this tuple to some sort of delegate

I think it makes sense to do the first, I'm going to get started with it in a PR. Open to any other suggestions though! 
 @edwardvalentini yeah, these are the tasks I've listed as a TODO ones in the first post, I've just removed the errors with building Frameworks, which didn't have Swift 3.0 set in settings. 

@AndrewSB yeah, one of the reasons I'd rather see this change in `NetworkLoggerPlugin` in a PR, to agree on the solution.

Also, I'm gonna take a stab at new progress APIs for Alamofire.
 üôå 
no experience with alamofire,  so I'm happy you offered üòÖ

Just submitted https://github.com/Moya/Moya/pull/612
 @charlag Yeah, we need to also update README, docs, examples, prepare for next major release and I thought that it would be good to have migration guide of some sort. I'm not sure if everything should be in this PR tho. Thoughts? 
 I think a separate PR for docs and README is a great idea.
 As of now, Moya core, Moya/RxSwift and Demo should build correctly üéâ
 Awesome! I think the last thing we need to do before releasing Moya 8, with support for Swift 3, is to get CI working. Does that sound right? 

Thanks again for all the work everyone!
 Yeah, I'm working on the tests right now, we also need help with ReactiveCocoa if possible, and we have to wait for Circle CI because as of right now they don't support Xcode 8 GM Seed (more info [here](https://discuss.circleci.com/t/what-is-timeline-for-xcode-8-gm-support/6153/2)). But we are really close :)
 Travis supports Xcode 8.  I've been using it on another project.   We can switch to Travis, maybe ?
 Aye, we've bounced back and forth between Travis and Circle. I can't remember what made us leave Travis last time, but it's definitely a possibility worth revisiting. 
 @charlag Thanks! Because both [Alamofire](https://github.com/Alamofire/Alamofire) and [RxSwift](https://github.com/ReactiveX/RxSwift) have iOS 9.0 as a minimum deployment target.
 Circle now supports Xcode 8 GM: https://discuss.circleci.com/t/what-is-timeline-for-xcode-8-gm-support/6153/5 I'm taking a look at things now, the last failure was due to an old cached version of Alamofire, which exhibited this bug: https://github.com/Alamofire/Alamofire/issues/1507 So it might be as easy as rebuilding without the cache. 
 Still being the beta 6 Xcode build number on Circle: 8S201h could be a slow rollout of the Xcode GM build.
 @Moya/contributors is there a way to use current master branch of [ReactiveCocoa](https://github.com/ReactiveCocoa/ReactiveCocoa) via CocoaPods? It seems like they have their Podspec [here](https://github.com/mhuusko5/Podspecs.git), instead of the main repo.
 @sunshinejr That's not possible, unfortunately. The workaround is to define the ReactiveCocoa branch in your Podfile. Documenting this requirement in the readme should be sufficient, I'll try to work on getting those ReactiveCocoa tests to pass.
 Okay, I dug into this. It is possible to get ReactiveCocoa downloading with CocoaPods, but it's a bit roundabout since they [don't yet have a podspec](https://github.com/ReactiveCocoa/ReactiveCocoa/issues/3000) in their repo. I've modified a community-supported podspec to point to their `master` branch, which has Swift 3 support.

``` swift
pod 'ReactiveCocoa', :podspec => 'https://raw.githubusercontent.com/ashfurrow/Podspecs/852d47f4d1ff836402fa2903c544a09ec665a72b/ReactiveCocoa.podspec'
```

However, ReactiveCocoa depends on a new library called ReactiveSwift, which does not have a podspec yet. I've [opened an issue](https://github.com/ReactiveCocoa/ReactiveSwift/issues/13) seeking advice. The team seems amenable to it, so the next steps for me are to:
1. Create a podspec for ReactiveSwift, send a PR to their repo.
2. Uncomment the tests, modify them as required.
3. Add instructions to the readme to specify both the ReactiveCocoa and ReactiveSwift pods manually in one's Podfile.
 @ashfurrow great! Can't wait for this piece to be done as well üéâ
 I've submitted a PR to ReactiveSwift: https://github.com/ReactiveCocoa/ReactiveSwift/pull/14 Once it's merged + pushed to CocoaPods trunk, we'll need to submit a PR to ReactiveCocoa to add a podspec there, too (updated to depend on ReactiveSwift). 
 BTW, CI is working with the Xcode 8 GM now. I'm building to see if it works, but macOS tests were failing on Circle earlier. 
 Same exact issue i had with travis CI last night when I tested Moya there ‚Ä¶  iOS tests passed but macOS tests were failing‚Ä¶ locally it was all working though
 Very strange! Still, we're one step closer. Is anyone else able to take a look at the failing macOS builds? I've got my hands full with the ReactiveCocoa stuff already. 
 @hiteshsondhi88 Agreed, do you have time to submit a pull request with those changes? 
 Okay, so we just need to update the Readme/Podfile to the new tagged versions of RxSwift and Alamofire. I'm thinking at that point, we consider releasing a beta? Or should we just release?
 @ashfurrow Hmm, how about staying in beta as long as our dependencies are? 
 Homebrew broke overnight, see https://github.com/Homebrew/brew/issues/991 . Going to fix in a PR. 
 Okay, once #657 is üçè and merged, I think it's a good idea to release `8.0.0-beta.1`. Let me know if there's anything else holding this back :+1:
 Okay, it's all green. Merging!
 Released as 8.0.0-beta.1, see the Readme for installation instructions. It's a bit touchy since ReactiveSwift isn't yet on CocoaPods trunk, open an issue if you run into trouble. 
  This is great, thanks!
 Thanks a lot for contributing to Moya! I've invited you to join the Moya GitHub organization ‚Äì no pressure to accept! If you'd like more information on what that means, check out our [contributor guidelines](https://github.com/Moya/contributors) and feel free to reach out with any questions.
  Moya relies on Alamofire to do its parameter encoding, I'm a bit surprised that it behaves this way. There is a workaround though.

Sounds like you might need to use a custom parameter encoding, similar to [what's described here](https://github.com/Moya/Moya/blob/master/docs/Examples/ArrayAsRootContainer.md). You can do this on a per-target basis, so just `SearchUPC` if that makes sense for your code.
 Care to share how you solved it? :)
  You can use the [built-in network logging plugin](https://github.com/Moya/Moya/blob/master/docs/Plugins.md) which can be used to log all requests. 
  Thanks a lot for contributing to Moya! I've invited you to join the Moya GitHub organization ‚Äì no pressure to accept! If you'd like more information on what that means, check out our [contributor guidelines](https://github.com/Moya/contributors) and feel free to reach out with any questions.
  @tomj How do you think we could improve our documentation around this? Any suggestions? 
 Looks great!
  I have added a snippet of code to clarify the use of a Plugin and done some textual modification to better understand what a plugin is.
 Woo, nice!
  Maybe @leoneparise can help with this. And the Multipart still has to be documented (see #586)
 I'm documenting this feature but for next version (8.0), which changed a lot from version 7.0. You can use my comment on this issue https://github.com/Moya/Moya/issues/572 to guide you implementation. 
 `.File` can be used only with `NSURL` and `.Data` with `NSData`. You need to convert your `UIImage` to `NSData` to build the Multipart.

Try this:

``` swift
var multipartBody: [MultipartFormData]? {
        switch self {
        case .ChangeProfileImage(_, let profileImage, _):
            guard let data = UIImageJPEGRepresentation(profileImage, 1.0) else { return nil }
            return [MultipartFormData(provider: .Data(data), name: "files", mimeType:"image/jpeg", fileName: "photo.jpg")] 
        default:
            return nil
        }
    }
}
```
 What version of Moya are you using?
 Yeah, that installs the latest version.
 Yeah, the syntax for that is the following:

``` ruby
pod 'Moya', '~> 7.0.0'
```
 `multipartBody` param is an array of `NSData`. You can return the array pointing to the same `name` form parameter. That will be parsed by the server as an image array.
 @riksof-zzlalani Hey there! What your code is lacking is subscription. This is not _really_ a Moya problem, but problem with Reactive Extensions. So, a quick fix would be a following:

``` swift
return testApiProvider
    .request(.PostTest(obj: _file))
    .debug()
    .mapJSON()
    .map({ JSON -> EKResponse? in
        return Mapper<EKResponse>().map(JSON)
    })
    .subscribeNext { _ in }
```

I hope it helps! Please next time use another issue for questions if they are touching quite different topic, so others can easily search for it üêº
 @riksof-zzlalani no problem! I think that the original problem @swabzz had should be resolved as of now, so I'm gonna close for now.
  Great question ‚Äì we actually had developers with a similar problem a while ago, check out their issue: https://github.com/Moya/Moya/issues/431 I think you'll find the solution here. Let us know how it goes. 
 I think I may have misunderstood your initial question, but I think you should be able to use the default `.URL` parameter encoding.

When returning `parameters` from the target, does the following work?

``` swift
return ["param1": "[\"15\", \"19\"]"]
```

Normally when URL-encoding an array, the format is something like `parameter[]=15&parameter[]=19`, I think. If that's not what you want, then you'll need to create the final string you're looking for manually, which is a bit messy I admit. Just using the `parameters` property of `Target` should be enough.
  I think you can omit the `?` when casting (so, `as` instead of `as?`).
 I have been taking a look, and it seems the `error` is not an optional. The unwrapping therefore makes no sense. Also, I found converting the `error` from `Error` to `Moya.Error` has no effect either, so that can be committed as well. That means you can the following in your closure:

``` swift
let provider = MoyaProvider<MyService>()
provider.request(.CreateUser(firstName: "James", lastName: "Potter")) { result in
  switch result {
  case let .Success(response):
    ()
  case let .Failure(error):
    switch error {
    case .Data(let response):
      print(response)
    case .ImageMapping(let response):
      print(response)
    case .JSONMapping(let response):
      print(response)
    case .StatusCode(let response):
      print(response)
    case .StringMapping(let response):
      print(response)
    case .Underlying(let nsError):
      // now can access NSError error.code or whatever
      // e.g. NSURLErrorTimedOut or NSURLErrorNotConnectedToInternet
      print(nsError.code)
      print(nsError.domain)
    }
  }
}
```

which will 'just work'.
  Great question! I wouldn't mind implementing something for our existing Swift 2.x code, but moving to `ErrorType` on `UnderlyingErrorType` and `RequestResultClosure` removes the ability for developers to switch to a specific `Moya.Error`. 

I'm not sure of the best approach here. @Moya/contributors any ideas? 
 Thanks for the follow up!
 Since there hasn't been any activity on this thread for some time, I am going to go ahead and close it. Please re-open or create a new issue if you would like to discuss further. Thanks.  @charlag because this is a PR to add support for Swift 2.3. We are currently using Swift 2.2, which also means using Xcode 7.3.1. We may need to change the CircleCI file though? (cc @ashfurrow @gustavogervasio)
 Xcode 8 supports both Swift 2.3 and Swift 3.0, right? May we do need Xcode 8 then? 
 Sorry if I wasn't clear - that's what I was trying to say. 

Swift 2.2 == Xcode 7
Swift 2.3 == Xcode 8
Swift 3.0 == Xcode 8
 @charlag I've opened PR #608 with help wanted on the Swift 3.0 migration for Xcode GM Seed, if you want to help üòâ 
 I can merge+release this for Swift 2.3 before releasing a separate version for 3.0, _or_ we can just do it for 3.0. What does everyone think? 
 Okay, will reply from @gustavogervasio's branch and push a tag. Wish me luck!
 Rather after #621, I think master is updated for 2.3. 
 I've cherry-picked the commits from #621 into the 7.0.1 tag and everything looks good. This means we can release _just_ Swift 2.3 support and not also the breaking changes currently on master. I'm downloading the Xcode 8 GM to test locally before releasing. Thanks everyone!
 Cool, will do :+1: What's the trick to get Xcode 8 to use Swift 2.3?
 Wow, that was a lot of work. I've got 7.0.1 released on Carthage and CocoaPods, would someone be able to verify it's working for them as expected?

I'm going to close this PR.
 üò¢ @marcelofabri can you check for other breaking changes? If that's the only one, we can replace the `7.0.1` tag and hopefully no one will be the wiser. 
 I've pushed the release up to a `release-7.0.1` branch. 
 Okay, well let's stop the bleeding. Hold on.
 I've pushed a 7.0.1 tag with an identical commit to 7.0.0 so no one's projects will break. I'll take another look tomorrow, thanks for pointing out the issue!
 Cherry-picking commits turned out to be too complicated, so instead I branched off of the 7.0.0 tag and redid the changes for Swift 2.3: https://github.com/Moya/Moya/compare/7.0.1...release-7.0.1-take-two . I'm going to lint the podspec locally before releasing, I'll let you know. 
 7.0.2 has been released, could someone take a look and verify it's all good? 
 Great, thanks!
  Makes sense to me! Good to merge when üçè
  @rlam3 I think that the discussion for difference between `endpointClosure` and `requestClosure` is moved to #617 so I will take on the next questions:
1. `YourAPI` is in this example is the `Target` you use for requests. Let's say you have one `Target` in your app and let's call it `TwitterAPI` here instead of `YourAPI`.
2. The `YourAwesomeOauthProvider` is just an example. Here you can use third party library to get your token, or you can just use Moya to get it - your choice. There are times you are working with existing SDK's for fetching tokens, but also there might be time that you will need to handle it yourself and Moya can be a perfect fit for it as well. You can even have it in the one `TwitterAPI` if you want.
3. Yes, now every time you use your `provider`, it will first use the `requestClosure` to map `Endpoint` to `NSURLRequest`.
 Closing this for now. @rlam3, please reopen if you have any additional questions related to this.  I'm not sure what the plans on this are, but a PR to update the branch would be great!
 Also, there seems to be an [issue](https://github.com/Moya/Moya/issues/513) that's tracking the progres. I am not sure how up-to-date it is, though. But it might be helpful.
 The Podfile currently uses [10.9 as a target](https://github.com/Moya/Moya/blob/fd2cb69a3e9a6c5e4c978c38563c90941ecbccc5/Demo/Podfile#L37) but [RxSwift requires 10.10](https://github.com/ReactiveX/RxSwift/blob/3.0.0.alpha.1/RxSwift.podspec). Maybe upping that would work?
 @DenisLaboureyras is this issue still causing trouble? 
  A PR to update that would be great!
  Sure!  If you want.  We've started using it with FutureKit, and it works great.

Should Moya _require_ or _depend on_ one of these microframeworks?  Could, but I would not like that decision made for me.  So I hope we don't go in that direction.
 https://github.com/ello/ello-ios/blob/cg/add/hire-me-button/Sources/Networking/HireService.swift
 Nope, I didn't even look at PromiseKit at the time. Pick whichever seems right for you. 

> On Aug 25, 2016, at 9:44 PM, rlam3 notifications@github.com wrote:
> 
> @colinta Is there a reason for you guys to choose FutureKit over PromiseKit?
> 
> ‚Äï
> You are receiving this because you were mentioned.
> Reply to this email directly, view it on GitHub, or mute the thread.
 @rlam3 has this question been solved to your satisfaction? Happy to provide further clarification. 
  A lot was done to multipart upload last month. Now I see that this was a requested feature by a lot of users. I'm opening this issue to document our current implementation and provide some guidelines of how it works and how can be used. I think next version should be released with this new doc.

The documentation must include:
- [x] How to configure the Target for multipart
- [ ] How to use with Rx extensions
- [ ] Update the main page to tell all users that Moya supports upload

What do you think @colinta @ashfurrow?
 Makes sense. One note: we don't use the GitHub wiki, but rather the `/docs` folder. Sounds awesome, thanks for opening the issue :+1:
  Awesome, glad you got it figured out! Thanks a lot for posting your solution, I'm sure it'll be of help to others. Going to close the issue, feel free to open another if anything else comes up!
  - Fixed some typos
- Fixed a duplicated header doc
- Added `backticks` to more clearly show types 
 I guess that's not actually needed? Or should I add a `improved header documentation` in the Changelog?
 This is great, thanks for the PR! Yeah, a changelog entry like the one you suggested would've been great, don't worry about it. 
  Fantastic, looks great to me!
 Thanks a lot for contributing to Moya! I've invited you to join the Moya GitHub organization ‚Äì no pressure to accept! If you'd like more information on what that means, check out our [contributor guidelines](https://github.com/Moya/contributors) and feel free to reach out with any questions.
  a PR would be awesome @mattfxyz :) 
 @mattfxyz Is it fixed? I saw that PR #581 was merged.
 I have a fix in my fork. Can we create a new release branch?  Should be possible, can you create a PR? What branch? Should I just make a new 2.3 one on Moya/Moya?  I suppose so, and then release a `7.something` release for CP / Carthage. @ashfurrow, is this possible? Makes sense to me. You should be able to branch off from the tags of our releases.  I created a release-7.0.4 branch and opened a PR to merge the changes into it.   Thanks for the PR! I like it, not too sure about _recommending_ using a force cast, even though I just looked and it's exactly what my code does too üôà What do you think about a 

``` swift
guard let request = endpoint.urlRequest.mutableCopy() as? NSMutableURLRequest else { return }
```

Or something similar? I think if we keep the force cast, we should add a short comment explaining it will always succeed. Thoughts? 
 I prefer a `guard`. It wouldn't be optional if it could never fail.
 But a `guard` does not do any harm in that case, either.
 I have the same feeling as @vzsg on this: using `guard` implies that we don't know what's going on, and so we're protecting ourselves from something; i.e. `request.mutableCopy()` _might_ return _another type_ of object.

But that's not how that method works ‚Äì we all know that it is a reasonable guarantee that we will get back an `NSMutableURLRequest`.

OTOH if this code was written with `guard` I would probably say nothing; it doesn't _hurt_ to have a guard there.  But there _is_ benefit to showing intention with force-unwrapping.  It says "we know what we're going to get, we trust the system".  I'm OK with that. `</twocents>`
 Anecdotal support of this argument: Alamofire uses a force-unwrap to convert `NSURLRequest` to `NSMutableURLRequest` https://github.com/Alamofire/Alamofire/blob/master/Source/Alamofire.swift#L72
 Adding a comment sounds like the best approach, thanks for all the discussion everyone! 
 Thanks a lot for contributing to Moya! I've invited you to join the Moya GitHub organization ‚Äì no pressure to accept! If you'd like more information on what that means, check out our [contributor guidelines](https://github.com/Moya/contributors) and feel free to reach out with any questions.
  This PR mainly fixes indentation errors for the code blocks in the documentation.
I have also added the Swift syntax to a code block where it was missing, as well as removed some unnecessary `break`s in a `switch` statement.
 This is wonderful, thanks! We've needed some tidying up for a while, thanks for taking the initiative. 
 Thanks a lot for contributing to Moya! I've invited you to join the Moya GitHub organization ‚Äì no pressure to accept! If you'd like more information on what that means, check out our [contributor guidelines](https://github.com/Moya/contributors) and feel free to reach out with any questions.
  Looks like this ran through Danger fine üëç 
 Thanks a lot for contributing to Moya! I've invited you to join the Moya GitHub organization ‚Äì no pressure to accept! If you'd like more information on what that means, check out our [contributor guidelines](https://github.com/Moya/contributors) and feel free to reach out with any questions.
  Makes sense, thanks!
 Thanks a lot for contributing to Moya! I've invited you to join the Moya GitHub organization ‚Äì no pressure to accept! If you'd like more information on what that means, check out our [contributor guidelines](https://github.com/Moya/contributors) and feel free to reach out with any questions.
  ``` swift
let endpointClosure = { (target: MyTarget) -> Endpoint in
  let url = target.baseURL.URLByAppendingPathComponent(target.path).absoluteString
  let endpoint: Endpoint = Endpoint(URL: url, sampleResponseClosure: {.NetworkResponse(200, target.sampleData)}, method: target.method, parameters: target.parameters)
  return endpoint.endpointByAddingHTTPHeaderFields(["APP_NAME": "MY_AWESOME_APP"])
}

let provider = MoyaProvider(endpointClosure: endpointClosure)
```

then i got this error

``` swift
"errors" : [
"Unable to find endpoint"
]
```

my usage is not correct or something, i read the documents....,thank you
 Interesting! "Unable to find endpoint" suggests that the request is failing on the server side of things, like maybe the URL you're trying to hit isn't correct? Can you try using the [network activity plugin](https://github.com/Moya/Moya/blob/master/docs/Plugins.md#network-activity-indicator) to print out what exact URLs Moya is using, and then double-check that they're correct? 
  `"name": "images"` caught my eye, I expected that to have an extension, e.g. `"name": "image.jpg"`.  Also, you are returning the `dictObj` (aka `objDict` - you might want to check your naming on that one) from `var parameters: [:]?`, and so the `imagesDataArr` is going to be included there (maybe base64 encoded - I have no idea what Alamofire does with `NSData` in that case).
 Oh shoot, you're totally right on the `"name"` thing!  My mistake.
 Can you provide a sample using `Alamofire` and `Moya` so we can know what's happening?

I saw that you return the same `[NSData]` array on `parameters` and you shouldn't do that. Here is an example of how to make a form with multipart-data:

``` swift
enum SomeAPI {
  case CreatePost(message:String, coordinate:CLLocationCoordinate2D,
        contentType:Post.ContentType, contentFile:NSURL)
}
```

``` swift
extension SomeAPI: TargetType {

  var path:String {
    switch self {
    case .CreatePost: return "/posts"
    }
  }

  var method: Moya.Method {
    switch self {
    case .CreatePost: return .POST
    }
  }

  var parameters: [String: AnyObject]? {
    switch self {
    case .CreatePost(let message, let coordinate, let contentType, _):
      return [
        "message": message,
        "lat": coodrintate.latitude,
        "lon": coodrintate.longitude,
        "type": contentType.rawValue       
      ]
    }
  }

  var multipartBody: [MultipartFormData]? {
    switch self {
    case .CreatePost(_, _, let contentType, let contentFile):
      switch contentType {
      case .Image:
          return [MultipartFormData(provider: .File(contentFile), name: "files", mimeType:"image/jpeg", fileName: "photo.jpg")]
      case .Video:
          return [MultipartFormData(provider: .File(contentFile), name: "files", mimeType:"video/mp4", fileName: "video.mp4")]
      }
    }
  }
}
```

This sample will post a form with `lat`, `lon`, `message`, `type` and `files` properties. I'm using a `File` multipart but you can use `NSData` directly. 

All your text inputs should be on `parameters` property as string and data on `multipartBody` (Moya will take care of the rest).

BTW, I started the multipart upload implementation inside Moya. Today the code is much better than the first version, thanks to our great community :)

The lack of documentation is my fault too, I didn't have time to document this new feature and now I'm waiting for version 8.0 to document it properly (because it breaks our current API). For now, use this example to make your implementation and post here any question.
 @rcholic Yes! only `NSData` should be on `multipartBody` everything else should be on `parameters`.
 @rcholic Tell me if it's working now so I can close the Issue. :)
  You forgot to implement this protocol required property:

``` swift
var multipartBody: [MultipartFormData]? {
        return nil
}
```

I also encountered the documentation wasn't up to date for this. Changed that now: 
https://github.com/Moya/Moya/blob/master/docs/Examples/Basic.md
 Have you been able to solve this issue, @kanishkatn?
  So, do you want to catch and ignore the error?
 Tricky problem! It might be possible for us to handle this, but it would be a departure from `URLSessionTask`'s behaviour. I'm not sure if Moya should be circumventing the behaviour of CocoaTouch libraries. 

A workaround could be to (manually?) dispose of the `Observable` before cancelling, which should prevent errors from being sent on the observable. Let us know how it's going :+1:  
 Hey @mingyeow, did you find a way to make it work as you wanted? Since there hasn't been any activity on this thread for some time, I am going to go ahead and close it. Please re-open or create a new issue if you would like to discuss further. Thanks.  üíØ
  @spxrogers This is great, thanks! Can you add a note to the changelog about the new parameter? 
 @orta there was a Danger failure [on the build](https://circleci.com/gh/Moya/Moya/358) that looked like:

```
$ bundle exec danger
sh: -c: line 0: unexpected EOF while looking for matching `"'
sh: -c: line 1: syntax error: unexpected end of file

Danger has failed this build. 
Found 1 error.

bundle exec danger returned exit code 1
```

I've not seen that before, anything I can do to troubleshoot/reproduce? 
 Thanks a lot! No pressure to rush! 
 Cool, looks good to merge! @spxrogers I think you'll need to merge from master first, feel free to merge after that üëç 
  That is a üíØ idea. 
  Cool! This is for Carthage support? Could you summarize the changes+motivation behind them in the PR? (For those of us not in the Carthage know-how.)
 omg you're my hero. this has been on my docket for too long. Excited to check this out when you're done @AndrewSB!
 Awesome! Sounds exciting, and like it's an involved process. Definitely worth a blog post, I'm sure we're not the only library to have this problem. 
 Just got around to finish implementing this, what I've done is importing the `Moya` framework into each of the Reactive & Rx source files, and remove all Moya source files from the Reactive and Rx targets.

Currently I'm importing Moya into the Reactive & Rx files like so:

```
#if !COCOAPOD
import Moya
#endif
```

where I'm expecting Cocoapods to define a debug flag named `COCOAPOD`, kind of like how it's explained in [this SO post](http://stackoverflow.com/questions/24111854/in-absence-of-preprocessor-macros-is-there-a-way-to-define-practical-scheme-spe/24112024#24112024).

I'm relatively sure Cocoapods doesn't define that flag, so some other workaround must be found. I've just created https://github.com/CocoaPods/CocoaPods/issues/5889 asking if there's anything I can do.

Also currently testing this to make sure it works through a carthage install
 Ok, I think this is now at a point where it's usable through Carthage, testing currently.
 This works for me through Carthage!

Heres an excerpt from the diff upgrading to this branch in my app üéâ

``` diff
diff --git a/Proxy/Internal/Network/Networking.swift b/Proxy/Internal/Network/Networking.swift
index d9bcd86..bafb067 100644
--- a/Proxy/Internal/Network/Networking.swift
+++ b/Proxy/Internal/Network/Networking.swift
@@ -9,7 +9,7 @@ import RxMoya

 private let reachabilityManager = ReachabilityManager()

-class OnlineProvider<Target>: RxMoyaProvider<Target> where Target: RxMoya.TargetType {
+class OnlineProvider<Target>: RxMoyaProvider<Target> where Target: TargetType {

     fileprivate let online: Observable<Bool>

@@ -17,7 +17,7 @@ class OnlineProvider<Target>: RxMoyaProvider<Target> where Target: RxMoya.Target
          requestClosure: @escaping RxMoyaProvider<Target>.RequestClosure = RxMoyaProvider.DefaultRequestMapping,
          stubClosure: @escaping RxMoyaProvider<Target>.StubClosure = RxMoyaProvider.NeverStub,
          manager: Manager = RxMoyaProvider<Target>.DefaultAlamofireManager(),
-         plugins: [RxMoya.PluginType] = [NetworkLoggerPlugin(verbose: true)],
+         plugins: [PluginType] = [NetworkLoggerPlugin(verbose: true)],
          online: Observable<Bool> = reachabilityManager.reach) {

         self.online = online
@@ -28,7 +28,7 @@ class OnlineProvider<Target>: RxMoyaProvider<Target> where Target: RxMoya.Target
                    plugins: plugins)
     }

-    override func request(_ token: Target) -> Observable<RxMoya.Response> {
+    override func request(_ token: Target) -> Observable<Response> {
         let actualRequest = super.request(token)

         return online
@@ -43,7 +43,7 @@ class OnlineProvider<Target>: RxMoyaProvider<Target> where Target: RxMoya.Target
 }

 protocol NetworkingType {
-    associatedtype T: RxMoya.TargetType, ProxyAPIType
+    associatedtype T: TargetType, ProxyAPIType
     var provider: OnlineProvider<T> { get }
 }

@@ -55,7 +55,7 @@ struct Networking: NetworkingType {
 extension Networking {

     // public interface
-    func request(_ token: ProxyAPI) -> Observable<RxMoya.Response> {
+    func request(_ token: ProxyAPI) -> Observable<Response> {
         let actualRequest = self.provider
             .request(token)
             .filterSuccessfulStatusCodes()
@@ -99,15 +99,15 @@ extension Networking {

 private extension Networking {

-    static func endpointsClosure<T>(_ target: T) -> RxMoya.Endpoint<ProxyAPI> where T: RxMoya.TargetType, T: ProxyAPIType {
+    static func endpointsClosure<T>(_ target: T) -> Endpoint<ProxyAPI> where T: TargetType, T: ProxyAPIType {
         let url = "\(target.baseURL.absoluteString)\(target.path)"
-        let sampleResponse: RxMoya.Endpoint.SampleResponseClosure = { .networkResponse(200, target.sampleData) }
+        let sampleResponse: Endpoint.SampleResponseClosure = { .networkResponse(200, target.sampleData) }

-        let endpoint = RxMoya.Endpoint<ProxyAPI>(URL: url,
-                                                 sampleResponseClosure: sampleResponse,
-                                                 method: target.method,
-                                                 parameters: target.parameters,
-                                                 parameterEncoding: target.parameterEncoding)
+        let endpoint = Endpoint<ProxyAPI>(URL: url,
+                                          sampleResponseClosure: sampleResponse,
+                                          method: target.method,
+                                          parameters: target.parameters,
+                                          parameterEncoding: target.parameterEncoding)

         let baseHeaderFields = [
             "Accept-Version": "2016-07-05",
@@ -120,7 +120,7 @@ private extension Networking {
         // networking is the epitome of side effects + shared global state üò∞
         let authenticationHeaderFields: [String: String]? = target.requiresAuth ? ["Authorization": "Bearer \(AuthToken.local()!.accessToken)"] : nil // swiftlint:disable:this line_length

-        return endpoint.endpointByAddingHTTPHeaderFields(baseHeaderFields + authenticationHeaderFields)
+        return endpoint.adding(newParameters: baseHeaderFields + authenticationHeaderFields)
     }

 }
```
 @petester42 @ashfurrow @justinmakaila: I'm sorry this took so long, but I think it's finally done!

Things left before this is ready to merge:
- [ ] check to make sure cocoapods install works
- [ ] fix danger on tests? currently `bundle exec danger` is crashing on CI
- [x] code review from you guys üòÑ, and a vote of confidence that this change is still a good idea to anyone but me üòã

Really excited to have this working now!
 Awesome! Thanks for the review @petester42 üëç I'm using this branch in prod with one of my apps, so I feel pretty comfortable with it too.

I do want to make sure that this doesn't break the cocoapods install though. Can any @Moya/contributors who use Moya through Cocoapods try pointing their install to this branch to confirm that everything still works?
 @AndrewSB I use Carthage as my dependency manager, and I believe @orta and @ashfurrow are the resident CocoaPods experts
 @justinmakaila alright, I'll wait for someone familiar with cocoapods to test it, I don't want to merge this into master and have it break for everyone depending on this library through Cocoapods üò¨
 I don't see any CocoaPods breaking changes, I think we're good to merge. 
 awesome, I'll merge üòÑ
 oh, @ashfurrow: you mentioned that it would be cool to write a blog post about this change. If you think it still merits one, I'd love to write/help write it. You can email me (asbreckenridge@me.com) to talk about it üëç 
 Circle is complaining, is this a problem? @AndrewSB 
 Nah, CI fails like that intermittently. Can you trigger a rebuild on master? 
 Rebuilding from their web interface immediately fails the build again, it seems. üòï 
  I noticed this when our CI tries to upload unit test code coverage reports:

```
error: Failed to load coverage
```

([Example build](https://circleci.com/gh/Moya/Moya/343).)

It happens for quite a few files, which may explain why as of a few weeks ago, our coverage dropped for %90 to %60. 

I have no experience with the tool, this might be an easy fix. If anyone nom @Moya/contributors who has experience could take a look, I would be very grateful :bow: 
 @swizzlr Do you still use CodeCov? Is this anything you've seen before? 
  Maybe we should remove it from continuous integration until it's working again? 
 Huh! When I get a chance, I'll take a look at Xcode's code coverage and see what it thinks. We might need to close this and open an "increase code coverage" issue üòâ 
 Have you been able to have a look at this, @ashfurrow?
 I have not, would anyone be able to take a look? 
 Xcode itself reports 0% (as it checks the demo itself, not the library)... or am I overlooking something?

<img width="1512" alt="screen shot 2016-08-26 at 14 31 42" src="https://cloud.githubusercontent.com/assets/4190298/18005381/e6aacd90-6b99-11e6-8581-766d1fdbfa3a.png">
 Ah great, thanks. The overall coverage reported by Xcode is 80% (see attached)

<img width="1680" alt="coverage1" src="https://cloud.githubusercontent.com/assets/4190298/18006575/74644958-6ba0-11e6-8426-0610ab22a571.png">
<img width="1680" alt="coverage2" src="https://cloud.githubusercontent.com/assets/4190298/18006576/75c4e8fc-6ba0-11e6-81d2-d0e86270dccf.png">
 Thanks for looking into that! 80% is a far cry from the 66% CodeCov is reporting, looks like there may be a config issue. Anyone familiar with this? 
 Not familiar with CodeCov, but the algorithms to get a percentage might be different, explaining the difference. But the gap would still be pretty big...
 Coverage reported by CodeCov is back to 79%. Closing this for now.
  Goodness, lots in here. SwiftLint us run with Danger on ever pull request we get. This is good, but there are a few problems:
- SwiftLint yielded lots of problems, which are now fixed.
- SwiftLint is run multiple times (see [this issue](https://github.com/ashfurrow/danger-swiftlint/issues/16)). So I updated the plugin to just run once, but on all files. This is fine as long as we don't merge warnings.
- SwiftLint was complaining about `Moya.swift` being over 400 lines of code long. Yikes. I split it out into multiple files.
- Updated Carthage's `Moya.xcodeproj` to reflect new files.
- Added a Danger failure for added/deleted library files without a change to the Carthage Xcode project. Fixes #270.
- Changelog for all this, and fixed formatting for a previous entry.
 Going to rebuild so Danger runs. 
 Cool, pushed the update to the Dangerfile, and no warnings! So that's nice. 
 üçè 
 üö¢ 
  Loosely related to #559.

WIP because GitHub is choosing not to render the `svg` tag.
 @orta suggestions for the best way to display these colours? This is what I'm going for:

<img width="296" alt="screen shot 2016-07-23 at 1 56 36 pm" src="https://cloud.githubusercontent.com/assets/498212/17080254/4e980ae4-50dd-11e6-869f-22f44506a6ed.png">
 My only known hack here doesn't work http://www.tizag.com/htmlT/bgcolor.php - https://gist.github.com/orta/62febeb573df8e52965a5af7ddf5ba17
 Images are the best way to go
 though the purple is massive, and the rest are the right sized, would recommend throwng in image optim too 
 Okay, I think this is ready for review üëç 
 Better fix all them swiftlintsssssssssssssssssssss
 Yup, working on it now. It's also running more than once. 
 but nah, everything looks good from me.

One option for improvement though. You could do all the images at 2x size, then set the width/height to be half that. Then you have retina images. This is how I do it in most of my web projects.

![screen shot 2016-07-23 at 9 29 03 pm](https://cloud.githubusercontent.com/assets/49038/17081196/806b3bd8-511c-11e6-93ae-7aed9f55160d.png)

with 

![screen shot 2016-07-23 at 9 28 23 pm](https://cloud.githubusercontent.com/assets/49038/17081193/7403bd66-511c-11e6-8a75-a926eec73061.png)

instead of this at full size:

![screen shot 2016-07-23 at 9 29 28 pm](https://cloud.githubusercontent.com/assets/49038/17081198/8baf4106-511c-11e6-8b24-24333da25541.png)

which is massive, but scaled inline here
 okaaaaay
 It's a free TIL ;)
 Yep - that should do it
 I've opened https://github.com/Moya/Moya/pull/561 to address the SwiftLint problems. 
  Moya's gotten pretty big, I reckon it's time we get some stickers üéâ There are a few aspects to this issue:
- [x] Pick a sticker medium (probably through [stickermule](https://www.stickermule.com)). Thinking a single-colour [transfer sticker](https://www.stickermule.com/products/transfer-stickers) would be the coolest
- [x] Make a sticker design based on the chosen medium ‚òùÔ∏è.
- [x] Figure out how to collect addresses for contributors to mail them stickers
- [x] Order the stickers.
- [x] Mail them out.

This is a long-term ticket, I'm thinking we'll try to get it wrapped up sometime before the end of 2016.
 I totally understand going with single-colour but oh boy; i'm going to miss the colors üòâ 
 Yeah, I'm leaning more and more towards the colours too üòÑ 
 IMO, think the colours too - can work with https://www.stickermule.com/products/clear-stickers 
Moya logo has too thin lines to pull off the ones CP/Artsy use 
 Agreed, I think either the clear ones or maybe the [square ones](https://www.stickermule.com/products/square-stickers) could work. I think the square ones would go well if we used the GitHub avatar rather than the entire logo:

![](https://raw.githubusercontent.com/Moya/Moya/master/web/logo_square.png)

I'm not sure which one, either that or the actual logo would be more recognizable:

![](https://raw.githubusercontent.com/Moya/Moya/master/web/logo_github.png)
 Agree re:square

Re: full logo might want type e.g.

![screen shot 2016-07-23 at 11 48 54 pm](https://cloud.githubusercontent.com/assets/49038/17081683/0ab56b34-5130-11e6-8215-b5aefe19bd75.png)

specifically done bad on purpose to not think of design 

---

I'm voting square if clear
 It's like "lorem ipsum" but for visual design üòÜ 

Cool. Okay, maybe a straw poll? Vote by reacting to this comment on if you think a square logo or a full logo would be more recognizable in sticker format.

| Square Logo | Full Logo |
| --- | --- |
| üéâ | ‚ù§Ô∏è |
 Cool, calling it: square logo. Which means the design is finished :tada:

I'll take care of ordering them, the tricky bit is figuring out how to collect addresses. @orta you have experience with this. Google Forms? 
 I used a shared google spreadsheet, but forms can work too üëç ( sheets made it easier to me to ask for edits etc )
 Stickers arrived: 

![ashfurrow_2016-aug-10](https://cloud.githubusercontent.com/assets/498212/17555701/87c18796-5ede-11e6-93c7-285678ed2d4a.jpg)

(Pen included for size comparison, they're 3.5cm squared.)
 The US-bound stickers are already in the mail, the international post should be going out this week. Thanks for your patience! 
 Mine arrived today!

> On Oct 12, 2016, at 3:04 PM, Ash Furrow notifications@github.com wrote:
> 
> The US-bound stickers are already in the mail, the international post should be going out this week. Thanks for your patience!
> 
> ‚Äî
> You are receiving this because you are subscribed to this thread.
> Reply to this email directly, view it on GitHub https://github.com/Moya/Moya/issues/559#issuecomment-253338744, or mute the thread https://github.com/notifications/unsubscribe-auth/AABrsnzlYVI99otwRW3t2kTRoPiWHp8tks5qzUtdgaJpZM4JTZGx.
 Hi @ashfurrow do you reckon I still have time to update my address?

The current address is `SoundCloud` but attention to ¬´Pedro Pi√±era¬ª because I didn't know if I was going to be in üá©üá™ by the time the stickers would arrive.

If its too much hassle I won't update, was just wondering
 @esttorhe Aye, I've addressed it to Berlin, but if you're not there anymore I can change it. 

If anyone else has address updates, please send the updated address to ash@ashfurrow.com . Thanks!
 Thanks @ashfurrow.
I'm in Berlin now actually. I just didn't want to bother Pedro now that I can actually get it myself üòä

But like I said. No biggie

‚Äì
Esteban Torres
CraftKollective (http://craftkollective.com) Co-Founder

Phone: (+506)8813-0934 (tel:(+506)8813-0934)
Skype: esteban.a.torres.hernandez
Twitter: @esttorhe (https://twitter.com/esttorhe)

On 12 Oct 2016, 23:20 +0200, Ash Furrow notifications@github.com, wrote:

> @esttorhe (https://github.com/esttorhe) Aye, I've addressed it to Berlin, but if you're not there anymore I can change it.
> 
> If anyone else has address updates, please send the updated address to ash@ashfurrow.com (mailto:ash@ashfurrow.com) . Thanks!
> 
> ‚Äî
> You are receiving this because you were mentioned.
> Reply to this email directly, view it on GitHub (https://github.com/Moya/Moya/issues/559#issuecomment-253342931), or mute the thread (https://github.com/notifications/unsubscribe-auth/AChTonfydJwuZiujIkPUgC3n9kdDmSz_ks5qzU8pgaJpZM4JTZGx).
 Alright, I've sent these all out, let me know if you don't get them. Thanks again for everyone's work in making Moya such a successful community project, I'm incredibly proud of what we've built together.
 Thank _you_, Ash!
 Exactly, thank _you_ Ash & @orta for starting this amazing journey üëè
  What's your setup like, CocoaPods or Carthage? What Xcode and Moya version are you using?
 Hmm, I haven't been installing Moya with CocoaPods 0.39 for a while. Can you post the relevant parts of your Podfile? I can take a look at it later tonight if someone hasn't chimed in by then. 
 @jcampbell05 I'm going to close the issue, if this is causing problems, feel free to reopen üëç
  Thanks! üôå
  Hmm, this is an interesting question. There's no reason we can't/shouldn't do this, it's just never been a priority before, so it's definitely worth considering. I'm thinking we abstract the functions we call from Alamofire into protocols, and extend Alamofire types to conform to those protocols. Then we just need a way to specify a different set of types that also conform.

There's a bit of hassle where we're currently using `typealias` to create Moya-specific types from Alamofire ones (for things like request methods, GET, POST, etc) that would need a little bit more code, but nothing too dramatic. 

I've got a flight tomorrow, might take a stab at this on the plane. In the meantime, you could explore subclassing Moya's `Provider` class to give you similar behaviour. Please let us know if you have ideas for implementation, too. 
 I forgot about that, thanks!
 I took an initial stab at this, it's quite an overwhelming change. We actually lean on Alamofire a lot, include use of `typealias` to create Moya types that are really just Alamofire types. If we do this, I would want someone to be able to theoretically use Moya without having any reference to Alamofire code at all.

@jasl how up-to-date is your fork? Moya has added multipart form uploading and a few other large structural changes recently, would it work with those changes? 
 Okay, thanks for the quick response!

I tried to tackle this from top-down, like replacing our references to `Alamofire.Manager` with a new protocol defined in Moya, but _everything_ broke immediately, and I was no where near finished an hour later. I think a better approach would be to remove the `typealias`s in `Moya+Alamofire.swift` first, then replace use of `Manager` with a new protocol. I'll see what I can do later. 
 I tried abstracting Alamofire and found Moya to be too tightly coupled to it to reasonably separate. This is probably because we've always built Moya on top of Alamofire, the de facto standard networking library on iOS. This is a reasonable hard dependency from my perspective, but as always, it's open for discussion. If anyone would like to send a pull request with this specific feature, I'd be happy to look it over :+1: In the mean time, we can keep this issue open in case others have ideas or suggestions.
 Since there hasn't been any activity on this thread for some time, I am going to go ahead and close it. Please re-open or create a new issue if you would like to discuss further. Thanks. Thanks for the kind words, @SD10, and good luck with Nora. :)  The code is repeated because the app target is specific against iOS, but the three testing targets are specific to iOS, tvOS, and macOS. They all use the same files, but can't link against the app target because it's only iOS. Does that make sense? 
 It's a good question, thanks for opening an issue üëç
  This has been in a few builds, but support for unscoped vars is going away soon.
  Awesome thanks! Ignore the SwiftLint errors, we're having problems with it on CI. I can review the code shortly üëç
 Cool, I feel like this is good to merge. @leonereveel @colinta you two wrote the original multipart upload code, how does this look to you? Shame we'll have two major versions in quick succession, but I think it's worth it. 
 Yeah, same here üòÑ Okay, gonna wait for others to have input, otherwise I think we're good to merge!
 Fab, gonna merge!
  Yeah, seems likely. We've run into problems in the past on our Demo app (`import`ing more than one version of Moya). You're using Carthage, eh?
 Well, CocoaPods will include all the specified subspecs in one module, named `Moya`. So if you have `pod 'Moya/RxSwift`, that will pull all the RxSwift Moya files _and_ the regular Moya files into one module. Carthage doesn't have an equivalent of subspecs (they're stance is that you should use multiple frameworks instead ‚Äì which we considered but decided against).

_Maybe_ you could do something like

``` swift
typealias TargetType = RxMoya.TargetType
```

And then you wouldn't see `RxMoya.`?
 That's odd. Hmm. @Moya/contributors Anyone else seeing build errors with Carthage?
 Yup! I did delete the pre & post build scripts in that PR üëç
On Wed, Oct 19, 2016 at 8:07 PM Pierre-Marc Airoldi <
notifications@github.com> wrote:

> I think this has been addressed by #563
> https://github.com/Moya/Moya/pull/563
> 
> ‚Äî
> You are receiving this because you authored the thread.
> Reply to this email directly, view it on GitHub
> https://github.com/Moya/Moya/issues/551#issuecomment-254997633, or mute
> the thread
> https://github.com/notifications/unsubscribe-auth/ADo1dE0LBtCwBJZ6lpO2x2Cxj99HFd7Zks5q1trQgaJpZM4JNqy5
> .
  Looks good! Much nicer. The SwiftLint warnings above are strange, since you didn't modify _any_ of the files it's complaining about. I'll fix that separately, gonna merge!
 Thanks a lot for contributing to Moya! I've invited you to join the Moya GitHub organization ‚Äì no pressure to accept! If you'd like more information on what that means, check out our [contributor guidelines](https://github.com/Moya/contributors) and feel free to reach out with any questions.
  When you get this error, the next step is usually to specify the return type explicitly. Looking at the Moya source code, you can change your line to the following:

``` swift
let requestClosure = { (endpoint: Moya.Endpoint<ICanHazProvider>, done: Result<NSURLRequest, Moya.Error> -> Void) -> Void in
```

Let us know how it goes!
 Yup, taking a look now. I've not seen this before, things are working for me with the latest `master` branch with Xcode 7.3.1. Have you run `pod install` in the Demo directory? What version of CocoaPods are you using?
 @bryanbartow I think the second example might be getting confused with the `nil`s used as parameters (they're non-optional, just remove them and they'll fallback to the defaults). But that doesn't explain the first error. 

I'm really at a loss on that one. Would it be possible to share a small Xcode project demonstrating the problem? It would help figure out what the problem is. 
 Awesome! So that works? Where do you think we should document this? 
 @bryanbartow your problem might be returning the `Result` type in the closure that takes `Void` as a return type. Below code works under Xcode 7.3.1 & Moya 7.0.0:

``` swift
let requestClosure = { (endpoint: Moya.Endpoint<ICanHazProvider>, done: MoyaProvider.RequestResultClosure) in
    let request = endpoint.urlRequest.mutableCopy() as! NSMutableURLRequest

    done(.Success(request))
}
```

@kamil-tomaszewski: @ashfurrow is right, when you specify `nil` in the rest of the parameters, Xcode throws not-so-specific error. When you remove the parameters with `nil` it should be good with the code below:

``` swift
let endpointClosure = { (target: GitHub) -> Endpoint<GitHub> in
    let url = target.baseURL.URLByAppendingPathComponent(target.path).absoluteString
    let endpoint: Endpoint<GitHub> = Endpoint<GitHub>(URL: url, sampleResponseClosure: {.NetworkResponse(200, target.sampleData)}, method: target.method, parameters: target.parameters)
    return endpoint.endpointByAddingHTTPHeaderFields(["APP_NAME": "MY_AWESOME_APP"])
}
```

About @dccarmo issue I'm kinda lost as well ¬Ø_(„ÉÑ)_/¬Ø Might try omitting the `Result` type in `done` callback, like `done(.Success(result))` and try if it works? Otherwise could you provide us an example project where the issue exists? Would be really helpful.
 @bryanbartow Yeah, we've had issues before when using multiple `Result` identifiers. You can use modules names to namespace the specific `Result` type, like `Result.Result` or `MyLibrary.Result`, it can get tricky. Let us know how it goes :+1: 
 @kamil-tomaszewski It could be that in the original code, you had `let endpointClosure: MoyaProvider.EndpointClosure` without specifying the generic type of `MoyaProvider` and it confused the type system? Try `let endpointClosure: MoyaProvider<GitHub>.EndpointClosure` and see what happens. (It works if you don't specify anything because the compiler can infer from the closure signature what `MoyaProvider`'s generic type is.)
 It seems the issue here has been solved, so I guess this issue can be closed, right?
  We forgot to add a changelog entry for #483, this change now fails a build if library source code has changed without a changelog entry. This means that refactors that don't change user functionality will need to be included, too. I'm okay with that, refactors might introduce bugs and changelog entries could really help someone. 

@colinta Any thoughts on this?

Fixes #546.
 An expanded message is a good idea üëç 
 Empty Moya message is a known issue: https://github.com/ashfurrow/danger-swiftlint/issues/10

@colinta does that message look good? 
 Yep
  Hmm, I see. This is when building with Carthage or CocoaPods. In CocoaPods, I can see Moya maybe having 10.9 as a minimum deployment target, with the RxSwift subspec having 10.10. Not sure if we can selectively allow 10.9 with Carthage.
 Can't we just set the RxMoya targets to 10.10?
 Not sure what's best here, @justinmakaila I'll defer to you on this one.
 Cool, #553 has breaking changes anyway, so we can merge this without worrying about semver. 
 Thanks a lot for contributing to Moya! I've invited you to join the Moya GitHub organization ‚Äì no pressure to accept! If you'd like more information on what that means, check out our [contributor guidelines](https://github.com/Moya/contributors) and feel free to reach out with any questions.
 @ashfurrow @sendyhalim Sorry guys, I got hung up with work. I tried my proposed solution above and it didn't seem like it worked; glad this got merged in and is good to go for all our `RxMoya` users... now we gotta figure out how to make it so you don't have to download unnecessary dependencies ;)
  Hmm, looks like an oversight. Want to send a pull request with the added entry? 
 It might be worth adding Danger's CHANGELOG as a fail back, even in this case it was missed, but the fail was legit:

<img width="788" alt="screen shot 2016-07-14 at 12 31 38" src="https://cloud.githubusercontent.com/assets/49038/16847420/0029f360-49bf-11e6-8d77-00d9f238e5ba.png">
 I think we would have noticed the danger message if it had run, but something went wrong on that build:

<img width="659" alt="screen shot 2016-07-14 at 12 36 13 pm" src="https://cloud.githubusercontent.com/assets/498212/16847560/a5d62ee6-49bf-11e6-9814-47a41b74ff62.png">

Which is on me, I should have re-run the build or fixed Danger. I think that pull request had just taken so long to get tot hat point, I was too impatient to merge. 
 I took that image from the PR: https://github.com/Moya/Moya/pull/483#issuecomment-230908591 - it must have got fixed on a rebase or something
 Yeah, what I mean is that if Danger had had a chance to run and fail due to a missing changelog, the human merging (me) should have asked for one. But because I ignored the Danger failure (because it wasn't working), I also ignored the previous comment Danger had made about this missing changelog. I guess I assumed it had been added at some point. 

I agree we should probably re-think how we treat missing changelog entries. What sort of heuristic do you reckon should we use? 
- Any swift files changed?
- A certain number of .swift lines added/removed/changed?
 Ah, yeah, on Danger we [check for any](https://github.com/danger/danger/blob/master/Dangerfile#L4-L5) lib files:

``` ruby
has_app_changes = !git.modified_files.grep(/lib/).empty?
has_test_changes = !git.modified_files.grep(/spec/).empty?
```

You could do the same for `Source` and `Demo/Tests`:

``` ruby
has_app_changes = !git.modified_files.grep(/Source/).empty?
has_test_changes = !git.modified_files.grep(/Demo\/Tests/).empty?
```

_\* disclaimer, I'm not great with regexes_
 Sounds good. I'll send a PR, thanks for bringing this up again Orta. 
  What you've got is actually how things are done, except broken into several lines. [Here's an example](https://github.com/artsy/eidolon/blob/70b59b1cfd0c68730b6a2860fabeb8cbaca2acca/Kiosk/App/Networking/ArtsyAPI.swift#L112) of using it. 
 Cool! Please consider submitting a PR to the readme to add it :+1:
  Weird, I'll check if danger has had any issues like that reported. @orta seen this?
 Looks like it's already been reported: https://github.com/danger/danger/issues/316 Issue involves how Danger determines which commit the PR is made from. Going to merge.
  This looks great, going to merge. @colinta thanks for your really rapid response time and quality code!

Just realized that now that #537 is merged, we'll continue to get code coverage reports on builds without changelog entires üëç 
  Moya only supports progress notifications while uploading a file, not for regular requests (thought Alamofire _does_ support this, so it shouldn't be too difficult to add this to Moya. I'm a little surprised that Moya doesn't already support this, to be honest, it's something we should consider adding. Could you tell us more about how you'd expect this to work?
 @colinta aye, could be worth factoring a bit out. If we can be backwards compatible, that's great, but we're about to have a major release with other breaking changes, so we could roll this feature into that release. 
 @alexdoloz yup, that makes sense! The trailing closure syntax is preserved that code.
 @alexdoloz now that #543 is merged, this should work if you use the latest version of Moya, on the master branch. If you're using CocoaPods, you can change the Podfile to include `pod 'Moya', git: 'https://github.com/Moya/Moya.git'` and do a `pod update` and it should work. Let us know!
 Ah, okay! No rush. 
 I think this was closed by #543, re-open if not. 
 Can you open another issue about the -1 bytes expected? Link back here for context üëç 

I think the bytes expected comes from Alamofire, and ultimately the server. It may be that -1 is what ALamofire provides when there is no expected number of bytes available, which might could from the server. Not sure, though.
 @alexdoloz I'm glad you got it figured out!
  This is a great question I looked through my own code, because this is something I've had to test to. The [code](https://github.com/artsy/eidolon/blob/fdd5981005b1c631d284f89f9a2d7bb808437e0d/KioskTests/ListingsViewModelTests.swift#L163) I found is a little old and doesn't apply directly to this question. 

So the way I would approach this fresh is that you don't necessarily need the state to be internal to the testing provider. When you create a provider in your tests, you can pass in an `endpointClosure` that accesses an `isFirstResponse` variable defined outside the closure, within the test. Set it to `true` before the test begins and the first time the `enpointClosure` is called, set it to `false`. Not sure what testing framework you're using ‚Äì if you provide the code that you've tried so far, I can give you an idea of how I would approach it.

Moya's architecture places a large emphasis on testing, but most of our documentation discusses only how to use Moya in production code. I think it's worth adding documentation demonstrating best practices and common techniques when using Moya with testing. @fruitcoder if you have any ideas on what could be included, let us know üëç 
 Sounds like you might be talking about this issue: https://github.com/Moya/Moya/issues/56 That's actually our _oldest_ open issue, something we've wanted for a while üòÑ 

So I think testing examples/demos should include things like the following:
- How to create a provider that always stubs (a "Hello, World" for testing with Moya).
- How to verify that a specific request was actually performed.
- How to verify that two different requests were actually made.
- How to return a different status code than 200.
- How to return different response data depending on parameters of the request.
- How to handle errors returned from a `requestClosure` (like an OAuth error).
- How to return different response data depending on how many times it's already been invoked (an example of polling for a specific response).

It could be really cool to include both a short code snippet showing the technique and also a link to an open source project that actually uses that technique. I can find Artsy examples once we have a list of everything we want to demonstrate. @fruitcoder any techniques you think we should add to this list?
 Cool üëç New issue sounds like a good idea, link back to this one, maybe copy over the list too. I think the new docs around testing should go in a new markdown file called Testing.md, if you're keen to to help out a pull request would be welcome!
 I've opened https://github.com/Moya/Moya/issues/632 to address improves to the documentation, going to close this, feel free to re-open. 
  What's the `carthage` command you're running that's producing the error? 
 We've seen [other issues](https://github.com/Moya/Moya/issues/445) with Carthage that were solved by running `carthage update --platform iOS --no-use-binaries` instead. Can you try that and see if it works? If that's the fix, we should add it to our readme. 
 I'm not sure then, I don't use Carthage so I'm not the best to help out with troubleshooting. 
  PR authors should be reminded of changelog entries, but missing entries shouldn't fail the CI build.
 Sure, seems fine with me üëç 
  Related to #534. Tested in local repo and got through `carthage update` no problem.
 Looks like it was checked in here, in October 2015: https://github.com/Moya/Moya/commit/9ee73026ba8e2bf4394de7d795ba42b778b3fea7#diff-8903239df476d7401cf9e76af0252622 so the problem this PR solves has been around since about [version 4.1.0](https://github.com/Moya/Moya/blob/master/Changelog.md#410) of Moya. @justinmakaila Do you think this is something worth including in the changelog? Like, would it be useful for Carthage users to have a note in there about it? 
 @ashfurrow I don't think so, everything looks fine for downloading the build with carthage with and without submodules. I think it made it in as a mistake and became a problem somewhere between then and now as `Carthage` progressed.

**EDIT**:
With the `Carthage/Checkouts` directory present, `Carthage` was able to pull the repos from that directory, which would come down with the `git clone` operation. When we pulled it in between now and the last tag, the `.gitmodules` file pointing to nothing in particular started causing problems while `Carthage` was trying to establish dependencies.
 Okay cool. The only CI failure is a missing changelog, so I'm going to merge (and then submit a PR changing that "no changelog" error to a warning...)
 > Okay cool. The only CI failure is a missing changelog, so I'm going to merge (and then submit a PR changing that "no changelog" error to a warning...)

Might want to check for App-level changes before failing instead
 Hmm, good idea. I added the error originally to help us be more diligent about our changelog entries. I still worry that if we keep the error, we might intimidate new contributors with a failed CI build instead of a warning. And longtime contributors are [even getting called out](https://github.com/Moya/Moya/pull/530#issuecomment-231434087). Going to move discussion over to https://github.com/Moya/Moya/pull/537
  I think this is a good idea, I don't see any other issues tagged "breaking changes", but we need to cleanup those issue tags anyway üòÅ 

I'll give some time for other @Moya/contributors to chime in, and if no one objects, we'll release Moya 7.0.0 üéâ
 We _might_ have a non-backwards-compatible feature request worth squeezing in: https://github.com/Moya/Moya/issues/542 I believe @colinta is taking a look, I can help too.
 Cool, I think we're good?
 Okay! That's tagged and pushed to CocoaPods, Carthage folk have their GitHub release, too: https://github.com/Moya/Moya/releases/tag/7.0.0

Thanks for the help all our contributors have put in to getting us to Moya's _seventh_ major release in two years!
  Thanks for the PR! Don't mind the SwiftLint warnings. 

CI is failing due to a problem finding the `isCancelled` property ‚Äì you said it's working for you locally? I can try and take a look here too. 
 I agree, sound good üëç 
 Mergin'!
 Thanks a lot for contributing to Moya! I've invited you to join the Moya GitHub organization ‚Äì no pressure to accept! If you'd like more information on what that means, check out our [contributor guidelines](https://github.com/Moya/contributors) and feel free to reach out with any questions.
  Reported in https://github.com/Moya/Moya/pull/530#issuecomment-231418477 , we should consistently calling the failure block when cancel. 
  Looks üíØ Sorry for radio silence on the other PR, on vacation this week. This looks good to merge when you're ready, I'll review the comments on the other tomorrow. 
 Agreed, that's surprising behaviour. I'll open a separate issue to fix that, this looks great to merge. 
  Yup, we have them there for Circle. Is the Demo project used by Carthage for building? (We really do need better documentation around it, every time someone has a question related to Carthage, I'm a bit at a loss). 

Can any Carthage-savvy devs on @Moya/contributors help take a look? 
 Glad it's working!
  A request with duplicated parameter keys? I've never seen a server require those before, since query string parameters are usually referenced as a dictionary, and can't handle duplicate keys. I have seen arrays specified as `?filter[]=a&filter[]=b`, is that what you're looking for?

It's possible to get around this by doing your own custom parameter encoding (since we rely on Alamofire's, which has this limitation of treating params as a dictionary). Here's [an example of using custom parameter encoding](https://github.com/Moya/Moya/blob/38b0bda890b7b4598552a353b3f8db4248c37d6e/docs/Examples/ArrayAsRootContainer.md) that you should be able to modify for your server requirements. Let us know how it goes.
 I'm glad ‚Äì I think if you just pass the array as a a parameter, it should "just work." Alamofire detects arrays and uses that query string format. 
  @AndrewSB would you mind adding an entry to the `Changelog` ? üòÑ 
 Looks good and test are passing ‚úÖ 
 Thanks a lot for contributing to Moya! I've invited you to join the Moya GitHub organization ‚Äì no pressure to accept! If you'd like more information on what that means, check out our [contributor guidelines](https://github.com/Moya/contributors) and feel free to reach out with any questions.
 I'll need some time to get used to the ü§ñAsh from posting as soon as I hit the merge button üòõ 
 It worked! https://github.com/Moya/Aeryn
  It's possible; how are you building the project that's not working? Any details around Xcode version etc would be awesome too. 
 I wonder if the Xcodeproj needs updating?
 No problem, thanks! First, if this is blocking your project, you should be able to use our most recent release. But as far as fixing master, hmm. The `Moya-iOS` Xcode project was added by @JRHeaton for Carthage compatibility. I can't remember the mechanism for updating it ‚Äì it doesn't look like it's from the release task, but I'm not sure if it's generated by CocoaPods either. I'll take a peak and see. @AndrewSB have you seen this before on other Carthage projects? Any tips for troubleshooting? 
 Looking at #505 it does look like `NetworkCurlLoggerPlugin.swift` was added to the project file, but not to the repo, probably by accident. Removing those lines [added to the project](https://github.com/Moya/Moya/pull/505/files#diff-a24d686152f5e86f361b118f3c399d22) should fix it. @AndrewSB are you able to test + send a pull request?
  To encourage better testing strategies üëç 
 @AsimNet Worst case:

```
var sampleData: NSData {
  return NSData()
}
```

...But as @orta said, mostly for testing. You don't realize how great it is until you start writing your tests.
  I released [the gem](https://github.com/ashfurrow/danger-swiftlint) so we don't need to refer to it by repo URL anymore. This does the same for Danger.
  Hey @tdouglas1313. There is a conversation in #513 about Swift 2.3 and 3.0 support. However, there is no PR with updates for any of versions _yet_. 
 Good suggestion! I've changed the title, thanks! I think in this case I can close this one in favor of #513.
   ![11401351_10205530165906879_6807594257863400673_n](https://cloud.githubusercontent.com/assets/49038/16508623/b3c41936-3f02-11e6-8b19-35e84b63fd59.jpg)
 Hmm, getting this again:

> Not a Pull Request - skipping `danger` run

I'll take a poke. 
 Looks like https://github.com/danger/danger/issues/226
 Appears to be a problem with Circle where they don't specify a `CI_PULL_REQUEST` environment variable even though this _is_ a PR build. As per [their discussion on this](https://discuss.circleci.com/t/ci-pull-request-no-longer-when-building-a-pr/4191/8), I've contacted support to get this figured out.
 Weird, printing the [four required variables](https://github.com/danger/danger/blob/f895ac3be3c1fc2c30062d2ca71598f076a3e0b9/lib/danger/ci_source/circle.rb#L9-L12) after setting one explicitly works:

``` rb
puts ENV["CIRCLE_BUILD_NUM"]
puts ENV["CI_PULL_REQUEST"]
puts ENV["CIRCLE_PROJECT_USERNAME"]
puts ENV["CIRCLE_PROJECT_REPONAME"]
```

```
249
https://api.github.com/repos/Moya/Moya/pulls/521
Moya
Moya
```

Not really sure where to go next. It might require more digging around in Danger to figure out why this isn't working. 
 @at-daonv thanks for the tip! I"ve added something similar to the Rakefile.
 Ooohhhhh boy would you look at that?!
 You probably want this too,

```
# Make a note about contributors not in the organization
octo_client = env.request_source.client
unless octo_client.organization_member?('moya', pr_author)
  message "@#{pr_author} is not a contributor yet, would you like to join the Moya org?"

  if modified_files.include?("*.podspec")
    warn "External contributor has edited the Podspec"
  end
end

```
 This looks **AMAZING**
 @orta good idea, I was actually going to play around with [squad_goals](https://github.com/benbalter/squad_goals), maybe make a Danger plugin. For now I think we can merge without it, and add it in if squad_goals takes too long. 
  Most importantly, this fixes the broken CI we've had for a while. It also updates the version of CocoaPods that we're using to 1.0 and adds a Rake task to make doing a `pod install` locally easier (makes it easier to develop Moya!).

So what about those tests? Why were they broken? 

Good question. This is a timing issue related to testing request cancellation in the _integration_ tests, which are only meant to test that the provider actually hits the network. I moved the test into the regular provider tests and specified an explicit timeout to avoid timing problems. Fingers crossed for this PR.

Fixes #498.
 Yikes, [all Travis OS X builds are currently delayed](https://www.traviscistatus.com/incidents/rqb906yypnk0), might take a while to see this üçè 
 ```
[!] Unable to satisfy the following requirements:
- `ReactiveCocoa (= 4.2.1)` required by `Podfile.lock`
- `ReactiveCocoa (~> 4)` required by `Moya/ReactiveCocoa (6.5.0)`
```

Been seeing this only on Travis. `bundle exec pod install` doesn't change any files locally. Might be the misuse of `~>`. Gonna poke around.
  Super, thanks! Don't worry about the üî¥ Travis result, it's being fixed in #520.
 Thanks a lot for contributing to Moya! I've invited you to join the Moya GitHub organization ‚Äì no pressure to accept! If you'd like more information on what that means, check out our [contributor guidelines](https://github.com/Moya/contributors) and feel free to reach out with any questions.
  You should be able to just have `"somethingBool": data4` as an element in the returned dictionary, right? 
 Thanks for the follow-up. How are you detecting the value, on the server side or client side? Could you try using the [network activity plugin](https://github.com/Moya/Moya/blob/master/docs/Plugins.md#network-activity-indicator) to log the request before it's sent? 
 @lucasp90 That's certainly puzzling! Especially since Moya gets Alamofire to do the parameter encoding, and I would have thought they would support Bool.
 @jasl Good thinking linking to that. It seems to [fallback to String interpretation](https://github.com/Alamofire/Alamofire/blob/master/Source/ParameterEncoding.swift#L198) of plain objects, so `Bool` should work, right? 
 I dunno, I think that if Alamofire is parsing `Bool` as "true" or "false" it must be a good approach. These [Wordpress docs](https://codex.wordpress.org/How_to_Pass_Tag_Parameters#Bool) explicitly say that either is acceptable for them.
 @lucasp90 has this been clarified to your satisfaction? 
 No problem! I think adding examples would be a great idea, where do you think they should go? https://github.com/Moya/Moya/blob/master/docs/Targets.md maybe? 
 Cool! Could I ask you to send a pull request? Don't worry if you can't, we'll get it :+1: 
 Closing this as it looks like it's been resolved üòÑ thanks for contributing the README again, @lucasp90!
  @matteogazzato It's going to depend on your backend. Some can just take raw image blobs, some need it encoded a certain way, blah blah blah.

If you just want to put the raw data in the dictionary, you can do so using `UIImageJPEGRepresentation(_:)` or `UIImagePNGRepresentation(_:)`, as per [the docs](https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIKitFunctionReference/index.html#//apple_ref/c/func/UIImagePNGRepresentation).

If you want to use multipart, check out the open PRs, specifically #441 and #483.

Let me know if you have any questions!
 Glad you got it working ‚Äì are we okay to close this @matteogazzato?
  Yikes, I hadn't heard that. Can't remember why we used spin locks, we can probably move to `NSLock` without too much fuss. Anyone up for a pull request? 
  Awesome! Looks good to me, want to add links to the new files from the readmes in the docs/ and docs/Examples directories? Good to merge after that üëç 
 @wattson12 I added some links and syntax to your markdown: https://github.com/wattson12/Moya/pull/1
 Fab!
  This is great work and a nice comprehensive write-up, thanks @aaroncrespo!
 Sorry about the accidental closure. Misunderstood what 'Close' meant in a third-party GitHub client. Was just trying to close the issue view. üò≥ 
 No problem, it happens!
 I've changed the title due to #522 discussion.
 Aye, think it's worth shipping a 2.3 dupe of current Moya, one the Rx deps have them, then moving to 3.0
 That makes sense ‚Äì should we make 2.3 version off of `master` or the most recent commit? (master has breaking changes.)
 Maybe the last stable release?
 We will have to wait before updating to the GM Seed version:
- [x] [RxSwift#869](https://github.com/ReactiveX/RxSwift/pull/869)
- [x] [Result](https://github.com/antitypical/Result) update

**Edit:** I've opened #608 for Swift 3.0 support.
 @sunshinejr It seems Result already is Swift 3. :)
 This looks like it's been solved with the 8.0.0 beta releases, I'm going to close it out. Please feel free to open this if there are any loose ends!
  Related to https://github.com/Moya/contributors/pull/7

Remaining items:
- [ ] We should probably refer to this document from the readme. 
 Feels good, will try and look at the README thing on the plane
 OK, v2 is ready
  @dropski I would humbly encourage you to close the issue, because I've seen lots of open-source projects where there are tons of issues still open, only because the maintainers can't tell if the person who opened the issue is "happy" with the results.  It's a good way to keep things tidy!
  Just one, for sure!  Here's how we do it in the Ello app:

###### ElloProvider.swift

``` swift
    public static func endpointClosure(target: ElloAPI) -> Endpoint<ElloAPI> {
        let sampleResponseClosure = { return EndpointSampleResponse.NetworkResponse(200, target.sampleData) }

        let method = target.method
        let parameters = target.parameters
        let endpoint = Endpoint<ElloAPI>(URL: url(target), sampleResponseClosure: sampleResponseClosure, method: method, parameters: parameters, parameterEncoding: target.encoding)
        return endpoint.endpointByAddingHTTPHeaderFields(target.headers())
    }
```

###### ElloAPI.swift

``` swift
    public func headers() -> [String: String] {
        var assigned: [String: String] = ["Accept": "application/json", "Accept-Language": "", "Content-Type": "application/json"]

        if self.requiresAnyToken {
            assigned += [
                "Authorization": AuthToken().tokenWithBearer ?? "",
            ]
        }
```
 [ElloProvider L32](https://github.com/ello/ello-ios/blob/master/Sources/Networking/ElloProvider.swift#L32)

[ElloApi L455](https://github.com/ello/ello-ios/blob/master/Sources/Networking/ElloAPI.swift#L455)
 I'm going to close this issue. @mrfarukturgut, feel free to open it again if you still have questions!
  Neat, thanks! üéâ Build failure is not connected with the PR so I'm gonna merge it. üêº 
 Hey there! Thanks a lot for contributing to Moya! I've invited you to join the Moya GitHub organization ‚Äì no pressure to accept! If you'd like more information on what that means, check out our [contributor guidelines](https://github.com/Moya/contributors) and feel free to reach out with any questions.
  Hey @Miasma87! What I think @petester42 meant, was to extend your `TargetType` to have 2 cases:
- First one for getting one genre from API:

``` swift
case Genre(String)
```
- Second one for getting more than one (or to be precise, 0 or more) genres using array of strings:

``` swift
case Genres([String])
```

But it depends if your API has an endpoint for getting more than one genre at a time. If not, I'm afraid Moya does not have built-in solution for that. Actually, it would be really tricky, because what happens if one request succeeds and one does not? We would need an array of result responses/errors or any other solution to handle this.

But what comes to my mind is that you could create an asynchronous queue and handle this by yourself. Or use reactive extensions for Moya, which would make that task significantly cleaner.

Hope it helps! üêº 
 Have you been able to fix this, @Miasma87?
 Do you have an update on this, @VivienGiraud? :) No worries, thanks for the update nonetheless! Since there hasn't been any activity on this thread for some time, I am going to go ahead and close it. Please re-open or create a new issue if you would like to discuss further. Thanks.  Looks awesome!
 Thanks a lot for contributing to Moya! I've invited you to join the Moya GitHub organization ‚Äì no pressure to accept! If you'd like more information on what that means, check out our [contributor guidelines](https://github.com/Moya/contributors) and feel free to reach out with any questions.
  Nice, thanks!
 Hey there! Thanks a lot for contributing to Moya! I've invited you to join the Moya GitHub organization ‚Äì no pressure to accept! If you'd like more information on what that means, check out our [contributor guidelines](https://github.com/Moya/contributors) and feel free to reach out with any questions.
  Hmm, not easily, though you could use the `StructTarget` to use a `struct` instead of an `enum` for your `MoyaTarget`. I'm not aware of anyone doing this, if you find anything online that helps, please let us know üôá 
 You may want to consider generating the Moya source code from your API similar to this: https://github.com/lkuczborski/SwiftMoyaCodeGenerator - you can't really get the advantages of Moya without their being defined types in code 
 @wonc003 did you manage a solution for this issue? Would love to have it added to our documentation üëç
 Since there hasn't been any activity on this thread for some time, I am going to go ahead and close it. Please re-open or create a new issue if you would like to discuss further. Thanks.  Can't tell without more information, like what it looks like when you request the API call. Also, not sure of the `func sendRequest` and `public func request`, are those from Moya or a subclass you've created? Thanks!
 Going to close this @kyleYang. Feel free to open a new issue if you still have a question. @robertofrontado can you post your code where you're getting this issue? Also, what version of Moya are you using?  Hey @iDiyor, thanks for opening an issue! :tada: 

Moya uses Alamofire's [parameter encoding](https://github.com/Alamofire/Alamofire#parameter-encoding) which has URLEncodedInURL case, which I believe you can use in your case. üòé

Hope it helps! 
  Not to belabor the point, but there is a lot wrong with parsing the body of a GET request. Here's a great explanation: http://stackoverflow.com/a/983458

> On Jun 13, 2016, at 7:53 PM, Sebastian Bean notifications@github.com wrote:
> 
> GET is meant as simply a request to a URL. Thus URL encoding is the only real thing that makese sense.
> 
> I'd try switching over to POST.
> 
> ‚Äï
> You are receiving this because you are subscribed to this thread.
> Reply to this email directly, view it on GitHub, or mute the thread.
 I think we can close this one, but if you will have any more questions @awclives about this topic, let us know! üêº 
  Good catch! Can you also make the same update to `ReactiveCocoa.md`?
 Awesome, thanks!
  Hey @iSame7, thanks so much for the idea! üéâ  Seems really fun! 

Although _I'm not sure_ if it would fit in current core of Moya, I would love to see it _**at least**_ as some sort of extension. What do you think about that? 

Also, anyone else from @Moya/contributors could take a look? üêº 
 I'd love to see a working example, I've been working on something similar, but unfortunately I can't get away from the singleton object for making requests, which results in a lot of `API.request(target: MoyaTarget)` calls around
 @iSame7 would it be possible to look at your code? I'm not sure if this is the right abstraction layer to institute this, but even if it doesn't belong in Moya, I'd love to add documentation around it. Please let us know :+1: 
 Closing this for now. @iSame7, please reopen a new issue if you think there is an opportunity to improve the documentation around abstracting Moya.  Very strange, thanks for reporting this. Could you provide some more details so we can reproduce this? Is it on a device or just the simulator? iOS 8, 9, or both? The networking code that demonstrates the problem would be helpful, if you can share it. Thanks again!
 Received the email, taking a look ASAP, probably won't be until the weekend. Will update. 
 Okay, I've tried taking a look but I don't have a device at the moment to test on. I'll try to take a look this weekend. In the mean time, I'd recommend trying to following trying to call the Alamofire request manually (if you can). I'd like to narrow down if this is a problem with Moya, Alamofire, or NSURLConnection. Can you provide any more details, like what device you're using, wifi status, any server logs you have? Thanks!
 @kevin5396 Interesting! Makes sense, since `NSJSONSerialization` would fail with empty data. I'm not sure what the best way to solve this is, maybe extend `mapJSON` to include a parameter for allowing empty data? 
 Makes sense! We should provide a default option, and this'll need to be added to both the RxSwift and ReactiveCocoa extensions too. Anyone available to submit a pull request? 
 So it looks like a PR to fix this issue would modify [the `mapJSON` function](https://github.com/Moya/Moya/blob/645398713e41a0f61a36c57e707d5135f2fa8477/Source/Response.swift#L60-L66).

``` swift
func mapJSON() throws -> AnyObject {
    do {
        return try NSJSONSerialization.JSONObjectWithData(data, options: .AllowFragments)
    } catch {
        throw Error.Underlying(error as NSError)
    }
}
```

We would need to add a new parameter like `failsOnEmptyResponse: Bool = true`. If it's `false` and `data == nil`, we need to return some other value. An empty `NSArray` or `NSDictionary` might work, or maybe `NSNull()`. Not sure, open for discussion. 

Oh, and we should test it, too üòâ 
 @nickolayl Pull Request üòâ 
 Okay, re-opening for discussion. Does Alamofire have any similar issues? 
 The issues list is at https://github.com/Alamofire/Alamofire/issues I'm unavailable to help right now, try searching for the symptoms and see what others have experienced. 
 Had a quick look, but can't seem to find anything similar in the Alamofire issues.
 Since there hasn't been any activity on this thread for some time, I am going to go ahead and close it. Please re-open or create a new issue if you would like to discuss further. Thanks.  This topic was discussed in #298, but it was long time ago and was mostly for deprecation. And because we have many breaking changes and it is time for breaking, I think it is the best time to decide what to do with `RACSignal` extensions. We have many warnings in Moya about deprecation of methods that we should take care of:

> This will be removed when ReactiveCocoa 4 becomes final. Please visit https://github.com/Moya/Moya/issues/298 for more information.

Personally I think that the extension for `Moya.Error` with `.nsError` property could stay, because we have questions about the `.nsError` property once a few weeks. Other than that I want to know what other @Moya/contributors think! üêº 
 I'm üëç for getting rid of RAC 2 support, and I'm keen to remove the `nsError` property, since it just serves to erase the `MoyaError` type, and was only necessary for Objective-C interop.
 +100 for removing deprecated RAC support.
I'm also for removing `nsError`. We have good docs now and it is really duplicate of existing functionality.
 I'm okay with removing the `nsError` property as long as we document the error section, because this is really a common question here. 
 We already have updated docs: [ErrorTypes.md](https://github.com/Moya/Moya/blob/master/docs/Examples/ErrorTypes.md)
But I agree maybe it worth additional mention or link in Readme.
 I think we should remove the `nsError` property. After all, we're really coercing our already good errors into NSError for legacy support and dated patterns. I think keeping it just adds to the confusion and is what is leading people to ask about it.
 Okay, I think we came to the agreement that it should be thrown out from Moya. Is anyone from @Moya/contributors willing to PR these changes? It would include erasing deprecated methods only, if we decide to expand documentation on the `Error` matter, I think it should go into another PR anyways.
 Closing in favor of #508.
  Very strange, sorry to hear about this. Not sure what the issue could be. Usually, Xcode's error inspector will have a drop-down arrow beside the "does not conform to protocol" that says which function is missing, is it there? 
 Gotcha. Thanks for taking a look through ‚Äì I'm not experienced with Carthage either, so if you find anything, please let us know!
 Hmm, must be a consequence of our Carthage setup. Some background: Carthage doesn't support any sort of "subspec" style organization. Since we keep Moya and the RxSwift/ReactiveCocoa code in the same repo, Carthage downloads all three targets even if you don't use them. Because of the project organization, `TargetType` is re-defined in three different modules. The solution you have will work.

I'm surprised we haven't run into this before, I think we should add documentation around this. @mlvhub when you first ran into this problem, where did you look for an answer? We should add documentation there so others can find the answer easily.
 Yeah, last time we looked it involved splitting out into three repositories, which is a lot of work to keep in sync, etc. Let us know what you find, thanks!
 @mlvhub is this still causing problems for you, or is it safe to close the issue? 
  This should be possible, Moya's completion handler provides a `Response` object when a network call is successfully sent/returned (failure is for things like not being connected to the internet). The response object has a [`NSURLResponse?` property](https://github.com/Moya/Moya/blob/master/Source/Response.swift#L6) you can access to use a similar solution as in the StackOverflow answer. 
  Everything looks fine, hmm. Very strange. Can you try using the [network logging plugin](https://github.com/Moya/Moya/blob/38b0bda890b7b4598552a353b3f8db4248c37d6e/docs/Providers.md#plugins) to see what request is getting sent? 
 Gotcha, looks like your `baseURL` has the query string and everything included with it. Moya uses `NSURL` to add additional paths, and that must be confused by the `?sign=...`. I would recommend returning only `http://124.172.184.216:8080/open_api/api` from the baseURL and use the `endpointClosure` to add those additional parameters. [Here](https://github.com/Moya/Moya/blob/master/docs/Endpoints.md#from-target-to-endpoint-) are some examples.
 Yeah, that should work. Here's a project that does ObjectMapper and Moya work: https://github.com/ivanbruel/Moya-ObjectMapper
  Cool! Want to email me at ash@ashfurrow.com to schedule a time that works? 
 Cool, this looks awesome. I think we have the following TODOs to get this wrapped up:
- [ ] Add ReactiveCocoa extension for requesting.
- [ ] Add documentation for multipart requests.
- [ ] Add tests for new functionality.
- [ ] Changelog entry.

I'll try to take a look at this this weekend.
 Definitely good stuff in this PR - and I like @hirad's changes in his experimental branch, FWIW.
 I'm def happy to review this, I'm excited to (finally!) get uploads into Moya.  Please ping me (`@colinta`) when it's ready (and `@Moya/contributors`).
 ^ Looks like Swift-lint is running once per target, might want to have an option there
 @orta weird, we only run `bundle exec danger` in the post-test step, outside the Rakefile. 
 This is fantastic work and a great example of open source collaboration. Thanks everyone!

Wondering about the new property in the TargetType protocol: `var multipartBody: [MultipartFormData]? { get }`. Could we have a protocol extension that has a default implantation that returns nil? Or would that override the user's implementation?
 üíØ
 Tests pass, not sure why Danger failed but I'm gonna merge üíØ
 Thanks a lot for contributing to Moya! I've invited you to join the Moya GitHub organization ‚Äì no pressure to accept! If you'd like more information on what that means, check out our [contributor guidelines](https://github.com/Moya/contributors) and feel free to reach out with any questions.
  I am a newbie to Moya, and I knew that the Moya is the most populate repo that integrate Alamofire and ReactiveCocoa.

I have two question.
## question 1

``` swift
public enum GitHub {
    case Zen
    case UserProfile(String)
    case UserRepositories(String)
}
```

sometimes, I need pass multiple parameters for specific API. For example the UserProfile, I need pass two parameters String, Int. How can I do this?
## question 2

In the demo, the parameters and paths are mixed together in the GitHub, and this will cause the GitHubProvider more and more complex. 

``` swift
extension GitHub: TargetType {
    public var baseURL: NSURL { return NSURL(string: "https://api.github.com")! }
    public var path: String {
        switch self {
        case .Zen:
            return "/zen"
        case .UserProfile(let name):
            return "/users/\(name.URLEscapedString)"
        case .UserRepositories(let name):
            return "/users/\(name.URLEscapedString)/repos"
        }
    }
    public var method: Moya.Method {
        return .GET
    }
    public var parameters: [String: AnyObject]? {
        switch self {
        case .UserRepositories(_):
            return ["sort": "pushed"]
        default:
            return nil
        }
    }

    public var sampleData: NSData {
        switch self {
        case .Zen:
            return "Half measures are as bad as nothing at all.".dataUsingEncoding(NSUTF8StringEncoding)!
        case .UserProfile(let name):
            return "{\"login\": \"\(name)\", \"id\": 100}".dataUsingEncoding(NSUTF8StringEncoding)!
        case .UserRepositories(_):
            return "[{\"name\": \"Repo Name\"}]".dataUsingEncoding(NSUTF8StringEncoding)!
        }
    }
}
```

And I want to know that can I split the parameters or paths for each model, like the octokit.objc?
 For question 2, there's also a struct-based solution we added [here](https://github.com/Moya/Moya/pull/427), but haven't had time to document yet. 
 @holysin is this issue resolved to your satisfaction?
  This looks awesome! The ReactiveCocoa provider needs a similar extension to add this functionality, we can do that in another PR. I think we do need to write some tests for this feature, though, and ideally add some documentation and a changelog entry. I'm happy to do a screenhero to pair on that sometime next week, probably. 

@leonereveel this is fantastic work, well done. 
  Awesome, thanks!
 Thanks a lot for contributing to Moya! I've invited you to join the Moya GitHub organization ‚Äì no pressure to accept! If you'd like more information on what that means, check out our [contributor guidelines](https://github.com/Moya/contributors) and feel free to reach out with any questions.
  Super cool, this looks awesome! Could you add an entry to the top of the changelog? 
 Looks good! Weird that CI is failing, I'll take a look when I get a chance. 
 Restarted CI, it is green now.
PR looks good for me, great work!
 Thanks a lot for contributing to Moya! I've invited you to join the Moya GitHub organization ‚Äì no pressure to accept! If you'd like more information on what that means, check out our [contributor guidelines](https://github.com/Moya/contributors) and feel free to reach out with any questions.
  The `nsError` property was created for use with ReactiveCocoa. If you want to get at an underlying response, you can `switch` on the error in your completion closure, like:

``` swift
switch error {
  ...
  case .Underlying(let error as NSError):
  // now can access error.domain or whatever
}
```

It's a bit weird to have to case `error as NSError`, maybe the `.Underlying` case should use `NSError` instead of `ErrorType`. Any thoughts? 
 No problem! This seems like something we might want to document better, and maybe make the change to `.Underlying` I mentioned above. You wouldn't be interested in making a pull request, would you? 
 +1 for the change from `ErrorType` to `NSError`, also we could provide an example when we are at it.
 If we change `.Underlying` to have an `NSError` instead of `ErrorType`, then we won't need to cast, right? In any case, casting from ErrorType to NSError is guaranteed to always succeed, so it would be fine too.
 Ah, you're right. I misunderstood. 
  Thanks for PR!
Your fork is behind of upstream. How about rebasing it on top of latest `master`?
 Looks great! A few notes:
- Needs a changelog entry.
- Tests for the ReactiveCocoa provider are good, need corresponding tests for RxSwift, and ideally for just Moya itself. Maybe using the cancellation token?

I'm _really_ busy this week, hopefully others get the chance to review. Otherwise I'll try to look at it this weekend. Thanks!
 We've just merged #479, another breaking change (it's nice to group them all together). Now I'm thinking about other things we should break...
 Looks good! CI failure is intermittent and doesn't look related to the PR, merging!
 6.5.0 was released off a separate branch with a diverged history from master; it was necessary to rewind to before some breaking changes to get the `queue` specification included in a point release (instead of in our upcoming major release, which will include the changes in this PR). Does that make sense? 
 It ought to be ‚Äì is it not working as expected for you?
 Glad you figured it out üëç
 Just to make this clear, the tracking is implemented inside the `MoyaProvider`. The `RxMoyaProvider` and `ReactiveCocoaMoyaProvider` inherit from this base class and therefor inherit the inflight tracking functionality. 
  If you're able to use RxSwift or ReactiveCocoa, they have retry operators that make this easy. You can also see [an example](https://github.com/artsy/eidolon/blob/1c746f9a9c6420cda9f691468783fee67376e8b1/Kiosk/App/Networking/Networking.swift#L22-L31) of how to write try-when-network-is-available logic. 
  Hey @vishal91. üéâ Can you please provide the code where you described all of these? It will help us with helping you üòâ 
 At a first glance, it seems like your switches in `method` (and/or) `path` are not exhaustive, there are different number of cases. I'd try to add `default` to both of them and see what happens.
 First of all, add `default` case to each `switch` and let us know. This should solve your issue, no matter how many cases you actually have.

Then, you can add http headers in `endpointClosure`: https://github.com/Moya/Moya/blob/master/docs/Endpoints.md
 Usually this error comes with more details, hidden behind a "disclosure triangle" - there's no other detail related to this error?

> On Apr 28, 2016, at 6:39 AM, Vishal notifications@github.com wrote:
> 
> Added default to all the 'switch' . Same error.
> 
> ‚Äï
> You are receiving this because you are subscribed to this thread.
> Reply to this email directly or view it on GitHub
 Cool! Glad to help!
  Hmm, good question. Generally, parameter encoding doesn't work like that (as far as I know). You'd more typically see `ids` sent as an array, like `ids[]=41MnTivkwTO3UUJ8DrqEJJ&ids[]=6JWc4iAiJ9FjyK0B59ABb4&ids[]=6UXCm6bOO4gFlDQZV5yL37`, but I admit it's been a while. Let's see how we would do what you're looking for.

This is how I would accomplish this; add an associated value to the `Album` enum case that holds a `String` array of the ideas:

``` swift
case Albums(ids: [String])
```

Then, in the `parameters` implementation, do the following:

``` swift
var parameters: [String: AnyObject]? {
  switch self {
    ...
    case .Albums(let ids):
      return ["ids": (ids as NSArray).componentsJoinedByString(",")]
    ...
  }
}
```

And that should do it. Let us know how it goes!
 @Miasma87 This is an error with your swift code:

``` swift
case .getSeveralAlbums(let ids):  // remove ': [String]' from your code
```
 And it looks like you're in the wrong section - you should be modifying the `var parameters`, not the URL path.
 Sure you can - the list of ids is assigned to the enum as an associated value.

The `path` is not supposed to include the `?-` GET parameters.  They will be added to the URL _for_ you, when you return them from the `parameters` property.  Don't try to construct the entire URL yourself (like you might in JavaScript).

``` swift
enum API {
  case .Status
  case .Albums([String])
}

var parameters: [String: AnyObject]? {
  switch self {
  case .Status: return nil
  case .Albums(let ids):
    return ["ids": (ids as NSArray).componentsJoinedByString(",")]
  }
}
```
 @Miasma87 has this issue been addressed to your satisfaction? 
 @VivienGiraud glad you found out the issue! Also looking by code, if you are using Swift's Structs API for arrays (instead of `NSArray`), you don't have to cast it and you can just use `joinWithSeparator(_:)` (in Swift 2) or `joined(separator:)` (in Swift 3) method:

``` swift
["test", "test2"].joined(separator: ",")
```
  Yeah, basically you pass the plugins in init of your provider, the same as closures, manager etc. For example something like:

``` swift
MoyaProvider<GitHub>(plugins: [NetworkLoggerPlugin()])
```
 I've written a whitelist/blacklist logger plugin. It's not elegant (which is why it's not in Moya üòõ ) but it works: https://github.com/artsy/eidolon/blob/master/Kiosk/App/Networking/NetworkLogger.swift
 I can think of a few ways to accomplish what you're after.
1. Hard: Fork Moya and add NSURLRequest to the completion.  Then you'd have to maintain a fork, which is no fun.
2. Reasonable: Fork Moya and add a plugin method to line 210 `plugins.forEach { $0.didReceiveRequest(request, result: result, target: target) }`.  Again a fork, but such a subtle difference that this would probably be easier to maintain.  And the debugging would be off on its own, in a plugin, which is nice.
3. Easy: Just re-create the request in your response handler!  There's nothing special about the NSURLRequest instance, and it's easy to create a copy.

``` swift
provider.request(.Zen) { result in
  let request = Api.Zen.urlRequest
  ...
```

Better yet would be to wrap this in a networking layer, and then you can send the request back in a custom completion block:

``` swift
class Network {
  static let provider = MoyaProvider<MyService>()

  static func request(endpoint: MyService, completion: (NSURLRequest, Result) -> Void) {
    provider.request(endpoint) { result in completion(endpoint.urlRequest, result) }
  }
}
```
 You can now get `curl` commands logged using the included [network activity plugin](https://github.com/Moya/Moya/blob/645398713e41a0f61a36c57e707d5135f2fa8477/Source/Plugins/NetworkLoggerPlugin.swift#L17). 
 @nikita-leonov what do you think, has this issue been addressed to your satisfaction? If not, what are the next steps? 
 I'd be happy to review a PR, I'm not sure what request/response correlation would look like so I can't say for sure if it'd be accepted. Could you explain your implementation idea? 
 PR is merged! Are there any next steps on this issue? 
 Closing this for now, as it seems this has been resolved by merging the PR. Please reopen if there's anything else that needs discussing! :)  Awesome, thanks! üéâ 
 Hey there! Thanks a lot for contributing to Moya! I've invited you to join the Moya GitHub organization ‚Äì no pressure to accept! If you'd like more information on what that means, check out our [contributor guidelines](https://github.com/Moya/contributors) and feel free to reach out with any questions.
  Hmm, hard to say. I've not used Charles much, are you stubbing the requests? Could you post the Moya code that's not working? 
 I've used Charles w/ Moya a ton - but when we added SSL pinning, that causes Charles to stop working.
 @samirGuerdah Hey there! Did you get this working? 
  Nice!  Thanks for adding this to the README.  I took a quick glance at your adapter, and it looks very straightforward.  I think this is good to merge (and will, if no one else objects or beats me to it).
 Yeah, looks good! Thanks! üéâ
 Hey there! Thanks a lot for contributing to Moya! I've invited you to join the Moya GitHub organization ‚Äì no pressure to accept! If you'd like more information on what that means, check out our [contributor guidelines](https://github.com/Moya/contributors) and feel free to reach out with any questions.
  @bitomule what method did you end up using? 
 Okay to close this issue? 
 Do we know how/if Alamofire handles this? Moya's goal is to abstract away the actual network layer, so handling these types of responses seems like it's something we should take responsibility for. 
 Glad you got it working! Is there anywhere in Moya's documentation where some info about empty responses would have been helpful to you? I'm sure you're not the only one to run into this. 
 No problem, always feel free to open issues or send improvements to documentation. 
  Try this:

``` swift
public enum MyService {
    case Users(limit: Int?)
}

extension MyService: TargetType {
//...
    public var parameters: [String: AnyObject]? {
            switch self {
            case .Users(let limit):
                var params: [String : AnyObject] = [:]
                params["limit"] = limit
                return params
            default:
                return nil
            }
        }
//...
}
```

In this case `params["limit"] = nil` will be equal of removing object for key `limit`.
 Doesn't matter, method type is defined in separate property

``` swift
extension MyService: TargetType {
//...
    public var method: Moya.Method {
        switch self {
        case .EmailAuth:
            return .POST
        default:
            return .GET
        }
    }
//...
}
```
 What is your problem exactly? Check the samples above or check the [docs](https://github.com/Moya/Moya/blob/master/docs/Examples/OptionalParameters.md).
  @jimmy0251 the `parameters` `var` is the dictionary containing **ALL** parameters and their values.

In this case if you want to send an array as parameter; e.g. `[String]` or something along those lines you would need to pass it like this:

``` swift
var parameters: [String: AnyObject]? {
  switch self {
    case .ArrayParameter: return [ "parameterName": arrayObject ]
  }
}
```

That means that the parameter called `parameterName` will contain the `arrayObject`.

Let me know if that helps and if not we can dig it up until you got it up and running
 @esttorhe that sends a JSON dictionary of `{ "parameterName": ... }`, but what if you wanted to send a JSON _array_ instead? `[ ... ]` for example. I don't think that's currently possible in Moya without using a `.Custom` parameter encoding.
 @ashfurrow yeah I was working under the assumption that perhaps Jimmy wanted to send an array as a parameter.

If what he wants is send a JSON array then yeah I guess `.Custom` would be needed.

Maybe let's wait until he can clarify if he meant the array parameter or the parameters as an array üòÑ 
 Yeah, good thinking. JSON-arrays-as-data is a personal pet peeve ‚Äì I really wish API developers would stop doing it :disappointed: 
 Same here but maybe there's a really good and valid scenario for something like that (although I haven't found one just yet).
 Great solution @jimmy0251! Thanks a lot for sharing, I'm sure this will help others :bow: Do you consider the issue closed at this point, or do you think we should add your solution to our documentation, etc? Maybe something for #466.
 I got you covered, added this example to PR, commit authorship set to @jimmy0251:)
 In fact, it's how you should approach this, @vytis üêº More about it [here](https://github.com/Moya/Moya/blob/master/docs/Endpoints.md#from-target-to-endpoint-).
 @tdouglas1313 Hmm, it should be possible to do it the same way, using `endpointClosure`. Did you encounter any problems with that? If so, please open another issue targeting Swift 3.0 version :)
 Yeah, you can pass it as `JSONEncoding.default`, `URLEncoding.default` etc., instead of an enum case.
 No probs! Happy to help! üëä
  Hmm, this is a really good question ‚Äì this isn't a scenario we thought about when making the request closure asynchronous. I think it would make sense for Moya to provide a way for the request closure to produce an error ‚Äì this would be a new addition to Moya, and likely a breaking change. @Moya/contributors anyone have thoughts/feels about this?
 I think that's a smart move. Maybe make the parameter for `done()` be a `Result<NSURLRequest, ErrorType>`? It would be a breaking change, but we already have several of those merged in master, so now is an idea time to make this kind of change. Is anyone interested in sending a PR? 
 Sure! I can take a stab at that.
 Closing in favor of #488.
  Hey!
I don't see any errors in your code. Actually, I even copy-pasted and compiled it.
Can you give more details?
  For additional token fields you could use Endpoint settings, explained [here](https://github.com/Moya/Moya/blob/master/docs/Endpoints.md#from-target-to-endpoint-) (with auth token as well).
  Looks fine to me! Thanks for the contribution. 

I'm concerned that, as-is, this is a breaking change (if someone was subclassing the provider and overriding this method, the changing method signature would break thei override). Do you think, for now, we could introduce a second request function, instead of using the default value for a parameter?

A changelog entry and test would be awesome, but testing this might be tricky. We can merge without one and add it later. 
 I think using the same function is better, too, and I want to do that when we move to our next major release, but I don't want to break our [semantic versioning](http://semver.org) by breaking anyone's code.
 Good point @nuudles! üëè  What do you think about it @kokhong20? Is it okay with you? Also it would be probably the last point before we can merge this one I think.
 Looks cool, I'm fine with releasing this as a non-breaking change. Complicating things slightly is the fact that `master` currently _has_ non-breaking changes already. I'll take care of releasing this this weekend. What I'll probably do is go back to the most recently released commit, merge this in, make a release, then merge _that_ commit into master (closing this PR). That way everybody wins :tada:
 This has been released as Moya 6.5.0 and should be accessible from CocoaPods and Carthage. I've also had to manually merge into master, a few mew conflicts but nothing too serious. The merge commit is  https://github.com/Moya/Moya/commit/350bff8edbdb35007bdb8fd909aceef7d9d83d6b

@kokhong20 thank you for your contribution! I've invited you to join the Moya GitHub organization ‚Äì no pressure to accept! If you'd like more information on what that means, check out our [contributor guidelines](https://github.com/Moya/contributors) and feel free to reach out with any questions.
  Hey Shai!

I'm afraid there is no direct solution other than mapping response to have the top object that should be the array with objects. üò¢
 Sure! Here I have a method that gets a user by repository name. Let's say I give name **Moya/Moya**, it does the request [here](https://api.github.com/repos/Moya/Moya), and retrieves the **owner** object to parse it:

``` swift

func getUser(byRepoName name: String) -> Observable<User> {
    return self.provider
        .request(GitHub.Repo(fullName: name))
        .debug()
        .map { response -> Response in
            guard let responseDict = try? response.mapJSON(),
                owner: AnyObject = responseDict["owner"],
                newData = try? NSJSONSerialization.dataWithJSONObject(owner, options: NSJSONWritingOptions.PrettyPrinted) else {
                return response
            }

            let newResponse = Response(statusCode: response.statusCode, data: newData, response: response.response)
            return newResponse
        }
        .mapObject(User.self)
}
```

**Edit:** You could also use our extension for Argo, which @aschuch pointed out. üí™
 Sure! You can make your own mapper extensions for it:

``` swift
extension ObservableType where E == Response {

    func marvelMapArrayOptional<T: Mappable>(type: T.Type) -> Observable<[T]?> {
        return map { response -> Response in
            // your map
        }
        .mapArrayOptional(type)
    }
}
```

Just copy your map code above and you should be fine. And then you could use `marvelMapArrayOptional` instead of `mapArrayOptional`. You could also do a more generic method if you would like to do it for more methods like `mapObject` and so on.

``` swift
extension ObservableType where E == Response {

    private func marvelMapResponse() -> Observable<E> {
        return map { response -> Response in
            // your map
        }
    }

    func marvelMapArrayOptional<T: Mappable>(type: T.Type) -> Observable<[T]?> {
        return marvelMapResponse()
            .mapArrayOptional(type)
    }
}
```

 Hope it helps! üéâ
 Unfortunately we don't have a slack channel, but you could try asking on the RxSwift channel if it is more connected to RxSwift, or [on this slack](https://ios-developers.io) for ios-devs, they are all very helpful. Of course you could still ask the questions on here, no problem with that as well üéâ
 That is actually a question for [Mapper](https://github.com/lyft/mapper) rather than Moya itself, so please make an issue there. Other than that it would be really helpful if you could make new issues as the questions go, it will be then useful for other people if they need the answer as well (rather than scrolling). 

I think that we have resolved current issue, so I'm closing it for now. Thanks!
  With new pod owners, I want to document the automated release process.

@colinta @petester42 @sunshinejr @esttorhe Any questions?

Fixes #454.
 Not from my end; seems pretty straight forward 
 > /Users/travis/build/Moya/Moya/Demo/Pods/Nimble/Nimble/Adapters/NimbleXCTestHandler.swift:9:64: cannot convert value of type 'String' to expected argument type 'StaticString'

Haven't checked the `.travis.yml` but are we building against/using `Swift 2.2`?
Or the `Podfile` points to `Nimble` with `Swift 2.2` ?
 The CI failure? Trying to fix that here: https://github.com/Moya/Moya/pull/452
 ahhh; thanks @ashfurrow 
sorry for maybe bringing old stuff up; have been kind of away from the project due to a massive amount of work and trying to catch up on stuff

:grimacing: 
 No worries! April is really busy for me, and I wanted to make sure Moya would be OK if I wasn't available. 
  Good catch!
 Hey there! Thanks a lot for contributing to Moya! I've invited you to join the Moya GitHub organization ‚Äì no pressure to accept! If you'd like more information on what that means, check out our [contributor guidelines](https://github.com/Moya/contributors) and feel free to reach out with any questions.
  This was [fixed in 6.5.0](https://github.com/Moya/Moya/blob/master/Changelog.md#650), feel free to re-open if we can be of further help.
  Thank you for the PR! üéâ
 Hey there! Thanks a lot for contributing to Moya! I've invited you to join the Moya GitHub organization ‚Äì no pressure to accept! If you'd like more information on what that means, check out our [contributor guidelines](https://github.com/Moya/contributors) and feel free to reach out with any questions.
  Cool! And we just throw in our .netrc file creds? Super neat! 
  Currently, I'm the only one who deploys Moya releases. This sucks because I'm not always available to do it, and I don't want to be a bottleneck for anyone else. 

So, I'm looking for existing contributors who are willing and able to occasionally release a new Moya version. It's not a huge job at all, but I feel like it's a bigger responsibility than being a contributor, so there's absolutely no pressure to accept. @petester42 @colinta @esttorhe @aschuch anyone interested?

(I would need to add some documentation around _how_ to make a release as well.)
 I'm not at all opposed to helping out with this, would love to have someone else involved to "have my back" (look over the release, sanity check that it's good to go, etc).
 I could help as well if needed. 
 Awesome, I've added you three :tada: Thanks so much. I'll submit a doc about deploying this weekend. 
 It's basically just `rake release["X.Y.Z"]` and mostly everything else is automatic.
 interesting; github did not notify me of this

aaaaanyways; If you need more hands i'm down to help with this as well
  Fixes #451.
 @Moya/contributors does someone want to try continue work here? 
The last ~10 PRs were merged with a red CI status
 Should be good to merge now.
 Awesome work @ealeksandrov üëç 
  Cool! Looks good. CI is failing on master, so that's not your fault, and since you tested Carthage locally I trust it works :smile: I've opened #451 to fix CI separately.
 Just a note, I had previously sent an invitation to join the Moya organization ‚Äì no pressure at all! ‚Äì just wanted to make sure you had received it. 
 No worries, take care! And thanks again for the help on this :bow: 
  This looks similar to #445, could you try the solution from there? (Something about `carthage update --platform iOS --no-use-binaries` and deleting a folder.)
 Hmm, sounds like a different problem. Discussing here sounds fine. 

Afraid I'm not very knowledgeable about Carthage, looping in @Moya/contributors to get another set of eyes. I didn't see any related [issues](https://github.com/ReactiveX/RxSwift/issues) on RxSwift or [ReactiveCocoa](https://github.com/ReactiveCocoa/ReactiveCocoa/issues). What would help diagnose the problem would be the contents of your Cartfile. 
  Is there any recommended and simple way for **defining targets for RESTful APIs using Moya?** I think this is a common way of how APIs are laid out nowadays so I think it would be great if Moya was making this easily addable and maintainable.

Say for example I want to consume an API that defines RESTful APIs for articles and comments that support **create**, **show**, **update** and **destroy** methods (using Ruby on Rails naming conventions) then I would currently solve this by defining a Target in Moya similar to this:

``` Swift
enum MyService {
    case ArticleCreate(title: String, content: String, author_id: Int)
    case ArticleShow(id: Int)
    case ArticleUpdate(id: Int, title: String?, content: String?)
    case ArticleDestroy(id: Int)

    case CommentCreate(message: String, article_id: Int, author_id: Int)
    case CommentShow(id: Int)
    case CommentUpdate(id: Int, message: String)
    case CommentDestroy(id: Int)
}

extension MyService: TargetType {
    // ...
    var path: String {
        switch self {
        case .ArticleCreate:
            return "articles"
        case .ArticleShow(let id):
            return "articles/\(id)"
        case .ArticleUpdate(let id, _, _):
            return "articles/\(id)"
        case .ArticleDestroy(let id):
            return "articles/\(id)"
        case .CommentCreate:
            return "comments"
        case .CommentShow(let id):
            return "comments/\(id)"
        case .CommentUpdate(let id, _, _):
            return "comments/\(id)"
        case .CommentDestroy(let id):
            return "comments/\(id)"
        }
    }
    var method: Moya.Method {
        switch self {
        case .ArticleCreate, .CommentCreate:
            return .POST
        case .ArticleShow, .CommentShow:
            return .GET
        case .ArticleUpdate, .CommentUpdate:
            return .PATCH // or alternatively .PUT
        case .ArticleDestroy, .CommentDestroy:
            return .DELETE
        }
    }
    // ...    
}

```

I'm thinking of something where I **explicitly mark an API target to be RESTful** without changing the existing behavior (much). For example the above code could then look something like this:

``` Swift
enum MyService {
    case Article(ResourceType)
    case Comment(ResourceType)
}

extension MyService: TargetType {
    // ...
    var path: String {
        switch self {
        case .Article:
            return "articles"
        case .Comment:
            return "comments"
        }
    }
    var method: Moya.Method {
        switch self {
        case .Article(let resourceType):
            return resourceType.method
        case .Comment(let resourceType):
            return resourceType.method
        }
    }
    // ...    
}

```

where ResourceType could be defined somewhere within Moya similar to this:

``` Swift
enum ResourceType {
    case .Create(params: [String: AnyObject])
    case .Show(id: Int)
    case .Update(id: Int, params: [String: AnyObject])
    case .Delete(id: Int)

    var method: Moya.Method {
        switch self {
        case .Create:
            return .POST
        case .Show:
            return .GET
        case .Update:
            return .PATCH // or .PUT
        case .Destroy:
            return .DELETE
        }
    }
}
```

Usage would then be something like this:

``` Swift
let provider = MoyaProvider<MyService>()
provider.request(.Article(.Create(["title": "Example", "content": "Lorem ipsum", "author_id": 100])), completion: { result in
    // ...
})
```

Please take note that **the above solution example is for demoing purposes only** and should only serve as a starting point for further discussions. I have not put much thought into it and it has several flaws (for example the params can include anything which is not good).

But I hope the differences between the currently possible approach and the suggested approach express why this might be a great feature for a future Moya release. Given that most RESTful APIs have dozens of targets you can imagine how bloated the enum would look given the current approach.

What do you think? Do you have any ideas on how we could implement this? Are your requirements for RESTful APIs somewhat different? What would make writing RESTful APIs easier for you?
 @Dschee did you try MultiTarget maybe?  Super, thanks!
 Thanks a lot for contributing to Moya! I've invited you to join the Moya GitHub organization ‚Äì no pressure to accept! If you'd like more information on what that means, check out our [contributor guidelines](https://github.com/Moya/contributors) and feel free to reach out with any questions.
  This is a pretty serious issue, but I don't have sufficient Carthage experience to fix it. @Moya/contributors anyone have suggestions? 
  Thanks for the kind words! The fix for this would be to change the [DelayedStub](https://github.com/Moya/Moya/blob/84e02244b5d89971611f167bf25d629ce77b5a74/Source/Moya.swift#L192-L194) function to look like this:

``` swift
public final class func DelayedStub(seconds: NSTimeInterval) -> (Target -> Moya.StubBehavior) {
    return { _ in .Delayed(seconds: seconds) }
}
```

I'm strapped for time at the moment, if someone else has the time to make + test this change, that'd be :100: 
 I can do this right now.
 Moving conversation to #443 
  I also like this implementation!  Feels very "Moya-esque" :smile: 

The "Response-subclass w/ `progress` method is a good idea to me, too.

Thanks for tackling this one!
 @startupthekid I think it should be possible for us to utilize the `encodingCompletion` invocation to add `parameters` from the target. All I'm doing is taking the encoded request and immediately kicking it off.

Also, short-term, I've been encoding any of my parameters straight into my multipart request as different parts
 The only thing I don't like about mirroring the `Alamofire.ParameterEncoding` to a custom `Moya.ParameterEncoding` (rather than the typealias) is that we tie ourselves to `Alamofire` updates. As their `ParameterEncoding` changes, we have to update ours. I'd rather us be able to abstract it in `Moya` land, transforming it into `Alamofire` land.
 Closing in favor of #483 and f3f7570dcf875d2c95cae41397176c4577cfc555
  Hi @jasl ‚Äì thanks for the bug report. I'd like to ask you to rephrase your comment about carelessness, as it could be interpreted as an accusation; we aim to discuss bugs without calling anyone's abilities into question. Thanks for helping keep Moya a positive place :bow: 

Sounds like this is always reproducible? Like it's not intermittent? When you get a chance, could you post a code snippet or PR a failing unit test to demonstrate the bug? Thanks!
 No problem! Thanks for looking into this, I'm sure it'll help when someone else has this issue. If you have any suggestions for documentation improvements, please let us know :bow: 
 Cool! Could you open a new issue with suggestions or ‚Äì if you're comfortable ‚Äì a pull request with the changes? 
  Thanks Justin, let us know when this is ready for a final look over :+1: 
  This **improves the documentation** of the Examples.rd and Provider.rd files by adding **more details**, structuring by params (**clarity**) and being more explicit about Moyas **default behavior** and **minimum usage requirements**.

I did these changes after trying to use Moya for a project and got stuck with it after reading the documentation alone. Once I looked into the code all my questions got answered quickly ‚Äì but not everybody will do that. So I in this PR I try to be more explicit about the parts that confused me and try to provide **more detailed** and **practical examples**.

See also #432.
 This is fantastic, @Dschee, thank you for taking the time to improve our documentation! I've made a few inline suggestions above ‚Äì I'm happy to merge as-is and submit a PR with my feedback, none of these are blockers.

![](http://media.giphy.com/media/V2xbsCrxcLQSQ/giphy.gif)
 Thanks a lot for contributing to Moya! I've invited you to join the Moya GitHub organization ‚Äì no pressure to accept! If you'd like more information on what that means, check out our [contributor guidelines](https://github.com/Moya/contributors) and feel free to reach out with any questions.
  The problem looks like Moya vends its own [Error type](https://github.com/Moya/Moya/blob/4a834fcc96ed239d1f8da621c0ca4d16162d0a9d/Source/Error.swift#L3). It's an `ErrorType` so every cast to `NSError` will succeed, but I suspect the Swift compiler is getting confused. Try this:

``` swift
case .Failure(let error):
    let nsError = error as NSError
```

Let me know :+1: 
 Hey @lkuczborski! Thanks for reporting the issue! üéâ 

Although Moya's `Error` inherits from `ErrorType` and `NSError` also inherits from `ErrorType`, the cast from one to another is done by some bridging, because they aren't really connected other than the `ErrorType` protocol. So when you cast from `Moya.Error` to `NSError`, you get some really basic info and the associated type is gone. I'm guessing that the compiler is just confused, and it could be a bug, but I can't tell for sure. For now you can use `Moya.Error` property `nsError`. It might be removed in a future so you could copy the code and make your own extension instead.
 Glad we could help! ‚úåÔ∏è
  Hey! Thank you for reporting an issue!. üéâ

With your problem could you please provide what was the case and how you have repaired it? It might be useful for other people in the future ‚úåÔ∏è

And about Heimdller, I didn't really play with that, but what I can tell you is that Moya relies on Alamofire in its core. If you want to use Heimdller instead of Alamofire, you would need to create your own version of Moya and replace the Alamofire code in requests etc. But you can try using `endpointClosure` to add additional parameters based on Heimdller. There is an example [here](https://github.com/Moya/Moya/blob/master/docs/Endpoints.md#from-target-to-endpoint-), that adds auth token to your request. Hope it helps! üòâ
 I think we can close this one as well, if anything pops out, let us know @mrfarukturgut!
  Stubbed responses, for one (testing as a first-class consideration).

> On Mar 18, 2016, at 5:23 PM, G Edward Gonzalez notifications@github.com wrote:
> 
> Love the concept of Moya, just reading the docs and struggling to see the benefits of it compared to just using vanilla Alamofire with an enum that conforms to URLRequestConvertible: https://github.com/Alamofire/Alamofire#api-parameter-abstraction https://github.com/Alamofire/Alamofire#api-parameter-abstraction
> I like that Moya formalizes the pattern, as it does seem like a side thought in the Alamofire readme. But are there other intentions/benefits compared to it?
> 
> ‚Äî
> You are receiving this because you are subscribed to this thread.
> Reply to this email directly or view it on GitHub https://github.com/Moya/Moya/issues/435
 Yup, the main features of Moya are:
- Compile-time checking for correct API endpoint accesses.
- Lets you define a clear usage of different endpoints with associated enum values.
- Treats test stubs as first-class citizens so unit testing is super-easy.

But philosophically, Moya represents a framework that encourages developers to think about the network calls they want to make upfront, to encourage more thoughtful coding.

Let us know if we can clarify anything!
 ## I'd happily review a pull request üòâ

Ash Furrow
https://ashfurrow.com/ 
  If the `Endpoint` type isn't generic, users can build a non-generic provider that may be better-suited for their needs. 

Background:

Today, @jasl and I had a Skype call about #376 to discuss their fork of Moya that uses a far less generic-based approach: https://github.com/jasl/MoyaX There are some really cool ideas there, and I realized that by forcing `Endpoint` to be a generic restricts those ideas. There's no need for it to be generic, that I can think of.

Other ideas were a little more radical, and might not fit within Moya, but would make excellent library extensions. For example, the non-generic providers used in MoyaX help define more complex APIs involved in social network apps (other people have cited social network apps as a use case for using structs instead of enums, too).

Once we remove the generic `Endpoint` requirement, there are some other ideas we should consider borrowing from MoyaX:
- Make the backend (Alamofire) abstracted away so users can replace their own. This might be an interesting way to stub network calls instead, like having a "StubBackend" to stub requests. 
- I'm sure I missed some, @jasl please add the ones I missed.

This is a longer-term project, and Moya as it exists today is relatively stable. We need to be mindful about how we introduce changes like this to our existing users, and balance the trade-offs appropriately. 

Thanks again @jasl for your great ideas :cake:
 Going to close this and move discussion to #556. 
  ## Sounds reasonable to me ‚Äì it simply wasn't included because we didn't see a need for it. Clearly there is one :) Would you be able to submit a pull request? Adding a comment above the function and an entry into the changelog would be üíØ  

Ash Furrow
https://ashfurrow.com/ 
  We need more examples in our docs page. I'm thinking about making a Table of contents in our [Examples.md](https://github.com/Moya/Moya/blob/master/docs/Examples.md), where we could make few examples. One would be the easiest, the most basic setup with `.GET` request, then we could make another one with POST, another one with custom and specific examples of endpoints, stubs, and we could even add the setup with structs (vide #428). Also the **Examples** document feels like too much text at once, we could make something like description of _how_ you can setup Moya and _why_, and then the examples step by step. 

This is just an idea but we can brainstorm together ü§î

What are your thoughts? üéâ
 I like this idea, but I don't want the docs to get overwhelming. Maybe we should expand from a single `Examples.md` and do something more like "TargetExamples.md" etc? That way each document stays bite-sized.

Seems like a bit of a duplicate from https://github.com/Moya/Moya/issues/189 , what do you think? Might be worth having a milestone around documentation to gather all the ideas in one place. 

Probably related to #428 and #369 as well.
 First, milestone is a good choice, it would be much easier to read (also yeah, kinda a duplicate, sorry about that). About examples I agree that multiple files are a way to go, also we could have one file that will guide new user through examples, like in this file you can learn basic and the simplest usage, then here you have this and that because reasons. Or maybe do it in the main docs? Hmm ü§î
 I think this might be a good structure:

```
docs/
  Targets.md
  ... etc ...
  Examples/
    Readme.md
    TargetExamples.md
    ... etc ...
```

Then the readme in the new directory can be a guide to the other documents, like [what we have now](https://github.com/Moya/Moya/tree/master/docs).
 I _really_ like that one! üôå
 Thank you for your input, @Dschee ! üéâ 

Yeah, we know that our documentation has to be improved. We are working on it and every hint at what we could improve is a great help. While I understand the problem with the required implementation, I kinda don't think I understand the logging part. Could you explain what exactly do you have in mind?

Also if you have any other feedback about current docs, feel free to write it here. Thanks!‚úåÔ∏è
 What else is missing now that #438 is merged? 
 Close in favor of #466. 
  Hey there! This is fairly straightforward, but our docs aren't great. We need to improve them. In your [`TargetType`](https://github.com/Moya/Moya/blob/master/docs/Targets.md), use the `parameters` and `method` properties to return the JSON data and POST/PUT. Then, when setting up your provider, you can use a custom [`endpointsCosure`](https://github.com/Moya/Moya/blob/master/docs/Endpoints.md#from-target-to-endpoint-) to specify `.JSON` encoding for appropriate endpoints. 

Let me know if that helps, and if you have any suggestions for improving our docs. Thanks for the great question!
 Sounds complicated but not impossible. I haven't heard of an API requiring both an HTTP body _and_ query string parameters, usually it's one or the other.

Sounds like you need a custom parameter encoding. In my answer above I suggest using `.JSON`, but you'll need to use `.Custom` instead. We piggy-back on Alamofire's custom parameter encoding, so you should be able to follow [their docs](https://github.com/Alamofire/Alamofire#parameter-encoding) to create a custom param encoding to use in the `endpointsClosure`. 

To be honest this is outside my experience ‚Äì I'll try to help with an questions you have, just me know üëç
 @m00sey Thanks for sharing your solution! :bow: 
 Hey @retsohuang! We've updated our examples and [here](https://github.com/Moya/Moya/blob/master/docs/Examples/ArrayAsRootContainer.md) you can see it step by step. Hope it helps! If you have any questions/feedback about our examples, please let us know üêº Also, I think that this issue is resolved for now, so I'm closing it.
  Based off of work done in #427, refined from [this comment](https://github.com/Moya/Moya/pull/376#issuecomment-197149515). 

This removes the generic parameter for `StructTarget` and instead lets users create one with _any_ struct that conforms to the `TargetType`, so one provider can be used with many different struct targets. 
 Seems fine to me, @ashfurrow! üéâ I don't know, but maybe we could add the info about structs to Changelog with this PR?
 Good thinking :+1: 
  This is an alternative implementation of #408 (in lieu of #424).

Basically, Moya provides an `enum` type called `StructTarget` that has a single case, `.Struct` with an associated, generic value. That value is the "real" `TargetType`, the `struct` that our users would use. So instead of

``` swift
MoyaProvider<MyStructAPI>
```

You'd use

``` swift
MoyaProvider<StructTarget<MyStructAPI>>
```

Pros:
- Simple implementation
- No breaking changes

Cons:
- More verbose for developers using structs

Curious to know what you think!
 This is more in line with what _I_ had pictured - simple, more verbose, but doesn't introduce or rely on any new features.

I must give props to @sunshinejr for the cool use of reflection, but I would actually steer clear of that in a library like Moya.  Keep it simple, keep it explicit, let individual developers choose to implement something more interesting & complex.

But that's just my opinion! :smiley:
 ![d8c017582e3](https://cloud.githubusercontent.com/assets/498212/13791647/845e2b92-eac4-11e5-973e-a588592ca5a0.gif)
 Cool! I'll create an issue to update docs and demo app.
  While preparing for Structs API that potentially could be coming to Moya, we decided that the PR #424 was too large and, what is more important, it had breaking change that is extracted to this PR. 

In this PR we extracted from `MoyaProvider`:
- Defaults: `DefaultAlamofireManager`, `DefaultRequestMapping`, `DefaultEndpointMapping`
- Stubbing: `NeverStub`, `ImmediatelyStub`, `DelayedStub`

and moved them to the new class `MoyaDefaults`.

For more information you can take a look at description of #424. Thanks! üéâ
 Makes sense! We should double-check if documentation needs updating. 

So if I understand correctly, we'll hold off on merging this and take these changes _out_ of #424? Then:
1. Merge #424.
2. Release a patch for structs in Moya.
3. Merge this.
4. (Possibly wait for other breaking changes.)
5. Release a major version for this.

Does that sound right?
 So we basically _can't_ (at least not with the changes I proposed) introduce #424 without introducing `MoyaDefaults`. Normally it would go the way you suggested, but this time we kinda have to do it the other way around, which is:
1. Merge this.
2. Make sure everything is running correctly.
3. Merge #424 which is the StructsAPI on its own (without `MoyaDefaults` introduction).
4. (Possibly wait for other breaking changes.)
5. Release a major version for this.

If something is still unclear I'm happy to answer! üòâ
 Well no, we could remove the changes that reference `MoyaDefaults` from #424.  That's what I had intended by my comment.

You could either rebase #424, and remove the `MoyaDefaults` code, or create a new commit, and this PR _should_ override that change.
 Yeah I could rebase the #424 and delete the last commit which is `MoyaDefaults`. What I meant was that merging #424 before this one will also include the changes from here (or I don't really understand the idea).
 Right, I _think_ what @colinta means is that we can rebase #424 to remove any reference to `MoyaDefaults` so that we have two, totally independent pull requests. Then we can have a release between #424 and this one, so that people can adopt structs without adopting this (possibly breaking) change. Does that make sense?  
 Yeah, makes sense! But, I don't know if it possible. #424 relies on `MoyaDefaults`, because there was problems with type inferring üòî
 Those do happen >.< Could I ask you to take a look and see what problems they are? Maybe we can find a less-than-ideal, non-breaking change and move to this (which is a good idea) as soon as possible. Does that sound ok?
 Sure, will take a look üëÄ
 So, the problem with generics is that we have 2 options:
- we have TargetType as a MoyaProvider's Target,
- we have ServiceType which has 0..infinity TargetTypes

What leaves us with the case that our base protocol is ServiceType. Swift's generics seems to have a problem when an actual TargetType is passed:

<img src="http://i.imgur.com/LXpZEtI.png)" />

And we can "repair" it by specifying the TargetType explicitly. From:

``` swift
MoyaProvider<GitHub>(endpointClosure: MoyaProvider.DefaultEndpointMapping)
```

To:

``` swift
MoyaProvider<GitHub>(endpointClosure: MoyaProvider<GitHub>.DefaultEndpointMapping)
```

But it is still a breaking change. üòî
 Interesting! I guess I was thinking of https://github.com/Moya/Moya/pull/424 as having only _one_ struct-based enum type that Moya gives for developers to put their structs in (noted in [this](https://github.com/Moya/Moya/pull/424#discussion_r56069092) comment, sorry if I was unclear). Would that solution fix this problem, since we wouldn't need a ServiceType and could continue with the existing implementation? 

Thanks again for all your work on this, it's really great and we all really appreciate it!
 That would be most likely possible, but I don't know if it suits really #424 tho? Maybe we could leave #424 with the current implementation and create new one, which will only add new Demo project or new class that shows struct setup that is currently possible. Also, we agreed on a new Demo project, right? DemoStructs seems all right? Do we need some extra changes in old Demo? You got the documentation part, right?

And thank you, I really appreciate that I can contribute to the project I use the most. ‚ò∫Ô∏è 
 Yup, I've got documentation covered but we need to finalize the implementation first :smile: I don't know if a new demo project is necessary (beyond #189) if we can just add a side-by-side demo of using structs in the existing project, your call.

If we _can_ use the single-case-enum I mentioned in #424, maybe it's worth trying out a PR with just that idea? I can whip something quick together this afternoon, I'd like to hear your thoughts on it. Let me know :cake: 
 Yeah, go for it üéâ Adding it to the existing Demo is perfectly fine with me üëå
 I'm closing this one. This doesn't need to be introduced since we went with another option of structs API. 
 Makes sense :+1: 
  This is a great question, thanks! It's not something I've personally had an issue with, but I can totally see the concerns. 

So, the rationale behind this decision is to make sure that people _have_ to define sample date to make testing easier / encourage testing. There's no way to define a requirement _only_ in a test target, so this was our solution. 

But it's not ideal for everyone. An empty `NSData()` would do the trick, but what if you wanted to use this for testing? Empty `NSData()` wouldn't work then. In that case, I'd take the JSON out of the Xcode target (so they're not shipped with the app) and instead of using `NSBundle` to load the JSON, use some other way to reference the Xcode. FBSnapshotTestCase does this using either environment variables:

``` objc
[NSProcessInfo processInfo].environment[@"ENV_VAR_NAME"]
```

or by using `NSBundle`'s `resourcePath`:

``` objc
[[NSBundle bundleForClass:self.class].resourcePath stringByAppendingPathComponent:@"FolderWithJSON"]
```

That way the code is loading the files directly for disk and not through `NSBundle`. This won't work if you're running tests on the simulator, though, so that's one potential downside.

Let me know what you think ‚Äì I'd like to know what you think an optimum solution would look like, and how we could improve our documentation around this. Thanks again for opening the issue!
 This is a really interesting idea, I like it. It takes away from the goal of encouraging testing at all costs, but that may be discouraging some users from trying Moya. And I'm pretty sure they'll just return `NSData()` anyway :wink: 

This is a pretty big breaking change that would pair well with #426 when that gets merged. I think we should be careful about it; I'd like to get feedback from @Moya/contributors on the following idea:

Move `sampleData` out of the `TargetType` and into a closure passed to the provider that returns sample data based on its parameter, a target. This would complicate how we [handle structs](https://github.com/Moya/Moya/pull/424), though... We can also consider moving this behaviour into the `stubClosure`, like:

``` diff
-typealias StubClosure = TargetType -> Moya.StubBehavior
+typealias StubClosure = TargetType -> (Moya.StubBehavior, Response)
```

And we could even make this parameter optional, and `nil` implies "never stub", which would simplify the provider a bit. Just an idea, trying not to get ahead of myself :wink: 
 I like the idea of expanding `StubClosure` rather than passing it with provider as it is already big I would say (even tho we might not get any problems of the structs now as we'd chosen the simpler way of handling it). It also _feels right_ in `TargetType` (at least for me üòÜ).  
 Any more discussion/action items on this? Or can we safely close?
  As per issue #408, I'm sharing with you the solution I've come up with to the topic, which is structs in Moya. The general idea was a perfect start by @Matthijn followed up by a really good direction by @colinta 
## Motivation

We would like to keep existing enum setup and additionally support structs based setup for bigger projects or for any other reason. Specifically, what should be possible with this PR is that we can still use old configuration of enums and it won't break, but additionally we can use Moya with structs configuration, for instance:

``` swift
GitHubStructProvider.request(.UserProfile(UserProfileResource(name: name))) { result in

}
```
## Implementation

My idea was to create protocol that will be a default protocol for enum when using it with wrapped structs, I called it `ServiceType`. Then make `TargetType` conform to it protocol so we can reuse code for both implementations.
## Issues

There were few issues that occurred during the implementation. Changes I've made created some problems with generic's type inferring so I had to move Defaults (`DefaultEndpointMapping`, `DefaultRequestMapping`, `DefaultAlamofireManager` and stubbing defaults) to another non-generic class and I called it `MoyaDefaults`, which is a **breaking change** in case someone used them via `MoyaProvider.DefaultAlamofireManager` for instance. Couldn't find a way for not-creating another struct without many changes in code so if you have an idea I would love to hear it. 
## Demo

I've also added an example of usage to the current demo. As per our conversation I also believe we could move it to second demo. In short we can now define our struct like the one below:

``` swift
public enum GitHubStruct: ServiceType {
    case Zen(ZenResource)
    case UserProfile(UserProfileResource)
}

public struct ZenResource: TargetType {
    public let path = "/zen"
    public let baseURL = NSURL(string: "https://api.github.com")!
    public let method: Moya.Method = .GET
    public let parameters: [String: AnyObject]? = nil
    public let sampleData = "Half measures are as bad as nothing at all.".dataUsingEncoding(NSUTF8StringEncoding)!
}
```
## Conclusion

This is really a first step and we could improve it I believe, so I'm curious to hear what you think about it.

Cheers üéâ
 Going to close this in lieu of #427.
  Hi there! I want to clarify what you're asking for ‚Äì are you suggesting a change to Moya's behaviour? What change are you looking for? 

As far as I know, `subscribeOn` isn't typically used, because its the observation that matters and its the observation that has the side-effects (not the subscription). Does that make sense?
 I guess I must be confused about the issue then ‚Äì I was thinking Moya returns an Observable and the user can do whatever they like with it. Alamofire sends callbacks on the main thread, and we simply send them through.

To clarify, is the distinction one between Moya allowing users to specify a scheduler to observe/subscribe on versus requiring users to call `observeOn`/`scheduleOn` themselves?

In any case, I think keeping the observe/subscribe schedulers as the main thread scheduler _by default_ is the safest move, since users will often update UI elements based on the callback. Actually, I'm kind of curious why you would want the callbacks on a separate thread for all requests ‚Äì is it a performance issue? 

Let me know what you think ‚Äì thanks for taking the time to clarify for me, I want to make sure I understand the problem fully before we make any breaking code changes :wink: 
 > I just want to Moya does not change the thread which I choose when using subscribeOn and ObserveOn.

Right, that makes sense. I guess what I'm confused by is, as far as I know, Moya doesn't do that does it? If it does, can you specify where in the code it does?
 But that's how Rx is supposed to work, no? The elements (network response) are made always on the main thread. If you want to observe them on a background thread, you should use observeOn, not subscribeOn (which I pointed out is rarely used).
 I'm basing my assumptions of how `subscribeOn:` works off of [the RxSwift-specific documentation](https://github.com/ReactiveX/RxSwift/blob/83bac6db0cd4f7dd3e706afc6747bd5797ea16ff/RxSwift/Observables/Observable%2BConcurrency.swift#L42-L56), which says:

> Wraps the source sequence in order to run its subscription and unsubscription logic on the specified  scheduler. 
> 
> This operation is not commonly used.
> 
> This only performs the side-effects of subscription and unsubscription on the specified scheduler.     
> 
> In order to invoke observer callbacks on a `scheduler`, use `observeOn`.

Which sounds like it differs from the general Rx feel. I've contacted the RxSwift maintainers to ask for a clarification.
 OK, let's back up a little here. This quote:

> In case observeOn isn't explicitly specified, work will be performed on which ever thread/scheduler elements are generated

Has nothing to do with which scheduler Moya is called from, it _only_ has to do with Alamofire. Unless you specify which [scheduler](http://reactivex.io/documentation/scheduler.html), the work (map, flatMap, subscribeNext, etc) will be performed on whichever scheduler the elements are _generated_ on. Alamofire always generates these on the main thread, and Moya just passes them through, so they go on the main thread scheduler.

I think you're asking for the following: if a network request is made on a background thread, then its response should be delivered on that same background thread, but that's not how RxSwift works. RxSwift observables generate elements from whatever scheduler/thread that they want, and it's up to you to observe them on a separate scheduler with `observeOn:`, otherwise RxSwift conventions specify it's up to Moya, and Alamofire, to decide whichever thread/scheduler they want since they are the ones generating the elements.

I hope that makes sense. If it doesn't, I'm happy to schedule a call with you and talk this out.
 >  I‚Äôm a user of Moya, and I expect that its tasks would be performed in whatever scheduler I would set calling onSubscriber

But Moya _does_ do this, like any Rx Observable. Just because it omits things on the main thread scheduler doesn't mean you can't shunt those to another scheduler. I'd encourage you to re-read the RxSwift `observeOn` function documentation ‚Äì it's the method that you should be calling to put observables onto other schedulers.
 This is typical behaviour in Rx; it sounds like you're looking for Moya to emit events on the scheduler you call `request()` from, but that's not how Rx works. You _do_ have control over the observables scheduling but only from the outside, which is again very typical. If you want the events to be observed on another scheduler, you have to call `observeOn`.
 OK, so I think we've discussed this thoroughly and have to come a conclusion that the behaviour Moya is exhibiting is idiomatic to RxSwift, though may be unexpected in a thread-based context (as Junior said, Rx is thread-agnostic). I'm going to close the issue, but if anyone has follow-up, feel free to comment, re-open, or open a new issue :cake: 
 I think I understand the two sides of this idea:
1. The ability to use RxMoya without Alamofire dispatching to a different thread
2. The fact that ^ is the expected behavior for a majority of apps using (Rx)Moya, to load a network resource and then show it in the UI

I was wondering how to get closer to the first scenario - strictly as a client of this library, not to change the implementation inside RxMoya.

Is it as simple as calling `.observeOn(ABackgroundThreadForMoreProcessing.instance)` after my `.flatMap { provider.request(.zenResource) }`?
So something like

``` swift
provider.request(.networkResource) // called on whatever the current thread is
    .observeOn(ABackgroundThreadForMoreProcessing.instance) 
    .flatMap(persistToLocalStorage) // called on the thread associated with ABackgroundThreadForMoreProcessing
    .flatMap(expensiveConversionToMakePresentableToUI) // called on the thread associated with ABackgroundThreadForMoreProcessing
    .observeOn(MainScheduler.instance)
    .subscribe { /* bind the result to UI here */ } // called on the main thread
```
 Also, maybe it would be cool to expose https://github.com/Alamofire/Alamofire#response-handler-queue through RxMoya? That way, as a Rx user, if I explicitly say `.observeOn` a specific scheduler, we can pass the queue related to that scheduler to Alamofire?

EDIT: it looks like somebody had a similar question about doing the same with Alamofire https://github.com/Alamofire/Alamofire/issues/1147  (another use case that involved Rx) - may be worth adding an optional parameter to the provider that specifies which queue to run the responseHandler on üëÄ
 Hmm, interesting. To answer your question:

> Is it as simple as calling ...

Yup, I've done this and it's awesome how simple it is. I'm up for including this as an optional parameter, should it go on the provider subclass initializer or on the request method? 
 That is so awesome ‚ù§Ô∏è

I'll also go ahead and open a PR to track progress on the optional param.

My thoughts on where to put the param is definitely impacted by what I'm currently working on though: I'm moving an SDK (almost) completely onto a background thread, so **all** my requests are going to be moved onto a background thread, and I'm going to call `.observeOn(MainScheduler.instance)` after I've parsed and cached the data and to pass it to a client

It makes more sense to me as in the provider subclass - so I have consistent behavior across all my requests, but I can be convinced otherwise. What do you think?
 Makes sense to put it in the subclass/initializer üëç
 Created #762 üôÉ
  Yikes! Hmm, I want to make sure I understand the issue: could you post a code snippet that demonstrates what you're doing with `concat`? We can take a look at it ‚Äì likely an issue from immediately stubbing means that the signal sends synchronously? Not sure, definitely need to take a look. Thanks for opening the issue!
 OK, that is a _seriously_ cool idea :100: 

To clarify, what's your test code look like? What are you expecting to happen, and what specifically is happening instead? 
 I think I understand your use case, not sure of the cause yet ‚Äì I'll need more time to think about it. I'll try to get back to you as soon as possible.

In the meantime, you've got a workaround at lest :sweat_smile: Thanks again for filing the issue!
 Still not sure what's going on here, will try to take a look. 
 Since there hasn't been any activity on this thread for some time, I am going to go ahead and close it. Please re-open or create a new issue if you would like to discuss further. Thanks.  Hey! 

First of all, thanks for the time spent on resolving the issue! Helps a lot üôå I've made some small comments, but other than that we are good to go! 
 @tbaranes Thanks again for the changes! You did great job in finding that one and fixing it! üíØ When the build will pass I will merge it. Cheers! üéâ
 @ashfurrow We will need an invite for @tbaranes :beers: 
 Done üéâ 

@tbaranes no pressure to accept the invitation ‚Äì if you'd like more information on what that means, check out our [contributor guidelines](https://github.com/Moya/contributors) and feel free to reach out with any questions.
  Yikes! Looking through [the changes](https://github.com/Moya/Moya/compare/6.1.3...6.2.0), I don't see anything that immediately jumps out that would cause a slowdown like this... 

Could you describe your setup in more detail? Are you using CocoaPods or Carthage? I looked through Alamofire's recent issues and didn't see anything that might cause this either. 
 Thanks for the details. I'm travelling right now but will try to reproduce locally. In the mean time, if anyone from @Moya/contributors could lend a hand, that'd be awesome. This is a pretty serious problem and we should make input top priority. 
 @tbaranes Could you please try to clone the repo, then use the pod from the cloned repo (using the path in Podfile, like in Demo project) and go from commit with version 6.1.3. to the latest one? We could get the commit that produced the error and work with it. Other than that I don't see a reason for the behavior on the spot. :cry: 
 @tbaranes Perfect! üéâ I was trying to reproduce the long request on 6.2.0 but got nothing so far. Might be some edge case that you have on your environment. I will try again anyways üòá
 Hmm interesting, yikes. If this is still an issue, let's re-open so this stays on our radar. 
 @tbaranes I'm not sure I quite follow the remaining issues, could you clarify? Is this a case of not calling `closure(request)`? 
 OK, this sounds like a serious problem. I'll take a look this afternoon. From your description, it sounds like I should just be able to load the Demo app (hitting GitHub's API) and see reeeaaally slow responses, aye?
 Ah, I think I see! So this:

> I reproduce these case by setting an endpoint / resolver, but without doing nothing in (like in my above example).

You mean something like this?

``` swift
{ (endpoint: Endpoint<StructTarget>, done: NSURLRequest -> Void) in
    requestedURL = endpoint.URL
    // specifically _not_ calling done(endpoint.urlRequest)
}
```

So the problem is not calling `done`? Or is it when you _just_ call it, as in your example?

``` swift
{ (endpoint: Endpoint<GitHub>, done: NSURLRequest -> Void) in
    let request: NSMutableURLRequest = endpoint.urlRequest.mutableCopy() as! NSMutableURLRequest
    done(request)
}
```

I've tried it the second way, and I'm not seeing the slow network calls.
  Looks great, thanks!
 Thanks a lot for contributing to Moya! I've invited you to join the Moya GitHub organization ‚Äì no pressure to accept! If you'd like more information on what that means, check out our [contributor guidelines](https://github.com/Moya/contributors) and feel free to reach out with any questions.
  Hey!

It is because you are assigning tuple of parameters to the activity constant. It is now a tuple and when you have your variables named then you can access it like you have shown `activity.id` etc. If you didn't have them named, access to it would be like `activity.0`, `activity.1` etc. If you want to assign your parameters not to a tuple, but to a variables, just specify them in the parenthesis, like:

```
case PATCHApiActivitiesIdJson(let id, let nextParam, let nextNextParam):
      return "/api/activities/\(id)/"
```

Hope it is now clear :beers: 
 @onemanstartup If you specify _only_ one parameter (when you need to assign more than one) in enum's case, it will convert it to a tuple of parameters, otherwise it won't. So in your case, if you have e.g. 3 associated types, when you specify one, all parameters are converted into a tuple (because you need to catch all the values), and then passed to the variable. If you specify all parameters, it doesn't convert it to the tuple, that's why `id` in my case isn't a tuple, because we have all parameters already. I encourage you to try tuples in playground, really fun stuff (e.g. you can pass tuple as one argument, when you have function with 3 parameters needed! - really similar situation). 

Also, don't worry, swift is evolving all the time, no-one knows everything about it, learning is a key. Keep it up  üéâ
  Hey there! Thanks a lot for contributing to Moya! I've invited you to join the Moya GitHub organization ‚Äì no pressure to accept! If you'd like more information on what that means, check out our [contributor guidelines](https://github.com/Moya/contributors) and feel free to reach out with any questions.
 Ahh, we probably need to publish a new release that includes the changes. Will do shortly. 
 Cool, this has been released under [6.2.0](https://github.com/Moya/Moya/blob/master/Changelog.md#620). Let me know if that works :+1: 
  cool, thanks!
  Simple answer: you pretty much just need two providers _per app_. One to send actual requests, and one for stubbing (during tests). 

Using a "shared provider" (a global) makes sense, so that you can set it to the "actual" or "stubbing" instance as needed. 

You might create additional providers to provide more stub providers (delayed, immediate, errors), but I can't think of a reason to have more than one "real" provider. Anyone else?

> On Feb 24, 2016, at 4:56 PM, r√©mi Ô£ø notifications@github.com wrote:
> 
> Hi, I have few questions  about the Provider.
> 
> Is it only 1 Provider per endpoint, and then per request ?
> If I have several request to do in my controller, do I need several Provider ?
> I need for each request add or not a special header in the request, so I use the Provider block construction, but It will recreate my Provider each time.
> ü§î
> 
> ‚Äî
> Reply to this email directly or view it on GitHub.
 @colinta I use multiple providers because I have multiple endpoints I am calling (e.g. an auth service and a content service) so I like to have different named providers for readability (I also use different TargetType enums for each to stop them getting too complex)
 @remirobert you should be able to send as many requests on the same provider as you like. The bottleneck here (apart from the quality of the connection, type of request being made etc) is the underlying `NSURLSessionConfiguration`. It has a default value of 4 for `HTTPMaximumConnectionsPerHost` but you could initialise a provider with a custom configuration if you wanted to change that 
 Does that answer your questions @remirobert? üêº 
  Are you retaining the provider anywhere? I've seen 999 errors when whatever is making the request is deallocated
 @matteogazzato You just need to retain the provider. You can do it by e.g. setting the provider as a property for your controller. ‚úåÔ∏è
 @matteogazzato No problemo :beers: 
 That's right! If you don't have it in a property, it gets deallocated as soon as it leaves the scope.

## 

Ash Furrow
https://ashfurrow.com/  

On April 10, 2016 at 10:25:58 AM, philcai (notifications@github.com(mailto:notifications@github.com)) wrote:

> @remirobert(https://github.com/remirobert) What I don't understand is that Why should I keep a reference on it? If I don't, will the provider be released outside the scope(For example, I make the request in viewDidLoad, and don't keep a reference.)? I didn't inspect the implementation of Moya, it a little strange...
> 
> ‚Äî
> You are receiving this because you are subscribed to this thread.
> Reply to this email directly or view it on GitHub(https://github.com/Moya/Moya/issues/412#issuecomment-207993002)
 Agreed, hard to debug. Moya tries to make it hard to crash the app üòâ

## 

Ash Furrow
https://ashfurrow.com/  

On April 15, 2016 at 11:30:35 AM, nikos kanellopoulos (notifications@github.com(mailto:notifications@github.com)) wrote:

> @ashfurrow(https://github.com/ashfurrow) Shouldn't this crash however? It is very hard to trace these kind of bugs.
> 
> ‚Äî
> You are receiving this because you were mentioned.
> Reply to this email directly or view it on GitHub(https://github.com/Moya/Moya/issues/412#issuecomment-210507282)
 @tomj it would be _awesome_ if you could make a PR with how would you like to be informed about retaining the provider. üôå 
 Thanks! Looks like we need to update `Basic Usage` with similar note: https://github.com/Moya/Moya/commit/000662a026faf04953163f615663db7b44be6afe
  Awesome, thanks!!
 Hey there! Thanks a lot for contributing to Moya! I've invited you to join the Moya GitHub organization ‚Äì no pressure to accept! If you'd like more information on what that means, check out our [contributor guidelines](https://github.com/Moya/contributors) and feel free to reach out with any questions.
  Awesome, thanks! The CI failure on Travis was unrelated. 
 Thanks a lot for contributing to Moya! I've invited you to join the Moya GitHub organization ‚Äì no pressure to accept! If you'd like more information on what that means, check out our [contributor guidelines](https://github.com/Moya/contributors) and feel free to reach out with any questions.
  > So this is only a proposition since I don't know if there is much against using `ParameterEncoding` as a `typealias` compared to our own enum.

In this PR I tried to remove explicitly typed enum for `ParameterEncoding` that only is a bridge between us and `Alamofire`. I think that `public typealias` sounds fine (at least for me :bomb:) and I've made few changes. 

From positives, we can forget about PRs like #404 and upgrading our code everytime `Alamofire` adds something. What was left, however, was the equality operator in our unit testing. BUT! Thanks to [this stackoverflow answer](http://stackoverflow.com/a/34769898/2340462) we can forget (at least for now) about it. If there are some negative aspects, please let me now.

I'm really eager to hear from your guys! Thanks üéâ
 Interesting! I had not thought of just using a `typealias`! My only concern would be making sure that Moya users don't have to be aware of Alamofire, but the unit tests don't `import Alamofire`, so it _should_ be fine. Cool!

Anyone else see any issues? Otherwise, I'd just want to make sure we document the change in the changelog. 
 @ashfurrow Exactly my thoughts, was worried that user would have to import Alamofire, but it seems fine. This was just a suggestion, because I thought that there was a specific reason we didn't try typealias yet ü§ï So if we end up doing this, I will definitely write up the changelog + in my opinion we could remove the `AlamofireMoyaMappingSpec` test since this should be now done by the Alamofire itself. ü§ìüëå
 Okay I've updated the PR to prepare for merge üòá
 Awesome, thanks so much!!
  Hey, this is pretty cool! Thanks for the kind words, too. 

I'll have more time this weekend to look closer at it. I agree there are limitations in centralizing things, especially as APIs grow. I've broken things into multiple enums in a project, and [we've been talking about structs](https://github.com/Moya/Moya/pull/376) for a little bit. The use of the reflection API is really clever.

I'm not sure if we can "turn the ship" at this point (the structure of the enums is... pretty engrained into Moya), but I'd love to borrow some of the ideas from this. We should then consider linking to it from our docs, if you're interested in maintaining it as a separate project.
 Hey! Sorry I didn't get to this over the weekend :grimacing: Work is very busy right now and I'm preparing for a few conferences. 

@Moya/contributors Would anyone be free to take a look, give feedback, and open issues to discuss ideas we should consider adopting?
 Instead of removing `DefaultEndpointMapping`, you could makeit  easier to port by having that method accept the `baseURL`, and then return a closure:

``` diff
-public final class func DefaultEndpointMapping(target: Target) -> Endpoint<Target> {
-    let url = target.baseURL.URLByAppendingPathComponent(target.path).absoluteString
-    return Endpoint(URL: url, sampleResponseClosure: {.NetworkResponse(200, target.sampleData)}, method: target.method, parameters: target.parameters)
-}
+public final class func DefaultEndpointMapping(baseURL: NSURL) -> (target: Target) -> Endpoint<Target> {
+    return { target in
+        let url = baseURL.URLByAppendingPathComponent(target.path).absoluteString
+        return Endpoint(URL: url, sampleResponseClosure: {.NetworkResponse(200, target.sampleData)}, method: target.method, parameters: target.parameters)
+    }
+}
```

I like that your fork's changes are pretty small - but important question: does the current `enum`-based system still work?

I know you're critical of it, but... well, you're an army of ~2 at the moment.  As long as we stay compatible with using `enum`s to store the endpoints, I think this is great!  What I mean is: it's great to support _both_, but if we're just going to support one or the other, I vote that we stick with the `enum`.
 It looks neat! I also thought about structures, but I really like enums' type safety. I'll take a closer look today/tomorrow if we could use something from it @ashfurrow. Also, great job @Matthijn üí£
 I'm going to +1 this idea. I love Moya but while using it, one of my biggest frustrations was when working with/adding an endpoint... I would have to jump around these very large sections to get to the different parts of the enums. I think this is really great to have it all contained in a single place. 
 Interesting discussion. I'd prefer enums still for a couple of reasons:
- I like how enums give my endpoints structure (e.g. AuthTarget.SignIn and ContentTarget.LatestPosts)
- While the enum code has more boilerplate, it has less magic and so less of an understanding curve which is important to me in an open source library

That said I really like a couple of points in the structs (non generic providers especially) and would be interested in seeing how we could get some of them into Moya
 that's true, but it's more work for my use case which at the moment is a few different services with a few endpoints each (i.e. a micro services backend) 

i might be biased though, I do love swift enums :) 
 I agree this is really interesting, I just want to provide a word of caution about radically changing Moya, and a work of assurance to our existing users who might be worried about large breaking changes. 

I'm still unsure of the best approach to take here, but whatever we decide it will be done with careful consideration :+1: 
 Isn't it possible to just _wrap your struct_ in an enum value, and forward the `TargetType` calls to your struct?

``` swift
struct UserResource {
  let method: Moya.Method = .GET
  // ... and so on ...
}

enum API {
  case User(UserResource)

  var path: String {
    switch self {
      case let User(resource):  return res.path.resolve()
    }
  }
}
```

You could probably take this a step further:

``` swift
struct UserResource: Moya.TargetType {
 // ...
}

enum API {
  case Resource(Moya.TargetType)
}
```

This lets people who use enums (which is still _everyone_ at the moment) to continue without major refactors, but also lets you use your struct in the way you've proposed.
 @colinta that is _super_ cool. I think bringing that down deeper into Moya to have first-party support would be great, but at the very least that's a great solution _for now_ and we should probably document this idea :100: :100: :100: 

The first-party support could look something like a middleware between the Moya `Provider` type and `Target` type. Something that generates an `Endpoint` (which really _doesn't_ need to be a generic at all). I'm just spit-balling, but having a middle layer that lets users use either sounds like an ideal world. 

And I think it's worth noting that `enum`s _are_ a great solution ‚Äì that's why we used them in the first place. It just happens that they don't scale well. On the other hand, structs _do_ scale well, but spread domain knowledge of how an API works across several files (that's good for experts but can overwhelm beginners). Each approach has its advantages, so while an ideal world where either works is hard to imagine (and implement!) I think it may be worth striving for. 
 :+1: - last year [I mentioned](https://github.com/artsy/eigen/issues/324#issuecomment-87065971) that the current structure of Moya might not be able to handle our largest iOS project, with these ideas, it should be able to I think
 I think a face-to-face chat (over the internet) would be helpful here, to pin down: 
1. What we want.
2. How to implement it.
3. Who will implement it.
4. Migration requirements.

I've scheduled a poll here for Thursday, March 10th: http://doodle.com/poll/ef4kbz3h8zi3crmz Sorry it can't be earlier, but I'm travelling until then. The times there are in EST, so go ahead and let me know when we can help this public hangout.
 OK, going to have a hangout tomorrow at 2pm EST. I'll post a Google Hangout link here.
 I forgot to reply to the poll, but I'll be there! :-D
 OK, I've set up a hangout here: https://hangouts.google.com/hangouts/_/artsymail.com/moyahangout

Thought about recording it, but decided not to so people can speak freely. I'll summarize our discussion afterward and post here.
 Ok, here are the notes from the hangout:

We're going to continue using Moya's `enum`-first philosophy and @colinta's wrap-a-`struct`-in-an-`enum` solution. It has no breaking changes on the face value (more that shortly) and keeps with our existing philosophy (which I think would be unwise to change at this point).

@sunshinejr is going to send a PR with they're solution and we can discuss any technical problems and possible breaking changes there. @colinta has agreed to review the PR.

We also need documentation for what/why/how to do this, references _to_ that documentation added throughout our existing docs, and changes to Moya's documenting comments that reference the "Target enum." I can take care of the documentation, as well as adding a `struct` demo to our existing demo app.

How well or poorly an `enum` scales to handle an API is subjective; it varies from person to person, and even from endpoint to endpoint. It might make sense for a project to use both, for example. I like this technical approach because it maintains our current philosophy but provides flexibility for anyone who needs it.

@orta @colinta @sunshinejr Thanks again for taking the time to discuss this, and to @Matthijn and others who have brought up this idea. I must admit I was initially sceptical of this idea, but a working fork and this discussion have helped clarify the needs of Moya users. Thank you to everyone who participated :bow: 
 Thanks for continuing to encourage such a community-based project, @ashfurrow!  Looking forward to see where this goes.
 I think we've addressed this in #427, pending some documentation updates in #428 and #429. I'm going to close this issue, but if anyone has any further feedback, please feel free to comment where you think is appropriate; we can re-open this issue or open new ones, so don't be shy!
  So after seeing issue #403 and  [this](https://github.com/Moya/Moya/issues/403#issuecomment-182784469) piece of code, and especially:

``` swift
return endpoint.endpointByAddingParameterEncoding(.URL).endpointByAddingHTTPHeaderFields(["Content-Type":"application/x-www-form-urlencoded; charset=UTF-8"])
```

I decided to make a convenience method that we can call without chaining it. 
Please let me know if there is something I can improve. Thanks! üéâ
 Cool! I love this idea, and the implementation is :100: Good use of `nil` to represent a "missing value" :+1: 
  Hey! Thanks for the PR! üéâ

You are right, it returns `Optional` and we should change it, since it is compile-time error. Although in the Demo project [we actually use it a little bit differently](https://github.com/Moya/Moya/blob/master/Demo/Demo/GitHubAPI.swift#L21-L25). I think we should stick to one version and depending on which one we choose, make changes to Docs & Demo respectively.

**Edit:** Just choose one, update it accordingly and we gucci üôå
 Agreed, making it the same as the Demo project would probably be best I think (that's how I use it in production ¬Ø\_(„ÉÑ)_/¬Ø). Thanks @Legoless!
 Perfect! thanks again @Legoless  üéâ
  Hey! Thanks for the PR! üéâ
Although it seems fine to me, please add the test case for it. 
 Agreed, this is great, thank you :bow: Adding an entry to the changelog would be :100: and also a test (here's an [example](https://github.com/Moya/Moya/blob/7fb084e700b12e3f0fc577e3dd8853db78d7c623/Demo/Tests/AlamofireMoyaMappingSpec.swift#L21-L29) that you can build from). If you don't have time, don't worry! I can take care of it this weekend.
 Coo, thanks! There was a merge conflict from #406 so I merged manually.

Thanks a lot for contributing to Moya! I've invited you to join the Moya GitHub organization ‚Äì no pressure to accept! If you'd like more information on what that means, check out our [contributor guidelines](https://github.com/Moya/contributors) and feel free to reach out with any questions.
  Typically HTTP bodies come from parameters, looks like you have one that's specified in `JSON`. So to set the HTTP body to the json, you just need to tell Moya which parameter encoding to use. 

``` swift
var endpointClosure = { (target: MyCustomApi) -> Endpoint<MyCustomApi> in
    let endpoint: Endpoint<MyCustomApi> = Endpoint<MyCustomApi>(
        URL: url(target),
        sampleResponseClosure: {.NetworkResponse(200, target.sampleData)},
        method: target.method,
        parameters: target.parameters
    )
    switch target {
    case .Person(let json):
        return endpoint.endpointByAddingParameterEncoding(.JSON)
    default:
        return endpoint
    }
}
```

And that should work. You can check out the different options for parameter encoding [here](https://github.com/Moya/Moya/blob/aece4ebe3ad3cab946d8df93de4ee72c7024c8e7/Source/Moya%2BAlamofire.swift#L9).

Let me know if that helps :+1: 
 Also i'd like to add [this link](https://github.com/Moya/Moya/blob/23c4d506c5be9b94d9ecf16cb1f70893ad0b4f41/docs/Endpoints.md#request-mapping)
Hope it will be helpful 
 Yeah, good point! The request-mapping is later-stage stuff in the [pipeline](https://github.com/Moya/Moya/tree/master/docs#documentation), but it's there that I'll often play around with stuff I can't get working at higher levels. 
 That would URL encode it, which might be what you want, I'm not sure of your server setup. 

In general, yes, this is exactly how you customize attributes of requests, through the endpoints closure.
 I think we can close this one for now, if anything pops out, let us know! üêº
  This is useful when you just need the (possible) network response but don't care about the specific Error (see [this example](https://github.com/artsy/eidolon/pull/584/files#diff-ce82ff0f55f023dbcf5e8ab92d76c934R90) of usage).

It feels silly to have to write it, but it makes sense. May as well only write the silly code once :smile: 
 :+1: 
 Thanks!
  Caching would be handled by AlamoFire: https://github.com/Alamofire/Alamofire#caching (which in turn uses the system cache)

A cache is set at a system level by default but if you want to set specific sizes or handle it yourself, you can set your own cache:

``` swift
let URLCache = NSURLCache(memoryCapacity: 4 * 1024 * 1024, diskCapacity: 20 * 1024 * 1024, diskPath: nil)
NSURLCache.setSharedURLCache(URLCache)
```
 Moya itself has no concept of a cache so you don't need to apply the cache in Moya directly, you also don't need to set a cache for AlamoFire since it uses the system level cache. If you set the system level NSURLCache it will be used by both libraries (though it is already set by default)

There is a good description of NSURLCache here: http://nshipster.com/nsurlcache/

(you can also set a subclass of NSURLCache if you want more customisation)
 Great answer @wattson12 ‚Äì thanks for answering so quickly!
 I think that everything _should_ be clear now, so I'm gonna close it. üéâ If you have any more concerns, please let me now and I will reopen the issue!
  Hmm, tricky question ‚Äì you've got a lot going on here, and I want to make sure I understand your question first. 

Looks like you have a `Network` struct on top of Moya so that you can handle retrying? That's pretty cool, I've done a similar approach [here](https://github.com/artsy/eidolon/blob/24e36a69bbafb4ef6dbe4d98b575ceb4e1d8345f/Kiosk/App/Networking/Networking.swift#L22-L31). Then it looks like you're using ObjectMapper to parse the response data, right? Have you looked at [this library](https://github.com/ivanbruel/Moya-ObjectMapper), which has bindings for Moya and ObjectMapper? It should make it so you don't have to do this every time. 
 The problem with your layer is in this line:

``` swift
var a : T = try! response.mapObjectMapper()
```

Method used in the `Moya-ObjectMapper` bridge has kinda different declaration, without the `Mapper` suffix. I tested your code with change in the mapping part, specifically:

``` swift
var a: T = try! response.mapObject()
```

aaaand it works. So if this is your custom method, make sure you test it correctly or just use the method from bridge library. Hope that now you will resolve it!
 [This one](https://github.com/ivanbruel/Moya-ObjectMapper) that @ashfurrow was talking about. In README it has only `mapArray()` in examples, but [here](https://github.com/ivanbruel/Moya-ObjectMapper/blob/master/Source/Response%2BObjectMapper.swift) you can see that there are 2 methods, `mapObject()` and `mapArray()`.
  Was in need of ModelMapper bindings to Moya so why not include them here also.
 Fantastic, thanks!
 Thanks a lot for contributing to Moya! I've invited you to join the Moya GitHub organization ‚Äì no pressure to accept! If you'd like more information on what that means, check out our [contributor guidelines](https://github.com/Moya/contributors) and feel free to reach out with any questions.
  Only problematic part i see now ‚Äî only 4.0.0 RC2 is available at Pods Spec repo 
 Also probably we should bump Moya version since RC4 update but i'm not sure yet, so decided to delay that change
 Cool. This is only failing because the RAC podspec wasn't pushed until like an hour ago. I'm going to re-run CI. 
 :+1: 
 Cool, this has been released as 6.1.3 on CocoaPods and as a GitHub release.
  Can you make us a pull request?
 #396 possibly does this ¬Ø_(„ÉÑ)_/¬Ø  
 Nah, that's just Carthage. We need to update our podspec.
 Moya updated to use release version of RC4.
  This is a _fantastic_ pull request :tada: Unit tests look solid, commented code, all :100: 

I'm going to merge, then add an entry to the changelog on `master`. Our plugins are getting more complex, what are your thoughts on adding some documentation? Could be worth opening an issue to discuss...
 awesome, thanks

yeah i'd agree it was a bit difficult knowing how to extend the network logger plugin (and it felt like the style of extension I made will get messy eventually)
  I've not used the ReactiveCocoa extensions with Moya. @justinmakaila would you take a look when you get a chance? 
  We currently have a barebones network request/response logging plugin: https://github.com/Moya/Moya/blob/bd4f36bd958eaadd01d5266db61b8705d5e02447/Source/Plugins/NetworkLoggerPlugin.swift But it just dumped out the data (converted to `NSString` to the console). It'd be cool to have something that tries to convert it to JSON instead, so it's more readable. Maybe a new plugin, maybe an option to the existing one. 

See conversation at https://github.com/Moya/Moya/issues/391 for details and motivation.
 A pull request would be awesome! I'm not sure I quite understand this:

> even formatted strings are printed without formatting when printing as part of the array

But I trust you'll come up with a good solution :+1: 
 Huh! I'd have thought it would deal with that :disappointed: Oh well, thanks again!
 That might be the core part of the issue, perhaps it has to escape the array in order to be printed?
 Fixed in https://github.com/Moya/Moya/pull/394 
  Hmm, I see the problem: the "terminator" is really in the `print` sense, something the logger terminates its output with. The `\n` you're seeing is due to the nature of the logging: we take a response, take its data, and turn it into a raw string. When we do this, and we that string is printed, the `\n` characters get printed. 

I _think_ that's what's going on. What you're looking for, I think, is a plugin to log the response data formatted as JSON, right? I think that's a reasonable request ‚Äì we should consider creating a new plugin, or even just adding an option to our current one to accommodate this. 
 Good idea, I think that'd be a great idea for a feature. I'm not sure I have availability to work on it right now, though. We'll take a loot (I've opened #392 to develop it). 

As for whitelist/blacklist, I've run into this issue before, too. Here's my solution: https://github.com/artsy/eidolon/blob/32442b5099f2cd9e937a2c79eb0c94079646bd39/Kiosk/App/Networking/NetworkLogger.swift It might make sense for you to write your own logger in the short term until we have these features built into Moya. Let me know if can clarify anything!
 Yeah, Moya is not designed to give that level of granularity for plugins, the Target is as low-level as we want to go. 

For the RAC issue, could you open a new issue? There are examples of using it in the Demo project's unit tests in the mean time. 
 _I think_ we can close this one for now, if anything pops out, let us know! üêº 
 Hey @beretis, we heard something similar before. Can you check https://github.com/Moya/Moya/issues/739#issuecomment-257120482 and see if it fixes for you?

If not, please open a new issue :wink:
  What does it look like in ember-data?
 If you're using RxSwift or RAC, you can use `flatMap`. I don't know if this approach is common, but [I do this](https://github.com/artsy/eidolon/blob/24e36a69bbafb4ef6dbe4d98b575ceb4e1d8345f/Kiosk/Bid%20Fulfillment/BidderNetworkModel.swift#L29-L37). 
 I'm gonna close this one, if you have more questions about it @joedaniels29, please let us know! üêº 
  This is great, thanks!
 Thanks a lot for contributing to Moya! I've invited you to join the Moya GitHub organization ‚Äì no pressure to accept! If you'd like more information on what that means, check out our [contributor guidelines](https://github.com/Moya/contributors) and feel free to reach out with any questions.
  Hopefully this resolves #385. @yinanfang Does this clarify things?
 Cool, thanks! I think we need to apply this same fix in https://github.com/Moya/Moya/blob/master/docs/Providers.md and https://github.com/Moya/Moya/blob/master/docs/Examples.md too. 
 Ahh gotcha.  Will do.
 :bow: 
 @ashfurrow phew, went a little nuts on `Examples.md`: ab85328
 https://github.com/Moya/Moya/blob/ab853283d8463e53fe306ed2b52b623f9db88856/docs/Examples.md
 Looks amazing! üòª
  Fab, thanks!
 Hey there! Thanks a lot for contributing to Moya! I've invited you to join the Moya GitHub organization ‚Äì no pressure to accept! If you'd like more information on what that means, check out our [contributor guidelines](https://github.com/Moya/contributors) and feel free to reach out with any questions.
 Ah yes! I forgot to release, let me do that now. 
 Cooooool, this has been released as 6.1.2. Let me know if that works!
  Huh, good point. Would you mind submitting a pull request to fix it? 
 It should probably be cool to use `~> 2.0` - assuming @kzaher keeps to SemVer
 I think what @orta is saying is that by using `~> 2.0`, it'll take 2.anything which is what we want, right? You can continue to explicitly define versions (I think that's what "hard versioning" is?) and it'll work for you, and for everyone. Does that make sense?
 How so? I'd say that requiring 2.1.x is more aggressive than 2.x, isn't it? `~> 2.0` is the most flexible, right? Maybe I'm confused.
 In my opinion automatically receiving minor updates for dependencies is much better. 
I don't think RxSwift will break something during minor update. 
  Yikes! Yeah, our readme/documentation is out of date, sorry about that :disappointed: 

You can see a working example in the [Demo app](https://github.com/Moya/Moya/blob/a78b32e78c3db401c1038e3e819fca6105d9e830/Demo/Demo/ViewController.swift#L15). It's basically a Result type that's either success or failure. Let me know if I can clarify anything. 
 try/catch is much much more common in Swift ‚Äì it replaces Objectice-C's NSError model, actually. In this case, it's due to JSON parsing. 
 Attempting fix w/ PR #388.
 Thanks @colinta !
  Hmm, yeah. nothing pops into my head immediately. I agree that automating this somehow would be :100: 
 I think mapping responses to models is something that is quite far away from a networking abstraction library such as Moya. I do not see this kind of stuff directly within Moya.

That said, you could create an internal protocol `JSONMappable` that defines the `responseType` property and conforms to `TargetType`. Your API definition(s) may then conform to `JSONMappable`.

I've done something similar with [Argonaut](https://github.com/aschuch/Argonaut) but opted for an implementation where you can optionally parse the response to Argo model(s).
Something along the lines of

``` swift
Provider.request(.Profile)
    .filterSuccessfulStatusCodes()
    .mapJSON()
    .mapToType(User) // maps to a User model
```
 Ok, I guess you can do something like this.

``` swift
// Create your own protocol that extends `TargetType`
protocol JSONMappableTargetType: TargetType {
    var responseType: ALSwiftyJSONAble { get }
}

// Implement your Moya enum using `JSONMappableTargetType `
enum ExampleAPI:  JSONMappableTargetType {
    // Implement all TargetType properties

    var responseType: ALSwiftyJSONAble.Type {
        switch self {
        case .X:
            return GetResponse.self
        // etc.
    }
}


// Then add an additional request method
func requestType<T>(target: JSONMappableTargetType) -> SignalProducer<T, Error> {
    return request(target).mapObject(target.responseType)
}
```
 If this is wrapped up, I'm going to close it. Feel free to re-open if we can help further. 
  Great idea! Will wait for :green_apple: then merge and release. 
 Hey there! Thanks a lot for contributing to Moya! I've invited you to join the Moya GitHub organization ‚Äì no pressure to accept! If you'd like more information on what that means, check out our [contributor guidelines](https://github.com/Moya/contributors) and feel free to reach out with any questions.
 Fabo ‚Äì this has been released as 6.1.1, thanks! :tada: 
 I'm sure you will :bow: But no pressure to, we all have lives outside open source!
  Fab! Gonna merge without waiting for CI. 
 Thanks a lot for contributing to Moya! I've invited you to join the Moya GitHub organization ‚Äì no pressure to accept! If you'd like more information on what that means, check out our [contributor guidelines](https://github.com/Moya/contributors) and feel free to reach out with any questions.
  The built-in `DefaultAlamofireManager` as parameter's default value instead of the singleton `Alamofire.Manager.sharedinstance` is now used when instantiating `ReactiveCocoaMoyaProvider` and `RxMoyaProvider` as well. Fixes #373.
 Super, looks great!
 Cool, version 6.1.0 has been released with this fix. Thanks again! :tada: 
  I, for one, consider this behavior to be _correct_, because Moya is only responsible for sending and receiving, not interpreting, the requests and responses.

A "Failure" in this context is a total network failure: either couldn't send, or couldn't receive the request.

In the Ello app, we re-send failed requests.  When the response is a 4xx, we create an error object (based on JSON data that comes back) and pass _that_ to a failure closure, which displays the error to the user.
 The only response that we handle from inside our Provider is a `401 Unauthorized`, which triggers a request for a new token (and while that is in flight we queue up requests, then send them once the new token is in hand).  500s are plain-jane errors that we show to the user, in this case with a generic error message (if no JSON / error message is provided from the server, we have a fallback error message)
 @marchinram: Is it possible to use a plugin? That would be awesome!

Both @colinta and I are using static functions after we see errors, that parse the JSON in an presentable error model. @colinta's code is actually open source, his function is called `generateElloError` https://github.com/ello/ello-ios/search?utf8=‚úì&q=generateElloError
  Makes sense to me. If CI passes we can merge, then make a small release. Thanks!
 Looks like no one has released an RC 2 podspec yet. I think https://github.com/mhuusko5/Podspecs is the canonical location to update them, since the ReactiveCocoa folks decline to maintain the podspec themselves. 
 I've hit the "Rebuild" button on Travis now that the RC 2 podspec is on trunk. Thanks @aloco :100: 
 Thanks a lot for contributing to Moya! I've invited you to join the Moya GitHub organization ‚Äì no pressure to accept! If you'd like more information on what that means, check out our [contributor guidelines](https://github.com/Moya/contributors) and feel free to reach out with any questions.
 OK, should be good to go on 6.0.1 :+1: 
  While I really like a lot of what I see here, I see that not only does this refactor the Provider code (and adding the Backend looks like a good idea), it also reverts the StubClosure back to the StubBehavior.

In short, I think there are too many breaking changes to have this considered as just a refactor - merging this would require a huge usage change on top of the mindshift.

I would rather see this broken into 2 or 3 PRs: One to just introduce the `MoyaBackend`, another to discuss reverting `StubClosure` to `StubBehavior`, and a third to move `Moya.swift` code into `Provider.swift`.  Does any one else feel like this PR is just _too huge_ to get merged in?
 Aye, @colinta I encouraged @jasl in https://github.com/Moya/Moya/issues/358 to open a PR to discuss some of the changes. I'll have time hopefully to look it over tomorrow!
 Yup, to be clear, I really _like_ the parts related to making the provider non-generic.  My worry is that the other changes introduced here will make it hard to keep the discussion focused on just that one thing.  Thanks for being open, though, and I look forward to seeing where this goes!
 @jasl Yeah, sometimes we want to stub immediately and sometimes we want a delay. Always in unit tests, of course. 
 Could be a use-case for an `enum`:

``` swift
struct StubBehavior {
    case .NoStubbing
    case .ImmediateStubbing
    case .CustomStubbing(closure: T -> Int)
}
```

Or something like that. I don't feel like the overhead of the current usage is bad at all, not sure how much extra utility we'd get changing the stub parameters (again lol) given everyone would have to update their code.
 So yeah, lots of interesting ideas in here, some I like and some I don't. I'm not sure I'm the best arbiter of what should/shouldn't be considered though ‚Äì Moya is too close to me and I don't think I can be impartial.

@Moya/contributors If you have time, taking a look through this PR and grabbing ideas to consider would be :100: Thanks again @jasl ‚Äì I think from this PR we can break out into smaller issues to consider the pros and cons of each idea individually. Does that make sense?
 Actually, I take back my comment about always stubbing in unit tests :speak_no_evil: [Eidolon](https://github.com/artsy/eidolon) uses stubbed responses for an offline mode available to OSS developers who don't have access to our API, as well as Artsy developers when they're offline. It's often useful for development, though I agree in _production_ it does seem weird. 
 Taking another stab at analyzing this, but again it's tricky because there are _many_ ideas all getting thrown into one PR.  I would still love to see this broken out into 3 (or more!) PRs.  So far, I've identified these changes:
1. Refactor Endpoint so that it doesn't neet `<Target>`.
   - This was the original goal, wasn't it?  And it looks like this would be a straightforward change.
2. Adding MoyaBackend - this looks like a nice way to separate the "real vs stubbed" response behavior.
   - Adds `Source/Backend.swift`, and refactors `Source/Moya.swift`
   - btw, looks like `MoyaProviderStubBackend` doesn't use or need the `manager` instance
3. Revert `StubClosure` to `StubBehavior`.  The most important reason, I think, for the `StubClosure` is because the `stubbedData` needs to be called lazily.  If this can be accomplished with `StubBehavior`, I think I'd be fine with it.
 ###### Some more questions
- What does `MoyaCommonProvider` do? I don't see this class used anywhere, but it is defined in `Provider.swift`.
- `DefaultCommonEndpointMapping` and `DefaultEndpointMapping` do the same thing, can this be simplified to just having `DefaultEndpointMapping`?
- `toNSMutableURLRequest` is only used to calculate a hash value (`public var hashValue: Int { return self.toNSMutableURLRequest().hash`), why not use `self.urlRequest` there?
- I see that `CancellableToken` has been made public, but I think it can remain private if you change the return type to `Cancellable` in `MoyaProviderBackend`

###### Most importantly

I labeled this `enhancement`, but then that begged the question: _what_ is being enhanced here?  I see a lot of changes (too many in my opinion, to be very honest), but I can't point at any one thing that is greatly _improved_ by these changes. @jasl what is the most important feature that is being added?  @ashfurrow what do you see as the best ideas here?
 Hi again @jasl, we've created a first-party approach in #427 that I think might work. Does that satisfy your needs? 
 Ah, I see. So you're looking to use _any_ struct that conforms to the `TargetType`, not just a specific one. That makes sense. I've opened https://github.com/Moya/Moya/pull/430 to try and fix that. Would love your feedback :cake: 

We need to balance the needs of different users, and while I understand wrapping the struct in an enum like this may not be the best approach from everyone's perspective, we've had to make compromises. I've been working with other maintainers for weeks on this issue and I feel like this is the best approach. If you like, I'd be happy to have a Skype call and chat about it, and hear more about your ideas to make Moya even better. Thanks again for the PR :bow: 
 Don't worry about renaming at all, it's open source because we want people to experiment however they like! I'll add you on Skype and see when you're free.
 After chatting with @jasl today, I've moved their feedback into #434 to discuss point-by-point. We'll borrow the ideas we can and bring them into Moya one-at-a-time, so I'm going to close this PR. However, that doesn't mean we should stop discussing the ideas. There are some really neat ones here, and I've asked in #434 that we list specific ideas to bring over, so please continue the conversation there :bow:
  Hi! Just to be sure, do you have Run Script which fixes well-known issue with frameworks? 
It's on 4th step [here](https://github.com/Carthage/Carthage#if-youre-building-for-ios-tvos-or-watchos)
 So you have Moya & Result & Alamofire added to project and all of them specified in script? 
I remember i had issue after Moya update when i forgot to add Result.framework too

Probably if all is set up properly it would be good to share some sample proj which reproduces issue?
  Hey there! Thanks a lot for contributing to Moya! I've invited you to join the Moya GitHub organization ‚Äì no pressure to accept! If you'd like more information on what that means, check out our [contributor guidelines](https://github.com/Moya/contributors) and feel free to reach out with any questions.
  Hmm, hard to say what's happening without more code. The underlying error isn't too descriptive in this case. 

Have you made any recent changes? Upgraded the library? Can you double-check the base URL?
 Oh, forgot to say: sorry about this! We try to have descriptive errors. Thanks for opening the issue, we'll do our best to figure out what's going on :+1: \
 Well! Glad to hear it's working :smile: It must've been a network issue, since an error like that indicates that there is no response (otherwise, you'd get a status code and stuff). 
 Hey there! Sorry you're having a problem ‚Äì not sure which version of Moya you're using, but an error code of 5 suggests that you can access the underlying error. Check the source code out here: https://github.com/Moya/Moya/blob/master/Source/Error.swift
 That's strange, RxSwift should already be using the new error-handling. You can use the Swift `case` syntax to unwrap the enum and the underlying data: https://github.com/artsy/eidolon/blob/24e36a69bbafb4ef6dbe4d98b575ceb4e1d8345f/Kiosk/Bid%20Fulfillment/PlaceBidNetworkModel.swift#L49
 Just to chime in here, what I think @aleufms understood was that he could use the `nsError` property of the [Error](https://github.com/Moya/Moya/blob/master/Source/Error.swift). If it is true, yes this is deprecated as of now, but the discussion about it is still going on in #489. 

Additionally, in your case you could just get the `.Underlying(let error)` case from the response error, as @ashfurrow mentioned. Having in mind your response error has a name `responseError`, you can get it as following:

``` swift
if case .Underlying(let error) = responseError {
    // Now you can use error property as an object of NSError
}
```

Hope it helps! 
 With @sunshinejr's comment, I think this is closed. Please re-open if not.
  Hmm, good question. Based on the current architecture, the plugins are only notified about the response (they're more meant for dealing with requests, not responses). For ObjectMapper, have you taken a look at this library? https://github.com/ivanbruel/Moya-ObjectMapper
 Yeah, I understand that perspective. But I'm not sure that level of extensibility is right for Moya's level of abstraction. 

What you're describing sounds like it might go well with the reactive approach, which [I've used here](https://github.com/artsy/eidolon/blob/32442b5099f2cd9e937a2c79eb0c94079646bd39/Kiosk/Bid%20Fulfillment/BidCheckingNetworkModel.swift#L124-L128). Happy to clarify anything. 
 Cool cool ‚Äì let us know if you have any other questions or if we can clarify anything else :+1: 
  Hey there! Sorry you're having trouble. It looks like you're just customizing the endpoint mapping, right? If that's the case, you don't have to subclass the provider at all, you can just pass in the closure when you create the provider. Subclassing the provider is generally only needed when you have to change the behaviour of the `request` method. For example, [waiting until there is internet](https://github.com/artsy/eidolon/blob/04a0c8488525be4b918e212e92a29f143e0f5838/Kiosk/App/Networking/Networking.swift#L22-L31) before sending the request.
 Definitely ‚Äì we need more examples for sure, and are tracking ideas here: https://github.com/Moya/Moya/issues/189 Let me know if there's anything else I can clarify :smile_cat: 
 I think we can close this one, if you have any ideas for our new [Examples docs](doc/Examples), please let us know! üêº 
  I hit an issue (#367) when attempting to use Moya's `Response` type in my code. When used from outside the module, it's easy to end up in ambiguous states where the compiler can't tell if you want Alamofire's `Response` or ours.

Since Alamofire is a dependency, should we consider prefixing or renaming `Response` to avoid this potential confusion? The fix is admittedly simple once you realize what's going on (referring to the type as e.g. `Moya.Response`), but may not be obvious to people who haven't encountered it before.
 I'm not sure I have a strong opinion either way, just wanted to open the table for discussion.
 Definitely, thanks for opening the issue @tomburns. 

This question is bigger than just Moya and something the entire Swift OSS community will need to answer. I don't have strong opinions, either. Maybe this is the new norm and we just need time to get used to it. Of course, lots of people said the same thing when _The Phantom Menace_ was released and look how that turned out.

Does the compiler error present when only importing `Moya`'s module, or when you link with Alamofire at all?

In any event, documentation and sample code should be updated to reflect the fact that using Moya's `Response` type requires namespacing it with `Moya.Response`.

/cc @Moya/contributors 
 This has been discussed previously. I think what is currently implemented is the standard swift way. You can always alias if you want to use something else right?
 @gregpardo Certainly, and perhaps the real issue here is that the Xcode error when you encounter this sort of ambiguity doesn't volunteer the more specific types as a FIXME. As I said, I wasn't sure any action was necessary here, but figured it couldn't hurt to make sure we had consensus either way :)

Thanks for the discussion!
 I think we can close this one, but if there is something to add to the discussion, please let us know! üêº 
  Thanks @aamctustwo ‚Äì much appreciated :bow:
  Yikes! I'll take a closer look later, but when I encountered problems upgrading eidolon to Moya 6, most problems were solved by being more explicit about closure parameter/return types. You can check out our existing inplementation, too. 
 I'm having the same problem. I thought it was a derived data issue or something like that but nothing I could do was working. When I removed my plugins it would compile but none of the autocomplete was working and it was seeming to happen with other pods to. It was driving me a little crazy glad I'm not the only one. 
 Update for me. I was also getting a casting to objc bridge error on my plugins array. Which is odd because I wasn't doing any objc. 

``` swift
let plugins = [somePlugin]
```

Now works as

``` swift
let plugins:[PluginType] = [somePlugin]
```

Not sure if this is a related issue but was a similar obscure result. I'm guessing you have to be explicit in such a case because the compiler shouldn't assume you don't want to add other types of objects to the array later.
 Ah, sounds like trouble :) Is this issue good to be closed? 
 It may be more of a swift 2 lint/compile error than anything else. Just seems like sometimes the errors are really unrelated to what is actually going on.
 Hey, don't worry about it! Issues are the perfect spot for questions like this. I guarantee other Swift developers are getting similar errors, and if we debug problems like this in the open, then they won't have to fix it by themselves next time :wink: 
  Figured it'd be easier to merge and have another PR for such minor issues ¬Ø\_(„ÉÑ)_/¬Ø
 :+1: 
  Yeah, Moya 5.3.0 uses RxSwift 2, which changed `just` to be a static function on `Observable`. This means `just(whatever)` became `Observable.just(whatever)` (or `.just(whatever)`). Running `pod update Moya` should fix this :+1: 
  Looks awesome, thanks! üéâ
 I've invited you to the Moya contributors list ‚Äì no pressure to accept! If you're curious about what being a contributor means, [check out the docs](https://github.com/Moya/contributors).
  Thanks for the kind words! I'm not entirely sure what the identity is, but I've only used Moya for OAuth/XApp/Basic HTTP authentication methods. As you noted, [the request closure](https://github.com/Moya/Moya/blob/master/docs/Authentication.md#oauth) is where I would think this would go, but it's clearly a no-go if you need only _some_ endpoints to be authenticated.

A Plugin could work. We [have a basic auth one](https://github.com/Moya/Moya/blob/master/Source/Plugins/CredentialsPlugin.swift) but it [has some issues right now](https://github.com/Moya/Moya/issues/326). I've done something [here](https://github.com/artsy/eidolon/blob/cb31168fa29dcc7815fd4a2e30e7c000bd1820ce/Kiosk/App/Networking/XAppAuthentication.swift#L8) that might work, but that approach relies on RxSwift/RAC.

A sort of hacky way to do this (for now, until we have a better answer) is to use the `requestClosure` and check against the Endpoint's URL or something. It's not great, but it would work. 

This seems like a common-enough problem that we should a) fix #326 and add documentation on how to do general-purpose authentication plugins.
 Ah, I see. Good point. I'm not sure if the best way to approach this ‚Äì the existing examples focus on authentication outside of Moya _or_ authentication at the Target level in the endpoints closure. 

@Moya/contributors any suggestions here? 
 Any further discussion on this? 
 Going to close this issue, but I'll note that there's a demo of a re-authentication plugin in this issue that's worth checking out: https://github.com/Moya/Moya/issues/744 Thanks again for opening @Skornos!
  Hmm, good question! I think the filtering idea you have could work, but it's not ideal. Like, Moya should handle this somehow. Let me think about it, maybe someone else has a better idea. In the meantime, filtering is your best bet. 
 Ah, that makes sense! We should add that as an example to our documentation. Would you like to send a pull request? :wink:
 Cool, thanks! Take your time, no rush! :christmas_tree: 
 With a separated out TargetType for each endpoint I take this approach:

``` swift
var parameters: [String: AnyObject]? {
    let optionalParameters: [String: AnyObject?] = ["value": nonOptionalValue, "optionalValue": optionalValue]
    return optionalParameters.mapMaybe { $0 }
}
```

where mapMaybe is to take a [String: AnyObject?] to [String: AnyObject]

As from Swiftz:

``` swift
func mapMaybe<Value2>(f : Value -> Value2?) -> [Key : Value2]
```
 Interesting discussion! I hadn't considered making the provider non-optional, since the original Moya was heavily configuration-based (where now you can create a provider with sensible defaults by passing in no initializer parameters at all).

I can see both sides to this. On the one hand, having a shared provider for all networking (multiple target types) would be convenient. OTOH, custom behaviour around specific cases of the enum (or whatever) is really hard without generics ([see this example](https://github.com/Moya/Moya/blob/master/docs/Endpoints.md#from-target-to-endpoint-)).

I'd be comfortable moving away from generics if there is a compelling reason and if we can keep the existing philosophy and customizability intact. That second part is a big question mark right now, and it may be outside the scope of optional parameters ‚Äì maybe it's time to make a new issue?

It's also worth noting that for a large number of endpoints, something like a generated-enum may work, which has [been an open issue for some time](https://github.com/Moya/Moya/issues/73).
 Yeah, that _compiles_ but as I tried to describe in my earlier comment, it betrays the philosophy of Moya. Conditionally casting a parameter to a specific enum (or one of several enums, to expand to many) is... icky. 

At a higher level, we're discussing the separation of the one-to-one relationship between the provider and the target type. That's a big change, I think we can all agree, and it's one that would need to be taken with care and thoughtfulness. 
 Sounds good! 
 I _think_ this is resolved, not 100% sure. @jasl sounded like you had an idea of what to do next here, is that right? 
  Did you get this figured out? Is it a duplicate of https://github.com/Moya/Moya/issues/356 ?
  This PR suppose to fix issue #350 by calling `request.resume()` manually.
 As discussed in #350 , I've updated PR with some more commits. Would you take a look?
  Great, thanks!
 The CI failure isn't your fault, btw :sweat_smile: 

I've invited you to the Moya contributors group ‚Äì no pressure to accept! You would have the ability to review+merge others' PRs. There's [more info here](https://github.com/Moya/contributors). 

Thanks again for the PR!
  Checkout `path` & `parameters` which mentioned in documentation [Target](https://github.com/Moya/Moya/blob/master/docs/Targets.md).

Hope this is helpful :)
  _Hopefully_, this will fix the intermittent false negative on CI. I also removed all the unnecessary async testing (we never really need to use `toEventually` in our case).

Additionally, I changed the release task to accommodate [this issue](https://github.com/CocoaPods/CocoaPods/issues/4326) and cleaned up some matchers.

Fixes #349.
Fixes #259.
 This is an interesting PR (humblebrag) specifically from a unit testing perspective; I'm happy to answer questions or clarify changes made to our use of matchers, etc.

@Moya/contributors this would also be a good "first PR review" if someone out there hasn't reviewed+merged one before.
 I wonder if the world would benefit from RAC factoring out the Scheduling library into its own framework.
 Open an issue ‚Äì they seem to be all about small libraries. 
 I _think_ I've addressed all the feedback; GitHub isn't collapsing it since it's on the commits instead of the PR ¬Ø\_(„ÉÑ)_/¬Ø

![](http://gifs.ashfurrow.com/party.gif)
  Before all, there is nothing to apology, and thank you for addressing this issue :100: 

The problem is probably from [here](https://github.com/Moya/Moya/blob/master/Source/Moya.swift#L220), inside `manager.request(urlRequest)`, it call `resume()` immediately.

In my opinion, this is a bug and should be fixed. I'll look forward and propose a PR to fix this.
 That's unusual! And also bad! That shouldn't happen! A PR to fix this would be most welcomed. Hopefully there's a way to retrieve the AF request object without side-effecting.
 I've opened an issue on Alamofire to get this sorted out. We'll see how it goes.

The problem appears to be how we structure the authentication plugins. Maybe we need to rethink the plugin architecture. Actually calling the network while stubbing seems like a serious issue and we should prioritize. 
 @cnoon has provided valuable feedback: https://github.com/Alamofire/Alamofire/issues/986 I believe we should follow their advice and use a custom manager instead of the shared one (while still allowing devs to pass in their own manager if they want). 

Thoughts? Feels? 
 Hmm, solution is surprisingly simpleüòÇ ... but it do solve our issue.  It's OK for me. I'll update PR #354 if there is no objection. 
 Sounds good, thanks! In the AF issue, they had some guidelines about how to create a manager with good defaults. 

We also need to update our documentation to make it clear that we don't use the shared manager anymore. Since this is a breaking change, the next Moya version will be 6.0.0.
 Yeah, in short terms, I think it would be suffice to modify ade1589 with default configuration:

``` swift
    public final class func DefaultAlamofireManager() -> Manager {
        let configuration = NSURLSessionConfiguration.defaultSessionConfiguration()
        configuration.HTTPAdditionalHeaders = Alamofire.Manager.defaultHTTPHeaders

        let manager = Alamofire.Manager(configuration: configuration)
        manager.startRequestsImmediately = false
        return manager
    }
```
 Yup! I would add a comment pointing to the issue, too, in case someone is curious. 
 Looks like this is fixed in the current master: https://github.com/Moya/Moya/blob/d2897a91ee3b92214fd6e8d7636cec96a019f2dd/Source/Moya.swift#L306-L314 Going to close, thanks again for opening and the discussion!
  I just wanted to start a discussion around patterns on the `TargetType`. The existing solution with Swift `enum` seems to enforce the implementing client code to have huge switch statements based on the endpoint. I don't think this scales well for many endpoints and doesn't really play well with request or response parsing. I have adopted a struct based solution where each target is a struct with parameters to each passed into the init.

This is related to #347.

Example:

``` swift
func moyaErrorToMyAPIError(moyaError: ReactiveMoya.Error) -> MyAPIError {
    return .MoyaError(moyaError)
}

protocol MyTargetMarker {}

struct MyTarget: TargetType, MyTargetMarker {
    let targetType: MyTargetType

    init(_ targetType: MyTargetType) {
        self.targetType = targetType
    }

    var baseURL: NSURL {
        return targetType.baseURL
    }

    var path: String {
        return targetType.path
    }

    var method: ReactiveMoya.Method {
        return targetType.method
    }

    var parameters: [String: AnyObject]? {
        return targetType.parameters
    }

    var sampleData: NSData {
        return targetType.sampleData
    }

    var parameterEncoding: ReactiveMoya.ParameterEncoding {
        return targetType.parameterEncoding
    }
}

protocol MyTargetType: TargetType {}

extension MyTargetType {
    var target: MyTarget {
        return MyTarget(self)
    }
}

enum MyAPIError {
    case Custom(ErrorType)
    case MoyaError(ReactiveMoya.Error)
}

protocol ProducerTargetType: MyTargetType {
    typealias ResponseType = Response

    func producer(provider: ReactiveCocoaMoyaProvider) -> SignalProducer<ResponseType, ErrorType>
}

class MyAPIProvider: ReactiveCocoaMoyaProvider<MyTarget> {
    func request<T: ProducerTargetType>(token: T) -> SignalProducer<T.ResponseType, MyAPIError> {
        return super.request(token.target).mapError(moyaErrorToMyAPIError).flatMap(.Latest) { response in
            return token.producer(self)
        }
    }
}


extension ReactiveCocoaMoyaProvider where Target: MyTargetMarker {
    func requestProducer(token: Target) -> SignalProducer<Response, MyAPIError> {
        let producer: SignalProducer<Response, MyAPIError > = request(token).mapError { MyAPIError.MoyaError($0) }
        return producer
    }
}

struct GetUserTarget: MyTargetType, ProducerTargetType {
    typealias ResponseType = MyUser

    var path: String {
        return "/user"
    }

    func producer(provider: MyAPIProvider) -> SignalProducer<ResponseType, MyAPIError> {
        return provider.requestProducer(target).flatMap(.Latest) { response -> SignalProducer<ResponseType, MyAPIError> in
            return response.mapJSONValueProducer().toDecodedProducer()
        }
    }
}

struct CustomGetSomethingTarget: MyTargetType, ProducerTargetType {
    typealias ResponseType = MyCustomType

    var path: String {
        return "/something"
    }

    func producer(provider: MyAPIProvider) -> SignalProducer<ResponseType, MyAPIError> {
        return provider.requestProducer(target).flatMap(.Latest) { response -> SignalProducer<ResponseType, MyAPIError> in
            // custom parsing and processing 
        }
    }
}
```

With a little boilerplate, this allows each `TargetType` to be defined as a separate object that can be passed to the API provider to initiate a request.

I would love/appreciate any feedback. 
 I've heard of people doing this ‚Äì @swizzlr I think ‚Äì but this is the first code I've seen. Looks really cool! I think this approach is definitely worth adding to the docs. Thanks @mpurland!
 At Network Locum, we're taking this struct based approach as it's a little more flexible. The enums with the vast proliferation of AVs is here, though since an AV is really just a tuple, I could typealias those away, or embed them in a struct, since they form a pack of relevant query parameters.

You can see I've taken something of a middleground over the usual enum approach, versus the innovative one above. @mpurland, it would be incredible if you could write this up somewhere and add a link to the Moya docs, or even better contribute back to them. I love the economy of the protocol extension, faking a base class without the cruft of inheritance with opt-in behavior!

``` swift
public struct LocumTarget {
  public enum Environment: String {
    case Dev = "com.networklocum.environment.dev"
    case Live = "com.networklocum.environment.live"
  }
  public enum Action {
    case FindJobs(postcode: String, radius: Int, fromDate: NSDate, weekdays: Set<Job.Weekday>, timePeriod: Set<Job.TimePeriod>, hourType: Set<Job.HourType>, includeUrgentCare: Bool, token: String)
    case FindJobDaysAtFollowedPractices(fromDate: NSDate, weekdays: Set<Job.Weekday>, timePeriod: Set<Job.TimePeriod>, token: String)
    case GetUserToken(saltedHashedPassword: String, email: String)
    case GetSaltForEmail(email: String)
    /// Nil status implies no filtering, so return every application
    case GetUpcomingApplications(token: String, filteredByStatus: Application.ApplicationStatus?)
    case GetUser(token: String)
    case ApplyForJob(jobID: String, userToken: String)
    case WithdrawApplication(applicationID: String, userToken: String)
    case GetApplicationByID(token: String, id: String)
    case PostViewedJobDayEvent(jobDayID: Int, token: String)
  }
  public let environment: Environment
  public let action: Action
  internal init(environment: Environment, action: Action) {
    self.environment = environment
    self.action = action
  }
}
```
 This has been implemented with `StructAPI`, and I've opened issue #552 to document its use properly. I _think_ this addresses everything, please re-open if there's more to do.
  I just wanted to start a discussion around response parsing for `TargetType`. I have an existing solution using ReactiveMoya with some protocol extensions. It would be nice to have it built into Moya though.

Example:

``` swift
protocol ProducerTargetType: MyTargetType {
    typealias ResponseType = Response

    func producer(provider: ReactiveCocoaMoyaProvider) -> SignalProducer<ResponseType, ErrorType>
}
```
 Sounds like this is resolved, feel free to re-open if not üëç 
  This should go along with https://github.com/mhuusko5/Podspecs/pull/3 or https://github.com/mhuusko5/Podspecs/pull/2

@mhuusko5 FYI
 Cool! I'm pushing to trunk now 
  Similar to way it's done via CocoaPods where podspec contains different types(Core/Rx/Reactive).

Right now when we pull Moya via Carthage ‚Äî all 3 versions are downloaded and compiled (as well as specific dependencies for each one). 
Obviously, that is much more time-consuming than pulling only 1 version.
Example: `carthage update --platform tvos  856.54s user 145.58s system 445% cpu 3:44.89 total`
And yup, i think this is not highest-priority thing because this is an issue mostly for first Carthage run with Moya at Cartfile.

I've checked Carthage and found zero answers about such possibility. 

From all stuff i wrote above i have 3 different assumptions: 
- I'm wrong (feel free to tell me) 
- This is an issue and Carthage actually has way to solve this 
- This is an issue and Carthage has no ways to solve this (probably i'll create an issue on it's repo than). 

I had a thought about dealing with that via 
- Tags 
- Separate branches (seems to be painful to support) 

But i just hope to get any advice before starting to dig into that without even knowing if it's reasonable to spend time on this. 

Thanks for attention :)  
 :disappointed: Thanks, hope it will get better soon. 
 Correct ‚Äì we tried multiple repos but it got out of hand, quickly. Moya was created as a CocoaPod, and the Carthage support we have today was added after the fact by volunteer contributors (we're very grateful). The Carthage team has been asked for a subspec-like feature to accommodate this, but they have decline (it's antithetical to how they believe libraries should be built). 
 Totally ‚Äì everyone has different needs :)
  As discussed in #338, this move to using the standard result type instead of creating our own. Due to Alamofire having its own result type I had to move some things around to remove the name clashing. I had to move things to other files since the antitypical result type cannot be prefixed since the name of the framework is `Result` and using `Result.Result` gives a compiler error.

This should work with cocoapods just fine but there seems to be issues with carthage. ReactiveCocoa versions give errors for tvOS and watchOS targets since the minimum deployment target is now 2.1 and 9.1 respectively instead of 2.0 and 9.0. The same thing happens with the RxSwift version for tvOS. Maybe there was a change in Xcode 7.2 that causes this problem or these frameworks don't have the proper setting for the minimum deployment target anymore. This needs investigation.
 Cool, thanks for looking into this. We could certainly just bump up out minimum deployment versions. Anyone else free to help on this? 
 I can try to bring proper solution 
 Did bumping to RC1 fix the issue?
 Looks good to me!
  This fixes a pretty egregious bug where underlying errors would be rarely, if ever, handled appropriately. In short, the presence of an NSURLResponse would cause Moya to discard the underlying error entirely, which is _not good_.
 Interesting, good catch :+1: It could _probably_ stand to be tested ‚Äì I'm ok merging as-is as long as we open an issue to add tests later. 
 Yes it could. Hold on.
 @ashfurrow ready to merge at your pleasure
 Cool cool, forgot to ask for a changelog ‚Äì feel free to merge once that's in. 
    **Hi! 
First of all ‚Äî thanks for an awesome tool which helps with making projects better** :+1: 

I've faced one situation while using Moya, but since that seems to be breaking change i'd like first to discuss (or sort for approval to make that change). 

What we have:
Let's imagine some api with parameter/based URLs (Flickr, for example).

and code:

```
    public var baseURL: NSURL { return NSURL(string: "https://api.flickr.com/services/rest")! }

    public var method: Moya.Method {
        return .GET
    }

    public var path: String {
        return ""
    }
```

So a thing here ‚Äî returning empty string as path looks a bit creepy.
Wouldn't it be better if we will make path optional? 
So Target type will look like: 

```
public protocol TargetType {
    var baseURL: NSURL { get }
    var path: String? { get }
    var method: Moya.Method { get }
    var parameters: [String: AnyObject]? { get }
    var sampleData: NSData { get }
}
```

Not sure if this still looks good. Maybe better option will be to provide different target types (üôÑ) or default implementation for protocol functions in extension? So if you don't want to return parameters ‚Äî no need to implement getter which will return nil. 

Thanks for attention :) 
 Thanks, your opinion on this seems to be much more reasonable. 
 I see now,  thanks fkr making this more clear. 
  Doesn't type inference tell Swift which to use? It's also possible to use Moya.Result. I'm not opposed to adding a dependency if we need it. 
 Sounds like the easiest solution is just to add a dependency to Result. I'm totally OK with that ‚Äì anyone have time to send a PR? 
 Fab idea. This would also be a great "first time" contribution, too!
 This was fixed in #344, I believe. If it's still an issue, we can re-open.
  Yay :tada:
 Aye let's merge. Can the people above in the conversation please open issues they feel need to be addressed? 
  Basically, GitHub has its own idea of git tags called "Releases", and Carthage uses _releases_ instead of _tags_ when you specify GitHub.

So the following two lines in a Cartfile are _not_ necessarily equivalent.

```
github "Moya/Moya"
git "https://github.com/Moya/Moya.git"
```

By added a GitHub Release, we avoid confusion with people installing older versions of Moya by accident. I've automated this to make sure I don't forget.

See https://github.com/Moya/Moya/issues/335 & https://github.com/Moya/Moya/issues/332
 @mpurland When you get a moment, could you review this PR? 
 :+1: 
 @ashfurrow Okay, sure, let me have a look

EDIT:

Looks good :+1: let it :boat: 
 :boat: 
  Oh, right. Carthage means different things between specifying "git" and "github" ‚Äì we've seen this before, sorry it's not fixed yet. 

I've created a [5.1.0 "Release"](https://github.com/Moya/Moya/releases/tag/5.1.0) in addition to our existing tag. Try again and let me know if that works. 
 Ah I see, right. Moya 5.1.0 has a different version of RxSwift as a dependency. I'll fix that tonight, or roll back to beta 2 for now. 

For anyone interested in the problems with releases vs. tags in Carthage, check out the end of this thread: https://github.com/Moya/Moya/pull/329
 #361 deprecates this
  @AvdLee I should think the correct way to do this would be to embed it within the Target and correctly generate the params using the `parameters` property of the `TargetType` so you have a single point of entry.
 Hmm, that's odd ‚Äì sorry this is being problematic. So Moya actually _used_ to let you do this, and we took it out to sort of "force" developers to put these types of parameters inside enum associated values. 

You're right that enums can't have stored properties, but an enum _case_ can. In [our login case](https://github.com/artsy/eidolon/blob/a93f9f67aca6b27996076b3042ea532b4fbb9fb5/Kiosk/App/Networking/ArtsyAPI.swift#L8), we attach username and password as associated values. Then later when we need to return our parameters, [we use those associated values](https://github.com/artsy/eidolon/blob/a93f9f67aca6b27996076b3042ea532b4fbb9fb5/Kiosk/App/Networking/ArtsyAPI.swift#L140-L147). This lets us store, and then retrieve the parameters. Your code to invoke the endpoint would change to look like the following:

``` swift
MyProvider.request(token: Target(offset: 0, limit: 15))
```

Does that make sense? 
 Ok cool, this looks like it got sorted out. Going to close, feel free to re-open üëç 
  ~~In this case, you can take advantage from "Pattern Matching" in Swift~~
 Ok...I also run my tests this time, it won't work. I removed my answer
 If you need to put the same `user` and `password` for any kind of `endpoint`, why not just add auth header directly without `switch` cases ?
 OK, so if the username and password apply to _every_ endpoint, you have a few options. The easiest is to store the username and password in a globally-accessible place. Then your closure would look like:

``` swift
var endpointClosure = { (target: TestApi) -> Endpoint<TestApi> in
    let credentialData = "\(globalUserName):\(globalPassword)".dataUsingEncoding(NSUTF8StringEncoding)!
    let base64Credentials = credentialData.base64EncodedStringWithOptions([])
    let endpoint = Endpoint<TestApi>(URL: url(target), sampleResponseClosure: {.NetworkResponse(200, target.sampleData)}, method: target.method, parameters: target.parameters)
        .endpointByAddingHTTPHeaderFields(["Authorization": "Basic \(base64Credentials)"])

    switch target {
    // TODO: Customize any parameters on an as-needs basis.
    default:
      return endpoint
    }
}
```

There are other ways to do this, like using composition to encapsulate the username/password inside an object that also holds onto the Moya provider for you. We do something similar [here](https://github.com/artsy/eidolon/blob/a93f9f67aca6b27996076b3042ea532b4fbb9fb5/Kiosk/App/Networking/ArtsyAPI.swift#L349-L408), but for other purposes. You could also store the credentials in [another type](https://github.com/artsy/eidolon/blob/f95c0a5bf1e90358320529529d6bf431ada04c3f/Kiosk/App/Networking/XAppToken.swift#L10-L64). There are lots of different options to do this _well_, but I'd first focus on getting it to work, and then make it awesome after :tada:

Does that help? 
  Hello, sorry you're experiencing this error. Not sure what's going on, as I'm not as familiar with Carthage. Any ideas @justinmakaila ?
 This is because 4.0.2 is the Latest release. The others are just tags. 

@minhoryang To fix this right now you can use:
`github "Moya/Moya" "5.1.0"`
 You should be able to try again now and have it work ‚Äì see https://github.com/Moya/Moya/issues/335 for more details. 
  Hey there! Great question, I've had this kind of error happen before too. I think it's a bug in Swift surrounding error-handling and inferring closure return types. The way I've fixed it is to explicitly tell swift what the closure return type is. `.map { response -> [Model] in` or whatever. Let me know if that works! 
 Great! Glad that worked, thanks for posting the solution! Should we close this issue?
  https://swift.org/package-manager/
 +10000 :tada: :+1: 
 The "correct" way to do this would be to provide a core "Moya" framework and then "ReactiveMoya" and "RxMoya" ancillary frameworks. Yes, you may end up needing to do two imports. You have to deal.
 YUP. Subspecs are a bad method of organising code.
 Creating whole repos, and all the required infrastructure for 1-2 files, then 1-2 test files is a bad method of organising code.
 I'd like to point out that, unlike with Carthage, we may have the opportunity here to add support for subspecs to SPM. I honestly think they're a fantastic feature, and I know the SPM/CocoaPods people have been chatting. Maybe that's something we could do together.
 They've already got something like this [on their todo](https://github.com/apple/swift-package-manager/blob/master/Documentation/PackageManagerCommunityProposal.md#package-flavors) as Package Flavours.
 Neato :ok_hand: 
 Like all things in programming, It's a trade off, there's additional complexity in maintaining a lot of redundant resources in order to keep things going as they are now.

Ensuring that multiple projects are now green on deploys becomes harder, might need a meta-repo to allow for editing all of the files at once, changes to one might not propagate to the others via multiple PRs. This is a community project, so those tradeoffs don't have to be the ones that I think are valuable.  

Switching to separate repos for all of these strongly correlated projects comes with lots of downsides, but if one of the upsides is that it can work with the current build of SPM before the add flavours, then maybe it is worth the tradeoff for someone to build and ensure all of the infrastructure is in place to simplify the extra work for contributors.
 Aye. If anyone is interested in the specifics of what's involved, check out [this PR](https://github.com/Moya/Moya/pull/169) for our first attempt at a multi-repo setup, and then [this PR](https://github.com/Moya/Moya/pull/215) that finally did add Carthage support (it discusses the reasons for going with only one repo).
 But Orta, the projects are _not_ strongly correlated! The RAC extensions to Moya are simply extensions to provide helpful wrapping. The core value of Moya lies in its endpoint modelling types, and if the extension subspecs went away tomorrow, we would be no worse off. There will be very little requirement for lockstep updates as long as the extensions only use public API, just as they should. A strong adherence to semantic versioning would obviate many issues. I agree that lockstep repo updates suck, but that wouldn't be the case here.
 > The core value of Moya lies in its endpoint modelling types, and if the extension subspecs went away tomorrow, we would be no worse off

That's idealistic, not realistic, I bet almost everyone who maintains and contributes to this project uses RAC/Rx with Moya. I had to argue that it was worth building a non-RAC version at all at the start. Again, I'm not the one who would be doing the work maintaining and keeping this all running, so it's not my neck on the line here.
 > I had to argue that it was worth building a non-RAC version at all at the start

Ha, I forgot about that!
 RxSwift has done this without [much faffing](https://github.com/ReactiveX/RxSwift/blob/master/Package.swift)
 Closing this conversation in favor of https://github.com/Moya/Moya/pull/643.

I didn't see this conversation when I was working on https://github.com/Moya/Moya/pull/563, but I'm glad to see other people had noticed the same problem I had üòÑ 

Of course, please re-open this if there's anything lingering that should be discussed!   Fab, looks great! Want to add an entry to the changelog?
 Sure, will do after I look into this build issue.
 @ashfurrow Can you trunk push this updated podspec for the latest ReactiveCocoa alpha? It's needed in order to set the version in the Podfile for the Demo project in Moya. 

See https://github.com/mpurland/Specs/blob/rac-update/Specs/ReactiveCocoa/4.0.4-alpha-4/ReactiveCocoa.podspec.json
 For reference: https://github.com/ReactiveCocoa/ReactiveCocoa/issues/2590
 Sure, can do. Where did you get the original to modify? We're using https://github.com/mhuusko5/Podspecs as a source for Ruby-based pod specs. /cc @mhuusko5

Also, I'm afraid to say that the ReactiveCocoa developers are unlikely to do anything but close your issue. They've declined repeated offers from myself and others to help maintain the podspec in their repo, and choose to be poor sports instead. 
 I used the podspec for 4.0.3-alpha-3 as a base since that's the last one you added. 4.0.4-alpha-1 is a much older version actually...
 Makes sense ‚Äì the Ruby ones are a bit easier to reason about. 

I'm not sure why they insist on declining, but it's been that way for as long as I can remember ‚Äì far before Carthage. 
 Not sure what the next step here is. The carthage build works, but the Demo project will not build because it depends on CocoaPods and the Moya podspec which can't reference a branch or commit.
 The next step is we need to push a podspec to trunk. Could you update the podspec on https://github.com/mhuusko5/Podspecs and send him a PR? Then we can push to trunk, then we can merge this :tada:
 Done https://github.com/mhuusko5/Podspecs/pull/1 
 Thanks @mhuusko5 

Re-pushed commit, now let's see if travis builds it...
 @ashfurrow This should be good now?
 Looks good to me, if someone else wants to review + merge after the changelog is updated, that'd be :100: 

Thanks again @mpurland ‚Äì great work!
 Ready to :boat: 
 Thanks!
 I've added you as a contributor to Moya, so you've got full push access :tada: You can read more about that here: https://github.com/Moya/contributors

I've also released 5.1.0 of Moya so you can use your new commits from Trunk! Thanks again!
 @ashfurrow Thanks. Glad to help out now and in the future.
 @ashfurrow Any reason why 4.0.2 is the Latest release and every release since is just a tag vs. a published release?

Also, any thoughts on submitting .framework.zip to releases for carthage compatibility so that Moya doesn't need to build (there are a lot of dependencies)?
 @mpurland of ReactiveCocoa? Not sure. 

I have no feelings towards Carthage support. If that's a thing we can do (easily) to help them, sure sounds good :+1: My only requirement is that it gets automated: https://github.com/Moya/Moya/blob/e069bc22e28b2d69cfcfbbae3cb15304d112fbd6/Rakefile#L27-L57
 I've run into that issue as well. I hope it will be addressed soon.
 @ashfurrow The above issue about tags and releases was encountered in #332.

It looks like the Rakefile will need to be adjusted to publish releases vs. just tags if you would still only want to cut releases that way.
 Oh I see, so specifying GitHub instead of Git in Carthage means very different things, one uses GitHub-specific thingies and the other just uses tags? I did not know that ‚Äì seems silly. Anyway to create a "release" from the command line? 
 There is a dependency for rakefiles that I've seen referenced that can be used.
 I think this is what I saw earlier: https://github.com/mpalmer/github-release
  Btw, I suppose if you can create the PR based on another branch instead of `master`, that would be great. :tada: 
 Ah... my bad.. I didn't see it. It should compile without any error then.

On the other hand.. it seems to that you can not just fake methods without implementing the details. It turns out this solution will likely break the implementation of `willSendRequest` in `CredentialsPlugin`

Why not just set `startRequestsImmediately` to false by default and call `resume()` manually.
 Really cool PR, thanks! I don't mind it coming from master at all, personally. Could you add an entry to the changelog when you get a chance?

Thanks again! üéâ
 @mrahmiao Great, thx
 You can update the changelog, commit, and push to this branch and github will add it to this pr ‚≠êÔ∏è
  Just a quick guess: you sure about `(request.request as? NSMutableURLRequest)?` will not give a `nil` cause `NSURLRequest` not same as `NSMutableURLRequest` ?
 Hmm.. you are right. It's not caused by `nil`

Apparently, it's because `willSendRequest` get called after `request.resume()`... (It probably should not !)

So the workaround for now is using the approach mentioned by @ashfurrow in issue https://github.com/Moya/Moya/issues/325#issuecomment-161039326, it will work.
 Sounds like something that the library should fix :smile: Could someone open an issue (or send a pull request :wink:)?
 I've finally got some time in weekend and could be back to this issue. Here is my rethought.
- All the manipulations of `NSURLRequest` should be done in either `endpoingClosure` or `requestClosure`, the latter is the original way to **resolve/alter** a request, and should probably be the answer of this issue. (I should've noticed it at the first place:disappointed: ).
- It is probably not a good idea to manipulate `request` in `plugin`. 
  Think about this case: assume we have `let plugins = [A, B, C, D]`, 
  - `C` could sometimes break `A`, because `C` could alter some value which already have been altered by `A` again accidentally, then we got a silent failure.
  - `D` will be functional based on `B`, which means `[A, B, C, D]` will work, but [A, D, C, B] will not work.
  - :bomb: 
  
  The `Plugin` mechanism is basically a "multicast delegation" pattern. If we do not keep every `plugin` entirely independent (such as alter the same instance one by one), we could easily entry into a mess.

**Conclusion:**
- This is not a bug. :wink: 
- We may need to rethink also the implementation of `CredentialsPlugin`. :thought_balloon: 
 I agree with @wangshengjia about the `Plugin` mechanism for manipulating requests can have problems. We could solve this with some type of requirements, ordering, priority, or another type of streaming/proxy solution (something along the lines of https://github.com/typelift/Aquifer comes to mind).
 Using `requestClosure`, is this issue is resolved?
  Hey, good question! Moya uses Swift's associated values on enums in order to pass in parameters. 

``` swift
enum TestApi {
     case Login(userString: String, passwordString: String)
}

let endpoint = TestApi.Login(userString: "Ash", passwordString: "password")
target.request(endpoint)
```

Does that make sense? 
 Ah! I see. You can `switch` on the `target` and return a different endpoint. 

``` swift
var endpointClosure = { (target: TestApi) -> Endpoint<TestApi> in
    let endpoint: Endpoint<TestApi> = Endpoint<TestApi>(URL: url(target), sampleResponseClosure: {.NetworkResponse(200, target.sampleData)}, method: target.method, parameters: target.parameters)


    switch target {
        case Login(let userString, let passwordString):    
         let credentialData = "\(userString):\(passwordString)".dataUsingEncoding(NSUTF8StringEncoding)!
         let base64Credentials = credentialData.base64EncodedStringWithOptions([])
         return endpoint.endpointByAddingHTTPHeaderFields(["Authorization": "Basic \(base64Credentials)"])
    }

    return endpoint
}
```
 Yup, that's right!
  This should close #265 with the omission of watchOS since it can't have test targets as of now.

Changes:
- Renames DemoTests folder to Tests
- Add test targets for OS X and tvOS
- Update Podfile to have the new targets
- Update Rakefile to run all the new test targets
- Add `ImageJPEGRepresentation` method for tests since there is no `UIImageJPEGRepresentation` equivalent for OS X
 When I've seen problems like this, it's typically "the nth test always fails", irrespective of which test that is. 
 Likely a combination ‚Äì I've seen it on other projects where Quick/Nimble only fail to work on slow hardware like Travis, and only sometimes. 

Want to restart that build to get the green check in our commit history? 
 Looks like the error we're seeing here is different from #265. Could this be a legitimate test failure? It's only happening on the pr tests ‚Äì @petester42 when you have a chance, could you merge in changes from master and see if the test continues to pass locally? That way we can verify if it's a true failure or a Travis problem. 
 Nope, just intermittent ¬Ø\_(„ÉÑ)_/¬Ø

I'm merging!
  Aye, sorry for the confusion @ivanruizscm. I've released the podspec, so the best thing you can do is go back to your original Podfile (the instructions in the project's Readme) and do a `pod update Moya`. Let us know if that works :+1: 
 Cool! Glad that's working. @ivanruizscm would you mind if we close this issue? 
  As discussed in #300 theses are some changes to the protocol names to match the naming convention is the swift standard library.

Changes:
- **Breaking Change** rename `MoyaTarget` protocol to `TargetType`
- **Breaking Change** rename `MoyaRequest` protocol to `RequestType`
- **Breaking Change** rename `Plugin` protocol to `PluginType`
 Looks fab ‚Äì could someone else take a look + merge? 
 Superb work, as usual :stars: It's been a few days for anyone to object, I'm going to merge. 
  This PR aimed issue #318 which update the documentations
 Fab, thanks! 
  Huh, cool. Let's wait for :green_apple: just in case. 
  This PR update some documentations which is not matching the API correctly.
 Looks great, thanks! 
  This aims to fix #313 I tried various things but this solution seems to be the one that affects everything the least. What I did is that for the reactive schemes I added a prebuild action that changes all references in the source files from `Moya.` to `ReactiveMoya.` or `RxSwift` and also added a post build action that changes it back to `Moya.`

It's sort of hacky but it works properly. I have a lot of thoughts on how we are supporting carthage currently which seems like a bigger headache than it should be or worth. I'll open an issue about changes we could make to make everyone's life easier. 

Here are some of the things I tired for those interested:
- Changing the module name to `Moya` which works but since the output name has to be `Moya.framework` there will only be 1 framework in the carthage folder since the other ones get overwritten
-  Changing the module name to `Moya` and renaming the framework after it has been built in a post build action. This also works in Xcode but carthage references the framework name when moving it to the carthage folder so it fails with `file not found` since the name it wants is `Moya.framework`
- Rename instances of `Moya.` in the source files for `ReactiveMoya` and `RxMoya` on the fly before compiling and rename them back after compiling
 The inherent issue is that Carthage just builds targets in an xcodeproj; based on the issue, I'd recommend option 1, which was to make extension frameworks that sugar the respective libraries for Moya. I'm pretty sure that's what Apple would recommend in this situation if we were back in submodules. Until such time as we have weak linking in Swift, I think that would be the best option.
 @petester42 I quite like your approach here. Seems pretty reasonable, given the constraints we're in. 

> supporting carthage currently which seems like a bigger headache than it should be or worth.

You took the words right out of my mouth... 
  Hey there! Great question. We cover a bit about parameter encoding [in the docs](https://github.com/Moya/Moya/blob/master/docs/Endpoints.md#from-target-to-endpoint-), but the short-and-simple answer is that you need to pass a custom `endpointClosure` when you create the provider. It takes a target, which you `switch` on to customize individual endpoints. 

The parameter encoding you're describing is pretty custom ‚Äì query string in the URL and a JSON body ‚Äì so you should use the `.Custom` parameter encoding type. It takes a closure that modifies the `NSURLRequest` and returns it. You can see the source [here](https://github.com/Moya/Moya/blob/731db29d6a68d350ef97ad059e881f361dc35e3f/Moya/Moya.swift#L38-L57). 

Like I said, it's a pretty custom thing so I'm afraid to say we don't have many examples on it yet. We'll help you figure it out, though! And once we do, it would be :100: if you wanted to submit a pull request that adds some more examples to the docs based on what your experience :cake:
 Hey, just following up! Anything I can to do help? 
 Looks good to me! I must admit I've not tried this before, but it looks like it should work :+1: 
  Hi guys. Today I pulled master and tried building all targets on all platforms in the project, to make sure all was gooby. I noticed that ReactiveMoya and RxMoya targets have incurred some errors as a result of the prefix-less type name changes. 

![](https://cldup.com/XzupFOCUYn-1200x1200.png)

Errors like this are happening on uses of types like `Moya.Completion` because `Moya` is only actually the module name in the "base" Moya, and the base source is shared. The reason this can't work is because Swift doesn't currently provide a way to reference things by the "current module." A lot of the decls in the source don't actually require the prefix where we use it, but some do, due to ambiguity, etc.

From what I can see, here are a few ways to fix this:
- Convert the Rx/ReactiveCocoa additions be extension frameworks that themselves link against Moya
- Revert type names back to having the Moya prefix
- Change the reactive framework targets' module names to `Moya` (though this would be kinda weird, linking to `RxMoya.framework` but using `import Moya`)

I had previous said I saw no drawbacks to moving to this naming convention, so I apologize üôÅ but I'd like to hear thoughts on what the best option for resolution is.
 Hey, no problem! The third option sounds appealing; it's how CocoaPods works anyway. We can also use preprocessor directives cleverly somehow maybe. 
 I may have spoken too soon about that option. It seems that Xcode for whatever reason won't let you alter the module name setting (only errors if name is not equal to the framework bundle basename). ![](https://cldup.com/kesfU5dzwf-3000x3000.png)
 It appears this was already brought up in the description of #310. Definitely something we should fix before doing a release with all of these new changes lest we break Carthage support.
  Fab, good catch! :cake: 
  This addresses issue #293. It changes the `Completion` closure to return a `Return` type instead of multiple optional parameters.

There is an issue though. Since we are using `Moya.Something` in places now some frameworks don't currently build. Since the module name for `ReactiveMoya` does not match `Moya` those frameworks don't build. This is even an issue with the current version but I don't see how to fix it.

Anyone have an idea on how to fix this. I tried setting the module name to Moya for all the frameworks but then you get a warning:

```
warning: PRODUCT_MODULE_NAME may not be overridden for framework target 'ReactiveMoya iOS'
```
 This looks :100: great work!

For the module name problem, since that exists currently, we should probably open a separate issue about it? 

Thanks again, @petester42. We'll need to update our docs, but we can open an issue for that after we merge this. Can someone else from @Moya/contributors take a look and merge if they're happy? 
 Quite impressive! I looked it over and it looks like this will be a great direction going forward. I'm going to go ahead and merge it so I can get some participation here. 
  Disabling force pushes: probably good.
Requiring status checks: probably good, but there are instances where discretion is required.

Then again, that discretion can be exercised by temporarily disabling the protection setting.
 Thanks for the great idea @SRandazzo! I turned on protection for master when we made Moya an organization, and even clarify(ish) this in the [contributor guidelines](https://github.com/Moya/contributors#when-should-you-use-push-access). Great minds :)

As far as CI passing, that's a trickier one. Sometimes we'll merge in broken tests because getting a PR merged is more important than getting the submitter to fix the tests (they're a first-time contributor and it's easier for me or someone to fix it after it's been merged). Also, we have intermittently-failing CI (see #259).

I think @swizzlr's "discretion"-based model is :+1:, and I want to give all the contributors a chance to use their own discretion. 

That's just my ¬¢2, if the community wants this then of course we'll enable it. Thanks again for the great suggestion! 
 > If it weren't for those intermittent failures, I would propose an experiment to try it out

Agreed! Definitely worth a shot. Do you think it's worthwhile to keep this issue open for more discussion? Let me know if I can help answer questions about CI :boat: 
 We're still pretty consistently getting CI failures, which sucks. I heard a rumour Circle might have a feature soon to restart builds failed with the infamous "Error 65", we'll see. 

In any case, we now have Danger on the repo's pull requests, and sometimes we do need to override. I really liked the discussion here, but I think we've settled into a groove with the somewhat protected branches. Thanks again for sparking a good discussion!
  Dependes on #305
 @swizzlr is it possible to turn off the code coverage check for the patch? It's consistently failing, and I don't think it's super-necessary. 
 Also for some reason it's still trying to merge in commits that were already merged. Can you merge in from master when you get a chance?
 Code coverage check is a nice way to remind you of technical debt, IMO, and I've got a fix coming up now.
 +2%. NICE.
 Yeah totally, I'm just worried someone sending their first PR will be intimidated by a failing CI :(
 @swizzlr Anything I can do to help on this? 
 Sorry, week got mad. To do is to address your crashing concerns and string inference, add some code coverage to alamofire method conversion and the method logger plugin. After that i think my codecov duty will be done.
 Cool. One thing, @swizzlr: there is absolutely no apologize necessary ‚Äì we're grateful for your contributions and you should not feel like you've let anyone down. 
 Looks üëå to me! Would someone open an issue to update our docs around plugins? 
  Should prevent some merge conflicts in PRs. 
 LGTM, mind if I merge this before CI check finishes?
 Note that I don't think this'll apply to any PRs sent without this commit in their history.
  Depends on #304 
 Cool, looks good. This depends on #304? Want to update the PR description?

Also, a changelog entry would be :cake: 
 Am I correct in reading this as "that would be cake"
 That would be a correct literal interpretation, yes. 
 I thought we were going to keep the `Moya-` prefix on these types, what's the advantage of removing it? Advantages to keeping it:

Unambiguous origination. A `MoyaResponse` came from Moya. Where does `Response` come from? I wish Alamofire used a prefix on these generic names, too. 

No possibility of namespace collisions. `import Moya` will bring `Response` in as a top-level type, no need to prefix `Moya.` - so what does it mean when you create your own Response type in a file that imports Moya?

I think, and this is just a "dissenting opinion" that this change is an unnecessary breaking change. 
 @colinta those are some good points. It seems like Swift libraries are going one of two ways: either they're sticking with common Objective-C-style conventions like prefixes or they're going 100% prefix-less with no prefixes. Alamofire has gone the latter route. 

I agree with the downsides. In the case where there are two `Response` types, you can delineate between the two by using the `Moya.` prefix (we do this when using Alamofire [here](https://github.com/Moya/Moya/blob/e0b2b2a9108d3b9df8e6e671a91e49422a0ef20c/Source/Moya.swift#L14) for example).

Seems we're at a crossroads. I honestly don't have a strong opinion either way, but I recognize that this is a big shift and it deserves thoughtful consideration. Trying not to spam @Moya/contributors but I think this deservers further discussion. 

Edit: Not to sway the discussion, but it seems like the prefix-less approach is "where the puck is going" with Swift, though.
 It does seem that way, and it just occurred to me that this change doesn't _remove_ the `Moya.` prefix, it just makes it optional. With that in mind, I'm less opposed to it. 
 https://github.com/raywenderlich/swift-style-guide

According to this we should just use namespaces. I'm okay with that. If there is a collision you just have a little more to type.

So you may have to refactor the refactor again if we go with namespaces :P
 I don't see any real downsides to prefix-less type names in frameworks. As has been established, with references to the full type name including the module name prefix, there's always a way to disambiguate references to same-name types that exist in separate modules.

In the case where a user of Moya (or any other Swift module) with a "colliding" type name doesn't want to keep prefixing with the module name, they can always use a typealias.
 Cool, can someone hit the "merge" button?
 Wheeeeeee!
 Do we "Delete branch" afterwards?
 Sure!
 THE CI WAS FAILING
 NOOOOOOO WE

(:sly smile:)
   Cool, looks good to me. Could you add a changelog entry? 

If someone from @Moya/contributors could also take a look and merge if once it's :+1: to them, that'd be :100: 
 Gonna close this since #305 got merged. 
  As per discussion in #301. 
 How about just removing when Moya hits v6?
 I'm closing this one in favor of #489. üêº 
  (Net reduction in LoC!)

I got carried away closing #293.

Significant changes:
- Completion handler now returns `Response?, ErrorType?`
- `Plugin`s are now a protocol
- `ReactiveCore` is gone and now part of Moya in general
- `MoyaTarget` is now `TargetType`
- `MoyaResponse` is now `Response`
- `MoyaProvider` is now `NetworkResourceProvider` (discussion welcome on improving this)
- `sampleResponseClosure` parameter is now an escaping autoclosure, which makes the API a lot cleaner to use.
- Test classes are now `final`, as all classes should be.
- `Response` is now `final` (see above bullet), and will be changed to a `struct` once we drop RACSignal support.
- `Endpoint` is now a struct, and the `SampleResponseClosure` typealias has been removed for simplicity's sake
- `EndpointSampleResponse` now takes a non-optional ErrorType, or a `Response` object as opposed to a code and data.
 I believe these changes to be good because they make the library a bit more "Swift". Modules provide a namespace, so we don't need to prefix stuff, nor do we need to create our own namespace.

Plugins sorely needed to be a protocol, but were quite objc. I sometimes feel Moya is really wanting to have that magic dynamism that Swift rightly disallows. Turns out that if we get rid of the provider param, we can make plugins protocols. I can't see a good use for it either. Could be replaced with an `AnyObject` param.

We should either make the completion in-type a result, or a throwing func, just as suggested by @petester42, right now this is just weird.
 Okie doke, wow! You're right this is a _huge_ PR :sweat_smile: That's ok, thanks for the work! I'd like to discuss a ew top-level issues before we discuss nitty-gritty details. 

I'm good with all the renames except `MoyaProvider` ‚Äì I know it's not necessarily "Swift", but I really like having the library name somewhere in there. Maybe it's just me ¬Ø\_(„ÉÑ)_/¬Ø

The changes to `EndpointSampleResponse` look good, too. The `final` test classes, I've never seen that but fi that's what's suppose to be, that's fine. 

I think adding @petester42's suggestions about throwing closures becomes necessary with these new changes. We can wait until after this is merged before doing it though ‚Äì already a big enough PR :)

This'll need a merge from master and all of these points need to be described in the changelog, but yeah I agree with the general thrust. Thanks for the work! Smaller PRs next time! :cake:
 I would add that I have always appreciated the names `MoyaTarget` and `MoyaResponse`. Reminds where those objects originated. 

In my apps I have often defined Target and Response types - those names seem too generic to "claim" by a library. 
 Yeah good point, even if the compiler lookup can succeed most of the time using type inference, my brain's type inferrer is less powerful. 
 You ever change one thing, and then change something else, and then before you know it you're crying on the bathroom floor and the compiler is screaming in the kitchen?
 I agree with the points about target and provider. Let me know if you think I should do it for response too. Generally speaking, Swift is moving in a direction where namespaces are a thing (cf Alamofire.Request etc) but I can totally see how this could be irritating and make the APIs less usable.
 I'm going to factor this into individual PRs, so we do this right!
 Sounds good! Looking forward to the PRs! 
  As the title states, ReactiveCocoa 2 support has been deprecated.

Closes #298
 Probably worth mentioning in the README too
 Him, maybe clarifying that its 3 and above, rather than saying what isn't supported is a better approach 
 Agreed with Orta ‚Äì some clarification in the readme would be good, but that's not a blocker. I'll open an issue. 
  I've created a v5 milestone. We shouldn't let breaking changes fester in master too long before releasing a release candidate, but while we're at it let's sneak some more stuff in!

I've identified five issues that I think should be resolved for v5; take it up in those issues if you think they should be descoped.

With this issue I'm opening the floor to any other suggestions for issues to be added to the v5 milestone.

Let's draw a line under planning any more features to v5 by, say, **Wednesday 18th November** (that is to say, a freeze on deciding what will go into v5, not doing it obviously), if only to stop it from bloating too much.
 Yeah, I like the idea of a milestone but I'm not sure we need any specific date to plan on. We can evaluate issues for version 5 on a case-by-case basis, and if anyone feels we're waiting too long, we can talk about it. 

This is also a great issue to discuss anything that's missing (changelog entries, for example). Thanks T-Swizzle. 
 So I think we're in a good spot now to release _a_ build. I know we still have 5.0.0 issues open, but many of them are either longer-term or could be done without breaking changes. It's been a while since we made a release and I don't want us to get to _too_ far away from the existing release. Does anyone have anything they want to make sure gets in this release? /cc @Moya/contributors 
 _Yes_. These all sound amazing. 

`Endpoint` should never be subclasses, so making it `final` is :100: I'll try and get to these changes this weekend.
 OK, anything else? I'll cut a release tomorrow morning if that's all. 
 Cool cool, this is released in https://github.com/Moya/Moya/commit/117af026df08d006aaac317c92294ebb9d5dffd1 with the podspec at https://raw.githubusercontent.com/CocoaPods/Specs/e0bf8b03d24b0b23829d8667298591ef5a431dfd/Specs/Moya/5.0.0/Moya.podspec.json .

So I'll close the issue and migrate the 5.0.0 milestone to a the "longterm" one. 
  Guess no one has yet tried to submit ReactiveMoya with Carthage yet.

This commit removes the MOYA_VERSION env var as it was out of date and not used everywhere. I don't think it's needed.
 Can you merge in from master and push? 
 If i'm not mistaken that was an error from Ô£ø that should be fixed by now.
 I can personally confirm that the matching version thing was a bug and was def fixed for me. There's no good reason to declare the framework version, so I think 1 is a safe bet.

The issue this resolves was that some targets had no MOYA_VERSION defined, thus causing a nil short bundle ID, and thus failing ITC checks.
 No worries sport; was there a reason why you wanted MOYA_VERSION? I can put it back in if that makes the library easier to use for more people.
 Well, looks like we're good to go with this?
  Not insignificant time is being spent maintaining the RACSignal extensions, as well as the non-RAC3+ provider. We should consider officially marking these as deprecated for some time, before eventually removing them. 

Not sure if anyone else is using them or if its just me, and I won't be for much longer. Open for discussion!
 Sounds like a plan!
 +1. Out with the old in with the new.
 Next action would be to add `@available(*, deprecated, message="This will be removed in the next major version of Moya. Please visit https://github.com/Moya/Moya/issues/298 for more information.")` to all relevant methods (I should think `request` overload).
  Before starting with #293 I just wanted to make sure that everything that came with #289 was finalized. There were a couple NSErrors that still existed so I cleaned it up to remove all usages of NSError and replace them with MoyaError.

Changes:
- Forward underlying errors when cast to MoyaError does not work
- Fix MoyaResponse extensions that were still throwing an NSError instead of MoyaError
- Change MoyaError to conform to `Equatable` in tests for cleaner syntax
- Update reactive extension tests to use MoyaError instead of NSError
- Update ReactiveCocoaMoyaProviderSpec tests to use the `SignalProducer` variant when possible.
 Looks great! Thanks!
 I've opened a PR against this branch to try to resolve some of the code coverage issues: https://github.com/petester42/Moya/pull/1
 Just a thought, but does it make sense to implement `Equatable` for "case equality" vs "value equality" (and are those two different for this type)? This expression could be true: `.Underlying(x) == .Underlying(y)` (where `x != y`). Seems to be typical convention to implement equality checking for associated value enum cases to compare the associated values, provided they're equatable (example: https://github.com/ReactiveCocoa/ReactiveCocoa/blob/fd64bf6ea7a83dec13fe42244db470fd9641a9a1/ReactiveCocoa/Swift/Event.swift#L94-L111), which I think `MoyaResponse` could conform to to make this work for this error type.

As for specifically checking the case equality, that's still very much useful and necessary, in this case for the tests, but it felt more appropriate as a function on the enum IMO. May be confusing for users of Moya seeking or trying to implement true value equality checking on this type, which may have been the reason for @tomburns' [initial reservation about implementing it this way](https://github.com/Moya/Moya/pull/289#issuecomment-154882315).
 Sure, just trying to stay aligned with observed language conventions üòä
From Swift `Equatable` docs:

> Instances of conforming types can be compared for **value equality** using operators == and !=.

I think it's more responsible of us to not to use an unconventional `Equatable` implementation just to be able to use `==` in a test rather than a (more appropriately named) function on the type. We don't need value equality for this type at this point, but we may in the future, or users of Moya may want to extend to implement it themselves, and would be stuck as the type already conforms with behavior they don't expect. 
 `Merging #297 into master will increase coverage by +9.07% as of 20e82cf`

üò±
 Do however agree with -1 on default cases in switches, and not comparing underlying values, but while it's internal to the framework it matters not to consumers of the API.
 Well I didn't say anything needed changed with the switch statement or how it was implemented (I agree with you, exhaustive is nice ‚Äì let's let the compiler work for us), just that this (again, perfectly valid) **case** comparison should change in no way _other than_ taking it away from `Equatable` where it doesn't fit.

And it _is_ public, unless you mean unreleased. It publicly conforms to `Equatable`, using up that conformity in a non-standard way, which was my point. Out of curiosity to understand: why is it thought that two "same-operation" errors from two entirely different responses are "equal?" Or two completely different `NSError` objects in `.Underlying(err)`? `.Underlying(errorA) == .Underlying(errorB)` evaluating true in any scenario other than where `errorA == errorB` seems lacking in sanity to me. As someone (also a user of Moya) who would potentially want equality checking with the behavior I describe, and would be forced to implement it OUTSIDE of `Equatable`.

For what it's worth, I [briefly described this situation on Twitter](https://twitter.com/JohnRHeaton/status/665185150356070400) and [saw an agreeing response from Joe Groff on the Swift team](https://twitter.com/jckarter/status/665186722498506752).
 > changed it to be a matcher

Great idea! :100: 
 Looks damn good to me! We just need to resolve the merge conflicts.
 Looks good once conflicts are fixed üëç
  Todo:
- [x] Update changelog

Allow injection of a date scheduler which will, when stubbing, be used instead
of the default behavior for executing stub closures.

This commit required reworking the internals of MoyaProvider, mostly factoring
out some common code to be shared by the subclass into a separate few methods
that are final and internal, and documented.
 To do: add tests
 Cool, looks great so far :cake:
 SOMEBODY MERGE IT
 I think you meant to say "this is ready for final review" üòâ

I'm on my phone right now ‚Äì anyone is free to merge this if it looks üëç to them ‚òïÔ∏è
 Nice work. I have some confusion regarding the behavior of `createStubFunction`'s `canceled` parameter. I'm unfamiliar exactly with how `inout` parameters work in this type of context. When the closure returned from `createStubFunction` checks this bool, is it still checking the original variable in the caller's scope by reference? Or is it a copied value at this point, thus negating the intended cancellation behavior?

Either way, it may be worthwhile to write a test that verifies this cancellation behavior pre-merge if we don't have one already. If we do, carry on and this should be ready for merge üòá
 You know, I have no idea. I need to experiment and find out. I'll make a playground when I get to work (~1hr)
 I've ducked the issue by making the stub function take a cancellable token, and refactoring the token to be a reference type. While I was at it I gave it a canceled property and ensured writes to it were locked, let's see what this does to coverage.
 @JRHeaton care to take a look?
 Clever! I'd say that seems like a better implementation. The only odd thing to me here is having a non-optional action closure on the token, but the initializer takes an optional one, defaulting to an empty `{ }` closure if initialized with `nil`. Perhaps the token could have an optional action closure (since it itself now handles a cancellation state boolean), and it could be invoked with Swift's optional function call syntax: `cancelAction?()` Feelings on this? It's a small thing, but would allow us to remove the icky force unwrap in `init()` :)
 Can do! Could also do an if let ‚Äì it's really just because the nil-coalescing operator gave up the ghost. I'm trying to be conservative with API changes, but I keep forgetting this is an internal class.
 Yeah, I like even the idea of a non-optional closure with a default init value of an empty closure. 
 If we're getting into the nitty gritty I'm going to assume the non-optional version would take slightly more overhead in terms of space; or I could just be justifying the change I made and pushed before I saw your comment :)
 I mean, I _prefer_ things to be non-optional whenever possible just to limit the surface area of the API. It's why the `Cancellable` tokens didn't keep track of their cancelled state until now :stuck_out_tongue: If you don't feel strongly against the idea, I don't feel _that_ strongly about it. 

Though I would like to keep things consistent within Moya and adhere to Apple's general practice of using `() -> Void` instead of `() -> ()` if that's okay.
 @ashfurrow sorted. Cancellable tokens should keep track of canceled state because otherwise they're really just a glorified completion handler.
 > they're really just a glorified completion

Now you're getting it :wink:
 Don't furrow me bro
   :100: :ship: it
  Since we are going to merge a breaking change with #289 I'd like to propose that we change the completion block type.

From
`public typealias Completion = (data: NSData?, statusCode: Int?, response: NSURLResponse?, error: ErrorType?) -> ()`

To
`public typealias Completion = (response: MoyaResponse?, error: ErrorType?) -> ()`

This would allow people that do not use the reactive extensions to be able to use the helpful mapping functions and simplify the integrating with various json parsing libraries.

What do people think?
 Great idea! Thoughts @Moya/contributors ?
 On board with this. This is much simpler. I was kind of wondering why it was broken up into 3 values related to response. 
 :100: 
 I think this should definitely be included in version 5.
 Hmm, super-interesting! I like it. Anyone else have feelpinions? 
 Well, I'd rather have a result type, because otherwise everyone's just going to be writing `let e = error as! MoyaError`, but what do I know checked exception bleh etc

(looking at you, Lattner)
 I have a massive PR incoming btw that addresses this issue plus a bunch of other stuff; this approach is better than our strange disjoint union of optional types.
 > Well, I'd rather have a result type, because otherwise everyone's just going to be writing `let e = error as! MoyaError`

@swizzlr I agree with that, at least with Swift's current shortcomings when it comes to specifying throwable error types. Leaving our known error type declared as `ErrorType` in the completion block requires a cast back to `MoyaError` to work with. 

What about the original idea, but with the explicit error type:
`public typealias Completion = (response: MoyaResponse?, error: MoyaError?) -> ()`

That also aligns more closely with the RAC signal type for requests:
`public func request(token: Target) -> SignalProducer<MoyaResponse, MoyaError>`
 I'm not a fan of the double-optional parameters, just because there's this weird state where both are nil that no one is quite sure what to do about and mostly ignore it. A result type feels like a reasonable compromise. 
  That's odd ‚Äì can you upload a project that demonstrates the error somewhere?
 :+1: Glad it worked out. 
  There was a lot of repetitive code in the reactive extensions for the mapping to different types. Decided to move those to an extension on `MoyaResponse` to be reusable. I also noticed that the tests for RACSignal were not in the test target so I fixed those up as well.

Changlog:
- Fix RACSignal tests not being run
- Update RACSignal tests to make them compile
- Create mapping helpers for MoyaResponse as an extension
- Change reactive extensions to use MoyaResponse mapping helpers
- Remove unneeded force unwrap in reactive extension's `request` method
 Fantastic work, as usual! We could add **Breaking Change** to the changelog entry just to be super-clear. 

I've learned never to merge things before coffee; will do a final review later (unless someone beats me to it!).
 Ah, clever! 
  Hmm, this could be accomplished using the custom parameter encoding block, but I agree it's a bit awkward. Maybe we could look around ways to make it easier to use custom encoding (or including an implementation that works with GraphQL? Is Alamofire doing anything lime this?). Regardless, a good solution to this issue should include good documentation and maybe even an example project :cake: 
 Agreed about the black-box functionality. Would making the `GraphQLQueryType` an associated value on the enum help? Not too much. Hmm. 

It could be a lot cleaner if the custom parameter encoding closure had access to the `endpoint` (or the target, I suppose). We only use that closure signature because we pass directly into Alamofire. If expanding it would help, that seems like a cool idea. 

I've not thought the issue through as much as you have ‚Äì what sort of obstacles would that present?
 Hmm, yeah. I mean, I know GraphQL is getting more popular so I think we should consider first-party support at some point. But for now I'm fine leaving it up to the user. 

This is what I was thinking of, probably not a huge improvement.

``` swift
let parameterEncodingEnpoint = { (target: GitHub, request: URLRequestConvertible, parameters: [String: AnyObject]?) -> (NSMutableURLRequest, NSError?) in
    // Instead of accessing the parameters dictionary to construct body,
    // You can access associated values of the target directly.
}
```
 A protocol, "ParameterEncodable" might be a good plan. We could add conformance for dicts to keep previous behavior, and then allow further smarts by providing a "GraphQLNode" struct (or let the users define it as an optional third party extension to Moya, until such time as it's a huge demand).
 @thomasmarsh I think that using the custom parameter encoding solution would be the easiest workaround. Let us know how it goes!
 @justinmakaila I've since used a GraphQL API, want to pick up the conversation on this? How did the framework go? 
 I'm afraid that I haven't used GraphQL with Moya yet, if you find things non-obvious, I'd love to see a PR adding GraphQL to our documentation üéâ
 Dope, just realized that my email response never sent:

@ashfurrow I wrote a simple framework that provided typed interfaces for GraphQL structures. You could then use the `description` property to build the proper strings. I implemented this around Moya like so:

``` swift
enum APITarget: TargetType {
    case graphOperation(GraphQLType, [String: Any])

    public var path: String {
        switch self {
            case .graphOperation:
                return "graphql"
            // ...
        }
    }

    public var method: Moya.Method {
        switch self {
        case .graphOperation:
            return .post
        default:
            return .get
        }
    }

    public var parameters: [String : Any]? {
        switch self {
        case let .graphOperation(operation, variables):
            return [
                "query": operation.description,
                "variables": variables
            ]
        // ...
        default:
            return nil
        }
    }

    public var task: Moya.Task {
            return .request
    }

    public var sampleData: Data {
        case let .graphOperation(operation, variables):
            // Your sample response based on the operation here
        // ...
        default:
            return Data()
    }
}
```

Turns out my initial issue with sending a raw string wasn't necessarily an issue with Moya, per se.
 @ashfurrow the framework went wonderfully for my use case, it's OS on my
profile.

I ended up just using standard JSON encoding to send queries/variables.

Not so familiar with Apollo though.
On Mon, Oct 24, 2016 at 05:14 Alex H√ºllmandel notifications@github.com
wrote:

> Hey @ashfurrow https://github.com/ashfurrow! Do you use GraphQL in
> combination with Moya? Is there any update on how to make parameter
> encoding more generic? I'm very new to GraphQL and try to integrate Apollo
> iOS https://github.com/apollostack/apollo-ios with how I use Moya and
> Alamofire to make network requests.
> 
> ‚Äî
> You are receiving this because you were mentioned.
> Reply to this email directly, view it on GitHub
> https://github.com/Moya/Moya/issues/290#issuecomment-255688417, or mute
> the thread
> https://github.com/notifications/unsubscribe-auth/ABkCVG8d1rhUmoGcPFWAenJMFhCN7IACks5q3HbZgaJpZM4GeTZL
> .
 Seems like this has been resolved, please reopen if there's any other issues. :)  Travis is failing for Moya intermittently (see: https://github.com/Moya/Moya/issues/259 ). I've restarted the build to see what happens, and I'll take a look at the code now. 
 Yup, green now :smile: :green_apple: 

This looks great, fantastic work :100:

The `MoyaErrorCode` enum exists, but I feel like (given the direction Swift 2 has taken with error-handling) it may be time to retire it altogether and use just your new `MoyaError` enum. This would only change using Moya with ReactiveCocoa (maybe we could make corresponding changes for RxSwift). Any opinions on that? /cc @Moya/contributors 

There're a few tests I'd want to make sure we cover in `SignalProducer+MoyaSpec.swift` but we can sort those out later.

Updating the changeling is a good idea in the mean time ‚Äì right at the top under "Next". Make sure to mark them with **bold breaking changes** and give yourself credit. Thanks again for the awesome pull request ‚Äì we'll discuss it for a bit and get your changes into a release hopefully this week. Cheers! :coffee: 
 Agreed it's worth being thoughtful about their associated values. I'm not sure how I feel about the range specification. I _think_ I like it ‚Äì anyone else have feels?
 Very cool, I think this is a great way to handle errors üëç. 

A couple of thoughts:
1. Since Alamofire fails with `NSError`, I think it may make sense to type the associated value on `Underlying` to be `NSError` rather than `ErrorType`. This prevents confusion that there could be any other type given and thus need to do runtime identification of the type that we know at compile time. This would require re-typing `EndpointSampleResponse.NetworkError`'s associated error type as well, so that `Moya.Completion` could have it's error type be `NSError`.

In short, the Alamofire/"underlying" layer only fails with `NSError`, and since none of these status code filtration or data mapping functions exist in the non-reactive Moya core, it is the only error type to be dealt with, so we can benefit from some type specificity here.
2. With Swift's sweet pattern matching, I think you may able to trim some redundant code off of the `sameErrorType` function by switching on a tuple of the two values. Example:

``` swift
switch (self, otherError) {
case (.ImageMapping, .ImageMapping), (.JSONMapping, .JSONMapping) /*, etc... */:
    return true
default: 
    return false
}
```
 I am also on board with moving away from NSError pattern. Can we just put the NSError into the metadata in case it's needed as well StatusCodeErrorMetadata @tomburns suggested?
 Good point @tomburns, it's a bit of concision versus compile-time safety. I wish there was a prettier way to get the latter, but oh well. At this point it may be best to keep it your way, unless there's another, more concise way to get that safety that I'm not aware of.

Any thoughts on my first point above? Alamofire only uses `NSError`, so the `MoyaError` case that covers the domain of Alamofire errors should provide an associated `NSError`, not `ErrorType`.
 I personally like ErrorType ‚Äì it's convertible to NSError. 
 Just seems silly to declare things as ErrorType when we _know_ it's literally only _ever_ an NSError. Am I not understanding a benefit of doing it the other way? I'm not complaining, but I am truly not understanding, I guess. This is even the motivation behind parametric error types for ReactiveCocoa signals ‚Äì to not leave a signal that can throw deterministic error types to the open-ended `ErrorType` that could be anything, but to give a specific `ErrorType`-conforming type so that there is no nondeterminism about types at compile time. It _is_ convertible to NSError, but it also ALREADY is an NSError, hence my not understanding declaring it differently. And this only applies of course to the `Underlying` error case.

Think about the call point of the Alamofire request. The completion handler provided takes an NSError, which Moya gets back, and then (only ever) feeds as `Underlying`, which takes a more generic type than we know it to be. 
 Is there anything preventing Alamofire from converting to using `ErrorType` over `NSError`?  If they do that, Moya would have to push out a new version.  Not _at all_ a bad thing, and this is the kind of version bump that makes semantic versioning so relevant, but that _might_ be an argument in favor of the more generic `ErrorType`.

A way of justifying it philosophically might be: if we don't need / aren't consuming the features of `NSError`, then using the generic type indicates that we _aren't promising_ what type of error is coming down the wire.  If this error is coming from a dependency, then this lack of promise is honest - we know we'll get an error, but we can't promise what it will be.

I'm just catching up on this discussion, but these are my initial thoughts.  Gonna re-read now.
 The ability to write exhaustive catch blocks is actually a really good point. 

Let's try to remember that we're all after the same thing (writing great code) even if we disagree on how to get there. If it would help, I can schedule a Google Hangout to discuss some of the pros and cons. 
 Should an issue be opened on Alamofire? I do believe it would be an API breaking change but I think it's probably worth pursuing. The docs on swift errors suggest using the ErrorType pattern is the way to go. 
 We should look into the history of their error handling first. The changelog might reveal why they have it this way. 
 Coincidentally, their 'benefits to upgrading' to 3.0 is almost all about errors.

I think the part that may be of interest is the custom wrapping of any NSError to a type of our choosing. 

https://github.com/Alamofire/Alamofire/blob/0cb96d59ad47be1b6f5018188fcfd1d6b0ecbb0c/Documentation/Alamofire%203.0%20Migration%20Guide.md#benefits-of-upgrading
 Cool, not sure where we stand on this one ‚Äì anything stopping it from being merged? 

In the mean time, I'm going to merge https://github.com/Moya/Moya/pull/291 because it has no breaking changes, and it'd be cool to include its changes in a point release before this one (so people can have just those changes if they want). 
 Cooooool yeah sounds great! There've been changes on master since this PR was submitted, @tomburns could I ask you to merge from master?
 Cool, seems good to me. If someone else could give this a final one-over and merge, that'd be :100: Good work everyone :balloon: 
  Cool, that approach sounds reasonable. @justinmakaila @petester42 do either of you have opinions about it? Whatever is more idiomatic for RAC 4. 

To be honest, I'd be OK with deprecating [`request()`](https://github.com/Moya/Moya/blob/136e3260e03a2d2e01ea6d9604e354ff3f9ed55d/Source/ReactiveCocoa/Moya%2BReactiveCocoa.swift#L39-L41) and shifting the responsibility to call `toRACSignal()` to the user. Thoughts?
 I think they'll just get an error like they do now, it's just it'll be an `NSError` cast from this new type instead of an `NSError` we construct presently. I like that change, but we'll need to bump Moya up a major version to adhere to [semantic versioning](http://semver.org) :checkered_flag: 
 Gonna go ahead and close this since #289 is merged. Nice job on this again @tomburns 
  Hmm, this is a question that has not come up before. Generally, there's [no all-purpose solution](http://stackoverflow.com/questions/28131329/how-to-install-projects-without-cocoa-pods) to using a CocoaPods library without CocoaPods. If you must integrate normally, dragging in the Moya files in the `Source` directory should age good, but you'll need to remove RxSwift and ReactiveCocoa files if you aren't using them, also integrate Alamofire, and remove the `import Alamofire` statements from the Moya files. That _should_ do it ‚Äì let me know if you run into issues. 
 Instead of dragging in Xcode projects, try dragging in the individual swift files. 
 It might be worth doing what AFNetworking does and just not supporting manual installation, you need to have a lot of prerequisites set up for Moya, and the more useful interesting stuff can only really happen when you have a larger dependency graph, of which doing manually is just a waste of time.
 Agreed. 
  Neat! Might go well with https://github.com/Moya/Moya/issues/73 if anyone is interested. 

Agreed with your concerns ‚Äì getting this to be an optional part of Moya will be tricky. Suggestions welcome!
 Nice idea, @DanielTomlinson. I guess this could be part of the `path` within `MoyaTarget`? However, I can see this to be difficult to implement in a generic way.
 I've added this for consideration to the v5 milestone, since now's the opportunity to break APIs (though not too much).
 Is this something we might be able to take on for `8.0.0` still? Not sure how this would fit in the API as it stands right now. @Moya/contributors, anyone? At first look, this seems doable with the associated values approach that we use--though might not be the most elegant way to handle it. Should we close this? I think it'd be nice to see if we can improve here in the future.  Sounds good to me. Looked at this more and took a look at @kylef's [URITemplate](https://github.com/kylef/URITemplate.swift).

I'm not sure I see the advantages to incorporating it here. This is what our current approach would look like:

```swift
var path: String {
  switch self {
  case .repo(let user, let repo):
    return "/\(user)/\(repo)"
  }
}
```

Using the approach from `URITemplate`, we could get something like this:

```swift
var path: String {
  switch self {
  case .repo(let user, let repo):
    return uri(template: "/{user}/{repo}", values: ["user": user, "repo": repo])
  }
}
```

This would introduce more expensive and fragile Regexes into constructing paths, has fewer compiler checks, and doesn't really look more readable to my eyes (granted Swift's string interpolation looks kinda ugly in paths).

Using reflection, I could get something like this:

```swift
var path: String {
  switch self {
  case .repo:
    return uri(template: "/{user}/{repo}")
  }
}
```

That does look nicer than the previous example, but it adds the additional drawbacks of requiring that the tags of the URI template match the order and number of associated values in the enum case, so it would be harder to associate any values not in the URI with the enum case. Also, you wouldn't actually be matching the tags--you could use "/{dog}/{cat}" and get the same result.

So at least in my opinion, our approach is superior because no regex and compiler checks. Maybe I am missing something though? ü§î I agree, and think our approach is better, at least according to Moya's vision:

```
Some awesome features of Moya:

- Compile-time checking for correct API endpoint accesses.
```

Which I think the current approach seems to do. Closing this. If anyone disagrees or has an even better solution, please feel free to reopen. Thanks for weighing in, @kylef! I think it's a really great tool, just not for Moya. :)  This should close #241 when it is finalized. The carthage targets should work but I am seeing errors when I run `pod lib lint`. Not sure what to do about it. The error is as follows:

```
 -> Moya (4.3.1)
    - ERROR | [Moya/ReactiveCocoa] xcodebuild: Returned an unsuccessful exit code. You can use `--verbose` for more information.
    - NOTE  | [Moya/ReactiveCocoa] xcodebuild:  <module-includes>:2:9: note: in file included from <module-includes>:2:
    - ERROR | [Moya/ReactiveCocoa] xcodebuild:  /var/folders/z3/llmwqlln7pz907z5596pjct80000gp/T/CocoaPods/Lint/build/Release-watchsimulator/ReactiveCocoa.framework/Headers/ReactiveCocoa-Swift.h:94:9: error: 'ReactiveCocoa/ReactiveCocoa.h' file not found
    - NOTE  | [Moya/ReactiveCocoa] xcodebuild:  <unknown>:0: error: could not build Objective-C module 'ReactiveCocoa'
    - ERROR | [Moya/ReactiveCocoa] xcodebuild:  /var/folders/z3/llmwqlln7pz907z5596pjct80000gp/T/CocoaPods/Lint/build/Release-appletvsimulator/ReactiveCocoa.framework/Headers/ReactiveCocoa-Swift.h:94:9: error: 'ReactiveCocoa/ReactiveCocoa.h' file not found

[!] Moya did not pass validation, due to 3 errors.
You can use the `--no-clean` option to inspect any issue.
```

Besides that it should be ready to go. 
- Adds tvOS and watchOS support
- Fixes carthage OS X target not having source files
- Makes base OS X target 10.9 instead of 10.10
 Looks :100: I have an idea about the lint failures ‚Äì will let you know. 
 Hmm. No dice here. Looks like it's problems with RAC on the watch/tv platforms. I'll try to look into it shortly. 
 Getting the same errors. Makes me think it's a problem I made with the podspec. I'll take a look at it tomorrow with @orta and see if we can get this merged. 
 Sure thing, hit me up when you get in to the office
 Alright, so it looks like the watch isn't getting `ReactiveCocoa/ReactiveCocoa.h` - it's likely from [this](https://github.com/ashfurrow/ReactiveCocoa/blob/v4.0-alpha.3-podspec/ReactiveCocoa.podspec#L48) subspec not providing a watch/tvos reference to the source files.

I did something like this for [Artsy Authentication](https://github.com/artsy/Artsy-Authentication/blob/17ceee99c3b3170a49b5fca7f7650f94f40e1de9/Artsy%2BAuthentication.podspec#L26).
 I've pushed up an updated podpsec to trunk that should deal with the problems: https://raw.githubusercontent.com/CocoaPods/Specs/92a7990f1f521367d3c4a1274d3ca37564973054/Specs/ReactiveCocoa/4.0.3-alpha-3/ReactiveCocoa.podspec.json
 Validating now. 
 <img width="403" alt="screen shot 2015-11-06 at 10 15 58 am" src="https://cloud.githubusercontent.com/assets/498212/11000374/65b1df06-846f-11e5-8c53-5b17c7e3b98d.png">
 Pushing up an update now. 
 Alrighty! Moya now supports iOS, OS X, watchOS, and tvOS: https://raw.githubusercontent.com/CocoaPods/Specs/2589039691ec831ba080994a5f4387306260da22/Specs/Moya/4.4.0/Moya.podspec.json

Thanks for all the hard work @petester42!
  Fab :cake: Gonna merge manually ro run a `pod install`. 
  Super, this looks great! Did the podspec already get updated? 
 No problem, it passed CI :)
  Removes some redundant code similar to #278.

Also, I added the changelog to the Xcode project so it's easier to find, and did a `pod install`.

@petester42 would you mind reviewing this one and merging when you're comfortable with it?

Fixes #276.
 Cool! I like the matching, but the empty return type is probably unnecessary. We don't specify `-> ()` when creating the obervable, either. Wanna take those out? Otherwise looks :100:
 Cool, great work! 
  Howdy. Please forgive me if I am wrong here. I've been working with the Swift version (v4) of ReactiveCocoa for a week or so.

I was reading this code: https://github.com/Moya/Moya/blob/3cd402cfddf2b361b6251de6d24214758ae54511/Source/ReactiveCocoa/Moya+ReactiveCocoa.swift#L20-L47

and it looks a lot like there's a redundancy. The outer producer, when started, starts the inner signal, and seemingly just pipes the events from inner -> outer, and links the inner disposable to dispose when the outer does. The outer producer seems superfluous.

As an experiment, I reduced it down to this:

``` swift
public func request(token: Target) -> SignalProducer<MoyaResponse, NSError> {

    // Creates a producer that starts a request each time it's started.
    return SignalProducer { [weak self] observer, requestDisposable in

        let cancellableToken = self?.request(token) { data, statusCode, response, error in
            if let error = error {
                observer.sendFailed(error as NSError)
            } else {
                if let data = data {
                    observer.sendNext(MoyaResponse(statusCode: statusCode!, data: data, response: response))
                }
                observer.sendCompleted()
            }
        }

        requestDisposable.addDisposable {
            // Cancel the request
            cancellableToken?.cancel()
        }
    }
}
```

And it still works as-expected, and unit tests pass. So am I missing a specific reason or behavior of producers that requires it to be the first way in some specific scenario? If there is, please explain if you're willing, I'd love to understand and improve my RAC-fu üëäü§ì. Otherwise, I will PR this.
 Interesting ‚Äì I think it's likely a relic of when we were keeping track of inflight requests, and deduplicating new ones. I think @justinmakaila would be able to give a concrete answer about it. 
 Coooool, @JRHeaton did you want to open a PR? 
 Yes, will do. Thanks for verifying! :+1: 
 Going to reopen this, as @petester42 pointed out the issue is in the RxSwift provider, too. 
  Hi there. I really like Moya, yet it's currently not set up ideally for people wanting to install via Carthage, or even manually integrate with target dependencies. I've updated the project in a few ways to make things better for those people, and not affect the situation with CocoaPods. My motivation for doing so is that it's currently impossible to install [Mantle](https://github.com/Mantle/Mantle) and the latest ReactiveCocoa at the same time via CocoaPods. I'm attempting to build a framework that depends on Mantle, RAC, and [Reactive]Moya.
### Carthage Changes
- An Xcode project has been made with 3 shared iOS framework targets: `Moya`, `ReactiveMoya`, and `RxMoya`. 
- Each of the 3 targets has been set up to link against built `RAC`/`RxSwift`/`Alamofire` products in `Carthage/Build/iOS`, which will happen magically when installing Moya to another project, and can also be done locally for development using `carthage update --use-submodules --platform iOS` to install and build them.
- A proper `Cartfile` for installing deps either locally for development or through another project's `Cartfile`. This now includes all of the dependencies that are needed to build each of the 3 Moya framework targets.
- Now that a Carthage install of Moya doesn't need `Pods.xcodeproj` to work anymore (the symlink `_Carthage.xcodeproj` has been removed), there is no need for the pods-installed RAC to build to build Moya. This removes that redundancy and _saves time_.
### CocoaPods changes

For the most part, none. The `Demo` project remains in-tact and the same, still hosting the unit tests for this library and being set up ahead of time with `pod install` for CI and such.
- Updated RAC dependency to the latest version released.
- It made sense to move the shared source code of Moya to `Source/` instead of `Moya/`.
### What does this mean for maintenance?
- Source file references need kept up-to-date in the Xcode project with the framework targets.
- Align the dependency versions of `RAC`/`RxSwift`/`Alamofire` in the `.podspec` the `Cartfile`.
### In simple terms
- CocoaPods users of Moya will see no changes, other than a newer RAC version. 
- Carthage users of Moya now have the lovely advantage of Carthage itself resolving the deps of Moya.
- It's not much extra work for authors :)
### Tests

Unit tests are currently still in the Demo project as a separate target as before.

Also, I'm unsure about it for this project, but `Cartfile.resolved` may be unnecessary to track. 
 Hey there! Gotcha ‚Äì a few things. You'll need to pull in changes from master (tests there [are currently :green_apple:](https://travis-ci.org/Moya/Moya)). If Carthage no longer relies on the Demo Xcode project at all, then we can stop checking in `Demo/Pods` altogether, and also stop duplicating changes in our pod specs for RxMoya and ReactiveMoya. 

At first glance, this change looks good to me :+1: We've been keen to avoid splitting in two, because we had previously tried splitting up the Moya _repo_, which didn't work. Keeping it all here would be fine imo. Let's see if anyone has any comments. 
 Cool, I've made the changes you mentioned, fixed a couple of things, and set the iOS deployment target to iOS 8.0 to match the podspec.

 I've been giving some other things a bit of thought...
- ~~What purpose do/did the separate Rx/RAC Moya podspecs have?~~
- What would be the correct rDNS company identifier to use for these targets' bundle identifiers?
- Should I add a step to the CI script to run `carthage checkout --use-submodules; carthage build --platform -iOS --no-skip-current` (verify that things resolve & build via Carthage)?
 Oh, hmm. Current ones are `com.ashfurrow.Demo` ‚Äì not really appropriate anymore. Are the important in Carthage? If we just need one, `com.example` is fine.

The podspecs provide Carthage-compatible build targets in the Xcode project, but also complicate unit tests. I don't believe their needed after this PR ‚Äì getting rid of them would be :100:
 Heh, oops, I updated that comment right as you replied. The identifier will be set as the bundle identifier of the built product, so it probably would seem a little weird to see a shipping app embedding a `com.example.ReactiveMoya` bundle, for example. I'll go ahead and remove the podspecs from this branch though :smile: 
 Well, there _really_ isn't much more work to do. Making sure the targets reference the right files is a matter of seconds of work, and only on the occasion that you actually add or remove a file. How often is that, and is the extra 15 seconds to open the project and drag in the file truly "a lot of work?" Definitely not any "duplicate" work that I can think of. The podspec in most cases should automatically work with file changes if the patterns still match said files. 
 I've just tried, works pretty well. Good work, @JRHeaton!
 Yea I like this. Maybe could use some documentation? Time for a Contributing.md file? 
 Also I think that adding a CI step to verify carthage is a good idea. Does anyone know if its possible to run 2 CI steps, one for unit tests one for CP/Carthage install testing?
 It‚Äôs possible to override Travis‚Äô script command and do both.¬†

--¬†
Ash Furrow
Sent with Airmail

On October 27, 2015 at 12:39:36 PM, Alexander Schuch (notifications@github.com) wrote:

Also I think that adding a CI step to verify carthage is a good idea. Does anyone know if its possible to run 2 CI steps, one for unit tests one for CP/Carthage install testing?

‚Äî
Reply to this email directly or view it on GitHub.
 So as it turns out, the two extra podspecs may be required after all. With Rx and RAC variants only available now as subspecs of Moya, there isn't a way to install Moya/RxMoya/ReactiveMoya as separate modules into the Demo app. Trying to install both subspecs will build both RxMoya and ReactiveMoya sources under the 'Moya' pods project target, which will have conflicts (for example, the public `Image` typealias that exists in both source bases).  So is the best solution just to keep them?
 This is why they were originally added ‚Äì Carthage does not have any concept of a subspec, and the maintainers refuse to accept one to encourage smaller libraries. To get rid of them, we would need multiple Xcode projects for Carthage? If we need to keep them, what's the concrete difference with and without this PR to someone using Carthage?

This is, like, my least favourite part of software development. I'm sure others feel the same. Thanks for the hard work everyone ‚Äì don't forget that this is volunteering, not your job. Don't burn out! If you need to step back or take a break, do it. 
 Heh, except I'm trying to use Moya at my job. ;)
Definitely not the highlight of software development, but we're all smart people and we're getting closer :+1: And indeed thanks to everyone who has commented and helped out so far.

So to clarify a bit, this isn't an issue with Carthage, it's an issue with the Demo project and its test target needing to test all 3 modules. Carthage doesn't require a concept of a subspec because it just builds any shared framework target, from a regular old Xcode project. You can configure any number of framework targets in any way you want, with any sources you want. This is why we have 3 targets in one project, Moya/RxMoya/ReactiveMoya.

So the issue is that _Without_ separate podspecs for the `Demo` project, there's no way to install 2 different subspecs as separate targets. For example:

``` ruby
pod 'Moya', :path => "../"
pod 'Moya/ReactiveCocoa', :path => "../"
pod 'Moya/RxSwift', :path => "../"
```

Now the sources of all three of those are trying to be built into one framework target by pods, which doesn't work. I think that these may have originally been made to, as you've outlined, build proper framework targets for Carthage to use, but what I think was not realized is this fact, that the tests in the Demo project _also_ depends on there being all 3 frameworks.

There are a lot of refinements for Carthage on this PR, the most important one is that now dependencies of Moya are resolved _through Carthage_, and it isn't relying on an underlying pod install to be set up properly. Before, even with the dependencies listed in the Cartfile on master, that means those projects are having to be built twice. Once in the pods project, once in Carthage. This not only takes time, but lately it's been a 100% dead stop for my team trying to use Moya since the RAC podspec was broken for a while, and now Mantle's is as well, hence our usage of Carthage. I guess you could say this PR enables one to unhook from needing any work done from pods when you're using Carthage.

Regarding CI, I have been trying to think of a reasonable way to test Carthage stuff on Travis. Since iOS framework targets require code signing though, and some of our dependencies, like Alamofire, leave the default identity value as "iPhone Developer", Carthage skips building their targets, which is obviously an issue, as _our_ targets depend on them. Some of them do properly build for the "iphonesimulator" sdk, and I'm not sure how they set up their projects to do that, but I will investigate it and apply it to the framework targets in this project. The remaining issue though is that we'd need those dependencies to also update their code sign settings in the same way, which is hard to count on.
 Reading the rest of your comment, though the following with CocoaPods:

``` rb
pod 'Moya', :path => "../"
pod 'Moya/ReactiveCocoa', :path => "../"
pod 'Moya/RxSwift', :path => "../"
```

Works fine. 

EDIT: I see you clarified after ‚Äì was reading the email >.<
 Not clear on the need to use Carthage, but that's fine. I realize Mantle complicates things. 

Yeah, we know that the tests are using different frameworks. In an ideal, CocoaPods world, we would build _one_ Moya framework with all the subspecs. But we need to accommodate Carthage, so we instead have these extra podspecs for them. It leads to duplicated code in the tests because there are several different `MoyaTarget` protocols depending on which framework you've imported. 

This conversation is getting pretty lengthy ‚Äì I'm not even really sure what we're trying to accomplish anymore :confounded: Would hopping on a Google Hangout help? 
 > In an ideal, CocoaPods world, we would build one Moya framework with all the subspecs.

What i'm saying is that this is not possible currently, because code from RxMoya conflicts with code from ReactiveMoya. 
For a concrete example, the definition of `Image` in both of these files:
- https://github.com/Moya/Moya/blob/master/Moya/RxSwift/Observable%2BMoya.swift#L5
- https://github.com/Moya/Moya/blob/master/Moya/ReactiveCocoa/SignalProducer%2BMoya.swift#L5

Basically, compiling all of the Moya source code in one build target will not work without some source modifications, so I put the separate podspecs back. That work, including reducing down unnecessary tests, can be done on a separate PR.

The goal is still the same for this PR: restructure things a bit so that the project "natively" supports Pods _and_ Carthage.  That part is done. Can we come up with a concrete list of things left to do that are required to consider this PR ready? I'm more than happy to do the work and finish it up, I just need to know what's actually required. Otherwise, if you feel there's more to discuss, and perhaps too much for here, I'm not opposed to a call.
 OK, cool. I think this PR is ready for final review.

One side-note:

> compiling all of the Moya source code in one build target will not work without some source modifications

This `typealias` is currently the only duplicated symbol ‚Äì it should be moved into the ReactiveCore group and defined _once_. Other than that, you could use all subspecs in the same CocoaPods project. 
 Looked through the [raw diff](https://patch-diff.githubusercontent.com/raw/Moya/Moya/pull/267.diff) ‚Äì all looks :+1: 
 OK, so we need contributing docs, deduplicated `Image` typeliases, and see if we need the extra podspes.
- https://github.com/Moya/Moya/issues/270
- https://github.com/Moya/Moya/issues/269
- https://github.com/Moya/Moya/issues/271

Anything I'm missing @JRHeaton ?
 Looks correct to me :+1:. Thanks for going ahead and making issues for those.
  :bow:
  I am getting 

```
A shell task failed with exit code 66:
xcodebuild: error: Scheme Moya is not currently configured for the build action.
```

when running `carthage update --no-use-binaries --platform iOS`
 Cool, so we just need CI + merge from master + changelog update. 
 Looks like ReactiveCocoa was updated in https://github.com/Moya/Moya/commit/535d7a1b03673f9097f89686b2845cc7685cbba8#diff-51d740005a289b6c12f9ba0fe81dc8db ‚Äì does that sound right? 
 Cool, thanks for checking!
  Cool! I can handle updating the tests. What's the lint error?
 Awesome! I'll take a look at tests when I get home. Thanks again! 
 Going to merge this as-is; I've opened https://github.com/Moya/Moya/issues/265 to address the CI. Thanks!
 Hey, so that's a great question. Normally, tags are created with the [automated release task](https://github.com/Moya/Moya/blob/3f657edb6dcb2346754d65828b898e2b58cf95a4/Rakefile#L28). I just forgot to run the task after merging this >.<
 New version is up: https://raw.githubusercontent.com/CocoaPods/Specs/87704665c95c9c49e1324991ee94142c3504ded6/Specs/Moya/4.1.0/Moya.podspec.json
  :+1: This looks good
  You just need a new tag for Carthage, right? Can do :)
 Cool, I've created https://github.com/Moya/Moya/releases/tag/4.0.2-carthage ‚Äì let me know if that works!
 As long as the new release didn't re-re-introduce the problem :sweat_smile: What did the fix turn out to be, so we can integrate it into our deploy script?
 OK, cool. This commit ( https://github.com/Moya/Moya/commit/d0d30b1ce98972ce30d4a5b7b2be0aa3d7b43fe3 ) got released as 4.0.3 tag. My guess is an older version of CocoaPods was used to deploy the problematic release. Let me know if it works. 
  Not sure what caused it. Looks like a problem with Xcode (go figure).

```
The following build commands failed:
    CompileSwiftSources normal x86_64 com.apple.xcode.tools.swift.compiler
(1 failure)
2015-10-22 00:38:04.847 xcodebuild[769:3065] [MT] IDETestOperationsObserverDebug: (357FE833-30CF-44F9-9DD3-7F464EB8F250) Beginning test session with Xcode 7A220 on target <DVTiPhoneSimulator: 0x7f99c2cdecf0> {
        SimDevice: SimDevice : iPhone 6 (CEBBD79A-B6C1-4A02-BD33-56BBCBDED03E) : state={ Shutdown } deviceType={ SimDeviceType : com.apple.CoreSimulator.SimDeviceType.iPhone-6 } runtime={ SimRuntime : 9.0 (13A340) - com.apple.CoreSimulator.SimRuntime.iOS-9-0 }
} (9.0 (13A340))
2015-10-22 00:38:33.992 xcodebuild[769:4353] Connection peer refused channel request for "dtxproxy:XCTestManager_IDEInterface:XCTestManager_DaemonConnectionInterface"; channel canceled <DTXChannel: 0x7f99c33d1c20>
Testing failed:
    Command /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/swiftc failed with exit code 1
** TEST FAILED **
```
 Misery loves company :)
 Hmm, we're actually not seeing this problem anymore. Going to close the issue. 
 Looks like I spoke too soon. 
 Can't hurt!
 Cool, so this is hopefully fixed in #317, but let's keep this issue open for a while to make sure.
  How are you installing Moya? CocoaPods? What does your podfile look like? Xcode 7, right? Did a clean build produce a different error? 

## 

Ash Furrow
iOS Developer, Author
http://ashfurrow.com

> On Oct 21, 2015, at 9:01 AM, istvanelekes notifications@github.com wrote:
> 
> ‚Äî
> Reply to this email directly or view it on GitHub.
 Interesting! Could you send a pull request? 
 Since #261 is merged, I'm going to close this. If it's still a problem, please re-open!
  Clever! Couldn't have done it better myself. I don't think this needs any unit tests ‚Äì could you add an entry in the changelog? We'll give people a day to look at #256 just in case, and we'll get this merged! Thanks for the PR :100: 
 Looks good, @nosrak113. :sparkler: 
 Released in https://raw.githubusercontent.com/CocoaPods/Specs/23ec77d5074667f94cc3820123b8e18fad5061fe/Specs/Moya/4.0.2/Moya.podspec.json as 4.0.2.
  Hmm, neat idea! I don't see a downside to it, other that we'd be leaking out information that a developer could misuse... Doesn't seem like a big risk to me. We'll give it some time for anyone else to chime in and then whip this up!

@nosrak113 If you'd like, I can give next steps for how you could submit a pull request to add this feature. No pressure ‚Äì just let me know if I can help!
  Fantastic, thanks a lot @bojan!
  Hey! Good question! The `onlineSignal` isn't a part of Moya, just our app. I actually just sent a PR changing the behaviour of the `onlineSignal` ‚Äì maybe that would help answer your question? https://github.com/artsy/eidolon/pull/527
  This looks OK to me; not too ¬´savy¬ª on `Carthage`; but not providing the last part of the `semver` will still work and will pick up minor releases?
 In my experience with Carthage, the last version (`2.0.2`) is picked up.
 Thanks @aschuch.

I think it won't hurt to merge this change.

Thanks
  :+1:
 Shouldn't the Cartfile specify `~> 2.0` instead of `~> 2.0.2`? Not sure about the exact implications of this, but pinning to a major version seems to be the better choice here. Opinions?
 Go for it :)
  Looks great, thanks!
  Hi there. I've noticed that this library is set up to resolve its own dependencies via CocoaPods, but shares the Pod project's framework targets to be built as shared so that Carthage can see them. So far so good.

The "issue" is that when installing Moya via Carthage, if you were to simply list Moya itself as a dependency, it will not fetch for example, Alamofire, which is a mandatory dependency of Moya.

Thus, our app that uses Moya must have the following entries in the Cartfile (since we also use ReactiveMoya):

```
github "Alamofire/Alamofire" ~> 2.0.2
github "Moya/Moya"   ~> 2.4.1
github "ReactiveCocoa/ReactiveCocoa" "swift2"
```

I think this can _possibly_ be remedied by including a Cartfile for Moya in the root of the repository that lists the dependencies. It won't need to be used obviously during development of Moya, but will provide a way for Carthage to know which deps to download + build. At the very least, I feel like this should be detailed in the README so that people don't have to debug this.
 I've also realized another fault due to Moya's project dependencies coming from the podspec. We are attempting to install Moya via Carthage with yesterday's Xcode beta, and using the `swift2` branch of ReactiveCocoa. Moya builds its own version of RAC that comes from its pod dependency on it. Because of this, and since it's an older version of RAC than we actually depend on, Carthage fails to build Moya's RAC w/ the beta command line tools.

The way this project is set up for Carthage is seemingly less than ideal. Is there some way that it can be changed to better support it (while retaining your support for CocoaPods)?
 Just brainstorming possible solutions here.

RXMoya, ReactiveMoya, and Moya could each have their own (shared) framework target inside of a dedicated xcodeproj (allowing carthage to build them), and then your subspecs could be kept to point to the same files still for people installing through pods. The demo project could install the library via either pods or carthage (or both, with two targets).
 We've gone through all this before, and eventually found that this was the least-bad ways to support Carthage users without placing an unreasonable amount of extra work on people maintaining and improving Moya. We're not moving to separate repos and multiple xcodeprojects to keep up to date for a a file or two per sub-project.

The alamofire PR looks like a good idea
 @orta There isn't a need for multiple repos as I understand it.  It's just having one single standard project w/ the 3 framework targets, and a Demo project that installs/uses it locally. Theoretically the Demo target(s) could even be in the same project file as the framework targets I think. The only maintenance I see being needed there is adding/removing references to source files to the framework targets when files are created/deleted, whereas they would be automatically included via the podspec's source file patterns.

When installed via Carthage, that project's 3 targets would be built and made available, as well as the dependencies listed in the Cartfile as expected. When installed with Pods, the podspecs work as they do now, generating targets to build etc.

Our team is currently working on a framework we plan to make available via Carthage, and would be nice to make usable via pods as well. So I'm genuinely interested from an author perspective what you feel the burdensome work deriving from such changes could be. It could help us save some time in the future potentially also :)
 Most projects will "just work" with Carthage,which is why I made `pod lib create` work with it by default and it's likely that most libs that ship with support come from CP. Moya seems to have hit the point where it was too complex to do it that way. A lot of this is in https://github.com/Moya/Moya/pull/215- but I'm afraid I'm going to decline your request for more information, given my position on the CP team.
 I don't see how most will "just work" ‚Äì factually, you are missing one single file at minimum that will _not at all disrupt your current setup_ (`Cartfile`) that is _required_ to have it checkout/build these frameworks, unless people want to use the ones Pods built (which requires going into the Pods build dir, rather than `Carthage/Build, and takes away dep version specification control from the depending target's Cartfile which is confusing to everyone). 
We ran into confusion at first when realizing Alamofire was missing when it's a direct dep of Moya, and then again when we adopted ReactiveMoya and ReactiveCocoa was missing. I can't quite see how maintaining a 2 line file is determined to be too much work; I think it could be at the very least a good compromise?

Otherwise, it reasonable to at least put proper usage instructions in the README? Saying use `github "Moya/Moya"` and that alone is gonna wind up with people going through the same aforementioned confusion, however brief (though this will be hard on beginner users of Carthage, which many are w/ it being new).

Also, not sure what's up with "declining request for information" (had a "whut" moment reading that actually) ‚Äì not only was it a pretty innocent request for opinion based on experience of what the "extra" work on similar goals we have was (in attempts of just understanding why not to properly support Carthage), but also stated that you're not saying anything because you work on Pods? I didn't realize there was a "don't use that guy's tool" war going on :'( Saying "we don't wanna support X because our Y will be supported by more people" serves only to perpetuate that truth. I was not trying to overstep or pry for information that isn't public or is special sauce... My apologies if I did. I will look at the PR you linked to and try to deduce what the deterrent was.

In the mean time I think we will just fork Moya and update it to support the dependency and Xcode versions we need. Thanks for the replies guys; no intention to come off abrasive, just want a better world where we can all use these sexy libraries without being constrained to certain dep managers :)

PS: fwiw as a random opinion, as someone who comes from a time before Pods/Carthage, it's also less desirable from a depending app setup that a library has no dedicated natural build targets for itself (in an xcodeproj) even with Carthage support not being considered. Makes manual integration via target deps + linking the framework impossible, as pods generating a project is the only way of building it.
 I agree with @gregpardo on this.

Like Orta stated already `Moya` grew to a ¬´too complex¬ª scenario where there's no ¬´works for all¬ª solution; I think supporting `Carthage` via the underlying `Pods` project works for _most_ of the cases and having a more ¬´detailed¬ª installation instruction for `Carthage` on the `README` would satisfy those scenarios not covered by the `Pods` project.
 Updating the README w/ proper directions for Carthage is an understandable compromise to the original issue topic. I think that is helpful from the perspective of someone using the library. :)

> The Cartfile is there now but I don't think it should include ReactiveMoya. Not all projects will need that dependency.

I think you mean `ReactiveCocoa`. While true, ReactiveMoya(+RAC) is already checked out + built anyway when Carthage builds all 3 framework targets in the Pods project (there are no subspec-specific installs w/ Carthage). Including RAC in the Cartfile would build that version into `Carthage/Build` (as expected anyway ‚Äì this will eliminate "hunting" for the build RAC result from Pods). Sure it will mean having 2 RAC builds, but that is already happening with the current setup (since dependent apps have to list it in their own Cartfile, breaking this rule here: https://github.com/Carthage/Carthage#nested-dependencies)
 That is correct, those all need checked out and built, though not all will need integrated into dependent targets (Rx/RAC mutually exclusive in this case).
 The only downside would be that for people installing Moya via Carthage with no intent to use the Reactive or Rx extensions will have to wait for Carthage to build its RxSwift and ReactiveCocoa checkouts. But this is sort of the nature of Carthage with there being no support for subspecs or any way to specify specific targets to build when checked out.
  I guess we haven't needed to set the request body directly. You can do that using the `requestClosure` if you associate a value with your enum case.

``` swift
let requestClosure = { (endpoint: Endpoint<YourAPI>, done: NSURLRequest -> Void) in
    let request = endpoint.urlRequest // This is the request Moya generates
    switch endpoint {
    case NeedsBodySetDirectly(let jsonArrays):
        let newRequest = ... // modify request to set the request body to encoded jsonArrays
        done(newRequest)
    default:
        done(request)
    }
}
let provider = MoyaProvider(requestClosure: requestClosure)
```

Our goal is mainly to abstract that messy stuff away and only do the mapping to parameters or body once, instead of at every request. 

Let me know if I can clarify anything.
 Is that a limitation of Swift's? As far as I know, you should be able to associate enums with custom types. 
 Ah yeah, thanks! We recently did a large rename and some of the documentation slipped throw :grimacing: 
  Continues some work done on https://github.com/Moya/Moya/pull/243. Mostly adding some newlines, removing an old file, and removing references to (defunct) inflight request tracking.

@petester42 I'll leave this up to you to review + merge? 
  Thanks a lot!
 :scream: beat me to it Ash :smile: 
  I think you can specify the specific branch of `RxSwift` on your `Podfile` with `tvOS` support and `CocoaPods` should be able to use the branch specified in the `Podfile` (as long as that doesn't break current implementation of `Moya`)
 ¬Ø\_(„ÉÑ)_/¬Ø  sorry; i thought you were trying to use a ¬´custom made¬ª `.podspec`.

It shouldn't take too much to support `tvOS`. I'll try to get to it today.
 Strange, our dependency on RxSwift is [~> 2.0.0-aplha-1](https://github.com/Moya/Moya/blob/a8a491bf14ab7ad4ce7793a204868fd05f03a4dd/Moya.podspec#L40). 

Esteban, it'd be great if you could do this ‚Äì I'm travelling and don't have good access to internet. If you need push rights for CocoaPods trunk, let me know. 
 @ashfurrow I just updated the `.podspec` to use `2.0.0-alpha.4` which is the one with `tvOS` support.

Also added all supported ¬´devices¬ª like so:

``` ruby
s.ios.deployment_target = '8.0'
s.osx.deployment_target = '10.9'
s.watchos.deployment_target = '2.0'
s.tvos.deployment_target = '9.0'
```

I can upload the `.podspec` but I can't push to trunk (I don't have push rights and the `pod spec lint` fails due to the dependency issue with `Alamofire`.

``` ruby
Resolving dependencies of
 -> Moya (3.0.0)
    - ERROR | [tvOS] unknown: Encountered an unknown error (The platform of the target `Pods` (tvOS 9.0) is not compatible with `Alamofire (2.0.2)`, which does not support `tvos`.) during validation.

Analyzed 1 podspec.

[!] The spec did not pass validation, due to 1 error.
```

We could have it living on a `tvOS` branch (the `.podspec`) while `Alamofire` merges that branch to `master` or makes an official release supporting it and people could use `Moya` for `tvOS` from our support branch.
 Sure ‚Äì it surprises me a library as popular as Alamofire doesn't have tvOS support on trunk yet. Putting the podspec on a branch for now sounds like a good plan. 
 Branch [`tvOS`](https://github.com/Moya/Moya/tree/tvOS) should address this.

Please @gregpardo test it and let me know if something is not working.

PS. I also modified the `Podfile` to use this branch
 Yeah; try to specify the `Podfile` like the `Demo` project in that branch => https://github.com/Moya/Moya/blob/tvOS/Demo/Podfile

Chances are you are missing this from the `Podfile`:

``` ruby
# Fix for `Alamofire` with `tvOS` support
  pod 'Alamofire', :git => "https://github.com/Alamofire/Alamofire", :branch => "tvOS"
```

---

_Bear in mind this is temporarily until `Alamofire` moves `tvOS` support to the `master`/official branch/release_
 Added 2 labels to it.

I think leaving it open would be better so we can keep it in mind.

I'll :lock: the issue though since it doesn't make sense to keep it open.

If any @Moya/contributors has other idea as to how to handle this I'm open to ideas.

Thanks for confirming the fix @gregpardo :bow: 
 Just noticed that when we merge `tvOS` with `master` we'll be able to close #192 as well since the `.podspec` on that branch already handles `OSX`, `watchOS` and `tvOS` :tada: 
 http://search.cocoapods.org/api/v1/pods.flat.ids.json?query=platform:tvos

tvOS support requires someone with the latest CP rc pushing, so it's got a pretty slow adoption ( plus my plugin undermines it somewhat )
 What an odd discrepancy. @Thomvis is there any reason the CocoaPods trunk version doesn't have TV support? 
 We should see an updated version tomorrow :)
 Result has been updated on Trunk: https://github.com/CocoaPods/Specs/blob/master/Specs/Result/0.6.0-beta.6/Result.podspec.json @petester42 are there any other that need updating? 
 Thanks to @Thomvis for his quick turnaround on that!
 OK, I've updated the [ReactiveCocoa podspec](https://github.com/ashfurrow/ReactiveCocoa/blob/v4.0-alpha.3-podspec/ReactiveCocoa.podspec) on my fork (see: [changes](https://github.com/ashfurrow/ReactiveCocoa/commit/6e9fcdaeeb7710289b57979e2e9ad68b69a6ffb6).)

Unfortunately, I don't have 7.1 installed at the moment so I can't validate + push to trunk. Will do when I get to NYC. 
 Oh, wait. Need to replicate `prepare_command` stuff. 
 Cool, did that: https://github.com/ashfurrow/ReactiveCocoa/commit/7dc4d95df1dd3166fb4acef6498662f695e55721 Just need to lint + push. 
 Opened https://github.com/ashfurrow/ReactiveCocoa/issues/4 to remind me
 Should be good to go ‚Äì validated with Xcode 7.1 just in case, and it worked :+1: 

https://raw.githubusercontent.com/CocoaPods/Specs/a6b9eb7156e4809e43056cd54b6f754d98be6150/Specs/ReactiveCocoa/4.0.1-alpha-3/ReactiveCocoa.podspec.json
 Make that `4.0.2-alpha-3` ‚Äì had a mistake in the podspec :grimacing: 

https://raw.githubusercontent.com/CocoaPods/Specs/112a7c37ff9e86ccb41c4e56a94ef55d7367658a/Specs/ReactiveCocoa/4.0.2-alpha-3/ReactiveCocoa.podspec.json
  This does a few things.
- All sample responses are now evaluated lazily, obviating the need for a `Closure` case in the sample response enum.
- The `EndpointSampleResponse` has been simplified. No one really understood what the difference between `Success` and `Error` was (looking at the unit tests, it doesn't look like _I_ even understood the difference).
- Adds documentation for authentication (HTTP and OAuth).
- Adds logging plugin based on @AlexanderKaraberov's work in #235).

Generally I really like how 3.0.0 has been coming along. Thanks to a lot of work from a lot of different contributors, Moya has gotten simpler and less complex, while also far more powerful. 

After this I thing we should go ahead and release 3.0.0 (see #236).

Fixes #200.
Fixes #220.
 Hey @aschuch ‚Äì you mentioned we can do in-place modification of the `Request` objects, right? I'm thinking that may be better than having the plugin functions return their own request ‚Äì less overhead. Thoughts? 
 Yup. Since `Alamofire.Request` is implemented as a class, we could simply modify the request object in place. There is no real need to return it, just illustrates the intent of the method and would be future proof in case `Alamofire.Request` might be changed to a struct or something.

I still think we could get rid of it now, can always change it back later...

Your implementation of the logger is pretty awesome as well :tada:
 OK cool. @aschuch I've pushed a change for that and would like your go-ahead: https://github.com/Moya/Moya/commit/55d8ed9eef1be7011247174a54a3ce77cb37c0df

The logger was a lot easier after @AlexanderKaraberov did all the work already üòÖ

One more thing ‚Äì I don't care for having to include Alamofire in the plugins. One of Moya's big selling points is that you don't have to care about Alamofire. We're leaking that up through our `manager` property and now the plugins. It's not a _huge_ deal, but I'd love to nip this in the bud. 

What if we created a new protocol in `Moya.swift` that included things in `Request` that you might want to do ‚Äì authentication, for example ‚Äì and then made `Request` conform to the protocol in an empty extension. The nice thing is since no one else uses the protocol, we can add more functions to it later if `Request` adds them, or if we forgot to add them. So expanding the protocol wouldn't be a breaking change. Thoughts? 
 Yeah, I like that a lot actually. Work is done in https://github.com/Moya/Moya/commit/d68c03e276a13f58c4ce3e185ca97042bcb5429b if anyone wants to discuss that specifically. 
 Looking good. 
I like the abstraction of the Request a lot. Much cleaner now. 
 @AlexanderKaraberov Yeah, just released 3.0! We'll be continuing to fix bugs that are reported, and implement features that are requested as they come up. If you have any ideas or suggestions, just open an issue :smile_cat: 
  I would like to propose a plugin system for Moya.
`MoyaProvider` can now be initialized with a set of `Plugin`s.  A `Plugin` receives callbacks to perform side effects wherever a request is sent or received.

For example, a plugin may be used to
- log network requests
- hide and show a network avtivity indicator
- inject additional information into a request

This kind of tackles #144 as well, as the number of additional closures is now much lower and can be initialized with an arbitrary number of plugins

I have also added plugins for the existing `CredentialClosure` and `NetworkActivityClosure` to make it easy for everyone to adopt this change. Maybe we should also try to build a plugin from the Logger in #235?

Would love to get some feedback on the idea or how to make this even more generic for everyone to use (I'm not super happy with the subclassing approach). :heart: 

Fixes #144.
 Generally looks great! I was a bit wary of the idea of "plugins", but I really like the implementation. 

I have a few pieces of general feedback:
- I saw the note about avoiding protocols ‚Äì let's see if we can think of something besides inheritance? Nothing comes to mind, though ...
- Should a plugin be able to distinguish between stubbed requests and real ones? 
- Maybe the plugin functions should accept the `manager` as a parameter? I dunno, probably unnecessary but it feels like something that _should_ happen. Thoughts?
- Could we call them something other than "plugins"? :stuck_out_tongue: 

Thanks again!

![](http://media.giphy.com/media/V2xbsCrxcLQSQ/giphy.gif)
 Thanks for the feedback. I'll push your remarks asap.
- First of, I don't really like the subclassing approach either. I tried a few things with protocols but none of them really seemed to work out. I'd love to discuss alternatives though.
- I decided to give the `Plugin` separate calls for stubbed requests and real ones, because the parameters are a bit different. This could, however, be abstracted into a single method on the plugin that accepts a stubbed/not-stubbed parameter.
- Could easily add the `manager` to the plugin functions, not sure what the plugin would do with it though. Do you have any use cases that come to mind?
- I am not too fond on the term _plugin_ either. Maybe _mixin_? _sideeffect_? I just named it plugin, because everyone is sort of familiar of this term. 

:boom:
 Ahhh, sorry I meant the `provider` parameter (through which, I guess, the `manager` would be accessible too).

I guess what I'm _really_ saying about the stubbed/not stubbed functions is that I don't think the plugin should even know if the request it's being called with is being stubbed or not. 

Nomenclature is hard, let's give it a think :)
 Also, I agree with using a logging plugin for this ‚Äì it looks like we're on board to go forward with this solution, so let's I'm going to close #235. Happy to recreate the logger from there as a plugin, if I could help. 
 And don't forget about the changelog! :poodle: 
 Wow :scream: 
Great idea and implementation @aschuch :bow: :ok_hand: 
 Ok, so I've removed the duplication of methods for stubbed/real requests and added the `provider` to the callbacks.

I have also put together a version [on a different branch](https://github.com/aschuch/Moya/commit/34c10bb4644868bc38a64cc84486549cfc556135) that shows how `Plugin` can be implemented in terms of a protocol. This requires a `PluginContainer` wrapper in order to keep a reference within `MoyaProvider` and satisfy the type system. 

I also tried to make  `PluginContainer` conform to `ArrayLiteralConvertible` to keep the API clean, but could not figure out a way to accept the type constraints.

``` swift
extension PluginContainer: ArrayLiteralConvertible {
    init<P: Plugin where P.T == T>(arrayLiteral elements: P...) {
        willSendRequestClosures = elements.map { $0.willSendRequest }
        didReceiveResponseClosures = elements.map { $0.didReceiveResponse }
    }
}
```
 Any opinions towards keeping the subclass vs. the protocol approach?
 Leaning towards protocols, personally. Will have time to review shortly. 
 Tricky problem ‚Äì I think the root of the issue is that we want the plugins to both be able to be used with any type of `MoyaTarget`, but refer to the specific type that's conforming to that target. 

What I mean is, I'm not sure we need to use a typealias'd protocol or a generic class. What about the following?

``` swift
public protocol Plugin {

    func willSendRequest<Target: MoyaTarget>(request: Alamofire.Request, provider: MoyaProvider<Target>, token: Target) -> Alamofire.Request

    func didReceiveResponse<Target: MoyaTarget>(data: NSData?, statusCode: Int?, response: NSURLResponse?, error: ErrorType?, provider: MoyaProvider<Target>, token: Target)

}
```

Even if someone wanted a plugin to support a _specific_ target type, they should be able to do that:

``` swift
class ExamplePlugin: Plugin {

    func willSendRequest<Target: MoyaTarget>(request: Alamofire.Request, provider: MoyaProvider<Target>, token: Target) -> Alamofire.Request {
        return request
    }

    func willSendRequest(request: Alamofire.Request, provider: MoyaProvider<HTTPBin>, token: HTTPBin) -> Alamofire.Request {
        return request
    }

    func didReceiveResponse<Target: MoyaTarget>(data: NSData?, statusCode: Int?, response: NSURLResponse?, error: ErrorType?, provider: MoyaProvider<Target>, token: Target) {

    }
}
```

@aschuch I'll send a PR over to your fork ‚Äì looking forward to hearing what you think. 
 Hmm, wait that might not work. Anyway, I'll play with it. 
 Nah, this is silly. You have a working solution, let's merge this PR and keep the idea of moving to a non-inheritance approach for another release. 
 Awesome. Thanks for your input everyone. :heart: 
  This looks _great_! Really good work. I've got a few _really_ small pieces of feedback that I'll provide inline. Additionally:
- Can you add a note to the changelog?
- Documentation can go in the `/docs` directory. Add it to the `Providers.md` file (which describes the provider initializer).
- The CI is failing because we really need to address #144. Could you update the `MoyaProvider` subclasses for ReactiveCocoa and RxSwift?

Let me know if I can help with anything ‚Äì thanks again! :cake:
 OK, that's all my feedback. Again, terrific work ‚Äì thanks!
 Looking good. 

One concern that I have: The default logger uses multiple `print` statements to log a single request/response. I guess that multiple simultaneous requests/responses (on different threads) could corrupt the log output in a way that could be misleading to the user...

I would like to suggest to at least accumulate a the log output of each of the `logNetwork...` methods into a single `String` that gets printed at the very end of the method. This way, a single log is somewhat _atomic_.
 Aye, that's a good idea @aschuch 
 NSLog is a good question. Honestly I don't know. Anyone have any resources? Blog posts? Surely Mike Ash has something to say on the matter...
 Yes, exactly ‚Äì just the parameters :smile_cat: 
 I think it is reasonable to accumulate the request log output into a string, then `print` the whole thing. That should be fine. Don't see any reason to use NSLog here. Also, I think its fine to log the request and the response separately (i.e. don't wait for a response to print request + response together).
 Yeah, I think `print` is fine :smile: Don't sweat the small stuff, eh?

@AlexanderKaraberov Do you want this in before we release 3.0? It's a matter of adding this feature to an existing release, or forcing users to adopt 3.0 (with breaking changes) to use it. 
 Closing in favour of new work to be done on #238.
 I think the logger is well-covered, but we've got lots of open issues ‚Äì feel free to dig in to any that look interesting to you!
  Afraid not. It's heavy reliance on Swift's enum functions make it impossible to back port.
  Well, it gets passed in to the Initializer ‚Äì the `MoyaProvider` is a generic type _on_ `MoyaTarget`, so it needs to know what the type is. I'm not sure if `MoyaProvider(GitHub.Zen)` would work, but I haven't tried it. There's no initializer that it could call ‚Äì or is this a Swift thing I'm not aware of? 
 @onmyway133 issues are for questions and clarifications, too! I want to make sure that we're on the same page. Let's start over:

What is happening that you don't expect? What is _not_ happening that you _do_ expect? 
 Yup! And you can only pass enum values of the correct type to the request method, since they're compile-time checked üéâ
 Closing, as I think this is sorted :+1: 
  Huh, good catch! And a great test! Could you add an entry to the changelog?
 Added it in, and merged to master. Thanks again!
  This caused issues for developers not expecting Moya to deduplicate network requests, as well as made it a _pain_ to test and maintain. Ideally, if people even want these, we can further subclass our Rx providers and limit the scope of what they do _just_ to inflight tracking. I don't think anyone will miss it, anyway. 
 Eek this shouldn't be a PR into master...
 My thoughts on this: Ideally this would be something that could be wrapped up in a plugin - it seems out of scope with "core Moya."

But in order to do this in a plugin, we would need to expand the plugin API to include an ability to delay/cancel requests. Not unreasonable, and a "MoyaRequestThrottler" could be really handy!

> On May 1, 2016, at 4:16 AM, Antoine van der Lee notifications@github.com wrote:
> 
> Passing by, as I was looking for this feature. I did miss it, as my app requests many of the same API endpoints at the same time. I was wondering why all these calls were fired.
> 
> Just for my understanding, what would ideally be the way to handle these duplicate calls and prevent them to be all fired? Should I create my own inflights and duplicate detection?
> 
> ‚Äï
> You are receiving this because you are subscribed to this thread.
> Reply to this email directly or view it on GitHub
 It may help to look in an older release to see how we used to do it. It might lend itself well to one solution or another. 
 It's tricky ‚Äì I'm not sure this can be done with a plugin, not without significantly changing what a plugin is and does. The best bet would probably be to subclass `MoyaProvider`, but that doesn't benefit users already using the `RxMoyaProvider` or `ReactiveMoyaProvider`. Not sure there's an easy answer to this, but I'd love to hear ideas!
 That makes sense and is a good solution, but we've had trouble before with "just add an initializer parameter" :smile: It eventually led to https://github.com/Moya/Moya/issues/144 and the idea of Moya plugins in the first place. I'm personally fine with it ‚Äì it's going to be a breaking change either way, so reconsidering plugins might be worth it.
 Looks cool! Want to add tests and submit a pull request? 
 Nope, it should be a matter of opening the workspace and hitting ‚åòU. What errors are you getting? 
 Tricky. Not sure relying on the plugins is the best way to test. You could use a custom endpoint closure or something similar. 2.4.1 was the last version of Moya to support this on all providers (it was even turned on by default!) and it was tested [like this](https://github.com/Moya/Moya/blob/2.4.1/Demo/DemoTests/MoyaProviderIntegrationTests.swift#L267) but wasn't super-great either. 
 Cool, thanks!
  These are meant for the 3.0.0 development branch, since they break things. 

Basically this renames a tonne of things that either no longer make sense, or never did :sweat_smile: Updated the docs and tried to add comments where possible. 
 These are some pretty big changes to the way we name things ‚Äì probably best to get input from @Moya/contributors 
 I definitely prefer the wording here.
 Cooool, thanks! I'll give some time for others to review, too. 
 will need a rebase, but good to merge from me
 OK, will merge when I get a chance. 
 OK, so this has had `master` and `3.0.0-develop` merged in. We should be good to go to merge this ‚Äì once we do, I don't see _too much_ stopping us from releasing 3.0.0 :tada: If anyone wants a final review, now's the time :smile: 
  Alamofire treats them as optional and behaves differently if they are `nil`, so we should allow optionals, too (I guess some servers differentiate between an empty HTTP body and a `nil` one).

Continued from #188. 
 This is fixed by https://github.com/Moya/Moya/pull/228 ‚Äì will be merged in an upcoming release (see #236).
  Pierre-Marc, this is _fantastic work_, thank you very much for your contribution! Well tested, well thought-out. Only thing I can find missing is an entry in the `CHANGELOG.md` file. 

Good to merge this once the changelog is in ‚Äì then we'll release a new version for CocoaPods/Carthage so people can start using this immediately.
  Awesome, thanks! First glance looks great, I'll do an in-depth review tomorrow. Maybe a generic constraint could avoid the forced cast? 
 This looks _amazing_ ‚Äì really well done both of you. I didn't see a changelog entry ‚Äì could you make one?

If this is a breaking change, I'd suggest we merge into the 3.0-develop branch instead of master. If it's _not_ a breaking change, I'm comfortable merging this.
 Sorry, didn't get to this today :( I will do it first thing tomorrow!
 :grimacing: This'll need changes from master pulled in. Let me know if I can help!
 Hmm, still showing as conflicted here: 

<img width="782" alt="screen shot 2015-09-21 at 10 55 06 pm" src="https://cloud.githubusercontent.com/assets/498212/10010084/d58647fc-60b3-11e5-98c1-def1564b6379.png">

Can you double-check? 
 Definitely, thanks :) I'll get back to you about this within a few hours. 
 OK, I'm not aware of anyone who uses the RAC 2 extensions for thoroughly than our app, and in migrating I only saw _one_ issue:

``` swift
let request = Provider.sharedProvider.request(.FindExistingEmailRegistration(email: email))

return request.map { (response) -> NSNumber in
    let moyaResponse = response as! MoyaResponse
    return moyaResponse.statusCode != 404
}
```

It said the type was ambiguous and was easily fixed. 

This feels OK to me, but I know @orta is the semver police here. We'll merge into master if we get the :+1: or merge into 3.0.0-develop otherwise. 
 OK, since _technically_ this is a a breaking change, and I don't want to give Moya users unexpected surprises when the `pod update`, I'm going to merge this into 3.0.0-develop instead. We'll be releasing 3.0 sometime this week, anyway, so you won't have to wait long to see this deployed :cake:

Thanks again for your awesome work!
 OK, cool ‚Äì this is merged in the develop branch, you can see your contributions to the history here: https://github.com/Moya/Moya/commits/3.0.0-develop
  Hey! Don't worry about asking a question on the repo, that's exactly the right thing to do :smile_cat: 

There's no first-class support for this kind of authentication-if-required behaviour. Moya abstracts network calls away, not your authentication. This is a limitation that's recently come up as a request by others, and we're planning on adding support to Moya: #209. 

I had a similar problem on an app I wrote using Moya. [My solution](https://github.com/artsy/eidolon/blob/e4a92cd40b789099297d4d49d5489efc64286269/Kiosk/App/Networking/XAppAuthentication.swift#L8-L26) uses the ReactiveCocoa extensions. Basically I filter all my API calls through one method. It returns a signal (kind of like a promise). The signal represents all the network stuff that has to happen to retrieve the `target`. So first it checks if it needs to re-authenticate, and includes that work in the signal it returns. 

If using the ReactiveCocoa or RxSwift extensions is something you're open to, I'd be happy to provide more details on what that might look like. 
 Sure! So, we're still using the RAC 2 API :cry: but the principles are the same. 

Here's a simplified version of our approach:

``` swift
func XAppRequest(token: ArtsyAPI) -> RACSignal {
    // This is just us looking for our auth tokens, which also expire.
    var appToken = XAppToken(defaults: NSUserDefaults.standardUserDefaults)

    // This is a signal that represents a request to update our auth token, *if* we have to. Nothing will be done unless we include this signal in our return value.
    let newTokenSignal = Provider.sharedProvider.request(ArtsyAPI.XApp).filterSuccessfulStatusCodes().mapJSON().doNext({ (response) -> Void in
        if let dictionary = response as? NSDictionary {
            let formatter = ISO8601DateFormatter()
            appToken.token = dictionary["xapp_token"] as? String
            appToken.expiry = formatter.dateFromString(dictionary["expires_in"] as? String)
        }
    }).logError().ignoreValues()

    // Signal that returns whether our current auth token is valid
    let validTokenSignal = RACSignal.`return`(appToken.isValid)

    // If the token is valid, just return an empty signal, otherwise return a signal that fetches new tokens.
    // After whichever of those completes, _then_ we attach our actual API-requesting signal.
    return RACSignal.`if`(validTokenSignal, then: RACSignal.empty(), `else`: newTokenSignal).then {
        return provider.request(token)
    }
}
```

I've written some comments inline ‚Äì let me know if I can clarify anything!
  Hmm. What are the contents of your Cartfile?

Actually, I'm pretty new at diagnosing Carthage issues. @justinmakaila does this look familiar? 
 @MarvinNazari could you clarify? I built the release of Moya with a version of CocoaPods _newer_ than 0.38.2. 

Again, not terribly familiar with Carthage (we _just_ added support) ‚Äì what happens if you remove the `Alamofire` and `ReactiveCocoa` lines from your Cartfile, out of curiosity? And just have `Moya` and let Carthage bring in the dependencies for you? 
  We're waiting on https://github.com/Moya/Moya/issues/118 to merge for RAC 3 support
 What Xcode version are you using? 
 Looks like it was a problem with ReactiveCocoa's choice to release 3.0.0 as a Swift 1.2 library. We were using `~> 3.0.0-swift`, and CocoaPods assumed that `3.0.0` would be compatible, so it tried to install that. I've pushed an updated Moya podspec that points to a proper 4.0 ReactiveCocoa version. Could you try `pod update ReactiveCocoa` and let us know? 
  Sounds like a good idea ‚Äì doesn't sound too difficult, either. We could hook into the existing provider initialization, if that makes sense, or use NSNotifications. Thoughts? 
 Aye, so this is what I was thinking:

A user could pass in an endpoint resolver or other callback we already have ‚Äì the one they pass in would log stuff. So that's how it could work now. With a new library, we could call a function that curries back a function to pass in. 

``` swift
Provider<TargetEnum>(endpointResolver: MoyaNetworkLogger.StandardLogger)
... or ...
Provider<TargetEnum>(endpointResolver: MoyaNetworkLogger.StandardLogger { target -> NSURLRequqest in
    return /* our custom request, which the logger will then log before passing onto Moya */
})
```

Make sense? 
 Hmm, good question. There's no existing way to log these at all ‚Äì we may have to add yet another callback to the provider :cry: 
 What if we added a property to the provider ‚Äì could be constant or not ‚Äì that conformed to a `Logger` protocol or something, and it gets callbacks about requests and responses. We could provide a basic logger, and people would be free to implement the protocol and provide their own. Thoughts? 
 Hey, this is _almost_ correct. 

``` swift
protocol Logger {
    // logging callbacks
}
```

Then provide a default:

``` swift
struct PlainLogger: Logger {
    // Do basic logging, basically print() all the requests/responses
}
```

Then have a new variable on the `MoyaProvider`.

``` swift
var logger: Logger? = nil
```

Then in our `request` method in the `MoyaProvider` itself, we can invoke the callbacks:

``` swift
logger?.logRequest(request)
...
logger?.logResponse(response)
```

I'm thinking the logger doesn't touch the `MoyaTarget` at all ‚Äì just the HTTP requests. Does that makes sense?
 Hmm, yeah. I suppose it makes more sense to be `let` :smile_cat: 

I think it should be optional, though, and default to `nil`. Many (most?) users won't want HTTP logging. 
 Yeah! 
 Awesome, looking forward to your pull request! Don't worry about getting it in immediately ‚Äì we've all got lives outside or GitHub üò∏
 This can be closed with the release of 3.0.
  Super! Don't forget to add a changelog entry with the update!
 Coooool this is up on CocoaPods trunk: https://raw.githubusercontent.com/CocoaPods/Specs/73d48221ff011b8eb62174b9761bca23c5ba78ca/Specs/Moya/2.2.2/Moya.podspec.json 

Thanks again!
  Hi there! No problem at all :) The Demo project on the current master requires Xcode 7 GM. For Xcode 6.4, you can check out the project in the [last release](https://github.com/Moya/Moya/tree/2.1.0). 

Note that the Demo project on master is currently not able to run an app, just unit tests. I'm working on fixing that in #215.
  Great bug report! This looks similar to #210. Hmm... we haven't found a solution to it yet, either. We'll figure this out :)
 Hmm. You ran `pod install`? What version of CocoaPods are you using? 
 Hmm. The CocoaPods version could be the problem. I remember skipping 0.38.2 but I can't remember why. Maybe updating would fix it?

Alternatively, using our last release with Xcode 6 is a good idea. Check out this tag: https://github.com/Moya/Moya/tree/2.1.0 and let us know how it goes :+1:
 Hmm. I'm seeing the same problem here. I'll investigate and get back to you and @zbeckman as soon as I have a solution. 
 Zacharias found that it was the podfile arrangement. I've pushed a commit that's yet to me merged: https://github.com/Moya/Moya/commit/a2be3c27bffc63427a980ebbcca6cb0c3f14fcec#diff-c2c2f4d15bfae1123d3167a807ac48d6R7
  This pull requests adds Carthage support to Moya, including its two extensions, RxMoya and ReactiveMoya. It builds off of @justinmakaila's work in #169 to include Carthage support, but works using a different solution that @orta and I implemented this afternoon. Let me explain.

In #154, we discussed a solution that involved splitting up Moya into several repositories to generate separate `.framework` files for each Moya, ReactiveMoya, and RxMoya. The solution in this PR instead uses thin podspecs _solely_ for the ReactiveCocoa and RxSwift extensions. This lets the `Pods` Xcode project build separately-named targets, which compile into the frameworks that Carthage needs.

The benefits of this approach are that we keep all of our code in _one_ repository instead of having to synchronize version numbers, tags, pull requests, and so on between three or four repositories. This would be a significant challenge.

The downsides are that we need to keep versions synced between the three podspecs (I've written a `rake` task to automate this). Additionally, if the public APIs to RxSwift or ReactiveCocoa change, Carthage users will need to continue to use the versions required by the CocoaPods builds. I actually kind of like the idea of one Moya existing in parallel on two dependency managers.
## Work Done
- We switched from a `Makefile` to a `Rakefile`.
- Automated releases.
- Re-added `Pods/` directory for Carthage support.
- Duplicated the RxMoya and ReactiveMoya subspecs into their own standalone podspecs, and trimmed them down.
- Removes unnecessary `Box` dependency from the Demo's `Podfile`.
- Updated documentation.
## Next Steps

The [ReactiveMoya](https://github.com/Moya/ReactiveMoya) and [RxMoya](https://github.com/Moya/RxMoya) repositories are no longer needed and should be deleted after this pull request is merged. Any existing Carthage users will need to update their Cartfiles.
## Notes

`MoyaResponse.swift` is included in both Carthage-specific podspecs, but it only appears once in the `Pods` project's file pane. The file is a member of both targets, but only appears once. The ambiguity between the files referenced in both frameworks led me to split up the unit tests into distinct files (to avoid having both `MoyaResponse`s in scope). I also tidied them up a bit.

Fixes #154.
Fixes #184.
Fixes #204.
Fixes #216.
 It generates all three frameworks when you do `github "Moya/Moya"` - as a user, you can choose which ones to integrate this way:

```
~/d/i/l/moya_cart ‚èõ  cat Cartfile
git "file:///Users/orta/dev/ios/libs/Moya" "internal_podspecs"

~/d/i/l/moya_cart ‚èõ  carthage update
*** Fetching Moya
*** Checking out Moya at "e6a00bff2b51838e4449afac952b3937d1cfa6de"
*** xcodebuild output can be found in /var/folders/mk/gxhr550d5mbcv5s9_f61x84h0000gn/T/carthage-xcodebuild.uPEpwO.log
*** Building scheme "Moya" in Pods.xcodeproj
*** Building scheme "ReactiveMoya" in Pods.xcodeproj
*** Building scheme "RxMoya" in Pods.xcodeproj

~/d/i/l/moya_cart ‚èõ  ls Carthage/Build/iOS
Moya.framework         ReactiveMoya.framework RxMoya.framework
```
 Right now that's not the case, but I don't see a reason to not make that behaviour default @ashfurrow ?

Plus it keeps all documentation consistent, that's the behaviour you get from CP.
 So you want the behaviour where you would always do `@import Moya;` and it would work fine regardless of which framework you've imported? This is totally doable using [module_name](https://guides.cocoapods.org/syntax/podspec.html#module_name) in the rx/RAC Podspecs. Also makes it consistent with CP.

I _think_ it would generate three differently named frameworks for drag & drop but they would all all work with `@import Moya;`. Can't guarantee that Xcode allows the generation of the three frameworks with the same module name, but can be tested. 
 OK, I'll play around with the `module_name` for the specs and verify it works :+1: 
 Hmm. Looks like it doesn't have the other Moya files. Makes sense since they're no longer subspecs. Thanks @gfontenot!
 @justinmakaila Looks like CocoaPods can't handle having frameworks with the same module name. 

```
[!] The 'Pods' target has frameworks with conflicting names: Moya.
```

This means that users will need to `import Moya`, `import RxMoya`, or `import ReactiveMoya` respectively. Switching flavours would mean a find-and-replace. Kind of a pain, but people don't often switch flavours, and it's not too much effort. It also fits better with the Carthage folks' philosophy. 

@gfontenot Running the command `carthage build --no-skip-current --platform iOS` (we don't support Mac yet) now produces the following results:

```
*** xcodebuild output can be found in /var/folders/c9/qfv9zg9n23v5yt50skqpmtg40000gn/T/carthage-xcodebuild.5IPQce.log
*** Building scheme "Moya" in Demo.xcworkspace
*** Building scheme "ReactiveMoya" in Demo.xcworkspace
*** Building scheme "RxMoya" in Demo.xcworkspace
```

This seems good to me :tada: 

There's a failure on CI ‚Äì looks like Xcode is getting confused about something when building the unit tests. Investigating now. 
 :green_apple: 
 Instead of removing the no-longer-needed [ReactiveMoya](https://github.com/Moya/ReactiveMoya) repo, we should transfer its ownership to someone so that GitHub redirects will work long enough for people to update their configs. @justinmakaila would you like it? 
 I've fixed #216 on this branch ‚Äì just rearranging the podfile a bit. I've run carthage locally and it seems to be :+1: 
 Hmm. Failing on CI, succeeding locally with Xcode, and failing from `xcodebuild` but for a _different_ reason. 
 OK, thanks @justinmakaila!
 Hmm, @justinmakaila I can't transfer it to you because you have a fork already. GitHub made me transfer it to me _first_ anyway, so the redirects will continue to work. Let me know if you still want it ‚Äì you'd need to delete your fork first.
 :tea: This is green again. I don't want to keep it open too much longer, or we're likely to get scope creep :sweat_smile: The Demo apps runs and the unit tests pass, and carthage builds fine ‚Äì going to give some more time for review, then merge and release 2.2.0 :tada:
  Hmm, seems likely. I'll see what I can do to reconfigure it.
 Thanks!
 I've merged this for now; will fix the errors and send a new PR so it's cleaner. 
  That's odd. How are you installing it? You'll need to manually point to Alamofire's Swift 2 branch in your podfile. It's working for me with this one: https://github.com/artsy/eidolon/blob/master/Podfile
 Hmm. I'll have to look at that tomorrow. Might be a change with the GM. 
 I'm going to work on getting it all to work this afternoon with the Xcode 7 GM. 
 OK cool, so this is working for me ([this PR](https://github.com/Moya/Moya/pull/212)).

@zbeckman Your podfile looks good to me. But you'll need to update things:

``` sh
pod update Box Result Alamofire Moya/ReactiveCocoa
```

Let us know if that works :cake: 
 The code on this PR is working for me locally: https://github.com/artsy/eidolon/pull/504
 Oh no! I had a similar issue yesterday but I can't recall exactly what fixed it. You've tried the routine fixes like deleting derived data and resetting the simulator? Are there any compiler warnings that seem related? 
 Here is our working build of [Moya + ReactiveCocoa](https://github.com/artsy/eidolon/blob/master/Podfile#L65-L67) - which generates this [lockfile](https://github.com/artsy/eidolon/blob/master/Podfile.lock)

``` ruby
pod 'Alamofire'
pod 'ReactiveCocoa', :git => 'https://github.com/ashfurrow/ReactiveCocoa.git', :branch => 'swift2'
pod 'Moya/ReactiveCocoa', :git => 'https://github.com/Moya/Moya.git', :branch => 'swift-2.0'
```

Should get you the right setup, if you have been using older references for these branches - you may need to `pod update` to get the latest commits on those branches.
 I agree the README needs updating ‚Äì I'll roll that into https://github.com/Moya/Moya/pull/214 .
 I've been able to use CocoaPods to install Moya/ReactiveMoya without any problems on a fresh Xcode project (download it [here](http://cl.ly/433l3C18233J)). I did so using Xcode 7 GM and the following Podfile:

``` rb
use_frameworks!

target 'Test' do

pod 'Result', :head
pod 'ReactiveCocoa', :git => 'https://github.com/ashfurrow/ReactiveCocoa.git', :branch => 'swift2'
pod 'Moya/ReactiveCocoa', :git => 'https://github.com/Moya/Moya.git'

end
```

@zbeckman If that isn't working for you on your existing project, could you try cleaning your build directory? Command-Shift-K should do it in Xcode. It could be that Xcode's forgotten its derived data cache is stale. Let us know if any of that helps. 
 I've never used Carthage and CocoaPods together before ‚Äì not sure of how that'd work. What version of CocoaPods are you using? There's a similar issue in #216. 
 We've rearranged this repository since you initially had this problem. Could I ask you to try creating a new Xcode project, and `pod install` using the following pods? Please leave Carthage out so that we can narrow the problem down. 

``` rb
pod 'Result', :head
pod 'ReactiveCocoa', :git => 'https://github.com/ashfurrow/ReactiveCocoa.git', :branch => 'swift2'
pod 'Moya/ReactiveCocoa', :git => "https://github.com/Moya/Moya.git"
```

After `pod install`ing, open the project in Xcode 7 GM and run the app. Hopefully it'll work (it's working for me). 

If that doesn't work, please download [this Xcode project](http://cl.ly/3e1f342x2G2X) which I've prepared. It works on my machine. If it doesn't on your machine, we'll have a better idea of where to look. 

If that _does_ work, we'll try the same approach on your library. If you could undo the changes made when you were troubleshooting using git, that would be helpful. If it still doesn't work, then it could be something specific about your project. 

I'll continue looking for the solution on my end. Thanks for helping us figure out the problem! :cake: 
 Great work! I'm having trouble with the Demo project in #216 too. After adding pods to the specific target in the Podfile, it's now working! This kind of stuff has always tripped me up ‚Äì looping in @orta. 
 Great! I'm glad that's working. 

Box is no longer required at all. Result seems to have been updated on Trunk, so we can remove it too. Same with Alamofire ‚Äì used to need it specified for Swift 2 support, don't anymore. 
 BTW you can reduce test pod duplication by doing [something like this](https://github.com/orta/Elasticity/blob/master/Podfile#L31-L38).
 Seems like this is resolved, I'm going to close the issue. Don't hesitate to reopen, or open a new issue, if you run into any further problems. Thanks again for your help! :100: 
  Our `endpointResolver` currently returns an `NSURLRequest`, which is cool, but makes working with async APIs like [Heimdall](https://github.com/rheinfabrik/Heimdall.swift) very difficult (by the nature of OAuth, [these requests cannot be synchronous](https://github.com/rheinfabrik/Heimdall.swift/blob/f67abd632b6ccc4604ae8fa2b6eab9d6b7855310/Heimdall/Heimdall.swift#L193).

I'm thinking that the the endpointResolver is passed in a closure that accepts the NSURLRequest as an argument, and the resolver calls this closure when the request is finished. Suggestions?
 So I'm thinking something like this:

``` swift
public typealias RequestClosure = (Endpoint<Target>, NSURLRequest -> Void) -> Void
```

That the user passes in to the provider. It's a closure that's given the target, and another closure that accepts an NSURLRequest. The way you'd do this is something like:

``` swift
let provider = MoyaProvider<MyTarget>(requestClosure: { endpoint, done in
    let request = endpoint.urlRequest
    // Modify the request, asynchronously.
    done(request)
})
```

My implementation of `request()` looks something like this:

``` swift
public func request(token: Target, completion: Moya.Completion) -> Cancellable {
    let endpoint = self.endpoint(token)

    var innerCancellable: CancellableToken?
    var cancelled = false
    let outerCancellable = CancellableToken {
        innerCancellable?.cancel()
        cancelled = true
    }

    let performNetworking = { (request: NSURLRequest) in
        if cancelled { return }
        let stubBehavior = self.stubClosure(token)

        switch stubBehavior {
        case .Never:
            innerCancellable = self.sendRequest(request, completion: completion)
        default:
            innerCancellable = self.stubRequest(request, completion: completion, endpoint: endpoint, stubBehavior: stubBehavior)
        }
    }

    requestClosure(endpoint, performNetworking)

    return outerCancellable
}
```

The hard part is synchronously returning something from `request()` that can cancel an activity that hasn't yet been created. There's almost certainly something nicer than this, but I'm pretty tired :sleeping: 

@MarvinNazari what do you think? 
 Supper we could wrap the cancellation: 

``` swift
struct CancellableWrapper: Cancellable {
    var innerCancellable: CancellableToken? = nil

    private var isCancelled = false

    func cancel() {
        innerCancellable?.cancel()
    }
}
```

Which simplifies our implementation a bit: 

``` swift
public func request(token: Target, completion: Moya.Completion) -> Cancellable {
    let endpoint = self.endpoint(token)

    var cancellableToken = CancellableWrapper()

    let performNetworking = { (request: NSURLRequest) in
        if cancellableToken.isCancelled { return }

        let stubBehavior = self.stubClosure(token)

        switch stubBehavior {
        case .Never:
            cancellableToken.innerCancellable = self.sendRequest(request, completion: completion)
        default:
            cancellableToken.innerCancellable = self.stubRequest(request, completion: completion, endpoint: endpoint, stubBehavior: stubBehavior)
        }
    }

    requestClosure(endpoint, performNetworking)

    return cancellableToken
}
```
 Thanks! What do you think of the implementation? https://github.com/Moya/Moya/pull/230
 Fixed in https://github.com/Moya/Moya/pull/230 Will be released soon.
  Hey there! Great question ‚Äì this is covered in the [docs on endpoint mapping](https://github.com/Moya/Moya/blob/master/docs/Endpoints.md#from-target-to-endpoint-). It should be straightforward, but let us know if you run into any problems :smile_cat: 
 Don't worry about it! Glad that's what you're looking for. 
  Cool ‚Äì looks great, thanks! 
  Meta-issue :)

I've not used gitter, and I don't really feel like inviting people to another Slack just for Moya :sweat_smile: I personally like issues because they're public, searchable, and anyone can easily participate. Even for things like roadmaps, I feel it makes sense. But I know my feelings aren't universal, too. Happy to go in whatever direction we need to to make a great library. 
 I've never used `Gitter` before TBH.

Would give it a try as long as someone could point me to the benefits of having a Gitter room vs only the issues here.

I think @colinta and @ashfurrow already made some valid points of pros for the issues in Github but I still don't know what are the benefits of the other option.
 Gitter's tend to end up like Alcatraz's : https://gitter.im/supermarin/Alcatraz - people come in with  questions but no-one gives answers.

Not to say that a slack doesn't have it's problem, or IRC; on CocoaPods we devs don't use the IRC so it's only usually for people who can help each other.
 I think the ¬´vast¬ª majority is against `Gitter`.

I agree that the fragmentation would be an issue.
How does `Gitter` work in regards of; I don't know. Google indexing? Would I get hits in Google pointing to `Gitter`? how long does the discussions in `Gitter` are stored? or are they discarded after X amount of bytes?

I think having an outlet for users to help themselves would be great; but ~~if~~ as long as there's not a way to preserve and index said discussions they would go to ¬´waste¬ª
 Gonna close this ‚Äì if we missed something in the discussion, or if it makes sense in the future, we'll revisit some sort of organizational chat :+1: :cake:
  This is great work, thanks @avf :cake: This is exactly how I would've implemented it, though it does make https://github.com/Moya/Moya/issues/144 even more important to deal with. 

Just a few things ‚Äì you'll need to pull in changes from the master branch so we can merge your pull request ‚Äì happy to help with that. 

Some tests would be nice, but it can be challenging to write them. If you like, we can write them together! Also, could you add an entry to the changelog? Make sure to give yourself credit!

Again, fantastic work :boom: 
 OK, sounds great! Feel free to reach out to ash@ashfurrow.com with questions. If I have some time this week, I'll send you some first steps that might help. 
 Hey! It's been a few weeks so I thought I'd check in. I never got around to writing some tests (busy weekend!) but this week I plan to get this merged. It'll take some work to resolve some conflicts ‚Äì I'll take care of those ‚Äì and I'll write a few tests. I'll post a new pull request and ask you to review it for us, if that's ok? Thanks again!
 Hey! So the tests you added look lovely. I just realized, though, that the `manager` we recently added should provide, this, right? The Alamofire's `Manager` class seems to handle a lot of customization of `NSURLSession` and requests. 

Do you think HTTP auth is common enough that we should have a closure specifically for it? Or should we stick to the manager? I like the closure since it keeps things abstracted with the `MoyaTarget` protocol. But it also adds yet another `init()` parameter :sweat_smile: Any thoughts, @avf?
 Thought about this more, and I really like you're implementation. It lets people auth on per-target instead of per-URL, which is the whole point of Moya. Great work, I'll get this merged ASAP. 
 OK, this is merged :tada: thanks again for your hard work, @avf. I've release 2.4.0 on CocoaPods trunk, and tagged a release on the repo for Carthage. 
  Yep!

Good thinking @skywinder 
  Yeah, good spot @skywinder 
  `Failure` is truly a network failure ‚Äì the status code is optional, even. It's meant to simulate when the device cannot connect to the internet. The `Success` case is a "success" in that the API returns some data. it's agnostic to the idea that a 404 would be a failure ‚Äì it succeeded because it returned data. 
 True, but there are also error conditions in The iOS network stack that we want to simulate. Maybe we should rename these two cases then. 
 That's a good idea, @damianesteban. I don't believe we actually use OAuth; we only need to add an HTTP header. 

I feel generally that Moya is spreading in a few different directions, and we don't have a set of best practices that demonstrate or implement common practices, like OAuth. I don't think we need to implement MoyaOAuth or anything :grimacing: but some examples of using common libraries would be very useful, too. 
 So, thanks for the suggestion!
 Awesome! Let us know how it goes!
 @Dschee it's a good question, and it's one that we've faced before. I'm up for the change, but it would mean abandoning the `Result` dependency and the nice functions that accompany it like `flatMap`. It's too bad we can't `typealias` specific cases of an enum.
 Yeah, we definitely can (I'm on the Result team) but I'm not sure it's a great idea, as you mention. Then again, I don't see any alternatives (I'm not a fan of documenting our way out of this ‚Äì basically just blaming the user). Let's sleep on it and see if we think of any alternatives? 
 There might be a better name than "Success", but having it broken out based on the status code implies knowledge of the server. I've worked with an app (a terrible one), where all responses were "200", and other servers use 404 for empty "array resources". 

But, instead of "Success", would "Response" be more appropriate?

> On Mar 25, 2016, at 9:48 AM, Cihat G√ºnd√ºz notifications@github.com wrote:
> 
> It just happened two days ago that one of my colleagues took over a project I implemented a new API class for using Moya and he was completely confused by the fact that an API error (regardless of 4xx or 5xx) was returned within the .Success case. Although I understand and like the fact that Moya only forwards network errors to the .Failure case what about renaming the generic .Success and .Failure cases to something more clear? For example simply adding Network as a prefix resulting to .NetworkSuccess and .NetworkFailure should already improve the clarity a lot. What do you think?
> 
> ‚Äî
> You are receiving this because you are subscribed to this thread.
> Reply to this email directly or view it on GitHub
 "Response" sounds appropriate. I don't want to impose semantics on top of Alamofire, so maybe have `Response` and `Incomplete`?
 Since there hasn't been any activity on this thread for some time, I am going to go ahead and close it. Please re-open or create a new issue if you would like to discuss further. Thanks.  The model is to return sampleData that reflects the info about the failure, just like on a success. We do this [here](https://github.com/artsy/eidolon/blob/5b724a68acd4e6e42d2e8b1092b4644ba6b6488b/KioskTests/Bid%20Fulfillment/RegistrationPasswordViewModelTests.swift#L14-L40) on a per-target basis. 
 `sampleData` is actually a closure that returns an `NSData` instance. The demo I posted showed how you could customize the `endpointsClosure` to return customized `Endpoint`s. 

I suppose what's probably confusing is the `Success` and `Failure` cases of the result. `Failure` is truly a network failure ‚Äì the status code is optional, even. It's meant to simulate when the device cannot connect to the internet. The `Success` case is a "success" in that the API returns some data. it's agnostic to the idea that a 404 would be a failure ‚Äì it succeeded because it returned data. 

I've opened https://github.com/Moya/Moya/issues/200 to make sure that we clarify this for other users. 

Does that answer your question? 
 I'm glad! I'm going to close the issue, but if you want to reopen later, or open a new issue, please feel free!
  I'm not sure this is Moya's responsibility, object mapping in Swift is still painful and there's no obvious winner given there's a [new one every day](https://cocoapods.org/?q=lang%3Aswift%20json) to back so we'd end up supporting a lot of different cases. I think @colinta's idea makes sense though, a separate pod that could act as a mapper.

FWIW though we didn't find it difficult at all to build our [own mapper](https://github.com/artsy/eidolon/blob/master/Kiosk/App/Networking/RAC%2BJSONAble.swift) that worked with [function chaining](https://github.com/artsy/eidolon/blob/master/Kiosk/App/AppViewController.swift#L76).
 I don't think this is Moya's job, either, but Orta's right ‚Äì we may able to be clever about completion blocks that would allow users to easily do this, even without the chaining. It could be a neat demo, case study, or example in the docs. I'll give some more though to what it might look like. 
 If you're using CocoaPods, I've enjoyed using `pod lib create` ‚Äì your just add Moya as a dependency and `pod install`. 
 @lkuczborski we use something [like this](https://github.com/artsy/eidolon/blob/511ebb901289dbeb648cb9b0234e21ab1543c373/Kiosk/App/Networking/RAC%2BJSONAble.swift), but that's built atop signals. You're looking for something with callbacks. 

Well! Let's imagine. 

Basically, you'd want a block that takes a type and returns a closure that can be passed into Moya's `request` function. This hasn't been run through a compiler, but you get the idea:

``` swift
func moyaCompletionMapsTo<T: JSONAble.Type>(classType: T, completion:(T?) -> ()) -> MoyaCompletion {
    return { (data: NSData?, statusCode: Int?, response: NSURLResponse?, error: NSError?) -> () in
        // process the response somehow and store result (might be nil) in model
        completion(model)
    }
}
```

Then you'd call:

``` swift
provider.request(moyaCompletionMapsTo(Model.self, { model -> () in 
}))
```

Or something to that effect. Does that make sense? 
 @SRandazzo very cool!

>  I feel like pattern of subclassing MoyaProvider isn't the best decision

Agreed. We've actually opened https://github.com/Moya/Moya/issues/144 concerning the subclassing pattern. With Swift 2's protocol extensions, it might make sense to ditch the MoyaProvider class altogether :tada: 
 It feels like things like this would make great separate pods, for example here's my simple [Gloss + RxSwift](https://github.com/artsy/Emergence/blob/master/Emergence/Contexts/Networking/Observable%2BNetworking.swift) extension for Moya - that could happily be it's own thing in a similar way.
 So I messed around on a branch and experimented with making the plugin system middleware style. Where each plugin can transform data before reaching the next plugin. I realize this is a huge change and there may be another way to accomplish some of the same things. One major change in my experiment is that all data is now 'AnyObject?'. This could allow for easy means to mutate response data and such for something like ObjectMapper. 

https://github.com/gregpardo/Moya/tree/experiment/middleware-flow

And example of a plugin that can transform response data might look something like this...

``` Swift
public class ResponseTransformPlugin<Target: MoyaTarget>: Plugin<Target> {

    public override func didReceiveResponse(object: AnyObject?, statusCode: Int?, response: NSURLResponse?, error: ErrorType?, provider: MoyaProvider<Target>, target: Target) -> MoyaProvider<Target>.Response {
        object = target.responseTransform(object)
        return MoyaProvider<Target>.Response(object, statusCode: statusCode, response: response, error: error, provider: provider, target: target)
    }

}

public extension MoyaTarget {
    func responseTransform(object: AnyObject?) -> AnyObject?
}
```

Then the target could look something like this

``` Swift
extension MyTarget : MoyaTarget {
   // Other setup here first (baseUrl, path, etc)
   public func responseTransform(object:AnyObject?) -> AnyObject? {
       switch self {
        case .GetUser:
            let user = Mapper<User>().map(object)
            return user
        }
   }
}
```

Does this make any sense or have I taken some strange roundabout approach to attempting to give plugins more power easily?
 Hmm, I can see this making sense but I agree it is a bit roundabout. I was thinking that this really belongs in the RAC/RxSwift provider extensions? Something like what we currently do at Artsy: https://github.com/artsy/eidolon/blob/f95c0a5bf1e90358320529529d6bf431ada04c3f/Kiosk/App/Networking/RAC%2BJSONAble.swift

Or we could add another `request` method that accepted a class, too. Thoughts? 
 Well yeah it works both ways but the downside of the reactive extension approach is a couple things in my opinion. 
- Different extensions need to be written for RxSwift/ReactiveSwift
- Either needs an API wrapper for all requests to map them to the object or each time the request is called the object class to map to has to be specified

The later seems like the approach most have taken but it kind of goes around the simplicity of configuring your provider and being ready to go.

I guess noticed two things about the current system that may or may not need improving.
- Plugins cannot mutate data in a middleware like fashion (Perhaps this is actually simpler and preferred)
- Moya layer is confined to returning NSData thus not allowing plugins to override this naturally
 I like the approach. I think it's a nice bridge and keeps any mapping out of Moya's responsibilities. Would it be possible to write an ObjectMapper plugin that allows me to configure different maps per endpoint with this?
 Okay this looks like a great approach. I suppose whether something is a 'plugin' or not is not really important as someone can download a cocoapod of an approach like this and would get the functionality included. Now I just need to code an ObjectMapper RxSwift version!
 Sounds good. I guess this ticket could become add examples of how to implement this. I think providing some direction in the documentation on how to accomplish such a thing would be useful to a lot of people. It seems this is a feature that a lot of folks are having to hack together. 
 @ivanbruel This is _fabulous_ :tada: Great work! 

I think we should be able to close this issue once the Readme has been updated to point to Ivan's library. @ivanbruel: if the maintenance on you ever need a hand maintaining your library, just let us know!
 Sure, sounds like a kind of super-documentation around ObjectMapper and Carthage? Neato. 
 Cool, sounds like a bigger project. I think a mention in the Readme can help people looking for OM support now until we have the extensions documentation done. 
 Given https://github.com/Moya/Moya/pull/339 I'd like to close this issue. Is the larger project something we ought to open a new issue for? Maybe pointing back to this one for context? 
  So, I spoke with @irace this week about a really neat idea for network requests in offline situations. If I understood correctly, each network request would do the following:
1. Serialize the request and store it on disk.
2. Try the request if you're online.
3. If it fails, or if the device becomes online and there are stored requests, resend them up to with max resend / max lifetime criteria.

It would be cool to do something like this with Moya. Maybe not in the primary repo, but maybe an extension or something in another repo. 

If anyone has ideas for feature requests, reference implementations, or ideas for how we could elegantly architect this, please comment!
 Interesting idea!!
 Yeah, I don't feel super-strongly either way about it. 

## 

Ash Furrow
iOS Developer, Author
http://ashfurrow.com

> On Aug 24, 2015, at 12:49 PM, Justin Makaila notifications@github.com wrote:
> 
> Could this potentially help with things like #164? If we provide an offline cache and specify a TTL at the request level, and whether or not a request should use the cache, I think we could ditch the idea of inflight requests.
> 
> ‚Äî
> Reply to this email directly or view it on GitHub.
 Awesome, @jarrodrobins if you're able to share an existing implementation, we could discuss ideas for implementing the same here. 
 Afraid not that I'm aware of.
 Looks like this was explored more recently in #713 and closed. Should we close this as well?  Hmm tricky. Let me take a look. 
 Maybe, but I feel like that would break the clear chain from target -> endpoint -> request. 

Could you provide more details about the nature of the request signing? Is this something that could be accomplished with HTTP headers alone? There are some details [here](https://github.com/Moya/Moya/blob/master/docs/Endpoints.md#from-target-to-endpoint-) on how that could be accomplished. 
 Hmm, I tried to make the `Endpoint` an abstraction for URL requests with [all of these properties](https://github.com/Moya/Moya/blob/fa071c26244e5e2aff8ee98b42ac7ccb3cc4e60c/Moya/Endpoint.swift#L22-L27). I didn't anticipate a need to access the request itself. 

It could also be possible to switch based on the endpoint's URL in the resolver. 

``` swift
{ (endpoint: Endpoint<ArtsyAPI>) -> (NSURLRequest) in
    let request: NSMutableURLRequest = endpoint.urlRequest.mutableCopy() as NSMutableURLRequest
    switch endpoint.url.absoluteString {
    case let url where url.hasPrefix("http://theRequestThatNeedsAuthentication"):
        return /* signed request */
    }
    return request
}
```

It's a bit janky, but would that work?
 Definitely something to keep in mind! 
  Right now `Moya` compiles and works on its `swift-2.0` branch including `RxSwift` but `ReactiveCocoa` is lagging behind due to a non-official `podspec`.

We need to support `ReactiveCocoa` as a dependency working with `Swift 2.0`
 Sadly `ReactiveCocoa` dropped support for `CocoaPods` some versions ago.

This means that the `podspec` is not maintained by them and there's currently no `Swift 2.0` `podspec`.

I forked `ReactiveCocoa` and added a `podspec` to their 2.0 branch but I'm having some issues when trying to compile the pod.

TL;DR
I need to figure out a correct `podspec` for `Swift 2.0` :smile: 
 I maintain the podspec for ReactiveCocoa; is it out of date? 
 I think is up to date but if I try to point the pod to the `Swift 2.0` branch it fails telling me there's no pod at that location or something along those lines (can't remember the exact error right now).
 Hmm. You should be 
 ``` console
Fetching podspec for `Moya` from `../`
[!] Unknown external source parameters for `ReactiveCocoa`: `{:branch=>"swift2"}`
```
 Let me check because I just changed something and I might be writing the `Podfile` wrong
 What's the podfile look like? 
 Ok; here's the `Podfile`:

``` ruby
platform :ios, '8.0'

source 'https://github.com/CocoaPods/Specs.git'

use_frameworks!

pod 'ReactiveCocoa', :git => 'https://github.com/ReactiveCocoa/ReactiveCocoa', :branch => "swift2"
pod 'RxSwift', :git => 'https://github.com/ReactiveX/RxSwift', :branch => 'rxswift-2.0'
pod 'Alamofire', :git => "https://github.com/Alamofire/Alamofire", :branch => "swift-2.0"

pod 'Moya/RxSwift', :path => "../"
pod 'Moya/ReactiveCocoa', :path => "../"
pod 'Moya', :path => "../"

target 'DemoTests' do

  pod 'Quick', :git => 'https://github.com/Quick/Quick', :branch => 'swift-2.0'
  pod 'Nimble', :git => 'https://github.com/Quick/Nimble', :branch => 'swift-2.0'
  pod 'OHHTTPStubs'

end
```

And here's the error:

``` console
Pre-downloading: `ReactiveCocoa` from `https://github.com/ReactiveCocoa/ReactiveCocoa`, branch `swift2`
[!] Unable to find a specification for 'ReactiveCocoa'.
```
 Tried pointing to your fork just in case; this is what I'm getting:

``` console
Pre-downloading: `ReactiveCocoa` from `https://github.com/ashfurrow/ReactiveCocoa`, branch `swift2`

[!] Error installing ReactiveCocoa
[!] /usr/local/bin/git clone https://github.com/ashfurrow/ReactiveCocoa /var/folders/xk/378q_x1x4b3289cbr_kjyhzr0000gn/T/d20150821-25846-1w2akmk --single-branch --depth 1 --branch swift2

Cloning into '/var/folders/xk/378q_x1x4b3289cbr_kjyhzr0000gn/T/d20150821-25846-1w2akmk'...
warning: Could not find remote branch swift2 to clone.
fatal: Remote branch swift2 not found in upstream origin
```
 My fork is _way_ out of date. 

Interesting ‚Äì I would've thought it would use the spec in trunk. You should be able to point to _your_ work and copy&paste this podspec into it: https://github.com/CocoaPods/Specs/blob/master/Specs/ReactiveCocoa/3.0-RC.1/ReactiveCocoa.podspec.json
 I'm using this: https://github.com/esttorhe/ReactiveCocoa/blob/swift2/ReactiveCocoa.podspec

I'll take a look at the one you provided and see what differs from mine
 I'm spending time this week to update our app to Swift 2 ‚Äì I'll try to get this working. 
 ![](http://i.giphy.com/JDnaQ8qn0Myuk.gif)
 Initial work is complete. I haven't finished yet, so I can't test, but [this](https://github.com/artsy/eidolon/pull/496/files#diff-4a25b996826623c4a3a4910f47f10c30R59) should help anyone currently stuck. I'm using my fork of ReactiveCocoa, and added a podspec to my branch. 
 I'ved pushed a version of ReactiveCocoa 3 with Swift 2 (Xcode 7 GM) support. Its version number is "3.0.0-swift2" and can be used in Podfiles _and_ in podspecs. 

Subsequently, I've updated the Moya podspec to use this new ReactiveCocoa version. There's a problem with the Carthage compatibility, but I'm hoping to have it wrapped up soon, and then I'll submit a PR. 
 OK, now all that's required for ReactiveCocoa extensions is the following in your podfile

``` rb
pod 'Moya/ReactiveCocoa'
```

And that's it! :tada:
  Hmm. I know @esttorhe is working on Swift 2 support on https://github.com/Moya/Moya/pull/181 ‚Äì maybe the Moya/Core subspec isn't being used from the `swift-2` branch? Maybe you need also

``` rb
pod 'Moya', :git => 'https://github.com/Moya/Moya.git', :branch => 'swift-2.0'
```

But to be honest, I'm not sure of the Swift 2 support in Moya yet. Ill's if I can take a look today. 
 AFC right now but if you point to mits 2.0 branch (see the Demo Podfile in there) you'll be able to use everything sans ReactiveCocoa subspec

## 

Esteban Torres
(+506)8813-0934
Twitter: @esttorhe

On Thu, Aug 20, 2015 at 8:22 AM -0700, "Ash Furrow" notifications@github.com wrote:

Hmm. I know @esttorhe is working on Swift 2 support on #181 ‚Äì maybe the Moya/Core subspec isn't being used from the swift-2 branch? Maybe you need also

pod 'Moya', :git => 'https://github.com/Moya/Moya.git', :branch => 'swift-2.0'

But to be honest, I'm not sure of the Swift 2 support in Moya yet. Ill's if I can take a look today. 

‚Äî
Reply to this email directly or view it on GitHub.
 *Moya¬†

## 

Esteban Torres
(+506)8813-0934
Twitter: @esttorhe

On Thu, Aug 20, 2015 at 8:22 AM -0700, "Ash Furrow" notifications@github.com wrote:

Hmm. I know @esttorhe is working on Swift 2 support on #181 ‚Äì maybe the Moya/Core subspec isn't being used from the swift-2 branch? Maybe you need also

pod 'Moya', :git => 'https://github.com/Moya/Moya.git', :branch => 'swift-2.0'

But to be honest, I'm not sure of the Swift 2 support in Moya yet. Ill's if I can take a look today. 

‚Äî
Reply to this email directly or view it on GitHub.
 Omw.¬†
I'll check in my computer in a few¬†

## 

Esteban Torres
(+506)8813-0934
Twitter: @esttorhe

On Thu, Aug 20, 2015 at 8:39 AM -0700, "EZabolotniy" notifications@github.com wrote:

I change my pod file to:

platform :ios, "8.0"

source 'https://github.com/CocoaPods/Specs.git'

use_frameworks!

pod 'Alamofire', :git => 'https://github.com/Alamofire/Alamofire.git', :branch => 'swift-2.0'

pod 'RxSwift', :git => 'https://github.com/ReactiveX/RxSwift.git', :branch => 'rxswift-2.0'

pod 'RxCocoa', :git => 'https://github.com/ReactiveX/RxSwift.git', :branch => 'rxswift-2.0‚Äô

pod 'Moya/RxSwift', :path => "../"

pod 'Moya/ReactiveCocoa', :path => "../"

pod 'Moya', :path => "../"

and still have the following error:

[!] Unable to satisfy the following requirements:

Alamofire (fromhttps://github.com/Alamofire/Alamofire.git`, branch swift-2.0)required byPodfile`

Alamofire (~> 1.3.0) required by Moya/Core (2.0.0)

[!] Your Podfile has had smart quotes sanitised. To avoid issues in the future, you should not use TextEdit for editing it. If you are not using TextEdit, you should turn off smart quotes in your editor of choice.

Evgeniys-MacBook-Pro:Eventgram evgeniy$ open -e Podfile

‚Äî
Reply to this email directly or view it on GitHub.
 You are correct @EZabolotniy.

I forgot that we haven't merged my branch into Moya's `swift-2.0` due to the issue with `ReactiveCocoa`.

You should be able to use `Moya` with `Swift 2` if you change your `Podfile` to this:

``` ruby
platform :ios, '8.0'
use_frameworks!

pod 'Moya', :git => 'https://github.com/esttorhe/Moya', :branch => 'swift-2.0'
pod 'Alamofire', :git => 'https://github.com/Alamofire/Alamofire', :branch => 'swift-2.0'
pod 'RxSwift', :git => 'https://github.com/ReactiveX/RxSwift', :branch => 'rxswift-2.0'
pod 'RxCocoa', :git => 'https://github.com/ReactiveX/RxSwift', :branch => 'rxswift-2.0'
```

With the caveat that you won't be able to use the `ReactiveCocoa` extensions ATM

---

Worth noting; I had to change my implementation; from when I created it to now @kzaher promoted `ReactiveX` to an organization and changed the name of the `Swift 2` branches.

I changed the `Podfile` accordingly and tested locally and `CocoaPods` can satisfy all the requirements; note that you'll have to point `Moya` to my branch for the time being since that `podspec` doesn't specify `Alamofire 1.3` as a dependency and leaves it open; then on the `Podfile` you can lock it to the `Swift 2.0` branch; same goes for the `RxSwift` dependencies
 @ashfurrow; would it be worth to merge my WIP branch into the `swift-2.0`?

I mean; right now that branch doesn't work and mine almost work except for `ReactiveCocoa` (which I'm hoping to clear some time to tackle that once and for all by the end of this week).

That way people can use `Moya` on `Swift 2.0` in a somewhat more ¬´official¬ª way
 I'm thinking merging it as-is is probably a good idea. It's not like we're merging into `master` or anything :)
 I think its ok to close this issue due to #194
  I think the `iOS 7` restriction is more along the lines that `Swift` pods are only supported with `use_frameworks!` flag in `CocoaPods`.

And dynamic frameworks are only available in 8.x and above.
 That makes sense ‚Äì OS X support seems pretty easy. iOS 7, though, confuses me a bit. How can Alamofire's podspec support iOS 7 if Swift pods require frameworks, and frameworks work only on iOS 8? Or am I misunderstanding something? 
 Ah, beat me to it @esttorhe  :)
 i think we hit `Comment` at the same time :see_no_evil: 
 Alamofire's [podspec](https://github.com/Alamofire/Alamofire/blob/master/Alamofire.podspec) points to `8.0` as you can see
 I think supporting 10.9 makes sense though, and should be ¬´trivial¬ª to add.
 Cool, I've opened up https://github.com/Moya/Moya/issues/192 to do just that. 
 Tricky, since ReactiveCocoa has a minimum OS X deploy target of 10.10. I'm having trouble getting this to work with a subspec having a different OS X deploy target. 

Since no one has requested this, I'm fine with closing this as-is. We have OS X support, which was one of the big parts; I'm on with 10.10.

If anyone wants to re-open and investigate, :tada:
  Our documentation is thorough, but not instructive. We need to do a better job of providing examples and real-world scenarios. 

(Continued from #188.)

> In general I would shoot for more complete examples. Newcomers as I am one, lack guidance. For example it wasn't quite clear at first for me if I have to implement my own Provider. Turns out it was sufficient to use the default one with a closure as an initialization parameter. ‚Äî@jk
 Might make sense for a more in-depth demo in a separate repo on this organization. 
 We have some real-ish examples in the documentation now. Do you think that is enough to close this issue?  @jk I'm glad you found the solution! Do you have any suggestions to improve the docs? 
 Cool, I've opened #189 ‚Äì let's collect all the suggestions, ideas, and feedback there :tada:
 No problem :) It's possible to specify parameter encoding on a per-target basis through the [endpoint resolver closure](https://github.com/Moya/Moya/blob/master/docs/Endpoints.md#from-target-to-endpoint-). You can use the `endpointByAddingParameterEncoding` function on `Endpoint` to help. Form there, if you really need a `nil` body instead of an empty one (though I'm not sure there's a semantic difference...) you can use the URL encoding, or otherwise. 

Does that answer your question? 
 We've got a breaking-changes release coming up, so it's a good time to get these in. 

Alamofire has default `nil` parameters ‚Äì I think we should change to reflect their behaviour. Alamofire [already handles parameter encoding](https://github.com/Alamofire/Alamofire/blob/af231fd15eec9661853bf0b5b3ec5806c8155836/Source/ParameterEncoding.swift#L103-L117) ‚Äì it only uses URL parameter encoding if the request _can_ encode parameters in the URL, so that's work we don't have to do. Since we already require users to specify the HTTP verb on the target, I think that's sufficient. 

Does that make sense? 
 @Neirys I've opened #226 that you can subscribe to to be notified when it's finished. Or take a stab at it yourself! 
  But doing that wouldn't produce a framework as well?
Which are not available to be used on 7 iirc?

## 

Esteban Torres
(+506)8813-0934
Twitter: @esttorhe

On Wed, Aug 19, 2015 at 6:13 AM -0700, "Justin Makaila" notifications@github.com wrote:

Add the .xcodeproj to your project, and then link the Moya.framework output against your project.

Let me know if you have any issues or need more clarification. 

‚Äî
Reply to this email directly or view it on GitHub.
 Maya itself should be usable without frameworks, but would require modification. 

Moya is built atop of Alamofire, so you'd need to have those `.swift` files in your project. Then you'd drop in the Moya `.swift` files, but that's not enough. Moya has `import Alamofire` statements that need to be removed first. Then in should work. 

A similar process _should_ work for ReactiveCocoa, but @mikejd you're right ‚Äì RAC 3 is iOS 8+ only. 
 Cool, glad to hear it worked out! :tractor: 
  Wow, nice catch! Thanks for the PR :cake: 

You mention the changelog ‚Äì very good point. We  Typically, breaking changes require a major update to Moya (so, we'd need to release 3.0.0 after merging this). However, a major release for _just_ a typo seems extreme, especially when it's on an optional parameter. @orta I'd appreciate your thoughts on this. 
 Yeah, afraid this _is_ a major version break.  Two options: 
- Make a backwards API compatible function?
- Save the PR till you're ready for a v3
 That makes sense to me ‚Äì we could add a new issue to remove it for 3.0. 
 Yep :+1: 
 Looks great, thanks! 
 good job
  Currently it takes a lot of steps:
1. Update podspec version.
2. In Demo directory, `pod update Moya`.
3. Commit.
4. Tag new version.
5. Push, including tags.
6. `pod trunk push Moya.podspec`.
7. Hope that current tag lints fine on trunk push.

We should automate this process, preferably using Fastlane. 
 ^ looks good, can do a `make release` task?
 I mean, your method looks good, we can automate it update and then to run `pod update` in the Moya dir via a make task :+1: 
  Cool, looks good! Could I get you to add an entry to the changelog, and maybe a line in the documentation? Then I think it'll be good to merge. Thanks again! 
 Sounds like a plan. I've just been using `git tag`, but I can deal with the release after if you want (it's a complicated process at the moment :\ ).
 Great, thanks!
 Cool, that's up: https://raw.githubusercontent.com/CocoaPods/Specs/c049a65c2b0fbe853846cd144d359f4a43d8dae5/Specs/Moya/2.1.0/Moya.podspec.json

Also opened #184 to make releasing easier. 
  Another option is to be fancy :cake: You could use method currying in some way:

``` swift
func countCompletion (completion: (Int -> Void)) -> ((data: NSData?, statusCode: Int?, response: NSURLResponse?, error: NSError?) -> Void) {
    return {  (data, status, response, error) -> () in
        if let data = data {
            let json: AnyObject? = NSJSONSerialization.JSONObjectWithData(data, options: nil, error: nil)
            if let count = json["count"] as? Int {
                completion(count)
            } else {
                completion(-1)
            }
        }
    }
}
```

Then call `UserProvider.request(.Online, completion: countCompletion { count -> Void in /* your actual callback, accepting an Int */ })`.

This avoids subclassing, which I personally like, and "feels more Swift", whatever that means. 

@callmewhy The overarching question is how do _we_ deal with this, and I can only speak for myself, but I use the ReactiveMoya or RxMoya to turn these into signals/sequences. Here's [one random example](https://github.com/artsy/eidolon/blob/5b724a68acd4e6e42d2e8b1092b4644ba6b6488b/Kiosk/Bid%20Fulfillment/RegistrationPasswordViewModel.swift#L28). 
  Thanks
 Umm. Apparently cant merge from my phone due to the failed tests.
Will check from computer later
 @regexident Thanks a lot!

@esttorhe CI failures are intermittent (see #176). When this happens to me, I [do this](http://www.idownloadblog.com/2014/06/19/ios-8-safari-request-desktop-site/)
 Ha, yeah we need to get CI working again. 
 :+1:  good tip Ash; I'll do that next time
  Hey! Thanks for letting us know. I've not used `pod try Moya` more ‚Äì honestly I don't know how it works, but I'll take a look and let you know as soon as I figure it out. 
 Think someone needs to go into the folder and run a `pod update` since moya's update, there's a more modern issue around this, but it's basically this issue: https://github.com/CocoaPods/CocoaPods/issues/1623
 That's weird ‚Äì thought I'd done that. I'll give it a try. 
 I'm willing to bet that was done after tagging
 Mmmhmmmmm. 
 Having trouble getting `pod trunk push` to work, hold tight. 
 If its failing on the lint make sure your xcode-select is pointing to NOT Xcode7¬†
Something like that was happening to me yesterday

## 

Esteban Torres
(+506)8813-0934
Twitter: @esttorhe

On Thu, Aug 6, 2015 at 6:48 AM -0700, "Ash Furrow" notifications@github.com wrote:

Having trouble getting pod trunk push to work, hold tight. 

‚Äî
Reply to this email directly or view it on GitHub.
 Good idea, @esttorhe. Checked and it's 6, which sucks since I _am_ getting a linker error. 

Set iTerm to "unlimited scrollback" to actually see the failure message. (Why is that _not_ the default??)
 I need to change that on my terminal as well now that you mention it.¬†

## 

Esteban Torres
(+506)8813-0934
Twitter: @esttorhe

On Thu, Aug 6, 2015 at 6:51 AM -0700, "Ash Furrow" notifications@github.com wrote:

Good idea, @esttorhe. Checked and it's 6, which sucks since I am getting a linker error. 

Set iTerm to "unlimited scrollback" to actually see the failure message. (Why is that not the default??)

‚Äî
Reply to this email directly or view it on GitHub.
 Cooooool got it to work! @jk Could you try again? Or, rather, `pod try` again?

![](http://2.bp.blogspot.com/_g88-bL8l6H0/TLPAOwcfosI/AAAAAAAAAA8/UwAQw5vcdLI/s1600/3322267.jpg)
 <.<
 Oh yeah? I'm a pretty compulsive ‚åòK'er, but I'll be on the lookout for slowdown. 
  To match the ReactiveCocoa one. 
 Yeah, exactly! We'd need to unindent the code and add Swift code highlighting (see the existing README samples' markdown). :cake:
 Hey @argentounce ‚Äì good question!

The RxMoyaProvider is created using the _exact same_ method as a regular `MoyaProvider`. You just say:

``` swift
let provider = RxMoyaProvider<MyAPI>()
```

And that's it! All the examples in the docs that show how to configure the provider apply identically to the RxSwift and RAC providers. Demos for those projects are a great idea :100:
  Fixes #173.
 Looks like something was missed in https://github.com/ashfurrow/Moya/pull/172 
 Ha, yeah @colinta I hear you. From what I understand of Carthage, which is by choice not a lot, it's necessary. 
  OK cool, I'll merge and we can fix CI later. 

I don't think `master` is in a stable state to release a build, so you'll have to use this in your Podfile:

``` ruby
pod 'Moya', :head
```
 I don't believe so, `:head` fetches from the repo's `HEAD` iirc. 
 OK, so once #174 is done, I'll be release 2.0 in #149, so we should be :+1: soon. 
  :+1: 
  This image is misleading:

![](https://raw.githubusercontent.com/ashfurrow/Moya/master/web/bad.png)

It's the first image in the README and is in the "on-brand" Moya colours. A casual reader might infer that this is the Moya solution. 

We should make it clear that this is _not_ how Moya works, but is an example of the problem that Moya solves. Possible solutions:
- Desaturate the image to make it look sad.
- Add sad faces or sad face emojis :cry: 
- Add a rage-comic style "wtf" person ‚Äì [Jackie Chan](http://wallpaper.ultradownloads.com.br/276253_Papel-de-Parede-Meme-Jackie-Chan_1920x1440.jpg)? 
- Something else.

Suggestions? Thoughts? 
 Perhaps leave the introduction paragraph and then a section of

## Current state of apps

![](https://raw.githubusercontent.com/ashfurrow/Moya/master/web/bad.png)

<Rest of that section>

## How `Moya` solves this

![](https://github.com/ashfurrow/Moya/raw/master/web/good.png)
<Next paragraph explaining how Moya works>
 Honestly I like that the image uses `Moya` colors to keep it in sync and consistent with the rest of the README; looks ¬´prettier¬ª IMHO
 Yeah, that's a good point. Maybe desaturate them a little bit? 

![bad](https://cloud.githubusercontent.com/assets/498212/9091634/49359e7e-3b6f-11e5-8f06-4928713098d3.png)

Meh, that kind of sucks too. 
 hahahahaha; it makes me think of infomercials when people are terribly using a normal product product.

Put a filter to make it look ¬´old and archaic¬ª? ¬Ø\_(„ÉÑ)_/¬Ø
 ![bad-2](https://cloud.githubusercontent.com/assets/498212/9091876/b2a51e92-3b70-11e5-807f-e65de781836e.png)
 Hmm. 
 Nah, I think maybe a label saying "BAD" or something would be illustrative. 
 Perhaps the ¬´biggest¬ª issue is that the image is the first in the README and as you pointed out could be potentially confusing.

What about putting them both side by side with `current / Moya` as a footnote to the images?

PS. I think the label could work as well but I'm throwing ideas just in case
 might be better to try have both in one image (roughly chucked together)

![screen shot 2015-08-27 at 10 07 21 am](https://cloud.githubusercontent.com/assets/49038/9522553/788e7656-4ca3-11e5-8c1e-df89ff449553.png)

http://cl.ly/0E0u3H422C3F/moya-front.sketch
 @orta it's a good start, but I think it needs more character. Suggestion: 

![artboard 1](https://cloud.githubusercontent.com/assets/498212/9523674/38babc28-4ca9-11e5-8937-0200a6c753a6.png)
 :shipit: 
 this this is the direction we're after, I can spruce it up and give it some good arrows etc. I prefer the emoji.
 Sounds good to me!
  Thanks a lot, Justin! It's a huge PR ‚Äì I'll take a look at it this weekend. If any other contributors could lend a hand, that'd be :+1: 

Justin, could I please ask you to mark these improvements in the changelog? I see you've already updated the README ‚Äì awesome :tada: 

The tests are failing ‚Äì looks like a Circle configuration problem around the Demo workspace. Any ideas?
 It's common to check in the Pods directory for libraries, so this is duplicating all of that too: https://github.com/ashfurrow/Moya/tree/master/Demo/Pods

Personally, I'd remove both of them, and in the README tell people if they want to demo it run `pod try Moya`.  It's a huge amount of additional files for a lib that's probably 6-8 swift files big in reality.
 `pod try https://github.com/justinmakaila/Moya/` will let you test. You need to add a working Podfile to the Example dir, [this](https://github.com/ashfurrow/Moya/blob/master/Demo/Podfile) will probably do it.
 Yeah, I think it's time to separate out the demo from the library repo. 

I only included the Pods directory because I was told it was necessary for Carthage support. If someone were interested in writing a how-to blog post about supporting Carthage and CocoaPods, that would probably be a great service to the open source community. As a library owner, I remain confused about how my own library is structured and why. It's not a comfortable feeling. 
 This could be rolled into #168 where we could have a Demo repo for both Carthage and CocoaPods, separate from the main repo. 
 Downside of that is `pod try Moya` doesn't work
 How so? Never used pod try before. 
 It will go to the Moya podspec, find it's repo, download it and look for an xcodeproj + podfile. Separating the demo repo from the lib repo would make that tough. 
 Not right now, https://github.com/CocoaPods/cocoapods-try/issues/38
 I don't think moving the example to a separate repo is a good idea, other libraries don't do this. 

I'd move the `Pods` and the Carthage-whatever directories into `.gitignore` then add a note in the README that if you want to run the example you have to go to the example folder and run `pod install` or `carthage install`. Or for the no-effort approach `pod try Moya`. Again, this isn't some mega-huge library with thousands of moving parts.
 Amazing! Let me know if I can lend a hand. Thanks again! :boom: 
 Hey @justinmakaila ‚Äì would it be possible to have the Example app and tests still built using CocoaPods? 
 So Carthage relies on the Moya xcodeproject? I thought CocoaPods was generating one for us now. Sorry if I'm showing my ignorance here ‚Äì I'm sure you can understand my hesitation to make Moya depend on an unfamiliar tool. 
 OK, so. Touchy subject for some ‚Äì I want anyone reading this to know that I have a lot of respect for the developers who've built Carthage, for @justinmakaila and @neonichu who have done so much work to support Carthage in Moya, and for developers using Moya. If someone tries to turn this into a flamewar, I'll be very disappointed in them. 

:heart: 

Ok! So Moya actually predates Carthage by a few months ‚Äì Moya was build as a CocoaPod, which the capabilities and limitations of that tool in mind. 

Carthage was released, and people asked for Carthage support on Moya. I didn't know how to add it, but several contributors offered to help, which is fantastic :smile_cat: They asked for help from Carthage, but their developers said that subspec-like functionality [conflicts with their philosophy](https://github.com/Carthage/Carthage/issues/588#issuecomment-116137295). 

Undeterred, @justinmakaila and others laboured to come up with a solution that worked for both tools, requiring Moya to compromise on the original library structure (informed by CocoaPods). At last, we'd nearly accomplished this herculean task. 

My remaining issue is that this PR fundamentally changes Moya from a CocoaPod that could support Carthage, to a Carthage library that can incidentally be used with CocoaPods. This might seem like a trivial matter, and it's at this point that I need to recognize that _I_ no longer own Moya ‚Äì the community does. My own feelings matter a lot less.

But the community has been using Moya _as_ a CocoaPod for its entire lifetime, and a change of this foundational nature needs to be considered carefully. 

Respectfully, Justin, I think the Demo, unit tests, CI, and all that stuff should remain built atop CocoaPods. I realize this undoes some of the work you've put into this, so I'd like to do the work: I'll check out your fork, get Moya working atop CocoaPods again, ensure that Carthage support still works, then send a PR back into your branch so you can review my changes. Does that sound OK to you? We can hop on a google hangout to discuss this in person, too!
 Hey! This is still on my radar, just got sidetracked. 

As for the code structure, having the separate repos like https://github.com/Moya/ReactiveMoya is fine for _code_, but I think it's a good idea to keep all documentation and issue tracking in this main repo. This will keep the barrier to entry low (someone learning to use Moya shouldn't have to know how we structure our code to read our docs). Any objections? 
 Alrighty, I've disabled issues on the other repositories. We also need to update their READMEs to point to this repository. These other repos are basically just places to store files.

If we're centralizing docs here, I think it makes sense to centralize tests here as well. I can't see that being a problem with Carthage ‚Äì @justinmakaila does that sound OK? 
 Shouldn't be a problem ‚Äì we're restructuring the tests to run under CocoaPods, which won't have that problem. 
 Orta and I have implemented a solution that doesn't require us to split up the source code into three separate repositories, which I've PR'd in #215. @justinmakaila thank you so much for your work on this :smile_cat: 
  I've never had an open source project reach this level of popularity ‚Äì I think it's time we consider whether or not it makes sense to move Moya off of my own personal GitHub account. I've not run an organization before, either. 

Benefits:
- Easier to mention all contributors in important issues/PRs.
- Emphasizes that this is a community project and not a personal one.
- We could separate Moya into distinct repositories, one for the core, one for ReactiveCocoa, and one for RxSwift.
- Adding new, related libraries would be easy and be on the same organization.

Drawbacks:
- Existing podspecs, cartfiles, submodules will need to move over to the new URL (redirects seem to stop working after a month in my experience).
- I don't get my name all over the project anymore.

Is anyone else aware of other tradeoffs? @orta?
 If you're thinking about it, then it should probably be done. Given that `/moya` isn't free, you might want to consider if you can think of other sibling projects that could go with it.

The distinct repos sounds like a bunch of faffing though to me FWIW.
 Good points. 

Distinct repos would solve our Carthage problem; they refuse to implement subspec-style libraries because it "encourages large libraries." Could be something CocoaPods could do ‚Äì it crease a project now, maybe one with separate framework targets for different subspecs?
 Would probably be a pretty reasonable CP plugin for lib authors wanting to make binary releases.
 Leaning more in favour of this. We should probably add a [CoC](http://contributor-covenant.org) while we're at it. 
 So, since no one has any objections, I've decided to go ahead with this. Here are the steps we'll need to take:
- [x] Think of an organization name (this is the hardest part).
- [x] Create a new org.
- [x] Add Moya contributors as admins to the org.
- [x] [Transfer the repo](https://help.github.com/articles/transferring-a-repository/) to the org.
- [x] Create an org [code of conduct](http://contributor-covenant.org/version/1/2/0/).
- [x] Send a PR to CocoaPods/Specs to change the git URLs to the new endpoint. (Right?)

Any other steps? Any suggestions on a name? 
 >  Send a PR to CocoaPods/Specs to change the git URLs to the new endpoint. (Right?)

Yep, the default redirects will work, but not forever.

> Any suggestions on a name?

MoyaAPI, MoyaNetworking, nothing strikes me as awesome. Will ask @moya if it can be transferred.
 Cool, yeah. 

@colinta Initially, it'd just be this repo and probably a demo or two showing how to use Moya. In the long run, I'd love to see the org grow to include new functional-ish ways to use Swift to solve problems on iOS and OS X. It would be awesome to have a sort of meta repo where we could keep a list of ideas for projects. That way if someone had an idea, or needs an idea, they have a space they can get more help than on their own.
 @orta Thanks for asking :)
 Given the lack of a reply from @moya I think it might make sense to go with MoyaAPI ?
 Or MoyAwesome :stuck_out_tongue: 

MoyaAPI just seems so... _pedestrian_. 
 It's possible, but the user could have private activity that we just can't see. I don't want to write them off :)

Moya is named after [a living spaceship](https://en.wikipedia.org/wiki/List_of_Farscape_characters#Moya). **puts on nerd glasses** Moya doesn't speak, so she doesn't have a voice actor, but she's biologically bonded to a pilot, voiced by Lani Tupu. It's [been suggested](https://twitter.com/twannl/status/628670104667070464) that using some variation of that name might work, though those names are taken. I'd be pretty cool with using another homage to Farscape, too, but everything I found was too on the nose. 
 Nah, https://github.com/Leviathan/ is taken. 
 I've been in contact with GitHub support, and https://github.com/Moya is now an organization I control. I'll be adding contributors as team members there, then transferring and doing related chores hopefully today, maybe tomorrow. 

:tada:
 Awesome sauce! :tada: 

:clap: 
 OK, so I've submitted a PR to update the Moya podspecs: https://github.com/CocoaPods/Specs/pull/13370

Circle CI needs to enabled the iOS beta on the Moya organization, so our CI will be broken until they flip that switch. 

I've also submitted this PR on Moya to update docs, CI, etc: https://github.com/Moya/Moya/pull/175 If one of @Moya/contributors could take a look, that'd be awesome!
  Hey, thanks so much! This is a great step forward. @esttorhe has done some work in #162 ‚Äì maybe you two could work together?

Until RxSwift renames `defer`, if it does, you just need to surround it in backticks like ``defer ``.
  I did this originally to implement inflight request tracking; a multicast connection's `autoconnect()` generates a new signal every time (subscribed to the same underlying signal), so I couldn't store it in the requests dictionary. I got a little frustrated and settled with a solution that appeared to work. I should review the docs and implementation. Since Moya has good test coverage, we can be sure that any changes don't break behaviour :smile: 
 Fixed in https://github.com/Moya/Moya/pull/232 ‚Äì currently in 3.0.0-develop branch. 
  Yeah, that's a fair point. We use comparisons based on the URL, the HTTP method, all the parameters, and the body. I would think that sending the same request twice would be different, but I suppose this is an assumption. 

Any suggestions? We could extend behaviour in the `MoyaProvider` class ‚Äì maybe a closure like this?

```
typealias ShouldCheckInflightRequests = (Endpoint) -> (Bool)
```

That way people _can_ opt-out on a per-endpoint bases if they want? Open to suggestions on this. 
 Hmm. Maybe a good default implementation would specify that GET and HEAD requests are coalesced, but POST PUT PATCH and DELETE ones are not. That seems like a sane default to me. Thoughts?

As for the inflight caching ‚Äì using a token makes sense to me. 
 Yeah, I dunno. Seems like this might be more trouble than it's worth, but @aschuch and @kzaher are right ‚Äì this should definitely be opt-in. 
 Fixed in https://github.com/Moya/Moya/pull/232 ‚Äì currently in 3.0.0-develop branch. 
  Ok, so I have tried to fix this, but it broke my test when I added the `>- variable`. It won't complete whet this is present.

The sync is working well on RxSwift but it won't complete if added to the `ReactiveCocoaMoyaProvider`.

Here is the test for the RxSwift to see if you can help me with that. I don't like the way it is but I couldn't think of another way:

``` swift
it("returns identical observables for inflight requests") {
    let target: GitHub = .Zen
    var response: MoyaResponse!
    let outerSignal = provider.request(target)
    outerSignal >- subscribeNext { (response) -> Void in
        expect(provider.inflightRequests.count).to(equal(1))
        let innerSignal = provider.request(target)
        innerSignal >- subscribeNext { (object) -> Void in
            expect(provider.inflightRequests.count).to(equal(1))
        }
    }
    expect(provider.inflightRequests.count).to(equal(0))
}
```
 Thanks for bringing up the issue, @kzaher ‚Äì good catch! Hand't considered the signals coming from other threads >.<

@alcarvalho Thanks for the help! It's a tricky problem and a _very_ difficult use case to test. Could I ask you to open a pull request, with your work and new tests? We can have a conversation about it there :fireworks: 
 Sure, @ashfurrow. Done! :wink: 
 This was fixed when #166 was merged. 
  Awesome, thanks!
 no problem :) Probably a good idea. 
 That's great! And there's someone working on the migration of RxSwift
already.

Maybe we'll have soon. ;)

On Fri, Jul 3, 2015 at 18:54 Ash Furrow notifications@github.com wrote:

> no problem :) Probably a good idea.
> 
> ‚Äî
> Reply to this email directly or view it on GitHub
> https://github.com/ashfurrow/Moya/pull/162#issuecomment-118432120.
 Great, thank you!

Now the tests are failing because some files are pointing to the absolute path on someone's computer. Maybe yours?

```
‚å¶  unable to read module map contents from 'Target Support Files/Pods-Alamofire/Pods-Alamofire.modulemap': Error Domain=NSCocoaErrorDomain Code=260 "The file ‚ÄúPods-Alamofire.modulemap‚Äù couldn‚Äôt be opened because there is no such file." UserInfo=0x7feb2a75bdc0 {NSFilePath=/Users/distiller/Moya/Demo/Pods/Target Support Files/Pods-Alamofire/Pods-Alamofire.modulemap, NSUnderlyingError=0x7feb2a7768f0 "The operation couldn‚Äôt be completed. No such file or directory"}
```

This `/Users/distiller/Moya/Demo/Pods/Target Support Files/Pods-Alamofire/Pods-Alamofire.modulemap` folder is inside someone's home folder. :wink: 
 Are the tests working on your machine? From the log I can see now is matter configuring the correct version of XCode on the `circleci.yml` file. But this could be just the beginning. :worried:  
 I see. After you get the tests running locally we'll need to see what is the correct XCode 7 version for Circle CI, if they support it already. Just to make sure the tests are passing there too. 
 Hey there @vCrespoP! I'm not sure the status ‚Äì I've not been using Swift 2 yet, but that will change soon, so I'll have some work time to devote to it. 
 Sadly (or for our own safety) we can't point `podspec` dependencies to specific branches and that's why I left all dependencies on this `PR` without version specific tags.

If you take a look at the `Demo` `Podfile` you'll see it like this:

``` ruby
platform :ios, '8.0'

source 'https://github.com/CocoaPods/Specs.git'

use_frameworks!

#pod 'ReactiveCocoa', :git => "https://github.com/reactivecocoa/reactivecocoa.git", :branch => "swift2"
pod 'RxSwift', :git => "https://github.com/kzaher/RxSwift.git", :branch => "feature/swift2.0"
pod 'Alamofire', :git => "https://github.com/Alamofire/Alamofire", :branch => "swift-2.0"

pod 'Moya/RxSwift', :path => "../"
#pod 'Moya/ReactiveCocoa', :path => "../"
pod 'Moya', :path => "../"

target 'DemoTests' do

  pod 'Quick', :git => 'https://github.com/Quick/Quick', :branch => 'swift-2.0'
  pod 'Nimble', :git => 'https://github.com/Quick/Nimble', :branch => 'swift-2.0'
  pod 'OHHTTPStubs'

end
```

That's in order to satisfy the `Swift 2.0` requirements that can't be specified on the `podspec`.
As for `ReactiveCocoa` haven't had the time to tinker with the custom made `podspec` to point to a `Swift 2.0` branch and thus, the status on that front is still the same :snowflake: 
 Hey @esttorhe ‚Äì could you close this, rebase from `master`, then submit a _new_ PR into Moya's `swift-2.0` branch? 
 @ashfurrow I'm headed out to get my :eyes: checked and won't be able to use the computer for 3-4 hours.

I'll close and rebase later today or tomorrow morning tops.
 Cool, thanks!
 FYI started this late last night with my eye sight barely functioning and couldn't get too far due to my :eyes: being too tired.

Today is a brand new day :city_sunset: and I'll hope to have this done by _EOD_ today
 Take your time! The last thing we want is for you to get strained and burn out on open source :)
 The rebase is done; I'm going to close this issue BUUUUUUUUT

I can't compile on √ü5; getting the following

``` console
Module file was created by an older version of the compiler; rebuild 'Security' and try again: /Applications/Xcode-7.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/swift/iphonesimulator/x86_64/Security.swiftmodule
```
 Or maybe I won't because I'll need to rename the branch or something else in order for Github to let me open a new `PR` (can't from the same `branch`)
 I've had that happen before. Silly GitHub. 

![](https://38.media.tumblr.com/96175edf52520fea3c47f0588fb55ba5/tumblr_mjkd49n4xk1rt8levo5_500.gif)

Maybe rename your branch, push, then PR into `swift-2`?
 ## I did it!!

![](http://i2.wp.com/metrouk2.files.wordpress.com/2015/05/shia-labeouf-video-still.jpg?crop=70px%2C14px%2C325px%2C183px&resize=650%2C366&quality=80&strip=all&w=450&h=253)
  That's a really great point, thanks!

PR looks good ‚Äì would you mind adding an entry to the changelog? 
 Interesting! I'll take a look later. It could be just that ReactiveCocoa was not intended to be used standalone, or that I didn't anticipate this need when I made the podspec. 
 Yeah, looks like ReactiveCocoa's `Core` subspec is not intended to be used standalone. CocoaPods bundles in whatever UI stuff you need depending on your platform. Could be that this is a use case the ReactiveCocoa developers _did_ intend, but they don't contribute to the podspec. 

Thanks again for the contribution!
  Hmm. I'm not quite sure what to make of this. Hoping @neonichu knows. 
 I'm going to move this to #154 ‚Äì there's a discussion there surrounding Moya and Carthage. 
  Thanks!
  Hey, totally! Great idea! I've pushed a `swift-2.0` branch so we can follow that there. If you're able to, a PR into that branch would be very much appreciated :)
 I'm not attached at all ‚Äì @neonichu asked to add the `Pods/` directory and its friends for Carthage support. If we don't need that, that's cool with me. 

![](https://s-media-cache-ak0.pinimg.com/originals/d9/be/72/d9be72f4ac11c7da286fa98e99c929f3.jpg)
 Hmm, sorry, I'm re-reading this and I thought you meant to pods _directory_. I'd feel more comfortable keeping the demo project built with CocoaPods. 
 Can this be closed with #194 ?
 Sounds good. 
  Hi there @XBeg9 ‚Äì good question. The `request` function purposefully returns a `CancellableToken` to obscure the underlying Alamofire implementation. The idea is that you shouldn't need to know that Moya uses Alamofire "under the hood", so returning the request defeats that purpose. 

So, how do we make it so you can use this mapping library, which looks pretty cool. That library is actually a thin wrapper around [ObjectMapper](https://github.com/Hearst-DD/ObjectMapper), which you could use directly. That's not a satisfying answer, I know. 

An alternative would be to extend the `MoyaProvider` in another subspec in a similar way that AlamofireObjectMapper does. It shouldn't be that much work, but I'm swamped until the weekend.

What sounds like the best solution to you? Does anyone else have suggestions? 
 So I'm thinking that we'd have `extension MoyaProvider` that would call through to the original `Request`, but also take a callback block similar to AlamofireObjectMapper. So it would call through to the original `request` function, then do something in the callback to map the objects, then call its own callback. 

So it would look something roughly like this:

```
func someRequest(target, someCallback) {
    request(target) { (thing) -> () in
        let mappedObject = ObjectMapperCallOrWhatever
        someCallback(mappedObject)
    }
}
```

Does that make sense? 
  Yeah, it doesn't appear to ‚Äì apologies for that. @neonichu or anyone else with Carthage know-how: what would be involved in adding support for the RxSwift subspec? 
 Oh, I see. So someone using Moya with Carthage now just _has_ to also use ReactiveCocoa, even if they only want the original `MoyaProvider`, not the ReactiveCocoa subclass? 
 RxSwift was the original name of the RAC 3 proof of concept. It also happens to be the name of a [Swift-based reactive extensions library](https://github.com/kzaher/RxSwift). The library is young but growing. Whether there's enough demand for this from Carthage users, I don't know. 
 @MarvinNazari Wouldn't be a bad idea if this was a Carthage-only repository, but I'm a CocoaPods user and this _is_ the right way to use CocoaPods. 

I feel like the Moya team have been very flexible on a number of issues in order to support Carthage. Frankly, I'm tired of jumping through hoops to support a nascent dependency manager that ignores community feedback. 
 @MarvinNazari Sorry, that was very rude of me. I don't mean to dump this on you ‚Äì I've been growing frustrated at this process for some time now. Splitting the functionality into multiple repos would be a good idea, but I don't think it's the right solution for Moya.
 @MarvinNazari I'm glad you like our library :) I wish there were a better way to support your use case. Hopefully the Carthage people will help.

Like, how do they do they manage different frameworks for different platforms? Could that work somehow? 
 Yeah, exactly. Could we leverage that technique? 
 Hmm. The target would be an issue, since CocoaPods lumps the subspaces into the same framework. 

So we'd basically need to create and maintain a separate Xcode project solely for Carthage support, right? 
 I'd appreciate that, Justin, thanks! 
 Cool, this looks great @justinmakaila ‚Äì want to submit a PR to add those instructions to the README? 
 @justinmakaila sounds cool, thanks! Send the PR over and we can take a look there :tada:
 Now that we have an organization, could we use submodules somehow to dump the necessary files for Moya, Moya/RAC, and Moya/RxSwift into separate repositories? I don't really know how Carthage works. 
 @gfontenot That sounds like a really intriguing solution ‚Äì I had never considered having subspecs use a different `source` ‚Äì @orta any reason why that'd be a bad idea? I personally like having all the source files in one repo, but if it solves our projects with Carthage support, then it seems like a reasonable compromise. 

I'll add you two to the org. Thanks so much for your help!
 CP can do the submodule fine too :+1: 
 Super, thanks @justinmakaila! GitHub repo transfers are messy ‚Äì I've created the other repos on the Moya organization for you, and you should have push rights. Just add a remote for them, pull, merge, and push.

``` sh
cd RxMoya
git remote add upstream https://github.com/Moya/RxMoya.git
git pull upstream master 
*** Merge any conflicts ***
git push upstream master
```

And repeat. I've created an RxCore repo for the shared resources, in case you need it. 

Let me know if I can do anything more to help! I really appreciate your work, and the work of everyone here to come up with a solution that works for everyone :tada: Good job, team. 

![](https://s-media-cache-ak0.pinimg.com/originals/d9/be/72/d9be72f4ac11c7da286fa98e99c929f3.jpg)
 Ah, sorry ‚Äì first time using GH organizations :) Try again?
 So @justinmakaila what are the next steps? Are the other repos working with Carthage? Swift 1.x or Swift 2? Do we just need to update CocoaPods now?

If the other repos are still works-in-progress, we should consider adding a note to their READMEs. And maybe include instructions for their corresponding CocoaPods subspecs' installations. Does that make sense? 
 Super, cool! So if everything is working with Carthage, there's only a few things left to do:
1. Ensure the new repos with RxMoya and ReactiveMoya are up-to-date with this one. 
2. Remove files from this repo.
3. Update podspec to point to the two new repos.
4. Test/lint podspec
5. Ensure `pod try` continues to work.
6. Release a new version of Moya.

Let me know if I'm forgetting anything. 

All sounds good? I can get started as early as this weekend, unless someone wants to do it sooner. 
  To my knowledge, no-one has stepped up to keep the Carthage/RAC branch in sync, we'd welcome a PR making sure it supports the latest from you.
 Yeah, to be honest I'm not entirely sure how dependency resolution with Carthage works. If it were CocoaPods, I'd fork the Moya repo and point to my fork in the Podfile. 

@neonichu: you added Carthage support ‚Äì any ideas? 
 Cool, thanks @aschuch ! I wasn't sure how the `~> 3.0` signifier works in Carthage. 
  :+1:  thanks
  tl;dr Moya doesn't currently support this.

Hmm. Interesting question. Alamofire seems to [handle this with `NSURLCredential`](https://github.com/Alamofire/Alamofire/blob/922c1ca3580b7adc9235bede1e99580e02ad3e9f/Source/Request.swift#L76-L80). Is this how you've done HTTP auth in the past? 

Maya doesn't currently have support for this, but using the `sharedSession` `NSURLSession`, so you _should_ be able to set things there and have all HTTP requests use those credentials. Obviously that's not a great fix, though. 

I guess what this would really need is some kind of (optional) way to specify which `NSURLSession` to use: the default, or one configured for your endpoints alone. 

Others are likely more familiar with the network library underneath Alamofire. Anyone have suggestions on how to implement this? 
 That makes sense. But it also adds a lot of complexity around individual API calls. Developers now need to remember which endpoints need auth and which don't, and that need is spread across their entire codebase. 

I think we need one of two things:
- an optional part of the `MoyaTarget` protocol that specifies per-target credentials
- an optional closure in the `MoyaProvider` initializer that gets last-moment chance to specify credentials based on the target. If it returns credentials, they're added to the request in the provider. 

I like the second option better because most users don't need HTTP basic auth and it keeps our protocol leaner. What do you think? 
 That would be lovely! Please let me know if you'd like to bounce ideas around or anything :smile: 
 Cool, thanks for the update @davidbarsky. Please let us know if there's anything else you'd like to see added to Moya!
  This is great, @lluisgerard ‚Äì very good catch. Thanks!
  As per @alloy's discussion in #135.
 :+1: 
 :bow:
  It uses default values for its initializers that need to be duplicated by subclasses. 

``` swift
public init(endpointClosure: EndpointClosure = MoyaProvider.DefaultEndpointMapping,
    requestClosure: RequestClosure = MoyaProvider.DefaultRequestMapping,
    stubClosure: StubClosure = MoyaProvider.NeverStub,
    networkActivityClosure: Moya.NetworkActivityClosure? = nil,
    credentialClosure: CredentialClosure? = nil,
    manager: Manager = Alamofire.Manager.sharedInstance) {

    self.endpointClosure = endpointClosure
    self.requestClosure = requestClosure
    self.stubClosure = stubClosure
    self.networkActivityClosure = networkActivityClosure
    self.credentialClosure = credentialClosure
    self.manager = manager
}
```

Dunno how we could do this.. 
 This is really tricky. Basically our providers are containers for data (their configs) and a `request` method. That's, like, the definition of a class. 

I suppose we could move `MoyaProvider` to be a protocol and put `request()` in a protocol extension? Or maybe turn Moya into a `struct` instead of a class. The real hassle is just updating initializers that don't do anything but call `super.init(...` so structs would remove that pain most of the time. Or maybe we could use composition instead of inheritance? 
 Alternatively, it seems a bit odd that subclasses _must_ override the initializer. 

``` swift
override public init(endpointClosure: EndpointClosure = MoyaProvider.DefaultEndpointMapping,
    requestClosure: RequestClosure = MoyaProvider.DefaultRequestMapping,
    stubClosure: StubClosure = MoyaProvider.NeverStub,
    networkActivityClosure: Moya.NetworkActivityClosure? = nil,
    credentialClosure: CredentialClosure? = nil,
    manager: Manager = Alamofire.Manager.sharedInstance) {

        super.init(endpointClosure: endpointClosure, requestClosure: requestClosure, stubClosure: stubClosure, networkActivityClosure: networkActivityClosure, credentialClosure: credentialClosure, manager: manager)
}
```

All the subclasses ever do is call `super.init()`. How can we abstract this?
 Maybe instead of subclassing, we can add extensions to the existing `MoyaProvider` type? 
 I like the idea of using protocols to extend the primary type, but I'm concerned about the constraints that would introduce for existing users who are currently subclassing (say, `RxSwiftProvider`). I'm going to look through [Eidolon](http://github.com/artsy/eidolon) for how we use Moya, and see if there are any foreseeable problems before starting an implementation.
 Fixed in #238.
 Well, it was addressed in the sense that subclassing the provider no longer requires so many initializer parameters and repeating their default values. What you're describing sounds like a new issue. I have subclassed `RxMoyaProvider` [here](https://github.com/artsy/eidolon/blob/1c746f9a9c6420cda9f691468783fee67376e8b1/Kiosk/App/Networking/Networking.swift#L7) without issues. 
 Subclassing in Swift usually requires calling a designated initializer in the superclass, I'm not sure of a great way to avoid this in Moya. Do you have suggestions?  

## 

Ash Furrow
https://ashfurrow.com/  

On April 30, 2016 at 12:24:01 PM, nikita leonov (notifications@github.com(mailto:notifications@github.com)) wrote:

> I see. Yes, it is easier to define default parameters now, but it still require overriding designated initializer. Actually situation does not change in compare with what you writing in Oct, 1. Here is current experience of subclassing ‚Äî https://www.evernote.com/l/AEaV5Z1HlZRGprguAUiszmTarcbrRgFzQA0
> 
> ‚Äî
> You are receiving this because you modified the open/close state.
> Reply to this email directly or view it on GitHub(https://github.com/Moya/Moya/issues/144#issuecomment-215976739)
 Interesting. I suppose what I meant was, a reason to subclass would be to provide custom behaviour, which may need to be given as an initializer parameter Subsequently, you'd want to define all the usual default values and would also need to call the super-initializer. I would love to hear ideas to solve either of those problems ‚Äì please keep us in the loop about your progress, maybe on a new issue? 
  :+1:
Would also put MoyaResponse file inside a newly created ReactiveCore
folder.

On Fri, Jun 12, 2015 at 04:59 Alexander Schuch notifications@github.com
wrote:

> At the moment, I find it hard to browse code on the Github repo.
> I think we should consider adding a folder structure to make browsing Moya
> on Github a better experience.
> 
> I would keep everything the same but introduce a new Moya folder that
> contains all the relevant files.
> - üìÅDemo
> - üìÅdocs
> - üìÅweb
> - üìÅMoya
>   -- Endpoint.swift
>   -- Moya.swift
>   -- MoyaResponse.swift
>   -- üìÅReactiveCocoa
>   --- Moya+ReactiveCocoa.swift
>   --- RACSignal+Moya.swift
>   -- üìÅRxSwift
>   --- Moya+RxSwift.swift
> - README.md
> - Moya.podspec
> - etc...
> 
> Thoughts?
> 
> ‚Äî
> Reply to this email directly or view it on GitHub
> https://github.com/ashfurrow/Moya/issues/138.
 No, it's used by reactive in general, meaning ReactiveCocoa and RxSwift, right now. I have extracted it from the ReactiveCocoa integration when I implemented the RxSwift provider to be a common core.

But there's a ticket #134 to remove all comments from file's headers.
 @SRandazzo the lack of an xcproj is strange to me too. The way I do it here is by opening the Demo to edit the code for the library. Not the most intuitive.
 I like this idea ‚Äì will do. 

As for a dedicated project/workspace, what would be the advantages of using one? The library is installed using CocoaPods; the Demo project is for illustrating the library's use and for its unit tests. That could be moved into a test-only project, sure. What advantages would there be of having another project/workspace? 
  Does it make sense now that we're saying that `parameters` are on the target, and `path` is on the path, given that either property depends on the enum's associated values? 

/cc @chriseidhof
  I want other people to feel like they own Moya, too, so it survives in the long run.

What I'm looking for is people who can:
- Reply to questions.
- Help diagnose/fix issues people have.
- Help form a roadmap for future releases.

All when you have time and feel like it. It's not meant to be a burden.

> Don't ever feel bad for not contributing to open source. ‚Äî@alloy

Thanks to @searls for the push to do this. 

If you're interested in helping out ‚Äì when it's convenient for you ‚Äì comment on this issue and I'll add you as a committer with push access.

/cc @colinta @orta @skywinder @garnett @aschuch @raphaelmor @powerje @process255 @powerje @neonichu @Thomvis @alcarvalho @joshuatbrown @SRandazzo @pietbrauer @juhagman @vandyshev @jspahrsummers @lipka @stephencelis 
 Super awesome!
 Awesome. @neonichu since you mentioned it, I've added you as an owner to the pod in CocoaPods trunk. 
 I would love to help, too! I am still in the early stages of adopting it, but our new app's communication layer will be all using Moya. :+1: 
 Gonna call this done! Thanks for your help, everyone :cake:
 @alloy I like it. As though adding more contributors should be a regularly part of open source. :bow:
 Yeah, go for it üéâ The guidelines Orta linked to are great, please let me know if I can help at all, and let me know how it goes! 
  Cool, thanks!
  Both are accurate (think "provider" as in `MoyaProvider` class), but I like your wording better. Thanks! 
  Awesome, thank you! 
  Thanks!
 Cool! Open an issue if you have any questions! 
  Cooooool thanks!
  Cool, thanks Boris! 
 OK cool. I've got a PR open for checking in the Pods directory. Once that is :green_apple: , I'll merge and you can rebase from master? Or should it be safe to merge directly in?

/cc @MichaelMcGuire
 Ha, meeerrrrge conflict. 
 @neonichu Wanna rebase so I can merge? 
 :red_circle: can you `pod install` or `update` or whatever needs to pass?
  Lots of changes:
- Documentation revamp. Expanded a bunch and added examples. 
- Parameters moved from `request()` functions to the target enums, instead. 
- HTTP methods moved from `request()` functions to target enums, instead. 
- The result of the last two is that there is only one `request()` method in the non-reactive `MoyaProvider` class, and one more in the `ReactiveProvider` class. 
- Related changes to the endpoint-resolving closure.
- `SampleResponse` enum now accepts a closure that returns sample data instead of the data itself.

Overall, I think this is a general simplification of the Moya framework. Lots of things that made sense when I started this didn't turn out being as useful as I had anticipated. This really supports a simple use: setup a target enum and create a provider. No messing around with `Endpoint`s at all anymore, unless you want to.

Once merged, I'll release this as a `1.0.0`, since it has breaking changes (noted in the changelog). 

Fixes #123 (documentation)
Fixes #74 (move parameters to target)
Fixes #60 (moves HTTP method to target)
 Thanks for the feedback! Yeah, my fingers were getting pretty tired >.<
  Neat! I'll take a look :rocket: 
 Hey! I've thought it over, and I don't know if this tool is right for this project. It seems to heavily rely on using labels and GitHub comments appropriately, but most of the time, I don't do that on Moya. I think the changelog generator is a really great idea, but it's not a good fit for this project. 

Thanks again for the suggestion!
  You absolute troll. 
 ‚ù§Ô∏è
  This looks amazing! :heart_eyes_cat: 

One small nitpicky note: The rest of the tests use spacing around the expectation, like `expect(thing).to( beNil() )` ‚Äì it's something that @orta got me doing and I think it looks nicer. 

Otherwise, looks awesome. Very nice job with the tests :+1:
 Hey there!

Sorry, missed the update. I'll take a look in a bit ‚Äì gonna merge the swift-1.2 branch into master and get back to you. 
 Ha, yeah. Jet lag took me out of commission for the past two days, too. 

Why don't I try to submit a PR to your branch that does the ReactiveProvider tests? Then we can do that separately, then merge this one into `swift-1.2`, then `swift-1.2` into `master` then :tada:
  Neat idea!

I think the base case for non-Reactive providers would be to return an opaque object; one that has no public members except a `cancel()` function. The object (or struct) would wrap the `Request` object from Alamofire to avoid a leaky abstraction. Then it would be up to the caller to do anything ‚Äì or not ‚Äì with the returned value. 

It wouldn't even be a breaking change, unless the call to `request()` was the online line in a closure that has a `Void` return value. 

For the Reactive extension, it's a bit trickier but not difficult. We currently have a side-effect that if the subscription to the signal is cancelled before the request finishes, we remove the request from the inflight cache. We would just need to add a call to `cancel()` [here](https://github.com/ashfurrow/Moya/blob/ad1e2266e8820433270eca3ba98aa01c787879a3/Moya%2BReactiveCocoa.swift#L74-L79). 
 Great questions! 
1. Hmm. Good question. I think `.Delayed` makes sense. 
2. This is a really interesting point. I really dislike having a tonne of different parameters in the completion block and making the user of the library try to figure out what they all mean, but my primary use of Moya is with ReactiveCocoa, so I only wrapped Alamofire (figured those people know what's best). In this case, I think we should stick as close to the behaviour as possible. If `NSURLSessionTask` completes with an error, then :+1:. It might not even be necessary to do that, since Moya uses their completion block to invoke its completion, so maybe cancelling the task is sufficient to have Alamofire call Moya, which calls its completion. Thoughts? 
3. Yeah, keeping it as-is is perfect. It's more like "is a request inflight" more than anything. 
 Oh, and let's go on the latest Xcode ‚Äì we can merge into the `swift-1.2` branch, which'll be merged into master shortly anyway. 
  :bow: A pull request with the extensions would be awesome! Let me know what I can do to help. 
 I've not looked too extensively into this, and would appreciate guidance or assistance.

Maybe we could add this new functionality to the _existing_ `ReactiveMoyaProvider` class? Or would we want a 3.0-only class? Since the two APIs are interchangeable, it might make sense to have only one class. 
 @rpowell that would be lovely! 
 @justinmakaila has implemented a solution on another repository (pasted below). We can't incorporate this change into the library yet because it's a breaking change to existing users, and we need to update Moya to the next major version (3.0.0). I'd like to get a Swift 2, Carthage-compatible release out _first_ (see #215) and then incorporate Justin's work, since it looks great :100: 

``` swift
/// Subclass of MoyaProvider that returns SignalProducer<MoyaResponse, NSError> instances when requests are made. Much better than using completion closures.
public class ReactiveCocoaMoyaProvider<T where T: MoyaTarget>: MoyaProvider<T> {
    /// Current requests that have not completed or errored yet.
    /// Note: Do not access this directly. It is public only for unit-testing purposes (sigh).
    public var inflightRequests = Dictionary<Endpoint<T>, Signal<MoyaResponse, NSError>>()

    /// Initializes a reactive provider.
    override public init(endpointClosure: MoyaEndpointsClosure = MoyaProvider.DefaultEndpointMapping, endpointResolver: MoyaEndpointResolution = MoyaProvider.DefaultEnpointResolution, stubBehavior: MoyaStubbedBehavior = MoyaProvider.NoStubbingBehavior, networkActivityClosure: Moya.NetworkActivityClosure? = nil) {
        super.init(endpointClosure: endpointClosure, endpointResolver: endpointResolver, stubBehavior: stubBehavior, networkActivityClosure: networkActivityClosure)
    }

    public func request(token: T) -> SignalProducer<MoyaResponse, NSError> {
        let endpoint = self.endpoint(token)

        if let existingSignal = inflightRequests[endpoint] {
            /// returns a new producer which forwards all events of the already existing request signal
            return SignalProducer { sink, disposable in
                /// connect all events of the existing signal to the observer of this signal producer
                existingSignal.observe(sink)
            }
        }
        else {
            /// returns a new producer which starts a new producer which invokes the requests. The created signal of the inner producer is saved for inflight request
            return SignalProducer { [weak self] sink, _ in
                let producer: SignalProducer<MoyaResponse, NSError> = SignalProducer { [weak self] sink, disposable in
                    let cancellableToken = self?.request(token) { data, statusCode, response, error in
                        if let error = error {
                            if let statusCode = statusCode {
                                sendError(sink, NSError(domain: error.domain, code: statusCode, userInfo: error.userInfo))
                            } else {
                                sendError(sink, error)
                            }
                        } else {
                            if let data = data {
                                sendNext(sink, MoyaResponse(statusCode: statusCode!, data: data, response: response))
                            }
                        }
                        sendCompleted(sink)
                    }

                    disposable.addDisposable {
                        if let weakSelf = self {
                            objc_sync_enter(weakSelf)
                            // Clear the inflight request
                            weakSelf.inflightRequests[endpoint] = nil
                            objc_sync_exit(weakSelf)
                            // Cancel the request
                            cancellableToken?.cancel()
                        }
                    }
                }

                /// starts the inner signal producer and store the created signal.
                producer |> startWithSignal { [weak self] signal, _ in
                    objc_sync_enter(self)
                    self?.inflightRequests[endpoint] = signal
                    objc_sync_exit(self)
                    /// connect all events of the signal to the observer of this signal producer
                    signal.observe(sink)
                }
            }
        }
    }

    public func request(token: T) -> RACSignal {
        return toRACSignal(self.request(token))
    }
}

/// Extension for mapping to a certain response type
public extension ReactiveCocoaMoyaProvider {
    public func requestJSON(token: T) -> SignalProducer<AnyObject, NSError> {
        return request(token) |> mapJSON()
    }

    public func requestJSONArray(token: T) -> SignalProducer<NSArray, NSError> {
        return requestJSON(token) |> mapJSONArray()
    }

    public func requestJSONDictionary(token: T) -> SignalProducer<NSDictionary, NSError> {
        return requestJSON(token) |> mapJSONDictionary()
    }

    public func requestImage(token: T) -> SignalProducer<UIImage, NSError> {
        return request(token) |> mapImage()
    }

    public func requestString(token: T) -> SignalProducer<String, NSError> {
        return request(token) |> mapString()
    }
}

/// MoyaResponse free functions

public func filterStatusCode(range: ClosedInterval<Int>) -> SignalProducer<MoyaResponse, NSError> -> SignalProducer<MoyaResponse, NSError>  {
    return { producer in
        return producer |> flatMap(.Latest, { response in
            if range.contains(response.statusCode) {
                return SignalProducer(value: response)
            } else {
                return SignalProducer(error: ReactiveMoyaError.StatusCode(response).toError())
            }
        })
    }
}

public func filterStatusCode(code: Int) -> SignalProducer<MoyaResponse, NSError> -> SignalProducer<MoyaResponse, NSError> {
    return filterStatusCode(code...code)
}

public func filterSuccessfulStatusCodes() -> SignalProducer<MoyaResponse, NSError> -> SignalProducer<MoyaResponse, NSError> {
    return filterStatusCode(200...299)
}

public func filterSuccessfulAndRedirectCodes() -> SignalProducer<MoyaResponse, NSError> -> SignalProducer<MoyaResponse, NSError> {
    return filterStatusCode(200...399)
}

/// Maps the `MoyaResponse` to a `UIImage`
public func mapImage() -> SignalProducer<MoyaResponse, NSError> -> SignalProducer<UIImage, NSError> {
    return { producer in
        return producer |> flatMap(.Latest, { response in
            if let image = UIImage(data: response.data) {
                return SignalProducer(value: image)
            } else {
                return SignalProducer(error: ReactiveMoyaError.ImageMapping(response).toError())
            }
        })
    }
}

/// Maps the `MoyaResponse` to JSON
public func mapJSON() -> SignalProducer<MoyaResponse, NSError> -> SignalProducer<AnyObject, NSError> {
    return { producer in
        return producer |> flatMap(.Latest, { response in
            var error: NSError?
            if let json: AnyObject = NSJSONSerialization.JSONObjectWithData(response.data, options: .AllowFragments, error: &error) {
                return SignalProducer(value: json)
            } else {
                return SignalProducer(error: ReactiveMoyaError.JSONMapping(response).toError())
            }
        })
    }
}

/// Maps a JSON object to an NSArray
public func mapJSONArray() -> SignalProducer<AnyObject, NSError> -> SignalProducer<NSArray, NSError> {
    return { producer in
        return producer |> flatMap(.Latest, { json in
            if let json = json as? NSArray {
                return SignalProducer(value: json)
            } else {
                return SignalProducer(error: ReactiveMoyaError.JSONMapping(json).toError())
            }
        })
    }
}

/// Maps a JSON object to an NSDictionary
public func mapJSONDictionary() -> SignalProducer<AnyObject, NSError> -> SignalProducer<NSDictionary, NSError> {
    return { producer in
        return producer |> flatMap(.Latest, { json in
            if let json = json as? NSDictionary {
                return SignalProducer(value: json)
            } else {
                return SignalProducer(error: ReactiveMoyaError.JSONMapping(json).toError())
            }
        })
    }
}

/// Maps the `MoyaResponse` to a String
public func mapString() -> SignalProducer<MoyaResponse, NSError> -> SignalProducer<String, NSError> {
    return { producer in
        return producer |> flatMap(.Latest, { response in
            if let string =  NSString(data: response.data, encoding: NSUTF8StringEncoding) as? String {
                return SignalProducer(value: string)
            } else {
                return SignalProducer(error: ReactiveMoyaError.StringMapping(response).toError())
            }
        })
    }
}
```
 Fixed in https://github.com/Moya/Moya/pull/224 ‚Äì merged into the 3.0.0-develop branch. 
  Cool, thanks! 

![](http://media.giphy.com/media/V2xbsCrxcLQSQ/giphy.gif)

Pretty sure this is failing on travis because of Swift 1.2. However, I would be more comfortable if we could add a command to the Makefile like `make test_carthage_build` or something to ensure that we can test Carthage's integration process and everything in the future. Does that sound OK? 
 Also a good idea. 

> On May 14, 2015, at 10:51 AM, Orta notifications@github.com wrote:
> 
> Could switch to CircleCI
> 
> ‚Äî
> Reply to this email directly or view it on GitHub.
 Travis build won't work with Swift 1.2 because they're still on Xcode 6.2 :cry: 

The more and more I think about it, the more I'm not really comfortable with Carthage files in the main repo. I'm totally cool with people using Moya and Carthage, but I'm not personally going to use it and I'm afraid of what happens when we go to implement new Moya features. Contributors would have to make sure that Moya works in CocoaPods _and_ Carthage, which is doubling deployment effort for this repo :confused: In the worst case, we say we have Carthage support but it doesn't work.

I'm open to suggestions ‚Äì if you comfortable with it, I'd love to let you handle Carthage and have the README contain instructions to use the Cartfile on your fork. Then you could pull in updates to your fork.

That's a lot to ask, though. 
 Hmm. Having the projects together would be nicer from a "fewer files in the repo" perspective, but it's really that I'm afraid that having Carthage supports is a promise to developers using Moya, and one that I'm not confident I can keep. 

But you're right ‚Äì this isn't a problem that only we have. I'm hoping that the community can solve this problem at a higher level so library authors aren't in this awkward spot. Maybe [this](https://github.com/neonichu/Rome) could help? 

For now, I would be much obliged if you were to maintain a fork with Carthage and submit a new PR updating the README to point Carthage users to use your repo :bow: :heart:
 From what people working on this repo and others have experienced, adding Carthage is not as minimal as you might expect. My issue is the problem of misleading developers by saying "we support Carthage", when I don't use it and won't know if Moya supports it correctly.
 Not at all! We're all after the same goal: making our own jobs easier. Take your time ‚Äì whenever you have a chance. 
  Sounds good to me ‚Äì CI is gonna break since Travis is sucky. Can you update the README status, too? 
 Thought they were still in invite-only beta?
 Cooool. 
 Thanks for the PR!
  üôá thanks! 
  Great idea! I think Alamofire supports this already, so there is an opportunity to leverage their code while being clever about how we expose the functionality. 
 OK, cool. We can start there then :)
 Help on this would be very much appreciated. I'm catching up on some work for the remainder of the week, and won't have time to look at it for a while. 
 This is a fundamentally new behaviour for Moya. I'm trying to figure out the best way to add it to our existing API without overly complicating things. 

If we want to use the existing `request()` function, then we would need to have a way to distinguish targets between upload and regular HTTP requests. We _could_ add `.Upload` to the `Moya.Method` enum, which would be easy, but would break parity with the HTTP verbs and the `Alamofire.Method` enum. 

On the other hand, if we add a new optional property to `MoyaTarget` for uploading (say, we call it `uploadData`), we could ignore the method of the target and assume it's uploading based on the presence of a non-`nil` `uploadData`. 

In either case, we would still need to figure out the progress callback. Maybe we could incorporate it into the cancellable token somehow maybe? 

Neither option really sits with me. We could, instead, have a new `upload` method on the `MoyaProvider` class. We would still need the optional `uploadData` property, the API would become _slightly_ more complicated, and it would be some duplicated code in `MoyaProvider` and its subclasses. 

Anyone have any feels about this?
 If only Swift had support for default parameters to Enums, we could have `.POST` and others with an optional parameter with a default to `nil`. 

But even if we don't have that support, we could just add more verbs that accept that to `Moya.Method`.
 Not yet, do you want to give it a shot and open a PR @clooth?
 Cool, that would be great! Feel free to ask questions in issues.

As for an implementation of this, I figure there's two part "entry points" where you could specify multipart upload: the `MoyaTarget` protocol or the `request` function. I think I'd prefer adding another function, or expanding the existing `request` function to handle it. Not sure of specifics, but you get the idea. 
 Let's make this happen!

How about creating a subprotocol, `MultipartFormUploadable` (I think we should get rid of this Moya namespacing too, but that's kinda just me) that inherits from `MoyaTarget` ‚Äì we overload `request` to take the more specific type, and to use it, and require an extra function to vend either an NSData, NSStream or a closure that returns those things to supply the body.

This might be the groundwork for a more strongly typed set of targets that more closely specify their methods of encoding and requesting, though that is perhaps an exercise best left to the reader.
 Played around with your ideas a bit, @swizzlr. A problem I'm running into is that if using something like:

``` swift
public protocol MultipartFormUploadable: MoyaTarget { }

public enum UploadDataProvider {
    case Data(NSData)
    case File(NSURL)
    case Stream(NSInputStream)
}

extension MoyaProvider where Target: MultipartFormUploadable {
    public func request(target: Target, provider: UploadDataProvider, completion: Moya.Completion) -> Cancellable
}
```

Then your _entire_ target type is then needing to conform to this protocol, or you need a second provider and target type for your multipart endpoints. While it doesn't seem like a necessarily common occurrence with a buffer of common sense, someone could technically call this version of `request()` with a `POST` target that is **not** multipart with a random (valid) data provider, since there's no way to distinguish between multipart and non-multipart enum target cases. Any better ideas for separation and compile-time verification of these types of endpoint targets?
 Yeah, this is why I think adding another `request` function specific to multipart uploading would be the best approach. 
 @ashfurrow Yeah, that is what I demonstrated above in the extension, but saw potential confusion with. Since the entire enum type must conform to `MultipartFormUploadable`, there's no way to determine whether a specific enum case should be able to be used for a multipart upload or not. This means it's not "perfectly strict" in that it can't warn or error if you try to misuse it in this way (misuse meaning call the overloaded version of `request()` in the extension with a data provider, on a target enum case that doesn't take multipart data). If you do so, you're stuck waiting potentially for the server to WTF at you for trying to upload data to a POST endpoint that doesn't take it, if that will even happen. In short, there's something that we know would at compile time, but can't enforce with the compiler in any way that I can think of, at least with targets as enum types.
 This makes total sense to me! 

> On Nov 18, 2015, at 4:49 AM, Guido Hendriks notifications@github.com wrote:
> 
> Maybe we should not focus on multipart/form-data, but on uploads in general. In Alamofire there are 4 types of uploads:
> 
> File
> Data
> Stream
> MultipartFormData
> I would say we add some kind of request type, which can be either Request or Upload (we could add Download too). Based on the request type it would execute the right Alamofire methods with the needed data from the target. That would also mean adding some kind of UploadType enum for all the supported upload types.
> 
> This way you maintain the abstraction. If you were adding a request specifically for uploads, you'd be picking the request type when executing a request, but that's something that the target should know.
> 
> Please do correct me if I'm wrong, but this seems like a step in the right direction to me.
> 
> ‚Äï
> Reply to this email directly or view it on GitHub.
 David, could you attach an example of the Ello.Target that would need to use Request and Upload types? I want to be sure I'm following you...

> On Nov 18, 2015, at 2:26 PM, David Warner notifications@github.com wrote:
> 
> I think, ideally, we'd like to be able to use the same endpoints for both Requests and Uploads, and therefore directly provide the DataProvider as a parameter to the request function. I ran with @JRHeaton's idea of a protocol extension to MoyaTarget, MultipartFormUploadable. I posted some of the implementation below and would love any feedback!
> 
> public protocol MultipartFormUploadable: MoyaTarget { }
> 
> extension MoyaProvider where Target: MultipartFormUploadable {
> 
> ```
> public func request(target: Target, parts: [MultipartBodyPart], completion:Moya.Completion) -> Cancellable {
>     precondition(target.method == .POST, "Uploads require Moya.method to be .POST")
> 
>     let endpoint = self.endpoint(target)
>     let stubBehavior = self.stubClosure(target)
>     var cancellableToken = CancellableWrapper()
> 
>     let performNetworking = { (request: NSURLRequest) in
>         if cancellableToken.isCancelled { return }
> 
>         switch stubBehavior {
>         case .Never:
>             cancellableToken.innerCancellable = self.sendUpload(target, request: request, parts: parts, completion: completion)
>         default:
>             cancellableToken.innerCancellable = self.stubRequest(target, request: request, completion: completion, endpoint: endpoint, stubBehavior: stubBehavior)
>         }
>     }
> 
>     requestClosure(endpoint, performNetworking)
> 
>     return cancellableToken
> }
> ```
> 
> }
> The sendUpload function would take an additional parameter representing a collection of each part of the multi-part upload, with those parts represented by the MultipartBodyPart struct. We could then have some helper function on the Manager that takes that collection and returns an Alamofire request.
> 
> public struct MultipartBodyPart {
> 
> ```
> public enum DataProvider {
>     case Data(NSData)
>     case File(NSURL)
>     case Stream(NSInputStream)
> }
> 
> public let name: String
> public let provider: DataProvider
> 
> // Additional stream parameters
> public let length: UInt64
> public let fileName: String
> public let mimeType: String
> ```
> 
> }
> 
> ```
> func sendUpload(target: Target, request: NSURLRequest, parts: [MultipartBodyPart], completion: Moya.Completion) -> CancellableToken {
>     guard let request = manager.uploadRequest(request, parts : parts) else {
>         var cancellableToken = CancellableWrapper()
>         cancellableToken.isCancelled = true
>         return cancellableToken.innerCancellable!
>     }
> 
>     return sendRequest(target, request: request, completion: completion)
> }
> ```
> 
> public extension Manager {
> 
> ```
> private func uploadRequest(request: NSURLRequest, parts: [MultipartBodyPart]) -> Request? {
> 
>     let formData = MultipartFormData()
> 
>     for part in parts {
>         switch part.provider {
>         case .Data(let data):
>             formData.appendBodyPart(data: data, name: part.name)
> 
>         case .File(let file):
>             formData.appendBodyPart(fileURL: file, name: part.name)
> 
>         case .Stream(let stream):
>             formData.appendBodyPart(stream: stream, length: part.length, name: part.name, fileName: part.fileName, mimeType: part.mimeType)
>         }
>     }
> 
>     do {
>         let data = try formData.encode()
>         return self.upload(request, data: data)
>     } catch {
>         return nil
>     }
> }
> ```
> 
> }
> ‚Äï
> Reply to this email directly or view it on GitHub.
 Yup that's about what I was imagining, and I wouldn't want those two endpoints either.

> On Nov 18, 2015, at 4:23 PM, David Warner notifications@github.com wrote:
> 
> @colinta pretty much any endpoints that could take optional data. I may not be completely understanding @GuidoHendriks solution, but I'd like to not have to write multiple enum cases for, say a "Create Account" request that may or may not take image data. Essentially, I want one "Create Account" endpoint to which I can optionally pass one or multiple NSData, NSURL, NSInputStream parameters.
> 
> Essentially, I'd like to avoid extraneous enum cases like this...
> 
> public enum API: MoyaTarget {
> 
> ```
> case CreateAccount(name: String, type: String, description: String)
> 
> case CreateAccountWithImageData(name: String, type: String, description: String, imageData : NSData)
> ```
> 
> }
> 
> extension API  {
> 
> ```
> public var requestType: RequestType {
>     switch self {
>     case .CreateAccount:
>         return .Request
> 
>     case .CreateAccountWithImageData:
>         return .Upload
>     }
> ```
> 
> }
> ‚Äï
> Reply to this email directly or view it on GitHub.
 Fixed in #483.
  Hmm. The only reason I can think of is that Moya hasn't been updated for Swift 1.2 yet, but Alamofire has. Suggestions? 
 Haha yeah. I should get on that ... I'll rename the issue. 
 Pretty busy for the next five or so days. Feel free to take a stab at it in the mean time ;)
 This is fixed as of https://github.com/ashfurrow/Moya/releases/tag/0.8.0 .
  This is a great idea! I think I'd prefer to have a closure as a parameter to the MoyaProvider initializer, or a variable property, that is called to begin/end. That way developers using something like [this](https://cocoapods.org/pods/BOTNetworkActivityIndicator) can provider their own implementations. Thoughts? 
 Hey @avgx! Is there anything I can do to help on this? 
 Cool, OK. The PR isn't _quite_ accurate, but I like the idea. Basically, you could have two network calls: A and B. A is slow, but B is fast. First we start A, then start B. B finishes quickly, but A is still running. However, since B finished, we set our `hasNetworkActivity` to `false`. 

I'm really interested in this ‚Äì I'll work on it today and let you know. 
 So I've got my idea up here: https://github.com/ashfurrow/Moya/pull/112 It still needs tests, but does that make sense? 
 Cool, I'm going to close this @avgx ‚Äì if I can help in any other way, or if the solution in #112 isn't sufficient for your needs, please let me know! 
  Hey, awesome! Thanks :) The CI is failing because Travis. Gonna merge!
  I'll create a new bump for ReactiveCocoa on CocoaPods trunk :)
 OK `3.0-alpha.3` is on Trunk. 
 I'll update the pod spec, then push. 
  Hey! These have been merged in. I updated the dependency on ReactiveCocoa on CocoaPods trunk. I don't have access to do so with Alamofire, our other dependency, so you need to have a Podfile that declares you're using their pre-release version _first_.

``` rb
pod 'Alamofire', :git => 'https://github.com/Alamofire/Alamofire.git', :branch => 'xcode-6.3'
pod 'Moya', :git => 'https://github.com/ashfurrow/Moya.git', :branch => 'swift-1.2'

# Or, if you're using ReactiveCocoa extensions...
pod 'Moya/Reactive', :git => 'https://github.com/ashfurrow/Moya.git', :branch => 'swift-1.2'
```

I just tried that on a test project and it seemed :+1: so feel free to re-open this issue if you're still experiencing problems and we'll work through it!
 @te-chris Glad to hear that! As always, don't hesitate to open an issue if you have a question, if something doesn't work the way you expect it to based on the documentation, etc. 
  Wonderful ‚Äì at it's tested :heart_eyes_cat: 
  The ReactiveCocoa version requires a specific version of LlamaKit; you'll need to use the same version in your Podfile. 
 Ah, apologies. The README looks out of date. Only include the pod names and not their :git components. 
 I'll update the README soon. 
  Interesting! I think this comes down to a couple things:
- Do redirected responses contain a response body?
- Does Alamofire handle redirects transparently?

I believe the answer to the first question depends on your server/API. I don't know the answer to the second question. @kylef ?

Do you think having something like `filterSuccessfulStatusAndRedirectCodes` would be worth it? 
 Sounds good! 
  Cool! @kylef has a cool repo. Maybe we could use it, or even borrow ideas from it: https://github.com/kylef/WebLinking.swift
 Could use the [representor pattern](https://github.com/the-hypermedia-project/charter#representor-pattern) too. Some closure that can return a(n optional?) new endpoint based on the previous response. This kind of thing would be really easy with the ReactiveCocoa extension: the signal for the initial request could emit another signal for a follow-up or something. 
 This should be fixed [with this issue](https://github.com/ashfurrow/Moya/issues/74), which makes parameters like the ones you've discussed part of the target protocol. 
  we don't need to submit to the app store, as it's an internal tool, I believe that beta 2 should have fixed the issues around deployment to app store.
  @colinta Hey! Sorry I haven't reviewed this yet. I just moved from Amsterdam to New York and some things have fallen between the cracks. I'll get to it ASAP ‚Äì thanks for contributing!
 Looks great! Tests would be :+1: Let me know if I can help getting them running on your machine. 
 Hmm. To be honest, I'm _totally_ cool with breaking changes, so don't worry about it. We're versioning the library so people can update if/when they want to. 

I don't know if `@autoclosure` is going to work going forward. Swift 1.2 changes the semantics surrounding this construct such that these types of closures cant be stored for later ‚Äì they must be executed immediately (as far as I understand it). I think moving to a pure closure would be OK. 
 Oh, and `bundle exec pod install` or just `pod install` should fix the error with testing. 
 What folder are you running it from? 
 Try it in the `Demo` directory, where the Podfile is. 
 I think the first option, adding a new case to the enum, would be awesome. Avoiding `@autoclosure` seems to be a good idea for now. Let me know if I can help!
 @alloy? Only on Slack :) I've left Amsterdam, sadly. 
 Looks awesome! 
  Cool ‚Äì please feel free to open up another issue if you have any questions or want clarification on anything. 
  That's strange, it shouldn't complain at all. If you look in the unit tests, you'll find code like the following that works fine: 

``` swift
let target: GitHub = .Zen
provider.request(target, completion: { (data, statusCode, response, error) in
    if let data = data {
        // ...
    }
})
```

It's very strange that you're seeing this error, and I'd really appreciate your help in tracking down what's going on. The first thing I'd like you to do is make sure that you're on the latest version of Moya (since we've added a few parameters to the completion handler ‚Äì something also not added to the readme yet oops). Next, if you're still seeing the error, could I ask you to upload a sample project somewhere? One that demonstrates the error ‚Äì that way we can troubleshoot what's going on and get a fix for everyone. 

Thanks again for bringing this to my attention, and I'm sorry I couldn't answer earlier ‚Äì I was at a conference all weekend. 

Thanks! :beers:
 Sorry this took so long ‚Äì thanks again for your help! :bamboo: 
  Cool, looks great! I'll add a test to verify the app no longer crashes later, unless you send another PR before then :)

:beers: 
  I can see the value in making sure that the network code is run asynchronously, but tying your network callbacks to the assumption that they'll have a short, undetermined delay is probably not the best practice to be encouraging. 

So maybe not a delay, but some kind of mechanism to defer to the next invocation of the runloop? 
 Very good point ‚Äì I hadn't considered stubs much outside a testing context. This is a great idea. I'll look into it more. 
 Yeah, we stub responses based on a heuristic to check if you have access to the API or not. I can also see it being valuable in rapid application prototyping, where the API isn't ready or stable yet. Thinking of adding a(n optional?) property to the enum protocol that allows developers to specify a delay. Thoughts? 
 IMO cool, as long as 0 doesn't jump out of being synchronous 
 We can use an enum with associated values. Something like:

``` swft
enum StubBehavior {
    case .Immediate
    case .Delay(seconds: Int)
}
```
 :+1: 
  :+1: 
 Thanks @jspahrsummers !
 Not sure. Any suggestion, @jspahrsummers? 
  Awesome! Thanks so much, @steam!

The CI failure is not your fault ‚Äì I'll get it fixed up ASAP. Could you write a quick test or two on your end for the new NSData associated value? 
 Nah, not fixed yet, but this looks awesome! :beers:
  Hi there! Got your email too. I'll take a look as soon as I can. Happy holidays!
 Would strongly recommend taking a look at the [Eidolon](https://github.com/artsy/eidolon) source code to see if it has something that you're looking for.
 Hmm. Eidolon uses the default parameter encoding, so it won't be much help. I'm trying out your sample code now and I'll let you know what I find. 
 OK, I think I've got things working. First, the `URLRequestConvertible` actually belongs to Alamofire, so you need to have `import Alamofire` at the top of your file. This is a leaky abstraction on my part ‚Äì I'll open an issue.

OK, so now for some Swift stuff. The syntax surrounding closures as variables is ... not intuitive :smile: I played around with things until I got the following to work: 

``` swift
let xmlParameterEncoding: (URLRequestConvertible, [String: AnyObject]?) -> (NSURLRequest, NSError?) = { convertible, parameters -> (NSURLRequest, NSError?) in
    //this is just to get things working
    return (convertible.URLRequest, nil)
}

let closure = { (target: EyeQEndPoints, method: Moya.Method, parameters: [String: AnyObject]) -> Endpoint< EyeQEndPoints> in
    return Endpoint< EyeQEndPoints>(URL: url(target), sampleResponse: .Success(200, target.sampleData), method: method, parameters: parameters, parameterEncoding: Moya.ParameterEncoding.Custom(xmlParameterEncoding))
}

let abcd = MoyaProvider(endpointsClosure: closure )
```

A few important notes: the `xmlParameterEncoding` closure has the variables _names_, not types, after the `{`, and I had to fully qualify  the `.Custom` with `Moya.ParameterEncoding`, since Alamofire exposes an identical enum with the same name. 

But that should do it! Let me know if I can clarify anything. 
 Awesome! I'll close this. Feel free to reopen or open a new issue if you have other questions. 
  Hi there! Thanks for opening this. Can you clarify where this link is? I can't seem to find it. 
 Ah, gotcha. I will fix that. 

The two readme's serve different purposes ‚Äì the other one is only named a readme because GitHub will render it as markdown when looking at the "docs" folder. 
  This is likely an issue that CocoaPods is having with signing frameworks (the PR is [here](https://github.com/CocoaPods/CocoaPods/pull/2835)). CocoaPods with Swift support is still prerelease, remember. 

You've got essentially two options: try and update CocoaPods to see if the latest version will support deploying (I honestly don't know), or change to use Moya as a submodule for now (this is what I had to do about a week ago ‚Äì and it broke my heart a little). 

If you have questions regarding either option, let me know here and I'll do my best to answer them. 
 Could be related to https://github.com/CocoaPods/CocoaPods/pull/2873

We had to delay a deploy because of this, but that was before this PR, unsure how stable that is
 We created a branch from the commit just before we switched to CocoaPods and cherry-picked the commits we needed from after we switched. You can check out the branch here: https://github.com/artsy/eidolon/tree/si-deploy
 Should be done now. Please reopen if not. 
  I'll take a look tomorrow. 
 Or whenever. Soon, though. 
 Hard to get a feel of this from the PR ‚Äì can you high-level it for me? Does it still run all of the tests? 
 Why not have carthage run `pod install`?
 Hmmm. I obviously fall on one side of this, but I think it's important to look at this like a library author. If the author uses CocoaPods, then they'll probably support CocoaPods with their libraries. Likewise with Carthage or even (_shudders_) submodules. 

Me, I use CocoaPods for my apps, so when I need to use Moya, I need it available as a pod. 

@swizzlr Can you high-level this for me? What's the problem? CocoaPods just lists the files and the dependencies ‚Äì it doesn't require a project file. So if Carthage does, fine, let's include one or whatever it needs, but I want to run my demo app and unit testing project using CocoaPods. I thought the point of Carthage was that I could define my dependencies in a text file or something? If I have to still include submodules, then what's the point? 
 We found a solution from the CP side that allows us to generate a single xcodeproj that makes a framework, it would be a command that generates all the necessary files for people that prefer build artefacts. 

See https://github.com/CocoaPods/CocoaPods/issues/2885
 @swizzlr Hey t-swizzle ‚Äì any update on this? Dunno what to do with it. 
 Cooooool :palm_tree: 
  [This](https://github.com/neonichu/Rome) might help. 
 Cool! 

So Moya doesn't have Swift 1.2 support yet because I'm still stuck on Swift 1.1. A PR onto the `swift-1.2` branch would be :+1: 

As for Carthage, I'm amenable to Carthage support for Moya ‚Äì it's just been that no one has asked for it yet. Someone tried once but apparently it was really hard? I dunno. If you want to send a separate PR for that (onto `master`), that would also be welcome!

![](http://media.giphy.com/media/V2xbsCrxcLQSQ/giphy.gif)
 Hey @te-chris! A new issue would be very much appreciated. Thanks! 
 Awesome! I'm wary about having two different demo projects. Would it be possible to have two projects that point to the same .swift files? 
 Maybe even the different targets in the same project? 
 @neonichu / @kylefuller / @segiddins do we have something that can generate Cartfile.resolved from a Podfile.lock. I wouldn't expect the carthage team to build something similar, but is it something we can try? Looks simple enough.

I don't think having two complete projects is a smart idea, two repos is even worse. As reasonable project owners we will probably have to re-write our project to support Carthage. 
 Closing this in favour of the solution discussed [here](https://github.com/ashfurrow/Moya/pull/117). 
  Awesome ‚Äì figured that was the issue (I'm on vacation atm, otherwise I would've replied earlier). I'll change and let you know. 
 Thanks @ryancrosby !
 You should be good now. 
  Thanks! :beers: 
  Definitely the oops ‚Äì thanks! 
  I get a warning like:

```
NSForwarding: warning: object 0x7f8943920a10 of class 'Kiosk.MoyaResponse' does not implement methodSignatureForSelector: -- trouble ahead
Unrecognized selector
```
 `MoyaResponse` just needs to subclass NSObject so that RAC's `rac_description` category method is available on it. 
 To be honest, I've been really busy. I'd gladly merge a pull request, though. 
  This has been a painful process.

Basically I've burnt everything to the ground and started over. I also need to manage our dependencies manually because Xcode is too stupid to realize it can't build "ReactiveCocoa-OSX" on an iOS app. 

Intermittently failing for some other linker reason. Can't wait for CocoaPods. <edit>Now uses CocoaPods</edit>

Fixes #76.
 :green_apple: 
 This looks good to me. :+1: 
  From our use in [Eidolon](https://github.com/artsy/eidolon/), we almost always call `request` with the [`defaultParameters`](https://github.com/artsy/eidolon/blob/29cfd75f3a63ed2d320a87659953f7cd5071ecb4/Kiosk/App/Networking/ArtsyAPI.swift#L40-L114) we've defined on our target, since the target contains all the details necessary for the action, anyway. So why not codify that requirement? 

Thoughts anyone? 
 I had debated building a `provider.request(Identifier).get()` that does default parameters, successful status code and toJSON. Which is basically the same each time.
 So have `request` return something that has a `get` function on it, and delay the execution of the request until it's invoked? 
 I meant more like a shortcut for the request + `.filterSuccessfulStatusCodes().mapJSON()`
 So the default parameters will be merged with the ones provided by the caller, I think. That way API calls needing parameters only have to manage them once instead of every API call. This calculation should be as part of the target `enum`, just like the path. 

I think Orta's suggestion would make sense if we weren't making [HTTP methods part of the API](https://github.com/ashfurrow/Moya/issues/60).
  Very cool ‚Äì let me know if I can be of any assistance. My next big push on Moya is https://github.com/AshFurrow/Moya/issues/68 , so your experience with this might be helpful. 
 ( our API supports swagger, we definitely would like this ;) )
 I don't even know what swagger is ‚Äì so I'll check it out. 
 might not be that useful, perhaps this should be built into Paw as a plugin. 
http://luckymarmot.com/paw
 Any news on this?

This would be super awesome! I have thought about doing it myself, but never took a look at it.

The problem I see, is with JSON (de)serialization, because Swift does not have a good reflection system (as of 1.2 at least) to support a reflection library, so all must be done manually. If the generator takes care of that too, would be great. :)
 https://github.com/lkuczborski/SwiftMoyaCodeGenerator from @lkuczborski does some of this
 and for people who care about Swagger: https://github.com/luckymarmot/Paw-SwaggerImporter
 Delegating that responsibility to  @ashfurrow :u5408: 
 @lkuczborski I can take a look, want to point me to a PR or something? 
 Will try to take a look tomorrow and let you know :+1: 
 @lkuczborski Hey there! Apologies for the delay ‚Äì I've taken a look and it all seems :100: to me. Note: I am not an Paw extension expert :grimacing: But from a Moya perspective it all looks :+1: 
 Is there any more discussion/movement here or should we close this? Since there hasn't been any activity on this thread for some time, I am going to go ahead and close it. Please re-open or create a new issue if you would like to discuss further. Thanks.  Thanks! :beers:
  :+1:
  This was fixed here: https://github.com/ashfurrow/Moya/commit/abaf6cb0adaf
  Thanks! :beers:
  It is strictly for callers or subclasses, to avoid having an optional parameter. You can see it used [here](https://github.com/AshFurrow/Moya/blob/master/Moya%2BReactiveCocoa.swift#L97) in a subclass. 

It's not documented anywhere, though it should be, but the "Moya" way to do this is to define a `defaultParameters` property on the enum ([here](https://github.com/artsy/eidolon/blob/24d8ee07edb4daaa0b7e840a9ca751edebc1d99e/Kiosk/App/Networking/ArtsyAPI.swift#L37-L113) is an example), and then you have a few options. At Artsy, we explicitly pass in our own properties _or_ the default ones any time we make a request (see [this example](https://github.com/artsy/eidolon/blob/24d8ee07edb4daaa0b7e840a9ca751edebc1d99e/Kiosk/Bid%20Fulfillment/BidCheckingNetworkModel.swift#L98-L99)). Alternatively, in the `endpointsClosure` used when creating the `MoyaProvider`, your mapping can pass in the parameters:

``` swift
let endpointsClosure = { (target: ArtsyAPI, method: Moya.Method, parameters: [String: AnyObject]) -> Endpoint<ArtsyAPI> in
    let endpoint: Endpoint<ArtsyAPI> = Endpoint<ArtsyAPI>(URL: url(target), sampleResponse: .Success(200, target.sampleData), method: method, parameters: parameters)

    return endpoint.endpointByAddingParameters(target.defaultParameters)
    }
}

let provider = MoyaProvider(endpointsClosure: endpointsClosure)
```

You could even have an `endpointsClosure` that always used the default parameters unless the caller had included ones that overrode them, which is probably the best idea now that I think of it. Something to consider for the future. 

Does that answer your question?
 Agreed, I've opened https://github.com/AshFurrow/Moya/issues/68
 Just an update, I've written some documentation here: https://github.com/AshFurrow/Moya/pull/75

Also I've been thinking about making `defaultParameters` part of the target requirements. Would love input: https://github.com/AshFurrow/Moya/issues/74
  Hmm. Is it possible that the version of Alamofire is newer than the submodule in this repo? 
 OK, cool, well then it's on me to update our version. I'm pretty busy for the next day or so, so if you submitted a pull request, that would be welcome. Otherwise, I'll update it tomorrow. 
 That would be awesome! If you do, make a note of it in the changelog, too!
  right now a test suite doing some networking looks like:

``` swift
    beforeSuite { () -> () in
        // Force provider to stub responses
        APIKeys.sharedKeys = APIKeys(key: "", secret: "")
        Provider.sharedProvider = Provider.StubbingProvider()
    }

    afterSuite { () -> () in
        // Reset provider
        APIKeys.sharedKeys = APIKeys()
        Provider.sharedProvider = Provider.DefaultProvider()
    }

    it("returns some data") {
        setDefaultsKeys(nil, nil)

        var called = false
        XAppRequest(.Auctions).subscribeNext({ (object) -> Void in
            called = true
        })

        expect(called).to(beTruthy())
    }

    ... etc
```

This is fine, and it goes and access pre-rendered stubs etc. I'd like some choice, and to allow making something like this (excusing broken syntax):

``` swift
  let networkProvider = Provider.runtimeProvider()
  beforeSuite { () -> () in
      Provider.sharedProvider = networkProvider
  }

  afterSuite { () -> () in
      Provider.sharedProvider = Provider.DefaultProvider()
  }

  it("returns some data") {

      var called = false

      networkProvider.responseString(.Auctions) {
        return "{ 'foo':'bar' }"
      }

      XAppRequest(.Auctions).subscribeNext({ (object) -> Void in
          called = true
      })

      expect(called).to(beTruthy())
  }


```

with maybe the potential of returning strings, json objects and data?
 Ah, interesting. So to decouple the creation of the target from the stubbed responses. It kind of violates a bit of the functional-ness of everything, and the purpose really is so the SUTs have access to stubbed responses without being any the wiser. 

I can see a potentially better option with something like the following maybe? 

``` swift
// Inside an it closure
Provider.sharedProvider = networkProvider.responseString(.Auctions) { "{'foo': 'bar'}" }
```

The `responseString` method could return a wrapped `MoyaProvider` so that the original instance remains unmodified. You could even chain subsequent calls to `responseString` to re-stub multiple methods. Would that solve the issue, and further more, would this be a supplement to or a replacement of the existing stubbing methods? 
 yeah
 Well, for the 1.0 release, we moved `sampleData` to be a closure that returns data, so it could return different things on different invocations. I know it's not enough, but it might help, and might help figure out better ideas. 
 I'm thinking we'll have a new initializer that does two things: 
- accepts an argument of some kind of representation of new stubbing behaviour to be defined.
- sets a private/internal property ‚Äì something like a "parent provider" that, when performing requests, would call through to the parent if the request didn't meet the newly added stubbing behaviour. 

In this way, you could chain things together, and every request would start at the bottom and work its way up:

``` swift
let newProvider = provider.addStubbing(someRequest)
    .addStubbing(someOtherRequest)
    .addStubbing(someFinalRequest)
```

Or something like that. Does anyone have idea thoughts on this approach?
 I was thinking more like you would need to specify both a target _and_ an `EndpointSampleResponse` to accompany it. 

``` swift
let request = Api.Status
let response = EndpointSampleResponse.Success(200, { /* Some sample data here */ })
let newProvider = provider.addStubbedResponse(response, forRequest: request)
```

Or something to that effect. 
 I'm thinking that the stubbed responses would be used for any request matching that `Api` enum. This makes sense to me as a simple use case, which is what this would provide. 

It's already possible to create this behaviour using custom endpoint resolvers that are passed into the `MoyaProvider` initializer. What this feature would do, in my mind, would let you have a sort of shorthand for this where only one or two requests need to be stubbed differently, for a specific test case. 

Does that make sense? So something like you have would work-ish, but the behaviour would be more consistent with the default Moya stubbing behaviour. 
 Maybe this complicated test case would fit better as a separate test component. Even more integrated with Nimble as a matcher or something like that.

That way, we could have an implementation of this matcher as something that expects to be called in that particular order and when called respond with that particular stub response.

This is would work very much like RSpec, if anyone is acquainted to Ruby code:

``` ruby
it "should call 'bar' with appropriate arguments" do
  expect(subject).to receive(:bar).with("an argument I want")
  subject.foo
end
```
 Neat, I hadn't even considered marchers for Moya. I was only thinking of functional or view snapshot tests. The idea of testing that a request was made... hmm. Sounds useful, but is it something to encourage? 

Like, it's possible now for sure, but a bit of work. I can't think of many scenarios where testing that a request was made would be more ideal than testing the actions based on the network response. Does that make sense? Curious about the use case. 
 Yeah, I don't really have a use case for that. I just remembered of that when I saw @colinta's comment.

But something that generally annoys me when writing tests with stubbed requests is that we usually only test the response component of it. Not what we send to the request. With this mechanism we could have both.
 What do you guys think about revisiting this and how it might fit in with #881 ? Since there hasn't been any activity on this thread for some time, I am going to go ahead and close it. Please re-open or create a new issue if you would like to discuss further. Thanks.  Will do. 
  @powerje Awesome, looks great! I see you updated the sample app, too. My bad for letting it get out of date ‚Äì thanks! 

Could you add a line to the changelog specifying what was done and your GitHub username for credit? 

So maybe modify `failureEndpointsClosure` to return a 401 error code (or whatever), then add something like this to the MoyaProviderSpec:

``` swift
describe("a failing reactive provider") {
    var provider: ReactiveMoyaProvider<GitHub>!
    beforeEach {
        provider = ReactiveMoyaProvider(endpointsClosure: failureEndpointsClosure, stubResponses: true)
    }

    it("returns the HTTP status code as the error code") {
        var code: Int?

        provider.request(.Zen).subscribeError({ (error) -> Void in
            code = error.code
        })

        expect(code).toNot(beNil())
        expect(code).to(equal(401))
    }
}
```

Thanks again!
 @plasmaphonic hey there ‚Äì I've opened https://github.com/AshFurrow/Moya/issues/51 in order to help answer your question. 
 Bedankt!
 :+1: 
  Oops - thanks! 
  :+1:
  dank u!
  Ha, oops. Sorry about that! That image is sadly being removed anyway in #21, but it's good to merge. 
  Fixes #2.
 Yeah, I really like this. Merging. 
  So this is a tough one that I need to figure out an abstraction for. The basic gist is as follows: You set up a `MoyaProvider` with a bunch of endpoints. Cool, right? Except as of this moment, you access the API like this:

``` swift
let provider = MoyaProvider(endpoints: [
                    Endpoint(URL: "http://rdjpg.com/300/200/", sampleResponse: {
                        /* doesn't matter */
                    })
                ])

...

provider.request("http://rdjpg.com/300/200/", completion: { (object: AnyObject?) -> () in
    ...
})
```

Not cool ‚Äì let's avoid stringly-typedness in this library. 

Is there a way to provide a compile-time check that the endpoint actually exists? Can we set up some sort of enum or token or something that you pass in when you create the endpoint, and then reuse that token later on when calling the API? It needs to be something accessible by both whoever sets up the API at app launch, likely the app delegate, and anyone else who wants to access it (view controllers, network layers, whoever). 

It's tricky since I want a clear separation of this library and the app code. Since each app has a different API, this abstraction ‚Äì whatever it ends up being ‚Äì needs to be something defined in _app code_, but is used by the library. 

So I need a thing that someone using this library creates, uses to register the endpoint, then uses somewhere else in order to access the API. Any thoughts? 
 I have endpoints generated by the user of the library, another developer. The user of an app can't define any. 
 I really, realy dig these. We could even go further and abstract away the need for a URL string, which would decouple its 1-1 relationship with an endpoint. That way, you could provide a different URL depending on parameters, etc. I'll put together a pull request. 
 Cool. Take a look at #6 and let me know what you think. 
