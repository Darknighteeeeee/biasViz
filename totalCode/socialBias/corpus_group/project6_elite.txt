  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla. **If you are contributing on behalf of someone else (eg your employer)**, the individual CLA may not be sufficient and your employer may need the corporate CLA signed.

If you have received this in error or have any questions, please contact us at cla@fb.com. Thanks!  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla. **If you are contributing on behalf of someone else (eg your employer)**, the individual CLA may not be sufficient and your employer may need the corporate CLA signed.

If you have received this in error or have any questions, please contact us at cla@fb.com. Thanks! Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla. **If you are contributing on behalf of someone else (eg your employer)**, the individual CLA may not be sufficient and your employer may need the corporate CLA signed.

If you have received this in error or have any questions, please contact us at cla@fb.com. Thanks! Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks! Could you explain more the issue this is solving? isPlainObject should be returning false for deep prototype chains, correct?

Also, could you include performance measurements for this change? This function is called quite a lot and is a potential performance bottleneck for the library Thanks, @jinalkathiara.

I updated your perf test here: https://jsperf.com/check-performance-for-prototype-checking/5 - unfortunately yours included console.log which is very slow and warped the test results.

As you can see, this change makes this function 100x slower, which is not going to be acceptable since it's one of the most often called functions within the library.

Could you talk more about the use case you're trying to enable? Perhaps there's a way to accomplish it without the library-wide performance penalty  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla. **If you are contributing on behalf of someone else (eg your employer)**, the individual CLA may not be sufficient and your employer may need the corporate CLA signed.

If you have received this in error or have any questions, please contact us at cla@fb.com. Thanks!  Yikes. That's not good. I'm not sure what the issue is, but very open to suggestions or PRs to fix this. 

Does anyone know what changed in this point release?  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla. **If you are contributing on behalf of someone else (eg your employer)**, the individual CLA may not be sufficient and your employer may need the corporate CLA signed.

If you have received this in error or have any questions, please contact us at cla@fb.com. Thanks! Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!  Thank you, @liubinyi for improving the docs! LGTM =)   Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!

**If you are contributing on behalf of someone else (eg your employer)**: the individual CLA is not sufficient - use https://developers.facebook.com/opensource/cla?type=company instead. Contact cla@fb.com if you have any questions. Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks! Looks legit to me. Thank you @icopp for fixing!  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!

**If you are contributing on behalf of someone else (eg your employer)**: the individual CLA is not sufficient - use https://developers.facebook.com/opensource/cla?type=company instead. Contact cla@fb.com if you have any questions. Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!  Thank you @wdhorton for fixing it! =)   Looks legit to me! Thank you @anilreddykatta for fixing it! @leebyron, is it ok if I merge it? =)  I see, it happens if `bundle.js` not yet loaded and one of the links are clicked.
However, I am pretty sure at the time it happened to me, my Internet connection was good. Perhaps something happened on server s.t. `bundle.js` was not returned to me.

Yes, as @jayjaycross mentioned, this problem may apparent on those having bad Internet connection (9-10 seconds to download `bundle.js`). Since the page is apparently server rendered, visitors may clicks any of the links (and encounter error) within those periods.  Thank you for reporting @xaviergonz! Closing it since it is a duplicate of #1183   Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!

**If you are contributing on behalf of someone else (eg your employer)**: the individual CLA is not sufficient - use https://developers.facebook.com/opensource/cla?type=company instead. Contact cla@fb.com if you have any questions. Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!  Thank you for improving tests @jokester =) Looks legit to me!  @leebyron, are you agree with this approach? =)  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!

**If you are contributing on behalf of someone else (eg your employer)**: the individual CLA is not sufficient - use https://developers.facebook.com/opensource/cla?type=company instead. Contact cla@fb.com if you have any questions.  Sounds legit! Please go ahead and submit pull request. I will review it =)   Looks legit to me! Thank you @philipp-spiess for fixing it! Going to merge it right now. Sorry for delay!   Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!

**If you are contributing on behalf of someone else (eg your employer)**: the individual CLA is not sufficient - use https://developers.facebook.com/opensource/cla?type=company instead. Contact cla@fb.com if you have any questions. Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks! Thanks!  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!

**If you are contributing on behalf of someone else (eg your employer)**: the individual CLA is not sufficient - use https://developers.facebook.com/opensource/cla?type=company instead. Contact cla@fb.com if you have any questions. Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks! Thank you @garrettm for adding test! It can be merged when the fix will be ready  =)  The same issue affects TypeScript. I'm not sure how to improve this but would love some help.  Thanks for the report!  Thanks for the report!  This adds strictNullChecks to the ts tests, and improves type definitions such that all tests pass. Specifically this adds two significant changes to typescript defs:

* `size` is now correctly typed to not belong on Collection, exist in a nullable way on `Seq`, and exist in a non-nullable way on all concrete collection types (List, Map, etc)
* `zip` and `zipWith` is overridden in all subtypes such that the return type is more correct.

Fixes #1158  What version of immutable.js? Could you show me what code you're writing to get this issue? I can't reproduce. What I'm running:

```
mkdir test-project
cd test-project
npm init -y
npm install -SE immutable@rc
node
> isImmutable = require('immutable').isImmutable // namespace export
[Function: isImmutable]
> isImmutable = require('immutable').default.isImmutable // default export
[Function: isImmutable]
``` Note that exporting these functions from the top level is new as of v4.0, so they'll only exist in the RC. Perhaps double check which version you're using?  What version of immutable are you using? The docs have been updated for the 4.0RC Merging into #1167   Very nice! Thanks :)  LGTM =) Thank you a lot!  Immutable.js doesn't support subclassing of Maps, Lists, and other collection types. The type constructors are functions (they don't need be called with `new`). The TS declarations are correct, the flow definitions are incorrect in this particular way but using the class definition made other desirable behaviors work with the flow checker.

Records can be sub-classed as a means of adding additional methods to the prototype, however subclasses cannot add new fields to the Record store and cannot perform work in a constructor (since every "mutation" results in the construction of a new Record). I typically recommend against subclassing Records and instead favor general purpose functions which accept the records as arguments - this approach is easier to type check, easier to scale in a codebase, and is more performant at runtime. Part of the confusion is the source text which was written before ES6/ES2015 was finished. It is using a non-compliant class transform which converts back to a prototypal function constructor  This is an intentional breaking change to bring `getIn` and `setIn` into alignment. Bug's resulting from the silent return of `null` for this case were a common complaint from the previous major version.

The reason this fails is because there is a value at `"a"` however that value is not a container and doesn't allow deeper retrieval. This is usually indicative of a mistake, expecting the value at `"a"` to be a collection if it exists.

Note if you change the test code to:

```js
const ABRecord = Immutable.Record({ a: null })
const myRecord = new ABRecord()
console.log(myRecord.getIn(['a', 'b']));
```

That you'll see `null` logged. Ah interesting! I'll definitely make sure there's more tests and clear language around this  Reopening as a reminder to myself to dig in  Thanks for the report. Does this only occur when used with the `uuid` library, or will this also work for a simpler test case? Also could you please let me know what version of the library you're using  Oh thanks! could you please run `npm test` and amend to the PR? That will generate the right distribution files which will make Travis pass LGTM =) Thank you!  Thanks for the report. Just to confirm: RC1 worked as expected with strictNullChecks enabled, and RC2 works only when strictNullChecks is disabled? Thanks for working on a PR!

It depends what that change applies to - for collections like List, Map, etc, size will never be undefined, however Seq (and therefore also Collection as a superclass) may have an undefined size. I think the fix will require removing `size` from `Collection` and then manually adding it to every concrete data type: List, Map, Set, OrderedMap, OrderedSet, Stack as `readonly size: number` Ok thanks for the update on your progress. I'm sure this is fixable.   This adds back the delete() and clear() methods to Record instances that set values back to the default values, in the process improving the equals() and hashCode() implementations.  This expands the type def of filter() to return a type-limited version of the original type.

Fixes #1152  Unfortunately in the previous version the any was *implicit*, so no type checking was occurring at all for Records. In v4 extending Records in a class requires an explicit cast.

I spent some time trying to get Records as soundly typed as possible, but would appreciate help from anyone who can find a way to support this case  Wouldn't this PR also result in problems? I would expect an error like: "Collection<string, C> is not assignable to type List<C>" - Returning a different type would probably mean replicating this change across all types much like `map<M>`

Looking into TypeScript's own lib, it seems like https://github.com/Microsoft/TypeScript/blob/master/lib/lib.d.ts#L1097 might be leveragable. #1146 Also mentions a desire for a sounder filter function - I was wrong to suggest TypeScript couldn't do that, but it seems Flow cannot yet. I just put up #1155 which includes a type-checked test that seems to be working just fine without requiring much specific annotation, the test before the changes to the type definitions failed with the same "Type 'List<A>' is not assignable to type 'List<C>'." error you were seeing before I think the trick was to put the version using guards before the version that does not, since TypeScript attempts to apply each override in the order they were defined.  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!

**If you are contributing on behalf of someone else (eg your employer)**: the individual CLA is not sufficient - use https://developers.facebook.com/opensource/cla?type=company instead. Contact cla@fb.com if you have any questions. Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks! Great suggestion. In fact I think we can get even more specific than this, similar to how the `map()` method gets specific definitions for each type.  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!

**If you are contributing on behalf of someone else (eg your employer)**: the individual CLA is not sufficient - use https://developers.facebook.com/opensource/cla?type=company instead. Contact cla@fb.com if you have any questions. Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks! Thanks!  These references are actually now referencing the JavaScript [Iterable](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols) interface! - Because I see errors also mentioning `Iterator` and `Symbol`, I'm guessing that you don't have `--target es6` in use with your typescript project, adding that should resolve these errors.

I'll look into how I might be able to support typescript without this option enabled After digging into this a bit and discussing on Twitter (https://twitter.com/leeb/status/840705430498103297) it seems like there's no way around this without requiring those using Immutable.js & TypeScript together to include either `--target es2015` or `--lib es2015` in their projects. This is the same solution the Angular community recommends. Added to the Readme and website You can also specifically turn on es2015.symbols.wellknown I think for a limited expansion of types  I'd love to support this in a general way, but as far as I know Flow and Typescript don't support lifting a predicate function onto a collection like this. As soon as they add support, then your function as written would pick up that knowledge.

Until then I recommend a type cast or utility function as you're using today.  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!

**If you are contributing on behalf of someone else (eg your employer)**: the individual CLA is not sufficient - use https://developers.facebook.com/opensource/cla?type=company instead. Contact cla@fb.com if you have any questions. Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks! :facepalm:  I think this might be too invasive. I find that git hooks can be more burdensome than helpful and what we really want is "pre merge" hooks where travis fills in. I'm going to close this PR - feel free to open it again if you would like to continue discussion on it  Definitely interesting - I like the idea of using predefined tuples for `setIn` type safety.

The master branch contains some pretty dramatic improvements to Record vs what's currently on npm (to be released very soon), so start from those if you're working on concrete improvements, otherwise please feel free to test and submit pull requests when you have this working!  Thanks for this - I've been meaning to add this forever.  Slick!  As suggested in https://github.com/facebook/immutable-js/pull/1035#discussion_r105333309  Ah yes thanks this documentation note is long overdue to be removed. 

There are actually plenty of object types that have toString() methods that make for reasonable strings as well, so I agree that it shouldn't throw.  So good! Thanks for the rapid fire release  Thanks for fixing :)  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!

**If you are contributing on behalf of someone else (eg your employer)**: the individual CLA is not sufficient - use https://developers.facebook.com/opensource/cla?type=company instead. Contact cla@fb.com if you have any questions. Thanks for digging into this. 

Our documentation lives in type-definitions/immutable.d.ts and is the source from which all other documentation is generated. I'd prefer not to create duplicate efforts for full documentation  I'm going to close this PR - but feel free to re-open or opening a new PR if you are interested in moving some of this additional documentation to the documentation source of truth. See #1144 for an example of editing those files.  Unfortunately there is a lot of code out there, including built into the JavaScript core and in browsers that assumes if value.length is a number that it's safe to use value[1] style indexing, which only works on Arrays and not custom data structures. 

If List were to expose a length property then a lot of existing code would break. Note that the native Map and Set collections also expose value.size for the same reasons  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!

**If you are contributing on behalf of someone else (eg your employer)**: the individual CLA is not sufficient - use https://developers.facebook.com/opensource/cla?type=company instead. Contact cla@fb.com if you have any questions. Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks! There's a bit too much happening in this PR. do you mind separating out the stuff unrelated to package.json dependencies and yarn.lock? Specifically the ts-jest changes are controversial and reduce test coverage, so I'd like to discuss those in isolation  It's pretty common for us to use the `arguments` object but leave a comment to explain what the arguments represent. Prettier screws those up.

Desired:

```js
static of (/*...values*/) {
```

Produced:

```js
static of /*...values*/() {
```

This was introduced to the codebase in #1123 and hopefully when fixed (https://github.com/prettier/prettier/issues/882 ?) will require a manual pass to cleanup. Sweet!  Applied to all files  Fixes #489  Yes - a new version is on its way soon  I'm glad you brought it up. There are reasons for a lot of this, but I agree that improvements can be made. Also - huge thanks for focusing on the kind of issues that make it easier for others to contribute, that's a great philosophy for contribution.

First of all, I think an obvious win is just to bump up the version of Jest being used to ensure the project is running on the latest. That should help with VSCode and other IDE integration.

Unit tests are written mostly in typescript because it's a two-in-one test, we're also ensuring the type definitions are correct. I recently made a change to the jest runner script to ensure no caching occurs, which ensures that typescript tests get static type checked before runtime tests run.

I think it's important to maintain the tests as typescript when possible, and use plain JS tests only when explicitly testing something outside of the typescript coverage - it ensures we get good coverage.

You may notice some tests actually cast through any in cases where it's testing error behavior, one thing I would like to see improved is something similar to the flow type tests where comments can be inserted where static type check errors are *expected*. That's been hugely helpful in testing the quality of the flow type tests. Since the jestPreProcessor is programmatically running those type tests, I don't think that would be too difficult to achieve.

For running tests against src/ instead of dist/, that gets tricky. It's dependent on another task #1044 to ensure the type definition files align with the source files. It also depends on a fairly major refactoring to actually ensure the src/ is valid ES2015 code - it was written before ES2015 was finalized and contains many quirks that now wouldn't run as written. There's still a good quality about testing the code you expect to distribute rather than the source code itself (ie. for compiled code, tests run against the compiled binary). One improvement that can be made more immediately is a continuous incremental build and test repl, that way the moment you save a file you have the relevant test results in a few seconds. I know the latest version of Jest added a repl, but some additional work may be necessary to get it integrated with the build step. Sorry I think I wasn't very clear on the flow type tests that led to your last action item there. 

What I meant was that the existing flow type tests have a `// $ExpectError` feature that's very useful for test writing and that feature would be a valuable addition to the existing typescript tests.  Does eslint have a typescript compiler plugin? That would be a great way to unify them if possible Very cool that looks like just what we need  This makes a few important changes:

* Existing errors for bad key paths have been improved to explain why and where the issue is.
* Previously strings were converted into an array of characters key path, a constant source of confusion. After this PR providing strings will throw an error.
* Previously anything iterable was allowed, but now only Arrays and Ordered Iterables, otherwise an error is thrown. This avoids a rare pitfall where Sets are used as a path, which have undefined iteration order.
* Adds a new thrown error for getIn()/hasIn() if a key path encounters a value which cannot be read with get(). Previously notSetValue was returned.

Fixes #635
Fixes #940
Fixes #451  Fixes #992
Closes #876 As far as I can tell yes, though if you're able to squeeze out any improvements that I missed, send a PR!  Can you share what version of the library you're using and also if this memory performance hit is still visible when using the latest build in the master branch? I just swapped out the js version for the master build: https://rawgit.com/facebook/immutable-js/master/dist/immutable.min.js and see this:

<img width="692" alt="screenshot 2017-03-07 12 16 37" src="https://cloud.githubusercontent.com/assets/50130/23676029/21a3412e-0330-11e7-9bdb-90f09caf3f63.png">

That looks like the immutable copy is about 38% larger, certainly better than 10x :) Closing this issue just for queue management, but feel free to reopen if there's more to discuss or more discovered  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!

**If you are contributing on behalf of someone else (eg your employer)**: the individual CLA is not sufficient - use https://developers.facebook.com/opensource/cla?type=company instead. Contact cla@fb.com if you have any questions. Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks! Manually merged in a2c4c741d9e552d4e2bc88d187970f315e2a0bda

Great work!  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!

**If you are contributing on behalf of someone else (eg your employer)**: the individual CLA is not sufficient - use https://developers.facebook.com/opensource/cla?type=company instead. Contact cla@fb.com if you have any questions. Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks! This is awesome, nice work I'd rather not include all the warnings - from past usage I've found warnings get ignored and just pile up over time. I think the eslintrc should either turn things off or make them errors with no need for a "lint:warn" npm script

Some examples of rules that are broken pervasively in this codebase and are safe to turn off:

- vars-on-top
- no-var
- consistent-return
- no-param-reassign  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!

**If you are contributing on behalf of someone else (eg your employer)**: the individual CLA is not sufficient - use https://developers.facebook.com/opensource/cla?type=company instead. Contact cla@fb.com if you have any questions. Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks! Sweeeet  These two functions warrant a variant for when the number of sets to be dealt with are unknown, with empty-set special cases.

Closes #415  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!

**If you are contributing on behalf of someone else (eg your employer)**: the individual CLA is not sufficient - use https://developers.facebook.com/opensource/cla?type=company instead. Contact cla@fb.com if you have any questions. Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks! Hey @umidbekkarimov thanks for digging into this!

#742 is a master task for modernification, it's important for each actual change to be focused and incremental. Could you separate this into separate pull requests?  Unfortunately there's nothing like that today - but you could certainly try to build it!

When doing something like that along with Immutable.js, you would need to reach into the implementation details of the data structures to have access to node sharing.

If you want to get a string representation of the  *whole* collection, you can just use `JSON.stringify()` to get a JSON representation  Sorry about this. The documentation site is produced from master branch, and this change happened very recently and has not yet been released on npm. After the next release this function will be available  This is actually a feature! `Seq` is a lazy collection and does not produce intermediate representations. Because of this, the order in which data is read results in the order in which the prior functions are called. Since the Sequence was reversed twice before being consumed, it is consumed in it's original order. If it's important that intermediate transforms like `map()` are called in a particular order, you'll need to ensure you convert the lazy Seq back into a real data structure (like an array) before calling it. Intermediate representations in this context refers to an actual data structure which holds the results of the previous operation. For example, if you use `Array` instead of `Seq` and call the same sequence of operations, you'll produce new intermediate representation Array data structures after each operation which will culminate in a final data structure. With `Seq` there are no intermediate representations, and what you say is correct that `Seq` is essentially planning a sequence of operations which is only executed lazily when necessary.

For example, consider this similar example which uses `reverse()` and `map()` but rather than calling `toArray()`, just accesses a single value with `get(2)`:

```js
const s = ['A', 'B', 'C'];
const result = Immutable.Seq(s)
  .reverse()
  .map(ch => (console.log(ch), ch.toLowerCase()))
  .reverse()
  .get(2);
// console.log: 'C'
// result: 'c'
```

Because `Seq` is lazy, the `map()` operation only applies to the one value requested, so `console.log` is only called once. Similar code with eager `Array` would console.log all three values.

This might illuminate what's happening when we "reify" the lazy sequence into a real data structure. `toArray()` is essentially calling `get(0)`, `get(1)`,  ... `get(seq.length - 1)` to produce all the items in the returned `Array` data structure, each access triggering only the transformation operations necessary to produce that specific value, and in aggregate triggering all those necessary to produce and return the `Array`. Because `reverse()` was called twice, `get(0)` refers to the first value in the original sequence, and so `map()` is triggered for that first value first, rather than the first value last.

Consider another example to illustrate why it's not possible for a lazy sequence to run these transforms in an order other than the final one requested without intermediate representations:

```js
const s = ['A', 'B', 'C'];
const result = Immutable.Seq(s)
  .reverse()
  .map(ch => (console.log('first:', ch), ch.toLowerCase()))
  .reverse()
  .map(ch => (console.log('second:', ch), ch + ch))
  .toArray();
```

Based on your original expectations, we might expect this one to log the "first:" three in reverse order, and the "second:" three in forward order. However because we're accessing the data only once in the end we can't be iterating *both* forward and backwards at the same time! A direction has to be chosen, and that direction is the final iteration direction of the sequence.  I would strongly recommend against using value based equality checking (`Immutable.is(a, b)`) within shouldComponentUpdate and instead use reference identity based equality checking (`a === b`). 

That's because you're doing a expensive computation (equality check) to determine if you can skip doing a expensive computation (re-render). If the equality check is slow itself, then you haven't really gained anything. However reference identity is extremely cheap and is perfectly suited for use in `shouldComponentUpdate` when using with React. Depending on how you update your data structure over time, false-positive re-renders will occur but should be rare.

The issue with computing Merkel-style hashes per node when doing equality checking is that you may convert a one-pass equality algorithm into a two-pass equality algorithm, first computing and comparing hashes, and then if equal comparing data structures as well to avoid collisions. An important difference from a Merkel-tree is that Immutable data structures are designed to live in memory and operate efficiently for general purpose use, so they do not use cryptographically secure hashes.  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!

**If you are contributing on behalf of someone else (eg your employer)**: the individual CLA is not sufficient - use https://developers.facebook.com/opensource/cla?type=company instead. Contact cla@fb.com if you have any questions. Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks! Stuck on #1074  Thanks! Unfortunately I had to revert this in aeb9aa4f3f9fc374a08ec8d9695ed0dfd2a72cba since it's still breaking tests. Also, this PR seems to have only altered the compiled files and not the original sources, so other tests weren't triggered.  Unfortunately I will still suggest that we do not do this.

Every method added has cost: more bytes for a compiled Immutable.js bundle means longer to download. More code means longer startup time in a browser or vm. And cognitive load is important to consider as well. Already one of Immutable.js's common complaints is that the API is relatively large and can take some effort to learn. Adding more methods makes this problem worse.

We only want to add methods when they add a unique capability that aligns to the goal of the library (programming with immutable data) and are non-trivial to implement (methods which take advantage of the inner workings of the data structures). Unfortunately `mean` and `sum` really do not meet these criteria. Honestly I believe it was a mistake on my part to have allowed `min` and `max` to be added as well, and could consider removing them in a future major release.

Immutable.js collections all implement the ES2015 Iterable protocol which was an intentional decision to make it easier to build general purpose versions of the types of methods you're suggesting. Then they could benefit from 1) not being bundled directly with Immutable.js and 2) work equally well with Immutable.js and native collections.

For example, here's an implementation of `sum` that you can use today, put on npm, or do whatever you like with. It will work with any collection that is Iterable, including native and Immutable.js collections:

```js
function sum(iterable) {
  let total = 0
  for (let value of iterable) {
    total += Number(value)
  }
  return total
}
```  This is actually a bug in the documentation generator, not a bug in the type definitions. This is a user defined type guard function:

https://www.typescriptlang.org/docs/handbook/advanced-types.html#user-defined-type-guards I just opened an issue for this at #1068 but would still appreciate help in fixing the doc generator!  This is an edge case to how `update` works with identity functions and default values.

See documentation discussion: http://facebook.github.io/immutable-js/docs/#/Map/updateIn

> If the updater function returns the same value it was called with, then no change will occur. This is still true if notSetValue is provided.

@tolmasky thanks for investigating, I added some additional tests for this case and unfortunately I think the changes you made would have broken them. Specifically, that first line you reference is handling the identity function case, and the second line - `NOT_SET` implies the value doesn't exist anymore, so actually `notSetValue` should be used there instead of `this`. I agree this corner isn't a great one. I'm hoping to improve it in a future major version. In the meantime these are great documentation suggestions  My only concern is growing the scope of the library. Maybe types aren't really about immutable data. I would prefer there to be a really good stand-alone library that provided Maybe/Either, but if there is some interoperability concern that building into the library directly would solve, I'd love to hear it.

What sort of interoperability are you thinking about? I'm going to close this issue - I believe Maybe/Either/Option is a really cool construct, but I'd love to see such a thing take off as a general use library outside of this one first. Then if interoperability opportunities arise we can take those on in more detail.  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!

**If you are contributing on behalf of someone else (eg your employer)**: the individual CLA is not sufficient - use https://developers.facebook.com/opensource/cla?type=company instead. Contact cla@fb.com if you have any questions. Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks! Thanks!  Thanks for investigating this. Ideally we could find a more performant implementation. ~1/2 as fast is a very high cost for this edge case @simonkberg yes however there are many cases where `isPlainObject()` is handling the uncommon case and it will be very common for non-plain-objects to fall through and hit the slow path.

@augusto-moura milliseconds matter in aggregate! This function is one called very frequently, so I don't think a 25x slowdown will be acceptable. We need to find another approach with a less punishing performance cost. @leebyron , it looks like you fixed it by this commit recently:
https://github.com/facebook/immutable-js/commit/2bff0cf0c13e6ec9f2bbfe2c48aec3740d4f552e

So, now there is no need for this PR  I don't think that rev will fix this particular issue. Objects with custom or other-realm prototypes still are not converted   `Map` typically takes two type arguments, the type of the keys and the type of the values: `Map<KeyType, ValueType>`, however since it's really common to use strings as keys, `Map<ValueType>` is also allowed, the type argument `ValueType` refers to what type you expect every value in the Map to be. Your example likely doesn't type check, but what would type check is:

```js
interface SomeInterface {
  prop: any
}

const map = Immutable.Map<SomeInterface>({
 someKey: { prop: 'hi' },
 someOtherKey: { prop: 'hello' }
})
```

A key detail is that `Map`, much like `Array`, is a *collection* type where every value in the collection is expected to be the same type. If you are looking for each value to be a different type depending on the key, you might be interested in `Immutable.Record`  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!

**If you are contributing on behalf of someone else (eg your employer)**: the individual CLA is not sufficient - use https://developers.facebook.com/opensource/cla?type=company instead. Contact cla@fb.com if you have any questions. Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!  No problem. It's just a new feature to flow and hasn't made it's way to immutable type definitions yet.

This would be a great task for anyone looking to contribute.  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!

**If you are contributing on behalf of someone else (eg your employer)**: the individual CLA is not sufficient - use https://developers.facebook.com/opensource/cla?type=company instead. Contact cla@fb.com if you have any questions. Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks! I think the error with `set` still makes sense. It protects against misuse. The desire to have merge behave similarly to constructor makes sense. It would be great to limit this change to merge. >  Why protect against misuse on set and merge but not on constructor and remove ?

I think `set` and `remove` should have similar behavior and `merge` and `constructor` should have similar behavior.

Specifically, I think it's appropriate for errors to be thrown for misuse of `set` or `remove` because they're indicative of mistaken usage. `record.set('unknownkey', 'value')` would be a no-op and typos would be likely to blame for a difficult to debug issues. However I agree `merge` should work similarly to the constructor and allow for applying a merged set that may contain more keys than the record itself does. Thinking about this more, I think making a breaking change to `remove` by adding throwing behavior could be inappropriate for the next immediate release and so perhaps dropping the error behavior is a reasonable backup plan - and ideally we can use type checking systems like typescript and flow to detect the sort of accidental misuse of set and remove.  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!

**If you are contributing on behalf of someone else (eg your employer)**: the individual CLA is not sufficient - use https://developers.facebook.com/opensource/cla?type=company instead. Contact cla@fb.com if you have any questions. Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks! https all the things!  Thanks for the report! Same issue with `skipLast(0)`  Yeah this would be great to have, but it's not easy to implement incrementally - some breaking changes would be necessary.

Specifically right now all types have a `toList()` and `toMap()` etc methods which convert between various collection types. That ties all of the library together and tree shaking typically isn't smart enough to trim prototype methods as well. A breaking major version change would be necessary to remove these methods to enable tree shaking.

However I don't actually think you would shave much from the ~15kb build already. That's roughly split into thirds: Map, List, and everything else. Merging into #317  Fixed in the next upcoming version!  Closing this issue since there's isn't actionable information here. If you can provide a reproducible issue, then please feel free to reopen the issue.  I agree with you about the utility of this. I'll merge this for now, but we certainly should consider a separate module in the future I'd prefer not to rely on 3rd party dependencies - I'll likely consider setting up a multi-package distribution in the future that allows subsets of Immutable to be used in isolation I plan on getting to another release sometime before 2019. 

Just kidding, I'm cooking up a new release in the next few days  For sure. #1056 is one attempt, however it has some punishing performance qualities.

I'm open to more exploration on this topic  Thanks :)  @Carlsson87 thank you for PR! ðŸ¥‡   Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!

**If you are contributing on behalf of someone else (eg your employer)**: the individual CLA is not sufficient - use https://developers.facebook.com/opensource/cla?type=company instead. Contact cla@fb.com if you have any questions. Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks! The next issue this is exposing is with generating the documentation. I've worked in a solution and will merge manually.  Coming very soon!  Unfortunately this is a consequence of the current implementation of `Record`. Using the collections higher-order API on them can lead to unexpected results.

Fixing this requires some rather dramatic changes to the implementation of `Record` and will require a major version bump of the library, so unfortunately for now there isn't much that can be done.  Thanks for the fix!  Map is not a type. It's a class as you can see [here](https://github.com/facebook/immutable-js/blob/master/type-definitions/immutable.js.flow#L489). For more info about `import type...` see [here](https://flowtype.org/blog/2015/02/18/Import-Types.html).  Thanks for answering @philpl. The key detail here is that javascript object keys are always strings, even if the characters in the strings look like numbers, and a numeric key and a string key that has the same numeric characters as the number aren't the same.  Closing since that rev got merged  Thanks for the report. The docs are out of date with the implementation which was updated to match the behavior of [Array#reduce](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce)  Good job. I think it's good to merge when there are tests for false positives (`$ExpectError`) Out of curiosity - what do you exactly mean by laxer? 

They are verbose, it's true. I don't have any experience with TS so I cannot compare. `immutable` is a bit special case because of generics and inheritance hierarchy. Great job. The only remaining issue are the `mergeWith` methods. Do you want to fix them here or should I or you create an issue for it? Other than that - thanks for helping all of us with this contribution.  @lacker I think it's good to merge.
@howardjing great job. Thanks for being so precise. Sorry for the nitpicking!  In the meantime, `Seq.Keyed()` will not expect array-likes.  Could you try the following:
1. Add `https://github.com/facebook/immutable-js.git` as your upstream.
2. Rebase your changes on top of master branch in the upstream
3. Build dist
4. Push it here

It fails because your changes are applied on top of an old commit.
<img width="467" alt="zrzut ekranu 2016-12-20 o 21 13 37" src="https://cloud.githubusercontent.com/assets/1693190/21366258/3d520de2-c6f9-11e6-973e-4aa7dba1c286.png">
 Looks good to me.

@lacker please verify and :shipit: .  Great answer by @philpl   Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!

**If you are contributing on behalf of someone else (eg your employer)**: the individual CLA is not sufficient - use https://developers.facebook.com/opensource/cla?type=company instead. Contact cla@fb.com if you have any questions. Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks! This does look helpful. Thanks!  It would be neat if you could run the docs locally, and then take a before & after screen shot so it's clear what happened. I think https://github.com/facebook/immutable-js/blob/master/gulpfile.js has the stuff to run the docs, maybe just running `gulp dev` works to see that. Hey @flarnie thanks for digging into this!

In order to run locally, make sure you have `gulp` installed then run `gulp dev`.

I noticed in your screenshots that the text shadow is still quite dark, which makes the text fuzzy and harder to read.

I originally put the shadow on the white text to increase contrast against the "immutable blue" header color, which gives an appropriate 3:1 contrast ratio for the typical case.

Perhaps we could do the opposite for boosting contrast? Instead of making the text gray and lightening the blue, we could instead make the splash screen background a slightly darker gray or give a slightly darker shadow on the white link text. Ideally we could make that shadow darker specifically for the gray wash case without much disruption to the blue background case I just added a commit which boosts contrast by deepening the shadows around those links and darkening the background  I think it's a feature. 
`List.findIndex` works like `indexOf` in `Array`
Using negative indices for getting values has been implemented in #116.

You should probably check if `findIndex` returns a negative value before passing it to `List.get` It's understandable since docs don't mention it. It would be great to get a pull request improving the docs to mention this! For this particular bug report though I think we should close as "working as intended". Thanks for bringing this up!  Arrow functions do not capture `this`.

https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions  Great answer by @philpl 

Returning the same reference for "no-ops" is a performance optimization and so only occurs in cases where it can be done performantly.

One work around is the following:

```js
x.merge(y.merge(z))
```  I *think* it's impossible to express with `flow` now. I added an [issue](https://github.com/facebook/flow/issues/2959).

---

Sorry, I wasn't clear. It is possible to express but it requires duplication of definitions. `Map` is typed correctly because the definitions are copied from its superclass and the types are tweaked to `Map` from the superclass.  `toJS` will convert deeply - you can check out some examples in the `__tests__` directory for illustration. Note that `immutableList[0]` indexing does not work with Immutable collections. You must use `.get()` and `.set()` instead.

Also, `toJS` converts as deeply as it can before encountering something it does not know how to convert. For example your code is using JS classes which are not immutable collections. My guess is that upon encountering an instance of `Immutable2` which is a general JS class and not an Immutable collection, `toJS` believes that it has converted as far as it can  Not dead! Immutable.js is still used heavily both within Facebook and in the broader dev community. However right now maintenance has slowed. I've been working on some strategies to get more attention to continued maintenance but the focus needs to be on refinements and bug fixes - most issues ask questions and PRs attempt to add new features which deserve their own libraries.

I'll hopefully have more to update soon.  Yeah we don't really advertise this much, and I'm not sure negative indices will stick around for future major versions since it breaks with native indexed collections and can be buggy along with indexOf so I'm not keen on starting to encourage usage now.  Sorry I can't reproduce your issue without runnable code and expected/actual results.

Remember that sort functions return numbers not booleans:

https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort  This is expected albeit confusing behavior by JavaScript. 

The issue is:

```
{
  11: {
      name: 'some error'
  }
}
```

This looks like `11` would be a number property on Object, but Objects can *only* have string properties, so JavaScript first converts `11` to `"11"` and then sets a property with a string that happens to have numeric characters.

Collection types like the ones Immutable.js provides (and the native Map and Set collections) allow for all kinds of types as keys or entries, not just strings.

You can use Map with numeric keys, but you just can't create it from a javascript object which itself enforces string keys, instead would have to use a sequence of [k,v] tuples. For example:

```js
Map([ 
  [ 11, Map({ 
    name: 'some error'
  }) ] 
])
```  `shallowEqual` relies on `===` for each value in `props` to determine equality. Two value-equal immutable collections are not necessarily `===` for the same reason two arrays with the same items won't be `===`.

However Immutable collections typically attempt to return themselves whenever an operation results in a no-op, that means that `===` can often be used alongside Immutable collections, but if you're constructing two collections independently and comparing them with `===` will always yield `false`.  I'd love to do this - I think tactically there are a few things we need to do to enable this.

First is to nominate some volunteers - anyone who has a good understanding of the library and it's mission and wants to contribute to maintenance. I'm open to suggestions.

Second is to bias towards creating an ecosystem around immutable-js. I know there are a lot of requested features, and I think the best case scenario is that we encourage a small-library ecosystem around a set of shared patterns and interfaces. That enables a marketplace of ideas and removes myself, Facebook, or any other maintainers from the path of innovation.
 Hey @linusnorton - sorry for not following up on this discussion sooner.

> Could you clarify your idea of the ecosystem?

Ideally installing immutable.js gives you a small set of core functionality, and you can use other npm modules for additional behavior - that way we can allow for anyone to release ideas that work well with immutable.js. I think it would be a failure if the only way new ideas and features can be introduced is if they have to all be added to this library in particular.

> Are you proposing something like extensions to keep the core small and focused? It sounds like a good idea to me. I think this is a very feature stable library and the core of it should stay that way.

Yes, 100% agreed. In my mind, the answer to most feature requests should not be to evaluate the feature itself but instead evaluate if there is a missing extension point that's in line with the library's intended use.

> Deciding the governance model will be important. Assuming people do step forward we'll need some agreement on how decisions are made so that it doesn't all fall on your shoulders, but also doesn't go away from your original vision entirely.

I agree this is important, but also something I'm a bit stumped on accomplishing. I'm open to ideas but right now my thought is to introduce more co-workers who are using Immutable.js at Facebook to help maintain, and then slowly adding trusted contributors from the community at large if necessary.

Overall though, this library intentionally moves slowly and there aren't many decisions to make. The goal is to bias heavily towards stability - so doc clarity, bug fixes, and perf improvements are valuable, but altering the feature set is less valuable. I think this approach shouldn't require a huge amount of effort in governance. Totally agree. In fact you should see some folks helping drive down the issues. The gracious @lacker is already making a dent!

 In the spirit of that, I'm going to close this issue as well. 

I'll try to get a reviewathon scheduled sometime soon to help press down the outstanding PRs. We'll go from there This reviewathon could really use some Typescript & Flow expertise - my first learning after going through a chunk of pull request and issues is what a large % of the issues are actually just updates to the type definitions.  Yes, checkout `zip` http://facebook.github.io/immutable-js/docs/#/List/zip Right to get a hashmap output, just wrap with Map:

Map(keys.zip(vals))  Merged, will be in the next release  Immutable collections allow for any kind of value as a key, not just strings. Your application may expect the proper way is to use strings, but other applications use these collections in other ways. It would be inappropriate to limit the usefulness of the library.

However `toJS()` only works as expected when you are using keys which convert to strings soundly. It sounds like part of the issue is that you are relying on `toJS` and converting Arrays to strings results in comma separated values of their children.

I strongly suggest using Flow or Typescript to catch these sorts of mistakes.  Any Object that has a prototype Immutable.js assumes isn't a candidate for conversion to Map/List. If you want to explicitly convert them, you can wrap them in the type you want:

```js
const obj = fromJS({
  child1: Map(yourCustomClassInstance),
  child2: []
})  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!

**If you are contributing on behalf of someone else (eg your employer)**: the individual CLA is not sufficient - use https://developers.facebook.com/opensource/cla?type=company instead. Contact cla@fb.com if you have any questions.
  Will be fixed in the upcoming release  The size member should not be mutable - I'll be adding a change to the typescript types to make that more clear. Unfortunately JavaScript does not provide many facilities for protecting readonly members in a performant way and performance is paramount in this library  I think this pull request has essentially timed out. If you are still paying attention, I was going to request some sort of test to ensure that this is working properly, but my guess is that this is abandoned. I am going to close it but if someone still actively wants to deal with this then please feel free to reopen it! Hey, I'm glad to hear that this is not abandoned! Sorry for closing this, I'll reopen it. Check out https://github.com/facebook/immutable-js/tree/master/type-definitions/tests - when you run `npm test` it sub-runs `npm type-check` which does a flow check on that directory, so if you add some code that exercises this particular type it'll ensure the type checks are correct. You didn't miss them, they got merged in pretty recently ;-)  Sorry, without code that I can run locally I can't reproduce your problem  Closing this aging issue.

I'd like to avoid relying on `toJS` any more since it's a performance pitfall. Pro tip if you're doing lots of accessing, `getIn` can help access a chain of keys  Closing this aging issue.

I'd like to avoid an ever-growing prototype of methods. Since the implementation for this is quite small, it looks like it would be a reasonable function in your application instead of in the data structure library  Looks like this PR has been failing tests for the past year so I am closing it.  Thank you for your pull request.  As you may know, we require contributors to sign our Contributor License Agreement, and we don't seem to have you on file and listed as active anymore.  In order for us to review and merge your code, please email cla@fb.com with your details so we can update your status.
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 `compareWith` seems like a problematic thing to expose because it works indirectly, it's like it just operates with side effects. At least if I understand it properly. Also maybe this just timed out at this point. I am going to close this pull request but let me know if you think there is still something we should do here. It seems like the right way to do this would be to create a collection with a custom comparator - that's how most languages handle this sort of data structure. Then it's per-collection rather than using `compareWith` impurely.  Fixed in master will be released soon!  Sorry for the long delay. Closing this aging issue, so I hope you figured it out.

Prototype methods need to use `function () {}` instead of arrows in order to refer to the class instance as `this`.  Thank you for your pull request.  As you may know, we require contributors to sign our Contributor License Agreement, and we don't seem to have you on file and listed as active anymore.  In order for us to review and merge your code, please email cla@fb.com with your details so we can update your status.
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 Dead? Pshhh. It's not like we let this pull request sit for 15 months without responding.

Anyway my guess is that this has been abandoned. I was gonna ask for some sort of test if this was still alive, but I'm just gonna drop it. Sorry for letting this be quiet for so long :P and if you want to keep working on this please feel free to reopen! hey, thanks for bringing it back. I didn't mean to insult you. I just didn't see too much activity on any pull request at that time. Anyway, if you want a flow definition here (vs having one in `flow-typed`) I am more than happy to maintain it. What's the "standard thing to do" around having a flow definition here vs in flow-typed? We should have a correct flow-typing as opposed to an incorrect one but I don't particularly have a stance on where it should go. Probably here? So I think it is awesome if you could help maintain this - so here's a question - do you think it makes sense when people submit a change to the flowtypes, to ask for a test that exercises the new type? I just want to make sure that we are protecting against stuff breaking as we improve things. In my opinion it's better when definitions are in the repo. For obvious reasons - it becomes immediately available to everyone who uses it. I'll ask in [this PR](https://github.com/flowtype/flow-typed/pull/401#issuecomment-264533899) for their point of view on it.

We might put it here for now and we will see how it evolves.

When it comes to testing, yes, I do think that tests are necessary. And tests are implemented [here](https://github.com/facebook/immutable-js/pull/878). I just need to make `flow` run on travis so that it's automated. Sorry that I spammed across few PRs to move people's work to my PR in `flow-typed` but I didn't know when and if our work here will ever be merged. Yeah I understand, it's cool that you were spamming your alternative, I feel your pain man. But now that I am paying attention I would like the immutable.js repo to be all nice and things. I could really use your help reviewing Flow stuff though since I'm sort of a Flow noob myself. So what do you think we should do for this pull request - just accept it, or ask for some extra test type stuff, or what? I think that the order should be the following:

1. Decide on the blessed way to [import](https://github.com/facebook/immutable-js/issues/863) things
2. Merge my PR I mentioned above which actually contains tests. It also needs some work but I can do it over the weekend.
3. Further improvements like this one

---

`flow-typed` makes a lot of sense because of versioning (separate versioning for flow versions and module versions). Also [testing if the definitions actually make sense](https://github.com/flowtype/flow-typed/issues/100) is a thing to look forward to. However for now, I'd like the "correct" definition to be anywhere and we can proceed with further improvements in the future. I made the tests run on travis in #878  OK so https://github.com/facebook/immutable-js/pull/878 is in now so we have some Flow type refactorings and also you can now test flow types. Would you mind updating to merge those changes in, and also adding a test that catches these changes? Thanks! I'm a bit confused. The diff shows that my changes are reapplied. Could you rebase the PR against current master? Possibly your fork's master is probably behind  If you look at [this file](https://github.com/facebook/immutable-js/blob/master/type-definitions/immutable.js.flow) and the contents of the PR, you can see that something is off. Maybe conflict resolution gone wrong? It would be awesome.  omg, sorry. This is what you call a 5 am review. I didn't notice that referred to `dist/` This is awesome. Great work ðŸ‘ 

Now it's up to somebody with commit access to merge it. Thanks @alexfedoseev for submitting this and thanks @wokalski for reviewing!  Fixed in master - will be released soon  The documentation function types are written in [typescript](http://www.typescriptlang.org/) to help explain how various methods work.

Some but not all documentation contains examples. If you wish, adding examples and improving documentation is an excellent way to contribute back to open source software.

All documentation for this library is automatically generated from https://github.com/facebook/immutable-js/blob/master/type-definitions/Immutable.d.ts which should make contributions easier  This is intentional as the method is deprecated and will be removed from the documentation in the next release.

I suggest using `Map([[ 'foo', 'bar' ]])` or `Map({ foo: 'bar' })`  I think it's more important for `reduce` and `reduceRight` to mirror the behavior of the same named functions on `Array` for predictability.

If anyone wanted to submit PRs to add laziness to reduce/reduceRight, that would certainly be interesting but it would either need to be a different name (fold?) or not upset existing predictable behavior.  Glad to hear it
  Fixed in master will release soon  @kentor has the right answer here. Any JS classes that wish to be used as Set members or Map keys need *both* `equals` *and* `hashCode`  Fixed in master now, will release soon  Unfortunately Flow doesn't have this capability just yet, but it's planning on it. I've put in the necessary syntax with fingers crossed that a future version of Flow works correctly, but in the meantime you'll need to use `status instanceof Set`  Sorry without executable code and expected/actual results I can't debug this issue.  Try `contains`. `has` looks for keys/indices while `contains` looks for values.

The first example correctly returns false because the flattened list has only one thing in it (index 0) so it does not have index 1. In the second example there are two things (index 0 and index 1) so it does have index 1.  I do need help reviewing!

However both of the changes in this PR are incorrect and were correct before being changed 
 Ah no wait, I'm reading the diff upside down! Quick someone get me coffee!
  Thanks for this report.

Actually `getIn` isn't possible to correctly type check unfortunately since the key path may lead to a collection of a totally different type and Flow can't translate that, so I'll convert them to return `any`. However you're totally right that `get` could return void.  Unfortunately proxies are *really* slow, so I'm not sure we would want to add this into the core library. Cool idea though! 

Reopen or submit a PR if you have an idea for how to do this in a performant way  As far as I can tell it isn't intended that "Infinity" is supported as a number to pass here. The docs don't claim this works or anything. That seems like it might be nice but at the same time this pull request is pretty old - sorry about that - so I think the practical thing to do here is just to close it. If you're still interested in this please feel free to reopen!  Is there some way to test these? Like adding a little bit of test code that exercises this specific type? We have a big backlog of pull requests of the form "tweak types a bit" and I just hesitate for the plan to be that I eyeball a bunch of them. Closed by #919   Closing this aging issue.

Sorry, I'm not sure I follow. Immutable is designed to provide iterable collections which React can collect as children via the technique described in [iterall](https://github.com/leebyron/iterall). Ensure your version of React is up to date.  Closing this aging issue.

The solution is to not use `new`. The JS VM will allocate new memory when call `new` even though Immutable.js does not use that memory, and that can create a performance hit.

In fact, `Immutable.Map()` when called with no arguments does in fact return the same instance of the empty Map every time, and VMs are very fast at optimizing paths like this.  @ccorcos Yeah we are maintaining this now all seriously-like. I was thinking it would be nice when we update flow types to make sure they are exercised in a test (for the withMutations part) - does that seems sane? Or is that already happening somewhere. OK so https://github.com/facebook/immutable-js/pull/878 is in now so we have some Flow type refactorings and also you can now test flow types. Would you mind updating to merge those changes in, and also adding a test that catches these changes? Thanks! Feel free to submit a PR if you have something working. I'd say closed and rewritten  @ccorcos, from conversation above, it looks like this PR should be closed. Let me know if it is not correct assumption. ðŸ˜…  @ccorcos could you remove the unrelated changes of handling exports? We should tackle that in a different PR. Also, please add some tests (see type-definitions/tests) that describe the correct behavior. @jedwards1211 I'd say let's wait for the conclusion of this PR.

@rgbkrk I started doing it in a PR to `flow-typed` but dropped it in favour of defs built in here. Maybe it needs to be revisited. You get many nice things with `flow-typed` like versioning. My line of thinking is that it allows more people to use flow defs. They don't need to use yet another tool. Closed by #1073  Yeah my mistake on typescript vs flow specific. I'll get equivalent changes out to flow types next :)  Does this PR still make sense now that we merged https://github.com/facebook/immutable-js/pull/878 ? @ccorcos, is the issue addressed in this PR still exists? If no, please, close. ðŸ˜…  @ccorcos could you recommend a way to test this change that would otherwise currently fail? I just added a flow type test that ensures the native es6 collections can be used alongside the Immutable.js ones.  Great idea. If there are any candidates, I think a page on the wiki is the right place for this.  > I assume it has something to do with objects supporting only strings as keys, but accepting integers nonetheless.

Bingo!

```
â¯ node
> Object.keys({1:'foo'})
[ '1' ]
>
```

JavaScript Objects only support string keys, but they allow specifying them without the quotes (as of ES3) which makes numeric character string keys *look* like numbers, but they're not.  I'm guessing this has been abandoned - we do need folks to sign the CLA, for what it's worth.  @Retsam thanks for the excellent answer  It's not clear that this is worth the added code. Maybe we need some sort of "immutable.js improvement proposal" IIP type process, because I feel bad just saying "meh". But, that said, we have to draw the line somewhere. I am going to close this but if you object then let's discuss because maybe there is something more intelligent to do here.  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
  That's correct. fromJS() expects plain JS arrays and objects as input. It does not operate on anything else.  Highly recommend https://www.amazon.com/Purely-Functional-Structures-Chris-Okasaki/dp/0521663504
  Closing this aging issue - sorry I hope you were able to figure out what was going wrong with your app. If you found something related to Immutable.js in there, please open another specific issue  The previous major version had `.length` but a very common problem was that other code would see the `.length` property and attempt to use Immutable collections as if they were arrays, however that does not work because `list[0]` syntax does not work on anything except arrays, with Lists you need `list.get(0)`. So the `.length` property was deprecated and removed, replaced with `.size` to remove confusion and mirror the same decision made for ES6 native `Map` and `Set`.  No description so I just closed it. Sorry! Are you still interested in this pull request? If so can you describe what's going on and why this is good. Sorry for the huge delay! Just kicked Travis to get a passing build and this looks great. Love this new TS feature.  Yea we do accept PRs. I could use a description of what this PR is all about, the ones with no description I stuck at the bottom of my "to-review" pile Super dope, thanks. Loving all these new TS features.  Tests have been failing for a while so I'm going to close this. If you are still interested in working on this please feel free to reopen!  Not really a bug per-se since there's never guarantees about `===` working - that's a perf optimization. However this does seem like it could be a pretty easy enhancement for someone looking to contribute.  Sorry, I don't follow your issue.

ES3 refers to the JavaScript version supported by browsers since 1999 https://en.wikipedia.org/wiki/ECMAScript#Versions  Try this:

```
return fromJS(state).get('myList').filter(l => l.get('id')).map(list => (list.forEach(elem => console.log(elem)), list));
```  Does this PR still make sense now that we merged https://github.com/facebook/immutable-js/pull/878 ? I *think* I fixed it. [The test](https://github.com/facebook/immutable-js/commit/0155f1c7b2e9c575b2090ff0e5e9093ae1039c87#diff-167148588528b5fa451dc535e9c29037R20) passes. The default export is `immutable` module. Since the tests now check that Flow works with:

    import Immutable, {
      List,
      Map,
      Stack,
      Set,
      KeyedIterable,
      Range,
      Repeat,
      IndexedSeq
    } from 'immutable'

it seems like this functionality is now in master. So I am going to close this pull request, but if you think I'm making a mistake please feel free to discuss/object/etc. Thanks for submitting this pr!  Seems like a missing opportunity - let's add it!  Thanks!  Unfortunately splice cannot be used within withMutations. Since it shifts indices it always results in full copy. Check out the docs for more facebook.github.io/immutable-js/docs/#/List/withMutations  Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 Hey, sorry for letting this go stale. Would you mind explaining how you tested that this does not introduce any problems? Hi @danjm! I am starting handling backlog. I know it is been a while since you've submitted PR, sorry for such delay. The are some conflicts. Could you, please, rebase? ðŸ˜…
Also, if you can explain how you tested the PR, it would be super helpful! 
 I'm going to close this PR - it's better to include this in the source rather than editing the site builder since some cases will have more than one example, or continued discussion after the example, and this condition is not sufficient for those examples.  This is not a spelling mistake!

https://en.wikipedia.org/wiki/Memoization
  I feel bad that we didn't help better, but honestly I cannot figure out what the heck is going wrong here. I'm going to close this under the theory that it is abandoned but if you're still interested in working on this please feel free to reopen. Sorry!  What problem is this fixing, exactly? Sorry for asking dumb questions. Is there a `this` thing that works better for this? I feel like I saw a different PR that fixed this differently. Updated before committing: some of the overrides were still returning `C<T>` instead of `C<M>`  W.T.F.

Could you please open an issue on Safari? https://webkit.org/reporting-bugs/

This sounds like a serious issue on their end.   Done in master! Will be released soon  Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 This seems like a good thing to do. Thank you!  This doesn't seem like something we would want to commit to - what's the problem that this fixes besides sort of an aesthetic completeness? I could be wrong so feel free to object but for now I am closing this.  Since Immutable methods for updating always return new collections, they're naturally chainable!

I just updated the wiki page.

Note that the wiki page for this repo is editable by anyone! Once you have answers, feel free to improve the wiki.  Let's do it  :/ The documentation sidebar used to be fixed and people complained loudly that it was extremely difficult to navigate and so it was changed to remain on the page.

I'm happy to entertain this change again, but a main concern is an ability to scroll that navigation when it's longer than the page.
  Closing this since it's aging  This is intentional - Set doesn't have any of the `*In()` methods since they only apply to associative collections which Set is not.  #1002 explains this

Immutable collections allow any sort of key, not just strings. Array keys are just fine!   New type definitions are almost done, and will be released soon!  `map()` and most other sequence transform functions do not mutate and always return new collections. Check out the docs for more info http://facebook.github.io/immutable-js/docs/#/List/withMutations  You definitely can use indices! I added a test to illustrate  fromJS() is exactly for converting JSON payloads to Immutable Maps and Lists! You're doing it right. 

The least efficient operation is toJS(). Immutable collections already can be provided to JSON.stringify() so there are only rare cases to use toJS() and yet unfortunately it's quite common. Overuse of toJS() can negate a lot of the beneficial properties the data structures in this library offer. 
  What's up with the `DocVisitor` changes?

This is really touching a zillion different things, huh. How did you test to make sure none of these are in error? @lacker, is this PR ready to be merged? Hey @Merott sorry for the huge delay but I'd love to readdress this.

Two primary concerns:

1) `this` is usually used to describe returning the same instance. Not the case for Map.
2) The problem described is relative to Record, but being applied everywhere. Could you re-scope the change to only apply to Record?
  Sorry for not responding in a timely manner.

I'm closing this aging issue, however if you can reproduce the issue against the master branch, please feel free to re-open the issue.  > To update state in Redux with Immutable, do I call state.merge(something) or state.update(...)

Both of these will return a new version of your state with a change applied. They just do different kinds of changes. Merge looks fine as you're using it now. There's a good parallel here to Arrays. push(), shift(), and map() are all about changing things, but they do different things. One isn't superior to the other. 

> When structuring my changed values, what is the best way to do that? I most certainly know that I have done something and most likely everything wrong, so I hope that you will correct me on this.

I think you're over thinking this. There's basically no wrong way to structure your data. It's your data. Structure it however you like that works for your app.

> How do I call update / updateIn on flat objects?

Could you clarify what a flat object is?
 One thing I noticed is that your function says it will accept Map as state and action, but you're using property accessors like `state.data` or `action.type`. Immutable Maps are not like JS Objects, they're like ES6 Maps. They don't have properties but instead have a get() method. 
 I'm not sure this code does what you think it does. Does it work?

I think you may be misunderstanding some fundamental concepts here. I definitely recommend backing up and getting a better grasp on what it is you're trying to accomplish without additional tools like redux and immutable or babel/es6 and only including these when they help you accomplish something in a better way.

To start, I suggest reading more about redux and reducers. Typically the goal or a reducer function is to accept an older version of something and one other value and then return a newer version of that same thing by using the value. When called multiple times with each new value becoming the "older version" with each subsequent call to the function, you can model change over time via the sequence of events. Immutability is a fundamental aspect to how a reducer function should work (not specific to JavaScript, the concept exists in most languages) but you don't need a special library to use immutability. Simply don't edit the "older version" and instead always create a new copy with your change applied. Redux is really just about popularizing this existing concept of reducers to UI programming. The "thing" being updated over time we call "state" and the value used to update it is the "action". You can see that in your latest version of your code, you're not using the previous state at all to produce the new returned state, that's definitely a big red-flag that your reducer isn't doing what you want it to do. 

Next, the ES6 features enabled with Babel being used here represent the "default values" for arguments, or what value to use if one is not passed to your function. In a reducer the second argument "action" is always provided, so the default value there isn't doing anything valuable. It's probably just distracting from how the reducer works. The first argument "state" is only not provided for the very first time the reducer is called in the case that you're not providing an initial state. If your redux setup has an initial state then you don't need that either. If it doesn't, then here's where that initial state can be defined. An empty Map is very likely not what you are expecting to be your initial state. So it's either distracting from what's really going on, or your probably have a bug there, depending on if you're providing your initial state to redux or not.

then there's immutable.js. I would strongly suggest familiarizing yourself with the concepts of immutability without using this library first just by using plain old JavaScript objects at first. Actually in your case it looks like your state is quite simple so you're probably not gaining much by using immutable.js anyhow. Since plain JS objects are much simpler, hopefully this can help you better visualize what's going on. You can return new versions of your state using Object.assign like this:

var newState = Object.assign({}, prevState, { keyToChange: newValueToUse })

I'm sure you can find ample examples of this sort of thing in the redux documentation and explainers. 

Once you get a better grasp of using redux to build apps and things are working, come back to immutable.js as you need to model more complex state or state that has larger amounts of data in it. Immutable.js uses different kinds of data structures that help conserve memory and improve performance for those kinds of situations.

I'm going to close this issue since both the question in the title was answered in an earlier comment (both merge and update are useful for updating redux states, as are the many other methods immutable.js provides) and the discussion has mostly been focused on this one piece of code, which may be better handled by either working with some tutorials or asking on stack overflow. 
  I agree, the docs would be better with some examples, like an "intro" or "tutorial" type thing. That said, I am going to close this issue because we are trying to keep the issues focused on bug reports. My goal here FWIW is to first clean up the outstanding issues & pull requests and then look at some stuff like improved docs, so I am hoping to fix some of this up. And pull requests to improve the docs are welcome too ;-)  Thanks
  I cannot reproduce this in a fresh `npm init` test directory.

In the _args and _requested section of your installed package, it looks like `^3.7.6` was requested. I expect that you might have multiple versions of your dependency listed in your project - or perhaps npm is installing in a buggy way.  Thanks for the great explaination! `fromJS` is the right path  Just as a note, you should always include your IDE's temporary files in your global gitignore for your git user.

See: https://help.github.com/articles/ignoring-files/
  Unfortunately this is a consequence of Records being iterable. You'll notice that if you do the same thing with `Map` in place of `Record` that you'll see the same behavior.

The solution here is to use `map()` instead of `flatMap()` if you're not returning values that do not need to be flattened, or to ensure that you're always returning a collection to be flattened.  That definitely makes sense thanks for investigating. Of course deletion at indices will change the shape of the List itself. Negative indices cause issue there. Let's start with Map since we know that works. I'll help get a clean merge  The original is correct. It's goal is to return a strings which have been "quoted", otherwise 

Input: `'string "foo" bar'`
Output: `'"string \"foo\" bar"'`

This is used for stringifying output so it is clear which values are strings and which values are something else.  Thanks!  Woops, I merged https://github.com/facebook/immutable-js/pull/873 but didn't see this. Does this still work in conjunction with https://github.com/facebook/immutable-js/pull/873 or what do you recommend now? Thanks!  Closing this aging issue

Unfortunately this sort of thing still isn't possible in a performant way.  Thanks for pointing this out! So, if we just add a failing test then the CI will lie down in the snow and die. So I think we would need to simultaneously have a fix for the bug, and a test. I am going to close this PR but if you would like to fix the problem as well then please feel free to reopen!  Thank you!  Sorry, but this isn't enough information for me to answer a question  Sorry, but I don't think such a function is appropriate for the general library. Though this may be something you can create an npm package from if it is of common usage!  So https://github.com/facebook/immutable-js/pull/878 refactored the flow types and also added tests for them. Would you mind updating this PR to merge those changes in, and also add a test that catches this? Thanks! OK, I am going to close this one in favor of 1027.  Seems to be fixed in master by moving the definitions of `map` to their subtypes  I'm on a pretty epic bug. I wanted to fix imports according to [this](https://github.com/facebook/immutable-js/issues/863#issuecomment-264611660) comment. The problem is that when I wrap everything in `declare module` everything is exported correctly, except for `List`. The funny thing is that if I rename `List` to `Lista` or really anything, it works. I just wanted to say that overall having flow type tests in this repo will make it a lot better, because it'll be a lot easier for us to accept a lot of the type-bug-fixes that have been submitted, so you are a hero for putting this PR together @wokalski  thanks for the review - I broke CI and didn't know about it. The little things you mentioned should be fixed now. Does `$ExpectError` actually fail if there is no error there or does it just allow an error on the subsequent line? Good point! It does fail. YOLO  Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 Thanks!  So https://github.com/facebook/immutable-js/pull/878 refactored the flow types and also added tests for them. Would you mind updating this PR to merge those changes in, and also add a test that catches this? Thanks! Hi there. I am starting handling backlog. I know it is been a while since you've submitted PR, sorry for such delay. The are some conflicts. Could you, please, rebase? ðŸ˜…  Thanks for sending this! Overall I think this is an improvement although I had a bunch of nitpicky details which is kind of what docsy PRs end up with. Looks good, thanks for helping improve the docs here!  LOL - that's amazing, it's like a secret way to discourage people from reporting github issues. Thanks for fixing this!  Closing this aging issue - there's no plans to add this to the library, however if you ever feel up for a serious contribution, I'd love to see your research into how to accomplish this.  Fixed in master will be released soon  It's partly a bug, and partly intentional!

After some investigation:

It's intentional that `map` is called in reverse order to preserve the order of the ultimate Stack - that is Stacks are constructed "bottom up" and because `map()` uses a prior Stack to create the new one - the initial Stack is iterated in reverse order to create the new one.

However the bug is that idx is not correct for the reversed values. Just some debugging knowledge dump before I leave this for the night. This might be a larger issue than just Stack and map, but perhaps any Seq that has been reversed *after* mapped (or filtered, or anything else) the prior operations may then get reversed indices.

I think fixing this may require a deeper refactor of how sequence reversal works at the moment.

```
> Stack('abc')
Stack [ "a", "b", "c" ]
> s = Stack('abc')
Stack [ "a", "b", "c" ]
> m = s.toSeq().map((v, i, c) => v + i + c.get(i))
Seq [ "a0a", "b1b", "c2c" ]
> Stack(m)
Stack [ "a2c", "b1b", "c0a" ]
> km = m.toKeyedSeq()
Seq { 0: "a0a", 1: "b1b", 2: "c2c" }
> Stack(km)
Stack [ 0,a2c, 1,b1b, 2,c0a ]
>
```  So https://github.com/facebook/immutable-js/pull/878 refactored the flow types and also added tests for them. Would you mind updating this PR to merge those changes in, and also add a test that catches this? Thanks! Closing this - the changed lines are all intentionally optional function arguments and are not nullable types.  I'm not sure a Seq can be meaningfully compared in a numeric greater/less-than way. That definitely sounds like a useful userland code, or perhaps a supporting library!  Either one big PR or separate PRs is ok. Maybe separate PRs are nicer because it's easier to just merge more things in then. Oh and thanks for improving this documentation!  That's correct - the previous behavior was a bug. Clearly the value at index `0` is `1` and not `4` in your example, so the entry `[0, 4]` does not actually exist in the sequence, however the entry `[3, 4]` does. That bug was fixed in 3.8.1  IMHO the standard way to use with ES6 imports should be:

```js
import {Map, fromJS} from 'immutable';
// or 
import * as Immutable from 'immutable';
``` however it would be nice for convenience to also export an ES6 default such that

```js
import Immutable from 'immutable';
```

Also continues to work correctly. That might mean a slightly more awkward flow definition file, but that would enable those who use it this way currently to keep doing so without breakage. I agree with @leebyron - it should be OK to do either of:

    import Immutable from 'immutable';
    import {Map, fromJS} from 'immutable';

It seems like this is how most things export stuff, React and React Native work this way for example. This is option (C) from @zertosh above. Both are now implemented in master and will be released soon  `src/` is pre-compiled source and because this source was originally written in early 2014, it's not perfect ES6 code - unfortunately at present you have to rely on dist/  Hi there. I am starting handling backlog. I know it is been a while since you've submitted PR, sorry for such delay. The are some conflicts. Could you rebase, please? ðŸ˜…  @xavierelopez - could you please explain what the warnings were and how to reproduce them? Also, our documentation is generated from this .d.ts file - could you please add to your test plan that the documentation website was still correctly generated? I'm going to close this PR since it's starting to age and many new tests have been added to the type defs in the recent weeks.

If you still see issues on the master branch, feel free to rebase and reopen.  Hey, thanks for sending in this pull request! I don't think this is the right thing to do, because then any breaking change to Immutable would also be a breaking change to the website. So I am going to close this pull request, but thanks again for putting in the effort to improve things.  The docs have been updated recently with more examples, hopefully that clears up how to use `.map()`

> The missing information is the mapper function passed to Iterable.Indexed.map() can return arrays of the form [key, value], while Iterable.Keyed.map() cannot.

This isn't correct - there is no significant difference on how `map()` works between Indexed and Keyed collections - both operate on values.  Fixed now!  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 It looks like this PR has been abandoned since that last comment never got any response. I am going to close it under that theory but if you are still interested in working on this please feel free to reopen! OK let's see what we should do here. I guess one question is how we should handle deprecations. I don't think the approach of doing a `console.warn` when you use it is quite the right one - that might cause trouble in some environments because you might have `console.warn` do something very interrupty and not even realize what's happening. I think we would be better off just commenting that methods are deprecated, and then removing them in the next major version bump. I will ping @leebyron about what the right timing is here.  Fixed in master will be release soon  Javascript `>` and `<` operators attempt to coerce values into primitives before comparing - so doing that with a collection like `Map` is surely going to get weird unexpected results.  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 So https://github.com/facebook/immutable-js/pull/878 refactored the flow types and also added tests for them. Would you mind updating this PR to merge those changes in, and also add a test that catches this? Thanks! Hi there. I am starting handling backlog. I know it is been a while since you've submitted PR, sorry for such delay. The are some conflicts. Could you, please,  rebase? ðŸ˜…   Thanks for sending in this pull request! It looks like someone independently made this change, so this PR is unneeded and I am going to close it. But thanks for pointing this out!  It's there!
  I can't reproduce this in my Firefox browser - can you share more details about OS/Browser versions?
 Closing this aging issue - feel free to reopen if still having troubles  Thanks
  What's different about `filter` and `flatten` that need to be defined differently from say, `map`, which is defined directly on `Iterable`?
 Not sure it's the right thing to have filter drop the type parameter though.

Based on flow's treatment of Array#filter: https://github.com/facebook/flow/blob/master/lib/core.js#L185 - we should probably match it.
 Right - but at least we could be consistent with flow's existing behavior rather than divergent.

I'd argue that both behaviors are non-ideal, but it usually makes me nervous to drop type information if it's not strictly necessary, that can result in false-negatives.

Example:

``` js
const arr = [1, 'foo', 2, 'bar', 3, 'batz'];
const numberArr = arr.filter(x => typeof x === 'number');
numberArr[0].toLowerCase(); // Wait, where's my error?!
```
 It's reasonably common practice in flow where filter is used to filter out _types_ rather than _values_ to take type coercion into your own hands to make it clear what you're doing:

``` js
const arr = [1, 'foo', 2, 'bar', 3, 'batz'];
const numberArr: Array<number> = arr.filter(x => typeof x === 'number'); // Error
const numberArr: Array<number> = (arr.filter(x => typeof x === 'number'): any); // No Error
```
 Thanks again for your help improving these
  This looks good to me but Travis is failing for some apparently-flawed reason. Let me try rerunning Travis and if that's good then let's accept this. @lacker, is this PR good to be merged? Most excellent.  Ah, yikes! thanks for the report, I'll look into a fix.
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 This is looking awesome, thanks for your help! I agree with this approach: set up a test infra and then let's do one test migration per PR to keep things easy to follow. 

I'm not sure what's up with the failing tests. I can help investigate tomorrow 
 Closing in favor of #1018   cc @bestander This should probably also fix https://circleci.com/gh/facebook/react-native/5344
  Excellent work, thanks!
  Unfortunately I don't think this is possible, as what you're asking for is syntactic rather than library code.

A default value must _always_ exist, because you can always do `myRecord.myField` and it must return _something_, even if that something is undefined. For example, this is totally fine:

``` js
var MyRecordType = Record({
  myField1: undefined,
  myField2: undefined
})
```
 We have a slightly nicer syntax coming in a future version that lets you provide coercion functions rather than just default values:

https://github.com/facebook/immutable-js/commit/44b20e4168613a7d28920495115a741b20fef2b4
  Thanks
  Good idea
  This warning has been removed in the most recent version
 If you update to the latest version of `immutable` on npm, then you should no longer see this warning.
 Hopefully react-native can update soon, perhaps you can open an issue there with this report. If you're calling `.length` on an Immutable collection that react-native is giving you, then ensuring that you're replaced that with `.size()` will also hide the warning.
  Fixed!
  Thank you!
  Fixed!
  Great answer @thomastuts 

In the future, ask questions on http://stackoverflow.com/questions/tagged/immutable.js?sort=votes
  Thanks for answering!

In the future, answer on http://stackoverflow.com/questions/tagged/immutable.js?sort=votes
  I'm a bit confused as to what you're asking for. Wouldn't a clone method just be an identity function? How would this relate to equality checking? Can you reference the removed clone method you are referring to?

```
Map.prototype.clone = function() {
  return this;
}
```
 I'm too concerned that this method would offer more confusion and anti-pattern than well meaning usage. If you would like to create a sense of change for a collection which has not changed, I recommend wrapping in a simple object or Record.  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 You're correct.
  Thanks for answering!

In the future, answer on http://stackoverflow.com/questions/tagged/immutable.js?sort=votes
  A `Repeat` is an object. So this is false for the same reason that this will log `false`.

``` js
console.log({ k: "v" } === { k: "v" })
```

However you can write `zeroArray(10).equals(zeroArray(10))` or `Immutable.is(zeroArray(10), zeroArray(10))` to get `true` by using _value equality_.

In the future, ask on http://stackoverflow.com/questions/tagged/immutable.js?sort=votes!
  Fixed!
  Nice simple implementation, thanks!
  In React, `this.state` is _always_ an Object. It's not safe to assign to `this.state` directly.

Instead try something like `this.state = { store: TabStore.getStore() }`

In the future, ask on http://stackoverflow.com/questions/tagged/immutable.js?sort=votes!
  Thanks for answering!
  This sounds like a great opportunity for a companion library for someone to build! However it probably doesn't belong in this core library.
  @xixixao  is correct here - by _removing_ what you didn't explicitly provide, what you've done is really just created a new value altogether.

Since the impl is quite small, Michal summed it up well, I'd recommend inlining it for your use.
  Fixed!
  Could you provide more information? What did you expect? By looking at your example, all output appears correct.
 groupBy uses equality checking to determine groups. Unfortunately JS arrays and objects are mutable collections that use reference equality.

A good way to remember this is:

```js
[] !== [] // true
{} !== {} // true
```

That means returning arrays or objects from groupBy will create a new group for every return value.

This is tricky to coerce since JS primitives are often used as opaque identifiers in many apps.  Unfortunately many rely on this behavior today, so we cannot remove it.

In a future version we can consider requiring a shared symbol instead.
  Can you share the explicit piece which is performing the `toJSON` and comparison? It appears that one side of the comparison is peering into the implementation-details of a `Map` instance, while the other is a JS Object.
 Closing this aging issue - I hope you were able to solve this. If not, please feel free to open a new issue with a minimal failing test case.  It is a custom built solution. The code for which is all found in https://github.com/facebook/immutable-js/tree/master/pages
 Yep, the docs aren't perfect and what they could really use are example uses
 The docs are autogenerated from the typescript definitions file in /type-definitions, the doc block above each message turns into the description. It's just commented markdown, so it should be easy to embed example use cases right there
 A cookbook would also be cool! Perhaps that's worth its own section on the website (all assembled in this repo in /pages)
  Thanks for the report.
  Great, thank you for this!
  These are very different data-structures. I'm unlikely to build them anytime soon, but if someone is interested in contributing, the first step is to consult existing research in persistently immutable cache mechanisms to determine next steps.

Closing this issue though, as it's not something that's on the near-term roadmap.
 This should behave correctly, but may not be an efficient implementation.  LRUMaps which seek to be performant and persistent usually use some kind of structure that's easier to clean up like a btree or minheap
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 This is so dope. Thanks for your hard work!
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 This pull request looks helpful, but would you mind resolving the conflict? Sorry for leaving this for so long unanswered! I'd like to get this in though. Awesome!  Hmm, this test appears to be failing on Travis: https://travis-ci.org/facebook/immutable-js/builds/184427778 Oh, I see. I thought this test was just like an improvement to the test coverage. My bad  This library references the method prototypes of `Array`, `Map`, and `Set` from ES6 whenever possible, and only diverges when it must or when divergence is relevant to the library.

For example `Map.get` and `Map.set` work identically to ES6 Map.
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 awesome. thanks so much for your help
  This landed in master branch yesterday. A new release is coming soon which will include this change.  It is 8 entries. This is a performance optimization where the each of these implementations have different performance characteristics for getting and setting, and ~8 entries is where BitmapIndexedNode begins to outperform ArrayMapNode.
  Fixed!
  Good find.
  This is intended behavior. `flatMap` expects to get back an iterable per item (like an Array or Immutable.List). It is intentionally more strict than `list.map(fn).flatten(true)`
  Actually this looks great. Thanks for this and also for including the tests!
  Hi there. I am starting handling backlog. I know it is been a while since you've submitted PR, sorry for such delay. The are some conflicts. Could you, please, rebase? ðŸ˜…  I'd prefer to see an approach that didn't require the nested concatenation loop of the key-path. That's liable to make mergeDeep much slower for everyone regardless of if they rely on this value.  #seemslegit

thanks!
  Could you provide some common uses of Multimap and some of the methods you would expect on it?
 Closing this aging issue  Yeah, currently you're doing it the best way. `merge*With` takes a custom merger which will let you do smarter things when it encounters something that is `List.isList()`
 That's correct. The merger function is only called when both previous and next both exist. The default implementation is (prev, next) => next
  You should check out https://github.com/ReactiveX/RxJS
  This is definitely something that would be nice to have one day. #88 tracks.
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 This file is automatically generated by our website's build script, it pulls directly from our README.md, so unfortunately if I were to merge this, it would be quickly overwritten (in fact, this file should probably be in the .gitignore)
 Seems like what was actually going on was that the readme.json file _wasnt_ being autogenerated anymore :(. I got that all fixed up in aca20705ee96bb00b038b24a531d9f92014ffdf2 which happened to solve this issue. Thanks also for bringing this to my attention, I added these auto-gen files to the .gitignore while I was at it.
  Hopefully this has been fixed by the recent improvements to typescript and the definitions file. Feel free to report again if this is still an issue.
  Thanks Thomas!

This is a great start.
  Thanks for your investigation. Agreed being stuck on old node sucked.
  Thanks for answering!

In the future, ask questions on https://stackoverflow.com/questions/tagged/immutable.js?sort=votes for searchability.
  Thanks for answering!

In the future, ask this kind of question on stack overflow where answers can be easily searched. https://stackoverflow.com/questions/tagged/immutable.js?sort=votes
  Unfortunately this is a limitation of Record. Any instance variables like this need to be defined on the Record itself, for example:

```
class ABRecord extends Record({a:1,b:2, networkstatus:null}) {}
```

Calling a function to compute those values is not safe since new Records are "constructed" again every time `set()` is called to preserve immutability.  I'm not seeing the same results:

```
> a = {test: 1}
{ test: 1 }
> b = {test: 1}
{ test: 1 }
> set = Immutable.Set([a])
Set { [object Object] }
> set.has(b)
false
>
```

Immutable uses something very similar to the `SameValueZero` comparison, however if both sides of the comparison are Immutable collections like `Map` or `List` then they use _Value Equality_ rather than _Object Equality_ which is a concept that ES6 does not contain.
  Closing this issue

I second the recommendation for [transit-js](https://github.com/cognitect/transit-js) for serialization of custom data structures.  Closing this aging issue, if still relevant feel free to reopen  I think this is best as a "recipe" as a written reduce function.

However if you find a non-trivial but very performant way to implement this, consider contributing it as a PR!
  Fixed
  Unfortunately this operation is not supported.

You could accomplish this with `mapEntries` though.
  Closing this aging issue - I hope you were able to figure out the issue with your app.

When testing your example code, I seem to get what you expected:

```
> var recommendations = Immutable.fromJS([{ searchLocations: ['brooklyn', 'manhattan', 'new jersey']}, {}, {}])
undefined
> var rec = recommendations.get(0).toJS()
undefined
> rec.searchLocations.join(', ')
'brooklyn, manhattan, new jersey'
>
```  Native behavior is to throw an error, which is at least more descriptive.

``` js
> [].reduce((left, right)=>left.concat(right));
TypeError: Reduce of empty array with no initial value
    at Array.reduce (native)
    at repl:1:4
    at REPLServer.defaultEval (repl.js:260:27)
    at bound (domain.js:287:14)
    at REPLServer.runBound [as eval] (domain.js:300:12)
    at REPLServer.<anonymous> (repl.js:429:12)
    at emitOne (events.js:95:20)
    at REPLServer.emit (events.js:182:7)
    at REPLServer.Interface._onLine (readline.js:211:10)
    at REPLServer.Interface._line (readline.js:550:8)
```
  Thank you!
  merge only converts structures to immutable if you pass a plain object. For now, try:

``` js
record.merge(Map({
  a: foo,
  b: foo
}))
```
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 Great, thanks!
  Released
  Do you have any profiling that helps understand the performance implication of a change like this?

It seems like we also have the choice of saying just not to convert to plain ol JS objects if your map keys contain strings that overlap with JS object special keys.

This ultimately boils down to a tradeoff, so we need some information to make a choice
 It seems like this pull request has been abandoned so I am going to close it. Please feel free to reopen if you'd like to continue working on this!  Best to ask this type of question on Stack Overflow where there is more traffic. https://stackoverflow.com/questions/tagged/immutable.js?sort=votes

The answer likely includes `mergeDeepWith` which allows for a custom merge function.
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 Great, thank you
  Great catch, thanks
  This is unfortunately not something we're going to do, as the performance of `get` and `getIn` are critical, and doing type sniffing on the input would be a serious performance loss.

I recommend writing a function like:

``` js
function p(path) {
  return path.split('.');
}

so you can write: `getIn(p('a.b.c'))`
```
  Thanks!
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 This seems pretty reasonable to me. Would you mind adding some tests and also adding the Flow types in addition to the typescript ones? Actually - chatting with @leebyron it sounds like the ideal outcome would be to move Cursor out of this library entirely. So perhaps a better plan would be to stop trying to add functionality there and first move it out. So, I am going to close this pull request, but if you are interested in maintaining Cursor separately from the core immutable library then I am interested to chat!  Merging into #1039   fixed
  The second will not do anything, because you're iterating over the temporarily mutable list rather than the immutable seed list:

``` js
const newList = List().withMutations(mutList => {
  list.reduce((newList, val) => {
      /*do stuff*/
      return newList.push(val);
    }, mutList))
```
  Most excellent
  Immutable.js's tools are behind the times and it is limiting progress on some of the top line goals.

This is a master task that details all the steps required to modernize the repository.
- [x] move the source for gh-pages into master branch (#741)
- [x] automatically deploy gh-pages when master pages src changes (a71d9b60f0944535c2b05c1dafb926833132473d)
- [x] use latest jest for tests
- [x] use eslint for linting (#1101)
- [x] improve strictness of lint rules (#1101)
- [x] run tests against latest versions of node (a91b5e7)
- [x] update to the latest version of typescript (#745)
- [x] use buble for ES6 -> ES3 compilation (#1102)
- [ ] remove usage of gulp in favor of npm scripts? (1b4166952995a7ceb898c254dfdc3b219210b597)
- [x] remove usage of grunt in favor of npm scripts (1b4166952995a7ceb898c254dfdc3b219210b597) (#1102)
- [x] include flow type definition file
- [ ] no longer check in distributed files (breaking change)
- [ ] move contrib to separate repository (breaking change)
- [x] setup yarn (#1100)
- [x] setup prettier (#1101)
- <s>move documentation generator source of truth to flow type + babel.</s> - Note, updated to latest TypeScript instead.
 Using `new` with collections is actually an anti pattern. They're designed to be used like the JS scalar types (Number, String) as just a callable function. 

That does mean the class syntax either needs to only ever be consumed by an off-spec transformer or it needs to be converted to use MapPrototype.method = function(){} or rely on Object.create's extra properties param or something like that I think it's safe to call this task done. There's always more modernization to be done, but this hits the major objectives.

Thanks so much for your help, @umidbekkarimov!  I would be happy to consider a PR for including `findKey` to Indexed collections.

I disagree that the other indexed methods like `indexOf` make sense on Keyed collections though. It's common that a Keyed collection is not keyed by an integer and then these methods make less sense. Even if a Keyed collection is keyed by an integer, it's not necessarily the case that the integer keys will be iterated over in incrementing order as they are in indexed collections, which at the very least would require different implementations, and at worst could cause unintuitive results.
 I think you're right. Thanks for the discussion and sorry for the delay. Check out the commit for details.
  Closing this since there is an answer with clear code, but please reopen with more details of the issue at hand if your code is different and you've encountered a bug.
  toArray will not alter the items in the list, in this case more Immutable List, since this is a 2D List. Use toJS() to deeply convert Lists to Arrays. Otherwise what you are seeing is fully expected
  Unfortunately `Promise.all` is fairly limiting in this way.

You might notice that using ES6's `Map` with `Promise.all` has the same issue.

Since you want to Promise.all the values of the Map, I would suggest:

`await Promise.all(promises.values())`
  Hello, 

I'm currently using `Immutable` for a project thats under development. I'm pretty new when it comes to immutable. I'm attempting to update multiple values within a `Map` and I know some of the issues that are causing the errors I'm just not sure how to resolve them.

``` js
//Initial attempt
export function handleUpdateSneaker (state, sneaker, sneakerDif) {
  var userSneakers = state.getIn(['dashboard', 'userSneakers']);
  var index = userSneakers.indexOf(sneaker);
  return state.updateIn(['dashboard', 'userSneakers'], sItem => {
    sItem.sneakerName = sneakerDif.sneakerName;
    sItem.shoeSize = sneakerDif.shoeSize;
    sItem.price = sneakerDif.price;
    sItem.trade = sneakerDif.trade;
    sItem.isbm = sneakerDif.isbm;
    sItem.info = sneakerDif.info;
    sItem.brand = sneakerDif.brand;
    sItem.quality = sneakerDif.quality;
    sItem.reRelease = sneakerDif.reRelease;
    sItem.colors = sneakerDif.colors;
  });
}

//Trying to solve the 2 problems stated below
export function handleUpdateSneaker (state, sneaker, sneakerDif) {
  var userSneakers = state.getIn(['dashboard', 'userSneakers']);
  var index = userSneakers.indexOf(sneaker);
  return state.updateIn(['dashboard', 'userSneakers', index], sItem => {
    sItem.set('sneakerName', sneakerDif.get('sneakerName', sneakerName));
    sItem.set('shoeSize', sneakerDif.get('shoeSize', shoeSize));
    sItem.set('price', sneakerDif.get('price', price));
    sItem.set('trade', sneakerDif.get('trade', trade));
    sItem.set('isbm', sneakerDif.get('isbm', isbm));
    sItem.set('info', sneakerDif.get('info', info));
    sItem.set('brand', sneakerDif.get('brand', brand));
    sItem.set('quality', sneakerDif.get('quality', quality));
    sItem.set('reRelease', sneakerDif.get('reRelease', reRelease));
    sItem.set('colors', sneakerDif.get('colors', colors));
  });
}
```

In the code snippet above Im using `getIn()` to reach within the `dashboard Map() -> userSneakers List()` and to find the correct `Map` within the `userSneakers List()` I am using `indexOf()` to return the index of the correct item to update its fields. 
Now the **Problems** that I can identify are:
1. You cant use `.`(dot) notation when trying to use access the values within an _Immutable_ `Map`.
2. When I use `updateIn` I'm reaching within  `dashboard Map() -> userSneakers List()` but not specifying the correct object that I got from `indexOf` to modify.

Im not sure how to fix those 2 problems and would appreciate if someone could explain to me how to fix it because I can imagine that I will encounter similar problems throughout the duration of the project.

Any and All help is appreciated ðŸ™‚
 @tgriesser thank you for the feedback, I didn't think about using `reduce`. I'll test it out now and let you know how it goes!
 @tgriesser My unit-tests checked out! Thank you so much, going to use this as a blueprint for how I go about making multiple changes through out the App!
 @tgriesser , After looking at your code for a bit and trying to understand it, Im not completely sure whats going on. Would you mind explaining whats going on there?
  I think @bvaughn summed it up well. Though this isn't really a performance concern, it's more of a correctness concern. Making a `List` of React components is a great example:

`Immutable.fromJS([ <div />, <span /> ])` could coerce those React components into Maps. `Immutable.List([ <div />, <span /> ])` won't touch the elements.

Obviously there are plenty of examples where this could bite you, React components was just one brought up here. Anything that's intended to remain a JS object shouldn't be forcibly converted. Also `fromJS` only ever builds `List` and `Map`, but of course there are plenty of other data structures you might want to use, which is best represented by using them directly.

This isn't unique to Immutable.js but also is how data structure constructors work in JavaScript:

`Set([ ['A'], ['B'] ])` does not result in a Set of Sets, it results in a Set of Arrays.

Basically the rule of thumb with both Immutable.js and with built-in data structures in JavaScript is that if you use `{}` you're definitely building a JS Object, and if you use `[]` you're building an Array. You need to explicitly use constructor functions to get any other kind of data structure.
  Agreed, thanks!
  This is pretty cool, but I'm concerned about the type signature. Unfortunately this would only allow making Maps where the keys and values are of the same type.

Maybe it would be better to just explicitly type this as `Map<any, any>`?
 I'll look into the test. It seems to pass in newer versions of node which is suspect
  Awesome thanks! I just rebased and landed this
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 Thanks for your investigation into this!

We've done some pretty thorough investigation into this idea a couple times now, the most in depth by @tgriesser and found some pretty serious performance burden by this, regardless of whether you actually use the inheritance feature. Since performance is a primary feature, we ultimately decided not to support this. 

Also, philosophically we encourage a functional style or at least composition over inheritance anyhow.

Here's how your same example might work using a functional style:

``` js
function setFormValue(map, z) {
  return map.set("value", z);
}

function setSpecialValidatedFormValue(map, z) {
  return setFormValue(z).set("valid", z != "");
}
```

Here's how your same example might work using object composition:

``` js
class Form {
   constructor(initialValue = "") {
      this._map = Map({ value: initialValue });
   }
   _create(newMap) {
      if (newMap === this._map) { return this; }
      var newForm = new this.constructor();
      newForm._map = newMap;
      return newForm;
   }
   setValue(z) {
      return this._create(this._map.set("value", z));
   }
}

class SpecialValidatedForm extends Form {
   setValue(z) {
      return this._create(super.setValue(z)._map.set("valid", z != ""));
   }
}
```
  Check out the roadmap for Immutable.js here https://www.facebook.com/notes/lee-byron/immutablejs-2016-roadmap/10153447836068757

This is a strawman document, which means I'm interested in your feedback on these priorities and to understand if I may have missed something.

Feel free to use this issue as a place to leave comments!
  Thanks for the report!
  Unfortunately this would add a performance burden. Since `withMutations` is designed to be a critical path optimization, I'd prefer not to incur a performance cost  Actually this is kind of awesome, I'm not sure I would consider this problematic but an (accidental) usage of Immutable.js's value protocol by node Buffer.

I suppose this is a problem for Immutable.js as much as the following is a problem for Node:

``` js
var buf1 = new Buffer('hi');
var buf2 = new Buffer('hi');
buf1.x = 123;
buf1.equals(buf2); // true
```

I'm curious what your expectations here. Should we not treat buffers as values? Does this cause a real issue for you, or is this only a theoretical concern?
 Closing this aging issue  possible that the docs need to be redeployed or something
 Fixed
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 Closing since related changes have landed, but thanks for your advocation!
  Closing this since I commented on the DefinitelyTyped task, and that should be good to go.

Moving forward, I believe supporting type definitions distributed through NPM is the right long term solution both for this library and for the node/js community.
  You should check out https://github.com/Reactive-Extensions/RxJS - It provides methods for iterating over asynchronous streams.
 That's exactly correct, and the primary difference is synchronicity. If your DB is a single async operation that results in a collection then you can use a JS Promise to model the database call and then use Immutable Seq to model the results. If accessing each next item is itself an async process then a Seq cannot model this, and you need to use something like a Stream or Observable (rxjs)
  Thanks!
  This has to do with how different platforms and browsers implement `console.log` which unfortunately is not a standardized part of JavaScript.
  The next version of Immutable.js will strive to have an even smaller API surface area, as it's primary benefit is providing highly performant persistently immutable data structures, not a broad data API. Ramda presents an excellent API for functional programming within JS, but that is not the goal of this library.

Immutable.js's data structures are intended to be used as flexibly as possible with many libraries. Unfortunately JavaScript's Array exotic can make this pretty difficult, but ideally libraries like Ramda and Lodash could help determine a standard access pattern so that Ramda and Immutable can work very well together rather than be seen as a "vs".
  Thanks for this info! I didn't know this was possible. I will look into making typescript and flow types for npm packages a first class feature in the next major version
  Closing this issue - you can do this today with `.update()`

```
> function sum(collection) {
...   return collection.reduce((sum, x) => sum + x, 0)
... }
undefined
> Immutable.List([1, 2 ,3]).
... map(x => x + 1).
... filter(x => x % 2 === 0).
... update(sum)
6
>
```  Unfortunately JS object keys are always strings and this is not possible  Updated in master branch, release soon  This is an artifact from the type definitions being written before typescript supported ES6. The comment documents the intent while the actual type definition is the best effort typescript would support.

I'm happy to entertain pull requests which improve this!
 Fixed in master, will be released soon!  Thanks for the report!
  Fixed
  Adding the help wanted tag for any aspiring contributors, however my concern that would need to be fulfilled is that this API would need to avoid confusion around using binary search on an unsorted collection. I anticipate a lot of questions around why their binary search isn't working well I think this is a naming concern first, so maybe searchSorted() or something to imply that it can only be used on a sorted list. That plus documentation would help catch most (but probably not all) issues of searching unsorted lists

Though I'm also concerned about scope creep of the library. In general I think there is currently too much on the prototype of the collections already and would prefer utility functions published as an ecosystem of npm modules instead. More people have been requesting a smaller bundle size than have been requesting additional features on the prototype.

On top of the scope creep issue I think it could be confusing why there would be two methods "find()" and "search()" which are conceptually identical but differ in implementation.

I'm thinking that what might be best is if someone built and published a library like immutable-binary-search which simply implemented this feature and worked with immutable.js. I would be thrilled to feature such a companion library from the documentation  I don't think an implementation of binary search that leveraged implementation details of List would be measurably faster than one that used the public API. Just using `.get(index)` would be best.  Fixed!
  This convenience method is going to be removed in a future version of Immutable as it can be confusing and currently restricts the ability to do incremental builds of Immutable. e.g. instead of doing: `myThing.toMap()` you would write `Map(myThing)`. For this reason I think we would not want to consider expanding the API to perform more tasks.

This also means if you would like a mapping function to construct the Map, you could write: `Map(myThing.map(a => [b, c]))` which is hopefully less confusing (people often confuse the `map` function and the `Map` type)
 Yep, I agree with you. What we're looking at is a tradeoff between chainability and modularity. Currently the library optimizes for chainability, but that means modularity isn't possible. As there's simultaneous demand for adding new kinds of data structures while also reducing the size of the library, we're stuck until the modularity problem is solved, and unfortunately that means giving up some chainability.

Luckily, after surveying a large body of code that uses Immutable, conversion between different types is far from the most common of operations, so this should have relatively small impact on code quality and readability.
 > Does `Map(myThing.map(a => [b, c]))` work currently?

It does!

``` js
var list = Immutable.List([ 1, 2, 3 ]);
var map = Immutable.Map(list.map(v => [ v, v ]));
map.toString();
"Map { 1: 1, 2: 2, 3: 3 }"
```
 I'm sorry you feel that way @dubrowgn, my hope is to balance lots of different concerns for a best possible outcome. I understand that means tradeoffs in some places in order to accomplish other things. I certainly am not trying to actively move in a direction opposite from where issues are trying to highlight, on the contrary I'm trying to move in a direction that can satisfy as many as possible.

Here I'm just trying to highlight that it's good news that your proposed code:

``` js
data.toMap((item) => item.id, (item) => item.value);
```

Can be written today as:

``` js
Map(data.map(item => [ item.id, item.value ]));
```

And that is both compatible with where the library's API is going in the future, and I hope is also not too detrimental to code legibility.
 > I think there is something wrong with the map() function then. This is what I tried before:
> 
> var m = Immutable.Map({ "10":100, "20":200 }).map((v, k) => [parseInt(k), v]);
> m.toString();
> // "Map { "10": 10,100, "20": 20,200 }"

My assumption with the example code above was that you were converting from a `List` to a `Map`. If you already have a `Map`, then at least we're beyond the question of conversion.

The `.map()` function on a `Map` type maps over the values, maintaining keys. If you want to map over each _entry_ as a separate element, then you should check out `.mapEntries()` which let's you write:

``` js
var m = Immutable.Map({ "10":100, "20":200 }).mapEntries(([k, v]) => [parseInt(k), v]);
m.toString();
// "Map { 10: 100, 20: 200 }"
```
  Unfortunately this is beyond the current abilities of OrderedSet to do in a performant way.
  You should be able to use this to generate some version of the docs locally: https://github.com/sebastian-lenz/typedoc
  Sorry for missing this! Thanks so much for the fix.

I'll clear up the dts noise first and then get this in
 Hmm, I actually want to understand this a bit better.

There are cases where we use `is()` to determine value equality - when not knowing true equality would result in an incorrect state, and there are other cases where we use `===` to determine cheap equality, where we're optimizing what would otherwise be a correct but more expensive operation.

This is similar to `myMap.set()` where when setting a new value, it's always correct to return a new Map with the provided value set, and we use `===` as a very cheap optimization to return the same map.

The reason we don't use `is()` for the optimization opportunity is that it does a full walk of any data structures provided.

I think this case you're updating is an optimization opportunity rather than a result correctness.

However, I think it's safe to use the `is()` for the optimization specifically for `mergeDeep` because `mergeDeep` will always walk over iterables and only the scalar (or at least non-iterable) leafs will be compared and merged. 

I think we should find a way to apply this change only in the condition that you're using `mergeDeep`
  Unfortunately not currently supported, but will keep in mind for future versions.
  One recurring point of confusion with this library is that people confuse what operations are fast vs slow. I'm noticing that this is related to how verbose an API is - people seem to expect short terse API to be fast. That gives me pause for `without` - since it's a one-liner to implement yourself so there's low value in adding it to the library, and people may become confused between when to use `without` and when to use `delete`.  Fixed in master and will be released soon!  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 The documentation was actually already correct as written, but I agree it was not very clear about _why_ this is the case. I'll make a change which better describes why the key "x" is going to be ignored.
  Fixed in master, will be released soon  Fixed in master, will be released soon  I think this method of taking the difference is too inefficient - a user of this library could just do it themselves if you are removing things one by one in `withMutations`. So if this method were included in the library people would expect it to behave more optimally. This PR is also pretty old, so I am just going to close it. If you are interested in working on this more then please feel free to reopen!  Closing this aging issue

Unfortunately not without digging into the implementation details  A collection of functions may wish to use a function as it's notSetValue - As interesting as this is, I fear it would add more confusion than value in the long run.

In my opinion, a better version is:

```js
var items = Map<string, Item>(...);
var item = items.get(key);
if (!item) {
  item = new Item()
  items.set(key, item)
}
```  I believe it is designed on purpose since === will check if arr1 and arr2 are the same object (using reference equality) but map returns a new immutable object so arr1 !== arr2. If you used immutable.is then they would be equal since is uses value equality 
 Unfortunately the "return the same reference" optimization does exist for `map` yet, so while the result will have the same value equality, it won't have reference equality. 

Similar to how:

``` js
var array = [1, 2, 3];
array !== array.map(x => x);
```

I've opened an issue for this at https://github.com/facebook/immutable-js/issues/679 since this would be a nice optimization to have.
  You can just call `List()` for an empty list or `Map()` for an empty Map. These return memoized versions of the immutable empty collection, so `List() === List()`.

And as a bonus, it's less characters than `List.empty()`!
  Fixed!
  ``` js
Immutable.is( new Immutable.List([{}]), new Immutable.List([{}])) === false
```

Is correct for the same reason

``` js
Immutable.is( {}, {} ) === false
```

For the same reason

``` js
({} === {}) === false
```

Two object references are always considered not equal since they are designed to be mutable and allowed value equality checking between them can be dangerous and lead to bugs.

Immutable.js only treats the immutable collections as value equal, which is why comparing two immutable empty lists together is considered equal.

A variation of your original example but using `Map` instead of a JS object will result in value equality:

``` js
Immutable.is( 
  Immutable.List([ Immutable.Map() ]),
  Immutable.List([ Immutable.Map() ])
) === true
```
  Closing since the question has been answered
  Closing this aging issue - but noted. There are a few other issues recommending improvements to this usage case.
  Or have a section to that explains the syntax that is used in the documentation as I think it is type script type of notation. I think examples of each utility would be great to have.
 Please contribute documentation to this repository once you learn best examples! This project improves when the community can contribute work like this.
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 Thank you, Rich! Sorry for letting this sit. Rollup looks pretty awesome, I'll look into getting this to pass tests and merge
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 Given this issue https://github.com/facebook/immutable-js/issues/505 I don't think we want to emphasize this since it should not share exactly the same API as Map
 This is actually just an implementation detail, and one that's likely to change in the future. It's a "Map" in the sense that it exposes `get` and `set` methods, but the HOF methods like `filter` and `forEach` make no sense on a Record.
  Merging into #635  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 Thanks!
  They're equivalent. `getIn` is implemented in terms of `get` - it's just a nicer API.
  Specifically only for Records, yes it is an experimental feature  The records themselves do not know where they exist within a parent (or multiple parents!)
  Awesome, thank you for this!
  Closing this aging issue  Sorry for letting this issue go stale.

There are plenty of great libraries out there that help implement OT - I don't think this data structures library is the appropriate place to add another  https://www.youtube.com/watch?v=I7IdS-PbEgI
  Thanks for this investigation, please feel free to open a PR applying your fix and adding a test that documents the original issue!
 I believe this was the result of an older bug with slice that has since been fixed. A new release is coming very soon which will resolve this for everyone  Closing this aging issue which should have been fixed with the v3 release. Please re-open if you see it again.  Sorry for dropping this super aging issue - I hope you were able to build something awesome and your approach sounds great  Nice! Thanks for this
  This is great, thank you for doing this.
  See this issue: https://github.com/facebook/immutable-js/issues/505

`Record.map` should not be used.
 Merging into #505  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 :+1: to this, seems like a lot of issues are being filed from this
 Thanks
  Curious if this is this still necessary after #647?
 Hi there. I am starting handling backlog. I know it is been a while since you've submitted PR, sorry for such delay. The are some conflicts. Could you rebase or close the issue if it's obsolete? ðŸ˜…  Closing since nonambient definitions are becoming the standard and those will be included in the next release  There's a fairly large API, and at some point we need to draw a line between how many methods have `*In` variations. Generally we favor the methods that apply to many different types for most convenience.

Otherwise, any time a deep method, say `data.xxxIn(arg)` is needed, a worthy substitute is `data.updateIn(_ => _.xxx(arg))`  Unfortunately not since it's not possible to do within JavaScript. WeakMap requires knowledge of the garbage-collection state which isn't available outside of the VM itself.
 Not that I've been able to figure out. I'm happy to take suggestions on how to do this, but every approach I've considered would either be very inefficient (copy the whole structure on every mutation) or leak memory (use a DAG with WeakMap leafs, but no way to know when to clean up without access to GC)

â€”
Sent from Mailbox

On Sat, Oct 3, 2015 at 7:41 AM, Paul Jolly notifications@github.com
wrote:

> ## Not even using the new experimental [`WeakSet`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakSet) and [`WeakMap`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakMap) under the covers?
> 
> Reply to this email directly or view it on GitHub:
> https://github.com/facebook/immutable-js/issues/639#issuecomment-145253965
 Actually, I'm not sure a copy of a WeakMap is even possible as that would require interation which they do not support as that would leak GC state. So leaking memory would be the only path forward

â€”
Sent from Mailbox

On Sat, Oct 3, 2015 at 7:41 AM, Paul Jolly notifications@github.com
wrote:

> ## Not even using the new experimental [`WeakSet`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakSet) and [`WeakMap`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakMap) under the covers?
> 
> Reply to this email directly or view it on GitHub:
> https://github.com/facebook/immutable-js/issues/639#issuecomment-145253965
  I think it makes sense to mirror the behavior of Array#slice and floor the passed indexes
 Just tried reproducing this but was unable to, it seems like the library exhibits the proper behavior.
 It looks like the version on the immutable website is a bit outdated, but in fact this bug has been fixed in more recent versions of Immutable.js
  Thanks, but when patching this in, I'm getting failures when running `grunt` with this patch applied. 
 Just leave grunt-jest and typescript alone :+1: 
 Thanks, this just landed in rebased form!
 didn't see it, never mind.
  Closing out. `reduce` is the way to go!
  Thanks for the report! You're right that the alias is getting the wrong method in this case.
  Unfortunately not  Immutable collections are not really classes, even though some of the syntax tries to articulate them that way. Instead each Immutable collection type is both a factory function and an instance type. The difference from this and classes, is that there is no constructor function.

Extending a Record as a class is a fine shortcut for adding prototype methods, but the constructor itself will not be called consistently and is probably unsafe to use.
  Closing this aging issue  #928   Unfortunately this is not possible at the moment  Thanks! Sorry for letting this sit - did you verify that this fixes the issue for you? 
 I'd like to test this. Could you include a test or use case that fails before this patch and works after?
 Tests look good, just need to rebase and merge. Will get to that shortly.
  Closing this aging issue  Great, thank you
  Hey, so there are basically two ways to implement a "diff" type function. You can just do it with an iterable over the whole structure, or you can get into the structure itself. The first way is simpler, and it's what this PR does, but people can do it themselves already based on the existing API. The second way actually gives some performance improvement. So I don't think we should go this direction, I think we should either not include "diff" in the API at all, or have an optimally-efficient mechanism. Thanks for submitting this PR though, I really appreciate the effort here.  @leebyron @derekdreery 
 My original intention was to have the key based. It's an oversight in the implementation if it is not, I think that this kind of differencing only makes sense over keys and we should exclude values. If we really wanted to support difference over values I think that that behavior should be specified by the consumer using a separate flag or something.
  what makes you think that this is in fact not the case?

I added the following test case and it seems to be passing the tests locally:

``` javascript
  it('casts to set correctly', () => {
    var orderedSet = OrderedSet([1,2]);
    var set = Set([1,2]);
    expect(orderedSet.toSet()).toEqual(set);
    expect(orderedSet.toSet().equals(set)).toBe(true);
    expect(set.toOrderedSet().equals(orderedSet)).toBe(true);
    expect(orderedSet.toSeq().toSet().equals(set)).toBe(true);
  });
```
 thanks @kentor, looks like https://github.com/tgriesser/immutable-js/commit/23bc0f3905701701cf233fe4e9f0018cee311443 should have fixed this issue
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 thanks!
  `withMutations` is designed for performance-tuning code, so it's critical that it's fast. It would be inappropriate to have it attempt to perform deep operations which could be very costly. Yes I would call this mistaken usage. For example in the original example here is the issue:

 ```js
let m2 = m.withMutations((res) => {
    let y = res.get("y");
    y.set("b", 9);
  });
```

While the `m` collection is in a mutable mode, the collection at the `y` key being referenced is of course still immutable. If `m.withMutations` were to recursively walk the data structure to convert all referenced collections to mutable, it would be extremely costly (O(N) instead of O(1)), defeating the purpose of having `withMutations` as a performance tuning tool.

A correct code would be:

 ```js
let m2 = m.withMutations((res) => {
    let y = res.get("y");
    res.set("y", y.set("b", 9));
  });
```

Or more tersely:

 ```js
let m2 = m.withMutations((res) => {
  res.setIn(["y", "b"], 9);
});
```

If there are multiple updates happening to the collection at `y` which suggest needing `withMutations` performance tuning, then that can be done as well:

 ```js
let m2 = m.withMutations((res) => {
  res.update("y", y => y.withMutations(yMutable => {
    y.set("b", 9);
  })
});
```

Remember that `withMutations` still always creates a copy from the original, so using `withMutations` to apply a single change is overkill and will be slower than just doing the simpler update directly. In general I suggest using `withMutations` only when metrics draw you to a costly piece of code, since normal immutable updates are already quite fast (O(logN)). 

I understand that the original example was intentionally contrived, but any code that updates a single or few values like this is best done directly:

 ```js
let m2 = m.setIn(["y", "b"], 9);
```
  Closing this aging issue - sorry for not getting to your question  Adding things to the prototype is a slippery slope to a hard to follow API and growing library weight. Especially for simple functions, it's preferred to have an external function provide the functionality.
  Thanks for the reminder - I'll get these bug fixes out in a new version today
 v3.7.5 is now on NPM
  This is now fixed in v3.7.5
  Note that you can convert between the two explicitly by passing to the constructor:

```
var es6Set = new Set([1,2,3]);
var immSet = Immutable.Set(es6Set);
var es6Set2 = new Set(immSet);
```
  Immutable collections do not change, so there are no methods for subscribing to changes. When you call a method like "setIn", that method will return a _new_ collection with that change having been applied, and the original collection will not have changed at all. 

If you want to send updates to React components when you have new data to provide, you need to ensure you're doing that directly with the result of the updated data store. 

For example, in your Link click handler, you're not using the return value of "store.set('aa', 100)" which would be the updated version of "store".

It's very much encouraged to use a "flux" like pattern or helping library when using Immutable with React. Redux is a great one. This pattern helps manage data flow so when you perform an update, you're doing so at the top level so there only needs to be one mechanism for re-rendering your app. 
  Merge is another way of saying "union" and a union definitionally never deletes anything. Does `deleteIn` suffice? Perhaps you could provide some code example of what you wish you could write which doesn't work at present?
 Closing this aging issue  This would break the behavior of the second argument to `get`. It would also break Typescript and Flow integration which expect a function to have a single return type. This would cause `get` to return either a value, or an array of values. This could lead to ambiguity. Should `get("id", undefined)` return one value? A list of one? A list of two with a second value of undefined?

Unfortunately I think this would break too many things to be considered.
 Destructuring would be awesome, ideally without having to use get.

I'm looking for the right way to support:

``` js
let { id, name } = myMap;
let [ first, second ] = myList;
```
 Thanks Tim :)
 Also, I believe I'm mistaken and `let [ first, second ] = myList;` works today, as this uses iteration rather than property access.
  This is now fixed in v3.7.5
  Closing this aging issue.

Trying to shy away from `toMap` and family, I'd prefer not to complicate them further.  Thanks Kevin! I'll get this out today
  Could you add what you expected in this case? I can explain what is happening at present: "merge" is an operation you perform upon a collection, but the value found at [2,"c"] is undefined. Perhaps we could improve the behavior or at least the error message in this case, but I'm curious what you expected the outcome to be if not an error. 
 Ah, I understand. At present, the operation you're attempting is covered by `setIn` - e.g. you want to take a value and position it at a certain path. `mergeIn` expects to operate on something which can be merged - some kind of collection - which undefined cannot. The value you provided `"hello"` is also not a collection and not mergeable.
 So these two variants should behave as you expect:

mergeIn against something collection-like:

``` js
test.mergeIn([2], { c: 'hello' })
```

setIn when wanting to position a value regardless of mergeability

``` js
test.setIn([2, 'c'], 'hello')
```
  > Looks like you are importing the "wrong" package. You are including this package from jbiasi and not immutable from Facebook (confusing, I know).

That's unfortunate :(
  This works as of v3.7.5 now on NPM
  The second item in your List is a JavaScript object, not an Immutable collection. You might instead want to type:

``` js
var test = Immutable.List([1, Immutable.Map({'a':1})]);
```

At which point your tests will do what you expect.

You may also want to use `fromJS()` to deeply convert from the inner JS structure you've defined. It will always produce List from Array and Map from Object.
 Could you open a separate issue documenting this? It may be a bug
  Closed in 59028b5e8552339acbdaab0c3f6547bd131f8f54
  Fixed in master, will be released soon!  This is behaving correctly. `List.of()` is a convenience method for creating a List from a list of arguments:

``` js
List.of(1, 2, 3)
```

If you want to create a List from an array, just call the List constructor directly:

``` js
List([1, 2, 3])
```
 Any suggestions on how you would like the documentation to be more clear? The primary landing page there has a number of examples of using `List.of()` throughout, and there is also the complete documentation at https://facebook.github.io/immutable-js/docs/#/List/of
 Thanks for bringing this to my attention anyhow. I'll mark this as needing better documentation in the future.
  Nope, this should not be possible.
 `Immutable.is` is at worst O(N), where N is the number of values in the tree, as it would need to compare every value in a tree. However, in practice often it is able to take short-cuts.

One short-cut is object identity, as you point out. If two sub-trees have object equality, `Immutable.is` does not recurse down them.

Another short-cut is short-circuiting on first mismatch. As soon as `Immutable.is` encounters an inequality, the algorithm halts and returns.

So the only time you the runtime is truly O(N) is when you have two value equal collections which contain  no object-identity subcomponents.
  Thank you for writing this! I added it to fromJS as well in ecae145be82a137f1b7f2d2fad67ad90e9c65ee1

> (I wonder if this confusion is why the ES6 Map doesn't have this kind of constructor.)

It definitely is one of the primary reasons that it does not. I think it's also one of the reasons it's not often used :)
  The issue here is not in Immutable, but JS objects. JS object properties are _always_ strings.

``` js
var x = { 1: 2 }; // { "1" : 2 }
var keys = Object.keys(x); // [ "1" ]
```

When you access a property using square-bracket notation, that value first gets coerced into a string before looking it up in the JS Object.
 Map, on the other hand, does not coerce to string first. Maps (ES6 Maps and Immutable.js Maps) allow you to store any kind of value as keys, strings, numbers, other Objects.
 I would love to entertain PRs for that kind of change to the docs!
 That's mostly right. I should point out that "all keys will be converted to string, am I right?" is not quite right - specifically there is no conversion happening as JSON object keys are _always_ already strings.

For example:

``` js
// Examples of valid JSON
{ "foo" : "bar" }
{ "true" : true }
{ "123" : 456 }

// Examples of invalid JSON
{ foo : "bar" }
{ true : true }
{ 123 : 456 }
```
 Added 59028b5e8552339acbdaab0c3f6547bd131f8f54 to help clarify further
 No problem at all. Thanks for the good questions, that led to better README!
 It's totally fine to use integers as keys - in fact that is a very common practice. However if you wish for an integer key and a string which happens to include that integer to both access the same value, then yes, you need some normalization between them - this is the same behavior as ES6 Map and Set.
  Records are defined with an explicit set of allowed keys.

So when you write:

```
var Car = Immutable.Record({});
```

You're defining `Car` as a kind of Record that always has 0 keys.
  I would suggest:

``` js
var index = 0;
myOrderedMap.forEach(function (item) {
  // do what you need to do with item and index
  index += 1;
});
```

As this will reduce the need to build a new structure, as `toArray` would.

Also, you may re-evaluate your use case and prefer to use a `List` if your primary need is to iterate over in a specific order with incrementing indices akin to an Array. `OrderedMap` is designed to mirror the behavior of the native `Map` and in many ways is similar to the native `Object`. Both of these native collections are not indexed, however happen to iterate over their entries in the order in which they were inserted (insertion order). Immutable.js's unordered `Map` does not make this iteration ordering guarantee, but has considerably better performance at nearly all operations and lower memory usage, as maintaining insertion ordering is not free.
 >  I guess I'm still struggling with the different between OrderedMaps and Lists and when to use what.

Another way to think of this is:

Would I usually use an Array? 
Use an `Immutable.List`.

Would I usually use an Object or ES6 Map? 
Use an `Immutable.Map`

But I need to preserve that insertion-ordering iteration order quirk JavaScript Objects have! 
Use an `Immutable.OrderedMap`
 Depending on how long these lists actually are, you may be better off sticking with a `List` and using the `find` method if you need to lookup by `id`.

Another thing you may consider is keeping both a `List` and `Map` together in parallel. Use the `List` when you need to work with orderings, use `Map` as a lookup from `id` to value. This is roughly how `OrderedMap` works.
  Maybe @chenglou should write that up in a wiki page here, good stuff!

But generally I agree with the suggestion here to add more detail on runtime expense, at least with a time order and ideally a little more flavor on the typical vs worst case vs amortized. 

I would be happy to entertain PR on these!
 This task is definitely still high value for any contributors.

The source of truth for documentation are the comments in type-definitions/Immutable.d.ts  You should check out [Record](http://facebook.github.io/immutable-js/docs/#/Record) which can work well as a Class substitute.
  Yes, this works today!

``` js
import { List, Map } from 'immutable';
var map = Map();
map = map.set(List(['something', 1]), "pair");
console.log(map.get(List(['something', 1]))); // "pair"
```

The Map keys are looked up based on _value_. This means you cannot create a new array to set and get from a Map. This will not work the way you expect:

``` js
import { List, Map } from 'immutable';
var map = Map();
map = map.set(['something', 1], "pair");
console.log(map.get(['something', 1])); // undefined
```

For the same reason:

``` js
var a = ['something', 1];
var b = ['something', 1];
console.(a === b); // false
```

This is also exactly how ES6 maps work:

``` js
var map = new Map(); // ES6 map
map.set(['something', 1], "pair");
console.log(map.get(['something', 1])); // undefined
```

However this will work (in both Immutable Map and ES6 built-in Map), because it refers to the same value:

``` js
import { List, Map } from 'immutable';
var key = ['something', 1];
var map = Map();
map = map.set(key, "pair");
console.log(map.get(key)); // "pair"
```
  ![](https://media.giphy.com/media/1guRIRO0SdOsRBDfL2M/giphy.gif)

![](https://media.giphy.com/media/Z9LMuhfk8iRuU/giphy.gif)

![](https://media.giphy.com/media/krOVpoDFxXgc0/giphy.gif)

![](https://media.giphy.com/media/a3IWyhkEC0p32/giphy.gif)

![](https://media.giphy.com/media/OtbZhLpNLxDoc/giphy.gif)
  Thanks for the report. It seems symbols arent playing nicely with our hash fn
  This is now fixed in v3.5.7
  I apologize for this. Unbeknownst to me, the open-source bot had a well-intentioned change recently that resulted in this noisiness. I will make sure this feedback is carried on to the responsible team.
 Thanks for letting me know. I got them as well and the team responsible for the bot is trying to make it more helpful and less noisy. 
  Merging into #505 

The `map` family should not belong on Records at all - `map` is for homogenous collections with Record is not.  I think this is intuitive because the regular find-index code in javascript does exactly this. Also, it would be a pretty big breaking change, so it would have to be quite valuable before it was worthwhile. I think that means the conclusion here is "wontfix", so I am going to close this pull request. Thank you for submitting it though - I really appreciate the spirit and the effort here.  Absolutely!
  Closing this aging issue - sorry for not getting to your question

`includes()` does indeed use `Immutable.is` which implements value equality for immutable collections  Closing this aging issue - sorry for letting it sit. Excellent work, @hleumas! Please feel free to add the package to the wiki on this repo!  Thanks!
 For future reference, once you squash your commits, you can just run `git push -f` to update the same PR without having to make a new one.
  Both write docs about the various predicates, also add an immutable value detection predicate at the top level of the API.
  Thanks for the report!
  `rest()` returns a Seq, not a List, so you'll need to accept something more generic. I'd recommend:

``` js
printNiceList(listOfStrings: IndexedIterable<string>)
```
 Closing this aging issue - latest in master has excellent types which will be released soon  At present, no this is not possible. Doing so would be a pretty significant performance penalty on `fromJS()`. 

It's also not recommended to rely on object identity when inspecting Immutable value equality. You might want to use `Immutable.is()` to compare the two values.
 It looks like this question is answered so I am going to close the issue!  ImmutableJS in fact does not support class-based inheritance. The current source class syntax is really misleading and I apologize for that, it's not actually creating an ES6 class. I'm working on a set of changes that will allow us to move away from the non-standard class syntax.
  Merged in 825e29ef98012d210f817905994529be09c45de2, thanks!
  Merged, thank you!
  It definitely is related, thank you for the report!
  Thanks for the report! I'll make sure to keep track of this case in #536 
  Thanks for the report, @tphyahoo - you're correct that the documentation isn't correct here. I'd actually like to change the behavior in 4.0 to match the documentation as a simplicity force.
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
  Thanks for your exploration and explanation, but I'm still a little bit confused.

Why could you not just slightly change your example to:

``` js
var square = input => input * input;
var timesTwo = input => input * 2;

var c2 = c1.update(square);

var c2 = c1.update(square(timesTwo(c1));
var c2 = c1.update(compose(square, timesTwo));
```

This gives you shorter and more versatile definitions for "square" and "timesTwo" -> it operates on the value of the cursor rather than the cursor itself, then you can use the pre-existing "update" function to group operations.

Is there a more real-world use case that you're trying to use that leads to this being necessary?
 Hmm, I'm sorry but I'm still a bit confused - I don't see where "groupedUpdates" fits into your examples. 

Because of the nature of cursor updates, an "onclick" does need to know about cursors, since calling `cursor.update` and ignoring the result (all React event handlers) implies the top-level mutation and side-effects that we use cursors for. 

To me, the 2nd example you illustrate there looks like a cleaner implementation. The component on-click is explicit about calling the cursor's side-effecting `update` method while the library functions are more generic since they operate on values rather than operating on cursors.
 To give more isolated feedback, if I were doing a code review and came across code that looked like:

``` js
function clickAction (cursor) {
  return cursor.update(someSortOfInput => someSortOfOutput)
}
function logAction (cursor) {
  return cursor.update(someSortOfInput => someSortOfOutput)
}
```

With the intention of being reusable or compostable, then I would recommend isolating the `cursor.update` calls outside of these functions. It's the inner `someSortOfInput => someSortOfOutput` functions within `cursor.update` which are reusable and composable.
 Regardless, I think we may be able to solve this using `update` without you needing to change how your methods work today.

When calling `cursor.update(value => ...)`, `value` will be the unwrapped collection. At this point you can call whatever you want on it, including `update` without triggering a change event on the cursor's root.

``` js
let onClick = partial(this.props.data.update, clickAction);
let onLog = partial(this.props.data.update, logAction);
let onClickAndLog = partial(this.props.data.update, compose(clickAction, logAction));

function clickAction (cursor) {
  return cursor.update(someSortOfInput => someSortOfOutput)
}
function logAction (cursor) {
  return cursor.update(someSortOfInput => someSortOfOutput)
}
```

This will still work as expected, each event handler will only result in one change event, since the values passed to `clickAction` and `logAction` are actually not cursors but regular immutable collections in all three cases
 Thanks for sending in this pull request. This has been stalled for a while so I think it is time to just close this pull request. It might be that this feature is useful, but it seems like we would need a more concise case for it to make it core-library-worthy.  I highly recommend you open this issue in the React repo. `toSeq()` produces an iterable, and that iterable is iterated over by the React internals _at some point_. It's up to React to determine how to do that iteration in a way that guarantees any assumptions it makes about context.

I'm closing this here since it's unsolvable from Immutable.js's point of view, but please reference this issue when you open it on React.
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 Thanks! Could you finish your sentence? When is this useful?

Also, if you could please squash your commits then I can merge this!
  Thank you for the report!
 If the number provided to take is larger than the size, you'll get the whole collection (not a larger one).

This should either raise an error or default to an empty list (eg, undefined/null coerced to 0)
 Closing this issue now as the last release on npm solved the infinite recursion bug.

As far as the no-argument/undefined-argument behavior goes: since `take(N)` is shorthand for `slice(0, N)`, I think it's probably reasonable to expect number coercion to 0 and return an empty list as slice does. Throwing an error would be behavior differing from JavaScript, so I have concern that behavior would be surprising to many.

If you're looking for a method to return the last element, try `last()` - I think that's a clearer named method for the particular use case
  Hey, so right now we wish Cursor were actually separate from Immutable itself. We are considering kicking it out into its own repo or something like that. So if you're interested in maintaining it separately let me know! - otherwise I am going to close this pull request since Cursor-in-the-immutable-main-repo is something we would like to deprecate.  Hey @donabrams let's update this and get it working!

It looks like the transducer protocol suggests that it use symbols when available, should this do the same?

You can look at how Immutable implements the Iterator protocol for an example.
 Ok, we can omit Symbols for now and add them later. This is cool.

Could you please include some simple test cases? That will help ensure these never break in the future, but would also document the minimal use cases.
 This pull request seems like it has gotten stalled in "needs tests" state, and I theorize it is stuck there indefinitely, so I am going to close it. If someone is interested in working on this then I think it could definitely still be a useful area to work on though.  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 Ok, lets get that in there :)
  The keypath for Lists are just the index, so for the specific example, `[0, "phones", 2, "mobile"]` is the keypath to John's mobile number.

If you want to update a structure like this, a fixed keypath isn't going to work for you since there's no way to index on what you're looking to index on (name, and type of phone). Instead, you'll need to search through the List to find the index to update:

``` js
var indexOfJon = obj.findIndex(person => person.get('name') === 'john')
var indexOfMobile = obj.get(indexOfJohn).get('phones').findIndex(phone => phone.has('mobile'))
var updated = obj.setIn([indexOfJohn, "phones", indexOfMobile, "mobile"], "444");
```

Now: note that `findIndex` is an O(N) operation. It needs to potentially look at every item in the list to find the one that matches your criteria. If this is not a very common operation, or if this list is not ever particularly long, this is just fine. However if looking up people from this list by name is a common operation or the list of people is pretty long, you may find O(N) to have poor performance. If instead of a List you used a Map, access and updates would be O(1) instead of O(N) - much more resilient to larger lists.

Similarly with the list of phones, as your example illustrates a list of maps with a single key, you need to look through the list to figure out which to update, but then also remember to update at the correct key. This is probably pretty burdensome to deal with, and I would recommend a single map with many keys.

``` js
Map({
  john: Map({name: 'john', phones: Map({
     home: '111',
     office: '222',
     mobile: '333'
  }) }),
  ...
});
```

Note however the tradeoff here, that you can't have multiple people with the same name, or multiple phones of the same type when using this sort of structure.
 I think the first line of what I recommended:

``` js
var indexOfJon = obj.findIndex(person => person.get('name') === 'john')
```

Is precisely how you would implement your suggested `myMap.keyPathOf( john:Object )`.

The performance problem as I described it is not just going to be an issue with Immutable.js but with any collection, including the built in native Array. Searching through a list to find one matching instance will always be O(N) where having a lookup into a Map will be O(1). This is simply a tradeoff you need to make for yourself when architecting your client code.

If your REST API returns data that is not going to be efficient to operate on within the client, you can always manipulate it into a different shape first, and then use that later. But again, there are tradeoffs involved and every application will have different needs. Immutable.js is not here to be prescriptive about how you structure your data, but just give you tools to make those decisions for yourself.

> through reflection/introspection in ES6? or have it store the path info internally?

I'm not sure what you're referring to by reflection/introspection in this case. I'm also not quite sure what you mean by storing path info. I think a data structure that maintains a fast lookup of path for every unique object is going to require looking very different depending on each use case. What may be fast for one use case would be slow for others, and constraints may be different - if your data includes the same "john" in two places, it could have two key paths - each semantically different. 
  I think getting the type to work correctly is probably the next step in getting this right. I like this direction.

I'd also like to find a way to be able to require `immutable/Map` rather than `immutable/dist/Map` without causing too much turmoil in the build script and library developer experience.
 Thanks for starting to explore this!
 Thanks for the suggestion, @clintwood - I'll look into that.

@ryan953 - I'm not totally sure, but that's something we'll need to solve in order to make this really work for everyone.
 I think this pull request has essentially timed out. I am going to close it but if someone still actively wants to work on this then please feel free to reopen it!  This is a common request, so I'll try to figure out a way to assemble an API to do this. Perhaps `StrictMap` and `StrictList` or something like that.

Doing so comes with the direct tradeoff that immutable collection of pointers to mutable values would not be possible. Definitely not what we want for the only behavior as this sort of thing is pretty common, but I also understand the desire to enforce strictness and throw errors if trying to put a non-immutable value into an Immutable.js collection.
 Thanks, I'll keep considering ways to do this nicely. It's a careful line to walk between supporting generic collections and supporting deep values.
 Closing - see #473   I made the changes pointed out in the inline comments atop your rev, in case you want to inspect what changed.

Thanks again for investigating this!
 See https://github.com/facebook/immutable-js/commit/8031a8b8b6a74701f6c189ad62af41643b60f5e0 for final code
  I'd like to be not prescriptive about this and let individuals decide for themselves how they would like to name these if they use them in concert with the ES6 collections.

Using your example of ES6 destructuring, I would recommend:

``` js
var { Map: ImmMap, Set: ImmSet } = require('immutable');
```
 Using ES6 module syntax, the same can be accomplished with:

``` js
import { Map as ImmMap, Set as ImmSet } from 'immutable';
```
 Closing this, hoping the suggestions above are sufficient. Let me know if not.
  This is to be expected. We use `console.warn` to alert to misuse, and test cases often test that `length` is in fact reporting this error.

In a future version, this warning will be removed and code that relies on the behavior of using `length` will  break.
 Phantom.js emulates a browser which is why the warns show their way through.
  This has been fixed, and I've merged in your tests to ensure it
  Rather than exposing the internal structure of Immutable.js collections directly, we would probably want some method that is semantically the kind of operation you're proposing and bakes the performance improvements described into the implementation of such a method.

But I'm also not totally sure how what you're proposing would work or how you see it connecting to React.

Can you maybe type some slightly-imaginary future code that describes what you're trying to achieve from the React-side point of view, and maybe that would help me understand what Immutable.js would need to implement to fulfill it?
 Sorry for the delay. I think this is really interesting and obviously the performance benefits are really interesting, but access to the implementation details is pretty dangerous as those are likely to change in the future as Immutable.js encodes more optimizations.

One thing that we _should_ be able to leverage despite future changes is that Immutable collections are always structured as Trees. While exposing the structure of these trees are potentially fragile, perhaps there's some sort of memoizing map/fold we could support.

It seems like what you're finding is that when you have a very long list of components in React, a similar structural sharing approach with memoization is a powerful one. However It would be really interesting to see if a `List -> Tree` mapping transform could be useful to not just React but many other environments as well.
 Closing this aging issue.

See #38 for an example of how implementation details may change in the future, especially around operations like `slice` and `concat`  Thank you for the report
  Yeah I agree. Want to send a PR? :D  Go for it!
 I still think this one is a pretty cool idea - though I've been out of the loop on how often transducers are being used.  Closing this aging issue

It's not uncommon to create Records from a larger input data source.

For type safety concerns like this where a typo can cause a huge headache, I strongly recommend static type checking tools like Flow or TypeScript.  It looks like this issue has been fixed by the referenced PRs so I am going to close it.  Could you expand on what code you wish you could type which today does not yet exist? I think I understand the request, but am not entirely sure how you are hoping for it to be exposed.
 Closing this aging issue. I think this is just a fact of life in a JS environment unfortunately, at least until we get something like the [null-coalescing operator](https://en.wikipedia.org/wiki/Null_coalescing_operator) is added to the language.

For what it's worth, I use `.get('thing') || backupVal` pattern all the time myself.  I'm working on v4.0 which will include a major reworking of `Record` to no longer be `Iterable` nor have most of the collection API. For example, `map` in this case doesn't make a lot of sense.

Of course, the current behavior of returning undefined is pretty awful, but the new behavior will be that `map` is not even defined :)
  Sounds like this question is answered, so I am going to close the issue. Thanks!  `keys`, `values`, and `entries` return Iterators. They are stateful and can be consumed one time, every time you call `next()` on an iterator, there is no way to get to the previous item.

`keySeq`, `valueSeq` and `entrySeq` return Seq, which you can think of as an "Iterable". They are stateless and can be consumed multiple times. Seq is documented well elsewhere, but the primary value proposition is to use their laziness when composing multiple operations to improve performance.

For example:

``` js
var myMap = Map({ a: 1, b: 2, c: 3 });
var squareOddValuesList = List(myMap.valueSeq().filter(val => val % 2 === 1).map(val => val * val);
// List [ 2, 9 ]
```
 That's not quite right, an `Iterator` (`keys`, `values`) and `Iterable` (`keySeq`, `valueSeq`) present different APIs and capabilities.

`keys`, `values`, and `entries` return `Iterator` to match the behavior of the ES6 collections. The same methods on ES6 Map, Set and Array return `Iterator`s, and I wanted to ensure the Immutable.js collections could be used in the same way.

Seq present a full collection-like API rather than the more simplistic `next()` that an `Iterator` provides, but each has it's purpose. `Iterator` is an important part of many ES6-aware APIs that Immutable.js is designed to play nice with.
  Closing this aging issue. May come back to this in the future  Thanks for the suggestion! We're going to pass on this for now while we focus on fixing broken and embarassing things but if a number of people end up clamoring for this then we are open to reconsidering.  Can I ask for some examples of when this is useful in practice? It seems reasonable, but currying arguments like this can often present a performance issue, so I want to ensure I'm supporting the use case you have in mind.
 Thanks :)
 Thanks for the suggestion! We're going to pass on this for now while we focus on fixing broken and embarassing things but if a number of people end up clamoring for this then we are open to reconsidering.  Correct. This is a relic of an earlier version of the API which had deeper integration with a specific cursor implementation but should now be considered deprecated.
  This is unfortunately not backwards compatible because the second argument of `map()` is the context `this` which will be passed to the mapping function, mirroring the `map()` API found elsewhere in the built in JS collection - hence the need for `zipWith` to handle this case.
  Could you explain how you expect these static methods to act via example code? 

The same named static method on List or Stack accepts a variable list of arguments and builds a collection like `List.of(1, 2, 3)`, as a convenience to the slightly noisier `List([1, 2, 3])`.
 Just curious why you would prefer typing `Coll.of(...val)` instead of `Coll(val)`?
 We can do significantly more optimizations with `Coll(val)`, including structural sharing, which can't be done with `Coll.of(...val)` so I'm nervous about encouraging that sort of use.
 I'm actually leaning towards removing the `of` method in a future version. It was added for parity with [`Array.of`](https://gist.github.com/rwaldron/1074126#arrayof--variable-arity-) but notably `Array.of` serves a purpose that isn't particularly relevant for `List`.
 It looks like the conclusion here is to leave as is, so I am going to close this issue. Thanks for bringing this up and sparking some discussion!  Yeah, these should probably be replaced by using `concat`. Good suggestion.
  Ah, thank you for your investigation and straight-forward fix with comments. Excellent work!
  Thank you for this as well, I extended your approach to apply to Map as well. The same issue could have affected Map vs OrderedMap
  Can you explain a bit more about your complex object? If it's an object with a prototype, it can implement an `equals(otherObject)` function, which Set (and the rest of Immutable.js) will then use.
  Thank you!
  I would just iterate through all the stuff in a map and create a new list from that. If you're even still trying to fix this a year and a half later ;-) Anyway hope this worked out for you!  This is reasonable, I understand that it's something people want to use Cursors to do.
  Thank you for the report!
  Wow, that's huge data. 

Have you tried Transit.js? It can help with moving rich data from server to client. I would be curious if that is at all helpful. 

http://swannodette.github.io/2014/07/30/hijacking-json/ Explains how to set this up. 

I'm curious to know if that's helpful on the initial data construction
  Since this is a "stylistic suggestion" and super old I am going to close the issue. Thanks for bringing this up!  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Sorry for not spotting this sooner - this is great but the /dist/ files are auto-generated as output from /src/, so if landed as is, this work would be quickly replaced when the next PR is landed.

Could you ensure this change is applied to /src/ instead of /dist/?
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 Merged (and squashed) in 35658506c294121ad3990745cccbe0f1980b3504. Thanks!
  React's propTypes have a well defined API that allows for extension. Because `PropTypes.instanceof` does not play well with value types, It would be excellent to have a sister library of Immutable.js specific PropTypes.
 That specific example works, but not all examples work.
- A variation of `arrayOf(SomeType)` for `immutableListOf(SomeTime)` for example.
- Support for cursors.
- Support for the more basic interface types like `KeyedIterable`
 I am going to close this issue under the theory that if it did not happen in Year 1, it will not happen. Feel free to object if there is some alternate theory for how this issue may become one day useful :P  Hmm let me look more closely at this. Equality checking currently takes into consideration if both sides are ordered or not. If neither side has defined ordering, it just looks for the same values in the sets (or entries in the maps) - but if one has ordering and the other does not - they cannot be considered equivalent because the iteration ordering will be different between the two.

@tgriesser how does this reconcile with clojure's equality semantics?
 It looks like the bug here is probably the unstable return type in union() if one is empty: the return type should always be the left hand side. Though I thought we had fixed that.

As far as equality goes, I know there are many definitions for equality (and ultimately many equality functions in some languages). However the equals() and is() functionality here should be "A could replace B for any operation, and produce the same result" - in which case OrderedSet and Set cannot be equal since OrderedSet makes a guarantee about iteration order and Set does not. Two OrderedSets which contain the same values but with different orderings are not equal. If you agree that should be true then it should follow that an OrderedSet compared to a _____Set of the same values but with any possible (eg undefined) ordering cannot be safely called equal either. Interestingly, an OrderedSet should always be able to stand in for a Set for that definition of equality, however equality must follow the Transitive property. If A = B then B = A
 Another possible issue here is the type constructors like Set() or the conversion functions which are short hands for those like .toSet()

Right now I think if you provide an OrderedSet to those that it returns itself since an OrderedSet is a kind of Set. Perhaps that's bad behavior given that it makes the "downcasting" equality comparison difficult. isSet() should probably still return true though, what do you think?
 Closing this aging issue - the bugs involved have long since been fixed.

  Records should not have the map/filter/reduce and other API methods useful for homogeneous collections like List and Map. Their operation does not do what is expected.
#220 #268
 Note when tackling this, ensure `isImmutable()` still returns true for record instances  I believe the issue here is that your first example is mis-using the record API.

```
var one = new Immutable.Record();
```

This line of code will create a new _type_ of record `one`. `one` is a function that when called will produce record values.

In your second example, you're using the record API correctly (though just a minor note, `new` is not necessary when calling these functions, but harmless). In those cases `one` and `two` are record _values_. We can use value equality to compare them.

_Value_ is an important part of what is going on here. Lots of the objects Immutable.js creates are treated as values by the Immutable.js APIs. The most important difference is in how equality is determined. `one === two` will always return false here because `===` means object reference identity. However if you wrote `one.equals(two)` or `Immutable.is(one, two)`, then you should get `true` as they are equivalent _values_.

Immutable.List's `indexOf` API uses value equality rather than object identity to find the matching index in the collection, and since `one` and `two` are value-equivalent, the first one encountered by `indexOf` is returned, which is why you're getting `0`.

In the first example, `one` and `two` are not values, but function objects, and they are not value-equivalent, which is why given a list of those two functions, indexOf will not see the first as equivalent to what you're searching for.

Please let me know if that's unclear, or if there's anything else I could do to make this sort of behavior more evident either via the API itself or via the documentation.
 `indexOf` uses `Immutable.is` to determine if it's found a match. That uses an `equals` method on each item if it finds one, which means if `object` in your example is an Immutable.js value, that it will use value equality not reference equality.

If you want to use reference equality instead, you could certainly write a bit of code to do that using `findIndex` which will let you define your own function to decide what is "found"

``` js
var i = list.findIndex(item => item === object);
```
  To detect NaN you can just do `value !== value`, NaN is the only value which fails that test.

Infinite recursion is bad news, so it would be nice to invariant here, however what I'd love to see is a test that `_capacity` can never become NaN in the first place.
 Thanks again for this investigation which inspired #511, fixing #459 
  Merged in dd4d8a56e1aa27c049683a16839f3814faa631c8
  You can find the source documentation here: https://github.com/facebook/immutable-js/blob/master/type-definitions/Immutable.d.ts - it's all generated from that file. 
 The code that does the generation is in the gh-pages branch. https://github.com/facebook/immutable-js/tree/gh-pages?files=1
  The documentation represents the latest version of the library. `includes` was added in v3.7.1 in response to changes made in the ES6 spec around the same time. Please ensure you're using the latest version of the library.
  The collection constructor functions List and Map accept any kind of children, so in your second example you have a list of references to JavaScript objects. Since every JavaScript object is unique and not equal ({} !== {}) the two lists of JavaScript object will also not be equal. 

fromJS, on the other hand, converts it's input deeply - replacing JavaScript array with List and JavaScript object with Map at every level of the input. So in that first example you have a List of Map, both of which use value semantics and are equivalent. 

If you're ever not sure what the shape of your data looks like, try calling .toString() on it to see this illustrated in a pseudo-JSON form. 

To update your second case to pass, your collection construction should explicitly create a map:

List([Map({name: "Name: Tim Cook"})]);

Let me know if this doesn't answer your question. 
  Thanks!
  This is an interesting suggestion - such usage isn't currently supported. Right now, the input to the `Record` function should be a list of keys and their default values, so this is actually creating a record type where `getMoneyPrice` is a possible key, and the function 

```
   function () {
        console.log(this);
        if (this.moneyPrice) {
            return (`${this.moneyPrice}`).replace('.', ',');
        }
    }
```

is the default value for that key in the record. Because dot-access can be used to `get` keys from a Record, this sort of miraculously works despite not being directly supported.

I'm not entirely sure of what's going with get property, I've never actually tested doing that.

I'm working on a revamp of Record to simplify the API and improve it's flexibility for v4.0, and this sort of usage which currently sort of works will out-right fail in that version. I'll ensure there's a reasonable API for doing this though, tagging with enhancement.

With today's Record API, you could add these functions by altering the prototype of `Product` directly:

``` js
var Product = new Record({
    'id': 0,
    'name': null,
    'moneyPrice': null
});

Product.prototype.getMoneyPrice = function () {
    console.log(this);
    if (this.moneyPrice) {
        return (`${this.moneyPrice}`).replace('.', ',');
    }
},

Object.defineProperty(Property.prototype, 'needsPayment', {
    get() {
        console.log(this.moneyPrice);
        return (this.moneyPrice && this.moneyPrice > 0);
    }
});

var shoe = new Product({id: 1, name:'Super Sneaker', moneyPrice: 59.00})
shoe.getMoneyPrice();
shoe.needsPayment;
```
 What you've done there is perfectly supported as well.
 Hmm, this is pretty weird and maybe a bug. I'd recommend using different names for derived values for now, if only to avoid confusing behavior between get() and property access.
 Closing this aging issue - the best solution here is adding methods to the prototype of the Record, or using class extension.  What you're doing is about as good as you can do with the data structure as it's currently designed, but it's also a pretty expensive operation since you need to search through the list of children. 

If the "id" of the children are unique, then I would suggest modeling the children as a Map, or OrderedMap if the iteration order is important. Then you can use the much simpler and more performant setIn and updateIn methods. 
 `setIn` and methods like it (e.g. http://facebook.github.io/immutable-js/docs/#/Map/setIn) are best for applying updates in deeply nested locations.

The methods will always return a value of the same shape (nested maps and lists in the same form) and if nothing actually changed as a result of the method call, then it just returns itself, so you can use `===` to see if nothing changed.
 Lists share the same `*In` methods, so to do what you asked you would write:

```
var newData = data.setIn([1, 'children', 3, 'children', 1, 'children', 1, 'active'], true);
```

You should also see that if you were to have set a value where nothing has changed, that you will get back the same original value. So for example, if you were to set true again:

```
var sameData = newData.setIn([1, 'children', 3, 'children', 1, 'children', 1, 'active'], true);
sameData === newData // true
```
  Alexey, I don't fully understand the behavior you're looking for. Could you supply some various examples of arbitrary nesting and the expected output of this operation? I'm curious for more examples of data of type:

type NestedValue = Array<NestedValue> | String
 That should be Array< NestedValue >
 Sorry, I meant List<NestedValue>, not Array<NestedValue>. But also, it's not yet obvious to me from your examples, so please humor me with more input to understand the pattern.

Here are the examples you've provided so far:

``` js
[ [ 'a', 'b' ], [ [ 'c', 'd', 'f' ] ] ] => [ [ 'a', 'b' ], [ 'c', 'd', 'f' ] ]
[ [ [ 'a', 'b' ], [ [ 'c', 'd', 'f' ] ] ] ] => [ [ 'a', 'b' ], [ 'c', 'd', 'f' ] ]
```

I'm curious about:

``` js
[ [ 'a', [ 'b' ] ], 'c' ] => ?
[ [ [ 'a' ] ], 'b' ] => ?
[ [ [ 'a' ] ], 'b' ] => ?
[ 'a', [ [ 'b' ] ], 'c' ] => ?
[ 'a', [ 'b', [ 'c', [ 'd' ], 'e' ], 'f' ], 'g' ] => ?
```
 What is your predicate in this case?

We would likely need a different kind of method or utility function for this sort of operation, since the flatten function is "greedy" to maintain an optimal O(N) performance.
 I'm having trouble following the purpose and behavior of the `getMapPaths` function, but I think I better understand now what you're looking for from a flattening point of view.

Hopefully this code will help you out:

``` js
import { List, Iterable, fromJS } from 'immutable';

function flattenIf(pred, list) {
  function flattenIfReducer(_list, item) {
    if (Iterable.isIterable(item) && pred(item)) {
      return item.reduce(flattenIfReducer, _list);
    } else {
      return _list.push(item);
    }
  }
  return list.reduce(flattenIfReducer, List());
}

function isListOfLists(list) {
  return list.every(Iterable.isIterable);
}

var myDeepList = fromJS([ [ 'a', 'b' ], [ [ 'c', 'd', 'f' ] ] ]);
var customFlatten = flattenIf(isListOfList, myDeepList);
```
 I studied your `getMapPaths` function a bit and I think I understand what you're trying to do here, please correct me if I'm mistaken:

I believe you want to provide a Map of Maps, like 

``` js
{ a: { b: true, c: true }, d: true, e: { f: { g: true } } };
```

And then produce a list of all paths to leafs, like

``` js
[ [ "a", "b" ], [ "a", "c" ], [ "d" ], [ "e", "f", "g" ] ]
```

If this is the goal, then you should be able to write a recursive reducer for doing this without a need for flattening afterwards. You should also avoid going back and forth between native JS arrays and objects and Immutable collections by using `fromJS` and `toArray` within utility methods like this - those require full copies and will add up to be quite poor on performance and should not be necessary.

Here's a recursive reducer version of `getMapPaths` which expects Immutable collections as input and returns Immutable collections as output without producing deeply nested lists.

``` js
function getMapPaths(deepMap) {
  return _reducePath(List(), deepMap, List());
}

function _reducePath(paths, map, path) {
  return !Map.isMap(map) || map.isEmpty() ?
    paths.push(path) :
    map.reduce(
      function (paths, subMap, key) { 
        return _reducePath(paths, subMap, path.push(key)) 
      },
      paths
    );
}
```

Then to use it:

``` js
var deepMap = fromJS({ a: { b: true, c: true }, d: true, e: { f: { g: true } } });
var paths = getMapPaths(deepMap);
console.log(paths.toString());
// List [ List [ "a", "b" ], List [ "a", "c" ], List [ "d" ], List [ "e", "f", "g" ] ]
```
 Thanks, I'm closing this task out since we're in a better place :)
  Thanks for this feedback! I wanted to keep the example as simple as possible but understand why this was confusing. I made some modifications to make them buttons, https://github.com/facebook/immutable-js/wiki/Immutable-as-React-state
  You can do this if your object has a "hashCode()" method. It just needs to return an int. objects that implement hashCode also need to implement "equals(other)" and return true if the two are equivalent. Two equivalent MUST return the same hash code, but the same hashCode doesn't need to guarantee equality.Â 

This hasn't been formally documented yet, but I don't think it will change.Â 

â€”
Sent from Mailbox

On Mon, Jun 1, 2015 at 1:18 PM, Matthew Dapena-Tretter
notifications@github.com wrote:

> Are there any plans to allow objects to define their own hashing algorithms a la Python's [`__hash__`][1]? It seems like it would just require making `UID_HASH_KEY` public (though I can also see an argument for not wanting to introduce new equality semantics into JS).
> 
> ## [1]: https://docs.python.org/2/reference/datamodel.html#object.__hash__
> 
> Reply to this email directly or view it on GitHub:
> https://github.com/facebook/immutable-js/issues/490
  Do you have a suggestion for what the method name should be that would be familiar and idiomatic to mongo users?
 Closing this aging issue

However if someone would ever like to resurrect this, I think it would be cool to see a PR illustrating what this would take.  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 Very nice
  Thank you for the report!
 Thanks for your investigation!
 It looks like the second should probably also throw an error. getIn expects an Iterable collection of keys. Strings are Iterable but often not considered collections because that leads to confusion. 

Would you please open a separate issue for this other issue?
  remove() is not safe on OrderedMap, but is on Map within a withMutations block. Sort is not safe within withMutations block.Â 

â€”
Sent from Mailbox

On Sun, May 24, 2015 at 9:34 PM, umphy notifications@github.com wrote:

> Hi, I'm trying to perform `remove()` and `sort()` inside a `withMutations()`. Now the documentation says that only `set()` and `merge()` can be used with a mutable collection. However, [this post](https://github.com/facebook/immutable-js/issues/228) suggests that `remove` is safe to use with a mutable Map.
> 
> ## Can someone please let me know whether I can use `remove()` and `sort()` for an OrderedMap in `withMutations`? Thank you.
> 
> Reply to this email directly or view it on GitHub:
> https://github.com/facebook/immutable-js/issues/485
 remove() is perfectly safe on OrderedMap, just not within a withMutations block. Only set and merge are safe there. 
 And sorry, "safe" isn't really the right word here. It's of course perfectly safe to use that method - but just be clear as to the behavior. remove() never performs a mutation on a mutative collection (e.g. Within a withMutations block) it always returns a new collection. 
 `remove` is actually implemented as a `filter` for ordered map. Removing multiple times will be `O(MN)` where N is the size of the collection and M is the number of keys you remove. Writing a single `filter` will be `O(N)` which will be nice if you're moving a number of things.

The wiki has a nice feature on this exact operation, often called `omit` by other libraries: https://github.com/facebook/immutable-js/wiki/Predicates#pick--omit
  This is about the constant time speed difference I would expect. Native Array is full of performance optimizations and relies on mutability which will always beat immutable data in raw-perf numbers. On average Immutable.js operations are a constant time 5-15x slower than native operations, depending on the operation. In part due to their being implemented directly in JS rather than in the VM, but also because the operations themselves are more involved.

The performance wins (both time and memory) come from opportunities to use structural sharing between operations, which unfortunately `concat` currently does not provide.
 You're correct that `concat` is a good candidate for structural sharing, and in fact there is pretty great research on how to do this - #38 is tracking this enhancement that I'm excited to have in the future.

The stock `flatten` implementation does in fact use laziness and that's likely to win back a lot of performance for this scenario.

``` js
// Immutable.JS flatten
xs = Immutable.Range(0, 700).toList();
item = Immutable.Range(0, 50).toList();
bigList = xs.map(function (x) {return item});
t = +new Date();
bigList.flatten();
console.log(new Date() - t);

// Persistent non-lazy native Array flatten
xs = Array.apply(null, Array(700)).map(function (_, i) {return i;});
item = Array.apply(null, Array(50)).map(function (_, i) {return i;});
bigList = xs.map(function (x) { return item; });
t = +new Date();
bigList.reduce(function(x, v) { return x.concat(v) }, []);
console.log(new Date() - t);
```

On my machine, the non-lazy raw Array flatten (your original code) ran in 33ms, but Immutable.js's `flatten` method ran in 20ms due to utilizing laziness under the hood - it avoids building the intermediate data structures.

mori uses many of the same techniques as Immutable.js (in fact, Immutable.js was inspired by ClojureScript's data structures) and has a similar performance profile, but also has undergone a lot more performance tuning and so that constant time slow down relative to mutable native arrays is more like 4-8x for mori (depending on the operation). ClojureScript (and mori) also do not yet feature RRB trees for enabling structural sharing in the concat case as far as I know.
  You should check out [`merge`](http://facebook.github.io/immutable-js/docs/#/Map/merge). It has exactly the API you're after. `mergeDeep` will handle the nested values.
 It's also perfectly fine to use an object (mutable or immutable) as a key, so the `set` API accepting a JS object is a supported use case
  Immutable.js hopes to mirror Math.min/max behavior as far as ordering goes, though min/max for collections may be comparing things other than numbers, which is why the return values are not the same as Math.min/max - those methods always coerce to numeric values to compare where Collection min/max does no numeric coercion. 

It is intentional that NaN is poisonous as it's meant for error propagation. NaN is usually a surprising value and you don't want to mask over errors by default - but instead handle them explicitly when they're possible.
  In this case the list itself is not being mutated. The list contains the same references to JavaScript objects before and after the operation.

In this example the list elements are mutable JavaScript objects and your update operation is mutating the JavaScript object held at the index, however the object is still the same object. In this case we can say this list is not "deeply immutable". In many cases this is preferable, but I assume you are expecting to be operating on deeply immutable data. 

Immutable.List() is a shallow constructor. It accepts an array of anything and creates an Immutable List of those same things, and makes no assumptions about what those things are - mutable or immutable. 

If you want to deeply convert nested JavaScript arrays and objects to become a deeply immutable nested List and Map, you should use Immutable.fromJS(). 

Once deeply immutable, an update operation which alters an immutable item in the list will result in a new item with that update operation applied (editing the "b" key in your example), and the new list will have to refer to this new item in the same position, and so you will get a new list with the update applied as the result of the "update" method. 
 The issue in your example is the line `item.b = [{a: 456789}];`. There are two issues.

The first issue is that `item.b = ...` is a mutative operation on a JavaScript object, rather than part of the Immutable.js API. You should notice when inspecting newItems.get(index) that in fact the "b" item in the map has not changed, but that instead you've mutated the implementation of the data structure with a b property that isn't be used anywhere by Immutable.js. If you want to do a set operation you need to use the `set` method: `item.set('b', ...)`. After changing your code to use Immutable.js `set` method instead of the JavaScript mutative property setter, indeed `items !== newItems`.

``` js
var items = Immutable.fromJS([{a:1, b:[{c:1}]}, {a:2, b:[{c:2}]}]);

var index = 1;
var newItems = items.update(index, function (item) {
   return item.set('b', [{a: 456789}]);
});

console.log(items === newItems); // false
console.log('old: ' + items.get(index));
console.log('new: ' + newItems.get(index));
```

The second issue is that when setting to `"b"` in `item`, you're setting a JavaScript array of a JavaScript object, not an Immutable.js List with a single Immutable Map. While this might be fine in some circumstances, my guess is that is probably not what you intended considering that the previous value was an Immutable.js List and Map. The final console.logs in that prior block of code will emit:

```
old: Map { a: 2, b: List [ Map { c: 2 } ] } 
new: Map { a: 2, b: [object Object] }
```

So again you probably mean to be constructing Immutable.js collections there either by doing so explicitly: `List([ Map({ a: 456789 }) ])` or via conversion: `fromJS([{a: 456789}])`
 Another tip - when doing these kinds of deep edits, the `*In` collection of methods are really useful - in this case you could replace the `update` and `set` combo with `setIn`:

``` js
var items = Immutable.fromJS([{a:1, b:[{c:1}]}, {a:2, b:[{c:2}]}]);

var index = 1;
var newItems = items.setIn([index, 'b'], Immutable.fromJS([{a: 456789}]));

console.log(items === newItems); // false
console.log('old: ' + items.get(index));
console.log('new: ' + newItems.get(index));
```
 `mergeIn` is probably what you're after for that. There's also `mergeInDeep` which will apply deeper merges.
 @reduxdj AFAICT these functions are already documented. Which page on the docs do you think should be better? Also pull requests are welcome - if you tag me on a docs PR then I promise I will review it real soon :P  Thanks for the report!
  `splice()` operates similarly to `map()` and `filter()` - it cannot be used within a withMutations and also cannot be used to update a cursor.

The right way to insert within an array when using cursors is to refer to the referencing element:

``` js
// instead of 
parentCursor.get('mylist').splice(...);
// do:
parentCursor.update('mylist', list => list.splice(...));
```

That same pattern will work for other kinds of map/filter operations as well.
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 Most excellent
  This is intentional - only a select few methods can be used in `withMutations` for List those are `set`, `push`, `pop`, `unshift`, and `shift`.

I'm adding these to the documentation now.
  I'm a big fan of the Option structure, but I think it's beyond the scope of the purpose of this library.

I think https://www.npmjs.com/package/option is pretty simple and useful.

Having the prototype methods return these structures is bit more complicated, as @Laiff points out that would be a breaking change and it's also not very idiomatic. Most javascript programs (for better or worse) expect to operate with the null and undefined primitives as a sentinel for "none", and since Immutable.js strives to be idiomatic when possible - I don't think a change like this will be appropriate.
  Perhaps better to use `mapKeys` for this?
 Also - is this function trivial enough that it may be more appropriate to be defined when used?

``` js
function renameKeys(keyMap) {
  keyMap = Iterable(keyMap);
  return myMap.mapKeys(k => keyMap.get(k, k));
}
```
  Great point! I'll try to figure out a way to include these kinds of methods on OrderedSet and OrderedMap
 I don't think so... as it's not indexed, it just has a fixed and specified iteration order vs non-ordered `Map`'s unspecified iteration order.
 Closing this aging issue - note that you can always convert OrderedSet and OrderedMap to various kinds of Seq to access different kinds of lazy indexed APIs at O(N) cost.  Yeah, @Gozala and I have been discussing ways to add these sorts of constraints correctly. #407 has a lot of interesting discussion as we investigate.

Part of the difficulty in getting this right is that it's pretty common to actually want to refer to a plain JS object within an immutable collection. For example, when mapping over an Immutable collection to produce React elements, you're producing plain JS objects - and if some flag was set to disallow plain JS objects, then we couldn't use Immutable.js with React anymore. Or at least not nearly as clearly.

Part of what doesn't feel right here is purely syntactical. Typing `Map({key: "value"})` is just more verbose than typing `{key: "value"}` so I definitely understand the desire to type what is syntactically most simple.

I'm definitely open to more discussion on this front - and hear out any interesting ideas people have.
 Closing this aging issue.

For those looking for guarantees about deep immutability, I strongly suggest using Flow or Typescript so that you can provide static type checks making guarantees about what kinds of values are passed around your program. For our products at Facebook this has effectively solved this sort of issue for us. The added benefit is that this checking doesn't need to be done at Runtime which maintains a performant and slim deployed program  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 Hey, thanks for submitting this! I'm sorry for not getting back to you earlier. Since this is old, not a huge pull request, and has conflicts I am just going to close the pull request. It's also kind of a judgment call and keeping the `apply` is probably just OK.  Certainly nothing about the code you've posted here is incorrect. From your stack trace it looks like your application is treating the Immutable `List` as an array somewhere - see `arrayEach` and `baseMerge` which are not part of React or Immutable's codebases.
  Do you have a suggestion for what kind of data structure to use? As far as I was aware, most environments that rely on persistent immutable data structures use a Persistent Vector for both Lists and Queues. That's partially why I choose to only implement List - it has the shift/pop API you want for a Queue, and both operations are the ideal O(log<sub>32</sub> N).
 Perhaps worth implementing a variation http://blogs.msdn.com/b/ericlippert/archive/2008/02/12/immutability-in-c-part-eleven-a-working-double-ended-queue.aspx - when reading couldn't help but think of "middle out" jokes.
 Yeah that seems fine. I usually encourage people to just use List directly and use the `shift` and `pop` methods as `enqueue` and `dequeue`.

The issue with a double-linked-list is that such a structure can't be make immutable. Imagine what "enqueue" would need to do - after creating the new node and pointing to the previous tail, the previous tail would need to be mutated to point to the new tail. Since the nodes are immutable, we would need to clone that node with the edit pointing to the new tail. Then the next node which was pointing to it also needs to be edited and you end up cloning the entire list on every operation, making `enqueue` and `dequeue` both O(N), a sad result.

What that MSDN article describes is called a "finger tree" - which is very similar in structure to the "bitmap vector trie" that is used to implement List, but ensures access to the beginning and end is only one link away while access to the middle is log N links away - making `enqueue` and `dequeue` amortize to O(1) - pretty awesome. In practice, if your queues are smaller than say... 1000 items, a "finger tree" and a "bitmap vector trie" are going to have identical performance. But if your queues are in the 10000+ category and are highly volatile, then using such a structure could squeeze even more performance. That's why adding such a new structure isn't going to be high priority, but still very interesting.
  Immutable.js doesn't have a SortedSet data structure yet, but I'd love to have one in the future. 
 Merging into #88
  Hmm bummer - seems like perhaps an issue with using web fonts. Do you encounter this on any other websites with the same Browser/OS?
 Still broken?
  Can you let me know what browser version and OS version you're encountering this?
  #seemslegit
  Sweet
  I would suggest that rather than passing in a result of `map`, that you instead pass in the original list, and allow the component's render function to perform the `map` - that way you can rely on the equality of that original list.

Otherwise, what you're describing is a memoization function, which should be independent of what operation you're doing (map, sort, slice, anything). Such a memoization function is beyond the scope of Immutable.js, but certainly something that you build yourself with very little amount of code.
 The reason Immutable.js doesn't contain memoization like this is that it makes referential vs value equality even more observable than it already is, which is something we're trying to avoid. - It also can lead to memory leaks if the memoization cache doesn't clear over time - and that behavior is usually application specific rather than library specific.
 Also I should note that referential equality is a performance optimization to be used by value equality - which is the recommended way to compare equality of immutable collections.

The rule of thumb usually being:

Use value equality to determine if two immutable values are equal or not - for whatever purpose you need. If you're concerned that comparing value equality will be expensive for some reason, and you're only using equality to shortcut some work (e.g. memoization), then use referencial equality as that shortcut. It will guarantee you that you'll never get a false positive (unequal things claiming to be equal) but you will often get false negatives (equal things claiming to not be equal).
 > Not sure I follow. Are saying you'd like library consumers to just call .equals() without thinking too hard about whether referential equality is being used vs. a deep compare?

Correct. If you want to know equality, use `.equals()` or `is()`. If you're writing a memoization function and you're wanting to think about the tradeoff for false-negatives and re-running whatever you're memoizing, then you can use `===`.
 Basically, reference equality is just a performance optimization for `.equals()` - so I want to avoid any API changes or performance hits just to enable this performance optimization more often.
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thanks!
 Thanks @kemitchell!
  Can you please point to where you're seeing the trailing commas? I'm happy to correct this - I definitely want to preserve IE8 support.
 Thanks for the report - at least uglify strips them by default, so the minified source will be IE8 safe. I'll clean up the rest.
  Array's no, but Immutable List yes. It should work exactly as you've typed it.
  Thanks for the report!
 Fixed by #511 
  This is a great suggestion. Other libs call this "zipLongest" but I kinda like "zipAll"
 Nice work @mduvall! This is definitely a good start where undefined is the default value. Let me review your diff a bit closer, but at first glance it looks great
  Good idea!
  For your second example, if you `merge()` instead of `mergeDeep()` then you will get the result that you expected. `mergeDeep()` attempts to merge at every level it can, including within lists.

Merge never removes fields - you can think of merge as analogous to "union". If you want to remove fields, you should explicitly use `delete()`
  You want to convert the class B instance into an Immutable Map?

You could write a function to do this deeply like:

``` js
function fromJSGreedy(obj) {
  if (Array.isArray(obj)) {
    return Immutable.List(Immutable.IndexedSeq(obj).map(fromJSGreedy));
  }
  return Immutable.Map(Immutable.KeyedSeq(obj).map(fromJSGreedy));
}
```
 Beware of converting non-plain objects - any enumerable property will become a key in the map. In some cases on some browsers that can include keys from a prototype. Also some non-plain objects don't have any enumerable properties and will result in an empty Map.
  The problem with this approach is that it becomes very expensive. `isPlainObject` is called many times through Immutable.js and changing it from an O(1) to an O(N) operation to support an obscure use case is probably the wrong tradeoff.

I would strongly suggest using a custom version from `fromJS` which supports exactly the characteristics you're looking for if the version that comes with Immutable doesn't work for you.

If your data that's been created in a different realm is safe to convert (e.g. has no complex or exotic objects - every object can be safely replaced with Map), then you can use a very simple implementation of fromJS:

``` js
function fromJSGreedy(json) {
  return Array.isArray(json) ?
    Immutable.List(Immutable.IndexedSeq(json).map(fromJSGreedy)) :
    Immutable.Map(Immutable.KeyedSeq(json).map(fromJSGreedy));
}
```
 I think this pull request has timed out, so I am going to close it. I think it would be an improvement to have something `O(1)` here that just works a bit better so if you are interested in making that work then please feel free to reopen!  You can use the variants without "In" suffix in this way. 

For the example you gave, if you instead call props.get("items") it will return the value you expect. 
 Good idea, Tim!
  You can check if something is an Iterable immutable collection with Iterable.isIterable()
 It's on my plate to make a nicer API for this, but you can use Immutable.Iterable.isIterable() to see if an object is any of the Immutable.js collections. Otherwise each type has a Map.isMap() or List.isList() etc that you can use if you're checking just one kind of collection. 
 Yes, I agree. I added a task to track at #566 
  Yep! Thanks for the fix.
  You can use the `.map()` directly in React v0.13 or later (v0.13.1 is the last release, v0.14-beta is also out), v0.12 requires children to be an Array but v0.13+ can accept an Iterable. All Immutable.js collections are Iterables.

If you're stuck using v0.12 for some reason, just write `.map().toArray()` to convert to an Array.
  Yes, `splice` is supported and works very similar to Array.prototype.splice - http://facebook.github.io/immutable-js/docs/#/List/splice

For making edits deeper in a structure, `updateIn` is your friend - http://facebook.github.io/immutable-js/docs/#/Map/updateIn

You can of course combine the two. In fact all of the short-hands like `setIn` are just 1-line implementation functions which combine `set` with `updateIn`.

Here's what that might look like for you:

``` js
var updatedDeepData = 
  deepData.updateIn(['path', 'to', 'items'], list => list.splice(position, 0, itemToAdd));
```
  This is actually counter to the purpose of the converter function. If you omit it, a default converter is used which converts Arrays to Lists and Objects to Maps, however the converter function is there to allow for overriding this behavior.

For example, if I wanted Objects to produce OrderedMaps and Arrays to produce Sets, I could write a converter function to do so. However, after this change, my OrderedMaps would get converted back into Maps and my Sets back into Lists.

I'm curious if you think this functionality is presented in a flawed way - or if the documentation around it just didn't make these cases clear enough?
 I'm also curious for what purpose you're using the converter function? Your example shows just using an identity function - but presumably that's not particularly useful in practice?
 Sorry for the delay, I've been out for a while. I'll get back to this really soon! I'm excited to get this right
 This PR still has the primary concern of coercing the initial inputs into concrete structures first, which is at best a serious performance penalty but at worse an unexpected coercion.

If you could find a way to handle this such that intermediate concrete structures are not created, I think you would be onto something.
  Thank you for investigating this and for this solution! I had to make some changes, but the approach is the same and the test is very close to the one you wrote. 
  Can you illustrate the user-land code you wrote that resulted in the exception? I can start with that to turn into a test case.
 I started with:

``` js
var iterator = Immutable.List.of(1,2,3).slice(0, 0).values();
expect(iterator.next).to.deepEqual({ done: true, value: undefined });
```

And this currently passes and does not throw.
 Thanks for surfacing this area - a bug and repro was found
  Note that `map[1]` first coerces `1` to `"1"` and then does a look-up in the JS object, which is why this is a commonly misunderstood behavior of JavaScript.
  The best practices are to use `.get()` when you need a specific value, and make use of the `.filter()`, `.map()` and other higher-order functions to convert to react children.

I'll update that wiki page.
 Wiki page updated to match this info.
  Another way to phrase this is that it maintains the existing mutability of the plain JS object. This is by design. Immutable collections can contain any values including references to mutable objects. 
 A future major version of immutable will have a way to determine if a collection is "deeply immutable" and contains no references to mutable objects
  Very cool. I'll probably hold off on adding something like this into the library itself until the support is broader, as people are concerned about library byte weight, but this monkey patch is a pretty great way to start experimenting with this.

I imagine Record would want the same sort of support from Proxy.

I'm curious - what kind of performance constraints does Proxy have in the FF nightly? Does this code perform with some overhead compared to using .get() directly?
  Closing this aging issue

Cursor isn't under active development  Since there are only a small number of collections now, there's unlikely to be many bytes shaved. In some earlier experiments I found that doing something like this could save about 1.5KB from the 15KB total if you only used Map and never List or vice-versa, but if you used both it could add up to 4KB _more_ because of the overhead of babel/webpack vs the current inlined build.

This is something I want to keep on deck for a future v5.0 where I hope to simplify the API and factor some functionality into separate pieces.

Also, as new collections are added in the future - the value of this will improve.
 I'll leave it open for 5.0. There's a PR exploring this directly
 Unfortunately this is not yet possible - perhaps in a future version  Closing this aging issue

However It would be really exciting to see someone make this happen in a PR in the future  This conflicts with the work happening on the 4.0 branch (see: https://github.com/facebook/immutable-js/commit/5001072516a65b1245b528f88556ae4d1e4871fe).

But perhaps there's another way to solve your problem. Could you actually explain the problem you're solving? I understand what this code is doing, but I'm just not quite sure why you would want to do it.
 Ah, okay, I see what you're saying.

Perhaps a better way to do this is with a custom factory function:

``` js
var _MyRecord = Immutable.Record({
  reference: null,
  status: Status.AWESOME,
  availableSince: null
});

function MyRecord(initialValues) {
  if (!initialValues[availableSince]) {
    initialValues[availableSince] = moment().toISOString();
  }
  return _MyRecord(initialValues);
}

var one = MyRecord();
console.log(one.availableSince);
```
 If you're using the class syntax, this would be a constructor function which calls `super()`
  Not necessarily a typo, it just made an assumption that you had imported a local Seq variable from the immutable module. I agree this is more clear though. Thanks!
  Unfortunately any library which _requires_ mutation will not work well with immutable data.
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 Thanks for your exploration on this.

This concept has come up a few times before (#237, #310) and has some serious flaws that keep it from being part of the core library.
- General disagreement on key path format. Some want dots, some want JSONPath, and there are other competing standards. I don't think it's the place of this library to make a call on this.
- Unclear how to support keys which include the character `.`. It also encourages client code to build these key paths, and it becomes easy for a client to write the code `keys.join('.')` which could result in some pretty crazy and hard to debug errors if one of those keys happened to have a `.` in it.
- Ambiguous support for indexing into Lists. Should `"a.1.3"` translate to `["a", "1", "3"]`, or `["a", 1, 3]`, or `[a, "1", 3]`, or `["a", 1, "3"]`. All are legitimate and different interpretations.
- Missing support for complex keys. If my Map is keyed on some complex key type, I can't use keyPath. It's a bit arbitrary for the feature to exist but only support a subset of the library's capabilities.
- General concern about extending the polymorphic shape of these functions. Passing a string where a keyPath is expected is actually a pretty easy mistake to make - usually you intended to use a different method (e.g. passing a single key to any of the `*In` methods when you meant to use the non-deep variant). The purpose of TypeScript and Flow is to help detect these kinds of errors. This change will remove that pitfall detection.

Since the implementation of this is usually very specific to a certain application's assumptions and also usually very simple (in your case, just a `split`), I recommend including a helper function in your own library code. It's slightly more verbose, but also gives you complete control.

``` js
// Vanilla Immutable.js
m.getIn(['a','b','c']);

// Your proposal
m.getIn('a.b.c')

// Using a helper function
m.getIn(p('a.b.c'));
```

Where `p()` can be whatever you want, even just `p = pathStr => pathStr.split('.')` as proposed here, but also could be a JSONPath parser, or as I proposed in #310, `p = pathStr => pathStr.split('.').map(k => parseInt(k, 10) || k);`
 >  In my mind why even bother with get vs getIn just have one function that does both. But thats a matter of taste.

It's also different functionality! Since Maps can have complex keys, the array itself could be a key into a Map, so having one function that does both would limit these uses.
 All the same reasons, @pedroteixeira. Separator escaping is one of many issues. JSON path (and anything with escaping rules) generally still has a "whoops, forgot to escape that" pitfall anyhow. 
 Your suggestion on contrib libs is having access to adding things to the prototype?

Certainly anyone could mutate the Immutable.js prototypes today, I wouldn't recommend doing that instead of using functions, but it would certainly work.
  Yes, any Map key that means something specific in the context of an Object property will be dangerous to convert to a JS object.
  Which two tests failed? Can you confirm what version of typescript you are using?
 Sounds very much like an issue with your local version of typescript. Can you ensure the version of typescript you're using matches the version required by the package.json of this library?
 I just updated package.json to restrict anything above 1.4.x until typescript wraps up their work on 1.5.0 and I can verify it doesn't break anything. Hopefully this fixes things for you.
  Could you please write up a jsfiddle or gist or something which illustrates the issue? I can't figure out how to reproduce the problem from just this description.
 Closing this aging issue  Await already means something specific as an ES7 proposal that is very different from what withMutations does. I think this would be more confusing, and not adding enough value to be worth the pain of having to migrate all existing users of this library through a change to a pretty common API.
  If you need targeted updates, then you may consider using `Map` instead of `List`. `OrderedMap` if the iteration order of the items is important.

> Now I want to get a new version of my_list where approved value is changed(to true or false) only for Map's with ids in ids array.

This will be an O(N) operation where N is the size of `my_list`. It could instead be an O(M) operation where M is the number of ids to update instead.

If you wish to use a List, then the code you originally post looks like it will work just fine. If you wish to use a Map, then the code @camspiers posted looks great.
  I think there's bound to be confusing no matter which direction we go. Vector was confusing to some before because it implied a certain kind of data structure and the properties associated with that data structure. Array is confusing because it's not the same API as JavaScript's Array (notably, no [] access). List does refer to Linked-List in some languages, but also refers to the abstract type of collection in other languages - abstract from any implementation. Tuple also fits this description, but is often used to describe lists of a fixed size where each index holds a different kind of value. Again, potentially causing confusion.

We can bike shed on this as much as we want, but in terms of practical things we can do, changing the name of this kind of collection in a future version of Immutable.js would be pretty high friction and not valuable unless the confusion around List is high and there's an obvious alternative to use, which I don't think there is.

I think the least confusing thing to do is to leave it as is.
 I understand your concern. I think it's a good concern - I'm just don't think it's detrimental enough that it warrants a large change to the library.
  You want toJS() which deeply converts
  This was an unintentional breakage but the use of "size" as a key in a record has always been problematic. I'm working on simplifications and improvements to Record which should fix this issue once and for all. 
 Merging into #377.
  This is intentional. There are two things going on here:
1. `fromJS()` deeply converts a JS object & array tree to Map and List. `Map()` (and the other factories) do not convert deeply.
2. `mergeDeep()` treats non Immutable Collections as opaque references and does not attempt to merge them.

`Map()` does not do deep conversion, only shallowly uses the provided object keys to build the map. For example, if you had custom objects in your application (say for example, React components), and wrote:

``` js
var myCustomObj = new MyCustomObj();
var myMap = Immutable.Map({ "key": myCustomObj });
assert(myMap.get("key") instanceof MyCustomObj);
```

You would expect this to pass. If Map() did deep conversion, then your MyCustomObj would get iterated over and flattened into a Map.

So in your example:

``` js
var a2 = Immutable.Map({ a: 1, b: 2, c: { c1: 3, c2: 4 } })
console.log(a2.toString()); // Map { "a": 1, "b": 2, "c": [Object object] }
console.log(a2.get("c") instanceof Map); // false
```

Immutable.js will treat that inner Object as an opaque object reference - it can't know enough about all objects to assume what kind of merge strategy to use, so it does the only thing that would be safe and predictable: it replaces the reference with the new reference:

``` js
a2.mergeDeep(b2)
```

When it encounters the `"c"` key, it sees the existing `[Object object]` and replaces that reference with the  value of `"c"` in `b2`, which is the Object reference `{ c3: 30 }`.
 Also, just a tip while debugging:

`toJS()` is lossy, and can therefore make it difficult to see the true structure of Immutable collections. Some things you won't see when using toJS() to print values in a console:
- Difference between Record, Map, OrderedMap, JS Object reference.
- Difference between List, Set, JS Array reference.
- Non-string Keys of a Map, such as numbers.

`toString()` should help preserve all of this kind of information and can be helpful when peeking into a data structure.
  Detect that the obj is an Object, both "hashCode" and "equals" properties are functions.Â 

This will be included formally in the next major version as Immutable.isValue() but you can write it yourself as a cheap detection.

If your library is calling any methods on Immutable collections (like perhaps, "get") then it's good practice to check to ensure those properties are also functions.

Does that make sense?

â€”
Sent from Mailbox

On Fri, Mar 27, 2015 at 1:03 PM, JÃ©rÃ©mie Astori notifications@github.com
wrote:

> Right now I am checking that [`obj instanceof Collection`] for https://github.com/astorije/chai-immutable.
> 
> ## Probably not the best way to do it, but I didn't investigate much. I'll keep an eye on this thread and will add a Chai matcher to my plugin when a better answer comes in.
> 
> Reply to this email directly or view it on GitHub:
> https://github.com/facebook/immutable-js/issues/421#issuecomment-87073502
  Hmm, this seems like a mitigation rather than a fix. A map shouldn't have nulled entries like this. Let me dig deeper, but thank you for your initial exploration.
 @leebyron, is there any decision was made regarding this PR?  I'd like to get to the bottom of this. The original fix is patching a symptom and probably isn't the only place this could appear.  Seen. Certainly there shouldn't be a TypeError, I'll look into that. But this is also not legal code. Union and Intersection always return new collections - even within a withMutations block, so this should result in the Set ['a', 'b', 'd'].
 @magnus-madsen you were right all along. #1083 implements that approach for the fix. Better late than never!  Sorry all, looks like I got ahead of the CDN and the JS file for the docs didn't load. I just fixed it, should work for you now.
  This is almost the fix we want - but we also want the creation of the iterator to be effect-free. The first call to `next()` should cause the fast-forward to the starting position.

I believe the fix should probably be replacing `!==` with `>` so the second iteration skips over this condition.

Thanks for expanding the test case and finding and fixing this issue!
 I added my requested change as well as a few more tests to your PR before merging.

Thanks again!
  There are some failing tests because of this change. What's the reason for that?
 Nice work!
  If there is truly an unknown number of sets, would it be better to provide an array/list of Sets instead of using var-args?
 I'm curious when you would use this API over set1.intersection(set2)
 Hi there. I am starting handling backlog. I know it is been a while since you've submitted PR, sorry for such delay. The are some conflicts. Could you rebase or close the issue if it's obsolete? ðŸ˜…   Thanks for the heads up! Fixed
  Considering that Record.List's constructor returns a List. I'm not convinced this warrants being a new type of collection. Instead what it looks like you want to do is build a smarter kind of `fromJS` which is aware of a schema of Records, Lists (and Maps, Sets).

I would recommend re-framing this as a standalone function which takes two arguments: the "shape" of the data to construct and the input js object data that returns a tree of Immutable collections in the appropriate shape.
 Hey, I think this pull request has essentially timed out. Sorry! I am going to close it but if you are still interested in it enough to rebase and poke around to see if it still makes sense then please feel free to reopen.  Just reworked the test runner to no longer used the tsc wrapper but use typescript services directly. It should be both faster to run tests and hopefully not fail like this.

If you pull and run `npm update` you should get the latest dev dependencies which should hopefully fix the issue. If it doesn't, re-open it, and we will look into what's wrong with Typescript so you can file an issue on them.
 Strange. CI claims all tests pass. I'll look into it. 
  Hi there. I am starting handling backlog. I know it is been a while since you've submitted PR, sorry for such delay. The are some conflicts. Could you rebase or close the issue if it's obsolete? ðŸ˜…  Closing in favor of 44b20e4168613a7d28920495115a741b20fef2b4 for the future major version - though we still need to get type definitions to work correctly.  This actually seems like a real issue to me, so I'm going to re-open. `merge` should be a shallow operation, `mergeDeep` needs to be used explicitly to do deeper merges.
  I think you may be mis-interpretting the initial value for the Record class. It is intentional that you're unable to specify what type each field is because type checking will quickly expand into a very large (and possibly expensive) extension to this codebase in a really unrelated matter.

What the object provided to Record describes is the list of valid keys on that Record and the _default values_ for each key, not their type. For example: to articulate the difference between `entries`, a list of `Suggestion` records, having a default value of empty list `List()` or `null` (e.g. should `entries` be nullable?) you could write either:

``` js
const Completer = Record({
  selected: -1 // Number
  entries: List() // List<Suggestion>
})
```

or

``` js
const Completer = Record({
  selected: -1 // Number
  entries: null // ?List<Suggestion>
})
```

Does this make sense?
 I'm very interested in layering type information atop Record, I just don't think this library is the right place for this to live. I see a few ways forward:
1. Integration with static type checking tools like _Flow_ and _Typescript_. This would allow the additional type information to be removed at runtime, offering zero overhead and allow for full program analysis ahead of time.
2. A separate library which supplies runtime type checking for Record (and presumably the rest of Immutable.js). This will come at a serious runtime cost, but will enable the strongest sense of safety. That cost (both runtime cost and library size) is not one that every user of Immutable.js should pay, which is why I think this needs to be it's own library if desired.
 I now understand from your pull-requests that you're interested not just in type validation but parsing an arbitrary JS body into a tree of Immutable collections. That's also super interesting and something I would love to see, but probably should not be specific to Record, but apply to all Immutable collections.

Something like that would probably have a different sort of API from the Immutable collection constructors. For example, as you discuss here, you can't simply write: `List(MyRecord)` and expect it to operate as a type checker, for the same reason you can't write `Record({number:Number})` and expect that to operate as a type checker. Both cases expect runtime values. We will need something else for schema-based object inflation.
 Thanks for all the detailed input @Gozala.

> To be able to serialise records into JSON and then construct them back from the JSON producing equal values

This is not possible in all cases because converting to JSON is lossy. In some simplified common cases it's possible though. I understand your overall point of wanting to convert _from_ JSON in a deep way. This points to a need for a serialization proposal which I'm interested in, but is maybe out of scope for this task.

> List implementation is not sub-classing friendly

This is true, and @tgriesser has good ideas on how to improve this. However, I'm not sure that I'm convinced a subclass of List is necessary in order to properly parse JSON to Records and Lists. I understand you want this to be able to override the set/merge/etc methods, but I'm not sure this is strictly necessary.

> In fact I did also wanted to propose another addition in a following iteration:

``` js
const Point = Record({x: Record.Number(0),
                      y: Record.Number(0)})
```

Something along these lines is more interesting to me. I think we can probably get closer to the syntax of your original proposal by differentiating when providing a Record _constructor_ instead of a Record _value_ in the default argument position. For example:

``` js
const Point = Record({ x: 0, y: 0 });
const Line = Record({ start: Point, end: Point });
```

In this case, the `Point` refers to the Point constructor. We can then infer that the `fromJS` should parse these fields using this constructor, and the default value will be the default values of the `Point`, e.g. `Point()`.

This would preclude the ability to define a record constructor as the default value for a Record field, but that use case is probably very rare. I cannot think of a case where that's what you would expect.

My one real concern with an API like this is that it may be confusing to see an intermixing of default values and types. I foresee misreading examples like this and mistakenly writing:

``` js
const Point = Record({ x: number, y: number }); 
```

which is a reference error, or:

``` js
const Point = Record({ x: Number, y: Number }); 
```

Which simply wouldn't do what you expect (Number function as a default value). We can chip away at these cases, but it still makes me nervous.

The remaining case is for Lists of a particular type, but by extension also `Map`, `Set`, `OrderedMap`, etc. As well as all the future possible data structures we may add to the library, or extenders of the library may define (especially if we follow @tgriesser's extension proposal). I don't think requiring subclassing is the answer, but I'm not sure what the answer is.

Rough and dirty sketches of an API might look like: 

``` js
points: Record.Type(List, Point)
points: Record.Type(js => List(Seq(js).map(Point))
points: Record.Type(List, item => Point(item))
```

Not sure, exactly. This needs more exploration.
 For the first part of this: nested Records, I have a diff pushed to the 4.0 branch here: 5001072516a65b1245b528f88556ae4d1e4871fe. This is based on your pull request, I actually borrowed the tests directly.

I've made some generalizations to hopefully make this even more useful - not being limited to only Records as the type factories. This made using Number, Boolean, and String possible to use directly which provides some of the runtime type safety we were interested in without being a wart. It also let me add a `Nullable` factory function which is important when assembling a runtime type system like this. By leaving these factories as just functions, I'm also leaving the future open. I imagine at some point, someone will want something like Union, but not today.

The 4.0 branch was set up to start tracking changes like these that are going to be breaking. There's no set target date for launching 4.0, but having the space will allow for some exploration. Consider it an alpha branch.
 Your rationale is sound here. I totally agree that having a clean way to parse JSON into Immutable collections is really valuable. The trick is getting the semantics and API right so it doesn't preclude other valuable use cases and the API leads you to what you might expect. Hopefully the diff I pushed to 4.0 branch is on the right point of that scale, though it doesn't tackle non-Record types yet. I'd like to brainstorm a bit more on the appropriate API and architecture to enable this kind of factory function on input data across the suite of collections.

> Could you please elaborate, example of where it's not going to work ? I understand that conversion to JSON is lossy, but (with proposed changes) RecordType does hold enough information to be able to reconstruct it back by parsing generated JSON. But it could be that I'm missing something.

There are a ton of small edge cases where information is lost, but there are also larger representation issues. Certainly having a detailed tree of type information that mirrors a JSON body helps enormously, but the toJS() form on Maps produces an Object, but a serialization API would probably want to produce and consume a list of tuples as JS Object keys can only represent strings and their ordering semantics are awkward at best and ill-defined at worst.
 > Did I managed to make a compelling case for RecordLists that are the key to having polymorphic functions without workarounds described earlier

The need for a List that contains Records is pretty clear. The mechanism for doing so, less clear. I'd like to avoid subclassing if at all possible. I have some early thoughts, but nothing implementable yet.

> How do I help to move this forward ? I do understand you do not want to rush this and rightfully so. I just don't know if you'd like to have more discussion or some more code or maybe just time to think through this.

I think I need more time to stew on possible ways to implement this that have the properties:
- Very small overhead on existing library
- Highly performant
- Works for all Immutable collections, current, future, and 3rd party.

If you have thoughts on how to accomplish this, I'm happy to keep spit-balling.

> I do need to move the project I'm working on forward & given the issues I described earlier I do believe I have only following options:

I think fork and patch is probably going to work for you. You can unlock a working but maybe not final API, and by the time we agree on something that works best, it will probably be quite easy for you to code-mod your codebase to fit the new API. Building up a separate library sounds like a lot of work given that I really like the idea and want to see it happen here eventually.
 Yeah, I see what you mean here.  I'm glad you dug into this and figured out the boundaries. I think I agree that this is pretty dooming for typed lists. However typed records still seems valuable, perhaps there's a way to leverage "list" being part of a record type. Typed records won't have the same issue of the mapping functions desiring to produce different shaped records, so I'm not sure the same pitfall exists there.

For example maybe very roughly like:

``` js
var MyRecord = Record({
  listOfFoo: values => List(values).map(Foo)
});
```
  The root of this issue is what merge does on Lists, right @appsforartists? You expected merge to be the same as concat? I'm just trying to unpack the concerns listed here, I'm sure there's some API evolution we can do to make these ops easier to discover and viscerally understand.
 merging by index isn't really useful behavior anyway, I think it should work as you propose @appsforartists but this will be a breaking change and need to wait for a version bump.
  Thanks for the report!
  `Seq` have a full collection API, so you could at least type out as:

``` js
someMap.keySeq().toJS()
```

I'd like to keep the Iterator as simple as possible - in the future I'd like them to be true ES6 IteratorPrototype, so I hesitate on adding much to them.
  Closing this aging issue - Immutable.js doesn't support holey Arrays (Note the TC39 ECMAScript board is trying to phase out holey Arrays as well as they're a constant source of confusion)  Good suggestion
  This is by design, `sort` is unavailable within withMutations.

A future API change will hopefully make this far more clear as it's a very common point of confusion.
  This Issue is old, but would still be a really valuable PR.

Note that one of the primary challenges for a PR is naming this method!  After @robertknight's diff, tests run 3x faster on travis-ci, which uses jest's inline mode. It's closer to 4-5x faster on my MPB. Still on the order of tens of seconds, but much better than the > minute.
  They are not cached because the resulting JS array and objects are _mutable_ and may be changed after created by any other code. At that point, if cached, the cached values would not match the immutable collections. 
  Daniel has the right idea. It is _not safe_ to mutate an Immutable collection in the way you have described. Memoization is just one of the reasons for this.

New empty collections are always memoized to save GC churn.
 Also, I should note that the use of "new" is a bit misleading. The Immutable.Map function is _not_ a class constructor, but a factory function. You can prefix with "new" if it helps your code legibility, however the new'd object is never used and may contribute to GC churn.
 For now, the best way to store that metadata is in the map itself. Perhaps prefix with an underscore or something to illustrate it not being part of your application data. A true metadata API will be part of a future major version update to the library which should help this kind of use case. 
  Louis is correct that retaining the created JS object produces a memory leak that would be unacceptable for uses other than this proposed use.

Another thing to consider is that the resulting JS object is mutable and may be changed after created, so retaining it to return again would not be safe. 

Imagine, from your first example:

var aObj = a.toJS();
aObj.x = "edit";
console.log(a.toJS());

Either this will log an incorrect result, or it will have to carefully track edits to aObj which would be very expensive, or it will have to always return a new object. 

Your example code at the bottom, the simple memoization, is exactly what I would recommend. It doesn't look overkill to me, it's O(1) at runtime. By comparison, Lodash's isEqual (and Immutable.is) are O(N) at runtime. 
  Thanks for the report! I'll dig into this 
  Agreed. You should keep a reference to the "resetted" collection. Because Immutable.js collections are treated as values, you can simply reuse this important initial collection to represent the "reset", similarly to how you would "reset" a String or a Number back to some initial value. 
  This is correct behavior because toJS() coerces all keys to strings so the string key "5" and the numeric key 5 collide when creating the JS object. 

This is one example of how toJS() is lossy: JS objects can only have strings as keys where-as Map can have any value as a key. 
 The key paths are both totally fine. If you log toString() instead of toJS(), or just otherwise manually inspect the resulting Map, you will see that both the string "5" and number 5 represent two different keys in the Map. 

Related, the JS object {5: "value"} has a string "5" as a key, not a number. JS objects cannot have numbers as property names, only strings. 
  Thanks, this makes tons of sense. I wholey agree that being explicit about key types when stringed helps explain the difference from objects, and naked strings look far too much like property names, which they are not. 
  @hufeng is correct. Get the key sequence and pull the first item from it. 

In a future major version update, I will likely change this API to return an entry tuple instead of a value, which adheres to Map's iteration behavior. 
  Using reviver here is interesting. Could you illustrate the API you expected in order to achieve what you're trying to achieve?
 Up for grabs to ambitious contributors.

In my opinion `toJS` is one of the most abused parts of the API - so perhaps this is a good opportunity to break from the norm and implement `Immutable.toJS()` instead of adding weight to the class method.  There's no perf test covering this case yet. We will first need good perf coverage of this use case. I imagine creating a new Seq on every iteration is probably quite expensive. 
 Excellent work, thank you for being so detail-focused!
  We will still need to cover the case where valueOf returns a null-ish primitive which throws when calling value.equals. I think that's the key issue here. 
 Also, could you add test cases that this solves for and ensure you run "grunt" as part of the pull request?
 Thank you again for your patience and great work. I'm happy this issue is fixed and very happy you found and fixed the issue with the tests.

(btw, I fixed that inline concern as I merged)
  Records definitely support nesting today, the full set of nested get/set methods exist on Record instances. 

The initial object provided to the Record class factory are the default values, so if you want an empty version of the sub-record as a default value, you must supply it there. You want to supply instances as default values and not record classes.
 What I believe you're referring to here is a way to parse a nested JS object into nested Records. The Record constructors will not do this for you, as it is equally valid to provide a regular JS object as a key. Instead, you should use Immutable.fromJS() with a custom reviver function which is written in a way that relates to your data schema. 
 I'm not sure I follow how it even works if you override the constructor and have it not accepting any values.

But FYI - I'm working on Record sub-type declarations as part of v4.0.0 in the branch of the same name. See https://github.com/facebook/immutable-js/commit/35c2af0fe5bb8c879c7beba09025966518d68995
 So definitions of Records just set up default values. I know some people also define custom factory functions to go along-side them like you've done with EventRecordFactory. That may be useful as well for something like your `EventRecord` which sets a default "start" time to be when you defined the record - so all event records will have the same default start time, that's probably not what you want.

Having those factory functions are nice because you can define whatever behavior you like in them, including calling other factory functions to produce the kind of nested records originally brought up in this thread.

See this super contrived example of nested records with factory functions.

``` js
var _RecordA = Immutable.Record({
  b: null // RecordB or null.
});

function RecordA(obj) {
  return new _RecordA({ b: obj.b ? RecordB(obj.b) : null });
}

var _RecordB = Immutable.Record({
  a: null // RecordA or null.
});

function RecordB(obj) {
  return new _RecordB({ a: obj.a ? RecordA(obj.a) : null });
}

var abab = RecordB({ a: { b: { a: { b: null } } } });
console.log(abab.toString());
```
  @copy, I'm glad you've caught onto this pattern! I haven't documented it anywhere yet, but in the next major version, I will document this as a way to define "value" objects that work in the Immutable.js ecosystem (eg, can be used as keys, and are considered values by Immutable.is())
 Methods can be added to Record classes as @kentor describes. Simply add methods to the prototype. It is probably not a good idea to add them as values in the Record.

Some ES6 transpilers support extending expressions, in which case you can write:

class Complex extends Record({real:1, image:1}) {
  magnitude() { return ...; }
}

For the transpilers that don't support subclassing an expression, but support an identifier, you can write:

var _Complex = Record({...})
class Complex extends _Complex {
...
}

I personally prefer just adding methods to the prototype. 
  Thanks for finding this, it is a bug. When the name is empty, it should default to "Record"
  toJS() already exists on Records. You can safely call it directly.
  Thanks for your patience, this is a great fix.
  Good call, Hugh!
  This should live in a separate sort of thing. Cursor is meant to be a very transparent view over a Map or a List, not to represent a new kind of data structure. What you're describing sounds more like Zippers which we do not have any tools for at the moment. Feel free to start to flesh that out!
 Sorry for missing your comment here. I highly suggest starting a project for this outside this library. In a future version, the `contrib` folder will be replaced by separate github projects.

What you're onto here is similar to zippers and lenses and probably benefit from being able to evolve as such rather than being tied to the fate of a (not the best) implementation of data cursors.
  This looks great! Thanks for building this. For basic use, what you have made is valuable. If you're looking to expand the API, I would suggest looking at the whole chai API for objects and arrays and writing similar assertions for Immutable collections. The has/includes are certainly valuable assertion methods as well. 

Nice work!
  Immutable's common operations like `Immutable.is()` and prototype methods make assumptions about their input having prototypes of a certain form. This is potentially problematic in some edge and corner cases.

If an individual Immutable collection has an altered prototype, the behavior could change.

If a Record introduces a prop key with the same name as a prototype method/prop, the behavior could change.
 @zerkms certainly the code is not un-runnable, there just may be dangerous caveats. For example, Immutable collections have a method called "map". If you define

``` js
var WorldMap = Immutable.Record({
  map: "flat"
});
var flatMap = WorldMap();
console.log(flatMap.map);
```

This works today and will log the string "flat". However, if the change I proposed earlier was added, then this code will behave differently and log "[Function]". That's why it's breaking.

However, now that I've thought about it a bit more, I'm not sure just not adding the property descriptors is a good idea because it will defy the expectations of the developer. Certainly in your example of Shirt, you would expect `myShirt.size` to be "XL" and not "2". It would be especially weird for `myShirt.size` and `myShirt.get("size")` to not be the same value.

I think what's more important is ensuring that internals cannot be squashed which can cause some issues, as pointed out by the task that spawned this one. I'm not 100% sure what the right strategy is there quite yet, but surely it can be solved. I'll think about it more.
 Fixed in master - now throws clear Errors instead of mysteriously breaking.

Unfortunately no, symbols can't be used because they're public API methods and accessors.  Arrghh. Thanks for flagging it.
 v3.6.4 is released now which is not broken. Thanks for stickin' with me.
  Thanks for this work! I appreciate you digging in and figuring out what to do
  Unfortunately this is not possible using this library. You may be better off using Object.freeze() and Object.seal() on a JS object with properties configured as needed.

This library's immutable Map collection is not analogous to JS Object, but to ES6 Map. As such, it doesn't have a concept of properties (nor property enumerability) but instead has a concept of key->value entries, where keys can be of any type (whereas property names must be strings). The toObject() and toJSON() methods exist as a convenience only, they can be lossy and do not work on all Maps.

In the case that you want to use Immutable Map, but want to ensure some entries are not iterated over as a way of emulating enumerability, you can use `filter` to exclude the keys you don't want to be included in the iteration. A good example of this case is highlighted in the wiki: https://github.com/facebook/immutable-js/wiki/Predicates#pick--omit

The code you might use for toObject could then look like:

``` js
myMap.filter(myOmitFunction).toObject();
```

However you will later need to define the non-enumerable properties.
  Seems like a pretty obvious win. Thanks for your patience, this is great.
  Interesting. I think you're correct here that if the key paths differ then the cursors can't be considered equal because they refer to different parts of the source structure.

However if a cursor is compared to a non-cursor, the key path should be inconsequential.

Thanks for the really detailed write-up about this.
 Closing this aging issue, especially since contrib/ is not a primary focus. If the changes discussed here are still relevant to someone then a PR would be a nice reboot for this concern  All Immutable.js collections implement the ES6 `Iterable` interface. JavaScript Array is in fact iterable in ES6-aware browsers (currently rare), but in other browsers Immutable.js will wrap the array in a `Seq` which is Iterable. Similarly for JS Object, as a convenience, will be wrapped in a `Seq` and iterated similarly to how an ES6 Map is iterated. These `Seq` wrappers have extremely low overhead, and are similar to the excellent [lazy.js](http://danieltao.com/lazy.js/) project in implementation, they do not create an immutable collection from the Array or Object (therefore no trie is created for them).

All methods in Immutable.js which expect an `Iterable` argument internally have a simple check which first checks if the argument is Iterable, and if not, wraps it in a Seq so that it is Iterable before running the rest of the method.

Immutable collections are in fact Trie structures, and since they implement the `Iterable` interface directly, aren't wrapped in `Seq` when provided to these kinds of methods.

Does that help explain?
 In that case, the expected output is an Immutable data structure - so yes, `fromJS` will create a Trie data structure from the array as input. An O(N) operation.

However, if you only want the API ( iteration and higher-order-function methods ) of Immutable, and you have no plans on actually updating that array, then creating the Trie might not be necessary. In that case, you would want to use a wrapping Seq directly.

``` js
import { Seq } from "immutable"
var myArray = [1,2,3,4,5];
var list = Seq(myArray); // O(1)
list.get(2); // 3
```

The Trie data structures are really meant to be useful for persistent immutable data where updated versions are going to be created over time. You can update an immutable Trie in O(log<sub>32</sub>N) which is very close to O(1). Seq has no API for updates at all, it's designed to be read-only.
  Yeah - the more I'm thinking about it, the more I'm concerned about the pandora's box that you brought up just now (and before) @tgriesser.

I agree with your conclusion that we should keep floating this as a fork to investigate the compelling use cases.

In previous conversations you compelled me to include a metadata API which I think handles a lot of the cases that subclassing was desired for - and that's still on the docket.
 @vtambourine I'm a little confused about your prop-types example. Are you saying that you have arrays of Immutable Maps? Or do you have Immutable Lists of Immutable Maps? Or Records?

Also note that React propTypes are just functions which do or do not return an Error, you can always write your own propType function that will do the custom validation you want.
 You're correct that if you're using `Record`, you can use `PropTypes.instanceOf(MyRecord)` without any issue.

> As far as I understand React approach, first array should be treated as immutable array of immutable object. How to handle props validation on each components?

There's no such thing as an immutable array in JavaScript, but you could certainly use an Immutable.js List collection here if you wish. You could use `PropTypes.instanceOf(List)` as your propTypes for this property, there's no need to test for the contents of the list since your `CargoItem` propTypes will already be doing this and there's no need to do so twice.
  This file is auto-generated. Must be a bug in the doc generator.
 Fixed in latest docs
  Note to anyone who would like to attempt this PR - most of the documentation for Record has already been written, however the documentation generator chokes on the Record definition.

The bulk of the PR to solve this issue will be in the documentation generator codebase in `pages/`  Nice work, thanks for your patience!
  Closing this aging issue  Thanks for the report!
 That's close to what I plan to do.

I also want to ensure that none of the other prototype methods are affected for the same reason, so I may use the prototype as a blacklist. Rather than throwing an invariant, I'll probably just not assign property descriptors for those keys, instead requiring that you access those keys via the `get()` method.

Either way, this will be a breaking change that will need to go into the next major version bump of immutable.js, and we may also need to include some way to opt out of this behavior in the case that you _want_ to clobber the prototype.

In the short term, I will look into a way to mitigate the immediate issue reported here.
 Closed because this immediate issue should be resolved in https://github.com/facebook/immutable-js/commit/6b6074677ae986c92c793673ceb958bc130a76c2 but the larger issue of clobbering prototype property keys still exists.
 Tracking the larger issue in #377
  I actually made this change in v3, but changed back after significant push-back. In addition to further decoupling of the cursor API from this library, I think an API like #249 would be nice if cursors are to behave the same way they do today.
  Hashes are calculated only when explicitly necessary, since they're expensive to compute. They're calculated when being used as a key in a Map, as an example.

Always hashing when calling `equals` would always improve speed. Certainly the first call to `equals` for un-hashed values would face a penalty, as now we would not only be comparing equality but _also_ computing these hashes. Also, in the cases that two are value-equal but not ref-equal it will compute matching hashes but still require comparing equality to ensure that no hash-collision has occurred.

I think the next step on something like this is to actually perform more research on the performance cost/benefit
  @samwgoldman is completely correct. Reference equality is a shortcut used in some places but can never replace value equality, which is what you want here. 

This is the case for very similar reasons to why:

var a = []
a.filter(() => true) !== a
 I'll keep this open as a note to myself to improve the docs to make this point more clear
  You cannot because immutable objects have no updates to observe!

Perhaps you could share some example code of what you're looking for and how you expect it to behave and I might give a better suggestion.
 Perhaps `Cursor` would suffice?
  This works today, but I'll keep this task open to make it a bit more obvious.

If you click on a header from the table of contents on the left side, you'll get a link to that location. In your example: http://facebook.github.io/immutable-js/docs/#/List/set
 To any contributors looking to help: it would be great if you could click the headers in the docs to get anchor links  thank you!
  Hey @JonathanHayward thanks for the report.

For future reference, if you scroll to the bottom of any of the pages in the docs, there's a red box explaining that they are autogenned with links to the relevant files.
  Thanks for finding this bug! I'll dig in to fix it
  Thanks for reporting this (and I'm so sorry for getting to it so late!)
 I think this is fixed, so I am going to close it, but if not please feel free to reopen this issue!  It sounds like Record is exactly what you're looking for. 
 Records can already be extended via normal prototypal inheritance, however the storage mechanism cannot.

I'm not sure I'm understanding what's being asked for here. Please re-open if this doesn't resolve the task.
  This should be partially solved by #507
  Use filter() before toJS()

See this recipe for a pick filter: https://github.com/facebook/immutable-js/wiki/Predicates
  This has seemed to trip up a lot of people lately, so I will definitely include more documentation on this. 

m.set('y', 5) !== m.set('y', 5)

For the same reasons:

{y: 5} !== {y: 5}

Objects use referential identity equality, not value equality. 

For value equality, you must use Immutable.is(m, m2) or m.equals(m2) which will determine if two collections have value equality. 

As an optimization, if the two cases being compared are referentially equal, then that value comparison will be extremely cheap.

In immutable, every time you call one of the mutative methods like "set", you're creating a new object. Within that new object it may share portions of data with the previous object, but at the top level it's still a new object and will fail referential equality (===) with any other object, including other objects that happen to hold the same shared data.

As an optimization, when calling a mutative method like "set" Immutable.js first looks to see if the value you provide is === with the value already at that key position. If it is, then it short circuits, returning itself, knowing that the operation would be a no-op.

This optimization helps Immutable.is() find that fast path in this common case.

With immutable data, you're far more often looking for value equality than reference equality. You should use is() and m.equals() whenever you want to know if two collections represent the same information. 

There are some cases, usually when writing memoization functions, where you instead want to know a rough and cheap to calculate equality and are willing to give up on some false negatives, eg "are these definitely not not-equal".

Hopefully that helps explain a bit. I'll capture this in better terms and add to the documentation. 
 They're called Hash Array Mapped Trie and there's decent documentation of the overall concept floating around, including on Wikipedia. I also gave a talk on the structure and have some illustrated examples in that talk that you can find on YouTube. 

Your assumptions are close, but maybe a bit upside down. The root of every structure is unique but often leafs of the tries are shared amongst one another. 
 Unfortunately not, @gniquil - or at least not without severe performance and memory penalty.

For example, a global cache would require some sort of cache eviction policy, which will incur a performance cost on every operation. Having a cache at all requires a memory footprint, and a trivial cache would just grow endlessly, never allowing the GC to clean up any created collections. This would have large negative memory implications on most applications which use Immutable.js and heavily rely on the GC cleaning up after them.

Then there's the problem of determining how to key into the cache in the first place. This means once performing any operation, you will need to do a full hash and cache lookup, an O(N) operation on the size of the object being looked up. This would make every operation in Immutable.js O(N) which would be untenable from a performance point of view.

I believe a better forward path is for the JavaScript/ECMAScript technical committee to consider value types and overloading the `==` equality operator. This is a conversation that is happening for consideration in a future version of the language, so that we may map `==` to use `Immutable.is()` when the operands are Immutable collections.
  This is interesting, thanks for putting this together. However, I prefer the explicitness of loading each dependency. It's easier to keep track of what npm dependencies are in use.
  Sorry, the hope was the assert() was illustrating that point, but I suppose the text could be more verbose.
  Hey zachasme,

Can you explain what happens when you use the current export today?

The raw source of Immutable is not designed to be used directly as it currently has some delicate circular dependencies. It's designed to be transpiled to a single file for use. The current top level export lets us produce the most tightly compiled output that should work with the most consumers. 

I have a few projects that use babel myself and I have used this import pattern without trouble, so I'm curious if something has changed that would break this more recently. 
 Can you run `grunt build` and update the PR? This might be okay, but we will need to take a look at what it does to the built distribution file.

> and making sure classes are instantiated with new

There are exceptionally few classes in Immutable.js, instead most are factory functions. Using `new` along side factory functions likely has some additional memory weight without any added value.
 This approach is more interesting. 

However, I'm curious why you want to load the raw source directly rather than the compiled production distributed file? Babel and other transpilers have support for loading in a vanilla CommonJS module like this one in the way you want. 
 Hey, thanks for submitting a pull request. Sorry for not getting closure on this earlier but I think this pull request has sort of timed out, so I am just going to close it. Please feel free to reopen if you think this is still a problem though.  size and count() are almost always equivalent. However some lazy Seq cannot know their size until being fulfilled so size will be undefined for those cases and calling count() will fulfill the lazy Seq to determine its size. 

Thanks for reminding me to update docs with this. I'll leave this task open until it's done
 If you're making use of Seq in your code then I definitely suggest sticking to count(). If not, there's nothing wrong with using size directly. 
 There are a number of places where it's very beneficial to know the size of a Seq without having to iterate through it - for example when slicing slices. You can reap very real performance benefits from this.

I definitely recognise the potential for causing trouble though - I'll consider this not just a detail to be documented, but an API to improve in future versions that maintains the ability to write highly performant code, but also doesn't present these kinds of potential bugs.
 This seems sufficiently answered, so I am going to close this issue!  Will the recipe for "pick" do what you need?

https://github.com/facebook/immutable-js/wiki/Predicates
  Great idea. I'll look into this more
 There's a missing feature from typescript that would help solve this. The idea of the return type being "this" eg the same type as the context object. In the meantime yes you have to manually write it out for any subtype which is pretty awful
 This should be fixed in master, will be released soon  Is there a particular use case you have in mind here? I would suggest using arrow function or bind if you need the immediate surrounding context at the present moment.Â 

â€”
Sent from Mailbox

On Sun, Feb 22, 2015 at 8:39 PM, Sebastien Barre notifications@github.com
wrote:

> Should `withMutations()` offer a `context` parameter, so that `this` can be set in the context of the `mutator`?
> i.e.
> 
> ```
>   withMutations(mutator: (mutable: Map<K, V>) => any): Map<K, V>
> ```
> 
> becomes:
> 
> ```
>   withMutations(mutator: (mutable: Map<K, V>) => any, context?: any): Map<K, V>
> ```
> 
> to match signatures such as `Map:map()`
> 
> ```
> map<M>(
> mapper: (value?: V, key?: K, iter?: Iterable<K, V>) => M,
> context?: any
> ): Iterable<K, M>
> ```
> 
> ## Thanks
> 
> Reply to this email directly or view it on GitHub:
> https://github.com/facebook/immutable-js/issues/340
 Good suggestion, I'll look into it

â€”
Sent from Mailbox

On Sun, Feb 22, 2015 at 7:03 PM, Sebastien Barre notifications@github.com
wrote:

> ## I guess in the context of a React component's method, `this` is set to `window` inside `withMutations()`, preventing any other component's method from being called?  But reading more about the arrow function it appears its biggest benefit is that it does not alter `this`. Sorry, not completely used to ES6. Thanks for the pointer. Maybe for consistency with the sequence methods, it would a useful addition...
> 
> Reply to this email directly or view it on GitHub:
> https://github.com/facebook/immutable-js/issues/340#issuecomment-75480112
 Deciding against this in favor of encouraging arrow functions to keep API simple.
  This is very similar to #282 which I suggest you read. 

The TLDR is that object keys are _always_ strings. Javascript lets you omit quotes for keys when writing the literal form, but they are still read and stored as strings. 
  Great suggestion. I need to look into web worker serialization a bit more to figure out the best path forward. Today there is not a clear way to serialize and deserialize Immutable collections. 
 Transit is a great tool, I definitely recommend using it. I'm also considering adding a very simple serialization API to the library
 If you're looking for a serialization method you can use today, I would strongly suggest using transit.js. It's a great library for serialization and you can find write ups on using it with immutable.js.

Better methods for serialization are on the roadmap, but it's unlikely that we will serialize the structural sharing itself, as that can have very tricky implications. Instead we will do something fairly simple and related to what transit.js does
 Unfortunately this is still an open challenge, but I'm closing this aging issue  These are two different objects, so this is expected for the same reason that {k:"v"} !== {k:"v"}. 

If you want to check value equality, use Immutable.is()
 It certainly doesn't defeat the purpose. Objects and Maps are very different things and the data structures this library implements can be very efficient and powerful way to use persistent immutable data in JS. Native JS objects and Maps are mutable, the purpose of this library is to introduce immutability. 

As far as equality checking, it's not that this library replicates a clunky behavior, it's simply that JS does not allow for operator overloading. If it did, this library would certainly take advantage of that. In lieu of operator overloading for ===, we just settle with a function is(). 

There are proposals for future versions of JS to make this sort of thing less awkward. JS Strings are persistent immutable data structures with a custom equality implementation, but since they are native to the language we tend to not stop and think about how strings and objects behave differently relative to memory usage and value equality. 
 That's good feedback. I'll clarify the documentation around this. 
  There is not at this time. You need to always define the whole key set when you define a record. 
  It's intentional, but probably misguided. Changing it would be a breaking change, but alongside clearer APIs about (de)serializing I think it would be the right thing to do.
 Have you tried `map.entrySeq()`? It does basically exactly what your "asTuples" does. 

Also, you can use the for of iteration loop since the natural iterator value for a Map is the entry tuple. This works both for Immutable Map and the existing ES6 Map

```
for (const [k, v] of myMap) { 
}
```
 mapEntries doesn't really make sense for a list, since returning anything other than incrementing ints as keys wouldn't make sense. 
  Thank you for this report! I'll look into it
  I want to append an item to a List deep inside another structure. Would ideally like:

```
pushIn(keyPath: Array<any>, value: T): List<T>
```

where the keyPath is one item shorter than an equivalent `setIn` would be (because the final operation is a push, not a set).

Thoughts?
 There's a bit of a slippery slope where ultimately every API method will have an equivalent *In() parallel. pushIn() makes good sense, so I'll keep this open. 

In the meantime, updateIn() is the generic deep update method which all other *In use directly. 

foo.updateIn(["a", "b", "c"], List(), list => list.push(123));

The empty list 2nd arg will be used in place of undefined in the update fn should the path not yet exist. 
  Merging into #1050 - sorry for the massive delay  Thanks. I must have had a dyslexic moment. 
  I explored this not too long ago, thanks to some help from members of this community and found that it's quite difficult as soon as you have operations that map from one type to another type, namely `reduce` and `map`. You could imagine how calling `map` on a `List.ofType(Number)` with a mapper like `num => num + " many"` List would either have to lose it's typing, or find some way to infer the type of the new list.

I think this fits into the category of things that are difficult and awkward to do without language or compiler support.
  Hmm, I'm having trouble reproducing this.

After running...

``` js
const Thing1 = {};
const Thing2 = {};

const x = {
    "key1": Thing1,
    "key2": Thing1,
    "key3": Thing2
}

const result = Immutable.Map(x).groupBy(x => x);
```

I inspect result...

``` js
console.log(result.size);
2
```

That's expected, since we're returning `Thing1` and `Thing2` as the keys to group on.

``` js
console.log(result.get(Thing1).size); 
2
console.log(result.get(Thing2).size); 
1
```

This also makes sense, Thing1 had two keys pointed at it.

``` js
console.log(result.toString());
"Map { [object Object]: Map { key1: [object Object], key2: [object Object] }, [object Object]: Map { key3: [object Object] } }"
```

That looks like what we expect.

---

Perhaps you could write up a quick test case that fails for you? I think I'm just not seeing the error yet.
 Ahh yes. `toJS()` is lossy for a lot of reasons.

So in this case, we're using Objects as keys in our Immutable.Map, but when we call `toJS()`, it's converting back to a JS Object, it needs to convert the keys to strings so it can use them as JS Object keys. Both `Thing1` and `Thing2` will produce `"[object Object]"` when cast as strings. Since all keys have to be unique, the 2nd key for `Thing2` overrides the first from `Thing1`, and you only see that data.
 To some degree. Immutable collections implement a pretty reasonable `toString` which does its best to illustrate what's going on, but it does still involve casting everything to strings. You can see in my investigation, when calling `toString()` both object references get flattened to `[object Object]` and it's a little tricky to see which is which, but it at least illustrates the shape.
  That looks just fine to me. Is it doing what you want?

Since your setIn key path is short, you can also do:

store = store.set('customers', fromJS(data))
 That's correct
  has() and set() are both O(1) while union() and intersection() are O(N) in the current implementaion. 

If you can point me to research in making these ops faster than order N, I would love to see it. 
 Sure. That's probably still O(N) but may have a better performance factor. Sets are actually backed by the same structure as Map, a HAMT. It has a similar tree shape. I have an outstanding task to make an optimized version of map merge or set union that follows this. I'm not sure that will do much for intersection though. If you have more info let me know!
 I'm interested in seeing reference implementations of this. If they're actually referentially the same data then yes I believe you could get O(log N) union/intersection. However if they are simply value equal then there is no way to escape O(N) as you need to actually visit every node to determine a union or intersection.
 Consider creating the union of:

```
      13
    /    \
   8      17
 /  \    /  \
1   11 15   25
 \         /  \
  6      22   27
```

and

```
      13
    /    \
   8      17
 /  \    /  \
1   11 15   25
 \         /  \
  7      22   27
```

Despite only one value being different, you have to at least crawl the tree to 
find it. You can't determine from seeing that both trees have an "8" node that
you can stop crawling the tree. You must spend O(N1 + N2) time to determine the
union.

In a Red Black Tree, you also must then balance the result of the merge, which
is itself O(M \* log N)

HAMT might yield a different outcome considering that it doesn't care about ordering so it doesn't require a rebalance, but I think simply determining the union/intersection will require a full traversal of both trees with the exception of the case where both trees are structurally sharing common subtrees. For example, if the `17` branch in both trees was _literally the same memory_, then we could shortcut and be O(1) for that subtree.
 Tracking this now in #507 
  Interesting. So you use meta as a marker interface to see if some data has been validated or not already. What other common uses take advantage of meta?
 @swannodette I'm sure you can provide some good advice here. What are the benefits and pitfalls of meta in practice in most clojure apps?
 Closing this aging issue - perhaps something we could consider in the future.  Thanks for reminding me about this. I actually needed to update all copyrights, not just this block file, which I did in 257b92c6887ae787da9c94fbabe34056014ffc93
  Same as #282 where there is more info
  Huge bummer, but thanks for the report. What browser and version are you seeing this in, or if it's all of them, what cut of Linux?
 What workarounds are you aware of?
  Thanks for the report (and the pull request) ((and your patience)).

I'll dig into this and make sure this is fixed and incorporate your pr soon.
  Thanks for opening this. I agree we want to eventually get here.

Some subtasks:
- [ ] Deprecate all methods like `toMap()` in favor of passing instances to `Map()` constructors.
- [ ] Ensure common methods which return full structures are factored out (`groupBy()` is a good example) into helper functions instead.
- [ ] Find a new build path which allows for a single distribution file independent of node style requires.
- [ ] Investigate bytesize addition of Browserify and Webpack in partial-build mode.
 @pluma it won't break it no. But of course, if you require `"immutable/fromJS"` then you'll implicitly also be requiring `Map` and `List`.
 It's only 15kb if you serve the min file and your host uses gzip (they all do)
 I'll note that's 1/10th the size of most JPEGs on your site
 No worries, no harm. I just want to make sure the number is clear, and it's in perspective.

I just also want to caution looking at this task as a source a big win. In it's current form, this isn't going to do much for you, but what this task does do is allow for the library to expand and include new data structures without impacting byte size. That's going to be important as I plan to add SortedSet/Map and more useful structures in the future.

Currently the bulk of the library is distributed across three files: Iterable, Map, and List. List and Map both extend from Iterable, so at the very most you could drop from 15kb to 10-12kb if your application uses only Maps or only Lists. I also haven't evaluated how much weight using Webpack or Browserify would add to the size for partial builds vs the ultra-thin Esperanto packager currently used for full builds, my hypothesis is somewhere around 0.5-1kb, but this is something I'll investigate.
  Thanks for the report. I'll get on this
  This has pretty severe performance implications. I'm actually planning on moving away from the class semanic because of this recent change to the spec. I don't actually use the constructor function behavior in Immutable (you can call these functions with `new`, but the constructed object is discarded). Instead these should be viewed as _constructor functions_, rather than _class constructors_.
 But I definitely appreciate you investigating this.
 I am going to move away from classes in v4. They will officially be factory functions and the syntax will make that more clear. Also as part of the road to v4+, I'm doing some refactoring to make the code truly ES6 compliant, it's currently not so and dependent on a particular build pass.

In the meantime, I highly discourage using the src/ directory directly unless you're using the build tools that come in the repo. That codebase is not safe to use with Babel. Instead you should always use the dist/ directory.
 Closing this PR since new isn't the correct semantic for factory functions.
  Yeah, I agree that type-checking when used with Record feels crummy right now. It's a combination of the capabilities of the type-checkers (requires a lot of dynamism) and how Record classes are built.

I'm inclined to investigate any changes in the API for Record if it can help support better type definitions. I'm open to more ideas.
  Cursors will likely find their way into a separate file for distribution in the next version bump.
 Closed with #1137   Yes, this is expected. Immutable.js has optimizations in its methods to return `this` when the method would be a no-op, enabling reference equality checking to determine if no change was made.

It makes more sense when using `set` as the example:

``` js
var a = Immutable.Map({key: 'value'});
var b = a.set('key', 'value')
a === b // true
```
  Thanks @Dashed. Yes, the tricky thing here is that not everyone agrees on what "path" encoding should be used. Also note that encoding path as a string means that you cannot use it to access when a non-string key is used. Finally, what would `'a.1.b'` become? `"1"` and `1` are different keys! You either exclude numeric strings, or you exclude the ability to index into a List!

Despite the issues with this, I know that it's a valuable shorthand. My suggestion to those who want this shorthand is to use a locally scoped function that turns it into a key path, so they can use the semantics they care about. Since the function is so small, it's probably fine for it to live inline in your application instead of needing to live on npm.

``` js
function path(pathString) {
  return pathString.split('.').map(key => parseInt(key) || key);
}
```

Then you can use it for any `*In` function in the library:

``` js
nested.getIn(path('a.b.d.1.2.3'));
```
  An updated dist has been built, thanks for the reminder.
  I would start with the documentation at http://facebook.github.io/immutable-js/docs/

You'll find descriptions of each of these types.
 Yes I have an existing task to add more example code to the documentation.

For now, you probably only need to pay attention to List. It's also the most well documented. 
  This file is autogenerated. The readme and generation files need to be changed. Thanks for the report though, I'll look into this. 
 Fixed in latest docs
  You're spot on. Thanks for your careful reading and spotting this slip-up.
  Maybe submit a pull request since you've already written up custom implementations?

If the performance impact of this is negligible then having the additional behavior is nice. If it's expensive then perhaps it makes sense as an external utility function. 
 > If we were really ambitious we could have as a goal that List.if(1.2.3).push(4) should === List.of(1.2.3.4)

This is unfortunately not possible without some devastating performance issues as it would require these two operations to "know about" each other (read: some global cache). Instead, you should favor Immutable.is() for these kinds of comparisons.

> (the same way "123"+"4" === "1234" thanks to immutable string in JavaScript).

This actually uses a deep value equality check. It's likely that the two strings occupy different memory addresses, but JS knows that comparing strings means doing a character for character check if a memory address comparison fails.

---

On the whole, we're balancing for performance here. We pay a very small penalty in order to detect no-ops and return `this` in some operations, it pays off because we know it's a common next-operation to compare both the old and new versions.

In this case, building fromJS to be aware of references requires building up a cache of all visited objects by reference, which is quite a burden to put on this method which should be quite fast.

At the end of the day, you should not be relying on `===` reference equality so directly as not everything that is value equal can also be reference equal. `Immutable.is()` is not slow, and contains the `===` check internally as a first step anyhow, so is often equivalently fast. Slowing down other operations to make `Immutable.is()` faster is very likely going to be a net-negative on performance overall.

Also, I would be thrilled to be proven wrong on this. If you have code and benchmarks I'll happily entertain them. The smartest tricks often appear to be terrible ideas at first glance.
  I'm not sure I understand what issue you've run into. Could you maybe provide some sample code and explain how you expected it to work and how this library behaved differently?
 Hey Tom, you certainly shouldn't depend on that order. For very small sets of entires, Maps appear to have the same ordering as OrderedMaps, but once you go above a certain size, the ordering can change. 

I would suggest explicitly creating the OrderedMaps at each depth if you need to guarantee ordering. 

I like this suggestion, but I'll need to think about any externallies. 
 Sounds great
  Filter may be more difficult as it would require changing the structure as well. 

Could you add a portion to the benchmarks so we can test the before and after of this?

I'll look into why your build got so noisy.
  Good call, I'll check for null prototype as well.
  I'm excited to see more of what you've built, Tim! Mind writing it up for me in an email or something? lee@leebyron.com
 I'm still very concerned about the performance implications as well as creating an API that leads to anti patterns. 

For those +1ing, could you please add a use case you're trying to enable that's not currently possible by using Immutable.Record or the existing List and Map structures?
 I think that should be entirely possible by composing Immutable.js collections rather than extending them. You can check out OrderedMap as an example of this. It is a new kind of collection with new properties and some differing API, but is implemented by using List and Map
 I'm going to officially close this issue since we decided a while back that it wasn't worth the serious performance costs. We would rather have performant data structures rather than subclassable ones. 

This also encourages using plain functions for extended behavior, or composition for more advanced data structures, which are good patterns to follow
 Yes, that's a great idea. In the meantime, check out the source for OrderedMap and OrderedSet, both are "new" data structures built by composing List and Map
  This is a bit counter to the purpose of Cursors, which seek to be invisible and act as the types they wrap.

For shouldComponentUpdate, I recommend using `Immutable.is()` which will automatically handle Cursor unwrapping for comparisons.

If you want to deref regardless of Cursor for more specific comparisons, you can use `obj.valueOf()`. Regular types return themselves in `valueOf`, but Cursors return their `deref()`.
 Immutable.is should not throw. Thanks for highlighting this bug!
 Also yes, separate issue
  Sweet thanks
  Thanks for adding this. I'm a bit behind on reviewing PRs, but I promise to dig into it soon. 
 Closing in favor of @jeffbski's fix.
  I'm not sure this makes sense to add to a data collections library, but certainly could be awesome as it's own library! Sharing conventions with Immutable would allow them to interop as necessary (e.g. implementing `hashCode()` and `equals()`)
 #506 hints at the semantics necessary for object types to masquerade as value types from Immutable's point of view.
  I changed the new key to `"@"` which is even less likely to cause conflict. Thanks again for digging into this.
  Yes! I actually have an almost identical change sitting in a branch on my local machine to do this, and I've been building out the perf tests in order to measure exactly the question you're asking about implications.

> The rest params transform looks a lot like your arrCopy (minus the leaking of args because it is inline):

Yep! I added that change to 6to5!

So I'm all for 6to5, but just need more time to understand the implications first.
  Thank you!
  Thanks for the report, I'll look into this
 Can you clarify a bit with code you're using that's producing this case?

I assembled a small example which works this way:

``` js
var R = Immutable.Record({ x: null, y: null });
var data = Immutable.List.of( R({ x: R({ y: 1 }) }) );
// List [ Record { x: Record { y: 1 } } ]
var js = list.toJS();
// [ { x: { y: 1 } } ]
```

Were you expecting something else, or are you doing something else and expecting this?
  Let me investigate this a bit more, I'm surprised no tests failed as a result of this change. It's currently documented to behave as coded before this change.
 Yeah, this breaks tests for `updateIn`. I'll update the Travis CI script to ensure it builds the distribution before it runs tests to catch these.

If you run `grunt` before pushing, you'll see the affected test cases.
  Thanks for catching this.
  Closing this aging issue - sorry I wasn't able to be more helpful. Sounds like a browser limitation for maximum properties on an object  Not to my knowledge. Though if Chrome lets you configure this, I'd love to do so.
 Nice utility! Sometimes I use a similar one which calls toString().

I also spotted https://gist.github.com/darwin/2a5651f590a4e8d55c68 which only works in Chrome canary with some flags turned on today, and allows custom formatting of arbitrary objects. Super cool, I hope we can leverage this approach soon.
 Closing this aging issue - I'd love to see a separate npm package for this. Seems like `immutable-devtools` is a good start  Yes! Thanks for writing up the whole draft of this, this has been on my wishlist for a while and I appreciate you documenting up the approach.
  In theory I agree, however I'm not sure how to go about actually doing this.
 Currently all of the higher order functions like `map` and `filter` first create iterators, then populate new instances of the same class via that iterator. The new instance has no reference to the previous nor way of making the comparison that nothing has changed.

However, if you have an idea on how to do this, I would very happily take a look at a pull request.
  Can you explain the performance issue further or share a benchmark?

The replacement will not work correctly if your key-paths are Iterables instead of Array, and I would like to preserve that behavior.

If you share a benchmark I can attempt to solve for the performance issue while maintaining the iterable keypath property.
 Thanks
 Released as v3.6.2. Thanks for the quick report.
  Thanks for the red-alert! I'll get this fixed pronto
 Fixed in 3.6.1
  This is actually just JavaScript doing it's thing. JavaScript Object keys are always strings.

``` js
var obj = {42: "test"};
// get the keys using Object.keys()
var keys = Object.keys(obj).forEach(function (key) {
  console.log(key, typeof key);
});
// get the keys using for in
for (var key in obj) {
  console.log(key, typeof key);
}
```
 More fun facts about JavaScript:

These two lines are equivalent:

```
var obj = { foo: "bar", 42: "answer" }
var obj = { "foo": "bar", "42": "answer" }
```

And property access always coerces to string!

```
obj["42"] // answer
obj[42] // answer
```
 `Immutable.Map.get` accepts any kind of input because you can use anything as a key.

For example, what should this log?

``` js
var map = Map().set(1, "number").set("1", "string");
console.log(map.get(1));
```
 Note, this is also how ES6 collections work:

``` js
var es6Map = new Map();
es6Map.set(1, "number");
es6Map.set("1", "string");
console.log(es6Map.get(1));
```
 JS Objects just aren't Maps. They're collections of properties keyed by strings. ES6 collections escape this problem altogether by not providing any tools for converting to and from JS Object.

The fact that ImmutableJS provides `toJS()` and `fromJS()` is because they're legitimately convenient, but you still must be aware of the limitations.
 In applications I've worked on at Facebook and elsewhere, we just avoid using numeric keys or at least make strong assumptions that they are strings. As an example, Facebook's API provides a unique numeric-string ID for every object in it's DB. We occasionally send them as keys in a JSON payload and need to respect that they are strings on the client, not numbers. This ends up important for other reasons as at some point our numbers got larger than the 52bit range that JS numbers can represent and also we ran into some cases where we needed to base64 encode IDs and we didn't need to change any app infrastructure to do so.
 Funny story: we used to represent ids as numbers on the client instead of strings, we even ran `parseInt()` to get them. We had a shortcut function for linking to someone's profile, setting the URL to `"facebook.com/" + id`. At some point a bug elsewhere caused IDs to be formatted slightly differently so our number parsing started to return `NaN` and all links went to my old manager's profile.
 In my opinion, you should structure your app such that that `id` will always be the same type: strings or numbers, but not both at the same time. I think having to consistently remember to coerce your `id` variables to strings with `id.toString()` or to numbers with `+id` will just be an opportunity to forget to do that once and you'll introduce a bug.

It's totally possible to create an Immutable.js Map where the keys are numbers instead of strings, it's just not representable as a JSON Object. You could also go all-in on string `id` and ensure that's the case through your whole application.
 @cesarandreu do you mean a String Map where keys are always first coerced to String? This is how JS objects work. They're not indifferent to type, they always coerce to String, which is what leads to this common misconception. 
 Is the concern that a data type that restricts key type is desirable, or is the concern that JSON is a non-ideal serialization format?
 @geekyme are you seeing an instance where a value is being coerced? That sounds like a bug, could you show some code which replicates the issue?
  Can you post the code used to generate this output so I can reproduce and investigate?
 I'll investigate any performance issues here, but just a few notes on your test case code:

`withMutations` is only really useful when doing more than one mutation. It avoids creating an intermediate collection for code like `data.set('a', 1).set('b', 2)`. Of course, for a single `set`, there is no intermediate creation to avoid.

`setIn(... getIn(...))` can be replaced with `updateIn`. In your example, these two would be equivalent, but the second line using `updateIn` will be slightly more performant since it only needs to traverse down the key path once instead of twice.

``` js
data.setIn(["a", "b", "c"], bar(data.getIn(["a", "b", "c"])));
data.updateIn(["a", "b", "c"], bar);
```

Also, since your updateIn function is simply setting, you could simply further by using setIn directly.

Here is a reduced version of your same test case:

``` js
var Immutable = require("immutable"),
    Cursor = require("immutable/contrib/cursor");

var data = Immutable.fromJS({a: {b: {c: {d: 0}}}}),
    cursor = Cursor.from(data, update);

function update (nextData) {
    cursor = Cursor.from(nextData, update);
}

function foo (data) {
    return data.setIn(['a', 'b', 'c', 'd'], 3);
}

for (var i = 0; i < 1000; i++) {
    var before = Date.now();
    foo(cursor);
    var delta = Date.now() - before;
    console.log(delta);
}
```
 Note: I just realized you're using Cursor which has a more limited API. `setIn` doesn't exist directly, so for now using `withMutations` as you are will work around, but I will add this back soon.
 Also, running the above code, I do not see an increase in runtime with each loop. Are you still seeing it for your simplified case? Or is there a more complex case that shows this behavior?
 Aha, yes. Now I understand the issue.Each call here results in two mutations - the inner set and the outer set. 

I'm not sure if this is something that can be worked around by the library directly or not, I will investigate further
 Good catch.

What's happening here is that the inner `data.getIn` is returning a cursor and then setting that cursor into the structure in `mutableData.setIn`. So now your cursor contains a cursor :). On the subsequent update you'll have embedded a cursor to a cursor. On the 1000th iteration, you're modifying a cursor of a cursor of a cursor of a cursor etc 1000 times deep.
  This library implements persistent immutable data structures. You can read about this concept here: http://en.wikipedia.org/wiki/Persistent_data_structure

The core idea is that the immutable collections have a mutative API so they can be made useful in an environment where data needs to change over time, however each mutative call always returns the result as a new object - leaving the original object unchanged.

The key thing happening in the example in your comment is `map = map.set(...)`. Here, `map.set(...)` is returning a _new object_ and that new object is getting assigned to the variable `map`.

Here's an example that might better illustrate this core idea:

``` js
var map1 = Immutable.Map({a:1, b:2, c:3});
var map2 = map1.set('b', 20);
map1.get('b'); // 2
map2.get('b'); // 20
```

Does that help explain what's going on?

I'm also curious how I could help improve the README if you were confused as to the purpose or operation of the library on first read.
 Also just updated http://facebook.github.io/immutable-js/ with the same changes.

Thanks again for bringing up this confusing example!
  Interesting!

This has come up once before and I ended up not following this path because using `has()` made things reasonable.

I imagine I will figure out the appropriate API once using more of Flow, as it cares a lot about nullability and having get() always return nullable is probably going to be pretty annoying.
 I suggest a utility function for this. I don't think it's the right call to expand the API surface area for this case - especially since many are concerned about byte size of the library.
  Event sequences are a bit of a different kind of beast from what Immutable covers. That's an example of a Stream or Observable, a concept that's out of scope of this library.

You should check out [RxJS](https://github.com/Reactive-Extensions/RxJS) which provides Observable and useful additions including Event sequences, it also includes the asynchronous versions of map/filter/etc that also are close those proposed in ES5 and ES6.
 Is there something specific you were looking for that relates Event sequences to Immutable collections?
 Unfortunately this is a different kind of lazy - asynchronousity. As you pointed out event sequences are lazy in that their values are spread out over time instead of being spread out in computation or memory. Supporting this use case would basically require re-writing all of the higher-order functions like map/filter/reduce to be asynchronous and work on a subscription rather than a computation.

Other than the names of the methods, I'm failing to see the similarity to the Immutable.js library.

For example - if you could produce a `Seq` from an event stream, what would it mean to call `toArray()` on it?
 It's usually helpful for me to start with a use case I want to enable to help articulate how the APIs should coincide. I'm not seeing one yet here.
 I would be curious to see a wrapped version first. Immutable exposes a lot so that it may be extended directly. If you built something like lazy-chain for Immutable that would be a great start to illustrate the usefulness of this.
 I'm looking forward to seeing what you build
  Good suggestion @chenglou I'll include this in the next release.
  This is a current limitation of the library. Lists aren't consumed as tuples. I agree with you that this should be possible though, so I'll leave this task open until I can investigate.
 This was fixed in the [v3.7.0](https://github.com/facebook/immutable-js/releases/tag/3.7.0) release 
  Yes! I have this working almost all the way using the really nice esperanto project. I've got some work to do to leverage import/export syntax correctly, since I use circular dependencies in a way that smash handles but ES6 does not. Then I am going to tackle this. 

I appreciate you opening the task to keep track! I'll post progress here. 
  ``` js
var iterator = myCollectionOrRange.values();
var step = iterator.next();
while (step.done !== true) {
  // do something with step.value
  step = iterator.next();
}
```
  Thanks for finding this and great suggestion on the fix. I implemented almost exactly what you recommended and added this example as a test case.
  Can you clarify - is this fixing an issue with typescript or an issue with browserify?
 Really strange. I'm curious, did you open an issue with browserify? This seems like a case they should be able to identify and correct for.
 Thanks for the investigation and fix by the way, clean and well explained.
  Closing as a dupe of #256 but thanks for the reminder to release a minor version on npm soon. 
  ES6 is the latest standard of JavaScript. The library is written in it as are the examples. While they can only run verbatim in the latest versions of Chrome or Firefox, they can be "transpiled" into ES3 which runs on all browsers being used today. The library itself is transpiled in this way for distribution on npm. 

The only feature of ES6 that are used in examples are Arrow Functions, which make code using inline functions much easier to read and understand. 

I'll keep this open to track adding a disclaimer about ES6 in the Readme
 Correct, @quarterto. Only a subset of ES6 features can be transpiled to ES3. Full featured ES6 can be supported by ES5. Immutable is written in this subset of ES6, and the feature in question (arrow functions) can be converted to ES3.
 Haha @paulcbetts caught you @rpflorence! :D

Arrow functions are one of my favorite features of ES6 and once you're used to them, make writing code with inline anonymous functions easier to read. It's not quite the same as JSX, though I definitely understand the comparison. JSX is an unofficial syntactical addition, but ES6 is the next official version of JavaScript which many modern browsers are now (partially) supporting.

I definitely understand the concern about adding the mental leap of understanding arrow functions to learning this library via the examples. However my hope is that the mental leap isn't too high and that once understood the rest of the examples will be much easier to read.

And if arrow functions aren't for you, that's just fine, you don't have to use them in your own code. Nothing about Immutable (or any other JS library for that matter) will require the use of them.
 Added some clarification to the readme and docs with e4666952f0718f3abf716bb9f2fe07f658f4a134.
  Only integer values are considered for the hash function. Decimal values should also rotate the hash. 
  Not always, no. Hash codes are inherently lossy - you're cramming unknowably large amounts of info into a 32 bit number. This is referred to as [Hash Collision](http://en.m.wikipedia.org/wiki/Hash_collision).

Here's the mental heuristic:

If two hash codes are unequal: the values are _definitely_ unequal.

If two hash codes are equal: the values are _maybe_ equal. 
 Also, what you've come across is an artifact of the hash code function: decimal values are discarded to compute them. I'll open a related issue to improve the hasher 
 #266 tracks it
  I'm also finding trouble coming up with a name for this which makes it clear that this will only delete the first instance of the value, not all instances of the value.

For now I don't think it's right to add it to the library since the helper function is quite small, and it's also unclear if the correct behavior is to throw or return the unchanged list. 

I'll keep it in mind in the future though.
  Good suggestion. I think default to no cache is still best to make chaining operations easier to build, but a cacheGets could be pretty interesting
 I would be happy to look at that PR!
 Sounds like the discussion in this issue has concluded so I am going to close it. Thanks folks!  Yes, all collections in this library, including Seq, implement the ES6 Iterable interface. 

One note is that they will follow the browser specific interface as some pre-ES6 browsers do not support Symbol. 

Here is a browser agnostic way to get an Iterator from an Iterable:

``` js
var iterator = iterable[typeof Symbol === "function" && Symbol.iterator ? Symbol.iterator : "@@iterator"]();
```
 ``` js
function getIterator(iterable) {
  return iterable[typeof Symbol === "function" && Symbol.iterator ? Symbol.iterator : "@@iterator"]();
}

var it = getIterator(iterable);

console.log(it.next());

```
 I'll consider this, but will probably stick to the ES6 API. It's agreed upon and it's uncommon to create them manually like this. 
 `values()`, `keys()` and `entries()` exist on all Immutable.js collections, mirroring the same methods on ES6 Map and Set. They've been in the library for some time.

However, this is not the same as the "default iterator" function (equivalent to `values()` for indexed collections and Sets, but equivalent to `entries()` for Maps).

These functions also are specific to collections and won't be found on any generic iterable where the `getIterator` function I provided above will always use the default iterator and will work for any generic iterable, not just those found in this library.
  Definitely not normal. When I run your code sample I get a Map back, which is what is expected, so I cannot reproduce this. What browser version are you using with what version of immutable?
  It would help to see some code which is causing this error, but my assumption is that you're returning an immutable Map from `getInitialState`. React expects `state` and `props` to be JS Objects when it operates on them internally.

It's semi-safe (in the current version of React at least) to return Map directly from getInitialState:

``` js
React.createClass({
  getInitialState() {
    return Immutable.Map();
  },
  ...
});
```

however, if you use mixins which provide `getInitialState` themselves, React will apply it's assumption that state is a JS object and call [Object.assign](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign) with all values returned from all `getInitialState` implementations in order to merge them together. Since Immutable Map does not behave as keyed object, Object.assign will not do what you hope.

The solution is to either only return immutable Map from getInitialState when not using mixins, or to have a single key in your state:

``` js
React.createClass({
  getInitialState() {
    return { data: Immutable.Map() };
  },
  ...
});
```

Does this make sense?
 Thanks for bringing up this edge case, I updated the wiki page to better illustrate this.
  There is no way (intentionally) for immutable persistent data structures to contain circular references. Immutable structures can contain circular references, but in order to be persistent and take advantage of structural sharing, they need to be acyclic. The stack-overflow you link to illustrates this well - showing how a double-linked list needs to make a complete copy in order to perform an append operation.

There are some other problems that emerge from circular references in values, such as deep equality checking and hash-value computation.

Languages based on immutable structures handle this in different ways:

Scala has `lazy var` which is pretty much what you wrote up here. A deferred memoized function.

Clojure has `atom` which is a bit different (and easier to understand IMHO). Atom is an atomically locked mutable wrapper. Since JavaScript is single threaded, no locks are necessary so it's only a mutable wrapper. In other words: `{ value: "foobar" }`.

For equality and hashing, Atoms are treated as Objects not as Values. So `{ value: "A" } !== { value: "A" }`.

So you might treat this like:

``` js
var node0 = I.Map({ prev: null, next: {} })
var node1 = I.Map({ prev:  {value: node0}, next: {} })
node0.get('next').value = node1;
var node2 = I.Map({ prev: {value: node1}, next: {} })
node1.get('next').value = node2;
var node3 = I.Map({ prev: {value: node2}, next: null })
node2.get('next').value = node3;
```

---

However, both approaches: lazy function or atom object are totally fine! This data structure library has no opinion on either, you just need to be aware of their use so you can treat them appropriately:

``` js
// Lazy function
node3.get('prev').get();
// Atom object
node3.get('prev').value;
```
 For those looking for an implementation of Lazy evaluated variables, try this:

``` js
function lazy(fn) {
  var didRun;
  var result;
  return { get: () => didRun ? result : (didRun = true, result = fn()) };
}
```

Usage example

``` js
var lazyFoo = lazy(() => "foo");
console.log(lazyFoo.get());
```
 I'm currently not sure baking this concept into the library, and changing the `get` definition to evaluate the lazy function is the right thing to do, as it would have pretty serious implications and possibly introduce bugs or at the very least confusion on equality checking and hash computation.

At this point I think it's reasonable to assume if you're using lazy values to determine for yourself when the lazy function should be evaluated.
 I'll definitely considering adding true support for lazy values in the future, but I would prefer to see such a thing used outside the library first to better understand the implications before baking it in.

If you end up patching Immutable to add this functionality, I would be really interested in hearing about the unexpected issues and opportunities you run into.
 Circular references break a lot of promises that immutable data provides, so I don't think I plan on accounting for them. 

You can read a more lengthy explanation of the issues with circular references via manual mutation written up in the "transients" section of the clojure documentation. 
 Closing this for now - I think this is going to be really hard to do without language features.
  I really appreciate the pull request, but yes you've entered into dangerous territory when it comes to avoiding ambiguity.

Map can use anything as a key, strings and numbers, arbitrary objects and arrays, other Maps and Lists.

Here's a simple example which uses an array as a key:

``` js
var arr = [1,2,3];
var map = Map().set(arr, "123");
map.get(arr); // "123"
```

Here's an example where splat creates ambiguity:

``` js
var list = List.of("A", "B", "C");
var map = Map().set("A", Map().set("B", Map().set("C", "123"))).set(list, "abc");
var value = Cursor.from(map).cursor(list);
```

Is `value` a cursor to `"123"` or `"abc"`? While this contrived example illustrates how this might be confusing it's at least currently non-ambiguous. Currently this points to "123" because the keypath is always an iteration of key values. If it were _always_ a splat then it would point to "abc" - but because it could be either a splat or list depending on the value (or as proposed, number of arguments) then it becomes ambiguous.
  wasAltered isn't safe to use in client code right now. It's undocumented because it behaves differently in some scenarios and is used as an optimization internally for a few explicit paths. If you're using it, your code could break when updating to future versions. 

I'm trying to better understand the use case, I originally had an isMutable method and decided to remove it when some reviewers pointed out how it could be commonly abused.

One scenario I considered was having "asMutable" and "withMutations" provides special "builder" object with a different API. Instead of the full Map/Record/etc API, they would be write only and only have "set", "merge" and "delete" methods. This would just simply exclude the ability to have custom caching methods or any internal methods relying on immutability go awry. Thoughts?
 Can you share some code illustrating how you're using these methods? I may be able to give better advice
 I'm curious how close this contrived example is to your use case. Not to divert too far from what we were discussing, but in that example file, I bet you would see better performance from not caching the result since some math operations are bound to be faster than the cache lookup, let alone avoiding creating a new anonymous class.
 Closing this since it's aging, but caching utilities is still an open area of discussion
  Can I ask why you were expecting `undefined` as the return value?

I think right now, when providing `undefined` as a key-path, it's interpreted as the empty key path. I don't have a strong opinion about this being The Right Way, so I'm open to a discussion about it.

Another approach may be to consider `undefined` an illegal input and throw an exception instead. What do you think of that?
 Ok, I hear the consensus for this being illegal input and I agree.
  There's a common pattern used in the cursor callback which protects from accidental updating from an expired cursor:

``` js
var state = ...;
var cursor = Cursor.from(state, ..., function (newState, prevState) {
  if (prevState != state) {
    throw new Error('Attempted to alter an expired cursor.');
  }
  ...
});
```

I think this pattern is a nice protection against the type of ugliness that you're running into.

With this pattern, your first `p1 = p1.set(...)` will execute as expected, at which point `p2` now refers to an old version of your state ("expired") and is not safe to use as an update point.

To update from two cursors, you would need to recreate the `p2` cursor from the new state before using it to update the top-level state.

Does this make sense?
 Yeah, as it stands there is no way to use an expired cursor to update the top level data structure since the expired one does not relate to the new data structure.

Yes, you could create a new `p2`, but you could need to refer to the parent structure to create it. `p1` does not have the information necessary.

Your example:

``` js
var state = Immutable.fromJS(
  {points: [{x: 3, y: 0}, {x: 7, y: 0}]}
);

var points = Cursor.from(state, 'points', onChange);
function onChange(newState, prevState) {
  if (prevState != state) {
    throw new Error('Attempted to alter an expired cursor.');
  }
  state = newState;
  points = Cursor.from(state, 'points', onChange);
});

var p1 = points.cursor(0);
var p2 = points.cursor(1);

var newX = (p1.get('x') + p2.get('x')) / 2; // newX -> 5

p1 = p1.set('x', newX);

// p2 is expired now, so we need to make a new one:
p2 = points.cursor(1);
p2 = p2.set('x', newX); //state: "Map { points: List [ Map { x: 3, y: 0 }, Map { x: 5, y: 0 } ] }"

// note at this point, p1 is expired as well.
```

In practice, people often create cursors in the process of rendering components for React or another top-down renderer. Using one of the modification methods of a cursor then results in re-rendering from the top (and therefore all new cursors).

Using this pattern, there's another issue with updating from two cursors in quick succession. Updating the first could cause a re-render, so updating p1 followed by p2 could cause two re-renders without some other synchronising element.

---

My advice is to avoid this altogether by moving one level up when making edits with `merge` or `withMutations`.

In this example:

``` js
points.merge([{x: newX}, {x: newX}]);
```
 You should see if setIn and updateIn will do what you're trying to do.
 I'm not sure I understand the purpose of `dissect`, but most uses of `select` can be done via `updateIn` and `map`. 

For your example:

``` js
// 1. get the current diagram to operate on as a cursor
var diagramCursor = getTheDiagramToOperateOn(state);

// 2. operate 'under' the cursor
diagramCursor = dissect(diagramCursor,
  select('components',
    select('legs', function (leg) {
      if (/* this is the object I'm looking for */) {
        // then do some things here
      }
      return leg;
    })
  )
);
```

might instead be written as:

``` js
// 1. get the current diagram to operate on as a cursor
var diagramCursor = getTheDiagramToOperateOn(state);

// 2. operate 'under' the cursor
diagramCursor = diagramCursor.updateIn(['components', 'legs'], legs => legs.map(leg => {
  if (/* this is the object I'm looking for */) {
    // then do some things here
  }
  return leg;
}));
```

does that work for you?
 Closing this since it's aged
  Immutable works with anything which follows the iterable or iterator interfaces. So I might build Fibonacci iterator like so (ES6):

``` js
var x = 0, y = 1;
var fibIterator = {
  next() {
    [x, y] = [y, x + y];
    return y;
  }
};
```

Then I can use it anywhere Immutable expects a sequence of input, or I can explicitly turn it into a Seq:

```
var fibSeq = Immutable.Seq(fibIterator);
```

Note: iterators can only be run once. Iterable can create iterators on demand, so if you need to use the sequence more than once, define an iterable instead.

``` js
var fibIterable = {
  '@@iterator': function() {
    var x = 0, y = 1;
    return {
      next() {
        [x, y] = [y, x + y];
        return y;
      }
    };
  }
};
```

Does this answer your question? Would you like to see something more specific in the Seq API?
 Another methods which might satisfy this is Range + map:

``` js
var naturalNumbers = Immutable.Range(); // no args means 0 to Infinity
var squareNumbers = naturalNumbers.map(n => n * n);
```

I'm not too familiar with lazy.js's generators. I'll have to read up.
 From lazy.js's docs, here is lazy.js generator:

``` js
var fibonacci = Lazy.generate(function() {
  var x = 1,
      y = 1;
  return function() {
    var prev = x;
    x = y;
    y += prev;
    return prev;
  };
}());
```

note the parallels to JS ES6 Iterator that Immutable prefers.

Here's an Iterator Seq which will have the same behavior as the lazy generator above.

``` js
var fibonacci = Iterable.Seq(function() {
  var x = 1,
      y = 1;
  return {
    next() {
      var prev = x;
      x = y;
      y += prev;
      return prev;
    }
  };
}());
```
 Seq() accepts an Iterable or iterator, not a function. Note in my examples, I'm providing an object with a next() method (the iterator pattern). 

If you want to provide a function which is passed "n", then you should map from Range.  E.g. Your memoized fib example:

var __fib = Immutable.Range().map(fib)
  Currently the update function is called whenever any of the updating methods are invoked, regardless of if they resulted in a change or not. The user of the API is responsible for applying any optimizations when `newValue` is different from `prevValue` in the updater.

It may be reasonable to skip calling the update function when no change occurred, what do you think?
 After talking to some others, there's a sense that leaving it as is makes the most sense since adding this as an optimization is easy, but taking it away is not and potentially confusing.
  Sounds like #111.

Can I ask your use case? Since this has come up a few times, I want to take it seriously, but I also want to be sensitive to the use case of complex objects (including functions) as keys:

``` js
var fn = x => x % 2 == 0;
var map = Immutable.Map([[fn, 'isEven']]);
map.updateIn([fn], 'evenPredicate');
```

In that case, you have a `Map<function, string>` and updateIn should use the function as a key not as a mapping function.

I've also heard the argument that this could apply to `List` only, since only integers can be keys and there is no ambiguity, but then there is different behavior for the method on each.

All in all, a fairly tricky edge case to address, but this does seem like potentially valuable functionality. I'm just collecting use cases so I can think about the best way to introduce it that supports what people are after.

(Closing, to move open task to #111)
  Thanks for the report. Weird merge conflict ate it. I'll have it up in the next bug fix release asap
  This may be a bug, I will investigate
  :+1: good suggestion
  I'm not sure I agree with the condition here. I'm not sure why the default value being iterable or not should affect the semantics of the updater function.
 I'm not sure there's a smooth way out of this. It would be helpful to know all the use cases to support so that we can create the best API for all cases without creating too much confusion.

For the original `cursor.set()` case, I think it makes sense to ensure that setting `undefined` works correctly. Also `x.setIn([path], undefined)` should set `undefined` at that path.

Are there other use cases of `updateIn` that you're coming across where you expect an identity function to result in setting `undefined`?
 For the code sample there, what is the expected result?
 I'm not sure I agree with that. Perhaps this is just a point of confusion in the API. For this method, the `notSetValue` argument means the value that will be provided as input to the update function should a value not be found at that path. This is most often useful when the updater operates on a specific type of value, and you want to provide a default value of the same type.

For example, if I was counting frequency of words, I might have a Map of strings to numbers, and my update when I encounter another word might look like:

```
wordFrequency.update(foundWord, 0, count => count + 1);
```

For the first line of your last comment, I would expect no change to occur because it's an identity function, and that's one of the held properties of the update methods - identity functions should represent no change.

The second line of your code uses a variable named `notSetValue` in a different way (hence why I think this may be due to confusing documentation) - in that case it's implying "If a value was not set here, set it to this". That's the current implementation of `setIn`, actually.

Does that make sense?
 Thanks again for the thorough investigation and discussion. I added some preliminary improvements to the documentation for this method, but will keep thinking about how to improve it. This also led to a find and fix of a bug in setIn. This is how the library improves!
  Hmm, this is indeed a tricky case. We want to be able to differentiate between the value `undefined` and the concept of not being defined, given a function. Unfortunately we don't have discrete values to differentiate them, so this is pretty tricky.

@Dashed can your use case be solved by using `setIn` instead of `updateIn`? The fix there is quite clear, but I'm still not quite sure what the best way to solve `updateIn` is.
 I closed this with a fix to Cursor#set and Iterable#setIn as I think the appropriate solution for this specific case is to be using `set` instead of `update` when you explicitly want to set a value to `undefined`.

So, a variant of the original code which should behave correctly after this fix:

``` js
var map = Immutable.Map();

var cursor = Cursor.from(map, function(newRoot, oldRoot, path) {
    console.log('newRoot', newRoot.toJS());
    console.log('oldRoot', oldRoot.toJS());
    console.log('path', path);
});

// newRoot { a: undefined }
// oldRoot { }
// path [ 'a' ]
cursor.set('a', void 0);
```
  Nice. Good idea
  Does https://github.com/facebook/immutable-js/releases suffice?
 No problem! I'm glad I could answer the question
  The current purpose of Cursor is to provide a transparent wrapper around an actual value in order to globally track changes. Code which consumes the Cursor should not know that it consumes the Cursor.

Can you explain how you are using Cursor differently which supports making these properties public? Knowing the use case will help me understand the best way to expose this information.
  Thanks!
  Thanks for the report. I'll dig into this.
  Considering that we would be limited to strategies that are persistent, this might be a little bit hard to follow for most. Would specifying custom properties be sufficient? Such as saying "sorted" instead of "red-black tree". 

How would you envision the API for what you're suggesting?
 Closing this - a separate task tracks the desire to add sorted collections.
  I prefer not to take a dependency on another library and keep Immutable as simple as necessary. I also have worries about future conflicts or confusion since keys are often strings. Finally, map keys may be complex, not only strings, and this format cannot support those keys.

My suggestion for this case is to use a small wrapping function so you can use this notation:

```
var ptr = require('json-pointer').parse;
// ...
var cursor = Cursor.from(data, ptr('/a/b'), onChange);
var deepValue = value.getIn(ptr('/a/b/c'));
```

The other reason I prefer this approach is because it is easier to describe the types. If `getIn()` accepts `Array<any>` and `ptr` is defined as `ptr(path: string): Array<string>` then `getIn(ptr('/a/b/c'))` can be easily understood by a type analysis tool like Flow or TypeScript.
 This isn't a question of which dependency to take, but rather that this library seeks to remain dependency-less. 

Also, performance is a primary concern, and in past performance tests we found this parsing step to be a serious perf regression on getting values. 

If it's important to you to use a path notation, then more power to you, it's easy to compose functions together to do just that, but I don't think it's the right trade-off to introduce a performance regression for those who don't need this feature
  This is part of why I'm concerned about allowing `length` on `List`. It means something specific in JavaScript as part of "array-like" which implies bracket notation access with numbers.

For example, this idiomatic JavaScript code illustrates how a List could be misidentified:

``` js
  if (arraylike.length > 0) {
    var first = arraylike[0];
    console.log(first);
  }
```

A lot of the JavaScript core library treats "array-like" as a special case which can change behavior. We want to ensure that the JavaScript core library doesn't start treating `List` as an array-like, otherwise we will see a bunch of github issues opening like "JavaScript thinks my `List` is full of `undefined`".

Now, ideally we could just embrace this. We could make List an array-like, support `length` and more importantly support bracket notation for reading from the List. Unfortunately without [Proxy](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy) objects there is no way to do this. Proxies are only supported by a few bleeding edge new browsers and are not polyfill-able.

I'm absolutely open to suggestions about how to solve this.
 I truly agree, @astorije. I would love for a common interface, I just have yet to find a way to make that happen.
 According the ES6 spec, `Promise.all(List.of(p1, p2))` should work just fine:

https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/all

Promise.all is specified to accept an `iterable`, which all of the Immutable collections satisfy.

(Which means if you're using a Promise library, and this doesn't work, that library has a bug.)
 However, also note that the spec says that while Promise.all accepts an `iterable` of Promises, its result is an **`Array`** of the results of all the Promises. If you want the result of Promise.all to be an Immutable List, you'll need to explicitly construct one from the result.

Here's a helper function that will do that for you which you can use in place of Promise.all if you want to ensure it's Immutable List in, Immutable List out:

```
function immutablePromiseAll(promises) {
  return Promise.all(promises).then(Immutable.List);
}
```
 Here's a jsfiddle which should help as a basic test for this:

http://jsfiddle.net/exc8vbhc/1/

Currently it passes in latest Firefox but fails latest Chrome.
 Filed: https://code.google.com/p/chromium/issues/detail?id=441175
 The bug I filled with chromium is actually a v8 (hence node) bug. Node's Promise does not follow spec
  Thanks
  Yep, you want `set` and `setIn`
  I think the behavior should be same as `Math.max.apply(Math, list.toArray())` which is not order-dependent. So thanks for pointing out this discrepancy.

However, I'm not sure that NaN and friends should be ignored. NaN has significance when used in math operations - the result of a math operation in which NaN is an argument should always produce NaN. It's a way of bubbling error conditions up through nested operations.
  `instanceof` is just too underpowered to do what you want to do here. It requires a single chain of prototypal inheritance. We would just end up tipping the scale in each direction as we try to support every case.

The nice thing about React propTypes is that they are just validation functions in the form:

```
type validator = (props: Object, propName: String, componentName?: String): ?Error
```

So you can define your own! You don't need to use `React.PropTypes` for every case.

You can see how React defines the set it ships with here:

https://github.com/facebook/react/blob/master/src/core/ReactPropTypes.js

But let's see what we would want to do for Immutable types. We don't want to explicitly state that it wants a Cursor if we can avoid it (it should be transparent to our React components if we're providing values vs Cursors to values) so instead lets just check to see if it's Keyed:

```
function propTypeImmutableKeyed(props, propName) {
  if (!Immutable.isKeyed(props[propName])) {
    return new Error('Expected ' + propName + ' to be Keyed');
  }
}
```

Does this suffice?
 Tracking this in #509
  Don't worry. I'll make this happen soon, the docs aren't linked too yet because they're not quite done. 
  I'm getting really close too! It's gunna be a good thing
 Closing because http://facebook.github.io/immutable-js/docs/
  Can you provide some code sample illustrating the issue and what you expected? I don't completely follow.
 Gotcha, thanks.

I think the issue here is that there are only a few methods which are safe to use on mutable copies, and while remove is safe to use on mutable Map, it's not same on mutable List.

I'm not sure yet what the right fix for this is yet.

---

> Okay I realize this question may be semi-flawed CS-ically because we probably want to go with a whitelist approach of building a new list using .filter() or something rather than chaining removals, as positions change after every single remove mutation.

I think this is exactly right. Under the hood, `remove()` is a simple filter to exclude one index. Filters always create new collections and can't modify mutable versions.
  This is clever. Let me think about the implications of this a bit more.
 Yeah, I'm really sorry for not keeping you apprised, Tim. The benchmarking
suite was a pre-req for this to make sure we don't regress. I'm sure
there's a way to do it, and now we can measure different approaches!

Lee Byron
[ lee@leebyron.com | (317) 460-9114 | www.leebyron.com ]

On Mon, Jan 19, 2015 at 9:33 PM, Tim Griesser notifications@github.com
wrote:

> So I updated this to latest and ran that new perf suite, looks like this
> branch takes a pretty substantial hit ~50% or more on each of the tests.
> 
> So unfortunately this doesn't look like it's the best approach, though
> figuring out some way to do this eventually would be really cool - the
> ability to have custom types for Maps/OrderedMaps has proved quite
> convenient in our application.
> 
> â€”
> Reply to this email directly or view it on GitHub
> https://github.com/facebook/immutable-js/pull/227#issuecomment-70595441.
  Sorry for the delay in answering here.

I'm not sure what the value of `defaultItem` is, but if it causes the updating function to behave as an identity function, then no update will occur by design.

Since this task was opened, I've updated the documentation of `updateIn` to hopefully explain this behavior a bit more clearly.
 Updated the documentation recently to suggest using modern function param default values instead of notSetValue - it helps avoid this API corner case.  I just want to pick one and be consistent so you don't need to think so much about which to use.
 Sure, go nuts. You might want to start with the ones I've already written for Jasmine.

https://github.com/facebook/immutable-js/blob/master/__tests__/Conversion.ts#L24
 The day we can reasonably do array-like bracket access (ex. `myList[2]` instead of `myList.get(2)`) then I think we should support `length`. Otherwise, I fear that Immutable.js Lists would suffer from incompatibility with code that expects a non-zero length to imply that bracket access will work, which I think will be surprising in the worst way. Some minor awkwardness to avoid that pitfall is probably the right thing to do IMHO.
 There used to be a warning during the transition away from using it - but even that warning resulted in issues with integration in other codebases that sniff for types, such as the dev tool console.

If you're looking to avoid accidental usage issues, I strongly recommend using Flow or TypeScript  See https://github.com/facebook/immutable-js/wiki/Predicates
  map.keys() gives you an iterator of keys. 
map.keySeq() a lazy seq (Iterable) of keys. 
map.values() iterator of values. 
map.valueSeq() a seq of values. 

These exist for all collections, not just Map. Full descriptions of each are in the type documentation. 
  Yes, except it's JavaScript, so "homogeneous" only means something when a type system like Typescript or Flow is applied. JavaScript is dynamic with loose types.Â 

For example, you could type your example as List<any>, and in fact TypeScript or Flow would infer that without you having to type it.
 Another way to say this is that no runtime type checking is done by this library.Â 

Does that clarify?
  I agree this should be possible. Adding this to my TODO list.
 Merging into #301.
  Thanks for highlighting this. The correct fix is probably to make sure filter (and related methods) aren't methods of Record
 Merging into #505   I'll try to make this more clear in documentation, `b:` here points to a mutable object, so we can say that `map` is immutable but not _deeply_ immutable. It may contain references to mutable objects. The reference itself may not be changed, but of course the mutable object itself may change.
 A terse way to describe this same case:

``` js
var mutable = { foo: "bar" };
var map = Immutable.Map({ ref: mutable });
map.toJS(); // { ref: { foo: "bar" } }
mutable.foo = "baz";
map.toJS(); // { ref: { foo: "baz" } }
```
  A List is a concrete data structure. It actually stores values in memory. A Seq is a lazy operation representation. You can think of it as a very light-weight container of a previous Iterable and some operation to apply (map, filter, etc), that operation is applied only when necessary to get a value. Seq doesn't store any values itself. 

Most of the time you want to use List. Seq is useful for making complex operations from List to List more efficient. 

This library could exclude Seq and keep working just fine, it's a tool for performance. However List is vital to the library.

Does that answer your question?
  This also came up in #198 so I figured it's worth documenting this:

https://github.com/facebook/immutable-js/wiki/Converting-from-JS-objects

Let me know if that answers your question!
 And always does what you expect :)
 Good catch!

I updated the wiki
  document `valueOf`, `equals` and `hashCode`.
  This works today! If you have a case that isn't working correctly please let me know as that would be a bug.Â 

â€”
Sent from Mailbox

On Sun, Nov 23, 2014 at 6:19 PM, Dave Tonge notifications@github.com
wrote:

> Thanks for the library - I've been playing around with it, but for my use case I need the ability to use complex types as keys for maps, i.e. to use a Map as a key for another Map. 
> [ES6](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map) does this, as does [Mori](http://swannodette.github.io/mori/#hash_map). Do you know if this is on the roadmap?
> 
> ## Thanks 
> 
> Reply to this email directly or view it on GitHub:
> https://github.com/facebook/immutable-js/issues/215
 Closing this issue since this implemented. If there is a specific bug please just reopen with a reproduction case!
  This is intentional. 

The only reason concat behaves the way it does is for behavior matching with Array, but it should really be treated as accepting `Iterable<T>` because of ambiguity pitfalls. unshift and unshiftAll are explicit about the type they accept: `T` and `Iterable<T>`, respectively. Strings are iterable, so this behavior is intentional. If you want an intelligent swapping of behavior, you should use a small helper function to check Array.isArray or something like it before using one or the other.

Stack() and Stack.of() have similar explicitness of the type they accept. Stack() accepts `Iterable<T>` while Stack.of() takes vararg `T`. So there are no ambiguous cases.
 If you want stack creation to treat the string as an iterable, use Stack() constructor, which will iterate out each character, as unshiftAll does. 
 For the use you're suggesting, I would recommend a helper function such as:

``` js
function listFrom(maybeList) {
  if (Immutable.List.isList(maybeList)) {
    return maybeList;
  } else if (Array.isArray(maybeList) {
    return Immutable.List(maybeList);
  } else {
    return Immutable.List.of(maybeList);
  }
}
```

This way you have clear control over each case and how it should behave relative to the type of input you expect for your function. You can of course swap out `Stack` for `List` above and have it behave the same.
  What if the return value wants to be falsey or undefined? It seems like this implementation would discard it.

For example, maybe I want to use this enhancement to make sure the cursor to my "a" key is always an even number. This test will fail, because the return value `0` is treated as falsey and so the new value will continue even though my validator said it should not.

```
var data = Immutable.Map({a:0});
var cursor = Cursor.from(data, ['a'], (newValue, prevValue) =>
  newValue % 2 === 0 ? newValue : prevValue;
);
cursor.update(() => 1);
assert(cursor.deref() % 2 === 0);
```
  Sorry for not seeing this before.

This seems like a good idea, but I'm a little bit concerned about applying the heavy weight of OrderedMap without option. I think it may be best to remain ordered though.
  Slick!
  This is great, thanks!

You've got it the right way, it's based on [JSON.parse/reviver](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/parse#Example.3A_Using_the_reviver_parameter)
  Thanks.Â 

Feel free to propose a fix with pull request if you're up for it!

â€”
Sent from Mailbox

On Thu, Nov 20, 2014 at 6:36 PM, Francisco Ryan Tolmasky I
notifications@github.com wrote:

> In Immutable.d.ts the following is listed as an example for using fromJS:
> 
> ``` javascript
> Immutable.fromJS({a: {b: [10, 20, 30]}, c: 40}, function (value, key) {
> var isIndexed = Immutable.Iterable.isIndexed(value);
> return isIndexed ? value.toList() : value.toOrderedMap();
> });
> ```
> 
> If you try running this however, you get:
> 
> ```
> return isIndexed ? value.toList() : value.toOrderedMap();
>                                           ^
> TypeError: Object  has no method 'toOrderedMap'
> ```
> 
> ## In my own dealings with fromJS I also experience this. For arrays I'm getting a Seq that responds false with isIndexed.
> 
> Reply to this email directly or view it on GitHub:
> https://github.com/facebook/immutable-js/issues/208
  Fixed in master, will be released on npm soon.
  Merging into #51
  Seems reasonable. Let me dig in to see just how difficult this will be :)
  Hell yes
 TypeScript predates Flow by a while, so when I started this project Flow didn't yet exist. Also, the type definitions are not here for the benefit of the library, but for the benefit of people using the library with these type checking tools. Since a lot of people use TypeScript (myself included) it felt like the right thing to do to include type definition files for it.

Once I get the Flow type definition files, the TypeScript ones will remain in the repository and up to date as well!
 Sorry for the delay. I'm excited to see progress on this. Nice work.

How have your flow definitions been working? Are there any holes?
 The flow team is working on the magic auto-conversion, but it's possible that it will be lossy, so the plan will be to update both manually.
 Supporting the *In methods would be awesome @samwgoldman, let me know if/how I can help you accomplish that
 Sorry this issue should be closed. Flow types were added in the last major version. 

See: https://github.com/facebook/immutable-js/blob/master/type-definitions/immutable.js.flow
  I'm not able to reproduce this issue. What environment are you using? (OS & Browser version)
 Also, can you post some code as a jsfiddle or requirebin that illustrates the problem?
 I think I might understand what's happening here, though I still haven't managed to get code to run which reproduces the error.

I'm not super familiar with Reflux, so let me know if this makes sense to you:

It looks like Reflux is supplying the Immutable instance by using setState, which React expects to be a simple object, as it will do a shallow merge into the previous state. Instead replaceState must be used.
 Here is an example: http://requirebin.com/?gist=e3673062232a500f1ecb
 Closing this issue then, since it's not an issue with Immutable, but with Reflux
  Is this a common pattern for you? I'm curious of a championing use case.
 Great example, thanks.
  How about this?

``` js
function tee(v) {
  console.log(v);
  return v;
}

Immutable.List([1,2,3,4,5]).map( x=> x + 1 ).map(tee).map( x=> x + 1 ); 
```

outputs:

```
2
3
4
5
6
List [ 3, 4, 5, 6, 7 ]
```

is that what you're looking for?
 Or if you want to print the whole list at that point, you could use the same printing identity function as a whole updater:

``` js
function tee(v) {
  console.log(v);
  return v;
}

Immutable.List([1,2,3,4,5]).map( x=> x + 1 ).update(tee).map( x=> x + 1 ); 
```

outputs:

```
List [ 2, 3, 4, 5, 6 ]
List [ 3, 4, 5, 6, 7 ]
```
 Closing this, reopen it if this didn't answer your question.
  Thanks!
  Currently there is not. I want to ensure that exotic objects (Date objects, DOM nodes, user-defined special things) don't get converted unintentionally.

However, the implementation of fromJS is really quite small, so making your own version with semantics custom to your environment would result in a fairly small utility function.

``` js
function fromJSGreedy(js) {
  return typeof js !== 'object' ? js :
    Array.isArray(js) ? Immutable.Seq.Indexed(js).map(fromJSGreedy).toList() :
    Immutable.Seq.Keyed(js).map(fromJSGreedy).toMap();
}
```

Or a version which turns array-like things into lists instead of strictly Array:

``` js
function fromJSGreedy(js) {
  if (typeof js !== 'object') {
    return js;
  }
  var seq = Immutable.Seq(js).map(fromJSGreedy);
  return Immutable.Iterable.isIndexed(seq) ? seq.toList() : seq.toMap();
}
```

Does this work for you?
  Now that we have `Immutable.isOrdered`, we should respect it as much as possible. For minimal impact, the initial implementation of ordered-ness for the lazy Seq type is always ordered, however it would be better to be smarter and inherit this property from the parent iterable.
  This is an area which needs better documentation. `splice` is actually not a mutative operation and can't be used within `withMutations`. 
 I'm leaving this open, and retitling it.
 `set` and `push` are the only safe operations to call within `withMutations`. In a future major version of Immutable, this example code will throw an error to make that more clear. Since these are unsafe to use in `withMutations`, they're simply not doing anything.

Also just to make sure you're aware of what's built here - you have an immutable list of mutable objects. For the example that you're illustrating here, it doesn't much matter. But if you ever edit any of those objects you are editing them wherever they are referenced since they're mutable.
 Link?
  Not newly broken... just poorly defined.

3.1.0 added a performance optimization which can possibly change the iteration order of it's keys. Since Map iteration order was always undefined, this should be safe.

The issue you found here is that our equality checking is asserting that iteration order is part of equality. Of course, if a Map has undefined iteration order, then you can't possibly compare the equality of two Maps. Oh shit!

Added an `Immutable.isOrdered` predicate to express at runtime which iterables have defined iteration order in d1c37bce449c52cf67156341e1dd0a3cbd57d570

Then `Immutable.is` and `myIterable.equals(other)` respects `isOrdered` in 79e903b986b2dcef24f5200287fc92c1b7d11810

Thanks for finding this!
 Released 3.2.0 with these revs.
  Yep. This is a tradeoff between possible leak (if it leaks is actually dependant on usage) and performance. OrderedMap#remove is currently O(log32N). We can guarantee limited memory consumption, but it would change OrderedMap#remove to be O(N).

Also, FWIW, this implementation is the same as Webkit's implementation of ES6 Map (a lookup table along with a sparsely-used list). https://github.com/WebKit/webkit/blob/master/Source/JavaScriptCore/runtime/MapData.cpp
 I'm open to suggestions here.
 It was also broken before that change :)

There isn't an equivalent to replaceAndPackBackingStore but there probably should be. Thanks for pointing that out!
 Fixed by e1b5fe492e747c2d788326595e648e6e08a8c2e8
  Thanks for reporting this! JS arrays coerce numeric strings, so I did the same.
 This is more complicated. Integer and string keys are both valid for Map. "3" and 3.0 are distinct keys.Â 

â€”
Sent from Mailbox

On Thu, Nov 13, 2014 at 6:55 PM, Pedro Henriques dos Santos Teixeira
notifications@github.com wrote:

> great!
> Perhaps, could coerce for the case of integer keys in Map as well :)
> 
> ```
> Immutable.Map({3:10}).get(3)
> ```
> 
> ## => undefined
> 
> Reply to this email directly or view it on GitHub:
> https://github.com/facebook/immutable-js/issues/193#issuecomment-62988989
  Hmm. This one is pretty tricky, yes. Maps have no defined order, so sorting them isn't super useful. The same issue exists with Sets right now.

I like the idea of explicitly returning OrderedMap from a map.sort(), I'll find a way to do the same for Set.
  I would love to have this, yes.
 Closing this aging issue. (nice work, @glenjamin!)  Closed in 19ebae805ccb3d81cf4d66ebcef9377d32a0d79a
  Thank you!
  Good catch, and thanks again for sending the pull
  Great catch. Thanks!
  Thanks
  Yeah, it's treating these as "array-like" which is too aggressive for both fromJS and Map constructor.

This is ambiguous behavior, more than a bug, but it's certainly confusing and I agree with you that this confusion and ambiguity is pretty critical.

I'll get on this and make sure the fix is in the next point release
 I'm close to a fix to this, and expanding test coverage to ensure it's done correctly. I'll update here when I have this issue fixed and released.

I agree with you that `fromJS(boringValue).toJS()` should return something of the same shape. That's a totally reasonable expectation that I will add a test for so it's actually upheld.
 Fixed by def9a096d25928d809930aa64fa1e4f07424f460
  Ah, thanks. This was actually an intended change in v3, as it's a better enforcement that keys are strings and better mental model since Records are more closely related to Object than Map.

I will update the docs to make this more clear, that was my mistake.

Thanks for bringing this up!
 Should be fixed by 0c5ca8f344908e3c5b106bae7b008948e6a9f859
 I also made an edit to the Wiki to point this out.
  Going to close this since it can't be merged. I don't think I can handle the mental bandwidth of keeping more package managers up to date than we currently have.
  Good catch, thank you :)
  I'm sorry I've let this languish. I really do support this and want to get it right. I do want to do some light refactoring to make the implementation a bit more robust. I'm making this a priority. Thanks again for your patience, I know you've been waiting!
 335b312c3e80ed2051b62ae4f29ba34f2734d3e9 Adds this functionality, including borrowing your test cases.

However, it does not cover keyPath for Cursors. I'll follow up.
 And 0ca53e537b82c73dca7e190fa16f87f8453967f4 adds this to Cursor
  I will definitely document this! I imagine it's an uncommon case though. Usually you want to simply use object identity directly.Â 

If you find yourself implementing hashCode() make sure to also implement equals(other)
 If you want to use object identity, just pass the object into the set directly, no need to implement hashCode
 #506
  Closing this aging issue. 

This is still something we would like to get to in the future, but won't be able to make it happen soon.  VesaVesQ: @reactjs Kind of buggy header on Firefox Mobile (android) http://t.co/BU8ALznb1r
 Thanks for the additional report! I'll look into what's going on for FF
  Thanks, I took the tests from your pull, but needed to implement it slightly differently in order to solve another issue with Record in 0c5ca8f344908e3c5b106bae7b008948e6a9f859
  I really agree with a lot of what you're saying here. Thanks for spending the time to write it up. I'm interested in devoting v4 to a better Record API.

First, I agree that Records implementing the Map spec doesn't really make sense. If you're iterating over your record as if it's homogeneous, then you're probably doing it wrong. This was my mistake.

I think the Record prototype API should be a little fuller than what you're proposing, but not by much. I think I would propose:
- `get` â€“ safely access any field, in case it collides with a prototype method. Also allows use with `getIn` called by a parent.
- `getIn` â€” deep access
- `has` â€” maybe even call this `hasOwnProperty`. Not sure.
- `set` â€” persistent set
- `setIn` â€” deep persistent set
- `update` â€” has positive performance implications, allows point-free updater functions, and allows `updateIn` called from above.
- `updateIn` â€” deep persistent update.
- `hashCode` â€” treat Records as values
- `equals` â€” treat Records as values
- `toObject` â€” back to JavaScript land. Also, think of this as "toMutable"
- `toString` â€” obvi.

I'm also considering having Record be a base prototype, not extending Object.
 > This approach has a number of advantages. First of all, it becomes feasible to simply implement it with a vanilla JS object and Object.freeze. I'm not sure what the performance characteristics are, but I suspect that the structures underlying Map (and thus, the current Record) aren't that much more efficient than a simple shallow clone for very small amounts of fields (like is typical for records). set would just shallow-clone the object, overwrite one value (or more, maybe), then freeze the new object.

Unfortunately, Object.freeze carries an very significant performance hit. To the point where Map dramatically out-performs it. However, I do agree that a much simpler underlying (unfrozen) object likely wins the performance war. What I would love to do is benchmark the performance of gets and sets for these three cases (frozen obj, regular obj, Map). My expectation is that Map becomes more performant after some threshold of key size, and that we can internally intelligently switch to use Map only when copying huge objects becomes slower.
 > First, shorthand field access (record.fieldName) works on ES3 too (currently it is implemented with defineProperty so only ES5 browsers and up will manage)

Unfortunately, there's no way to enforce immutability for ES3 with shorthand property access. Object.freeze is ES5 only, along with defineProperty.

Our only two options here are to drop support for ES3 (predominantly IE8) or to offer an non-shorthand API (`get`/`set`). That's ultimately why I decided to also expose get/set and not only property access. If you only care about ES5 browsers, you can use property access!
 > Finally, somewhat offtopic, but why did you choose obj.set('field', value) over obj.set({field: value})?

Consistency with other uses of `set` both in this library and in ES6. Map and Set's `set` can't accept an object, because their keys can be anything, not just strings. Records must have strings, but keeping the API consistent was important. `Map` has `merge` which accepts an object. Maybe it makes sense to have something like `Record.assign` similar to `Object.assign` which conj's multiple records or objects together into a single Record which would support this case.
 > One other strong advantage of backing Record by a plain ES3 object, is that you can simply pass a Record to any library that expects an object (including when it uses hasOwnProperty or Object.keys and so on), and it'll just work. Sure, toObject isn't far away, but it's nice if it doesn't matter.

Totally agree. It would be excellent to ensure these properties.

> One thing about freeze and enforcing immutability: this is JavaScript. Even if we try, it's a dynamically typed language that allows a lot of stuff, way too much probably. As such, I'm not entirely sure that it's necessary to enforce immutability in production code. Would it be interesting to ship two builds of the library, one for development, and one for production? Much like React, the development library would do all kinds of checks and Object.freeze and all that (skipping it if not available), and the production library would just back Record with a plain old object, end of story. I guess we can assume that even if Object.freeze does not work on every browser, it works on every developer's most commonly used browser.
> 
> If all development and automated testing uses a version that enforces immutability, then maybe it's no disaster if production code doesn't.

Yes, we do this in React and also all over the place in FB production JavaScript. In dev mode, we are strict and throw exceptions loudly, and in production we're more likely to fail silently with the hope that nothing bad will happen that we didn't catch in dev.

In practice, this is pretty hard to manage outside of a larger software shop like Facebook. You really need significant coverage over your dev build to ensure all edge and corner cases are caught before production. This kind of discipline requires organizational work. Therefore, easy to fuck up. We even fuck it up once every few weeks, and need to hot-fix things that we should have caught in dev but didn't.

One step further into the future for Record is part of an ES7/ES8 spec that would enable VM optimizations and techniques for parallelization. One of the reasons to prefer immutable data in multi-threaded environments is you need no locks. JavaScript's WebWorker interface is simplistic to shield us from the perils of multi-threading, but a truly immutable value should be able to pass to and from WebWorkers without serialization overhead. I recognize that this is overkill when targeting ES3/5 browsers of today, but something I'm keeping top of mind.
 > in practice, what happens when code tries to mutate an immutable object?

IMHO immutability enforced, throw an error and stop execution.

I should clarify that the reason we don't use Object.freeze in production is purely because of the performance tax. I actually think Object.freeze's behavior of silently failing on mutation attempt is actually bad. It's really easy to think everything is working when it's subtly not working. Also, execution behavioral differences between development and production environments are often the source of great pain and frustration. "Bug repros in prod, but not in my dev environment" is a heart-sinking feeling where you know you're about to lose a day. I just want to avoid anything like that.

> I don't know about how these ES7/8 VM tricks work, but I assume it'll mean telling the VM "we promise, this won't go wrong"? In that case, it's still a userland promise so there's no real difference to passing an Immutable.Map or a plain old JS object.

If I can spec this, an ES7/8 environment could provide immutable Record as a VM promise, not a userland promise. That's the only way to let the VM optimize it (memory usage, access patterns, shared memory between threads). A polyfill of this for <= ES6 would offer immutability as a userland promise to provide the same developer API and behavior, but maybe not the same performance characteristics.
 As an example of prod/dev behavior - at Facebook we use a lot of `invariant()` style assertions which check a condition and throw an error if it's broken. We don't remove these in production despite the fact that removing them could save some download bytes and condition checking. The value of having the same behavior in prod overrides that.

I think I've got us on a tangent though :), we both agreed above that expecting usage of a development build to catch issues could be problematic enough.
 Thanks David, I think that's probably pretty close to what I'd like to do.
 @abergs - if each record in the collection was a modification of a previous record then this works today! Just sub `List` for "Collection".

Structural sharing is the result of (Representation A) + (Operation X) = (Representation B), so if you can express your 1000 similar records in terms of "previous-record + operation" then absolutely.

Otherwise, it's actually pretty hard to do the reverse, taking `B - A` to get `X`. It's possible, but you're likely to trade a 2-3x improvement in memory footprint for a linear (`O(N)`) degradation in runtime performance.
 @eteeselink good points, thanks again for your input. Conversion methods like `toObject` and friends will need to be there.

I will probably still implement by backing with `Map`.

> One goal I had was being able to pass a Record to any function that expects a plain old JS object, but it appears that that's nearly impossible to achieve.

This is indeed tricky. `Record` uses property accessor functions, which allows for the `myRecord.myField` expression, however it requires an ES5 runtime that supports this feature (e.g. not IE8). So fairly modern browsers will do fine with treating Record as a simple read-only object, but broad browser support requires using `get()`
 @Pauan mind sharing your perf script? It would be interesting to run it again since some perf improvements for small Maps have been added and I'm not sure if it was before or after your test.
 Merging this into #286.
  Fixed in 0c5ca8f344908e3c5b106bae7b008948e6a9f859
 Thanks for finding this and reporting it!
  ```
Immutable.List.of(1,2,3,4,5).splice(2,1)
"List [ 1, 2, 4, 5 ]"
Immutable.List.of(1,2,3,4,5).remove(2)
"List [ 1, 2, 4, 5 ]"
```

Previously, `remove(i)` behaved similar to Array's `delete arr[i]`, which is roughly synonymous with `arr[i] = undefined`, which is far less useful when working with a dense list.

Does this help clear any confusion?

But maybe you're referring to something else? If I can help clarify the docs, I'm happy to.
 fair :)
 Just edited it to read `list.remove()`
 Awesome, thanks!
 Thanks, will fix.
 Fixed in f93acade760c699151255edf80df45e770f65f03
    @wolffiex recently also pointed out some related issues with mergeDeep.

I'm digging into this now, and will write up more test cases
 Pop open that commit to see what was happening, if you're curious.
 Also relevant 1a707cbfd5a50f4f75aa61227b644f0ac03501d9
  The good news is that this is totally possible. You'll just need to write a little bit of a helper since typed arrays aren't designed to be built from iterables.

``` js
var ia = new Int8Array([0,1,2]);
```

Converting from a typed array to an immutable List is straight forward:

``` js
var list = Immutable.List(ia);
// List [ 0, 1, 2 ]
```

Converting back requires a little work:

``` js
var ia2 = list.reduce((ia, v, i) => (ia[i] = v, ia), new Int8Array(list.size));
// [0, 1, 2]
```

Does this cover what you need?
 Not currently, no. A lot of the performance benefits of typed arrays is the ability to be backed by a single buffer - but the data structures used here are trees of small arrays. It's unclear how much performance we could actually gain from using typed arrays.
 Closing this aging issue  Hmm.. I'll look into this for you. What you've typed up there seems very reasonable, but sometimes TypeScript requires some convincing.
 Ah yes, that example is valid ES6, but not TypeScript.

I haven't tried this, but perhaps this might work:

```
var _ABRecord = Immutable.Record({ a: 1, b: 2 });
class ABRecord extends _ABRecord {
    getAB() {
        return this.a + this.b;
    }
}
```

If not, I'll have to look into how to get this working in TypeScript in better form.
 Hey! I'm not sure yet actually and am open to suggestions.
 Latest type definitions are helping out quite a bit more, will be released soon  Thanks @tgriesser
  What ES6 code are you seeing?
 Ah, you're right, there are arrow functions in there! I will get a rev up to fix that. Thanks for letting me know!
 Fixed in master, I'll have a point release on npm a bit later
 3.0.1 is now on npm!
  Yep, this is intentional.
 Thanks @pluma, good explanation :)
 In a future release, I'll change the inspect string of Cursors to be "Cursor" instead of "Seq" to make this a little more clear.
  filter is a lazy operation, Sequence represents these lazy operations. To convert back into a real collection, use `toVector` so your example:

``` js
Vector([1,2,3]).filter(function(x){return x == 2}).toVector().set(1,'x')
// Vector [ 2, "x" ]
```
 By the way, this will change in the next major version of the library, lazy-by-default has confused a lot of people.
  Thanks!
  <3 browserify
  The uppercase file names were a mistake, they should be lowercase. This was supposed to be fixed in 2.5.1 but the 2.6.0 release was a regression.
  Vector is always dense.

What performance characteristics are you looking for in a different data structure?
 In data structure libraries, "List" often means "LinkedList". If you're looking for that (cheap O(1) LIFO) then `Immutable.Stack` might suffice for what you're looking for.
 Vector.remove() is similar to `delete array[at]` but only leaves the value set as `undefined`, `has()` will still return true, because Vectors are dense.

The difference between `remove` and `splice` is whether or not the indices after the removed indices shift down to fill the slot or not.

Almost all of the time, you can consider `vect.remove(index)` equivalent to `vect.set(index, undefined)`.
 I'm going to close this issue because it sounds like Vector supports the case you need.
 remove(x) should probably behave like splice(x,1) though. That is confusing at the moment. I'll fix that in a future major version.
 There is not a lot of advantage from it. It's a hold-over from when Vectors were modeling sparse collections, before v2.3. Now it's equivalent to set(i, undefined), which is less useful.
 Note: in v3, `remove(i)` is now equivalent to `splice(i, 1)`
  Thank you. I'm not sure wtf happened here.
 v2.6.1 is now out
  Thank you!
  Should now be fixed on npm with v2.6.1
  Thanks for the recommendation.
 I think this should actually be a filter predicate so it can apply not just to Map but to all Sequences.

You could use a simple predicate builder to implement `pick`:

``` js
function keyIn() {
  var keySet = Immutable.Set.from(arguments); 
  return function (v, k) { return keySet.has(k); }
}
```

so then you can do `myMap.filter(keyIn('a','b','c'));`.

For convenience, I just added `filterNot` in 163a40b8f8291f0dd448e5560d0a0c70e73dda39 to make negating predicates a little easier to do, so `.omit` becomes `.filterNot(keyIn(x,y,z))`.
 I think that's a great idea. I'll figure out what structure works best and then add this to it as one of the first examples :)
 Tracking that in #152
 Starting the seeds of a wiki to stash away this knowledge

https://github.com/facebook/immutable-js/wiki/Predicates
  ``` js
var x = Immutable1.Map({a: 1});
var y = Immutable2.Map({a: 1});
Immutable.is(x, y); // false
```
  This is actually not necessary. `NOT_SET` is never stored anywhere or returned back to user-land. It's only used within the context of a single call stack and only internally, so it's safe to have one global reference and reduce allocations for these operations. It's not the main blocker of #117 
 I like the `removed` argument though. I think that's clearer.
  Thanks for the report! I just fixed this bug in master and will have an npm version out soon
 I'd love to see an example of your flux stores!
  Good thinking, thanks for writing the test as well.

I think it may be easier to just remove the `toArray` (and `ObjectSequence#toObject`) methods entirely and rely on their base implementations.
  I've never seen this before and can't repro.Â 

What browser and OS version do you have?

â€”
Sent from Mailbox

On Mon, Oct 20, 2014 at 4:03 AM, Robert Nagy notifications@github.com
wrote:

> The workaround for now is to always `get` every value twice.
> 
> ``` javascript
> var value = map.get('key') || map.get('key');
> ```
> 
> ## I only get the problem in special cases and I haven't managed to create a small repro sample... not sure what is going on...
> 
> Reply to this email directly or view it on GitHub:
> https://github.com/facebook/immutable-js/issues/145#issuecomment-59727402
 I think we need to see more code to understand what's going on. `get()` has no side effects and so calling it shouldn't cause calling it a second time to behave any differently.

One possibility is that whatever JS VM you're using is making poor optimizations that are altering the runtime behavior. We've seen this before, but without code I can run to repro it, I won't be able to investigate.
 If you could provide a sanitized version of your production code for me to investigate within, or if you investigate yourself then please reopen this. Otherwise this isn't actionable without a repro case.
  thanks for the report. That should say "first()" I'll fix it!
 Improved in ed332199f41e5240676ef03ad023d122d91c47ec
 The reason it was wrong was due to recent changes to lazy sequence operations and the Readme wasn't kept up to date. Should be better now
  Sorry can you clarify? Are you suggesting that your code doesn't work? Are you looking for help simplifying the code?
 Hmm, I'm not seeing this issue reproduce. I wrote a test case to make sure mapping over a cursor returned more cursors in 3fba5a5e60d907d29e37121c78a71871d8ca3809 and the test passes.

Your example from above might work if you change it to:

```
var reactElements = cursor.get("values").map(function (subCursor) {
  return <Element className="foo" initial={subCursor} />;
});
```
 Expanded the test to cover Cursors to Vectors and not just Maps in 07348f43973e11d2f50c75c646d298b911422487, still passes. 
 No problem! I'm glad you got things working. 
  I'll look into this
 Indeed a bug. Thanks for the report!
 Merging into #141 
  Solved in 9e63cc0b6f3a310cfe73b0adf86daf72c847e769 - will be on npm soon
 Thanks again for the report!
  Thanks for the pull! Great find and fix.
  I fixed this in master yesterday. I'll get a fix release on npm today. Thanks for the reminder!
 Closing for now since it's fixed in master. stay tuned for npm
  Reopening. 

The cursors in this library are definitely far from good. Still "experimental" I guess. 

I have some ideas on how to solve this that line up well with the links and ideas shared here. Thanks for keeping the brainstorm alive, guys :)
 Yep! I'm working on v3.0.0 now which will introduce some API changes around Sequence construction and will expose the ability to create your own
 Hey @tgriesser - Immutable v3 is out now and exposes everything you should need to implement your own variant of Cursor. Check out the contrib dir to see the existing Cursor impl which has no internal dependencies.

Documentation is relatively limited right now, so if you come across anything that took a while to wrap your head around, please either let me know or write something up. It could be really awesome to have a wiki page describing how to extend Immutable.
 Yes, my hope was that would be implied by the contrib second-class :) I will add it to docs so it is explicit.
  This looks like an awesome tool, thanks for the suggestion!
 I'm getting started on this now, by the way. I intend to do it right.
 http://facebook.github.io/immutable-js/docs/ Feedback welcome. I plan to continue to improve based on feedback.
 Yes, adding contrib to the docs is on the plan :)
  Awesome thanks!
 I manually merged it. No big deal :)
  This isn't really viable because `Sequence` does not imply concrete backing data, only that the Collection is "sequenceable" (at some point in the future I may rename to `Iterable`, as its a clearer name). Not all Sequences (Iterables) could support a set() method.

If you're doing persistent mutations, then I would recommend using Vector and Map instead of Array and Object as they are concrete collections and will give you much better memory usage over time.
  This is expected. What you have made is an immutable map which contains a mutable object as a value, and your example code is mutating that contained mutable value.

If you replace the Immutable.Map() line with Immutable.fromJS(), it will deeply convert the js object into nested Immutable Maps. 
  Can I ask the use case?

â€”
Sent from Mailbox

On Tue, Oct 14, 2014 at 12:17 AM, plievone notifications@github.com
wrote:

> ## It would be nice to have the version number included in built lib?
> 
> Reply to this email directly or view it on GitHub:
> https://github.com/facebook/immutable-js/issues/133
 Makes sense. I think a comment block is a good idea.
  Good catch. Thanks for the test!
  Hmm, I just pulled 2.3.0 from npm a couple times without any issues.

I'm closing this for now, but if you reproduce it from another machine or network, let me know and reopen this.
  :+1: 
  Definitely a bug, thanks for the report!
 Released in v2.2.2
  Really just avoiding the kitchen sink problem. It's easy to keep adding these sorts of convenience methods until the library grows huge and burdensome. I want to keep the mantra something like: what ES7 should consider adding to Array/Map prototype. 

For max:

mySeq.reduce((a, b) => a > b)
 This isn't to say I wouldn't add these methods, but the demand for them should be pretty high first. 
 I just realized my comment code sample was totally wrong. This will work though and reads pretty well:

mySeq.reduce(Math.max)
 FYI, I just added these (and minBy and maxBy) and will be in the next minor rev.
  Is there a branch of the project and a test I can run with node or something to repro this?

Unfortunately I'm not sure there's enough information here for me to go on.

From a cursory read of the stack trace it seems like it's not an issue with `Immutable.is`, but one of the map or filter functions previously used since those are lazy and wouldn't have fired until `Immutable.is` forced them to.
 Ok, let me know if you make any progress on a smaller test case
 Cool, let me know if you end up shrinking it any further or have any leads on what's up. I'll try to dig in and see what's going on
 This is now fixed in v2.2.3 which is just now on npm
  Totally on point and great tests. Thanks for catching this issue and for fixing it so quickly! Excellent work.
  You should use `Record` for this.

```
var World = Immutable.Record({
  rooms: Immutable.Map.empty()
});

var myGame = new World();
var firstGame = myGame.update('rooms', function (rooms) { return rooms.set('palace', 'cold and dark')});
...
```

If you use ES6 transpiler, you can really tighten this up:

```
class World extends Immutable.Record({ rooms: Immutable.Map.empty() }) {
  createRoom(name, desc) {
    return this.update('rooms', rooms => rooms.set(name, desc));
  }
}

var myGame = new World();
var firstGame = myGame.createRoom('palace', 'cold and dark');
...
```
 Record will give you a more efficient "clone" and abstract it away. Also, it will then provide an API designed to deal with immutable persistent data.Â 

Your approach is okay, but the root level is still a mutable object, and you will have to closely protect it from mutation.Â 

And yes, I agree that using Object.create is a bad idea, as each mutation will add to a chain and access will get slow and memory will leak.Â 

On Sunday, Oct 5, 2014 at 5:21 PM, jayrbolton notifications@github.com, wrote:

Ah, interesting, I hadn't seen Record. Do you see red flags in the strategy that I cited? I think I'm still favoring it because it feels very simple to the end user and is perhaps easier to make arbitrarily named methods that take any number of arbitrary parameters and update any arbitrary amount of entries in the record

One thing I did notice in mine is that I probably shouldn't use Object.create(), because that will create endless nests of proto -- instead I'll use just a simple shallow clone func

â€”
Reply to this email directly or view it on GitHub.
  Currently, Vector and ArraySequence, and therefore IndexedSequence, are aware of and handle sparse holey sequences. There is a difference between an index being set as the value `undefined` and an index just not being set at all.

This has a lot of negative side-effects. 
- There is no clear way to describe holes in iterators.
- The differences between ES3/ES5/ES6/ES7 spec for methods on Array are confusing with respect to sparsity. (see [Array.from](http://esdiscuss.org/topic/array-from-and-sparse-arrays))
- It introduces a performance penalty by requiring hasOwnProperty checks.
- Difficulty in predicting values like the lengths of some indexed-sequence operations.

I'm proposing a change to Immutable-JS to remove the concept of sparsity/holes from Vector. There will no longer be a distinction between `undefined` at an index and an unset index. `vector.has(index)` will be replaced with a much simpler `0 <= index < length` check, and _not_ check if the value at index is the `undefined` value.

This also means a change for `.entries()` and `.keys()` iterators on Vector. `.keys()` will now iterate all indices 0 .. length, and `entries()` will do the same, where undefined indices will yield `[4, undefined]`.

My understanding of the primary uses for sparse vectors is a numeric map. Luckily, `Map` allows keys of arbitrary type, including (actually, especially) integers. Preserving this use case.

Some consequences of this change:
- Map's iteration order is not sorted (SortedMap to come in the future). No remaining way to describe an index sorted sparse list.
- Lossy conversion between Map and Vector. `Map(Vector(Map({1: undefined}))).has(0)` returns true. 

---

This is a call for suggestions, concerns, use-cases I haven't considered here from those using this library.
 cc @DavidTimms @spicyj @Tvaroh @tgriesser @rockymadden 
 Thanks, that's useful context and a vote of confidence for this plan. The behavior is the same for holes:

```
> mori.clj_to_js(mori.js_to_clj([,,,1,,,]))
[null, null, null, 1, null, null]
```

I do think maintaining the difference between null and undefined is important to preserve the JavaScript semantics, but the hole-filling certainly will make Vector different from Array.
 I have an open task (though lower priority than some other tasks) to implement SortedMap using a balanced binary tree or RB tree, but your code sample certainly would hold anyone over who would rely on this combination of traits.
 @rockymadden by monads I assume you mean the Maybe/Option monad? I'm a huge fan of null-less languages, but unfortunately JavaScript doesn't have a type system which is really crucial to the successful use of it (I've tried).

I also think it's beyond the scope of these data collections to introduce Maybe/Option, but you could certainly use any JS implementation of them along side it!
 But I definitely agree with your sentiment that sparse arrays do a poor job of describing "lack of value", and the Maybe monad does a great job capturing that.
 @rockymadden I've implemented it myself with [loda-js](https://github.com/leebyron/loda-js). The pain point is that there is just no way to enforce it's use across a codebase, especially since all of the JS/DOM native APIs return null/undefined/-1 all over the place and you end up not getting all of the program-wide safety you want. But at least within your application code you can reap a lot of rewards.

---

Ok, I'm really happy to see near total agreement on this. I have some pending diffs I'll wait to land in case there's more comment on this, but right now consider this plan in motion.
 Diffs are in.
  Yeah, this is intentional. `splice` is a lazy operation that returns a (lazy) Sequence. This is still pretty confusing and I plan on either changing the behavior or more clearly explaining this in docs.
 Yeah this is definitely not ideal. 

My plan to fix this is to make sequence operations eager for persistent collections like Map and Vector, but preserve the lazy route for the performance tweakers. I'm still figuring out the best way to present this, but I'm on it. I don't want to leave the library in a state where this point of confusion is so common. 
 Merging into #38 which makes concat and splice eager for Vectors.
  Thanks for the report, I'll dig into this.

For my curiosity, what are you using the seq 3rd argument for? At present, I'm sort of dogmatically matching the JS existing HOF APIs, but I would love to gather more info to make sure I'm properly supporting the cases people care about.
 Yes, this is definitely a bug as I intend to stick to the JS API.

Of course, this use makes total sense! You're basically doing a look-ahead/look-behind.

Thanks for this extra context, this actually really helps in terms of how I'll fix the issue.
 I'll get it out on npm soonÂ 

â€”
Sent from Mailbox

On Mon, Oct 6, 2014 at 8:20 AM, David Timms notifications@github.com
wrote:

> ## Closed #121.
> 
> Reply to this email directly or view it on GitHub:
> https://github.com/facebook/immutable-js/issues/121#event-174590403
  Coercing object keys as strings is a JavaScript behavior, not Immutable-js behavior. JS lets you use "naked" keys, letting the quotation marks be optional, however object keys are always strings, even if they look numeric.

However, Map and Object are not the same. Immutable.Map (and ES6 Map) accept arbitrary keys (strings, numbers, even objects) and so no key coercion is done for any of the Immutable.Map API.

If you want to be more cautious of your Map construction when intending to use non-string keys, use kv tuples in the constructor. 

Map([['a', 'letter'], [1, 'number']])
  Great clarifications here! Thanks :+1: 
  Hey @ihodes! Thanks for the pull. I modified it a bit before I landed it to handle a couple other edge cases and expanded the tests.

`Array#join()` is weird. Check out these edge cases the test runner caught that illustrates the extra checks.

```
> ["",""].join(null)
'null'
> [null,null].join("")
''
```

The joiner is only ever checked against undefined, the `null` value becomes the string `"null"`. However, values in the collection are checked against null and undefined, and become empty string. >_<
 I'm learning a lot about Javascript's core libraries by fuzz-testing them.
  Right now this would be pretty difficult because the implementation uses object identity for a couple sentinel values. If you ran two copies of Immutable, passing a collection created with one instance into a method from another instance, you could see issues.

I'm curious what your use case is though, perhaps I can investigate a limited way to enable this to unblock you, while staying conscious of the tricky cases.
 This is really useful to know, thanks for explaining. I'll try to chip away it over time for sure.
 Good idea
 @mystor that can become dangerous for other reasons. One version of Immutable-js may be incompatible with other versions.

One of the design goals of Immutable-js is that it plays nicely in a vanilla JS environment. The uses of `x instanceof Immutable.*` should be few and far between. If we can accomplish this, then two versions of Immutable should be able to co-exist - but they would each appear to each other as "vanilla JS object"

Can you give some more concrete examples of issues encountered when using two different versions of Immutable in the same runtime environment?
 Thanks. Tracking that one in #149 now
 Thanks, that's #150 
 Just fixed both #149 and #150 in master.
 Closing this out as we should have everything you need to interoperate between different copies of Immutable.

Note: v3 and v2.6 only interop for the issues solved in #149 and #150, but two copies of v3 should smoothly interoperate.
  Awesome work
  Thanks for the report. This one is a bit tricky to solve as Immutable.Map is trying to be as close to ES6 Map as possible, including the behavior when constructing with Arrays. I will likely make this case fail faster and provide a specific API for building from indexed sequences like Array.
 Closed, this is now fixed in v3
  Thanks for the report. This is a known problem that #38 will help address.
 Merging into #38 
  I like that idea!
 Good feedback, @xixixao. Something to consider for future versions.
  Right now there are not many ways to construct these directly. They are mostly used to represent the lazy sequence computations such as mapping or filtering a Vector.

Range() is one of the ways you can create a lazy sequence directly. I haven't yet added something akin to `generate` or `repeat`, but those will come soon.
 Closing this - but note that in v3 (released late last year), Seq got it's own API directly.

``` js
var lazySeqOfStrings = Seq(["a", "b", "c");
```

Then you can use the full collections API on these.
  This is a pretty interesting suggestion. Let me mull it over a bit.

One possible issue is that a function could possibly be a key itself, which could create ambiguity between using the function as a key vs using it as a mapper.
 Yeah, feature-creepy is part of what I'm worried about here. If you're only looking for the "all" predicate, then that's just `map`, right? Would this suffice for your example?

```
var m = Immutable.fromJS({
  books: { name: 'Somename', price: 15},
  magazines: { name: 'Anothername', price: 8},
})
var n = m.map(function (obj) { return obj.update('price', function (v) { return v + 0.9 })});
```

Or using ES6 arrow functions for legibility:

```
var m = Immutable.fromJS({
  books: { name: 'Somename', price: 15},
  magazines: { name: 'Anothername', price: 8},
})
var n = m.map(obj => obj.update('price', v => v + 0.9));
```
 updateIn(predicate, ... could be done with a small utility for map:

```
collection.map(mapIf(predicate, mapper))

function mapIf(predicate, mapper) {
  return v => predicate(v) ? mapper(v) : v;
}
```
 I've already come across a pretty reasonable number of real uses where functions are being used as keys into a map, so I'd rather not break those existing uses. I find global config flags easily confuse as they aren't colocated in the API with the behavior and changing that can result in dependent code which shares the Immutable library not behaving properly.

@nonuby thanks for illustrating this use case, that helps me understand what you're trying to do.

In the meantime, have you tried something like:

``` js
appstate.updateIn(['contact','item','deals'], deals => {
  var dealIndex = deals.findIndex(deal => deal.get('id') === cmd.dealId);
  return deals.updateIn([dealIndex, 'breakdown'], breakdown => breakdown.push(
    Immutable.Map(...)
  )
};
```
 Closing this since it's aging, but I think a utility function that performs this sort of operation would be useful.
  I agree this behavior isn't very clear right now and might not even be right.

For clarity as I improve things, can you say more about the use case you're having trouble with? I don't quite understand the JSON reference with relevance to equality checking.
 That sounds like a really interesting project! I'd love to see it.

If I understand correctly, it might help to write your own equality method for use in your language which first checks that the two have the same constructors (are of the same class) and then calls `Immutable.is`.

I'm not quite sure I follow about losing type information when modified. For example `myVector.push('x')` returns another `Vector`.
 Or another way to say that is - they should definitely have type information, but the `Immutable.is` function doesn't use type information to determine equality right now, instead only comparing equality of the contained items. (This might need to change anyhow)
 myMap.set(k,v) should definitely return another Map.

Only the sequence reductions like map/filter/etc should result in a lazy Sequence (which you can always reify by calling .toMap() or .toVector() on them)
 The lazy sequences are one of the main reasons why value equality checking doesnt look at the type. A lazy filtered Map should be able to be compared to regular Map. However, I still agree that it's confusing - so I really value this feedback.
 Keep me posted on your JSON Lisp, it sounds like a really awesome project
 Closing this, as I decided (for now) to keep the equality semantic of "same keys and values", so all empty collections will still appear equal.
  In general you shouldn't be concerned with a value being a cursor vs an original map, but certainly it could make sense to assert that your react prop expects an Immutable collection. I think instanceOf works just fine here, or you could provide any validation function:

```
propTypes: {
    appState: function (value) {
        // return true if value is acceptable. For example, value.has('foo') && value.has('bar')
    }
},
```
 I'm glad you're unstuck, I have no idea why the PropTypes.instanceOf is doing the wrong thing. Maybe worth opening an issue on @facebook/team-react ?
  Thanks for the report. I will fix this!
 I hate JavaScript sometimes.

```
> [1,2,3].reduce(function (x,y) {return x+y})
6
> [1,2,3].reduce(function (x,y) {return x+y},undefined)
NaN
> [1,2,3].reduce(function (x,y) {return x+y},null)
6
```
 Fixed by e034f5e3a57ad12601ed2c09debaf8bf10357475
 I believe you're right. I'll get that fixed
  This is by design, as `typeof value === "object"` is far too lenient and can often iterate through unexpected keys.

When an object has a constructor other than `Object`, it is almost always representing a Record and not a Map. The example you shared here of "Point" is actually a great example. Point is not well represented by a HashMap and much better represented as a Record.
 Check out `Record` in the type-definition documentation. Hopefully it better aligns to what you're trying to accomplish.
 Whoa, that's an interesting use case. I'll think about another way to detect Objects.
 By the way, this should now work as expected.

`Immutable.fromJS()` still looks for plain objects, but directly constructing a collection like `Map(myPoint)` or `Map(myObjFromAnotherGlobal)` should work as you originally expect.
  This is a bug, thanks for the report!
  I'll look into both fb's cdn and cdnjs. Great suggestion.
 I added the jsDelivr link to the Readme :)
  The original phase is correct, or I'm not seeing the typo. Can you explain?
 @spicyj I just made your recommended change to Readme. Reads easier and hopefully will solve this confusion that's come up a number of times.
  Thanks for the fix!
  Thanks!
  You are comparing next.id to next.id instead of prev.id to next.id, so it's expected that the list should remain stable when all comparisons are "equivalent"â€”
Sent from Mailbox

On Mon, Sep 8, 2014 at 10:17 AM, Clint Ayres notifications@github.com
wrote:

> ```
> > var data = [{id:2},{id:3},{id:1}];
> > var v = Immutable.fromJS(data);
> > var comparator = function(prev, next) { 
>   var b = next.get('id'); 
>   var a = next.get('id'); 
>   return a > b ? 1 : a < b ? -1 : 0;
>  }
> > JSON.stringify(v.sort(comparator).toJS());
> < "[{"id":2},{"id":3},{"id":1}]"
> ```
> 
> ---
> 
> Reply to this email directly or view it on GitHub:
> https://github.com/facebook/immutable-js/issues/101
 Just saw your update on sorting cursors. I'll look into that. 
 Oh, I know what's happening here. Cursors only support Maps right now. I'll merge this into the task tracking Cursor support for Vector
 This works as expected as of v2.4.0
  This turned out to be a VM JIT issue which was fixed a few weeks ago.
  @plievone is correct. "undefined" is a valid key! deref() returns the original map. 

Is there outdated documentation leading you astray? Point it out and I'll fix it. 
 Closing this now that it's clear that cursor() returns a thing that looks like a Map, so get() with no key should definitely return whatever is set in the Map for the key `undefined`.
 Today, your example code should look like: 

```
Immutable.unCursor(
  Immutable.fromJS({}).cursor()
)
```

Which returns `Map {}`
  Thanks for the recommendation. Would you mind sharing some examples of what you're trying to do with Immutable that would be made easier with these methods, or the API you would expect?â€”
Sent from Mailbox

On Wed, Sep 3, 2014 at 11:31 PM, AlexGalays notifications@github.com
wrote:

> Hello,
> 
> ## I don't see any support for this very useful operations?
> 
> Reply to this email directly or view it on GitHub:
> https://github.com/facebook/immutable-js/issues/98
 It looks like using flatten is a missing piece here. I'll look into that furtherâ€”
Sent from Mailbox

On Fri, Sep 5, 2014 at 1:34 PM, Tenor Biel notifications@github.com
wrote:

> :+1:
> 
> ## @leebyron I think all the flatMap method would need to be is a lazy-operation-optimized sugar method for `.map(myFunc).concat()` which is all flatMap is.
> 
> Reply to this email directly or view it on GitHub:
> https://github.com/facebook/immutable-js/issues/98#issuecomment-54656502
 Map and concat are both lazy so the line you just wrote results in a lazy sequence itself!

I'll look into it further, but I want to make sure the API stays terse. If the pattern is common and tedious then it should be included, but if it's already easy to accomplish what you want without the dedicated method, then I would rather not include it.Â 
â€”
Sent from Mailbox

On Fri, Sep 5, 2014 at 1:34 PM, Tenor Biel notifications@github.com
wrote:

> :+1:
> 
> ## @leebyron I think all the flatMap method would need to be is a lazy-operation-optimized sugar method for `.map(myFunc).concat()` which is all flatMap is.
> 
> Reply to this email directly or view it on GitHub:
> https://github.com/facebook/immutable-js/issues/98#issuecomment-54656502
 Aha. Sorry, I'm not a Scala person, and my mind didn't quite click on the equivalence of flatMap and bind. I'll definitely look into implementing the bigger picture here which is to allow Immutable.Sequence to behave as a Monad.
 `flatMap` has been in for a while now (and it's lazy!)
 Hey @stiff I'm a little confused by your example - is that what you're expecting to see or what you are seeing?

Here is what currently occurs:

```
> function a(x){return[x,x]}
undefined
> Immutable.fromJS([[1,2,3], [4,5,6]]).map(a)
"Seq [ Vector [ 1, 2, 3 ],Vector [ 1, 2, 3 ], Vector [ 4, 5, 6 ],Vector [ 4, 5, 6 ] ]"
> Immutable.fromJS([[1,2,3], [4,5,6]]).map(a).flatten()
"Seq [ Vector [ 1, 2, 3 ], Vector [ 1, 2, 3 ], Vector [ 4, 5, 6 ], Vector [ 4, 5, 6 ] ]"
> Immutable.fromJS([[1,2,3], [4,5,6]]).flatMap(a)
"Seq [ Vector [ 1, 2, 3 ], Vector [ 1, 2, 3 ], Vector [ 4, 5, 6 ], Vector [ 4, 5, 6 ] ]"
```

Were you expecting flatten() or flatMap() to deeply flatten?
 I've currently modelled flatten/flatMap against Scala's definitions. Please let me know if this is confusing (or incorrect). My goal is to translate this sort of behavior from existing languages into idiomatic JS.
 Great feedback. I'll investigate level/shallow and have flatten() deep by default.
 I've got a diff in master (not released in a version yet) e41d99e53a20bacfcfe7861bcb5be3abea95611d which changes the behavior of `flatten()` to follow the lodash/underscore precedent, and also supports a specific level of flatness ala Ruby.

It doesn't change the current behavior of flatMap, which as I understand today does what you expect it to do, correct?
  This is on my short list. Currently Cursor only supports nested Maps, but I intend on adding support for more types soon.
 Solved in [v2.4.0](https://github.com/facebook/immutable-js/releases/tag/2.4.0)
 data.cursor('x') does return a Cursor to a Vector there because Vector is an immutable collection.

Calling cursor() should always return the same type of thing as what the cursor would point to. In the case of regular JavaScript values, we don't have control over them, so it doesn't make sense to wrap them.
 Ah snap. Yes, you're right.
 @mikaelbr It is possible, but you certainly need to be aware of your data structure. I think this is a trade-off worth making. Now cursors can be treated as you would the type it points to. A MapCursor behaves as a Map. It's still possible to do top-down rendering with cursors, but you just need to be sure that when you call `cursor(x)` that you're not referencing a scalar.

I've also commented on your gist with a few edits you could make to make that code work correctly.
 @JaapRood @torgeir - I just pulled v2.4.0 from github and npm - it's definitely a breaking change that should have been a major version number bump.

Considering @mikaelbr already illustrates a very real case where the breaking change will require work to upgrade to this next version, I'll bring it back as v3.0.0 later today.
 cc @tgriesser - I know you're working with Cursors as well.
 Ultimately, I rolled back the change to cursor and went with a minimal fix to this issue.

I may consider changing Cursors in the future, but it seemed to make more sense to not mess with them for now.
  Thanks for the report. This should be an easy fix.
 Thanks again for reporting this!
  Thanks for the reminder. I intend to use semver but clearly I made a mistake when I added keySeq and didn't bump minor version.

I'll pay closer attention going forward!
  Thanks for the reminder to do this! I needed to change your bower.json file a bit, so I didn't merge your pull directly, but 4c6d4f94d28a543b1b46a35f0649ac28a3a16682 is essentially the merge of this. I also just released 2.0.17 which includes the bower manifest and registered it on bower.

Let me know if you run into any issues with using Immutable via bower!
  Thanks for the report. I'm looking into this now
 Thanks again. This issue was also appearing for `skip(N)` as well, this last commit fixes the issue for both.
  Whoa, bizarre. Thanks for the report I'll try to see what's going on.Â â€”
Sent from Mailbox

On Fri, Aug 29, 2014 at 9:30 PM, broberson notifications@github.com
wrote:

> Nicely spotted. 
> Fails in MobileSafari on iOS 7.1.2, works in Chrome for iOS.  
> 
> ## Mozilla/5.0 (iPhone; CPU iPhone OS 7_1_2 like Mac OS X) AppleWebKit/537.51.2 (KHTML, like Gecko) Version/7.0 Mobile/11D257 Safari/9537.53
> 
> Reply to this email directly or view it on GitHub:
> https://github.com/facebook/immutable-js/issues/92#issuecomment-53948424
 Hey @conradz - are you still reproducing this? I loaded your codepen on my iPhone (5S, iOS 7.1.1, Safari) and it's just reporting `done` without any errors. 
 If this is device specific, I'm going to throw blunt things in the general direction of Cupertino.
 It might be an issue introduced between iOS 7.1.1 and iOS 7.1.2. If I can't repro on 7.1.1 and once I update to 7.1.2 (doing this right now) and repro it, we'll have narrowed it down to that.
 My 5S running 7.1.2 also does not reproduce the issue :-1:  - What other devices are you seeing this reproduce on? You mentioned your iPhone also reproduces the issue, does it still? What model is it?
 Ok, I reproduce this on my iPad. Also failing on the 37th iteration. I'm digging in more now.
 TIL about the iOS JS debugger. If you hook it up to your laptop and open Safari's debugging tools, this error disappears. Going into debugger mode probably means your laptop's JSVM is running instead of iOS's. Heisenbug!
 @conradz I think you're correct. I think this is a bug in iOS 32bit JS JIT.

I've managed to ghetto log my way down to the source of the problem:

In `BitmapIndexedNode.prototype.get` on [line 1381](https://github.com/facebook/immutable-js/blob/master/dist/Immutable.js#L1381)  `(1 << ((hash >>> shift) & MASK)` at some point just starts evaluating to `1`, regardless of the values of `hash` and `shift`. My best guess is that the JIT is making bad assumptions, which would explain why the first dozen goes at it work just fine.

This is still heisenbuggin' because as soon as I do something like:

```
console.log('(1 << (('+hash+' >>> '+shift+') & '+MASK+')) = ' + (1 << ((hash >>> shift) & MASK)))
```

The problem goes away completely.

It's also sensitive to the context of everything running around it. I've tried isolating just this line but the issue stops reproducing then as well, so I'm having trouble creating a minimal failing case to file a Radar with.

I also haven't found a fix yet that doesn't require sticking a console.log in there :(
 BTW, I filed this to Apple as rdar://18220947 in case anyone from Cupertino is reading this and can help or bring advice as to how to fix this.
 I put a log right after line 1381, logging `(hash >>> 0)` and sure enough, after some iterations, it starts evaluating as `0`.
 Good suggestion, @tgriesser - https://bugs.webkit.org/show_bug.cgi?id=136508
 I've committed a workaround, but ideally I can figure out what's actually gone wrong here and end up with a better solution in code.
 This is now fixed in v2.1.0
  Excellent work! Thanks for including tests.
 Btw, I followed up with 3d16cc64afb101b2d8ca7ed807ba44340620ad32
 Also, I would LOVE to know what you end up building with this. 
 Let me know if there are any benchmarks that prevent you from doing what you want to do.
  Map.from is ~0.6x as performant as a manually written for loop within `withMutations`, it should have less overhead.
  Yes! I want to build this and SortedSet.
 RB Tree sounds like the right way to do this.

I'm putting this up for grabs for any adventurous contributors. Best way to learn about Persistent Immutable data structures is to implement them!  Good feedback
  Thanks for bringing this to my attention. I added a test case to test this in a broader way and actually found a handful of related issues as well. All fixed in the referenced diff.
  Correct - this is to ensure laziness. Wrapping them all in `toXXX()` would make them all non-lazy and become a performance burden.
 The general rule of thumb is that methods on Array which are mutative (set, delete, push, pop, shift, unshift) should have equivalent counterparts on Vector that are persistently mutative and return new Vectors with that mutation applied whereas methods on Array which are not mutative (filter, map, slice, concat) should have equivalent counterparts on Vector that return Sequences and are lazy. The current exception is `splice`, which currently returns a Sequence but should ideally return a realized Vector. It requires RRB trees and tracked in #38. After #38, I'll probably convert slice and concat to return Vector simply because this issue of confusion is legitimate and comes up fairly often.

To your other question: it depends. 

`concat` runs in O(1) - returning a Sequence which simply points to both the vector and the arguments passed to `concat`. `push` runs in O(logN) - returning a Vector by structural cloning which is not slow, but definitely more work than `concat`.

Sequences have O(N) `get`, and do not have `set`, but have efficient `O(N)` iteration. `seq.toVector()` is an O(N) operation.

If the Sequence constraints are sufficient for whatever it is you need to do next (like map/reduce or convert to an array), then yes, `concat` would be faster than `push`. However, if you need the result to be a Vector, because you're going to do further modifications or you need near-O(1) `get`, then `push` will be faster than `concat`.
 I agree that better clarity around this is still needed. Some of this clarity I hope to get from using RRB Vectors so slice/concat/splice become mutative and draws a more natural line between sequence and mutative methods. The rest is better documentation around this distinction and philosophy behind itâ€”
Sent from Mailbox

On Tue, Aug 26, 2014 at 10:30 PM, Niklas BostrÃ¶m notifications@github.com
wrote:

> ## In the end I guess that this is a speed versus usability thing.
> 
> Reply to this email directly or view it on GitHub:
> https://github.com/facebook/immutable-js/issues/85#issuecomment-53528319
  This is expected. Set can only accept hashable values, which are either primitives or objects with a `hashCode(): int` method.
 Unfortunately native Set and Map's ability to accept any keys are very difficult to correctly polyfill as they take advantage of pointer identity which is only available within the VM, and not in JS land.

I'll ensure this is more clear in the documentation.
 Hey @alexeyraspopov I managed to add this functionality in 12c34bfcf4a9c176bc93d1e0a29456a09d9c0247 which will be part of an npm release soon.
  Closing as what we have today returns appropriately wrapped results.
  I think I understand what you're after - when iterating over a cursor, each entry returned should itself be a cursor (if relevant), yes? This is a great suggestion.
 Ok, I have a diff coming, but it doesn't solve your expected cases. And I don't think your expected cases should work.

Cursors should be lazy pointers to a value, and not a fully realized copy of the original. That means that any new cursors should be lazily created and therefore won't share pointer equality but will be value equal. As an example:

``` js
> var c1 = data.cursor();
> var c2 = data.cursor();
> c1 === c2
false
> Immutable.is(c1, c2)
true
```

This then also applies to your examples above which are expecting pointer equality, but will actually get two different cursors. However, you _would_ be able to do this:

``` js
c.get('users').every(function(user, index) {
   return user.deref() === c.getIn(['users', index]).deref();
});  // true
```

(Which is exactly what `Immutable.is` does for Cursors).
 3ae7fb1ae5a36c02c959c57f563d06e126cb2bfb Adds what you're looking for in the high level. Specifically, mapping over a Cursor to a Sequence and returning React elements should now do the right thing, giving each React element a Cursor rather than derefed values:

``` js
<div>
  {props.data.map(subData => <MyComponent data={subData} />)}
</div>
```
 Correct @Tvaroh, sorry for the post before test.

I'll work with the React team for a generic way to accept Immutable data structures as children.
 For reference I opened [react#2296](https://github.com/facebook/react/issues/2296) to handle this.
  Thanks for the report. I'll add this test and then dig in.
 I just added this test at 2c3978fd686f29a96e143888b0bd246ff7144387 using [jasmine-check](https://github.com/leebyron/jasmine-check) and it indeed fails. The smallest failing value is a map of 17 entries which means I've probably messed up an expansion from index node to array node, as that happens when the 17th entry is added.
 In fact - jasmine-check reduced the failing test to `{"0":0,"1":0,"2":0,"3":0,"4":0,"5":0,"10":0,"A":0,"c":0,"B":0,"D":0,"e":0,"":0,"F":0,"G":0,"h":0,"j":0}` which uniformly covers the hash space. So good.

Ok, I've got a lead on the failure point. I'll get a diff up soon.
  Thanks for the report! This is a bugâ€”
Sent from Mailbox

On Fri, Aug 22, 2014 at 8:01 AM, Kevin Dangoor notifications@github.com
wrote:

> FWIW, I just wrote this utility function, but I'd rather not have to think about "when do I need to use this?"
> 
> ``` javascript
>     function updateOrSet(treeData, path, setterFunc) {
>         if (path.length === 0) {
>             return setterFunc(treeData);
>         } else {
>             return treeData.updateIn(path, setterFunc);
>         }
>     }
> ```
> 
> ---
> 
> Reply to this email directly or view it on GitHub:
> https://github.com/facebook/immutable-js/issues/80#issuecomment-53071286
 Wait - @dangoor I cannot reproduce your issue. Your code example should work exactly as expected.

There is already a check: https://github.com/facebook/immutable-js/blob/master/src/Map.js#L91 which looks for falsey or empty key paths.

Can you ensure you're using the latest release of Immutable and re-test your reproduction case?
 @andreypopp can you reproduce this?
 Ok, I'm going to close. @dangoor please re-open or just shout if you think I'm closing in error.
  This is great, thanks! Can you also change:

temporary mutable copy of a collection and applying a batch of mutations in a highly

To

temporary mutable copy of a collection and _apply_ a batch of mutations in a highly 
 (Just append that to your last commit, rather than make a new commit with --amend)
  Thanks for the report!
 Also, just for my interest - what environment are you using? Node, Chrome, Firefox?
  Hi @ide!!!

Yes, let's consider this a bug. Any "mutative" action that results in a no-op should return self. 
 Based on your example though, it's working as expected. A "mutative" method will only return self when the set/merged values have pointer equality. 

In your example you have two instances of Set (which are value equal) since they are different instances the mergeDeep should return a new object. 

I tested this though and the bug does exist when there is pointer equality. 
 Yeah, that may be true. However, I think a common case of using mergeDeep is to merge two JSON bodies together - in which case it will walk down to scalars and those will `===` and you'll get the optimization. It's only when you're dealing with non-mergeable object pointers that you'll lose it. `Set` doesn't support deep merging currently (another to-do) - but if it did then this should behave as you expect.

I just want to avoid doing value equality checking on set/merge as it could potentially be expensive if the objects were quite large - and because set/merge is often done in batches, I want to keep that method pretty streamlined.
 Heads up that with this last diff, your example case still doesn't do what you expect because of the outstanding issue that Set is treated as non-mergable and thus uses pointer equality when merging.

``` js
> var set = immutable.Set('x')
> var map = immutable.Map({key: set})
> var map2 = map.mergeDeep({key: immutable.Set('x')})
> var map3 = map.mergeDeep({key: set})
> immutable.is(map, map2) // The new map has value equality to the old map
true
> map === map2 // Set pointer inequality caused a new value to be created.
false
> map === map3 // Set pointer equality resulted in no modifications
true
> map.key === map2.key // maps, not records, so both return undefined
true
> map.get('key') === map2.get('key') // two different Sets
false
> immutable.is(map.get('key'), map2.get('key')) // but with value equivalence
true
```
 Tracking set in #76 
 Ok, after 3e1e874af1863bb34d68b473692d03f57d35622e your example behaves as you expect.

Now that you've illuminated this one, I've seen a few other places where this bug exists. Thanks, James!
 And published as 2.0.14
 Send feedback as you have it! Miss you, man.Â â€”
Sent from Mailbox

On Wed, Aug 20, 2014 at 6:46 PM, James Ide notifications@github.com
wrote:

> ## awesometown
> 
> Reply to this email directly or view it on GitHub:
> https://github.com/facebook/immutable-js/issues/75#issuecomment-52860852
  Thanks for the report. I'll correct this.Â â€”
Sent from Mailbox

On Sun, Aug 17, 2014 at 1:59 PM, Simon Edwards notifications@github.com
wrote:

> I have typescript code which compiles fine using:
>     ///<reference path='./node_modules/immutable/dist/Immutable.d.ts'/>
>     import immutable = require('Immutable');
> But when this code is run via node it fails and complains that it can't find module 'Immutable'.
> The problem appears to be related to the use of upper and lowercase 'i' for immutable. If I put a symlink called 'Immutable' inside my node_modules directory and pointing to 'immutable', then my code starts up fine.
> 
> ## I'm using Linux and a case sensitive filesystem. This problem probably won't appear on case insensitive file systems.
> 
> Reply to this email directly or view it on GitHub:
> https://github.com/facebook/immutable-js/issues/73
  Excellent feedback. Thank you!â€”
Sent from Mailbox

On Sun, Aug 17, 2014 at 12:15 PM, Tim Griesser notifications@github.com
wrote:

> Saw that you've added cursors to the library and were looking for feedback. Very cool.
> I've been working on an implementation of om-style cursors based on mori's data structures, using a custom build of mori which allows for extending [vanilla JS objects with cljs protocols](https://github.com/swannodette/mori/pull/108) (thanks to some great tips from @swannodette)
> https://github.com/tgriesser/mori-cursors
> One of the coolest things about the om-style cursor implementation IMO is the ability to treat them as basic persistent data structures, each time a value is returned (`get`, `get_in`, `assoc`/`dissoc`, any seqable functions, etc.), so long as the value isn't a primitive, you'll receive a new cursor of the appropriate type (`MapCursor` / `VectorCursor`) which continues to keep track of its path in the root object automatically.
> As far as I can tell, in the current implementation, you need to explicitly call `cursor` to create sub-cursors, and even then, it's a bit limited in scope with regards to being able to modify the local value of the cursor. 
> For example in the implementation I linked above, you could have something like (using immutable's api):
> 
> ``` js
> var data = Immutable.fromJS({
>   users: [{
>     name: 'Test',
>     accounts: { /* deep nested data */ }
>   }, {
>     name: 'User',
>     accounts: { /* deep nested data */ }
>   }]
> });
> var c = data.cursor();
> c.get('users') // would return a new VectorCursor, path ['users']
> c.getIn(['users', 0]) // would return a new MapCursor, path ['users', 0]
> c.getIn(['users', 0, 'name']) // would return 'Test', since name is a primitive
> // Returns a new MapCursor, path ['users', 0], just without the 'accounts'
> // map. This is useful in cases like React where you want to slice and dice into
> // sub-cursors with a limited scope of data for efficient shouldComponentUpdate
> c.getIn(['users', 0]).delete('accounts')
> ```
> 
> So the main idea is that the cursors should behave exactly like their respective data-structures from an API standpoint, only differing with the underlying "type" of the cursor, automatically keeping track of their path (which is hugely valuable).
> Another main difference between this implementation and the one I mentioned above, is the idea of a "root" cursor, which sub-cursors are created from / updating against. There doesn't seem to be much value of just locating/updating values if they aren't coming from a central "root" object. In OM's case, I believe this is an atom, in the project I linked above it's just a special `RootCursor` which also acts an EventEmitter. My implementation is also pretty basic compared to OM's, nothing about deref'ing / taking into account render states.
> 
> ## Really cool to see that you're adding them to this project though, I've found them invaluable when using persistent data-structures with React, interested to see what you think about these ideas.
> 
> Reply to this email directly or view it on GitHub:
> https://github.com/facebook/immutable-js/issues/72
 I've started to add some of this feedback in. For example get() and getIn() now return Cursors when relevant.
 Closing this out since it's old and discussion has been slurped up. Thanks again for the feedback, guys! I'm excited to see more cursor implementations come to be.
  Thanks
  Try out React's `replaceState` instead of `setState`. `setState` expects a state "update" - explicitly an object of keys which it will "merge into" the existing state. Whereas `replaceState` actually takes an entirely new object which will become the new state.
 @samwgoldman has the right idea here. React is trying to move away from `replaceState` in the future, and in v0.13 `setState` can accept a delta function:

``` js
getInitialState() {
  return { data: Immutable.Map() };
}

...

this.setState(state => ({ data: state.data.set('x', 1) }));
this.setState(state => ({ data: state.data.set('y', 2) }));
```

The setState delta functions will be called in the order supplied.
 @andersekdahl at this time, no. You should bring that up on the React github issues if you want to discuss further.
  Let me consider this. Debugability is certainly a valid concern. Webpack, browserify, et-al should behave the same on an already minified source. The primary reasons to keep it small is an improvement on load and parse time and to provide a decent default behavior if browserify does not sent its results through a minifier.
 I like your suggestion of .min.js - so rather than changing package.json - I changed the build step. The end result is still what you're after.

Thanks again for bringing this up.
  As spec'd (kinda) in:

https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/The_Iterator_protocol
https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/iterable
http://wiki.ecmascript.org/doku.php?id=harmony:iterators
http://wiki.ecmascript.org/doku.php?id=harmony:specification_drafts
 0164a55a13a476516e3bdf7e5316a173974ad05a Adds Iterator methods to Vector, Map, Set, OrderedMap
 049eff1482884be0c4e74080c2c18acb9447f2d5 Adds ES6 Symbol.iterator polyfill
 Hey Joseph, what version are you using?â€”
Sent from Mailbox

On Fri, Aug 29, 2014 at 1:51 AM, Joseph Silvestre
notifications@github.com wrote:

> Hi,
> I'm not sure it's the right place to ask/tell but I've tried to use `orderedMap.values()` but the result does not seem to have a `done` property nor `next()` method. Is it a bug or am I just misusing it?
> 
> ## Thanks.
> 
> Reply to this email directly or view it on GitHub:
> https://github.com/facebook/immutable-js/issues/68#issuecomment-53851968
 Not yet, but I have that on my short list!â€”
Sent from Mailbox

On Mon, Sep 22, 2014 at 8:54 PM, voodoohop notifications@github.com
wrote:

> ## is there any way to create a lazy Sequence directly from an ES6 generator?
> 
> Reply to this email directly or view it on GitHub:
> https://github.com/facebook/immutable-js/issues/68#issuecomment-56465081
 As of v2.3.0, all Sequences can be iterated and all collections can be constructed from an Iterator or Iterable.
  Use `Record`!

Check it out in the API docs
â€”
Sent from Mailbox

On Fri, Aug 15, 2014 at 6:54 AM, Manuel Simoni notifications@github.com
wrote:

> Hi, I'm using immutable-js for all data structures in a project of mine and am enjoying it very much. The only thing that bothers me is that I lose type safety / information when using Maps as a replacement for JS objects.
> Say I use a map to store information about a Person (like name and age). Is there some way to make it a real Person object and not a Map, so my code can say `instanceof Person`, and maybe even call custom methods on it?
> 
> ## Or is there another way to get some level of type safety when using Maps?
> 
> Reply to this email directly or view it on GitHub:
> https://github.com/facebook/immutable-js/issues/67
  They will not have pointer-equality as === enforces. Use `Immutable.is(v2, v3)` for value-equality.
 (Similar to `Object.is()`)
 `withMutations` isn't going to do much for you here since `slice` is not a mutative method (eg, method that returns the "mutated" collection), but lazy sequence generating methods.

However, the purpose of `withMutations` is to improve the performance of calling multiple mutative methods in a row (lazy sequence methods are already performant to call in a chain). `withMutations` still returns a "new" collection, which is exactly what persistent immutability is all about. Because of how JS evaluates `===`, only scalars like strings and numbers are evaluated for value equality and all objects are pointer equality.

Example:

```
[1,2,3] === [1,2,3]
// false

Imm.Vector(1,2,3) === Imm.Vector(1,2,3)
// false

Imm.is([1,2,3], [1,2,3]) // note: arrays are not immutable, they won't be treated as values.
// false

var arr = [1,2,3];

arr === arr
// true

Imm.is(arr, arr) // pointer equal
// true

Imm.is(Imm.Vector(1,2,3), Imm.Vector(1,2,3))
// true
```

Short of making a mutable collection, `===` will always return false for two different objects, even if they represent the same value.
 No problem!
  That TODO is suggesting something else - but I'm glad you've identified that the issue lives somewhere nearby!

Thanks for the report, I'll dig in.
 Hey thanks - also feel free to send pull requests as you review!
 I just added a more generic version of your test case in c1bdb78f62b79ada7e1a96feaac8b2f33914c94e which indeed fails as you've described it.

```
Vector â€º it unshifts multiple values to the front ( [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0], [0] )
Expected: {0: 0, 33: 0} 
toEqual: [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
```
 Thanks again for the report, this one ended up being pretty straight-forward to fix.
  Ah thanks for finding the repro case! I've heard reports of this stack exception but didn't have a small case yet. I'll dig into this.Â â€”
Sent from Mailbox

On Wed, Aug 13, 2014 at 7:43 AM, brandys11 notifications@github.com
wrote:

> I have noticed that when key with different hash is set to  `HashCollisionNode` new `BitmapIndexedNode` is being created with wrong hashValue for `HashCollisionNode` (hash value of new key is used instead of `collisionHash`).
> This piece of code leads to "_Maximum call stack size exceeded_"
> 
> ``` javascript
> var map = Immutable.Map();
> map = map.set('@', '')
> map = map.set(64, '')
> map = map.set(96, '')
> ```
> 
> ## The bug can be found here: [src/Map.js#L324-325](https://github.com/facebook/immutable-js/blob/95fdfa49b224dac7cc505f8063d6c891a67d7ed7/src/Map.js#L324-325)
> 
> Reply to this email directly or view it on GitHub:
> https://github.com/facebook/immutable-js/issues/64
 This will go out as one of the next point releases (sometime today)
  Thanks for the report! Just to be clear, you're only seeing this issue for OrderedMap - yes? Map and Vector are not suffering similar leaks?Â 

Also, just curious, what runtime are you using to get these numbers? Node? Chrome?
â€”
Sent from Mailbox

On Wed, Aug 13, 2014 at 5:59 AM, brandys11 notifications@github.com
wrote:

> Using `UnorderedMap` for longer time can consume lots of memory.
> For example this code: 
> 
> ``` javascript
> var map = Immutable.OrderedMap({'b': 'b'});
> for(i = 0; i < operations; i++) {
>     map = map.set('a', 'a');
>     map = map.delete('a');
> }
> ```
> 
> leads to this memory consumption :
> operations | Memory (kb)
> --------------- | -----------
> 1000 | 16000
> 10000 | 19000
> 100000 | 23000
> 1000000 | 58000
> 10000000 | 160000
> It is because indexes are created sequentially and calling `Vector.delete(index)` does not free any memory. 
> 
> ## The element `b` is there to ensure that UnorderedMap does not become empty and remove `Vector`.
> 
> Reply to this email directly or view it on GitHub:
> https://github.com/facebook/immutable-js/issues/63
 Closing now, OrderedMap should no longer have this leak.
  Thanks. Tired eyes...
  Certainly an issue. The custom traceur runtime should be scoped to only apply to the guts of the library and shouldn't conflict. I will figure out what's going on here.
 Thanks again for the report - it should be fixed in v2.0.9 now on npm
 spicyj - jstransform was a little more limited in transform coverage and ended up outputting verbose transforms of "class" that didn't crush well. Traceur expects a massive external library which is a bummer but I made a custom version that's tiny and only supplies the few things needed.

I think we've talked about adding some customization to jstransforms treatment of classes which could make this work.

Ultimately it came down to minified & crushed size.
  Curious. Let me dig into this further and see what's going on. Thanks for the report.
 Thanks again for snooping this one out.
  Let's rename to "rest" and "butLast"
 Why close this, @rockymadden ?
 Okay, you should reopen so I don't forget about it. 
 Done! It's in 2.0.10
  Thanks Rocky! I've taken your pull and changed it a bit before landing it. I added a related test which was also failing but your pull didn't yet address. I also just pushed this as v2.0.7
  On your note about lacking in-practice examples - yes I agree. I'm hoping to see some of these evolve from community usage and will later consider making contrived cases and putting them in an `/examples` dir.
 So you're looking to maintain the order of this array of records but also have the ability to look up each one by id. Then yes, OrderedMap is what you want, but of course OrderedMap expects key/value pairs, not just an array.

Here's one way to do it - building up the OrderedMap manually. Let's call your posted data, `var data = [...];`.

First, let's show how we would do this very simply, but not yet efficiently:

``` js
var map = Imm.OrderedMap();
data.forEach(record => {
  map = map.set(record.id, Imm.Map(record));
});
```

The problem here is that we're creating a whole new Map for every set. Because of structural sharing this isn't as bad as it would be if we were really cloning the whole data structure, but we can still do better since we want to think of this as "one operation". You're idea to use `withMutations` is the right one!

``` js
var map = Imm.OrderedMap().withMutations(m => {
  data.forEach(record => {
    m.set(record.id, Imm.Map(record));
  });
});
```

This will be very performant, as it only ever creates a single map data structure.

Note that we had to use forEach and side effects to perform this task. That's really just perfectly fine, but if we wanted to do this in a more pure function style, we could use Sequence operations:

``` js
Imm.Sequence(data).mapKeys((_, v) => v.id).map(v => Imm.Map(v)).toOrderedMap();
```

This is a nice one-liner. It's almost exactly the same "under the hood" as the previous example using forEach. `mapKeys` to replace the array's indices with the `id` property of the record that we want for our OrderedMap. Then we `map` the JS object values to Immutable Maps, then we turn that lazy sequence into a concrete structure - our OrderedMap.
 Totally agree! It's on my list to make that .d.ts much easier to look at.
 I just pushed v2.0.8 which adds `mapKeys` which makes this even easier to write (edited above)
 Damn!
 Wait, what's wrong with the comment?
 oh yep. totally right. thanks, my eyes must be tired.
 fixed in master now
 It won't give the same result. Without `.map(v => Imm.Map(v))` you will have an immutable OrderedMap of mutable JS Objects. With it, you will have an immutable OrderedMap of immutable Maps.
  Can you separate this into two pull requests? One to fix the range bug and the other for adding new functionality. 

For the range bug, can you add a test case that fails without your patch and passes afterwards?
  Yeah, great idea. I prefer Clojure's naming convention here since it better pairs with the existing `first` and `last` methods. How about using `rest` instead of `tail` and `butLast` instead of `init`?

(I always found "init" confusing since it's a popular abbr. of "initialize")
 Thanks, you definitely picked up on the theme!
  Definitely possible! In this library, such 2-element tuples are called "entries" to match the existing JS definitions.

Say you have a sequence of tuples:

``` javascript
var rawTuples = [['a', 1], ['b', 2], ['c', 3]];
var seqEntries = Immutable.Sequence(rawTuples);
```

Now we can convert a tuples sequence into a k/v sequence (lazily):

``` javascript
var seqKV = seqEntries.fromEntries();
```

And then from this sequence we can convert it to a map:

``` javascript
var map = seqKV.toMap();
// Map { a: 1, b: 2, c: 3 }
```
 Recently, I changed the behavior of Map's constructor to accept these as well - as it matches the ES6 Map specification. So now simply `var map = Map(rawTuples)` will do what you expect.
  Yes, you can do any method within update, including delete.Â 

updateIn(['a','b'], map => map.delete('c'))â€”
Sent from Mailbox

On Mon, Aug 11, 2014 at 12:29 AM, Naresh Naredla notifications@github.com
wrote:

> var nested = Immutable.fromJS({a:{b:{c:[3,4,5]}}});
> Assume i am having above nested map...so i want  to delete key(c) and its values also..
> To update value we have updateIn() method,
> like that , is there any method to delete ?
> 
> ## How to do that ? could you please help me 
> 
> Reply to this email directly or view it on GitHub:
> https://github.com/facebook/immutable-js/issues/53
  I'm not sure I understand the question, but certainly immutable-js supports applying diffs. I think `mergeDeep` is probably what you're looking for.
 Ah, I understand. I think that is out of scope for this project. Such a process should be equally applicable to non-immutable objects. You might want to look into `JSONPatch` to get started with this.
  Totally agree. Because of how immutable JS currently handles iteration this can't be done efficiently yet, but can be done. I'll look into adding these in a next minor release!â€”
Sent from Mailbox

On Sun, Aug 10, 2014 at 12:01 PM, Rocky Madden notifications@github.com
wrote:

> ## Sequence zip, zipall, and zipwithindex a la something like Scala would be delightful: http://www.scala-lang.org/api/2.11.2/#scala.collection.Seq
> 
> Reply to this email directly or view it on GitHub:
> https://github.com/facebook/immutable-js/issues/51
 Here's a question for you zip fans (cc @rockymadden, @stiff, @tolmasky)

Other languages provide the pair `zip` and `zipWith`, the latter taking a specific zipping function, much like clojure's `map`.

```
var a = List.of(1,2,3);
var b = List.of(4,5,6);
var c = a.zipWith(List.of, b);
// List [ List [ 1, 4 ], List [ 2, 5 ], List [ 3, 6 ] ]
```

So question: if there is also `zip`, what should the default zipping function be? `List.of` or "tuple" (`(...args) => args`).

I imagine this depends on what you plan on using zip for. It's often used in clojure to create k,v pairs to build maps from, in which case we would want "tuple", but of course if you're using it to build more immutable structures, you would want `List.of`.

Hidden option C is that `zip` is not provided at all, only `zipWith`, so you have to be explicit about this, very clear but a bit verbose.

Thoughts?
 Will be included in the next release
  The correct phrase here is "does no work". So this is not a typo. Perhaps it would be more clear as "performs no work"
  Haha you're right. This wasn't a typo. 
  Thanks!
  Is it possible? I'd love to be able to use immutable-js collections as keys or include them in sets.
 This is on my todo list :)
 fantastic, i cant wait. how are you going to do it?
 I'll borrow the hash algorithm from clojure's map, probably :)
 sounds good.
 Correct
 This is now closed by 12c34bfcf4a9c176bc93d1e0a29456a09d9c0247
  Hey, can you clarify your question? What do you want from the Vector?â€”
Sent from Mailbox

On Fri, Aug 8, 2014 at 10:26 PM, Naresh Naredla notifications@github.com
wrote:

> ## please reply me any one its important to me...please thank you
> 
> Reply to this email directly or view it on GitHub:
> https://github.com/facebook/immutable-js/issues/46#issuecomment-51677794
 So I'm still not 100% sure what you're asking, but it sounds like iteration in which case I think you're looking for `forEach` which might look like

vect1.forEach(function(value){ do work here });
 The reason `vect1.map(...)` will not call the values is that `map()` returns another lazy sequence, the function within is only called when necessary when the resulting sequence is operated on. The documentation for that method specifies that you should not rely on side-effects from that method.

`forEach` is a non-lazy operation, designed to provide side-effects.
  The minified version should actually change the delete references to property accessors (uglify manages our IE8 support). So if you use the distributed compressed library, you should get IE8 support.

However, I'm not sure the library is IE8 safe as there are some ES5 library function calls made that will probably need to be polyfilled. I have not yet tested IE8, so I can't tell you for sure.
 Are you seeing similar issues with IE8 from the compressed distributed build?
 Should now be fixed by c22e45d557d99e3104515ed8707ea68561746c6f
  Since that value is a mutable object, not an immutable map, the immutable API does not apply to it (see [Object's API](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object)). If your update backs up one level, then it points to the object instead of the key within the object:

```
var map1 = Immutable.Map({a:1, b:{d:2}, c:3});
var map2 = map1.update('b', function (value) { value.d = 1000; return value; })
```

However, note that this has mutated a mutable value, which your original `map` still points to, so in this case `map2 === map1`.

You could also return a copy of this object:

```
var map1 = Immutable.Map({a:1, b:{d:2}, c:3});
var map2 = map1.update('b', function (value) { 
  var newValue = {};
  for (var k in value) {
    if (value.hasOwnProperty(k)) {
      newValue[k] = value[k];
    }
  }
  newValue.d = 1000; 
  return newValue; 
})
```

And now `map2 !== map1` and `map1`'s mutable object has not been changed. However this highlights one of the use cases of Immutable Map. If you desired the second behavior, then using an immutable Map instead of a mutable Object as a nested value would provide an API much easier to work with:

```
var map1 = Immutable.Map({a:1, b:Immutable.Map({d:2}), c:3});
var map2 = map1.update('b', function (value) { return value.set('d', 1000); })
```
  I believe your second question is answered by #44 
  Hey @arnemart - I'm not familiar with cursors, can you fill in me on the pros/cons of this or what example code taking advantage of it might look like? I'm a little bit worried about adding more overhead to mutations but if it unlocks some awesome use cases then we should carry on.
 Cursors sound pretty cool, but it also seems (from my admittedly limited reading of om) that Cursors depend on data structures rather than vice-versa. In other words, it seems like what we would want to do here is build a tiny "Atoms and cursors" library which use immutable-js, rather than having cursors as a feature of immutable-js. Am I off-base?
 Nice!
 I'm glad you're enjoying them. They're definitely still experimental, so bring feedback as you have it!
  Thanks for the report - this definitely seems like a bug.
 Unfortunately I believe this is a wont-fix, unless someone can teach me something new about `console.log`. node looks for `inspect` because it's `console.log` is powered by `util.inspect`. In the browser I don't think we have an equivalent.

Fortunately, the workaround shouldn't be too much trouble. Just `console.log(myImmutableObject.toString())` or `console.log('' + myImmutableObject)`
 Note: when Direct Proxies are the norm (the distant future), this will work correctly :/
  Clever, thanks for sharing this. I'll investigate what adding this might look like. 
 Hey @jasonkuhrt - I'm a huge fan of functional libraries, and the functional tools you're talking about (I even have a project to add some haskell style functions and operators to JS called [loda](https://github.com/leebyron/loda-js)).

I'm not making a call on this yet, but so far I've been thinking that a functional API just isn't the right thing for this library, considering its design guideline is to mirror idiomatic ES6 JS which, unfortunately, doesn't favor the point-free functional composition style.

I really like the idea of building a sister library which provides a functional curried API for all of the Immutable collection prototype methods.
 I'd love to see what you end up with here, that sounds cool.

From a technical point of view, they need to be methods because there are different implementations of a method name for each type. Clojurescript makes point-free functions work via double-dispatch, so there are methods going on under the hood. I would probably recommend a similar architecture for a functional layer over this library, where the free functions simply called into the methods for free specialization. 

Example:

``` js
function map(fn) {
  return function(collection) {
    return collection.map(fn);
  }
}
```

The nice thing about this approach is that such a library of functions would work equivalently on both ES6 collections (Array, Map, Set) and Immutable.
 I'm actually going to close this issue. I think it's decidedly out of scope, but if no one else gets to it first, I probably will write a fp wrapper for this library in the not-too-distant future :)
 Share what you build! Looking forward to it.
  Not yet known, you're definitely giving it a good stress test. 

Is there a more contrived version of this that you can share so I can figure out what's up?
 Oh I just re-read this and realizing you said splice() not slice(). Yes, splice is quite inefficient. 
 If you're calling it repeatedly, you might try replacing .splice(...) with .splice(...).toVector()
 splice() is definitely an exensive operation regardless as everything after the splice point needs to be shifted (moved in memory) for regular arrays. The same is true for a HAMT.

I was thinking about this a bit and wonder if you might benefit from a different kind of data structure that's designed around making splice() fast. Linked lists are really fast at this if you're willing to give up O(1) access and immutability. Perhaps some kind of b-tree would be well adapted to immutable(persistent) form and deal well with splicing.

What's the specific use case here?
â€”
Sent from Mailbox

On Tue, Aug 5, 2014 at 1:43 PM, Nathan Sobo notifications@github.com
wrote:

> For now I'm just building a new vector as they're quite small.
> 
> ## Is this inefficiency inherent in the nature of the trie data structure you're using or something implementation-specific? Do the ClojureScript data structures exhibit this issue?
> 
> Reply to this email directly or view it on GitHub:
> https://github.com/facebook/immutable-js/issues/38#issuecomment-51256755
 I'll definitely keep it in mind, so I'll keep this open. At the very least I think a real TODO is clarifying splice()'s use with withMutable and even finding incremental perf improvements.Â â€”
Sent from Mailbox

On Tue, Aug 5, 2014 at 3:04 PM, Nathan Sobo notifications@github.com
wrote:

> ## Yeah, great point. I'll just replace the entire `Vector` for now because it has so few elements. Thanks for your thoughts. Feel free to close this unless you'd like to look into improving `splice` so far as it's possible.
> 
> Reply to this email directly or view it on GitHub:
> https://github.com/facebook/immutable-js/issues/38#issuecomment-51267032
 Interesting. I'll read up! Thanks guys.Â â€”
Sent from Mailbox

On Wed, Aug 6, 2014 at 6:23 AM, Alexander Semenov
notifications@github.com wrote:

> ## BTW, that official paper on RRB trees is lacking many details. I would recommend to look at this [thesis](http://hypirion.com/musings/thesis).
> 
> Reply to this email directly or view it on GitHub:
> https://github.com/facebook/immutable-js/issues/38#issuecomment-51333012
 My understanding was the constant perf hit only came if the RRB nodes are in the path, which means the result of slice/concat.Â 

I'm interested to hear more though.Â 

â€”
Sent from Mailbox

On Fri, Oct 31, 2014 at 10:51 PM, Scott Feeney notifications@github.com
wrote:

> @hypirion (author of the thesis above): didn't you say you found RRB-trees slower in practice (like, by a constant factor) than the Clojure-style vector for some operations?
> 
> ## I bring this up because if so, that may be an argument for presenting RRB-trees as an alternative implementation rather than replacing the current one.
> 
> Reply to this email directly or view it on GitHub:
> https://github.com/facebook/immutable-js/issues/38#issuecomment-61359140
 Thanks @hyPiRion this is really helpful.
 Nice work @Pauan!

I haven't spent much time benchmarking or optimizing Immutable.js yet, so there are likely some wins to be had. A huge thanks to you and @swannodette for illustrating some baselines to strive for. It's always awesome and inspiring to see the headroom to strive to close :). However one thing I want to be cautious of, and part of why I've under-prioritized benchmarking, is comparing benchmarks to every day use. I don't think benchmarks are enough to prove or disprove an idea unless they closely mirror common use scenarios. AVL trees are really interesting and I'm looking forward to seeing how they may play a role in this lib, or at least in the new landscape of these structures as a whole. May I also suggest a composite test where reads and writes are interleaved at different frequencies? Most common use tends to read a lot more than write which is part of why Clojure/Scala/immutable chose to optimize for reads instead of writes
 Totally. The beauty of data structures is that there are so many variants and each one has its ideal use. 
 @swannodette Exactly my point. Clojure & ClojureScript's performance is the result of multiple smart people working diligently for quite a long time with production performance in mind. And it's seriously impressive and inspiring (like, literally inspiring, like literally inspired this project). My hesitancy towards benchmarks is simply to ensure they don't become the driving force for optimization work which in my experience on other projects has often led to _worse_ performance for production apps, or distraction from more important work. Always focus on production performance first. Immutable.js has a long road to follow, and many great ideas to borrow to get there (including this task). Putting together a benchmarking rig is on my todo list, with benchmarks designed to mimic common patterns, and I'll want to do that before going deep on performance tweaking, but production use and perf is still going to be my end-goal :). Not there yet!
 I had to make slice non-lazy to fix some behavioral issues, my intent is to make it lazy again in the future (and by lazy, I mean just a view on a backing List, same as subvec).
 Yeah, guys I'm gunna have to call this convo over (at least in this context) because we've gotten pretty off-topic from RRB trees :). You've both inspired me to a) investigate some alternative options for speeding things up and b) add a benchmarking harness of some kind to start tracking this stuff better.

When I get a benchmark harness up, I'll be psyched to get your feedback.
  This is a bit subtle, but splice is not available as a mutative method. It always returns a sequence. Because splice needs to push the indices of the elements after it, it always needs to create a new vector.

I agree that this behavior isn't super obvious though. I think the code you wrote should have done what you expected. Unfortunately right now it doesn't. The answer is to (outside of withMutations) do vect.splice(...).toVector()
 This behavior is also made clearer by RRB, so now tracking this in #38
  Yeah, I think this is out of scope for `immutable-js` because it's not intended to be a transport and there is no standard for this (and I don't want to force a proposed standard). For example, what if someone sets the key "type" on a map/set? There's then a collision.

I do recommend using something like transit-js for this. Or, a function to do this should be pretty straight-forward. Then our `fromJS` method should already support this by providing a `converter` function as the 2nd arg and checking for this "type" key.
  Thanks for the report, and for building this awesome benchmark! If you happen to hit this exception again, see if you can get the contents of the Map and the operation resulting in the exception and I will look into it.

I have yet to do any benchmarking for this young library, and I'm actually pretty impressed that it's doing as well as you've measured. I'll be using your benchmark while I improve the performance of this library.
 Also, you mention about this library - "The API is richer and will be familiar to OO programmers, but I disagree with many of the design decisions." - I'm interested to hear more of your feedback. Is this a general concern about OO vs functional APIs, or are there more specific parts you were referring to?
 Good feedback and great arguments here, and overall I tend to agree with you and with the general sentiment that OO APIs have some real drawbacks. I think I would apply this concern to pretty much all of JavaScript's (and most/all OO languages') core API design principles.

However the goal of this library (and a personal goal of mine) is to bring some of the ideas forged in functional languages to a vanilla JS environment with approachable APIs, which means prototypal OO methods.
 Thanks guys. I just haven't done any performance tuning yet. I definitely plan to do so. The first step is finding an accurate way to measure the performance across all runtimes.Â â€”
Sent from Mailbox

On Sun, Aug 17, 2014 at 1:57 PM, Chris Pettitt notifications@github.com
wrote:

> ## Commenting to follow this more than anything. I'm working on a persistent graph library and am seeing hamt outperform immutable by anywhere from 2 - 3.5x ops/sec. I would love to see immutable improve  - I prefer its API to the hamt API.
> 
> Reply to this email directly or view it on GitHub:
> https://github.com/facebook/immutable-js/issues/35#issuecomment-52434765
 Hey @cpettitt I just released v2.0.12 to npm which has some considerable performance improvements.
  Excellent sleuthing and minimal fix. Thanks for including the test! I'm sure you just fixed a few other subtle bugs we haven't come across yet with this one. 
  Yes, this is documented on "length" in the API docs, but I definitely understand that this behavior can be non-obvious. 

The current way to do this is:

```
seq.filter(...).cacheResult().length
```

This issue is good feedback that this should be much easier to do. I'll find a way to make this work the way you expect
 And your intuition is correct that this is the result of sequences being lazy. Without actually performing the filter, we cannot know the length of the resulting sequence. 
 Just to be clear, the new way to do this is:

`seq.filter(...).count()`
 Or! `seq.count(...filter function...)` works great for your use case. 
  BTW, I pushed a version to NPM that fixes this issue last night
  I'll look into this thanks for the reportâ€”
Sent from Mailbox

On Fri, Aug 1, 2014 at 2:05 PM, Alexander Semenov
notifications@github.com wrote:

> Example:
> 
> ``` javascript
> // having a set of ids
> var ids = Immutable.Set('a', 'b', 'c');
> // and some data
> var data = Immutable.fromJS({a: {foo: 'bar'}, b: {foo: 'bar'}, c: {foo: 'bar'}})
> // let's get data items by id
> var items = ids.map(function (id) { return data.get(id); });
> // and group them by 'foo'
> var grouped = items.groupBy(function (o) { return o.get('foo'); })
> // let's take the first item
> var first = grouped.first();
> // and to string it (notice the absence of comma between inner maps)
> first.toString() // "Seq [ Map { foo: "bar" }Map { foo: "bar" }Map { foo: "bar" } ]"
> // finally convert to array
> first.toArray() // [undefined Ã— 3]
> // 3 times undefined??? WAT
> ```
> 
> If we add `toVector` call just after `groupBy`, this scenario works correctly.
> 
> ## I apologize for the long description, this thing was driving me crazy...
> 
> Reply to this email directly or view it on GitHub:
> https://github.com/facebook/immutable-js/issues/31
  Thanks!
  Definitely! This is high on my list of additions for the next minor release!
 Released in 2.0.6!
  The one liner would be:

``` javascript
newMap = oldMap.updateIn(['test1', 'test2'], x => x.set('d', 4));
```

@JannesMeyer does this do what you're looking for?
 I'll definitely keep in mind the suggestion to add convenience methods for more specific actions and for creating intermediate maps.

The main reason I haven't add this yet is that I was concerned it would be confusing in the case that one of the keys is numeric - should it create a Vector or a Map? Probably always a Map, but there may be a case where a Vector was intended but there's no way to make that happen. I still think this could be really valuable though, so I'll keep it in mind for a future minor-version.
 I'll open this back up. Good feedback.
 Done :)
 Nope, after this diff landed, you can now write:

oldMap.setIn(['test1', 'test2', 'd'], 4);
  Do you like this better than `filter().length()`? I really like this idea, but I worry that people already have ideas about count() being a simple getter that takes no args (from Java's collections API). 
 Oh you're totally right. Okay, I like this proposal. I'll make it so the predicate is optional, if you exclude it then it will calculate total length (lazily if possible)
 That's exactly what I'm thinking. 
  Thanks yous!
  This is great, I've been planning on something like this, but glad you're thinking in the same lines.

It would be even better if dist resulted in a single file which can be included directly, included by an AMD system, or required by Node. Also, let's leave out the version number from the file - that will allow the package.json to point to the fire directly and keep it consistently named. The npm package itself is versioned, so we shouldn't need this info repeated here.

Exciting!
 I think it might just require wrapping the result of ugly-browserify with an AMD wrapper.
 @Tvaroh - I just added similar benefit in 95fdfa4. It replaces the dist directory with a built and minified file that's wrapped in a universal module so it can be used by node, amd or a script tag.
  I'm not sure I understand, could you give a small code example of what you're intending to do, or how you might expect `update` to be used?
 Ok, I understand. This becomes shorthand for

```
m.set('key', m.get('key') ... );
```

This is nice. Currently you could do this with:

```
m.updateIn(['key'], function (value) { ... });
```

I'll consider adding this in a future update
  Thanks for this suggestion, I agree that the learning curve here is less than ideal. I really like the idea of a single method which casts back to the original concrete collection type, I hadn't thought of that! I'll have a think on what naming scheme or API might best encapsulate that.
 That is conceptually ideal, but Vectors are concrete fulfilled data structures while a Sequence is lazy - it doesn't actually refer to any data, so defaulting to a concrete type means that every time we call a method that returns a sequence, we would actually have to build a new data structure.

The main idea here, with lazy sequences, is that chaining them becomes O(1) and casting the result provides many options. If you wanted to first filter your vector and then return the result as an array, Sequences offer the ability to do that in 1 operation instead of 2 saving memory and time.

However, the totally valid point that @Tvaroh has brought up is that a **common case** is that a single sequence method is called and the desired resulting value is the same type as the original, and this flexibility makes the common case at best more verbose than desired and at worst confusing. I agree with the problem, but will need to think about the best way to solve it.
 Transducers are great, and I'm working on using their concepts internally, but I'm trying to keep the API in it's current form to be more idiomatic to a JS environment, which a transducer API unfortunately is not.

If you prefer the transducer API, then you can absolutely use it. Immutable-JS works well with the few transducer JS libraries out there.
 Closing now that v3 is out and these collection methods are eager by default so they now behave exactly as desired by the OP. Operations can be safely chained and type information is maintained because each operation is eager! In v3 you must explicitly use .toSeq() first to use the lazy view API
 I like lazy behavior, and have built this library to take advantage of it. Seq is included as the primary tool for doing so.

The reason operations were changed from lazy to eager in v3 is that it was the biggest source of confusion for newcomers to the library. Lots of old github issues are about confusion as to why the operations were not maintaining the type they started with.
  Thanks for the report, great find! I'll write a test for this and fix the issue.
  There are a few reasons for this, but the primary reason is that every getter needs to be defined on every instance. That means every time you do a set, the new map needs to call `__defineGetter__` for every possible key that could be gotten. This would make mutations O(n), and I'd like to avoid that. Another, lesser reason is that an Immutable.Map can possibly have non-string keys.

I do actually take advantage for property getters functions for [`Immutable.Record`](https://github.com/facebook/immutable-js/blob/master/type-definitions/Immutable.d.ts#L1033) since the keys will always be strings and are pre-defined for each record type.
 That's correct @JannesMeyer - I'd love to experiment with Proxy support in the future, especially when ES6 is a little more broadly supported by both node and browsers, but since it can't be polyfilled it would unfortunately be an experimental feature for quite a long time.
 Map is API compatible with the ES6 Map, but not JS Object - unfortunately the language does not provide a capability to do that. There's some discussion in the JavaScript technical committee to find a way to provide read API compatibility performantly, but even with a decision made, it will be months or even more than a year from a first browser adopter, and many years until browsers with that feature are widespread to the point that we can rely on such a feature. 

Unfortunately that means custom data structures in JavaScript must have a different read API from Object and Array for the foreseeable future. 
  Thanks for the suggestion! I hadn't considered doing this before, but I definitely will start doing this for future versions.
 (I'll keep this issue open until I've integrated the grunt plugin and pushed the first github release)
 9552a11 is the first commit using grunt-release (which is **awesome** - thank you for the suggestion) and adds 2.0.4 (a few bug fixes, and `count()`!)
 I haven't gotten to WebJar yet. I'll reopen so I don't forget.
 I'm not sure what the WebJar artifact name guide is, I'll give you some context and let you make an informed decision.

On github, the project is called "immutable-js" because "immutable" is pretty broad, and github hosts projects of all sorts.
On npm, the project is called "immutable" because the "js" part is implied.
In spirit, the project is called "immutable", the "js" is added on when the context of being a JavaScript project isn't already implied.

My best guess is that WebJar is web specific enough that the "-js" isn't necessary.
 Thanks @guersam!
 Thanks @pluma :+1: 
  Thanks for this suggestion - I've been toying with the idea of doing exactly this but have held off before I have a performance testing set up in place (I wanted to avoid implementation complexity before I could measure it's value). I'm glad you've already found this change was worth it, that puts it higher on my list of priorities.
 In the meantime, `Sequence({k: 'v'})` results in something very similar to PersistentArrayMap for reads, but without the full map mutation API.

What I will likely do is make ArrayMap/HashMap an implementation detail of "Map" and just automatically convert between the types when the size of the collection gets past some tradeoff threshold.
 Very cool!
 I just added this in f7ec901e6e0d89caf69ba8a65f0c1c53cb137402 - but I'm open to feedback on improving it further! @swannodette if you see any missed opportunities, I'm all ears.
  Yeah, in truth these are more "inspired by" and less so conforming to the ES6 Map/Set API. For now it's less confusing to have one `keys` method rather than an additional `keySeq` - although I'm going to be paying close attention to how people use this library in their ES6 environments. It's not designed to be a full drop-in replacement for ES6 Map/Set because of these API variations.
 That is definitely a concern. But like I said - I haven't really seen much ES6 action yet, so based on people use it, I'll evolve it accordingly - that may result in making this change.
 This is now mostly solved with 0164a55a13a476516e3bdf7e5316a173974ad05a. There's still some work to be done, but this can now be considered closed :)
  Thanks Ben!
  Yes this is a typo on my part. I'll fix it!â€”
Sent from Mailbox

On Wed, Jul 30, 2014 at 11:26 AM, Kyle Dorman notifications@github.com
wrote:

> Hey, 
> Immutable looks pretty cool!
> While reading through the doc, I saw your merge example: 
> 
> ```
> var map1 = Immutable.Map({a:1, b:2, c:3, d:4});
> var map2 = Immutable.Map({c:10, a:20, t:30});
> var obj = {d:100, o:200, g:300};
> var map3 = map1.merge(map2, obj);
> // Map { a: 20, b: 2, c: 10, d: 1000, t: 30, o: 2000, g: 300 }
> ```
> 
> I think the resultant Map should be:
> 
> ```
> // Map { a: 20, b: 2, c: 10, d: 100, t: 30, o: 200, g: 300 }
> ```
> 
> Or is the obj meant to be in thousands?
> Cheers, 
> 
> ## Kyle
> 
> Reply to this email directly or view it on GitHub:
> https://github.com/facebook/immutable-js/issues/16
  Yeah I will probably hide toJSON and expose toJS which similarly does a deep conversion to plain JS objects, but doesn't muck with JSON.Â â€”
Sent from Mailbox

On Wed, Jul 30, 2014 at 11:32 AM, Felix Kling notifications@github.com
wrote:

> I also don't like this naming convention, but it actually has nothing to do with this library. `toJSON` is a special method that is used by `JSON.stringify` if it is available ([spec](http://www.ecma-international.org/ecma-262/5.1/#sec-15.12.3)). Built-in objects, like `Date` [implement such a method as well](http://www.ecma-international.org/ecma-262/5.1/#sec-15.9.5.44).
> 
> ---
> 
> Reply to this email directly or view it on GitHub:
> https://github.com/facebook/immutable-js/issues/15#issuecomment-50659438
 Hide as in not document beyond "supports JSON.stringify"â€”
Sent from Mailbox

On Wed, Jul 30, 2014 at 11:40 AM, Felix Kling notifications@github.com
wrote:

> @leebyron : This was actually more of a reply to @benjamingr :) Not sure what you mean by "hiding" in this case. The method should definitely exist to make JSON conversion easier.
> 
> ## I just dislike the choice of the method name in general ;)
> 
> Reply to this email directly or view it on GitHub:
> https://github.com/facebook/immutable-js/issues/15#issuecomment-50660507
 toJSON is no longer described at all in the type definitions file, but continues to exist as an alias for toJS so that JSON.stringify still behaves correctly. I also changed fromJSON to fromJS to solve for the same ambiguity.

Thanks for highlighting this point of confusion, @benjamingr!
  Ya let's call it TypeScript
 Thanks!
  Intentional to match array join's default. Reasonable?â€”
Sent from Mailbox

On Wed, Jul 30, 2014 at 9:14 AM, Ben Alpert notifications@github.com
wrote:

> ## â€¦while Sequence.prototype.join defaults to `','` -- intentional?
> 
> Reply to this email directly or view it on GitHub:
> https://github.com/facebook/immutable-js/issues/13
  Correct. All mutative methods return new collections. Add push() to this list. I thought I made that clear in that section of the readme but I can definitely improve it. It's a first pass as describing things.Â â€”
Sent from Mailbox

On Wed, Jul 30, 2014 at 9:10 AM, Matt Casey notifications@github.com
wrote:

> ## Either I am nit-picking or misunderstand the readme, but these two methods are listed as examples that would normally mutate a collection under "JavaScript-first API".
> 
> Reply to this email directly or view it on GitHub:
> https://github.com/facebook/immutable-js/issues/12
 Ahh. Yes, great point and currently confusing. I'll fix this.Â â€”
Sent from Mailbox

On Wed, Jul 30, 2014 at 9:18 AM, Isaac Salier-Hellendag
notifications@github.com wrote:

> ## I think @mattcasey is noting that native slice() and concat() are non-mutative, so listing them in a section that discusses "every method that would mutate the collection" isn't quite accurate.
> 
> Reply to this email directly or view it on GitHub:
> https://github.com/facebook/immutable-js/issues/12#issuecomment-50638524
  Ill loosen it. There's no reason other than I looked over it.Â â€”
Sent from Mailbox

On Wed, Jul 30, 2014 at 8:50 AM, Jingwei Liu notifications@github.com
wrote:

> Maybe loosen restriction in package.json to support for Node beta?
> 
> ## Or is there any particular reason to keep these restrictions?
> 
> Reply to this email directly or view it on GitHub:
> https://github.com/facebook/immutable-js/issues/11
  Yeah I prefer thinking of it as a namespace and keeping it capitalized, similar to React. I agree that if we change it in React then it should change here too.Â 

However this is just the readme, so feel free to define the var as lowercase in your own uses of it.Â 
â€”
Sent from Mailbox

On Wed, Jul 30, 2014 at 12:32 PM, Benjamin Gruenbaum
notifications@github.com wrote:

> At least he didn't name it `$`. I agree that whenever a function cannot be used as a constructor is it usually named in lowercase.
> 
> ## This project probably uses the same naming conventions as React, which also uses this naming convention so I'd rather see this naming stay or it change in both projects together.
> 
> Reply to this email directly or view it on GitHub:
> https://github.com/facebook/immutable-js/issues/10#issuecomment-50667626
  Thanks for reading carefully!
  Yeah, please note the note about the issue with typescript right above that example. Typescript doesn't yet have npm resolution so you need to write out a file path. 
 I will try to make this more clear in the readme
 Thanks, I'll look into this and see if I can find a way to make this work.Â â€”
Sent from Mailbox

On Wed, Jul 30, 2014 at 7:40 AM, Panu Horsmalahti
notifications@github.com wrote:

> I think the main issue here is hat the declaration for immutable is not an ambient external declaration. (Although I just skimmed through the .d.ts file).
> Ambient external declaration files look like this:
> 
> ```
> declare module 'immutable' {
>     class Bar {
>         bar(): void;
>     }
>     export = Bar;
> }
> ```
> 
> ## TypeScript doesn't generate these automatically, but in another project I wrote a small script to convert TypeScript's definition files to ambient external declaration files.
> 
> Reply to this email directly or view it on GitHub:
> https://github.com/facebook/immutable-js/issues/8#issuecomment-50623600
 Let me know if you run into any other typescript issues.
  Thanks, fixed in #3
  Thanks, fixed in #3
  Fixed in #7
  Immutable.fromJS() and Immutable.toJS() do deep transforms to and from native JS deep structures but there is more work to be done here. setIn() deleteIn() and getIn() are designed to be used in nested structures.Â â€”
Sent from Mailbox

On Mon, Jul 14, 2014 at 10:43 PM, Michael Williams
notifications@github.com wrote:

> hi, `immutable-data` looks great! :)
> i'd imagine using this with nested objects (a "store" `Map` that contains many "model" `Map`s that may contain "relational" `Map`s, `Set`s, etc). however, it appears `fromObject` and `toObject` don't support serializing and deserializing these nested objects.
> 
> ``` js
> var x = Im.Map.fromObject({ a: { b: { c: 1 } } });
> // Map { "a": [object Object] }
> x.getIn(['a','b','c'])
> // undefined
> x.toObject()
> // { a: { b: { c: 1 }}}
> ```
> 
> and in reverse
> 
> ``` js
> var x = Im.Map.fromObject({ a: Im.Map.fromObject({ b: Im.Map.fromObject({ c: 1 }) }) })
> // Map {"a": Map { "b": Map { "c": 1 } } }
> x.getIn(['a','b','c'])
> // 1
> x.toObject()
> // {a: Map { "b": Map { "c": 1 } } }
> ```
> 
> ## is this something that might be within scope of `immutable-data`?
> 
> Reply to this email directly or view it on GitHub:
> https://github.com/leebyron/immutable-js/issues/2
  Really good thoughts, Cheng! The one little optimization I have here (and the reason clone is separate) is that if "as(Im)mutable" do not have clone semantics then the "asImmutable" call can "mutate" it's mutable self into being immutable for an extremely cheap operation for both memory and CPU.

I think if I decide to keep clone() then I will implement your proposal. I think the usage of clone() is dubious though and I may decide to remove it altogether.Â 
â€”
Sent from Mailbox

On Mon, Jul 14, 2014 at 12:24 AM, Cheng Lou notifications@github.com
wrote:

> `asMutable` and `asImmutable`behaviour aren't immediately obvious. How about `cloneAsMutable` and `cloneAsImmutable`?
> `clone` also isn't obvious and is only there to retain API parity with the mutable version of `clone`.
> 
> ## The first point is more than just bikeshedding the wording if, say, `cloneAsMutable` works for mutable collections. This way, you can safely remove `clone` altogether.
> 
> Reply to this email directly or view it on GitHub:
> https://github.com/leebyron/immutable-js/issues/1
 Right, we definitely want to avoid boilerplate isMutable() calls and the swift array pit of mutability despair. Mutability is certainly an edge feature here, filling the same need it fills in clojure, i.e. only to chain mutations within a pure function, but I agree that it's easier to mess up because we're not doing set! instead of set.Â 

Â Thanks for prodding at this issue guys I have some ideas for clarifying this and making it easier to understand the role of the mutable cases.
â€”
Sent from Mailbox

On Mon, Jul 14, 2014 at 3:29 PM, Ben Alpert notifications@github.com
wrote:

> ## (See also https://news.ycombinator.com/item?id=8028306.)
> 
> Reply to this email directly or view it on GitHub:
> https://github.com/leebyron/immutable-js/issues/1#issuecomment-48948138
 Ok, I've committed c61c93802671cb675f502a3b00d3fdc99d3d4232 which removes `isMutable`, `asMutable` `asImmutable` and replaces the three with `withMutations` which I think better encapsulates the desired usage of the original three methods and has much less opportunity for abuse (pit of success and all that). I think it also reduces boilerplate quite a bit.

As an example, previously you might have done something like:

``` javascript
function setFooBar(map) {
  var newMap = map.asMutable();
  newMap.set('foo', 'baz');
  newMap.set('bar', 'fizz');
  return map.isMutable() ? newMap : newMap.asImmutable();
}
```

There are a few things dangerous about this (pit of failure):
- There is definite boilerplate and multiple pieces of it, it could be easy to forget a part.
- It's pretty trivial to forget the last line and leak mutable collections into the rest of your program.
- The last line's ternary is easy to mess up. If you simply used `map.asMutable()...asImmutable()` then you could incorrectly return an immutable collection when you passed a mutable one in. That's pretty subtle.

After c61c93802671cb675f502a3b00d3fdc99d3d4232 this becomes:

``` javascript
function setFooBar(map) {
  return map.withMutations(newMap => {
    newMap.set('foo', 'baz');
    newMap.set('bar', 'fizz');
  });
}
```
- Only one addition (function wrapper), hard to mess up.
- Much harder to return a leaked mutable collection, you would have to explicitly assign from within the closure.
- Respecting the mutability of the original collection is done for you.

c61c93802671cb675f502a3b00d3fdc99d3d4232 also removes `clone()` as it makes no sense when the expectation is that everything is immutable. Just use assignment!
