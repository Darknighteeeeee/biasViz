  Nice find! Thanks!  Looks good to me! Thanks for working on this! Published `marko@4.4.7`  I think this is fair. Would you be interested in working on this? I think `silent` would be a good option for this. `silent` should be set to `false` by default. @nahtnam I would be more than happy to help you implement this feature. We love to welcome new contributors.

First off, you will need to add the `silent` option to the `enable` function: https://github.com/marko-js/marko/blob/fe60da9c111ae60613e567ab957b47e9b77cebea/src/browser-refresh.js#L4

As I said before, the `silent` option should default to `false`.

You will need to pass the options to the `hotReload.handleFileModified(...)` function call. The `hotReload` module can be found here: https://github.com/marko-js/marko/blob/master/src/hot-reload.js#L127. From there it's as simple as only running the `console.log` statements if `silent` is not `falsy`.

If you would like to work on this, or have any additional questions let me know! We'd love to get your help. @nahtnam Contributions are greatly appreciated and we are happy to answer any questions you might have related to this proposed change. I also agree it would be a good addition. @nahtnam here's the link to the contributors guide: https://github.com/marko-js/marko/blob/master/.github/CONTRIBUTING.md

All of the latest code is on master. You would want to fork the repo and create a new branch from master to implement the new feature and then submit a pull request using your new branch as the source. @nahtnam Great to hear that you will work on it! You do not need to add the option to `runtime`. Let  us know if you have any other questions.  #705 /cc @patrick-steele-idem @mlrawlings  @mlrawlings Can you please review and merge? Looks like the failing build is an unrelated timeout.  Thanks for the all of the fixes!  Hey @newyork-anthonyng, thanks for reporting the problem with the docs. Marko allows `<script/>` and I think we have gotten used to that, but you are right that we should update the docs since we are referring to a standard HTML file. If you can send a PR to update the following file that would be greatly appreciated: https://github.com/marko-js/marko/blob/master/docs/webpack.md

Thanks again!  First off, the following is not valid:

```marko
< input id=state.id  />
```

That prevents the HTML tag from being parsed. The initial space after the `<` needs to be removed:

```marko
<input id=state.id  />
```

That is a separate issue though...

It is somewhat of an odd restriction, but the ID for the root HTML element of a UI component needs to be static and (we need to provide a better error message... sorry about that!). The reason for this is that a UI component is uniquely identified by its ID and if the ID changes during a re-render then diffing/patching will break. Wrapping everything in a `<div>` (without the `id` attribute) will fix the `state is not defined` error and it is recommended to have a single top-level HTML element (for now, at least... see below):

```marko
class {
  onCreate() {
    this.state = { id: 1}
  }
}

<div>
  <input id=state.id  />
  <include('./include-target', {id: state.id}) />
  <include('./include-target') id=state.id />
</div>
```

Typically, you want to always avoid assigning an `id` to any HTML element when using Marko. You should either use `key` (to assign a scoped ID) or use `class` for targeting styling.

Marko does not currently correctly handle multiple dynamic top-level HTML elements correctly in all cases. We are working on a fix for that. @austinkelleher @mlrawlings, can either of you look into improving the error message if the ID for the top-level HTML is dynamic? Thanks. I'm keeping this issue open because we are not providing a good error message to the user. @patrick-steele-idem I'll get to working on this either later tonight or tomorrow.  We'll investigate. Thanks for reporting the problem. I'm not able to reproduce the issue using the [marko-webpack](https://github.com/marko-js-samples/marko-webpack) sample app. I tried using both `webpack@1` and `webpack@2` and I also used `npm@5`. Could you provide a sample app to reproduce the problem or more details on your setup?  I was not able to reproduce the issue using the [marko-webpack](https://github.com/marko-js-samples/marko-webpack) sample app. I tried using both `webpack@1` and `webpack@2` and I also used `npm@5`. Could you provide a sample app to reproduce the problem or more details on your setup? Thanks for providing the project, @arthurchenn!

@austinkelleher, can you please take a look at the provided project  to reproduce the problem? Thanks  I see client-side routing and scoped CSS as two gaps that we should fill (whether it be with a new marko-specific solution or integrating a third-party solution). We will be tackling the scoped CSS this sprint and we plan to do some more research and investigation for the client-side routing piece. In the meantime, maybe check out the following library for client-side routing: https://github.com/FormidableLabs/redux-little-router

With the approach that `redux-little-router` provides, there would not necessarily need to be any direct integration of the routing library with the view library (although they do provide React helpers). Seems like a promising approach, but I have not tried that library myself. @anupdineout Here are some resources for moving from Marko v3 to Marko v4:

- [ROADMAP.md](https://github.com/marko-js/marko/blob/ed6f06a7af8f991cc0735e1366a9737e65e74a92/ROADMAP.md) (may be slightly inaccurate)
- [Migration guide](https://gist.github.com/ianvonholt/9f700ec9a6def8655179b46f9f294e61) by @ianvonholt 
- [Medium Article: Marko 4.0 is here](https://medium.com/@mlrawlings/marko-4-0-is-here-837884c5f60d) @anupdineout 

> In Marko 4 u r proving state View architecture , We can eliminate Marko Widgets ?

Marko Widgets was merged into Marko and that has made things a lot more seamless. /cc @charlieduong94   `ui-components-playground` is using `marko-starter` under the hood. `marko-starter` is using `lasso`. Perhaps this isn't clear enough. Right now, we aren't actively pushing people to use `marko-starter` apps for production, but in the future we plan to encourage this. What do you think @patrick-steele-idem @mlrawlings? Should we switch the link to the `marko-lasso` sample?  Thanks!  This PR introduces a new "dist" directory that gets generated during a publish using babel and a set of babel plugins. Initially, we are only minifying property names, but we will eventually use this to introduce better error messages in the debug build and those error messages and warning messages will be stripped out for the "dist" build. The "dist" build will automatically get used if `NODE_ENV` is anything other than `undefined`|`development`|`dev` or if `MARKO_DEBUG` env variable is set.    When introducing the [unrecognized tags](https://github.com/marko-js/marko/wiki/Error:-Unrecognized-Tag) error was introduced, compiling from XML yields . Currently the only workaround for this is to create an `html-elements.json` file and ignore each individual tag used.

We should consider:

- When compiling Marko XML files (e.g. `template.xml.marko`, `template.marko.xml`) ignoring all unrecognized tags by default

- Introduce a wildcard into the `html-elements.json` for ignoring all unrecognized tags:

```json
{
  "<*>": {}
}
```

/cc @mlrawlings @patrick-steele-idem   This is a nice change. Thanks for that. Published `marko@4.3.1`. Thanks again.  Events are not getting handled from components that are included using `<include(input.renderBody)/>`

Example: https://github.com/austinkelleher/marko-render-body-events-bug @ianvonholt This one is kind of interesting and I'm not sure there is a good way to avoid the problem. With `marko@4.3` we changed how the page boots in the browser after at it renders on the server (https://github.com/marko-js/marko/issues/651). The new behavior is that only the input/state for the top-level UI component is serialized down to the browser and the top-level UI component is re-rendered with the serialized `input`/`state` in the browser when the page loads. The problem in this case is that the `input` for the top-level UI component (`<header-bar>`) includes a `input.renderBody(out)` function that is not serializable down to the browser so when the top-level UI component is re-rendered it has no children and the page does not fully boot.

I have an idea that might work. I am thinking that if we detect that a top-level UI component has a non-serializable functions on its `input` then we will revert to the old behavior for that component. @ianvonholt We ended up going with the following solution:

> I am thinking that if we detect that a top-level UI component has a non-serializable functions on its input then we will revert to the old behavior for that component.

This solved the problem in a transparent way with no code bloat.

New version published with fix: `marko@4.4.6`

We added some tests. Please let me know if you see any issues.  Hey, @juliojerrick. Check out [Marko vs React](https://hackernoon.com/marko-vs-react-an-in-depth-look-767de0a5f9a6) for an in depth comparison of Marko and React. The article has a [differences in rendering section](https://hackernoon.com/marko-vs-react-an-in-depth-look-767de0a5f9a6#ed58), which lists some details on how Marko's rendering is more performant. 

We also have plans to add `scoped` CSS like Vue. You can track this issue #666.

Hope this helps. We've talked about the performance in a few places, but here's a more consolidated view of why Marko is fast:

# Multiple compilation outputs

Marko compiles components differently for the server and the browser.

Given the following template:

```marko
<div>Hello ${input.name}!</div>
```

## Compiled for the server

The compiled output is optimized for streaming HTML output on the server:

```js
var marko_template = require("marko/html").t(__filename),
    marko_helpers = require("marko/runtime/html/helpers"),
    marko_escapeXml = marko_helpers.x;
 
function render(input, out) {
  out.w("<div>Hello " +
    marko_escapeXml(input.name) +
    "!</div>");
}
```

## Compiled for the browser

The compiled output is optimized for virtual DOM rendering in the browser:

```js
var marko_template = require("marko/vdom").t(__filename);

function render(input, out) {
  out.e("DIV", null, 3)
    .t("Hello ")
    .t(input.name)
    .t("!");
}
```

# High performance server-side rendering

Compared to solutions like React that exclusively do virtual DOM rendering (or if you are using JSX with Vue), Marko has a huge advantage for server-side rendering. When rendering to a virtual DOM tree on the server it's a two-step process to render HTML:

- First pass to produce an entire virtual DOM tree in memory
- Second pass to serialize the virtual DOM tree to an HTML string that can then be sent over the wire (this requires traversing the entire tree structure)

In contrast, Marko renders directly to an HTML stream in a single pass. There is no intermediate tree data structure.

# Compile-time optimization of static sub-trees

Given the following template:

```marko
<div>This is a <strong>static</strong> node</div>
```

Marko will recognize that the template fragment produces the same output every time and it creates the virtual DOM node once as shown in the following compiled output:

```js
var marko_node0 = marko_createElement("DIV", null, 3, ...)
  .t("This is a ")
  .e("STRONG", null, 1)
    .t("static")
  .t(" node");
 
function render(input, out) {
  out.n(marko_node0);
}
```

Rendering a static sub-tree has virtually zero cost.

In addition, Marko will skip diffing/patching static sub-trees

# Compile-time optimization of static attributes

Marko will also optimize static attributes on dynamic elements.

Given the following template:

```marko
<div.hello>Hello ${input.name}!</div>
```

Marko will produce the following compiled output:

```js
var marko_attrs0 = {
        "class": "hello"
      };
 
function render(input, out) {
  out.e("DIV", marko_attrs0, 3)
    .t("Hello ")
    .t(input.name)
    .t("!");
}
```

Notice that the attributes object is only created once and it is used for every render. In addition, no diffing/patching will happen for static attributes.

# Smart compiler

With Marko we favor doing as much at compile-time as possible. This has made our compiler more complex, but it gives us significant gains at runtime. We have ~90% code coverage and over 2,000 tests to ensure that the compiler is working correctly. In addition, in many cases the Marko compiler provides hints to the runtime for a given template so that the runtime can optimize for specific patterns. For example, Marko recognizes if an HTML is a simple HTML element with only `class`|`id`|`style` and the runtime optimizes for these virtual DOM nodes when doing diffing/patching (the Marko compiler generates codes that flags specific virtual DOM nodes).

The React (including React variants) runtime is typically used with JavaScript code generated by a JSX transform. JSX is just a simple transform for JSX elements to function calls. While there are  a few babel transforms that apply a few compile-time optimizations, the bulk of the optimizations are happening in the runtime since there is very little happening at compile-time.

On a related note, we don't promote the usage of the Marko compiler in the browser (even though you can make it work). The Marko compiler is targeted to work almost exclusively on the server and it is pretty hefty. In contrast, Vue supports the widely adopted use case of compiling templates in the browser (in addition to compiling on the server). That means that Vue needs to be more mindful of adding new features to the compiler that might increase page weight.

# Optimized data structures

Instead of rendering to a tree of virtual DOM nodes in the browser where children are represented by arrays, Marko renders to a tree where children are represented by a linked list. This reduces the memory allocation required and it is much faster in the use case of rendering virtual DOM nodes that get immediately thrown away. The virtual DOM data structures are heavily optimized as well for JavaScript runtimes based on known optimizations that V8 and others apply for given code structures and usage patterns. [Here's the VDOM runtime code](https://github.com/marko-js/marko/tree/c648b764f203d0c0284470d6267dfd9864a004f5/runtime/vdom).

# Optimized runtime

Marko has a heavily optimized runtime that has been benchmarked and fine-tuned over a long period of time. We extensively use profilers for Node.js and the browser and analyze generated opcodes to ensure that we maximize performance. We also aim to keep the code minimal to avoid introducing overhead. Lastly, we have created a variety of benchmarks that we have used to make sure we are staying fast:

- https://github.com/marko-js/isomorphic-ui-benchmarks
- https://github.com/marko-js/templating-benchmarks
- https://github.com/patrick-steele-idem/marko-vs-react (deprecated in favor of `isomorphic-ui-benchmarks`)

# Focused

Vue supports multiple ways to define a view:

- Vue templates in standard HTML (that is, an existing element in the DOM is targeted to be the template)
- Single-file components
- JavaScript string as Vue template
- JSX

Marko, on the other hand only supports and optimizes for one way of defining a view in a `.marko` file. Maybe Vue is doing a good job of equally optimizing all of those approaches to defining a view, but I suspect that is not the case.

----

I'm sure I could come up with some more reasons that Marko is fast, but I think that covers the bulk of the optimizations that Marko applies. Hope that answers your question. I'm going to close the issue, but feel free to add more comments here if you would like further clarification.
 @patrick-steele-idem your response would make for a very interesting blog post. This should really be posted on the markojs site somewhere for others to easily find! We just published an article to explain why Marko is fast! https://medium.com/@psteeleidem/why-is-marko-fast-a20796cb8ae3  Given the following template:

```marko
<style> 
#search-guide { 


} 
</style> 
<div id="search-guide"> 
  $ console.log( 'search-guide::state - ', state ); 
  <div> 
    <!-- state.len: ${ state.len } --> 
  </div> 

    <button on-click('pickSomething')>Pick Something!</button> 

    <hr> 

    Picked: ${ state.len } 
    Pick Something Else! 
    <!-- <button on-click('pickSomething')>Pick Something!</button> --> 
</div>
```

## From @ramses0:

...this gets stuck in an infinite loop after the on-click, due to it getting stuck in the weeds with the `style` tag during    `$__rerender: function(isRerenderInBrowser) {` ... `                var targetEl = targetNode.firstChild;
                while(targetEl) {
                    var id = targetEl.id;`
yes, i know it's a terrible dom structure (working on it, eventually ;) ), but for some reason this seems like the only component which has this problem, in many other place i'm using the "dangling style tag" structure w/o issue.
moving the <style> into the <div> seems to make it not get confused ... i could try to get a smaller repro and file an issue if necessary but wanted to share as i found it.  

i didn't pursue it too much b/c i had a workaround (dump `<style>` inside a single top-level `<div>` tag per component instead of outside) and i'm planning in revamping all my styles eventually anyway  When rendering on the server, the top-level UI component cannot have function references. Marko serializes the data for the top-level UI components rendered on the server. If you have a reproducible test case to better illustrate your problem that would be helpful.  Thanks for the docs! We love seeing additional integrations with Marko.  Thanks for the PR @Hesulan. I agree that this does not look right. I'm not sure if there was an underlying reason for this, so I'm going to leave this open until either Patrick or Michael looks at it too. /cc @patrick-steele-idem @mlrawlings   Thanks for the PR. This is actually the correct behavior. Using the `static-text` attribute, Marko ignores HTML tags. The Marko.js website is not rendering the output correctly though [here](http://markojs.com/docs/core-tags/#codemarko-bodycode). It should look like this:

```marko
<div>
    This is just one
    &lt;span if(foo)&gt;
        Hello ${THIS IS NOT VALID}!
    &lt;/span&gt;
    big text block
</div>
```

I'm going to go ahead and close this, but feel free to comment here if you have any additional feedback. Also, I've opened up https://github.com/marko-js/markojs-website/issues/11 to track the Marko.js website issue.  This change looks good to me. Do you mind squashing your commits? Thanks. Actually after given this some more thought, I'm not sure if this is the right approach for globally overriding the default for a component. I don't think the compiler config is the appropriate place for such configuration. Have you considered overriding the `<await>` tag? I'll create an example of this and post a link here.

 Here's an example of overriding the `await` core tag:

https://github.com/marko-js-samples/override-core-tag @mauricionr In the demo you'll see that I copied part of the `<await>` marko.json. This is my proposed solution for that: https://github.com/marko-js/marko/issues/686 @mauricionr After speaking with @patrick-steele-idem, we decided that instead of my old approach where I overrode the tag renderer and copying the `<await>` tag's `marko.json` file, we can just override the `await` tag completely and use a transformer to set the `timeout` attribute.

*await-timeout-transformer.js*
```js
module.exports = function(el, context) {
    if (!el.hasAttribute('timeout')) {
        el.setAttributeValue('timeout', context.builder.literal(30000));
    }
}
```

The [override-core-tag](https://github.com/marko-js-samples/override-core-tag) project has been updated with the changes. 

I'm going to go ahead and close this issue. Please let me know if you have any other questions.   This looks good to me. Thanks for the fix.  I believe this has been resolved. Closing the issue, but please feel free to add comments.  Related: https://github.com/marko-js/marko/issues/528  ## Bug Report

### Context
If you have an await tag in a template that only gets rendered by an action, like setting state after the initial render, the await tag will error. The "$__sync" property is set to true by the updateManager.$__batchUpdate().

You get the following error `Uncaught Error: Not allowed`. 

### Expected Behavior
It should run the await tag and wait for the promise to be fulfilled.

### Actual Behavior
Throws an uncaught error.

### Simple Example
This is a very simple example
```JavaScript
class {
    onCreate(){
        this.state = {
            promise: Promise.resolve(),
            selected: false
        }
    }
}
<div>
    <if(state.selected)>
        <await(p from state.promise)>
            done
        </await>
    </if>
    <else>
        I show first
    </else>
    <a href="#" onClick('setState','selected', true) >click me</a>
</div>
```

<details><summary>Additional Info</summary>

### Your Environment
<!-- Include as many relevant details about the environment you experienced the bug in -->
* Version used: 4.2.8
* Environment name and version (e.g. Chrome 39, node.js 5.4): Chrome
* Operating System and version (desktop or mobile): Windows 10

### Stack Trace
AsyncVDOMBuilder.js:171 Uncaught Error: Not allowed
    at r.beginAsync (AsyncVDOMBuilder.js:171)
    at t.exports (await-tag.js:231)
    at r (index.html:33)
    at renderer.js:195
    at Component.js:525
    at Object.s [as $__batchUpdate] (update-manager.js:63)
    at n.$__rerender (Component.js:520)
    at n.update (Component.js:470)
    at o (update-manager.js:44)
    at i (update-manager.js:16)

</details>
  HTML-style comments are already completely removed at compile-time and should never show up in the rendered output. For example, given the following template:

```marko
<h1>
    <!-- Hello ${name}! -->
</h1>
```

The output HTML would be:

```html
<h1></h1>
```

For removing console logging statements, that could be done using babel: https://www.npmjs.com/package/babel-plugin-transform-remove-console

Typically, babel is only used when generating JavaScript bundles for the browser, but you could also use babel to preprocess JavaScript files loaded by Node.js.


If I am misunderstanding your question regarding the comments removal please let me know. Marko doesn't process HTML-style comments in `<script>` tags. Anything inside a `<script>` tag can be any language so it wouldn't make sense for Marko to fully parse out the content of a `<script>`.

I also prefer to avoid using babel on the server, but just wanted to throw it out as an option. 

When you are in "JavaScript land" (e.g. inside a JavaScript function), Marko does not have much control because we don't want Marko to get in the business of rewriting JavaScript code.

Another option is to monkey-patch the `console` object to make the `console.log` method a no-op, but this might cause issues with debugging and would not be recommended, but here it is anyway:

```js
console.log = function noop() {};
```

A better option is to pull in a logging framework with configurable loggers so that you can control logging. With that approach, you would be going through your own logger instances instead of calling `console.log` directly.

I'm going to go ahead and close this issue, but feel free to comment here if you have any other questions.  For context, please see [Issue #651 - Proposal: serialize only input and state on top-level server-rendered UI components #651](https://github.com/marko-js/marko/issues/651)

This Pull Request introduces some important changes to Marko:

- Only the data (including `state`, `input` and properties added to the UI component instance) for _top-level_ UI components is serialized down to the browser (previously, this data was serialized for _every_ UI component rendered on the server)
- When the page boots in the browser, the top-level UI components are "partially" re-rendered using the serialized data
- As part of the partial re-render, the rendering logic executes but the DOM is not updated and no VDOM nodes are actually created (the partial re-render is only used to mount nested UI components)
- NOTE: If a top-level UI component is "split" (that is, rendering logic is not sent down to the browser) then the old behavior will be continued
- The `out.global` object is not serialized, but specify properties can be whitelisted to be serialized. For example, to have the `out.global.apiKey` and the `out.global.locale` properties serialized you would do the following:

```js
template.render({
        $global: {
            serializedGlobals: {
                apiKey: true,
                locale: true
            }
        }
    }, res);
```

There is a chance that this might break existing apps. To revert back to the old behavior on a page-by-page basis you can do the following:

```marko
<marko no-browser-rerender />

<html>
  ...
</html>
```

  @stephenbrady thanks for opening the issue. I added a test case and I am not able to reproduce. Can you please provide more details on how to reproduce? This looks to only be an issue with [marko-loader](https://github.com/marko-js/marko-loader). I haven't had a chance to investigate yet, but I am able to reproduce it. I think this is an issue with the way we're loading the css and how webpack interprets requires.  

Here, the inline css is passed as a query parameter to the internal code-loader:
https://github.com/marko-js/marko-loader/blob/master/src/index.js#L31-L32

But because webpack uses exclamation points in require statements as a loader syntax (`require('css!less!./path/to/style.less')`), the `!important` is throwing things off.

I'm doing something [weird](https://github.com/marko-js/marko-loader/blob/master/src/code-loader.js#L3-L6) to handle newlines, but we should probably replace that with a call to `escape` [here](https://github.com/marko-js/marko-loader/blob/master/src/index.js#L30) and `unescape` [here](https://github.com/marko-js/marko-loader/blob/master/src/code-loader.js#L5).

@stephenbrady Would you mind experimenting and creating a PR if things work out?  ```marko
style {
    div.__colors {
        /* ... */
    }

    ul.__colors {
        /* ... */
    }

    __colorLI {
        /* ... */
    }

    __disabled-button { 
        color: grey;
    }

    __enabled-button { 
        color: yellow;
    }
}

<div.__colors>
    <ul.__colors>
        <li.__colorLI>
            Red
        </li>
    </ul>

    <!-- Scoped styles can also be passed to other UI components: -->
    <fancy-button disabled-class=style('disabled-button') enabled-class=style('enabled-button')>
        Click me
    </fancy-button>
</div>
```

> NOTE: It would also be possible to use unscoped CSS alongside scoped CSS

The Marko CSS preprocessor would produce the following CSS code:

```css
div.colors_abc123 {
        /* ... */
}

ul.colors_abc123 {
        /* ... */
}

.colorLI_abc123 {
        /* ... */
}

.disabled-button_abc123 { 
    color: grey;
}

.enabled-button_abc123 { 
    color: yellow;
}
```

> NOTE: The CSS code that Marko preprocessors then would go through any user CSS processor specified (`style.less`, `style.scss`, etc.)


Finally, the Marko compiler would provide a `style` function variable similar to the following:

```js
var style = marko_style('_abc123');
// style('colorLI') --> 'colorLI_abc123'
``` I could see this getting messy very quickly. I would much rather like to have a `scoped` attribute like Vue. With the above implementation, you could mix the scoped and non-scoped CSS, which is much messier. Additionally, when a component is created, often times there will be component-specific styling. This means that there will be a lot of underscores in component styles.

## Mixed syntax can be messy

In the following example, it's difficult to see which specific styles are scoped and which specific styles are global without scanning the entire block:

```marko
// A mix of scoped and global styles
style {
    .non-scoped {
        /* ... */
    }
    div.__colors {
        /* ... */
    }

    ul.__colors {
        /* ... */
    }

    .more-non-scoped {
        /* ... */
    }
    __colorLI {
        /* ... */
    }

    __disabled-button { 
        color: grey;
    }

    .even-more-non-scoped {
        /* ... */
    }

    __enabled-button { 
        color: yellow;
    }
}
```

## Scoped Attribute

In the following example, you can easily see which styles are scoped and which styles are global:

```marko
style.scoped {
    .scoped-class { 
        /* ... */
    }

   div.colors { 
        /* ... */
   }
}

// Global styles can be included in the component too
style {
    .non-scoped-class { 
        /* ... */
    }

   div.another-non-scoped { 
        /* ... */
   }
}
```

You could use `less` or an another CSS extension as an additional attribute as usual:

```marko
style.less.scoped {

}

style.less {

}
```
 Sorry guys, but I am going to have to have a dissenting opinion here. We considered the Vue.js approach before creating this proposal, but there are some serious drawbacks with the  Vue.js approach:

## Vue.js approach drawback: scoped styles must be separated out from unscoped styles

It forces scoped styles to be separated out. For a single file UI components that is fine because it is just a separate block in the single file. However, that would be a problem when the developer wants to split the styles out to a separate style file. Do we allow `style.less` + `style.scoped.less`? That would be suboptimal because now styles are split across multiple files. A separator within the file could be used but that introduces more things to learn and the separator could be problematic (do we use a CSS comment?). You could argue that unscoped styles would not be needed alongside scoped styles, but I think that would be an odd restriction.

## Vue.js approach drawback: Marko must understand each compile-to-CSS language

Another drawback with the Vue.js approach is that it requires that Marko to be able to deeply understand and parse the style source in order to rewrite the styles. This means that Marko would need to have custom support for each render-to-CSS language (Less, Sass, Stylus, etc.) language so that it could render the style code into CSS so that it could then be deeply parsed to figure out all of the CSS class names and then modified to add an attribute selector. I don't think we want to go there.

 For example, given the following:

```marko
style scoped {
    .list-container:hover {
        background: orange;
    }

    @media (min-width: 250px) {
        .list-container:hover {
            background: orange;
        }
    }
}

<div>
    Hello World
</div>
```

Marko would need to figure how to preprocess the possibly non-CSS style source to produce the following CSS output:

```css
.list-container[data-m-21e5b78]:hover {
    background: orange;
}

@media (min-width: 250px) {
    .list-container[data-m-21e5b78]:hover {
        background: orange;
    }
}
```

We actually don't want Marko to render compile-to-CSS languages to CSS because we want that to be handled by the asset pipeline/bundler (e.g. Lasso or Webpack). This is because we allow global imports for Less and Stylus (and possibly others) and Marko would not have that context.

Contrast that with the proposal I gave above:

```marko
style {
    __list-container:hover {
        background: orange;
    }

    @media (min-width: 250px) {
        __list-container:hover {
            background: orange;
        }
    }
}

<div.__list-container>
    Hello World
</div> 
```

With a little regular expression magic, the `__` prefixed variables could be easily rewritten to the following:

```css
.list-container_21e5b78:hover {
    background: orange;
}

@media (min-width: 250px) {
    .list-container_21e5b78:hover {
        background: orange;
    }
}
```

The rendered HTML would be the following:

```html
<div.list-container_21e5b78>
    Hello World
</div>
```

In addition, since we would use a special prefix, Marko would not need to deeply parse the CSS to find all of the scoped CSS class names to be added to the output HTML.

## Vue.js approach drawback: scoped style classes cannot be passed to nested components

In my proposal above scoped style classes can be passed to nested UI components:

```marko
style {
    __disabled-button { 
        color: grey;
    }

    __enabled-button { 
        color: yellow;
    }
}

<div>
    <fancy-button disabled-class=style('disabled-button') enabled-class=style('enabled-button')>
        Click me
    </fancy-button>
</div>
```

With the Vue.js approach your best option would probably be to use less efficient and less reliable descendent selectors:

```marko
style scoped {
    .my-component .disabled-button { 
        color: grey;
    }

    .my-component .enabled-button { 
        color: yellow;
    }
}

<div.my-component>
    <fancy-button disabled-class='disabled-button' enabled-class='enabled-button'>
        Click me
    </fancy-button>
</div>
```

I'm making the assumption that the output CSS code would be the following:

```css
.my-component[data-m-21e5b78] .disabled-button { 
    color: grey;
}

.my-component[data-m-21e5b78] .enabled-button { 
    color: yellow;
}
```

## Vue.js approach drawback: not compatible with multi-file adaptive styles

At eBay, we support splitting out styles into multiple files for building adaptive UIs so we might have the following:

- `style.mobile.less`
- `style.mobile.ios.less`
- `style.less`
- ...

In order for that approach to work with the Vue.js approach, Marko would somehow need to figure out how to look at all of the possible style files to figure out if a particular CSS class name is a scoped CSS class name or not so that it can add the extra `data-*` attribute to the HTML elements that use those scoped class names.


## So you don't like underscores?

We also discussed the following option based on title case:

```marko
style {
    .ListContainer:hover {
        background: orange;
    }

    @media (min-width: 250px) {
        .ListContainer:hover {
            background: orange;
        }
    }
}

<div.ListContainer>
    Hello World
</div>  
```

I don't know how I feel about that, but I could definitely be onboard with it. I think the regular expression might be a little less reliable but we could put in a few restrictions to avoid that problem. We recommended the `__` prefix because it would fit into any compile-to-CSS language and `__` is commonly used to marko properties in JavaScript as private. A pro for the title case is that `.ListContainer` looks okay, but `.__list-container` looks bad. A con with the title case is that I don't like having to type uppercase characters (shift key), but "_" requires shift as well so that is super minor.

> It's an implementation detail, but the hash could be based on the file system directory path. That is, for any file in the directory we could figure out what the hash would be regardless if we are looking at `/path/to/style.less` or `/path/to/style.mobile.less`. It could then be the job of the asset pipeline/bundler to add the hashes to the CSS code (instead of Marko doing that work).

## Summary

- What I proposed above is a combination of scoped CSS and CSS modules
- It fits in nicely with any compile-to-CSS language without Marko having to deeply parse the compile-to-CSS source code
- It works with multi-file and single-file approaches
- It's easy to explain (a unique hash is added to scoped class names that have a special prefix or that are somehow recognizable)

Still think the Vue.js approach is better? Any other thoughts or proposals? How about double dot?

```marko
..list-container:hover {
    background: orange;
}

..list-container..tasty {
    background: chocolate;
}

@media (min-width: 250px) {
    ..list-container:hover {
        background: orange;
    }
}
``` @gilbert It's subjective but I am not sure double dot looks better than `.__my-class` or `.MyClass` and I suspect that the double dot will impact tooling and syntax highlighting for the render-to-CSS languages such as Less or Sass, but I have not verified (`..my-class` is not valid CSS but both `.__my-class` and `.MyClass` are valid CSS and should not cause any linting and syntax highlighting issues).  What is the recommended way to share common methods across widgets? Normally, I would extend a base class, but it seems this isn't possible since constructors are never called. 
 
I can't seem to find a clean way to extend ALL widgets with common functionality. Everything I try requires either mixing into the prototype of "class {}" or relying on doing composition within the onCreate method. Is there a better, cleaner, way to do this?

Side Note: My team is constantly fumbling with the class syntax in components because they are not real Classes. We are using es6 and Babel in our projects and Components are the one place that do not follow how real classes work. It's making things very confusing for our developers. Is there any way to use real classes with inheritance in Components? 

UPDATE: Sorry, I missed Patrick actually answered my side note in another ticket https://github.com/marko-js/marko/issues/619. Still, any examples of how to "nicely" mixin supporting methods?  Not sure what happened there. I'm investigating. Thanks for reporting the problem. I'll be publishing a new version of the website soon after I investigate a few other issues that others have reported. You can also run the website locally: 

```
git clone https://github.com/marko-js/marko.git
cd marko
npm install
npm link

cd ..

git clone https://github.com/marko-js/markojs-website.git
cd markojs-website
npm install
npm link makro
npm start
```  Do you have a `<body>` on your page? Are you explicitly using the `<init-components/>` tag? I am not able to reproduce (unless I render UI components into the `<title>` tag). Actually, I see the problem. It does look like a bug.  Can you please provide more of template for the UI component that is failing to render so that we can try to reproduce?

EDIT: Just saw that you link to your repo. Currently, the `key` attribute is only applicable within the context of a UI component with a backing `class`. A quick fix would be the following:

```marko
class { }

<div>
  <label for-key="somekey">${input.label}</label>
  <input key="somekey" type="text" placeholder="some placeholder" />
</div>
```

We plan on revisiting this limitation in the future. I will leave the issue open.  This is related to: https://github.com/marko-js/marko/issues/589

@mlrawlings We need to work on the fix for #589

The following template is not compiled as a UI component because of the surrounding `<if>`:

```marko
class {
    onCreate(input) {
        this.state = {
            foo: false
        };
    }
    onMount() {
        this.state.foo = true;
    }
}

<if(state.foo)>
    <div.foo></div>
</if>
<else>Loading...</else>
```

Keeping this issue so that we add it as a test case when we work on #589

  Thanks!  <!----------------------------------------------------------------------
  |     IF FEATURE SUGGESTION (skip to next section for bug reports)    |
  ---------------------------------------------------------------------->
## New Feature

### Description
_list.marko_
```marko
<ul>
    <li for(itemData in input.items)>
        <include(input.item, itemData)/>
    </li>
</ul>
```

_page.marko_
```marko
<list items=input.items>
    <@item(data)>
        ${input.name}
    </@item>
</list>
```

### Open Questions
<!--- What still needs to be discussed -->
Typically, `<tag(data)>` has been used to pass data to the tag, not receive data.  Is this a good pattern?
 I think it would be confusing to use the parens to define variables for the `renderBody()` function. I'll throw out something that might be a terrible idea:

```marko
<list items=input.items>
    <@item renderBody(data)>
        ${data.name}
    </@item>
</list>
```

I'm not really a fan of this either, because technically it becomes `function renderBody(out, data) {  }`


Maybe the following?:

```marko
<list items=input.items>
    <@item input(data)>
        ${data.name}
    </@item>
</list>
```

With destructuring?:

```marko
<list items=input.items>
    <@item input({name})>
        ${data.name}
    </@item>
</list>
```
  See: http://stackoverflow.com/questions/43202021/simple-client-side-rendering-not-working

We either need to implement this method or throw an error (and update the docs). We should implement it.  This would be a great first contribution for anyone looking to get involved. @harrisjose Please feel free. Just try to follow the coding style and keep code fast and small. Here's where you will be making changes:

https://github.com/marko-js/marko/blob/430ce144ccf658d79cf1868cba5851f19c75d5d1/runtime/vdom/AsyncVDOMBuilder.js#L302-L304

Keep in mind that `getNode()` returns a `DocumentFragment`. `DocumentFragment` nodes do not support `outerHTML` which is why this is currently broken (marko used to return the first top-level HTML element node).

Also, test cases :)

Thanks in advance Awesome! And don't hesitate to ask any questions. One of us will point you in the right direction ðŸ˜„  @harrisjose Yeah, that seems to be the case.  Sorry for taking so long to reply.  Is this something you're still working on/planning to work on?  The UI components compiler should ignore "key" attributes if the custom tag declares its own "key" attribute using `marko-tag.json`. There could still be some confusion to developers, but I think it's still the right thing to do.  Putting the logging behind a flag/attribute is definitely an option and I am not opposed to that. However, if you need that level of control, I would recommend not using the `<await-error>` tag and, instead, make sure there the promise is not rejected by providing your own `.catch()`. For example:

```
$ var userInfoPromise = getUserInfo()
    .catch((err) => {
        return {
            error: err
        }
    });

<await(userInfo from userInfoPromise)>
    <if(userInfo.error)>
        We are sorry, we were unable to retrieve the user information.
    </if>
    <else>
        Hello ${userInfo.firstName}!
    </else>
</await>
```

Thoughts?  This proposal impacts how UI components are bootstrapped in the browser when the page is initially rendered on the server. This proposal improves performance on the server and it reduces the chances that a developer will run into problems related to serialization/deserialization of UI component `state`/`input`/properties when a page is rendered on the server. This proposal should maintain backwards compatibility in most cases, but there are a few caveats (see the Caveats section below).

# Current situation

Currently, each UI component rendered on the server will have its `state`, `input` and properties serialized down to the browser. This works and it is relatively fast, except there are a few issues:

- Not everything is serializable
- All `state`, `input` and properties for nested UI components can usually be derived from its top-level UI component so it is most likely redundant to serialize data associated with nested components (NOTE: Marko will dedupe objects/arrays but there is still excess serialization)

> Not everything is serializable

As an example, a reference to a UI component class is not serializable as JSON. The following will not work as expected:

```
import someModule from './foo';

<some-nested-component some-module=someModule />
```

The `some-module` attribute will result in a property being added to the `input` for `<some-nested-component>` but if `someModule` is a JavaScript module that has functions then those functions will not be included in the serialized `input` and `someModule` will _not_ be a reference to the `./foo` module when the UI component mounts in the browser.

# Proposal

Instead of serializing the `input`/properties/`state` of every UI component rendered on the server, only serialize the information associated with the top-level UI component(s) (excluding top-level "split UI components" that are not renderable in the browser).  In addition, a re-render of top-level UI components should be triggered when the top-level UI component boots in the browser. A "complete" re-render it is not actually necessary since there is no need to update the DOM in the browser (i.e., there is no reason to render any virtual DOM nodes when booting in the browser). It is, however, necessary to run through all of the rendering logic in order to determine which UI components need to be created and to determine their `input`/properties/`state`.

# Caveats

- If a nested UI component derives its props/state or generates input properties from anything other than passed in `input` (e.g. `this.locale = out.global.locale`)` then that information will not be available when the UI component mounts in the browser.

# Status

This has been mostly implemented on my machine and it is working well for the apps that I have tested so far. More testing and optimization still needs to be done.

-----

Thoughts? Concerns? Feedback?  Do you have a use case in mind? Maybe some sample code that might make the need more clear? Thanks for the clarification. A fix will go out with the next release.  The `value` attribute is not valid for a `<textarea>` tag â€“ I suggest removing that. I haven't had a chance to verify, but it appears that the `\n` in the concise line is being preserved by the parser and added to the textarea body for every render. A temporary workaround would be to use the HTML syntax for the `<textarea>` tag:

```
div
  <textarea key='input' on-input('onChange')>${input.value}</textarea>
```

We'll investigate a fix in Marko. Thanks for reporting the problem.  That does indeed look like a bug. I'll investigate. The following line looks like the problem: https://github.com/marko-js/marko/blob/47d3fc36cb5f1c83b8257e8561375c5db8886ed8/runtime/vdom/helper-styleAttr.js#L19

If `value === 0` then the if condition will not evaluate. Interested in submitting a Pull Request to fix the problem? Actually, I'm going to go ahead and take this one. There are some other changes that I think need to be made. New version published with fix: `marko@4.2.2`

Thanks for reporting the problem!  **tldr; Don't use split UI components unless there is a really good reason to do so**

When using a split component (i.e., `component-browser.js` + `component.js`) then the JavaScript module bundler (e.g. Lasso.js) will only send down the `component-browser.js` and not `component.js` (assuming it is not nested within in an un-split component...). Split components allow the rendering logic to remain on the server (instead of also being sent to the browser). However, split UI components have the caveat that they cannot be rerendered unless the `component.js` is also sent down. You are seeing that error because `component.js` was not sent down to the browser and hence the rendering logic is missing in the browser for the UI component. The error message is cryptic and we should fix that (we need to improve error messages in development without adding bloat in production).

My advice would be to avoid using split UI components. Split UI components can have some benefits but they are usually a premature optimization with not too much gain.

I'm closing this issue because I think everything is working as intended (I'll open a separate issue for improving the error message). If you still have questions or concerns please feel free to add them here.  > It's amazing how simple it is to have universal components with Marko.

Thanks for the feedback!

Currently, the best option is to use a UI component to transfer the global variables to a shared module. Something like the following:

```marko
import myStore = from './path/to/my-store';

class {
    onInput(input, out) {
        this.someImportantData = out.global.someImportantData;
    }

    onMount() {
        myStore.setSomeImportantData(this.someImportantData);
    }
}

<div.top-level-ui-component>
</div>
```

Any other UI component or JavaScript module can do something similar to the following:

```marko
import myStore from './path/to/my-store';

$ var someImportantData = myStore.getSomeImportantData();
```

I'm thinking there might be value in some how marking certain globals as being serializable to the browser so that they will automatically show up in `out.global` on both the server and in the browser. I'm going to explore this option some more and try to put together a proposal that makes this intuitive. @rubennorte Would you be good with the following proposal:

```marko
class {
    get globals() {
        return ['title'];
    }
}

<div>
    Title: ${out.global.title}
</div>
```

Basically, the `globals` property on the component class definition would be used to specify the names of the global properties that should be serialized down to the browser. 

Look good? Any other ideas? @rubennorte Would this pattern work for you?

Define and include a `<global>` component that runs before any other component on the page:

```marko
class {
  onMount() {
    var global = {
      getImageUrl: (path) => `https://${ this.input.imageHost }/${ path }`
    }
    window.out = { global: global }
  }
}
```

Then include it in your layout:

```marko
<global imageHost=process.env.IMAGE_HOST />
```  Marko does not currently have a framework with native bindings like React Native, but you can certainly create a static build of your app and use Phonegap etc.

Check out: [marko-phonegap](https://github.com/marko-js-samples/marko-phonegap) Another developer built a mobile app using Marko + [Framework7](https://framework7.io/): https://twitter.com/rtalwar26/status/847702923198963716

I haven't used Framework 7 myself but it looks promising. I installed the [ConfEngine](https://itunes.apple.com/in/app/confengine/id1010574267?mt=8) app built using Marko and Framework7 and looks very nice on my iPhone.  Thank you for the detailed problem report and the working app. Very helpful!

I put in a fix to make this issue less common, but it has to do with the UI component first being rendered on the server and Marko not knowing that an attribute was added by an external library/code. When rendered initially in the browser this would not have be an issue. The fix skips removing non-Marko rendered attributes for keyed elements. The `key` is required to know for sure that the two elements being diffed are the matching elements.

New version published with fix: `marko@4.2.1`  You are right that the error message is not helpful. I've not seen that error message. Any suggestions on how to reproduce to see if we can improve the error message? Are you only able to trigger the problem when using `browser-refresh` and modifying templates?  Your approach looks good to me. However, you're trying to do root-level text, which may mess things up. Try wrapping your `input` and text within a `<div>`. Just wanted to mention that Marko has a [known limitation](https://github.com/marko-js/marko/issues/589) that does not allow dynamic top-level HTML elements or text nodes. Once we fix #589 then the wrapping `<div>` would no longer be needed. We have some ideas on how to fix the issue, but it's a little tricky.  Thanks for reporting the problem with the website. We're investigating This has been fixed. Thanks for reporting the problem!  We need to make this more clear in the docs, but `extends` can not be used with component classes. The reason for this is that marko internally makes every UI component inherit from an internal `Component` class and you can't have multiple base classes. If you really want to do mixins then the following will work:

```js
class Component {
  foo() {
    //the following 2 lines codes are working as expected.
    var bar = new Bar()
    bar.funcInMixin() //print 'funcInMixin called' in console

    // In fact,we want component instance has mixed function `funcInMixin`
    // Unfortunately `this.funcInMixin` is undefined, it caused unhandled exception
    this.funcInMixin()
  }
}

var mixins = {
    funcInMixin() {
        // ...
    }
};

Object.assign(Component.prototype, mixins);

export default Component;
```

Does that work for you? I'm closing the issue, but please feel free to add more comments here if you still have concerns or questions.  Can you not define both and use them only when you need to? I think we need better error reporting here, but a macro should only be declared once.  Try adding `no-update` to the chart div:

    <div class="chart" no-update /> The reason it was happening in the first place was because marko's vdom logic was causing your `chart` div to revert back to what you've written in the template.

If you still want to make use of `state.percent` (and thus marko's vdom), then this structure might work better for you:

```marko
<div class="col-md-12">     
      <span class="chart-wrapper">
        <span class="chart" no-update></span>
        <span class="percent">${Math.round(state.percent)}</span>      
      </span>
      <span class="btn btn-default" onClick('updateChart')>Update chart</span>
</div>
``` > like "props" and "state" in react?

Yes, that's correct.  We'll be putting some proposals on the table soon, but if anyone wants to share ideas or their favorite router, please feel free.  ```marko
import Hello from './path/to/hello';

<Hello name="Frank"/>
```

In addition, we could also overload the `import` syntax to allow importing a UI component based on the tag name:

```marko
import Hello from <hello>;

<Hello name="Frank"/>
``` @Hesulan you may be right. I'll throw out some other ideas:

```
import-tag <hello> as Hello;
import-tag <hello>; // if no "as" is specified then default to title case
``` What's the use case for this? Auto-detection has worked pretty well for me so far (that doesn't make me opposed to this though).  From Gitter chat:

Eldar @Eldar-X Mar 24 10:47
@patrick-steele-idem in component-browser.js following not working

```js
module.exports = class {
    onCreate() {
        this.state = {
            count:0
        };
    }
    increment() {
        this.state.count++;
    }
}
```

But this is okay

```js
module.exports =  {
    onCreate() {
        this.state = {
            count:0
        };
    },
    increment() {
        this.state.count++;
    }
}
```

Error message:

```
TypeError: component.$__setCustomEvents is not a function
    at Function.ComponentDef.$__deserialize (https://localhost:3000/bundles/admin/news.js:3725:15)
    at https://localhost:3000/bundles/admin/news.js:3919:37
    at Array.forEach (native)
    at Object.initServerRendered [as concat] (https://localhost:3000/bundles/admin/news.js:3918:19)
    at https://localhost:3000/admin:2:99
    at https://localhost:3000/admin:2:275
``` I tested with the upcoming Marko v4.2.0 release and I am not able to reproduce.

@Eldar-X Can you provide more details on how to reproduce the problem you mentioned in Gitter? I'm closing the issue for now, but if it is still a problem please let me know.  Thanks for reporting the problem @eltimn. We found some issues when converting the VDOM nodes to actual DOM nodes for certain input controls. We put in some fixes that will go out with the upcoming v4.2.0 released scheduled for a little later today. Thanks, again.  New version published with fix: `marko@4.2.0`

Thanks, again.  Thanks!  Are you interested in server-side performance or client-side performance or both? For server-side performance, Marko v4 is faster than Marko v3, but not by a huge margin. On the client-side, however, Marko v4 is much, much faster due to the introduction of VDOM rendering. Unfortunately, I don't have a 1-to-1 benchmark for Marko v3 vs Marko v4. What I can say is that Marko v3 is slower than React: https://github.com/patrick-steele-idem/marko-vs-react/tree/8d686de0782995d72bc26a058e84e938f0f8c2f9#client-side-rendering-performance

Marko v4, however, is much faster than React, Preact, Inferno and Vue: https://github.com/marko-js/isomorphic-ui-benchmarks

We just gave an internal talk at eBay and in the slides we talk about improvements that we made in v4 and we also have a few slides on performance: http://markojs.com/presentations/marko-v4/

I should also mention that Marko v4 includes a Marko v3 compatibility layer to allow Marko v3 and Marko v4 components to be used together. We need to do a little more work to make the transition easier, but if you are interested in going that route let us know. The Marko v3 compatibility layer does increase the page weight so migrating UI components to Marko v4 is recommended.

Hopefully that helps you convince your team to upgrade to Marko v4 :) If you need any more details let us know.  Thanks!  ## New Feature

### Description
Currently, the only thing you can pass to the onClick attribute is a string which has to be a method on the parent component class. Now that we can access  the component directly in the template, I'd like to propose being able to pass a function to call instead of a string, or at least to pass the context for which the method should be invoked.

### Context
- This would open up the opportunity to call methods exposed by child components without having to write methods on the main class just to facilitate a click taking an action on another component
```HTML
<child-comp key='child'></child>
<a onClick(args => component.getComponent('child').method(args), 'some arg'>Click Me</a>
```

- When transcluding components, you are forced to jump through hoops in order to call a method on the component which is transcluding the content. This would allow you to expose the component to the transcluded content and call the method on it, instead of the parent.

```HTML
<list data=[1,2,3,4,5] >
   <card onClick(() => list.setSelected(item)) data=item class=[selected]  />
</list>
```
Inside list
```HTML
class {
   setSelected(item){ this.state.selected = item }
}
<for(item in input.data)>
   <include(input.renderBody)  list=component item=item selected=(item==state.selected) />
</for>
```
Currently, in order to set the selected item on List when the Card is clicked, you have to do a chain like: 

Card Click -> Call Parent Save -> Save state on Parent -> Pass state to list -> list: save state -> pass selected to Card as var on include

This is all because the context of "card" is not list, despite it being used as a renderer (child) for List. If you could at least reference the component and pass it's method to the event handler, it would allow for better reuse of components without having to bind everything up to the parent component and then back down, just to set it's own internal state. I'd much rather have Card be able to set state and call methods on List, then have list emit an event that can be listened to by parents if they are so inclined.

Now, I'm not suggesting that we just bind transcluded content to the components state, as I'm sure there are legit use cases for treating it separate. This would simply allow you to do either.

As another example, take a carousel which provides Forward and Backward methods, but leaves it up to you to call them. Perhaops even offering a transcluded region within the component to place them.

e.g.

```HTML
<carousel items=data.items>
   <@nav>
      <a onClick(() => carousel.prev())>Prev</a> | 
      <a onClick(() => carousel.next())>Next</a>
   </@nav>
</carousel>
```
This style of composed widgets allows me to reuse carousel in many ways, without having to include a particular nav type into the component itself. I could provide another component in @nav that handled it as a paged list, for example.

### Possible Implementation
I would suspect this is an easy change as a simple type check on the first argument should tell you if you are trying to call a method on the parent component (String) or a function (Function).

### Discussion
I'll admit I don't love the need for the arrow function, but you need to supply context for the method execution, so it's either that or signature like event('method', context, ...args), or perhaps an object event({m: 'method', c: context}). I could be misinterpreting your comments, but I just want to make it clear that the following works in Marko v4 because Marko v4 supports binding additional arguments to an event handler (see: http://markojs.com/docs/components/#codeon-eventmethodname-argscode):

```jsx
class {
   setSelected(item){ this.state.selected = item }
}

<list data=[1,2,3,4,5] >
   <card onClick('setSelected', item) data=item class=[selected]  />
</list>
```

The reason for not allow functions to be used as the first argument to an event handler is that functions cannot be serialized down to the browser if the page is rendered on the server (functions are not serializable as part of JSON). With Marko v4, if the page is rendered on the server then event handlers will work as expected when the application boots in the browser. This is because we serialize the method name to the browser (it's just a `String`) and use that to handle the event in the browser.

Does that clarify? It clarifies why only strings are support, thanks! Unfortunately, your example is exactly what I'm trying to avoid. The selected state is not a property of the outer most component `class{}`, it's a property of the `List` component (`<list>`). I'm trying to set the value for `List` from `card`, without having to write the boiler plate on the outer most parent (`class{}`).

In order to have a click on `card` set `List`'s selected property, I have to write...
```HTML
class {
   setSelected(item){ this.state.selected = item } // boilerplate
}

<list data=[1,2,3,4,5] selected=state.selected>
   <card onClick('setSelected', item) data=item class=[selected]  />
</list>
```

This might be OK for a single component in a template, but when this component has 10+ child components that also transcludes stuff - says it's a `Page` component with multiple components in it's `body` - then I end up with tons of these event handlers and state values. And the only reason I need them is to pass the state from the `transcluded child` to it's `parent component`. I believe this also causes the whole outer parent `(class{})` to rerender because of a state change, when the change was really internal to the `list` component.


 What I'm really trying to achieve is this:

```HTML
class {
   // no state or event handlers
}
<list data=[1,2,3,4,5] >
   <card onClick(list.setSelected, item) data=item class=[selected]  />
</list>
```
Clicking a `card` would just set `List.setSelected = card.item` without bleeding functions/state into the outer `class{}` to facilitate. 

The only way I can do this now is to put `card` inside `list`'s template, then `card` can call `list` functions directly, but then my re-usability is less because I can't supply different `cards` for different appearances. 

Does that make sense? I have lots of examples where I'm using transclusion in this way, but the fact that the transcluded component/template is not in the context of the component that's including it, means I have to write boiler plate everytime. :( I can see this comment in the output of AttachBubbleEvents which "seems" to indicate you can provide a component ID for the method

```
// Attributes will have the following form:
// on<event_type>("<target_method>|<component_id>")
```

But I can't seem to figure out how to invoke it. Is there a way to say what component the target_method should be called on??? This would solve my problem if I could target a specific component_id.

It seems to be referenced again in `getEventAttribute` as 

` // <method_name> <component_id>[ <extra_args_index]`

But I never seem to be able to enter the if block for this because `virtualAttrs` is always set with the parent ID already. Here's a solution that I've used before:

```
class {
   // no state or event handlers
}
<list data=[1,2,3,4,5] >
   <card onClick('setState', 'selected', item) data=item class=[selected]  />
</list>
``` Thanks @mindeavor , I assume this would still require passing in `selected` to the list component to set it's state? It's better, but I still couldn't call methods on List from the event, which is the other part I'd like to do.

All we need is a way to tell onClick which component we want the method called on - assuming `key=id` is set ont he target we want...
```
onClick('id:method')
onClick('id method')
onClick('id|method')
onClick('method') eventId='id'
```

Anything like this that let us target the component to be called would solve all my issues :) 

But thanks for the tip @mindeavor  @patrick-steele-idem Any advice? Is it possible to set a target component for the method execution? The code seems to elude to it, but I can't figure out where it's set. I'm guessing in the AST somewhere?  I'm assuming you are using Marko v4 and if so the following works if you want to dump to the console output:

```
$ console.log('someVar:', someVar);
```

Or if you want to dump it to the browser as part of the HTML:

```
<pre>
  ${JSON.stringify(someVar)}
</pre>
```

`JSON.stringify` will only work if the object you want to dump doesn't have circular references. If that is the case, then you can use a [`util.inspect()`](https://nodejs.org/api/util.html#util_util_inspect_object_options) (a builtin Node.js module) for dumping to a String:

```
import util from 'util';

<pre>
  ${util.inspect(someVar)}
</pre>
```

Hope that answers your question. @seangates `console.log()` does not return a value so the `<pre>` tag will be empty, but the value will be written to the `console` at least :)  Scoped CSS is indeed useful, but having "just HTML" means you have to write JavaScript inside non-sytax-highlighted strings (and "just HTML" is not even technically true, since vue.js uses [dots in attribute names](https://vuejs.org/v2/guide/syntax.html#Modifiers)). The HTML-JS syntax is definitely a step forward in templating languages :) Hey folks, support for scoped styles is something we thought about when working Marko v4 and it is something we want to offer in the near future. The problem requires some thought because the solution needs to be compatible with the module bundler (webpack, lasso, etc.) and we would need to figure out how marko scoped styles would play nice with simple CSS and the various CSS preprocessor languages. @thisguychris Since you mentioned that you are interested in working on this, it would be great to hear some proposals. We need to find a good solution for Marko while considering existing solutions:

- [BEM](http://getbem.com/introduction/) 
- [Scoped CSS in Vue](https://vue-loader.vuejs.org/en/features/scoped-css.html)
- [React CSS modules](https://github.com/gajus/react-css-modules)
- etc.

Let's see some ideas :) @jordanbtucker I concede my incorrect point about the attribute names :) For code, I'm talking about code in HTML attribute value strings, not script tags. I put a proposal on the table: [Proposal: Scoped CSS using "__" prefix](https://github.com/marko-js/marko/issues/666)

Feedback greatly appreciated!  __tldr; Use `onCreate` instead of `constructor` because of limitations associated with native ES6 classes.__

With the release of 4.0, we added support for an `onCreate` lifecycle method which was able to be aliased as `constructor` when using the class syntax to define a component.

This was implemented as a [simple assignment](https://github.com/marko-js/marko/blob/e3547b97c00255d9692a2a5a652953773849d31c/components/defineComponent.js#L47).

Unfortunately, we have discovered that despite the claim that `class` is [just syntactic sugar](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes) over typical JS prototypal inheritance, this is not actually the case.  There are limitations around how the `constructor` is implemented.  Although the constructor is `typeof "function"'` and `instanceof Function`, it cannot be called without the `new` keyword and cannot use its prototype methods of `call` and `apply`.  This prevents us from dynamically inheriting from `Component` (which has a `constructor` that we would want to call _before_ the user's `constructor`. Also, `Component` is actually only inherited from in the browser).

We didn't catch this earlier because we used the ES5 equivalent of classes in our tests because phantomJS (which we use in our test suite) does not support ES6.

Additionally, `onCreate` is not _quite_ the same as `constructor`.  It is a lifecycle method that is called when the component is created.  In the case of a server render, handing off to the browser, it does not get called when mounting in the browser.  A component fires `create`, `input` and `render` on the server and then _only_ `mount` in the browser.  The way ES6 classes are implemented would necessitate that `constructor` be called both on the server and in the browser for these isomorphic renders, which is not what we'd like.

`constructor` will continue to work in from a single-file component (we already transpile to a plain object with an `onCreate` method), but we will add a deprecation warning when using `constructor`.

To summarize, [classes have issues](https://medium.com/javascript-scene/the-two-pillars-of-javascript-ee6f3281e7f3#.42r2fz3zy) and internally, Marko does not use true classes.  We really only support the `class` syntax because it looks nice and you don't have to separate methods with commas. Is this also why I cannot use the "extend" keyword on a component class? I would have assumed with a transpiler that I could inherit from a base classes, but Marko throws an error about "a component cannot be a function." This kind of sucks as there are methods I find myself having to add to components over and over because I can't just inherit a base component. :( I usually end up with an ugly mixin object.  Fixed. New version of marko published: `marko@4.1.2`

CHANGELOG: https://github.com/marko-js/marko/blob/master/CHANGELOG.md#412 @jasonmacdonald Yeah, we probably need to make this more clear, but `extends` is not something we can support. Internally, marko creates its own class for each component that extends our base [Component](https://github.com/marko-js/marko/blob/master/components/Component.js) class and components can't extend multiple classes. `mixins` are the way to go.  Here's a question I've had and maybe you could add to your documentation: can you use `<await>` within components? Thanks for the PR! (sorry for being slow to merge this PR)

We'll be publishing a new version of the site soon.  @leili2017 can you confirm that installing `marko` as @jrop suggested works?

In any case, we should make it clear in the docs that you need to have `marko` as a dependency of your project  Thanks for the bug report. I will try to reproduce I am not able to reproduce the problem. Are you using Webpack? Might need to take a closer look to see what is wrong with your setup...  Convenience. I don't believe it's required That's a good question. We're actually going to make some related changes that we have been meaning to make that I suspect you will like. We'll get back to you soon.  This looks great. Would you be interested in providing a working koa app in the following repo: https://github.com/marko-js-samples/marko-koa

(I added you as a collaborator)  Thanks! I'll add some additional clarifications, but that is a nice addition. Thanks, again.  Hey Jordan, that's a very fair question. That was done for performance reasons since monkey-patching the prototype chain is more efficient then monkey-patching each `res` object that gets passed through for every request which is what would be required if we were to use middleware. 

With that said, there might be hope in using the [Express `mount` event](https://expressjs.com/en/api.html#app.onmount) to get access to the parent express app so that the prototype chain can be monkey-patched. That requires more investigation though. If you or something else is able to make the following work then it is something we would consider:

```js
const express = require('express')
const marko = require('marko/express')

const app = express()
app.use(marko()) // marko should be a function call that returns an `express()` app
```

Alternatively, it might not hurt to also support something like the following:

```js
require('marko/express/response').patch(express);
```  I believe the `key` attribute can only be applied to components. What are you trying to do? The `key` attribute can only be used within the context of a component as it stands now. We should probably make this more clear in the docs with updated text:

> The `key` attribute can be applied to both HTML elements and custom tags for UI components within the context of a component's view template.

I'm going to give it some more thought and see if it makes sense to support the `key` attribute outside the context of a component view template. I did some more investigation and verified that Marko is handling this correctly. Keys are _scoped_ IDs that are scoped within the context of a component. If there is no component then `this.getEl(elId)` wouldn't make sense. There should be a component definition for the template with the key (either an inline `class { }` or a `component.js` in the same directory). If you have any questions please let us know, but everything appears to be working as expected.  For consistency we should also automatically discover custom tags that are outside a directory  A new version should be published later today. Thanks!  Hey Fabien, sorry for the slow response. You can do the following to break out of concise syntax mode:

```
---
    <SubObject>
        <Value>primary</Value>
    </SubObject>
---
```

Does that work for you?  We want all compiled Marko templates to be loaded in strict mode to catch problems early. As an example, Marko uses `Object.freeze()` on the state object to prevent new properties from being added that won't be watched. Without strict mode adding properties will silently fail. Marko automatically transpiles the `class` syntax into an object declaration so that the compiled template will be ES5 compatible (assuming you aren't using other ES6 syntax). It produces something like the following:

_index.marko_

```jsx
class {
    foo() {

    }
    bar() {

    }
}

<div>
</div>
```

Compiled output:

```js
"use strict";
// ...
var marko_component = {
        foo: function() {},
        bar: function() {}
      }
// ...
```  With Marko v4, we now create an instance of the UI component when rendering a UI component, but the UI component instance is not publicly exposed so it is not possible to call instance methods in the marko template code. This proposal introduces a new `component` variable that can be used to reference the UI component instance as shown below:

```jsx
class {
    getFullName() {
        return this.input.firstName + ' ' + this.input.lastName;
    }
}

<div>
    Hello ${component.getFullName()}!
</div>
```

Thoughts? Concerns?

ðŸ‘  or ðŸ‘Ž  ?

/cc @mlrawlings @austinkelleher @philidem @mindeavor @ramses0

 Just to be clear @ramses0, you are in favor of this proposal as-is, correct?  I think it makes sense to have as an option, and see no harm in adding it. I like this proposal too. Thanks for the feedback. I will work on implementing this.  You should be able to nest `<await>` tags, but if you can run them in parallel, that's better to do anyway.  I believe `Promise.all` is your best bet. @mauricionr Are you rendering this client-side or server-side?  @Hesulan Thanks for reporting! `marko@4.0.0-rc.21` has been published with the fix  Thanks for the feedback @mauricionr !

Just to add to what @Hesulan said, minification and [minprops](https://github.com/mlrawlings/minprops) (not yet documented) are the only two things that are strongly recommended for production builds. But yes, we will be publishing a guide for production builds. I'll keep this issue open as a reminder. Thanks, again!    Marko v3 supports scoped vars:

```jsx
<var x=1 y=2>
  The `x` and `y` are scoped to this block.
</var>
```

We moved from `<var>` to `$ var` and need to rethink support for scoped variables in Marko v4. /cc @ramses0  Need to either add an error message or make changes to support dynamic top-level HTML elements. /cc @ramses0 Related:

```marko
class {
  test() {
    console.log('test');
  }
}

<for(_ in [0, 1, 2])>
	<div on-custom-event('test') />
</for>
```

Throws:
```
ReferenceError: __component is not defined
```

[try online](http://markojs.com/try-online/?gist=e2ea1d6b198e37077895c17e49f7038b) - [gist](https://gist.github.com/mlrawlings/e2ea1d6b198e37077895c17e49f7038b)

Adding a wrapper `<div>` or even a sibling `<div>` causes the `__component` variable to be pulled in properly.    Thanks for opening this bug report @smulder. We'll take a look.     Good news: can already use the `include` tag for this

```html
<include(input.renderBody)/>
```

Include actually looks for a `renderBody` property if its an object, so this works as well:
```html
<include(input)/>
``` Yeah, but `data` isn't going anywhere anytime soon and we won't be adding deprecation warnings for it right away either. But all the docs for Marko 4.0 will reference `input`  When users see `<for(var x in xs)>`, they think it's native JavaScript and try to do fancy ES6 stuff like destructuring.

Here's an actual attempt:

    <for(const [airport, { area, name, pos: { lat, lng } }] of Object.entries(geo.airports))>

I have two suggestions (not mutually-exclusive):

1. Rename `for` to `each` to avoid confusion
2. Give `for` native JS code support

This would be the last nail in the "uncanny JavaScript-like tags" coffin.  @tinovyatkin Can you provide more details?  When running the tests the file/line shows up correctly.

```
WARNING!!
The "<invoke>" tag is deprecated. Please use "$ <js_code>" for JavaScript in the template. See: https://github.com/marko-js/marko/wiki/Deprecation:-var-assign-invoke-tags
  at test/autotests/render/invoke/template.marko:7:33
```

Is the `<invoke>` node being added dynamically somehow?   Failure is intermittent.  Thanks for reporting this issue. This is a result of: https://github.com/marko-js/marko/issues/560. I will have a fix up soon. This should be fixed now. A new version should be published later today.     The CI build fail looks to be an intermittent failure.  Currently, Marko supports "scoped IDs" in the form of a "ref":

```html
<div>
  <button ref="ok" type="button">OK</button>
  <button ref="cancel" type="button">Cancel</button>
</div>
```

A nested element/widget can be looked up by a ref:

```js
var okButton = this.getEl('button');
```

A "ref" attribute results in an ID attribute being assigned to the final element. For example:

```html
<div>
  <button id="w0-ok" type="button">OK</button>
  <button cancel="w0-cancel" type="button">Cancel</button>
</div>
```

[morphdom](https://github.com/patrick-steele-idem/morphdom) uses the "id" attribute as a "key" to match up elements during a diff/patch. Therefore, marko is using the "ref" attribute for two purposes:

- To assign a key for diffing/patching
- To assign a key for referencing nested elements/widgets

A "key" is the more general term ("scoped-id" is more appropriate, but too long) and "key" is already well understood to be used for matching up elements during diffing/patching.

As a late breaking change for the Marko v4 release, we want to rename "ref" to "key". We will introduce deprecation warnings, but we do not want to ship the "v4" release with support for "ref".

Thoughts? Concerns? Thanks in advance. I think this is a good change. Does using a `ref` prevent the element from being messed with during a redraw? @Hesulan For better or worse, React and all of the React variants have already hijacked the "key" attribute: https://facebook.github.io/react/docs/lists-and-keys.html#keys

The `key` attribute that we are proposing for Marko would serve the exact same purpose as developers are used to with React. The only difference is that we would also be using the `key` attribute to allow an element/widget to be referenced by the `key` (that is, `getEl(<key>)`, `getWidget(<key>)`). In comparison, React has a separate concept of a `ref` which started out as a string, but is now a function: 

```jsx
<input
  type="text"
  ref={(input) => { this.textInput = input; }} />
```

That is another reason we want to get away from `ref`.

(side note, React requires a lot of code to reference an element... uggh)

@mindeavor 

> Does using a ref prevent the element from being messed with during a redraw?

No, it doesn't impact rendering. It only impacts how elements are matched up for diffing purposes. DOM elements with the same `key` are guaranteed to be diffed against each other. Even without specifying a `key` things will still render correctly, but the developer might notice unexpected behavior (e.g., focus moving to the wrong element or CSS transitions being applied incorrectly).

 Also, just to be clear, this would be a simple internal rename from `ref` to `key`. It would require minimal code change (although we would have to go fix all of the tests and sample apps :/ ). Thanks for taking this on @austinkelleher ! We want to show a deprecation warning initially and publish a new `rc` release. We will completely remove support for `ref` and the deprecation warnings when we do the final v4 release.    Just to clarify â€“ you meant to say "because a joined empty array is falsey", correct?  `getTemplateData` was necessary for v3 widgets because there was only `data` passed to the template and we needed some way to get `state` into the template as well as any input data you might have also needed.  

In v4, your template receives an `input` variable (also aliased as `data` for compatibility) and a separate `state` variable is available to your template if you set `this.state` in your component's class.  You can then access both `state` and `input` in your template.  You no longer need `getTemplateData` to make this data available to your template.  If you need to massage the input data that is being passed in as `input`, you can return a different value from `onInput`.

**Old:**
```js
module.exports = require('marko-widgets').defineComponent({
    template: require('./template.marko'),
    getInitialState(input) {
        return { count:0, color:input.color };
    },
    getTemplateData(state, input) {
        return state;
    },
    increment() {
        this.setState('count', this.state.count+1);
    }
})
```
```xml
<div w-bind>
    The current count is <span style={ color:data.color }>${data.count}</span>
    <button w-on-click="increment">+1</button>
</div>
```

**New:**
```jsx
class {
    constructor(input) {
        this.state = { count:0 };
    }
    increment() {
        this.state.count++;
    }
}

<div>
    The current count is <span style={ color:input.color }>${state.count}</span>
    <button on-click('increment')>+1</button>
</div>
``` `getTemplateData` was technically part of the v3 style legacy widgets, but the code was so intermixed that you could still use certain legacy methods with the new components. That code has now been split out - is there still a need for it, or was it just surprising? I wouldn't recommend it, but you could do the following:

```jsx
import { getTemplateData } from './component';

$ var data = getTemplateData(state, input);

<div>
    Hello ${data.name}!
</div>
```  Currently, if you have a template with the following
```xml
<some-tag-that-does-not-exist/>
```

The following HTML will be output:
```xml
<some-tag-that-does-not-exist></some-tag-that-does-not-exist>
```

We should instead throw an Error if the tag is not a standard HTML tag or has not been defined as a Marko custom tag.  This will help catch typos as well as users who might accidentally write concise style tags at the root when they meant text (or tried to write JS).  If you are using webcomponents, you will be able to list those tags in a `marko.json` file.

The Error message will contain helpful info.  Something like 

```
Marko does not recognize the <di> tag.  Did you mean <div>?  
If you do want to output the <di> tag as HTML, you can whitelist 
it in your marko.json file. See https://markojs.com/docs/somepage 
for more info.
``` @jsumners see the comment from @mlrawlings above. The idea is that you would need to whitelist the custom elements by registering them in your project's `marko.json`:

_src/marko.json:_

```js
{
  "<my-custom-element>": { /* empty */ }
}
```

It's a tradeoff, but I am in favor of catching problems earlier at compile-time. I suppose we could come up with a way for declaring non-standard tags as being tags that should passthrough. For example:

```
<!my-passthrough-tag></!my-passthrough-tag>
<-my-passthrough-tag></-my-passthrough-tag>
<my-passthrough-tag custom-element></my-passthrough-tag>
```

I'm not saying that is a good idea, but I am just through that out there. Personally, I think registering the tag in `marko.json` is a reasonable tradeoff since you also get autocompletion for free and better error checking and reporting at compile-time. We do already throw errors for mismatched tags.  This may come up more in concise mode since the tag does not need to be repeated, but also in HTML when using the self-closing syntax.

I'm not sure this is a good idea, but we could have a global "off" switch for this behavior if there are users that are heavily using Custom Elements and don't wish to list them all.  If there was info about how to do that in the docs linked in the error I think that would eliminate any potential confusion. I think @jsumners has a point. It might only make sense to throw an error on a would-be concise tag.

My vote is for disabling concise mode by default (with exceptions for `class`, `import`, and `export`), and making it easy to enable it via a flag. That should solve most all confusion around syntax. I can definitely see how having many tags to whitelist would be annoying.  For example [a-frame](https://aframe.io/docs/0.4.0/introduction/) has 20+ custom tags implemented as web components.  But if we allowed you to whitelist patterns like `<a-*>` it wouldn't be too bad.

@Hesulan If we're doing this it needs to be the default as one of the big reasons for these kind of helpful error messages is to help beginners who likely won't realize there's some way to opt-in to warnings.

@mindeavor 

> My vote is for disabling concise mode by default

While we could put some modifier in the template (e.g. `@concise`), I don't like the idea that concise users would have to put boilerplate in every file. Putting that configuration in a separate file would break syntax highlight so that would not be an option.

Root level text would also be an issue if there was some global way to turn concise on or off because what would be parsed as text in HTML mode would be parsed as concise tags in concise mode. I'm not convinced this is the right idea, but we could also only have the warning for tags names without dashes in their name.  Custom Elements [require hyphens in their names](https://www.w3.org/TR/custom-elements/#valid-custom-element-name) so we wouldn't catch those tags with this rule. When building a complex project you will often need to rename a UI component. It would be _really_ nice if you could recompile all of your templates to figure out exactly which UI components broke as a result of the name change. I'm strongly in favor of throwing an error when the Marko detects an unrecognized tag as long as we get the error message **perfect** (the developer should know exactly what to do to register the tag and it should be super simple). > I don't like the idea that concise users would have to put boilerplate in every file

Sorry, I meant a global flag. Something like `require('marko/compiler').config({ conciseSyntax: true })` > Sorry, I meant a global flag. Something like require('marko/compiler').config({ conciseSyntax: true })

That won't work because the syntax highlighter would not have that context and do syntax highlighting independently. Can there not be two highlighter definitions? Sublime supports it, at least. Someone enabling `conciseSyntax: true` will know that they're opting into extra syntax, and that they'll want to change to the relevant highlighter if they want those niceties. @Hesulan I don't dislike concise mode per se; I only point out that supporting both concise and normal syntax *at the same time* is the root of all these problems. If concise were opt-in, all the pitfalls disappear (or at least be hidden behind a global flag). If concise were disabled, @ramses0's examples of surprises would no longer be surprising; they would do what you'd expect in any HTML document.

```html
this is
for
you
<h1>Test</h1>
var not_a_var = "this is just text, just like HTML"

for this is text as well!

${ "interpolated" + "value" }
$ console.log("this is JS code. Iffy, but acceptable")

I am plain text
<my-custom-element>
  No problems here
</my-custom-element>
``` @Hesulan As clarification, the idea for this originally stemmed from the discussion we (@mindeavor, @ramses0 and I) had on how to reduce any confusion around syntax, specifically concise syntax at the root, but I think it has enough merit to stand on its own.  

That it would throw an error for unintentional concise tags at the root is only one benefit. Related to this, Patrick and I are looking at creating a "standard" of sort that could be adopted by web component libraries to make their custom tags visible to tooling.  

Marko's autocomplete in Atom was originally forked from [`autocomplete-html`](https://github.com/atom/autocomplete-html) and it was extended to autocomplete not just HTML elements, but also Marko custom tags that were discovered through directory scanning and `marko.json` files.

We're thinking that we could submit a PR back to the original package that would support discovering an `html-elements.json` in project, but also at the root of any packages that the project depends on.  This process and the format of the json file would be similar to the Marko process and format, which has worked well for us.

This would allow a web component package to simply add this file (which could be generated) and autocomplete would be made available to the `autocomplete-html` package (which has over 200k downloads).  There's an immediate benefit to doing so, but future tools would also be able to make use of this information.

And of course so would Marko.  If we could get the web community to adopt this, it would mean you might never (or rather, rarely) have to add definitions/exceptions for third-party custom element tags on your own.

That's definitely a big "IF", but between reaching out to other developers, possibly making some PRs to popular libraries and the fact that there's benefit to the libraries and end users (it's not purely driven by a need of Marko) it could very well work. Great idea. I fully support that. @Hesulan Saving people from root-level text is the whole point of this thread, isn't it? It's only a problem because of automatic concise mode.

> This will help catch typos as well as users who might accidentally write concise style tags at the root when they meant text (or tried to write JS). @Hesulan I know the goal is to prevent typos, but the only reason this came up is because of concise mode. After all, **any** custom element tag is valid HTML.

In *principle* there should be no errors thrown, because an unknown tag is 100% valid in the browser. However, in *practice* I don't feel that strongly about it, and wouldn't mind if these errors made it in.

Actually, this just dawned on me â€“ custom element tags are only valid HTML [if they contain a dash within the name](https://w3c.github.io/webcomponents/spec/custom/#h-note2). Since JavaScript keywords nor identifiers can contain dashes, doesn't that mean there is only a reason to throw errors on unrecognized single-word tags? oops, I totally missed his comment on that :) I still think starting with throwing on all unrecognized tags is a sane default and the error message would point you to information on how to configure things:

### Configuring in `marko.json`

Throw on any unrecognized tag (default value):
```js
{
    "ignore-unrecognized-tags": false || []
}
```

Turn off errors/warnings:
```js
{
    "ignore-unrecognized-tags": true || ["*"]
}
```

Turn off errors for tags with dashes:
```js
{
    "ignore-unrecognized-tags": ["*-*"]
}
```

Turn off errors for certain tags from polymer:
```js
{
    "ignore-unrecognized-tags": ["paper-*", "iron-*", "google-*"]
}
```

### Defining individual tags in `html-elements.json`

We still need to figure out the details on this, so this probably wouldn't make it in right away.

Defining tags in `html-elements.json` will make it so Marko recognizes them and won't throw, but Marko's atom plugin will also pick them up and make them available for autocompletion when authoring your templates and components.

The goal would be for authors of the web components to generate this file as part of the web component package.

```js
{
    "<paper-button>": {
        "url":"https://elements.polymer-project.org/elements/paper-badge",
        "description":"<paper-badge> is a circular text badge that is displayed on the top right corner of an element, representing a status or a notification. It will badge the anchor element specified in the for attribute, or, if that doesn't exist, centered to the parent node containing it.",
        "@for": {
            "type":"String",
            "description":"The id of the element that the badge is anchored to. This element must be a sibling of the badge.",
        },
        "@icon": {
            "type":"String",
            "description":"An iron-icon ID. When given, the badge content will use an <iron-icon> element displaying the given icon ID rather than the label text. However, the label text will still be used for accessibility purposes.",
        },
        "@label": {
            "type":"String",
            "description":"The label displayed in the badge. The label is centered, and ideally should have very few characters.",
        },
        "@target": {
            "type":"String",
            "description":"Returns the target element that this badge is anchored to. It is either the element given by the for attribute, or the immediate parent of the badge.",
        }
    }
}
 For the record, I now believe this was the right choice. After upgrading to rc.13, marko immediately informed me about two invalid tags that I forgot to change during a rename! ðŸ˜„  @mindeavor I experienced the same thing. We had some tests that were incorrectly referring to unregistered tags. I'm not very impressed with the Github Wiki system, but we decided to put details on errors in the Wiki: https://github.com/marko-js/marko/wiki/Error%3A-Unrecognized-Tag

Please let us know if you see any issues!  The `class` tag currently supports creating a component when anonymous:
```jsx
class {
   constructor() {}
}
```
But creates a normal JS class when it has a name:
```jsx
class Foo {
   constructor() {}
}
```

We want to remove the second functionality.  It will _always_ create a component's class and you can optionally name that class.  With the new `$ <code>` syntax, we have a better way to add JS to a template and no longer need these tags.  We do want to make them available for the v3 -> v4 migration.  Should we just add a deprecation warning or split them out into a `marko-v3-compat` package? My preference would be to split them out so we're rid of them as v4 users, but it makes things a little tricky with sub packages that export tags because taglibs outside of Marko are not global. Related: #379 I think a migration package is a good idea. If one intends to move from v3 to v4, installing a package would be the least of those efforts.

What do you mean by sub packages that export tags? @mindeavor Say I am using a package with a taglib that is intended to be share across apps, let's call it `ui-components` and say one of the tags it exports is `<ui-carousel>`.  

`ui-components` was developed against v3 and as such uses legacy widgets.  The way things currently stand with v4, these components should still be able to be used with a v4 app.

The problem in moving deprecated tags out to a package is that if the `<ui-carousel>` template uses the `<var>` tag, it wouldn't be discovered because templates only look for tags in packages that their package (in this case `ui-components`) directly depends on.  It wouldn't look at the application's dependencies to find `marko-v3-compat`.
 This really isn't an issue as we could use the not-really-documented [`taglibLookup.registerTaglib`](https://github.com/marko-js/marko/blob/master/compiler/index.js#L229-L234) to make it globally available.  But if there is any runtime code (which there isn't in this case) using that API can cause discoverability problems. @Hesulan We actually are using the parser in legacy mode in v3 and have a number of warnings, including the [switch from `-` to `--`](https://github.com/marko-js/htmljs-parser/blob/master/Parser.js#L1359-L1361).  The goal is to allow users to upgrade without any changes if there are no deprecation warnings in v3. This might be a crazy idea, but what about a `marko-v4-stepping-stone` package that enables v4 syntax for v3 and adds deprecation warnings for all the old stuff from v3? Oh interesting, I didn't know `<var>` could use body text like that. Is that scope actually enforced? > The introduction of $ var flavor=input.someFunc() kill the template and you end up with PHP all over again.

Let's be honest here: We don't get PHP simply because of `<? ?>` tags. Unless you consider Ruby on Rails and ERB to be PHP as well!

I do find the `<var x=10>...</var>` feature interesting. To avoid potential confusion with JS, maybe you could rename it to something like `<scoped x=10>`, for those who want that feature. Fixed by https://github.com/marko-js/marko/commit/768d8085f7adc8811e027ec7a88cae682a703a9e (thank you @austinkelleher !) The scoped variables use case is interesting. I'm not opposed to introducing something to support that use case, but I am not convinced `<var>...</var>` was the best solution. @ramses0, what are your thoughts on the following? :

```html
<div>
    <scope>
        $ var name = 'Frank';
        $ function doSomething() {
        
        }

        <span>Hello ${name}!</span>
    </scope>
    <!-- `name` and `doSomething` will be undefined here -->
</div>
```  â€¦ing the Node.js require hook.

Also allows passing `extensions` or `extension` as options to `handleFileModified`.  Hey @steebchen, this is a duplicate of [Issue #363 - Auto hot reload for any extensions provided when installing the Node.js require hook](https://github.com/marko-js/marko/issues/363). Would you have any interest in working on this? At the moment, that issue is lower priority, but we do plan to have it resolved by the time of the final v4 release. @austinkelleher has completed the work for this and we'll publish a new release candidate soon  @jasonmacdonald can you please point to the code? `Symbol()` should not be used in browser code and all of our tests are running in a very older version of V8 that doesn't support `Symbol` so I would not expect `Symbol` to be used. Also, which JS module bundler are you using (Lasso, webpack, etc.)? There is a "widgets/util.js" and a "widgets/util-browser.js". We remap the former to the latter by putting a `browser` field in the `package.json` file: https://github.com/marko-js/marko/blob/44c38e74ad1a0c515ab96a05169f9c096678a3c2/widgets/package.json#L6

All JavaScript module bundlers (including Browserify, rollup, lasso, webpack, etc.) should respect the `browser` field. If you can provide a simple app to reproduce the problem with `browserify` that would be helpful. It could be a bug in browserify or it could be some strange combination of things. We should definitely investigate because browserify is supported.  > I suspect this is working as intended

It is, but with a little work, we can get the result you want.

> I also tried using input.renderBody(out, WidgetB_data), inside WidgetB. But, that still seems to use WidgetA data.

@jasonmacdonald You're on the right track! 

Before we get to the solution, I want to show you _why_ this is what is happening (and why it makes sense).  This is a simplified version of what gets compiled for Widget A:

```js

function render(data, out) {
    widget_b({ 
        data:2, 
        renderBody: function(out) {
            out.w('<div>'+data+'</div>');
        }
    }, out);
}
```

So, it's no surprise that `data` comes from Widget A in this case.  Or that passing an additional value to `renderBody` didn't work, because it only has an `out` parameter &mdash; but we can change that.

In the `marko-tag.json` file for Widget A (or the `marko.json` file under the Widget A definition), you can add a new key [`"var"` or `"vars"`](https://github.com/marko-js/marko/blob/eb2351212d32fb09959d1823f347ce6203070b7f/compiler/taglib-loader/loader-tag.js#L452-L481) (note it is not prefixed with `@` like an attributes). `var` takes a string as its value while `vars` takes an array, but in both cases the variable(s) are added as parameters to the `renderBody` function.

So with this in your `marko-tag.json` for Widget A,
```js
{
    "var": "data"
}
```

The new output would be:
```js
function render(data, out) {
    widget_b({ 
        data:2, 
        renderBody: function(out, data) {
            out.w('<div>'+data+'</div>');
        }
    }, out);
}
```

And now `input.renderBody(out, data)` would work as expected.

**But**, I would recommend that you don't just name the parameter `data` as the user of Widget A may still want access to Widget A's data and you're essentially preventing the user from accessing it by naming the parameter the same.

There's also a more flexible value that can be passed to `var` (or as an entry in the `vars` array): 
an object with the key `"name-from-attribute"`.  This allows the user to specify what they want the parameter to be called:

Widget A's `marko-tag.json`:

```js
{
    "var": { "name-from-attribute": "param" }
}
```

Usage:

```jsx
<widgetB data="2" param="nestedData">
   <!-- trying to declare this inner content as a template 
   to be used to render the contents of Widget B -->
   <div>${nestedData}</div>
</widgetB>
```

The new output would be:
```js
function render(data, out) {
    widget_b({ 
        data:2, 
        renderBody: function(out, nestedData) {
            out.w('<div>'+nestedData+'</div>');
        }
    }, out);
}
```

And you can call `input.renderBody(out, data)` and that second `data` parameter will be made available in the `renderBody` method as `nestedData` &mdash; which the user chose. I also want to point out that we add one more layer on top of this for the await tag.  The await tag is used like:

```html
<await(value from promise)>
    ${value}
</await>
```

We transform this to the following in the [await transformer](https://github.com/marko-js/marko/blob/master/taglibs/async/await-tag-transformer.js#L28-L29):

```jsx
<await _var="value" _dataProvider="promise">
    ${value}
</await>
```

The await tag also has `{"name-from-attribute":"_var"}` specified in the [`marko.json`](https://github.com/marko-js/marko/blob/master/taglibs/async/marko.json#L53-L55)

Which results in `value` (in this case) being made the second parameter to `input.renderBody`.  Then we just wait for the promise to resolve and [pass the result to `renderBody`](https://github.com/marko-js/marko/blob/master/taglibs/async/await-tag.js#L120). This should work:

```html
<div for(item in items)>
    <invoke data.renderBody(out, item)/>
</div>
```

Note, that in 3.0 if `<tileList>` stateful, `renderBody` won't be available the second time around, but this is fixed in 4.0 if you do:

```html
<div for(item in items)>
    <include(data.renderBody, item)/>
</div>
``` Marko 4 includes widgets, so you don't need `marko-widgets` anymore @jasonmacdonald Adding the `marko-tag.json` file as you did is the correct thing to do. We'll revisit the docs for v4 to make things more clear. Since we are completely reworking the documentation I'm going to go ahead and close this issue. In the meantime, please let us know if you have any specific questions...happy to help.  We no longer want to hijack the standard HTML `<style>` tag to avoid confusion and future problems. Instead, we will use the following:

```css
style {
    .foo {
        background-color: 'red';
    }
}
<div>Hello World</div>
```

Or, with a specific CSS preprocessor language:

```css
style.less {
    .foo {
        background-color: 'red';
    }
}
<div>Hello World</div>
```  We've decided to stop hijacking the script tag and use concise style tags that look like JS instead.

### Deprecate `<script>` with export

Old:

```html
<script>
   module.exports = {
      handleClick() {
         alert('hi!')
      }
   }
</script>

<button on-click('handleClick')>Click me!</button>
```

New:

```jsx
class {
   handleClick() {
      alert('hi!')
   }
}

<button on-click('handleClick')>Click me!</button>
```

### Deprecate `<script template-helpers>`

Old:

```html
<script template-helpers>
   function sum(a, b) {
      return a + b;
   }
</script>

<div>The sum of 1 + 2 is ${sum(1, 2)}</div>
```

New:
```jsx
static function sum(a, b) {
   return a + b;
}

<div>The sum of 1 + 2 is ${sum(1, 2)}</div>
```


### Moving to an external file

One concern you may have is that with the `<script>` with export approach, the only change required to move a component to an external `.js` file was copy and paste.  Admittedly, it's not _quite_ that simple, but it's still really easy.

This template:
```jsx
import sum from './helpers/sum';

class {
   handleClick(a, b) {
      console.log(sum(a, b))
   }
}

<button on-click('handleClick', 3, 4)>Click me!</button>
```

becomes these two files

_component.js_
```js
import sum from './helpers/sum';

export default class {
   handleClick(a, b) {
      console.log(sum(a, b))
   }
}
```
_index.marko_
```xml
<button on-click('handleClick', 3, 4)>Click me!</button>
```

So we copied over _and had to add an export statement_.  Still pretty simple. What does moving static functions over to `component.js` look like? @mlrawlings Can you update this issue to also mention:

```js
static {
  function myHelper() { ... }
  var foo = 'hello';
}
```

I wonder if it makes sense to recommend `static { ... }` because it makes it a little easier to move those functions how to a separate file if needed (only the block content needs to be copied out) @mindeavor, @philidem and I had an impromptu discussion based on concerns raised in the Gitter chat room. The following proposal seemed to be liked by everyone:

```js
static {
    function myHelper() {
         /* ... */ 
    }

    class ViewModel {
        constructor(data) {
            this.data = data;
        }

        get fullName() {
            return this.data.firstName + this.data.lastName;
        }
    }
}

component style lang="less" scoped {
    .foo {
        background-color: 'red';
    }
}

component class {
    onInput() { /* ... */ }
    handleButtonClick() { /* ... */ }
}
```

Reopening the issue for discussion. It's not too late to voice your approval or concerns. Although I find that syntax ok, my ideal syntax would still be something like this:

```html
<script marko>
import helper from 'library';

class Component {
    onInput() { /* ... */ }
    handleButtonClick() { /* ... */ }
}

function myHelper() {
     /* ... */ 
}

class ViewModel {
    constructor(data) { /* ... */ }
    get fullName() { /* ... */ }
}
</script>


<style lang="less" scoped>
.foo {
    background-color: 'red';
}
</style>

<div class="the-component">
    <h1>${ state.name }</h1>
</div>
``` I think it's good and unsurprising that marko transforms `<style>` tags. I wouldn't want my styles to be inlined every time I use the component :)

If we really want to stay away from `<script>`, then we can use a different name instead:

```html
<component>
import helper from 'library';

class {
    onInput() { /* ... */ }
    handleButtonClick() { /* ... */ }
}

function myHelper() {
     /* ... */ 
}

class ViewModel {
    constructor(data) { /* ... */ }
    get fullName() { /* ... */ }
}
</component>
```

My primary preference is to have a single tag for all my JS code if possible. > I think it's good and unsurprising that marko transforms <style> tags. I wouldn't want my styles to be inlined every time I use the component :)

@mindeavor I mostly agree (which is why this is the current behavior), but there is the concern that someone could be using Marko as a pure template language (without lasso, webpack, etc) &mdash; something we still want to support.  Suppose you had a template like the following that you wanted to include in the `<head>` of many pages:
```html
<title>${data.title ? data.title + ' | Marko' : 'Marko'}</title>
<link rel="icon" type="image/png" sizes="32x32" href="/public/favicon.png" />
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<style>
    body { background:#f00; }
</style>
```
It would probably be surprising if your `<style>` tag didn't show up in the output.


> I really like this proposal. Correct me if I'm wrong, but I'm assuming the HTML syntax would look like:
> ```xml
> <static {
>    function myHelper() { /* ... */ }
> } />
> <component class {
>     onInput() { /* ... */ }
> } />

@Hesulan Yes that would be the equivalent HTML syntax, but I don't think that's a good idea (and Patrick is talking about potentially making that invalid).

> Would <static> still accept body content like <script marko-init> did?

It does not with the current implementation, but that would be trivial to implement.  It would require updating the syntax highlighter though.

 I would like to point out that I prefer the HTML syntax, _but_ I think it makes sense to use the concise syntax for these JS-like tags and other tags that don't directly affect the output, while still using the HTML syntax for tags that are actually involved in rendering the final HTML output.

`<script>` and `<style>` not ending up in the output HTML doesn't fit with the default expectation and for someone learning how to write a component, they will look up the documentation and follow what it says.  I don't think there's some default expectation that putting something in a `<script>` allows you to create component methods that can be attached to elements - this idea is foreign to HTML and why we need something like Marko in the first place.

Regarding `component class` or `component style`, everything in the template is _for_ the component.  It is redundant to say `component`.

For someone who is new to Marko, I really find it difficult to believe that someone would look at the following and not understand what is happening.  And I don't see how wrapping this in a `<script>` tag would make it any less intimidating.

![image](https://cloud.githubusercontent.com/assets/1958812/22353057/8e1b2186-e3d3-11e6-8476-e74234ab757e.png) @mlrawlings I generally agree with what you're saying. `style {}` is fine, and so is `class` in your simple example. Using curly brackets to differentiate between html tags and output is a good idea too.

The problem appears when you want something more than just a `class`. Specifically:

- Where do I put imports?
- Where do I put helper functions?
- Where do I put static data?

`class` is not really a class, but a special tag that looks like JavaScript. The current answers are in the same vein: a special `import` tag, a special `function` tag, and a special `static` tag. Put this together with `var`, `for`, and probably others, and you've reached an uncanny valley of javascript-but-not-really-javascript syntax.

The reason I was ok with `component class {}` was that the word `component` immediately tells you something special is going on, to up your guard and not think you can write just any JavaScript code in this file.

Another proposal with these things in mind:

```jsx
script {
  import helper from 'library';

  class Component {
    onInput() { /* ... */ }
    handleButtonClick() { /* ... */ }
  }

  var languages = ['js', 'css', 'html']

  function myHelper() {
     /* ... */
  }

  class ViewModel {
    constructor(data) { /* ... */ }
    get fullName() { /* ... */ }
  }
}

style {
  .count {
    font-size: 3rem;
    padding: 0.5rem;
    width: 3rem;
  }
}

<button on-click('handleButtonClick') />
<select>
  <option for(lang in languages) value=lang>lang</option>
</select>
``` The "component class" is special and I believe it deserves to be moved up to the root. I think a block consisting of curly braces is a good indicator that the code is JS/CSS. Taking your example, I think the following reads really well:

![marko-syntax](https://cloud.githubusercontent.com/assets/978214/22354955/014cc216-e3e5-11e6-9b43-a97c41a33595.png)
 â˜ï¸ @patrick-steele-idem That does look nice.

## Other thoughts

> and not think you can write just any JavaScript code in this file.

@mindeavor I understand that concern and I could probably be convinced to dial back some of the JS tags introduced in v4, specifically `class` (for non-component classes) and `function` and probably `invoke`, maybe even `assign` and `var` &mdash; we could require them to be within a JS block where any JS is valid.

Beside the fact that I like the component's class definition at the top-level, I really think that within the `static` block (or `script` as you suggested - but I think [static](https://en.wikipedia.org/wiki/Static_variable) is the right term) that it should be _"Just JavaScriptâ„¢"_.  You shouldn't have a special `class Component` that gets picked up in some magical way - that kind of stuff should happen in Marko land.

Here's my current thoughts on the list of "JS" tags we should support and their rational:

### `static { ... }` to embed static javascript code
We need a way to have code that runs statically, that is once when the template is loaded and then is available every time the template is rendered.  This beats `<script marko-init>` because this is not included in the output - see previous messages for more detail.

### `{{ ... }}` to embed runtime javascript code (in the `render` method)
Currently we have `var`, `invoke`, and `assign` tags (and we added `function` and `class` in v4) but maybe we deprecate those? We also have scriptlets (`<% ... %>`), but sticking with our curly brace notation seems to make sense and using something that could be interpolated in both HTML and concise syntax. (This would actually be a language level thing, like scriptlets, not a tag).

### `class { ... }` to define a component's class
Defining the component's class is somewhat special, and I don't think we should start modifying what you're expecting to be pure JS.  Just by seeing `class`, it lets you know exactly what syntax is allowed inside the `{ ... }` because it's a 1:1 match with JS.  (This would be my argument against something like `component {}`).

### `style { ... }` to define a component's style
We need a way to write styles and don't want to hijack the `<style>` tag.

### `import` to pull in external helpers
For one, this is ES6 syntax, but we generate CommonJS `require` calls, so you wouldn't need any extra transpilation step.  I also really feel like imports should be at the top outside of a block, but maybe that's not valid?

### `export` to export data attached to the template
There are some legitimate cases where you might want to export some values from a template.  The template lives in a `marko_template` variable that gets generated, but that shouldn't be manipulated directly, the `export` tag will do that for you.  (Having this tag also is somewhat of an argument for `import` to make things balanced).

### `var`
Do we need var?  It already exists in v3 and we probably don't want to remove it at this point, right?  I agree that it's kinda nice to not have to wrap `var` in `{ ... }`, but the same could be argued for any JS statement, so where do we draw the line?


## What about...

@patrick-steele-idem, @mindeavor What are your thoughts on this example?

```jsx
import { CurrencyFormatter } from './formatters';

static {
    var format = new CurrencyFormatter('usd');
}

class {
    constructor(input) { ... }
    adjustPrice(index, amount) { ... }
}

{{ var products = state.products; }}

<table>
    <tr for(i, product in products)>
        {{ var name = product.name;
           var price = product.price; }}

        <td>${ name }</td>
        <td>${ format(price) }</td>
        <td on-click('adjustPrice', i, -1)>- $1.00</td>
        <td on-click('adjustPrice', i, +1)>+ $1.00</td>
    </tr>
</table>
``` @mlrawlings I think dialing back the JS tags is a great solution. Having a minimal number of them makes me a lot more comfortable explaining and promoting the idea to others.

I think I agree with all your points in tandem; your example suits well with me. The only confusion I foresee is people trying to `import` or `require` within `static`, but good error messages should be able to mitigate.

The special tag for runtime code makes a lot of sense when you compare it to the `static` tag; presenting them together makes them easy to explain.

If you don't mind a bit of bikeshedding... I think `%{}` would be a nicer than `{{}}`, since it parallels with `${}` :) > If you don't mind a bit of bikeshedding... I think `%{}` would be a nicer than `{{}}`, since it parallels with `${}` :)

Totally fine.  I have some more thoughts to share on the stylistic front.  And would like your opinion on some of these things.

One _small_ issue I have with `static { ... }` is that it kinda seems as if the JS is scoped to that block, when in reality it's available throughout the template and even to the `class`.

If you look at the OP, `static` also supports an "inline" mode where you can have a single statement without a block:

```js
static var foo = 123;
```

I'm curious what you think of this mode, but I like that it brings the statement up to the top level, but I still know that anything following the `static` keyword is just JS.

In any case, I wonder if we could have something that gives us a similar experience for the runtime JS.  I still want something that could be (safely) interpolated within HTML.  


```jsx
import { CurrencyFormatter } from './formatters';

static var format = new CurrencyFormatter('usd');

class {
    constructor(input) { ... }
    adjustPrice(index, amount) { ... }
}

% var products = state.products;

<table>
    <tr for(i, product in products)>
        % var name = product.name;
        % var price = product.price;
        <td>${ name }</td>
        <td>${ format(price) }</td>
        <td on-click('adjustPrice', i, -1)>- $1.00</td>
        <td on-click('adjustPrice', i, +1)>+ $1.00</td>
    </tr>
</table>
```

In this case we would also support `% { ... }` for multiple statement if thats what you wanted to do.

Okay, so I used `%` in the example just because, but @patrick-steele-idem kinda hates the `%` symbol and I don't know that I really like it either.

We also looked at the following options:

Looks nice, kinda like a REPL prompt, but could be confusing with `${}`:
```js
$ var foo = 123;

// this has a space, so it's different than ${}
$ {
    var bar = 456;
}
```

Probably safe, but two characters:
```js
$$ var foo = 123;

$$ {
    var bar = 456;
}
```

Also looks like a prompt, but ruins any hope of using markdown in a template:
```js
> var foo = 123;

> {
    var bar = 456;
}
```
Only breaks nested blockquotes in markdown:
```js
>> var foo = 123;

>> {
    var bar = 456;
}
```
For reference:
> This is a block quote
>> This is a nested block quote ðŸ˜¢ 
> > This nested block quote has a space though and would still work (`> >`) `static` one-liners seem good; the keyword conveys something different than plain JS is happening.

To be honest, I'm ok with drawing the line at `var` for JS tags, so long as documentation uses the `<var />` form to avoid any confusion. If someone opts for writing concise syntax, they'll know that they're only stripping away some angled bracket characters, as opposed to writing plain JS.

With that said, I don't know if `%{}` (or `$${}` or whichever symbol chosen) needs a concise version. The current `${}` certainly does not, and the only difference between it and the former is that the former outputs nothing. @mindeavor Really appreciate your input on this. I do think we will end up in a good place and I think we all are in favor of reducing the number of special tags.

> With that said, I don't know if `%{}` (or `$${}` or whichever symbol chosen) needs a concise version.

Agreed. Whichever syntax we finally settle on, it will be the same for both concise and HTML.

We internally polled some devs at eBay and the following seems to be the most popular:

![marko-component](https://cloud.githubusercontent.com/assets/978214/22394142/f3d08f78-e4d4-11e6-88ed-f889c5929bf8.png)
 Huh... I think I like it :) Would a backslash `\$` allow you to insert literal dollar sign characters? > Would a backslash \$ allow you to insert literal dollar sign characters?

Yup, that's what I am thinking and that is what we allow if you need to escape placeholders.

If you are good with it, then I propose we move forward with `$ <code_block>` and `$${ <code_block> }`.

If anyone has any last minute objections please let us know!

/cc @austinkelleher @philidem @mlrawlings @Hesulan @Eldar-X  @mikewoo200 this past week I looked into what it would take to support linting of embedded JS inside Marko. We can do it in Atom very easily, but I think the main goal will be to ensure that the JavaScript is valid. In the future, when Marko supports source maps we can apply linting to the entire compiled output to catch problems such as undefined variables and unused variables (this cannot be done on individual embedded JS fragments). With source maps we can map the linter warning back to the location in the original template file. Here's another potential issue to discuss: Would any `$` enter "js mode", or does the `$` need to be the first non-whitespace character of its line?

Example:

```html
<div>
  $ console.log('x')
  Price range is $ for this venue.
  Price range is $$$ for that venue.
</div>
``` That's the plan - first non whitespace character, followed by a space

On Sun, Jan 29, 2017, 12:39 PM Gilbert <notifications@github.com> wrote:

> Here's another potential issue to discuss: Would any $ enter "js mode",
> or does the $ need to be the first non-whitespace character of its line?
>
> â€”
> You are receiving this because you were mentioned.
> Reply to this email directly, view it on GitHub
> <https://github.com/marko-js/marko/issues/547#issuecomment-275944198>, or mute
> the thread
> <https://github.com/notifications/unsubscribe-auth/AB3jnOk12Z1yIi79QgScEITg3Wpipjyfks5rXPkVgaJpZM4LtAQG>
> .
>
 Both need to be at the start of the line or prefixed only by whitespace:

- Single line: `/^\s[$]\s/` 
- Multiline `/^\s[$]{2}\{/` @mikewoo200 

> But for style linting (spaces, indents) in the template, what can we do?

We could definitely come up with a way to enforce code style for embedded JS and Marko code as well. We'll probably need to explore that more after the v4 release. Copying thoughts from an internal discussion where we've decided `$ <code>` and `$ { <code> }` is the direction we're going to take.

----

So despite my initial reservations on `$ { ... }` I think this is the right approach.

It would only be allowed at the beginning of a line (`/\s*\$ \{/`):

```
$ var price = 5;
$ {
  var id = 0;
  function nextId() {
    return id++;
  }
}
```

Ambiguity has been the reasoning against this, but looking at it again, even without syntax highlighting, I think it is pretty clear (and it definitely looks nicer), and @scttdavs  has pointed out that with proper syntax highlighting it would be made _very_  clear (red `$` vs blue `$`, for example).

<img width="420" alt="screen shot 2017-01-30 at 9 35 49 pm" src="https://cloud.githubusercontent.com/assets/978214/22452575/4afce74e-e735-11e6-9b2f-af28c42a984b.png">

Part of the reason this makes sense is that we're already planning to allow `{}`, `()`, `[]`, etc. to allow the expression to continue to the next line:

```js
$ var foo = {
   bar: 1
}
```

But JS already supports a [block statement](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/block), so we would actually have to special case `$ ` to _disallow_ `$ { ... }`.

And there is an issue with `$${ ... }` that could potentially end up with a confusing situation like this:

```html
<span.price>
    $${price.toFixed(2)}
</span>
```

So in order to get what you want in this case (`<span class="price">$5.00</span>`), you would need to escape the first `$`:
```html
<span.price>
    \$${price.toFixed(2)}
</span>
```

But if you actually wanted to output the multiline sequence (perhaps you're explaining how to use it), you need to escape the _second_ `$`:
```html
<code>
    $\${
        var price = 5;
    }
</code>
```

With the single `$`, escaping is straightforward:
```html
<code>
    \$ {
        var price = 5;
    }
</code>
```

It's a fairly subtle difference, but I do think that it's only going to be an issue in one direction:
```jsx
// I could see someone doing this
${
    var foo = 123;
    var bar = 456;
}

// I don't see this happening
<div>
    Hello my name is $ {name}.
</div>
```

In the above case, we're typically going to see multiple JS statements because we also allow the single line version:
```js
$ var foo = 123;
```

So, if you accidentally forget the space for a multiline JS block, it will compile to:

```js
out.w(escapeXML(var foo = 123;var bar = 456;));
```

That's going to be pretty easy to detect. @Hesulan What I meant is that the single line version, because we allow continuing, is also the multiline version.  So If we wanted to have a _different_ symbol (like `$$`) and didn't want the single `$` to allow multiline, it would take more work.

Your logic is pretty much how I implemented it: https://github.com/marko-js/htmljs-parser/commit/21958233e1c4c442e8e338dc14c537b813ffab2a#diff-61eec70114a46820c77ce5879a128729R658

I'm going to close this as the work has been completed.  Thank you everyone for your feedback and help in reaching this point! @jsumners I also dislike classes in general. However, the *concept* of a class fits perfectly with what a marko component is, and the class syntax is now officially part of the JS language. In marko's case, a class is the best tool for the job.

As I understand it, the only "floating JS blocks" marko 4 will support are `class` and `import`. I think this is reasonable, especially since they are so common (though I would push back against adding any more), and even then they are not really JS blocks, but tags. Real JS code blocks need to be written using either the `static` tag or the `$` runtime tag. @Hesulan `static` supports a block:

```
static {
  function myHelper() {
  }

  var foo = '123';
}
``` > On a related note, could <static> fall back to using body-text if the { /* ... */ } attribute is omitted? I think a lot of users would prefer that, and it would certainly ease the transition from <script marko-init>.

Hmm... do we only do it for `static`, or everything?  This might be a bad path to go down...

```html
<!-- Not quite JS -->
<class>
    constructor() {
        this.state = { count:0 };
    }
    increment() {
        state.count++;
    }
</class>

<!-- Highjacking the style tag again :( -->
<style>
    button {
        background:#fff;
    }
</style>

<!-- the "concise" equivalent is technically a language construct, not a tag -->
<$ var foo = 123/>
<$>
    var foo = 123;
    var bar = 456;
</$>

<!-- I don't think I have any issues with these -->
<static var foo = 123/>
<static>
    var foo = 123;
    var bar = 456;
</static>

<!-- I *would* take issue with this -->
<static function sum(a, b) {
    return a+b;
}/>

<!-- These are fine -->
<import foo from "file"/>
<export var num = 2/>
```
  Thanks for reporting the problem. I'm investigating now. Resolved. New version published with fix: `marko@3.14.1`

This bug had already been fixed in Marko v4.

Thanks again for reporting the problem.  You can immediately switch into HTML parsing mode by using an HTML delimited block:

```html
--
This is all parsed
as <strong>HTML<strong>!
--
```

Does that solve your issue? @patrick-steele-idem The parser allows disabling concise mode.  Do we (or can we) disable it for `.marko.html` and `.marko.xml` files? We could disable concise mode for `.marko.html`, but I'm not sure we want to go there because it breaks syntax highlighting (unless we refactor our syntax highlighting bundles). Sorry for the lack of docs on that @rgagnon24. We are completely reworking the docs for the Marko v4 release and things will be a lot more clear. Let us know if you have any questions, but closing this issue for now.   I pushed a fix. I will be publishing a new version very shortly. Thanks for reporting the problem @Eldar-X.  New version published: `marko@4.0.0-rc.6`

Please let us know if you see any other problems. Thanks!  @Eldar-X Would this cover your use-case? https://github.com/marko-js/marko/blob/bce3836d099854f3aa9f2f48fffb470cd7a78399/docs/04-core-tags.md#export

I'm going to implement this in a bit unless you have some feedback.  Can you explain a bit more? I'm not clear on what you are suggesting.  The `marko-magic` module enables game changing auto-detection for asset dependencies. I had thought that marko would absorb it all for v4, but it looks like `marko-magic` is still necessary for some lasso-related things.

For example, in the [ui-components-playground](https://github.com/marko-js-samples/ui-components-playground) I still see:

- `<lasso-head/>` and `<lasso-body/>` in the layout
- a `browser.json` for declaring a `style.less` dependency
- a `browser.json` for the home page, declaring the `<app>` and other browser dependencies.

Since marko is already at `v4.0.0-rc3`, I need to ask: are you all planning to release without the asset detection features? So technically, these changes will be outside of Marko and be a part of the Lasso taglib.  While Marko is at an RC, there are still some things to update in supporting packages and this is one of those things.

However, I would like to have some discussion around the Marko magic approach and if we should make all of it mainstream.  

Particularly, I have concerns about automatically injecting the Lasso head and body tags automatically.  I wonder if it's a bit weird that, since we use `head` as an injection point, that if there is no head tag you won't get any styles.
Likewise for body. I think requiring `<lasso-head/>` and `<lasso-body/>` is acceptable. It's the json files that I'm mostly concerned about; I want to write as few of those as possible :)  ## Version **2.0.0** of [fs-extra](https://github.com/jprichardson/node-fs-extra) just got published.

<table>
  <tr>
    <th align=left>
      Dependency
    </td>
    <td>
      fs-extra
    </td>
  </tr>
  <tr>
    <th align=left>
      Current Version
    </td>
    <td>
      1.0.0
    </td>
  </tr>
  <tr>
    <th align=left>
      Type
    </td>
    <td>
      devDependency
    </td>
  </tr>
</table>

The version **2.0.0** is **not covered** by your **current version range**.

Without accepting this pull request your project will work just like it did before. There might be a bunch of new features, fixes and perf improvements that the maintainers worked on for you though.

I recommend you look into these changes and try to get onto the latest version of fs-extra.
Given that you have a decent test suite, a passing build is a strong indicator that you can take advantage of these changes by merging the proposed change into your project. Otherwise this branch is a great starting point for you to work on the update.


---


<details>
<summary>Commits</summary>
<p>The new version differs by 40 commits .</p>
<ul>
<li><a href="https://urls.greenkeeper.io/jprichardson/node-fs-extra/commit/fcfa595ca022011ce0f61d337598a4573fe8eb3c"><code>fcfa595</code></a> <code>2.0.0</code></li>
<li><a href="https://urls.greenkeeper.io/jprichardson/node-fs-extra/commit/23f2b1d51d48a433a5ce8547190e84e2a36d12c0"><code>23f2b1d</code></a> <code>CHANGELOG: add issues</code></li>
<li><a href="https://urls.greenkeeper.io/jprichardson/node-fs-extra/commit/b34da2762a4865b025cac06d02d6a2f1f1027b65"><code>b34da27</code></a> <code>(Closes #344) LICENSE: update year</code></li>
<li><a href="https://urls.greenkeeper.io/jprichardson/node-fs-extra/commit/c010fff71f9d9d0b5789c44e5bad37e3e8fc1bd9"><code>c010fff</code></a> <code>Merge pull request #343 from mawni/readme-add-klawsync</code></li>
<li><a href="https://urls.greenkeeper.io/jprichardson/node-fs-extra/commit/90bd756785fc54aa10a9078e559076cf522fa622"><code>90bd756</code></a> <code>Readme: add klaw-sync link</code></li>
<li><a href="https://urls.greenkeeper.io/jprichardson/node-fs-extra/commit/ab644a48cbd3e51182d750f7d66609b5bfd5fe0d"><code>ab644a4</code></a> <code>Merge pull request #340 from jprichardson/docs</code></li>
<li><a href="https://urls.greenkeeper.io/jprichardson/node-fs-extra/commit/f6ee61e1bcad75bb12123c1a8a9b1e1f1c15cc15"><code>f6ee61e</code></a> <code>Add note about walk()'s removal, recommend jprichardson/node-klaw</code></li>
<li><a href="https://urls.greenkeeper.io/jprichardson/node-fs-extra/commit/3dc711f46776814df16a8b8bfb1528ac9d241e70"><code>3dc711f</code></a> <code>Add fs-promise as fs-extra-promise alternative</code></li>
<li><a href="https://urls.greenkeeper.io/jprichardson/node-fs-extra/commit/383a26985cab5b8a184cea9fa776d2fa6da8a5fe"><code>383a269</code></a> <code>Move API docs to seperate docs/ folder</code></li>
<li><a href="https://urls.greenkeeper.io/jprichardson/node-fs-extra/commit/a2904644f2ef2f77b1981788c899e2f6e06c140a"><code>a290464</code></a> <code>Remove Node v0.12 support message from README</code></li>
<li><a href="https://urls.greenkeeper.io/jprichardson/node-fs-extra/commit/fa408833fbdcd5bc5f4e8cf0af1207832a1a5c79"><code>fa40883</code></a> <code>Move klaw to devDeps</code></li>
<li><a href="https://urls.greenkeeper.io/jprichardson/node-fs-extra/commit/de1d48336fd801114ba9e2e609230565f669d6ef"><code>de1d483</code></a> <code>Merge pull request #339 from jprichardson/rm-walk</code></li>
<li><a href="https://urls.greenkeeper.io/jprichardson/node-fs-extra/commit/1f83cb0cdfc468b4a6b447a1b49b4492391ffb36"><code>1f83cb0</code></a> <code>Remove walk() &amp; walkSync()</code></li>
<li><a href="https://urls.greenkeeper.io/jprichardson/node-fs-extra/commit/cc1aaa949e221fab2976b563e4aa91b200ade7b5"><code>cc1aaa9</code></a> <code>Merge pull request #335 from jprichardson/move-tests</code></li>
<li><a href="https://urls.greenkeeper.io/jprichardson/node-fs-extra/commit/80ec80d394e348a33077042d83a98ccd071878e1"><code>80ec80d</code></a> <code>Merge pull request #334 from jprichardson/move-cleanup</code></li>
</ul>
<p>There are 40 commits in total. See the <a href="https://urls.greenkeeper.io/jprichardson/node-fs-extra/compare/2da7defbd3d3f140f4d2f4cfa7e89b11846a827a...fcfa595ca022011ce0f61d337598a4573fe8eb3c">full diff</a>.</p>
</details>

<details>
<summary>Not sure how things should work exactly?</summary>

There is a collection of [frequently asked questions](https://greenkeeper.io/faq.html) and of course you may always [ask my humans](https://github.com/greenkeeperio/greenkeeper/issues/new).
</details>


---


Your [Greenkeeper](https://greenkeeper.io) Bot :palm_tree:
   Also changes `--vdom -v` to `--vdom -V`. Thanks for working on this!  ## Version **2.0.0** of [md5-hex](https://github.com/sindresorhus/md5-hex) just got published.

<table>
  <tr>
    <th align=left>
      Dependency
    </td>
    <td>
      md5-hex
    </td>
  </tr>
  <tr>
    <th align=left>
      Current Version
    </td>
    <td>
      1.3.0
    </td>
  </tr>
  <tr>
    <th align=left>
      Type
    </td>
    <td>
      devDependency
    </td>
  </tr>
</table>

The version **2.0.0** is **not covered** by your **current version range**.

Without accepting this pull request your project will work just like it did before. There might be a bunch of new features, fixes and perf improvements that the maintainers worked on for you though.

I recommend you look into these changes and try to get onto the latest version of md5-hex.
Given that you have a decent test suite, a passing build is a strong indicator that you can take advantage of these changes by merging the proposed change into your project. Otherwise this branch is a great starting point for you to work on the update.


---


<details>
<summary>Commits</summary>
<p>The new version differs by 2 commits .</p>
<ul>
<li><a href="https://urls.greenkeeper.io/sindresorhus/md5-hex/commit/5d8f3a88b2de9bfdf7e4f07f253dd88c102814df"><code>5d8f3a8</code></a> <code>2.0.0</code></li>
<li><a href="https://urls.greenkeeper.io/sindresorhus/md5-hex/commit/386c34ebe3477dc2eaf6cfd111119fded06c2e22"><code>386c34e</code></a> <code>ES2015ify and require Node.js 4</code></li>
</ul>
<p>See the <a href="https://urls.greenkeeper.io/sindresorhus/md5-hex/compare/273d9c659a29e4cd53512f526282afd5ac1c1413...5d8f3a88b2de9bfdf7e4f07f253dd88c102814df">full diff</a>.</p>
</details>

<details>
<summary>Not sure how things should work exactly?</summary>

There is a collection of [frequently asked questions](https://greenkeeper.io/faq.html) and of course you may always [ask my humans](https://github.com/greenkeeperio/greenkeeper/issues/new).
</details>


---


Your [Greenkeeper](https://greenkeeper.io) Bot :palm_tree:
  ## New Feature

Perhaps related to #125

### Description

Allow the signature `setState(key, value)` to accept an Event object as its value (`e`), causing `setState` to extract `e.target.value`.

### Context

Forcing two-way data binding to be explicit is good in general, but for very basic cases it's a chore. For example, take the following component:

```html
<script>
module.exports = {
  onInput(attrs) {
    this.state = { password: '' }
  },
  setPassword(e) {
    this.state.password = e.target.value
  }
}
</script>

<div class="password-picker">
  <p>Your password is ${state.password.length} characters long</p>
  <input type="password" value=state.password on-input('setPassword') />
</div>
```

For this very basic task, I had to write a `setPassword` handler to capture user input into state. If I had more than input, I would have to either write more handlers, or write a generic handler that differentiates by some kind of key. In any case, it's something I have to write and think about every time I need to handle user input.

However, if `setState` were to accept an event as its value, it would allow me to write the following instead:

```html
<script>
module.exports = {
  onInput(attrs) {
    this.state = { password: '' }
  }
}
</script>

<div class="password-picker">
  <p>Your password is ${state.password.length} characters long</p>
  <input type="password" value=state.password on-input('setState', 'password') />
</div>
```

This avoids the need to write any handler at all, and remains very readable for what it does. For anything that needs something more complicated â€“ such as scrubbing out invalid characters for a phone number input  â€“ it's not hard to fall back to the "write your own handler" way of doing it.

### Open Questions

- Is this too "magical" for marko's taste?
- Would this work for all types of input?

### Is this something you're interested in working on?

Yes
 Just throwing this out there is a possible alternative:

```html
<script>
    module.exports = {
        handleNameChanged(value) {
            this.state.name = value.toUpperCase();

            if (this.state.name.length > 10) {
                this.state.invalidName = true;
            }
        }
    }
</script>

<input value:bind('name')/>
<input value:bind('name', 'handleNameChanged')>

<!-- OR: -->

<input bind('name')/>
<input bind('name', 'handleNameChanged')>
```

In theory, this could be implemented in user land (via a combination of a custom compile-time transform and a small runtime) and if it proves to be valuable then we could pull it into the core marko. Thoughts? For reference:

- React
  - [Forms/Controlled Components](https://facebook.github.io/react/docs/forms.html)
  - [Uncontrolled Components](https://facebook.github.io/react/docs/uncontrolled-components.html)
- Vue
  - [Form input Bindings](https://vuejs.org/v2/guide/forms.html)

 Coming from Mithril.js, I always liked teaching two-way data binding in this manner:

```js
var myData = 'initial'

var myComponent = {
  view: function () {
    return m('input[type=text]', {
      value: myData
      oninput: (e) => { myData = e.currentTarget.value }
    })
  }
}
```

The value in this is it uses plain DOM concepts (`value`, `oninput`, `e`), and the data flow is very clear (on the input DOM event, assign `myData` to the event target's current value).

In other words, there's very little magic to it. So far, Marko has also avoided data-flow magic for the most part, and is thus very close to plain HTML and JS; it's precisely why I was able to pick it up so easily.

HTML-based frameworks (including angular & vue) do not have the benefit of being plain JS, which is why those other frameworks add easy, "proprietary" ways to bind data â€“ they want to take the chore out of it. However, I don't think it's the best approach to take for these reasons:

- **The data flow is not clear.** When you see something like `v-model="x"` or `ng-model="y"`, it's not immediately clear what that's doing or where it's coming from. Contrast that with everything else Marko does, where all data originates from `state` (nice and explicit)

- **It takes away from other core features.** Marko already has `on-click('myMethod')`, a solid data-flow feature connecting JS and the view. It'd be nice if that were the primary way for JS to interact with your view, instead of having an additional syntax that splits common use cases.

I think changing `setState` (via the proposal) or adding a method of some sort (`on-click('set','x')` ?) will strike a good balance between lack of boilerplate and lack of magic.
 Here are some notes from various discussions:

```html
<script>
    module.exports = {
        onInput() {
            this.state.orders = [
                { id: '0', title: 'Foo', shipped: true },
                { id: '1', title: 'Bar', shipped: false },
            ]            
        },

        handleShippedChanged() {
            this.state['orders.${i}.shipped'] = foo;
        }
    }
</script>

<ul>
    <li for(i, order in orders)>
        <input type='checkbox' checked:bind('orders.${i}.shipped', 'handleShippedChanged')> Shipped?
    </li>
</ul>
```

```html
<script>
    module.exports = {
        onInput() {
            this.state.orders = [
                { id: '0', title: 'Foo', shipped: true },
                { id: '1', title: 'Bar', shipped: false },
            ]            
        }
        toggleShipped(i, event, input) {
            // Add support for a settting a property chain while maintaining
            // immutability
            this.setState('orders', i, 'shipped', input.checked);

            // Or, the long way
            var orders = this.state.orders = [].concat(this.state.orders);
            var order = orders[i] = Object.assign({}, orders[i]); // Create a clone of the order
            order.shipped = input.checked;
        }
    }
</script>

<ul>
    <li for(i, order in orders)>
        <input type='checkbox' checked=order.shipped on-change('setState', i)> Shipped?
    </li>
</ul>
``` I'm starting to really like the enhanced `setState` argument. I think ``on-change('setState', `orders.${i}.shipped`)`` is readable, intuitive, and convenient, assuming it does the "immutable update" that we discussed.

Another reason I think it's important to keep the data bind directions separate is to allow for different kinds of data binding without creating more esoteric language constructs. For example, if you have an `<input type="text" value:bind('name') />`, is the (DOM -> JS) data binding on the `oninput` or `onchange` event? Both are valid events; depending on your use case, you may want one over the other. @mindeavor Our thinking was `:bind` would look for _both_ `change` and `input` events.  But you're right, I've often had an `change` event handler on a text input to reformat a phone number **after** input, so it wasn't changing as the user typed.

The issue with  ``on-change('setState', `orders.${i}.shipped`)`` is that in this case, we want the value of `checked`, not `value`.   

We could add a new method: ``on-change('setStateFromState', `orders.${i}.shipped`, `checked`)`` @mlrawlings did you mean `setStateFromEvent`? Ideally `setState` would be smart about events. If I'm not mistaken, `checked` is an anomaly; all other input types store their user input within `elem.value`.

The [non-mutually exclusive] options I see are:

- Upgrade setState's logic to be something like `newValue = e.target.checked || e.target.value` when given an Event object value
- Add a `setStateFromEvent` for the generic case (maybe one would want to set state on a `data-`  attribute instead of input value) Checking in again â€“ that first bullet point would be very handy in small components and demos :)  Thanks for letting us know. New version published with those directories removed: `v4.0.0-rc.1`

The new version also includes https://github.com/marko-js/marko/issues/525  The signature for `onInput` should be `onInput(input, out)`. It is currently `onInput(input)`. /cc @ianvonholt  Closed via https://github.com/marko-js/marko/commit/2c04a4d916fb427e42ee923b3b66509bb26ac4f5

Note: When using [`setProps`](https://github.com/marko-js/marko/blob/master/widgets/Widget.js#L325-L346), `out` is not passed (nor was it passed to `getInitialState` in v3).  @mlrawlings I'm not seeing an issue related to `setProps`. Calling `setProps(newProps)` will cause the component to be rerendered with `newProps` as the input and a new `out` will be created to do the rerender and those things will be passed to `onInput()`. Am I misinterpreting your note?  Related: [#492 - Deprecate w-body in favor of include](https://github.com/marko-js/marko/issues/492) (there is a collapsed "Other Options Considered" section that has relevant details)

#418 is out-of-date after further discussions were made as part of #492. The feedback that we received was that no one really liked the usage of `<include()>` with an empty argument since it didn't make it clear what exactly was being included.  We settled on dropping `w-body`, and dropping the temporarily introduced `body-slot` attribute/tag, in favor of a universal `<include(target)/>` tag. We still need to capture this correctly in the final release notes and documentation, but for now [#492 - Deprecate w-body in favor of include](https://github.com/marko-js/marko/issues/492) contains the latest docs for this feature.

Hope that clarifies. While we want to avoid changes at this point, nothing is set in stone so if you have any thoughts or concerns then please share. I'm closing the issue but please feel free to add more comments here.  We've already deviated from JavaScript (in ways that I make more sense) and we would not want to introduce any breaking changes at this point. FYI, You can do the following if you want both the key/index and value when looping over the elements/properties of an `Array`/`Object`:

```xml
<for(colorIndex,color in ['red', 'green', 'blue'])>
</for>
```

That syntax works with objects too:

```xml
<for(colorName,colorHex in { red: '#f00', green: '#0f0', blue: '#00f' })>
</for>
```

If you still have suggestions/concerns, please let us know and happy to discuss some more, but closing issue for now. Thanks.  ## Bug Report

### Context

```html
<script>
module.exports = {
  onInput(attrs) {
    var content = 'Hello there!'
    this.state = {
      text1: `Text 1: ${content}`,
      text2: 'Text 2: ' + content
    }
  }
}
</script>

<div>
  <h3>${state.text1}</h3>
  <h3>${state.text2}</h3>
</div>
```

### Expected Behavior

```html
<h3>Text 1: Hello there!</h3>
<h3>Text 2: Hello there!</h3>
```

### Actual Behavior

```html
<h3>Text 1: </h3>
<h3>Text 2: Hello there!</h3>
```

### Your Environment

* Version used: v4.0.0-beta.12
 @mindeavor I would expect that to work since Marko shouldn't do anything special with the code inside the `<script>` block. Would you be interested in working on this? I don't think I would have the time to dig into the codebase in the near future, no :( @mindeavor No worries!

I think you are right, @Hesulan. Would you be interested in working on a fix?  Michael and I had a quick discussion and our conclusion was that we should update `htmljs-parser` to ignore Marko placeholders inside template literal strings in `parsed-text` mode.   Thanks!  Thanks for opening the issue. This has been fixed. Please see issue #509. If you upgrade to the latest beta you should be good to go   I think more changes are required. The `handleRootNodes` transform that is being used to do the implicit binding to all root elements is also internally adding the `w-bind` attribute to make everything work: https://github.com/marko-js/marko/blob/6aaf8679a88e53cef644582e51edca94517a51e4/widgets/taglib/TransformHelper/handleRootNodes.js#L202 Looks good. Thank you for working on that!  Thank you, @smulder, for finding these bugs! I'll be publishing a fix soon. New version published with fix: `marko@4.0.0-beta.9`  New version published with fix: `marko@4.0.0-beta.10`  New version published with fix: `marko@4.0.0-beta.11`

Thanks for reporting the problem!  Thanks for the fix! New version published with fix: `marko@4.0.0-beta.10`

Thanks, again, for the PR.  We should definitely consider improving the error message or handling this better, but the reason you are seeing the error is that you should typically never need to render a `<!doctype html>` node in the browser since it is only meant to be something interpreted by the browser when loading an HTML page rendered on the server. Just curious, what is your use case for needing to render an entire page (along with the `<!doctype>` tag) in the browser?

One option is to just not generate any code for the `<!doctype>` node when compiled for the browser. Another option is to show a friendly compiler error. Thoughts? Concerns? Alternative ideas?  Fixed! New version published: `marko@4.0.0-beta.8`    Hey @albertogasparin, it was necessary to deprecate a single hyphen in v3 because we have to remove support for single hyphens in v4 to support the improvement of allowing spaces in attribute values when the attribute value is a complex expression. If you are not able to get rid of the deprecation warning then that is a bug. I am investigating now and will publish a new version of `htmljs-parser` if necessary. I will update soon. Thanks for reporting the problem! Sorry for the bad deprecation warning when using a double hyphen. The problem has been fixed with `htmljs-parser@2.2.2`. I know the deprecation warnings can be a lot of noise, but we didn't see a good way to avoid this change as part of Marko v4. I hope it is not too much of a pain to update your code now, but we do plan on providing a migration tool a little later that would automatically fix the issue, but it is not ready yet.  Introduces colon alias destructuring support for `import`:

```javascript
<import { test: testAlias } from './test' } />
```  I agree that this should be supported. But you can use `as` for aliases:

```javascript
import { client as twilio } from '../../lib/twilio'
``` I wrote up a fix to support colon destructuring as it's supported in standard JS destructuring. I actually didn't know that colon destructuring is not supported in `import` destructuring, which I find quite surprising and inconsistent. I rejected my PR. This issue should be closed. /cc @patrick-steele-idem  We want to strictly follow the ES6 import syntax. Closing this issue. Thanks.  â€¦attrs attribute. Fixed merge conflicts /cc @patrick-steele-idem @mlrawlings   This has been resolved.  The easiest way right now to achieve what you want is to register your own custom tag that is configured to have a body of "static-text". 

For example, you could register your own `<static-text>` tag:

_src/components/static-text/marko-tag.json:_

```json
{
  "body": "static-text"
}
```

```xml
<static-text>
        Content
         More Content
        ${data.myVar}
</static-text>
```

Does that work for you?

Related: https://github.com/marko-js/marko/issues/343 NOTE: If you want to recognize placeholders (i.e. `${...}`) then you should use `parsed-text` instead of `static-text` Which version of `marko` are you using? I'll add a test case @eikaramba Sorry for the delayed response. I added a test case for what I was trying to explain. Please take a look at the following: https://github.com/marko-js/marko/tree/master/test/autotests/render/static-text-tag

The implementation for the `<static-text>` tag can be found in the following directory: https://github.com/marko-js/marko/tree/master/test/autotests/render/static-text-tag/components/static-text

NOTE: The test case was added to Marko v4 (master branch), but it should work the same in Marko v3

Does that clarify and does that solution work for you?  Notes:

- Use [minprops](https://github.com/mlrawlings/minprops) to reduce code size
- Use [envify](https://github.com/hughsk/envify) reduce code size  Fixes #477  Nice. Thank you!  Just some initial thoughts:

- It's already possible to embed a React component in a Marko component but we can definitely provide things to make this more seamless
- I'm definitely open to ideas on improving operability (in addition to the reasons you mentioned, but also because I would like to make it easier for teams to try or transition to Marko)
- If you use React when rendering on the server then you will have no choice but to rerender everything in the browser since React requires this (Marko does not require this)
- Seamless interoperability can become complex when trying to support both server-side and client-side rendering, but I think it is completely doable
- It seems reasonable to create a generic adapter component for embedding a React component in Marko (and vice versa)
- It's possible to translate a rendered Marko VDOM tree to a React VDOM tree with a performance hit (via tree traversal of the Marko VDOM output)
- Alternatively, a Marko component can be rendered and mounted during the `componentDidUpdate()` lifecycle method (client-side only)
- Usage ideas:

_Marko component with embedded React component (using Marko v4):_

```xml
import MyReactComponent from "./MyReactComponent";

<div>
  <react-component(MyReactComponent) name="Frank" age=30/>
</div>
```

React component with embedded Marko component:_

```jsx
import myMarkoComponent from "./my-marko-component";

// ...

return (<div>
  <Marko component={myMarkoComponent} name="Frank" age={30}/>
</div>)
```

I would to hear some more thoughts from others, but I just wanted to share my initial thoughts. Thanks for opening the issue. @mindeavor there have been some conversations about providing an adapter to support registering Marko UI components as Web Component custom elements, but we have not done anything further. After the v4 release we should do more exploration to see what is possible and capture it in our ROADMAP. Right now, the Marko v4 release is our top priority and we hope to get that finalized soon :)  I'm not opposed to this, but it is probably sufficient to add some extra metadata to the compiled template as a JavaScript comment such that it would be minified out in production. In addition, for Marko v4 we introduced support for inspectable metadata that gets added templates compiled for the server.

> (in addition, add `--version | -v` support to `markoc` command)

Can you open up a separate Github issue for that enhancement (this makes tracking progress easier)? Would you be interested in working on either of these enhancements? As we discussed a few days ago @patrick-steele-idem, we should also consider adding a note to the compiled output stating that it is compiled and to not edit it. e.g.

```js
// Compiled using marko@4.0.0-rc.5 - DO NOT EDIT
```

or

```js
// Compiled using markoc@4.0.0-rc.5 - DO NOT EDIT
```  This has been resolved.   Thank you! ðŸ‘   Good catch. Thank you! I'll work on adding a test    Thanks @johnjv!  ```xml
validate-input (input) => {
    var assert = require('assert');
    
    assert(input.label || input.renderBody, '"label" or "renderBody" is required');
}

<button class=['app-button'] onClick("handleClick")>
    <span include(data.label || data.renderBody)/>
</button>
```

For production builds, the `validate-input` tag should have no impact on the compiled template.

We should also consider enabling render-time input validation based `marko-tag.json` for simple validations.  This is an open-ended issue.

While code-coverage is not a perfect metric, it would be awesome to see our coverage reach 90% on this next release.  We use an autotests format for our tests, which make it really easy to add new tests, just copy a directory and modify it for the new test.  If you're interested in adding some tests and have questions, feel free to ask them here.

### Some high-impact places that could use better coverage:
- [ ] [runtime/dom.js](https://coveralls.io/builds/9270231/source?filename=runtime%2Fdom.js)
- [ ] preserved attributes when re-rendering in [widgets/Widget.js](https://coveralls.io/builds/9270231/source?filename=widgets%2FWidget.js#L578)
- [ ] rendering then using dom insertion methods when using the legacy widget api (`require('marko/widgets').defineComponent`) in [widgets/Widget.js](https://coveralls.io/builds/9270231/source?filename=widgets%2FWidget.js#L728)
- [ ] passing an object to `setState` in [widgets/Widget.js](https://coveralls.io/builds/9270231/source?filename=widgets%2FWidget.js#L340)
- [ ] a number of `builder` methods have no, or incomplete coverage in [compiler/Builder.js](https://coveralls.io/builds/9270231/source?filename=compiler%2FBuilder.js).  These tests could go in [test/autotests/codegen](https://github.com/marko-js/marko/tree/master/test/autotests/codegen).
- [ ] parsing a function expression in [compiler/util/parseJavaScript.js](https://coveralls.io/builds/9270231/source?filename=compiler%2Futil%2FparseJavaScript.js#L97)
- [ ] [compiler/taglib-loader/loader-taglib.js](https://coveralls.io/builds/9270231/source?filename=compiler%2Ftaglib-loader%2Floader-taglib.js)
-  [ ] error assertions (in many, _many_ locations)

### How to find other files that could use additional coverage:
- visit https://coveralls.io/github/marko-js/marko?branch=master
- scroll down to "Source Files on Master"
- sort by lines missed

![image](https://cloud.githubusercontent.com/assets/1958812/21169139/6cfff21a-c16e-11e6-864d-b20279e30354.png)  @yomed if you need a temporary workaround:

```js
<${String(data.type === 'primary' ? 'div' : 'span')}> 
``` I have confirmed this is still an issue in v4 as well. Re-opening as the fix needs to be back-ported to v3. `marko@3.13.1` has been published with this fix.  yeah as already stated, this is marko trying to avoid naming collisions. The import parser could use: 
https://github.com/marko-js/marko/blob/master/compiler/util/safeVarName.js
to generate a safe name, but it would still fail for:
```html
<import { asset } from 'asset' />
```
 A quick fix would be to just add a namespace to that function as well, so in the above case it would output:
```javascript
var m__asset = require("asset"),
    asset = m__asset.asset;
```
The namespace could be anything pretty unique, but you could technically still encounter the bug if you know it or miraculously name your var the same. Otherwise, I don't see an obvious solution other than digging into marko's naming collision logic.
@patrick-steele-idem @mlrawlings Thoughts? @tinovyatkin For now, we want Marko templates to compile to ES5-compatible code since compiled templates can either be loaded in the browser or on the server. On the server, the compiler requires Node.js v4+, but the runtime is ES5-compatible and works with IE9+ and all other modern browsers.

As it stands now, `import`/`export` is not finalized and that syntax is not natively supported by Node.js and browsers. We don't want to require the use of Babel for any of the core tags that we document as part of Marko so that means that Marko need to transpile `import`/`export` to something that is widely supported and since we are going to transpile we might as well make the code ES5-compatible for improved compatibility.

Regarding transpiling the following:

```xml
<import { asset } from '../../../shared/marko/asset' />
```

Something similar to the following would work:

```javascript
var asset_module = require("../../../shared/marko/asset"),
var asset = asset_module.asset,
```

A single `_` in the variable name should be sufficient for avoiding collisions since developers typically don't use `_` in variable names. However, we can make the variable as long or as short as we want since it won't matter after the code is minified.

At the moment, I am currently swamped. If anyone wants to work on fixing the compiled code for the `<import>` tag please let me know. Thanks in advance. I _think_ this is as simple appending `_module` or something [here](https://github.com/marko-js/marko/blob/8f4c884fba1d7460690de989d292968c613130cc/taglibs/core/util/parseImport.js#L33).

Along with the change I'd like to see an additional test making sure something like the following produces a sane output:

```html
<import { asset as test } from "./test1/asset"/>
<import { asset } from "./test2/asset"/>
``` > It just occurred to me that `require()` is expected to cache loaded modules:
> ```
> var foo = require('./foo').foo;
> var bar = require('./foo').bar;
> ```
> Not very pretty, but perhaps more readable, and definitely more collision-proof. Thoughts?

Other then still being slightly slower to execute, that code wouldn't minify as well so I would still like to see each module only be required once.  ```html
<custom-component emit('event1', 'event2')/>
```

would be equivalent to:

```html
<custom-component on-event1('emit', 'event1') on-event2('emit', 'event2')/>
```  @SebastiaandenBoer I think your issue is separate. I think you are forgetting to set the `Content-Type` header to ensure that the browser knows how to interpret the response from the server. You should be doing something similar to the following in your page controller:

```javascript
res.set({ 'content-type': 'text/html; charset=utf-8' });
```  Given:

_src/components/my-component/index.marko:_

```xml
<script>
module.exports = {
    handleButtonClick() {
    }
}
</script>

<style lang="less">
.foo {
}
</style>

<div class="foo">
</div>
```

The `<style>` code should be pulled out into `src/components/my-component/index.marko.less` at compile-time. The `lang` attribute should be used to determine the file extension and the default `lang` should be `css`.

The generated file should then be imported in the compiled template so that it will automatically be picked up by the bundler:

```
require('./index.marko.less');

// ...
```
  **Old:**

`./layouts/main/template.marko`:

```html
<!doctype>
<html>
<body>
    <layout-placeholder name="body">
        Default body content
    </layout-placeholder>
</body>
</html>
```

`page.marko`:

```html
<layout-use('./layouts/main/template.marko')>
    <layout-put into="body">
        Hello World
    </layout-put>
</layout-use>
```

**New:**

`./layouts/main/template.marko`:

```html
<!doctype>
<html>
<body>
    <if(data.body)>
        <include(data.body)/>
    </if>
    <else>
        Default body content
    </else>
</body>
</html>
```

`page.marko`:

```html
<include('./layouts/main/template.marko')>
    <@body>
        Hello World
    </@body>
</include>
```  <!--- Provide a general summary of your changes in the Title above -->

## Description
<!--- Describe your changes in detail -->
Deprecate `renderSync(data)` and `render(data, callback)` in their current forms.  Use `renderToString` instead as v4 will return a `RenderResult` instead of a string.


## Motivation and Context
With this notice in place, there shouldn't be any breaking changes when moving from v3 to v4 that don't already warn you in the current version.


## Checklist:
<!--- Go over all the following points, and put an `x` in all the boxes that apply. -->
<!--- If you're unsure about any of these, don't hesitate to ask. We're here to help! -->
- [x] My code follows the code style of this project.
- [x] I have updated/added documentation affected by my changes.
- [x] I have read the **CONTRIBUTING** document.
- [x] No new tests, changes already covered by existing tests.
- [x] All new and existing tests passed.

  ## Description

adds import tag, works like: 
```html
<import mod, { b as bar } from "./bar" />
```

## Motivation and Context
Fixes https://github.com/marko-js/marko/issues/404

## Checklist:
- [x] My code follows the code style of this project.
- [x] I have updated/added documentation affected by my changes.
- [x] I have read the **CONTRIBUTING** document.
- [x] I have added tests to cover my changes.
- [x] All new and existing tests passed.
 Thanks for working on this @scttdavs!  I did a fairly quick code review and one issue I see is that we want to avoid parenthesis when using the `<import>` tag so that the user can write out the import in the ES6 way. Currently, it appears you are parsing the import statement from within the argument on the `<import>` tag:

```xml
<import({bar as b} from './bar') />
```

I would like to only support the following:

```xml
<import {bar as b} from './bar' />
```

The only code change that should be required is that you will need to loop over the attributes and join the attribute names by a space (e.g., `attributeNames.join(' ')`) to build the import string that is then parsed. For example, here is the AST after parsing `<import {bar as b} from './bar' />`:

```json
{
    "type": "TemplateRoot",
    "body": [
        {
            "type": "HtmlElement",
            "tagName": "import",
            "attributes": [
                {
                    "type": "HtmlAttribute",
                    "name": "{bar as b}"
                },
                {
                    "type": "HtmlAttribute",
                    "name": "from"
                },
                {
                    "type": "HtmlAttribute",
                    "name": "'./bar'"
                }
            ],
            "body": []
        }
    ]
}
``` 

Do you have any concerns about dropping the parens?

Also, I wouldn't bother mentioning `<script marko-init>` in the docs since that is deprecated.
 On a related note, we might have issues when we update the parser to handle commas so we probably need to provide a helper to get the raw string inside the open tag. Sure that looks like a simple change. I'll have time tonight to work on it
some more
On Sun, Nov 27, 2016 at 10:46 AM Patrick Steele-Idem <
notifications@github.com> wrote:

> On a related note, we might have issues when we update the parser to
> handle commas so we probably need to provide a helper to get the raw string
> inside the open tag.
>
> â€”
> You are receiving this because you were mentioned.
> Reply to this email directly, view it on GitHub
> <https://github.com/marko-js/marko/pull/448#issuecomment-263129223>, or mute
> the thread
> <https://github.com/notifications/unsubscribe-auth/ADdocOk7n8rV_MlkhTxiTmDSWHACIHDlks5rCaXLgaJpZM4K9JxM>
> .
>
 @patrick-steele-idem What do you think of the above implementation in the last commit? Instead of joining the attribute names for now (sounds like comma parsing will conflict with that later), I add the tag string to the node, so `el.tagString ` returns `"<import foo from './foo' />"`, and we get all we need from that. Is there a better way of doing this? Still feeling my around :) `tagString` would have the problem that it would be different for concise vs non-concise unless we always stripped off the the starting `<` and the ending `/>` or `>`. If we strip off those characters then I am okay with using `tagString`. @patrick-steele-idem any more comments, or is this ready to merge? It's ready to merge :) I am just finishing up the changes to support nested `<@foo>` tags and I will merge your changes very soon. We will then publish a new beta release. Thank you, again! great, thx! Also made one slight more optimization, couldn't help myself ðŸ¤“   Thanks! ðŸ‘   Thank you for bringing this up. I think it makes sense to normalize the HTML string before doing the comparison to avoid issues related to having/not-having a new line character at the end:

```javascript
str = str.replace(/\s$/, '')
```

Or, possibly a little more conservative:

```javascript
str = str.replace(/(\r\n|\n)$/, '')
```

Thoughts? Agreed. Would you be interested in making this change to normalize the string before comparison?  Thanks for the PR @JeroenVdb, but I think it it is better to discuss how nested content is handled within the [Includes](https://github.com/marko-js/marko/blob/master/docs/language-guide.md#includes) section of the docs. I want to avoid adding a new section to the docs so I am closing this PR. Thank you though!  Thanks! ðŸ‘   ## Description

Making the render api consistent.

### Sync Render
Rendering synchronously now returns a RenderResult:
```js
var result = template.renderSync({});
result.appendTo(document.body);
result.getWidgets();
// etc.
```

**Differences:**
In v3, we return a string.  In order to make this a more painless switch, I will introduce a `renderToString` method in v3 and prompt users to switch to using that if they need that string output.

### Async Render

Calling `.render()` still returns an out:
```js
var out = template.render({});
out.on('finished', function(out) {
    
});
```

**Differences:**
In v3, there is no value passed to the `finished` event.  No breaking change here.


### Callback 

```js
template.render({}, function(err, result, out) {

});
```

**Differences:**
In v3, the callback is passed the `html` string instead of a RenderResult.  The third parameter, `out` is only passed for legacy reasons.  You can also access it from `result.out`.

### Promise

See also #439, #442.

```js
template.render({}).then(result => result.appendTo(document.body));
```

**Differences:**
In v3, then was not available.  No breaking change here.

### Widgets

`defineRenderer` and `makeRenderable`/`renderable` now include both `render` and `renderSync` that function similarly to above.  I plan to add `renderSync` to `marko-widgets@6` and warn users that are using the api like:

```js
widget.render({}).appendTo(document.body);
```

to switch to 

```js
widget.renderSync({}).appendTo(document.body);
```
or
```js
widget.render({}, function(err, result) {
    result.appendTo(document.body);
});
```

## Checklist:
- [x] My code follows the code style of this project.
- [ ] I have updated/added documentation affected by my changes.
- [x] I have read the **CONTRIBUTING** document.
- [ ] I have added tests to cover my changes.
- [x] All new and existing tests passed.


@patrick-steele-idem I'd like some eyes on this and the plan described above before merging.
@Hesulan How does the Promise implementation look?
  Hmm... I see the issue...  Unfortunately, our goal with #389 was to pass the stream as the value so you could do something like:
```js
template.render().then(out => out.appendTo(document.body));
``` @patrick-steele-idem Maybe we need to consider having a `RenderResult` that is separate from the stream.

```js
var result = template.renderSync();
var out = template.render();

out.on('finish', function(result) {});
out.then(function(result) {});

template.render({}, function(err, result) {});
```

Pretty much everything in the `outMixins` except `then`/`catch` would be a method of the `RenderResult`.


`result.out` could point to the original stream if necessary. > Maybe we need to consider having a `RenderResult` that is separate from the stream.

That's probably the right thing to do.

What are your thoughts on adding a `try...catch` to wrap the rendering of the template so that we can emit an `error` event in the `catch` clause? We would only do this if an `out` is not provided to the `template.render()` method.  Add support for an `extends` property to `marko.json`:
```js
{
    "<foo>": {
        "transformer":"./foo.transformer.js"
    },
    "extends": [ 
        "bar", // extend a node_module (gets marko.json from the root of the package)
        "./other/marko.json" // extend another marko.json file
    ]
}
```

This would allow a package to "export" tags from packages it depends on.

Open to other names: `includes`, `imports`, etc. The use case I'm thinking of is allowing one package to make the tags of another package available without the main application needing to depend directly on both.  

As an example, take your `let` and `const` package.  Maybe I want to create an `es6-taglib` package that would expose those tags as well as some others.
 In theory this sounds good, but it becomes a problem if the other `marko.json` being extended belongs to a nested package dependency and not a `peerDependency`. Nested dependencies may get installed into a `node_modules/` directory of the package with the parent `marko.json` which can cause problems since the `marko` compiler needs to generate `require()` calls to those nested dependencies. If a tag is purely a compile-time tag then it is not an issue, but it would be a problem for runtime custom tags that need to be imported into compiled templates.

I'm not sure there is a strong enough need for this at the moment, but we can discuss some more. Looks like [`taglibImports`](https://github.com/marko-js/marko/blob/master/compiler/taglib-loader/loader-taglib.js#L200-L248) with a small tweak will already do this.  Here are some replies:

> The promise resolution procedure must only access the `.then` property once.

Why do you say that?

> If attempting to retrieve the `.then` property throws an error, then the error must be caught and the resulting promise must be rejected with the error as the reason. (It currently isn't being caught.)

I don't see a need for this since accessing the `.then` property should throw an error if it is a `Promise`.

> The `.catch(onRejected)` method is neither defined nor required by the specification

`catch` is part of the specification: http://www.ecma-international.org/ecma-262/6.0/#sec-promise.prototype.catch

While we could fall back to `.then(null, onRejected)` in the case of no `.catch()`/`.fail()` method, but I'm not seeing a need for that.

> Should Marko actually be trying to handle Promise resolution directly, or would it be better to rely on a native/polyfilled `Promise` implementation?

Marko should rely exclusively on the native `Promise` implementation and that is what is happening now on `master`. 

> The `<await>` tag, however, needs to be usable in pre-ES5 environments, which leaves either a built-in polyfill or just more compliant handling code as the only options.

In the case of the `<await>` tag, Marko is never actually creating a `Promise` (it is just continuing the `Promise` chain of an existing `Promise`). In an ES5 environment you would need to use a native `Promise` polyfill or use a third-party library (`bluebird`, `q, etc.) to create the `Promise` instance.

> However, I've also noticed one other issue: The `<await>` tag currently accepts either a value, a Promise, or a node-style function (last argument is an error-first callback).

The `<await>` tag accepts a `Promise`, a Node.js-style callback function or a "resolved" object. I'm not seeing a problem with this approach.

---

Marko has some logic to handle old-style `Promise` objects, but for the most part we are assuming that a `ES6`-style `Promise` is being provided: file:///Users/psteeleidem/Library/Application%20Support/Dash/DocSets/JavaScript/JavaScript.docset/Contents/Resources/Documents/developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_objects/Promise.html

I'm not seeing a need to change anything related to the comments above. We still need to decide if we want to wrap the `render(data)` call with a `try...catch` to reject the promise. Currently, we don't have a single `try...catch` block in `marko` for performance reasons (functions with `try...catch` are not optimized by V8) @Hesulan these are great points, but I think we should focus on the `Promise` specification as defined as part of EcmaScript and implemented by Node.js and browsers (and polyfills). I would welcome as many tests as possible to make sure the Marko implementation holds up to all edge cases for the native `Promise` implementation, a popular `Promise` polyfill and maybe `q` and `bluebird`. For example, we need to make sure we have a test case for a synchronous error when rendering a template and using `.then()`/`.catch()`. Does that seem reasonable?  @cheft, Marko v4 will be IE9+, so I would plan for that, but I believe we're currently IE8+ on v3.

I'm going to close this, but feel free to ask if you have more questions.
  When an error occurs within an `<await>` tag, the rest of the page continues rendering and we log a n error message to the console, but there is no indication in the browser that an error occurred.  When using something like `browser-refresh`, developers aren't constantly having to look at the console, so it might be nice to give a big red error indication in `NODE_ENV=development` mode. I agree. The default implementation should show inline error messages for `<await>` tags that fail in development. If the user provided an `<await-error>` then that should always be used.

On a somewhat related note, we probably want to start making use of `process..env.NODE_ENV` to show more friendly error messages in development mode without bloating runtime code for production. We should then update lasso to transform `process.env.FOO` references to include the actual value of the environment variable when doing a non-development build. This would allow code to be minified out. While we could use [envify](https://github.com/hughsk/envify) as a module transform, we would also want to run that transform on non-JavaScript modules (i.e. vanilla JS) as part of an output transform.  The point of the layout taglib is to be able to include another template (`<layout-use>`) and insert content (`<layout-put>`) at various insertion points (`<layout-placeholder>`).  I'd like to make this more generic and concise.

@patrick-steele-idem has already done work on making `<include>` work to replace `w-body` (#418) and I think we can take this one step further to replace the need for layout-specific tags.

**Old:**
`./layouts/main/template.marko`:
```html
<!doctype>
<html>
<body>
    <layout-placeholder name="body"/>
</body>
</html>
```
`page.marko`:
```html
<layout-use('./layouts/main/template.marko')>
    <layout-put into="body">
        Hello World
    </layout-put>
</layout-use>
```

**New:**
`./layouts/main/template.marko`:
```html
<!doctype>
<html>
<body>
    <include(data.body)/>
</body>
</html>
```
`page.marko`:
```html
<include('./layouts/main/template.marko')>
    <@body>
        Hello World
    </body>
</include>
```

### `@` tags

As seen above, I'm also proposing the ability to prefix a tag with the `@` symbol to indicate that it should be passed as an attribute. I chose `@` because we already use it to indicate attributes in `marko.json` and it looks nice.

These are like [nested tags](http://markojs.com/docs/marko/custom-taglibs/#nested-tags) but more concise and don't require defining attributes in `marko-tag.json`.

Only putting the `@` at the front will require a change to the parser to support, but I think it would be worthwhile:
```html
<@body>
    Hello World
</body>
```
vs
```html
<@body>
    Hello World
</@body>
```

These `@` tags would work for *any* tag, so we could use layout concepts easily for custom tags as well:

**New:**
`./components/layout/index.marko`:
```html
<!doctype>
<html>
<body>
    <include(data.body)/>
</body>
</html>
```
`page.marko`:
```html
<layout>
    <@body>
        Hello World
    </body>
</layout>
```

### Passing values to `@` tags?

Perhaps we could also allow passing an argument to the `@` tag, indicating the name of a data variable:

```html
<my-component>
    <@body(foo)>
        Hello ${foo}!
    </body>
</my-component>
```

would compile to:
```
my-component({
    body: function(foo, out) {
        out.w('Hello '+escapeXML(foo)+'!');
    }
});
```
and could be called within `my-component` like this:
```html
<include(data.body, 'World')/>
```

 Thoughts?
/cc @philidem @austinkelleher @charlieduong94 @Hesulan 
 The other question this raises is should we deprecate [nested tags](http://markojs.com/docs/marko/custom-taglibs/#nested-tags) in favor of `@` tags?

**Old:**

``` html
<await(foo from data.fooPromise)>
    <await:error>
        Something bad happened
    </await:error>
    ${foo}
</await>
```

**New:**

``` html
<await(foo from data.fooPromise)>
    <@error>
        Something bad happened
    </error>
    ${foo}
</await>
```
 I just realized that `<await:error>` isn't a thing.  It's `<await-error>` which gets transformed into an attribute at transform time... haha ðŸ˜ .  But I'm thinking we could still use `<@error>` in this case.

@Hesulan My thinking on the `<@tags>` is that they would need to be the immediate children of the target parent, so there wouldn't be any ambiguity.  
 I suppose another question is how to handle multiple instances of a tag.  Currently, with nested tags, you define in the `marko-tag.json` whether a nested tag can have multiple instances.  If it can, it's always passed as an array.  

Without defining that upfront I think we're left with passing it as a single value if there's only one `<@tag>` and as an array if there are multiple.  React does this with its children prop and I don't really like it.  They ended up providing a collection of [helpers](https://facebook.github.io/react/docs/react-api.html#react.children) because it's hard to work with.

You _could_ do something like the following to ensure a value is an array before looping over it:

``` html
<var tabs=[].concat(data.tab)/>
<ul>
    <li for(tab in tabs)>${tab.name}</li>
</ul>
<div class="tab-content" for(tab in tabs)>
    <include(tab)/>
</div>
```

Or maybe you **have** to define an entry for nested tags if you want multiple: `"@tabs <tab>[]"`.  Otherwise the compiler throws an error.
 I like this suggestion and here are some thoughts:

-----

I think it should be `<@foo>...</@foo>` (with the `@` repeated in the ending tag)

-----

Attributes should be allowed on `<@>` tags:

```xml
<@placeholder tag="div">Loading...</@placeholder>
```

-----

`<@bar>` should be shorthand for `<foo:bar>`. The only challenge is that the `<@bar>` would just need to be matched with the first ancestor custom tag:

The following are equivalent:

__Old:__

```xml
<app-tabs>
    <app-tabs:tab title="Home">Content for Home</app-tabs:tab>
    <app-tabs:tab title="Profile">Content for Profile</app-tabs:tab>
    <app-tabs:tab title="Messages">Content for Messages</app-tabs:tab>
</app-tabs>
```

__New:__

```xml
<app-tabs>
    <@tab title="Home">Content for Home</@tab>
    <@tab title="Profile">Content for Profile</@tab>
    <@tab title="Messages">Content for Messages</@tab>
</app-tabs>
```

-----

Nested tags currently compile down to an object with each attribute resulting in a property and a `renderBody(out)` function if the nested tag has body content. The nested tags get discovered at render time by rendering the body and the nested tags register themselves with the parent tag when they get rendered but they otherwise produce no output at that time. This allows nested tags to be repeated, have conditional logic, etc.:

```
<app-tabs>
    <for(person in family)>
        <@tab title=person.name>
            Hello ${person.name}! You are ${person.age} year(s) old.
        </@tab>
    </for>
</app-tabs>
```

However, we can optimize this by handling nested tags that are direct children of a parent tag:

```xml
<app-hello name="Frank">
  <@message>Have a good day!</@message>
</app-hello>
```

__Old compiled output:__

```javascript
app_hello_tag({
      name: "Frank"
  }, out, 0, function renderBody(out, app_hello_tag0) {
    app_hello_message_tag({
        renderBody: function renderBody(out) {
          out.w("Have a good day!");
        }
    }, out, app_hello_tag0);
  });
```

__New compiled output:__

```javascript
app_hello_tag({
        name: "Frank",
        message: {
            renderBody: function renderBody(out) {
                out.w("Have a good day!");
            }
        }
    }, out);
```

We could even optimize for a single `if()` condition surrounding the nested tag:

```xml
<app-hello name="Frank">
  <@message if(someCondition)>Have a good day!</@message>
</app-hello>
```

```javascript
app_hello_tag({
        name: "Frank",
        message: someCondition && {
            renderBody: function renderBody(out) {
                out.w("Have a good day!");
            }
        }
    }, out);
```

-----

__tldr; Introduce`<@tab>` as shorthand for `<tabs:tab>`__  I think a test for this should live in `test/autotests/api`. An example is: `test/autotests/api/require-render-to-stream`.
 Also, the API has changed in v4, and I don't think this is an issue anymore, but I think this change should be back ported to v3.
 I saw it's against the v3 branch. Nice. LGTM /cc @mlrawlings 
 Actually I have a small suggestion after reviewing the code in v4. What do you think about changing the implementation to be more uniform with the v4 implementation?

https://github.com/marko-js/marko/blob/master/runtime/stream.js#L40
 I like it.  Thanks @jsumners and @austinkelleher!
 @jsumners Just published `marko@3.12.1`
  ## Description
Deprecate w-on* attributes for handling widget events. Added support for registering event handlers with on*().

## Motivation and Context
This is part of the Marko v4 roadmap.

## Checklist:
<!--- Go over all the following points, and put an `x` in all the boxes that apply. -->
<!--- If you're unsure about any of these, don't hesitate to ask. We're here to help! -->
- [x] My code follows the code style of this project.
- [x] I have updated/added documentation affected by my changes.
- [x] I have read the **CONTRIBUTING** document.
- [x] I have added tests to cover my changes.
- [x] All new and existing tests passed. Thanks!
   I'm not sure what's up with Coveralls. It's running twice.
    Here are my thoughts:

Marko should not be in the business of transpiling JavaScript. If a developer wants to use ES6 functionality, then the code should pass through unmodified. On the server, you wouldn't want to transpile the code since later versions of Node.js have great ES6 support.

There is one exception and that is ES6-style imports:

``` xml
//html syntax:
<import foo from "./foo"/>

// concise syntax:
import foo from "./foo"
```

ES6-style imports are not currently enabled by default in any browser and are not supported in Node.js. However, we like the syntax and semantics of ES6-style imports so we want to support it.

Specifically related to the `let` and `const` tags, I want those to pass through as-is as there ES6 keywords. No transpiling is required on the server and no transpiling is required for modern browsers. If the user wants to support older browsers then they would need to enable babel to run on `.marko.js` files to produce ES5-compatible code.

Could integrate babel? Maybe, but I don't think we should since the JS module bundler will typically be doing transpiling anyway.
    Thank you @Hesulan! For completeness, I think it is great that you worked on this. The tests are failing because we have some tests for the "taglib lookup" that will fail if you add new core tags. You simply need to update the following two files to include your new core tags (i.e. `const` and `let`):
- https://github.com/marko-js/marko/blob/master/test/autotests/taglib-lookup/forEachTag/expected.json
- https://github.com/marko-js/marko/blob/master/test/autotests/taglib-lookup/getTagsSorted/expected.json

(you just need to copy the text from `actual.json` over to `expected.json`)

Please do add tests when you get a chance. Copying and modifying the following test is sufficient for now: https://github.com/marko-js/marko/tree/master/test/autotests/render/var
 I don't really like the idea that `var`, `let`, and `const` are treated the same by the compiler. I think if we introduce these new tags, they need to function differently. For example this is okay with `var`:

``` html
<!-- This is okay! -->
<var nameUpper=data.greetingName.toUpperCase() nameLower=data.greetingName.toLowerCase()>
    Hello ${nameUpper}!
    Hello ${nameLower}!
    <var nameUpper=data.greetingName.toLowerCase()  nameLower=data.greetingName.toUpperCase()>
        Hello ${nameUpper}!
        Hello ${nameLower}!
    </var>
</var>
```

But it should throw a compile time error using `let`:

``` html
<let nameUpper=data.greetingName.toUpperCase() nameLower=data.greetingName.toLowerCase()>
    Hello ${nameUpper}!
    Hello ${nameLower}!
    <!-- Compiler throws an error! -->
    <let nameUpper=data.greetingName.toLowerCase()  nameLower=data.greetingName.toUpperCase()>
        Hello ${nameUpper}!
        Hello ${nameLower}!
    </let>
</let>
```

`const` should also be treated like like a `const` in JavaScript, so if we declare `<const>` and try to use the `<assign>` tag below it, the compiler would throw an error:

``` html
<const nameUpper=data.greetingName.toUpperCase() nameLower=data.greetingName.toLowerCase()>
    Hello ${nameUpper}!
    Hello ${nameLower}!
    <!-- Compiler throws an error! -->
    <assign nameUpper=data.greetingName.toLowerCase()/>
</const>
```

What do you think @patrick-steele-idem / @mlrawlings / @philidem ?
 @austinkelleher, `let` and `const` would compile to code that uses `let` and `const`. 

Also, just wanted to point out that `let` is beneficial in the following contrived situation:

```
<let foo='Frank'/>

<if(someCondition)>
    <let foo=123/>
    <!-- do something with foo -->
</if>
<else>
    <let foo=456/>
    <!-- do something with foo -->
</else>

<div>
  Hello ${foo}! <!-- Outputs "Hello Frank!" -->
</div>
```

Within the body of custom tags, `var` happens to be scoped correctly since marko automatically wraps the body of custom tags in a `renderBody(out)` function.
 @mlrawlings Can you please review this PR and decide on next steps? Thanks.
 I'm torn on what to do here.  These are language level features, so I don't think they belong in an external package.  If we're going to support this, I don't want to handle transpiling.  I'd either be in favor of letting it pass through unchanged (node 6+), or if we want to support 4/5 prepend `'use strict';` to the template.

On the other hand, I'm not sure we really need them.  The only real benefits are they introduce a temporal dead zone and `const` can't be redefined.

And taking Patricks example from above, we already have a way to create a TDZ of sorts:

``` html
<var foo='Frank'/>

<if(data.someCondition)>
    <var foo=123>
        <!-- do something with foo -->
    </var>
</if>
<else>
    <var foo=456>
        <!-- do something with foo -->
    </var>
</else>

<div>
  Hello ${data.foo}! <!-- Outputs "Hello Frank!" -->
</div>
```

The `es6-taglib` taglib idea is interesting, but I don't think it's necessary.  We will always be able to write something that is es5 compatible for core taglibs.  It's only these places where we're trying to emulate the javascript language.

Also, userland tags might require es6, and we don't have control over that, but also I'm not sure we want to introduce something at the core that when used in userland modules forces the application using them to transpile or drop support for older platforms.
 @Hesulan I think that makes sense.  `marko-layout` and `marko-async` started out as separate packages that eventually were merged into core.  The same could happen here.  I'm going to go ahead and close this issue, but do publish that package so we can play with it.  And maybe we can reopen this in the future.
  ## Description
Added the "ref" and "for-ref" attributes, which replace the now deprecated "w-id" and "w-for" attributes. 

Added warnings to discourage the usage of "w-id" and "w-for".

## Motivation and Context
This change is for the upcoming marko v4 release (see ROADMAP.md).

## Checklist:
<!--- Go over all the following points, and put an `x` in all the boxes that apply. -->
<!--- If you're unsure about any of these, don't hesitate to ask. We're here to help! -->
- [x ] My code follows the code style of this project.
- [ x] I have updated/added documentation affected by my changes.
- [ x] I have read the **CONTRIBUTING** document.
- [ x] I have added tests to cover my changes.
- [ x] All new and existing tests passed.
 Thanks for the PR @charlieduong94 ! Your changes look great. I did make a small change to include the location information for a deprecation warning. For example:

```
The "w-id" attribute is deprecated. Please use "ref" instead. (test/autotests/widgets-browser-deprecated/widget-render-to-iframe/components/app-iframe-content/template.marko:3:4)
```

If you are interested in any other issues, please let us know. Thanks again!
  Currently, `htmljs-parser` switches into HTML parsing mode when the first character of a concise line is `$`. This was a deliberate decision at the time, but it results in unwanted differences between the HTML and concise syntax. Currently, in order to have a dynamic tag name, the HTML syntax must be used. We want to fix that.

Given the following template:

```
${isInline ? 'span' : 'div'} - Hello World
```

Given a value of `true` for `isInline`.

Old output:

```html
span - Hello World
```

Expected new output:

```html
<span>Hello World</span>
```

 TODO: Output warning in old parser used by Marko v3. Something similar to:

```
WARNING!!
The behavior of `${` at the start of a line in concise parsing mode will
be changing in Marko v4. To avoid problems in the future, you should
make the following change right away:

OLD: ${foo}
NEW: - ${foo}

See: https://github.com/marko-js/marko/issues/425
```  This change allows whitespace in complex expressions such as the following:

``` xml
<assign name=lastName.toUpperCase() + ', ' + firstName.toLowerCase()/>
```

See related PR for `htmljs-parser`: [htmljs-parser PR #37](https://github.com/philidem/htmljs-parser/pull/37) Only handling this for the `var` and `assign` tag is a reasonable suggestion. I think I might be okay with that. What do you think @mlrawlings ?
 The parser does support entering into new parsing modes based on the tag name so that is certainly an option. It's also possible that the `var` could handle making sense of the separate attributes (divided by spaces) and group things back together, but that might get messy.
 @Hesulan It's certainly safer to make this apply to only `var`/`assign` because there is no possibility that an operator in a variable name is valid.  However, I'm concerned that there may be confusion if I can do `<var sum = 1 + 2 />` but not `<counter start = x + 1 />`.  

@philidem also suggested that if we were to do this it should be across the board at the parser level.

### Reasoning

I certainly understand that this can impact readability:

``` html
<custom-tag count = 1 + 2 + 3 class = foo style = styles.foo />
```

vs.

``` html
<custom-tag count=1+2+3 class=foo style=styles.foo />
```

However, I see the main reason for this is to be able to write code in `.marko` that looks like js:

``` js
import { calc } from './helpers'

var sum = data.value + 5
var calculated = calc(data.value, 2)

<div>${calculated}</div>
```

### Another possibility

I don't know if this is a good idea, but I'll throw it out there:

What if we required comma separation when using whitespace around `=`:

``` html
<custom-tag count = 1 + 2 + 3, class = foo, style = styles.foo />
```

Which actually lines up with JS pretty well:

``` js
var count = 1 + 2 + 3, x = foo
```

@patrick-steele-idem and I had also talked about allowing a semicolon at the end of a concise tag:

``` js
var count = 1 + 2 + 3, x = foo;
```
 Using comma separation is an interesting idea, I do like the fact that it aligns with JS. The down side is that it may cause confusion if it's only required when using whitespace.
 Good discussion. After giving it some thought, I think the comma solution is the best option and it should be allowed for all tags (not just `var`/`assign`). The parser should be updated such that, when encountering a comma, would combine everything after an attribute `=` and before the `,` together to allow the following to work as expected:

``` xml
<custom-tag count = 1 + 2 + 3, class = foo, style = styles.foo />
```

I think that provides a good balance to being like HTML (space-separated attributes), while also being like JavaScript.

Are we okay with the comma being used sometimes, but not all times for the same tag?:

``` xml
<!-- commas sometimes: -->
<custom-tag count = 1 + 2 + 3, class = foo style = styles.foo />
```

The only possible edge case is that the comma was supposed to be part of the expression, but I can't think of any reason that would ever be the case.

Similarly, I am still in favor of allowing a `semicolon` to end a tag such that the following would be allowed:

``` xml
<var foo=123, bar=456;/>
var baz=456;
```

Thoughts?
 As a side note, a comma would allow the following in concise mode:

```
var foo=123,
    bar=456
```

The comma at the end of the line would make it clear that additional attributes are expected and the parser would say in the tag parsing mode even if the EOL is reached.
 @patrick-steele-idem What about if the last (or only) attribute has spaces?

``` xml
<custom-tag count = 1 + 2 + 3 />
```

In concise mode, if we allow a semicolon as an indicator that this is the last space separated value, that could work:

``` js
var foo,
    count = 1 + 2 + 3;
```

What if the comma/semicolon syntax was specific to concise mode?  We're trying to make things look more like JS, but there's nothing wrong with wrapping the value in parenthesis:

``` xml
<custom-tag count = (1 + 2 + 3) />
```
 Patrick and I were just discussing this and realized that there could be some other issues:

### Text content on same line

Content on the same line would be an issue:

``` js
tag baz = 3 - Hello, World;
```

_Is that `<tag baz=3>Hello, World;</tag>` or `<tag baz=(3 - Hello) World />`?_

### Multi-line values

Attribute value split across multiple lines:

``` js
var foo = doSomething()
    .chain1
    .chain2
```

_Are `.chain1` and `.chain2` property accessors, or shorthand divs with classes?_

I suppose in this case it would be easy enough to say that multiline values **_must**_ be wrapped in parenthesis. 
 **Here's my proposal:**

- When parsing _attribute value_, encountering whitespace followed by a character that is not a binary operator character (except for `-` in concise mode and `>` in HTML mode) will keep the parser in the _attribute value_ mode.
- When parsing _attribute value_ in _concise mode_, encountering `-` will switch to single line HTML mode (this is the current behavior)
- When parsing _attribute value_ in _HTML mode_, encountering `>` will end the current tag (this is the current behavior)
- When parsing _attribute name_ or _attribute value_, encountering a `,` (comma) will be treated as an attribute delimiter. All whitespace (including newline character) will be ignored after the comma is encountered until the next non-whitespace character is encountered. A mix of commas and whitespace can be used as delimiters within the same tag.
- When parsing _attribute name_ or _attribute value_, A `;` (semicolon) will always be treated as an attribute delimiter and will not be part of the attribute name or value. Unlike the comma, a semicolon cannot be used to wrap attributes across multiple lines. (I think we still need to discuss this more) I just made a PR implementing this and some related parser updates. I'd love some feedback from everyone that has contributed to this discussion. https://github.com/philidem/htmljs-parser/pull/42

 Fixed with upgrade to `htmljs-parser@^2`   If `out.error()` is called the `finish` event is still emitted. That would result in both `reject` and `resolve` being called. I'm not sure what the `Promise` spec says should happen when that occurs, but we should probably add code to make sure that `resolve` is not called when `reject` is called. Do you mind investigating that?
  `w-bind` â†’ `widget` or `component`

See also #393 #395 #399 

__Update:__ we decided to remove `w-bind` and alternatives completely. If you want to bind a widget to the DOM nodes you need to name the file `widget.js`, `component.js` or embed an inline `<script>` tag in the template with a `module.exports`/`export default`. @Hesulan We decided to not allow that anymore @Hesulan The problem with `<widget-types/>` was that all possible widgets ended up being bundled up by the JavaScript module bundler. The better alternative is to have a single widget that can delegate out to a particular widget implementation or to conditionally remap the JavaScript widget module to the correct module at bundling time. Lasso supports conditional remaps (see `requireRemap` in https://github.com/lasso-js/lasso#nodejs-style-module-support). There are better workarounds and deprecating `w-bind`/`<widget-types>` simplifies Marko and simplifies documentation. I hope that clarifies.    Thanks for opening the issue @cdhowie. You are right that it is missing from the language guide. We did document this feature in the "What's New in Marko v3", but we did not move over those docs into the language guide: http://markojs.com/docs/marko/what-is-new-marko-v3/#tag-body-content-parsing

On a related note, marko uses [htmljs-parser](https://github.com/philidem/htmljs-parser) and that parser automatically switches into `parsed-text` mode when parsing both `<script>` and `<style>` tags (see: [philidem/htmljs-parser/Parser.js](https://github.com/philidem/htmljs-parser/blob/4a1b907092a512bc1f2e22f52a24ea9cf1dfc3ff/Parser.js#L2520-L2521[). This means that the parser won't recognize HTML tags inside `<script>` and `<style>` tags since those tags do not contain HTML. Therefore, you should very rarely need to know about the `marko-body` attribute. You should only need to know about `marko-body` text if maybe you are creating a custom tag that allows non-HTML content to be nested. When creating a custom tag you can specify the `body` parse mode as shown below:

_src/components/my-script-wrapper/marko-tag.json:_

``` json
{
    "body": "static-text",
    "preserve-whitespace": true
}
```

Hope that helps! 

I'm keeping the issue open so that we update the docs. We are currently extremely busy with all the work associated with the upcoming [Marko v4](https://github.com/marko-js/marko/milestone/2) release so if you would be interested in fixing the docs, please feel free to submit a PR to the following docs file: https://github.com/marko-js/marko/blob/master/docs/language-guide.md
 To be honest, I could probably be swayed towards making the default `static-text` (instead of `parsed-text`) for `<script>` and `<style>` tags in Marko v4. Allowing expressions in `<script>` blocks was kept around because a lot of earlier developer were doing something similar to the following:

``` html
<script>
window.foo = ${JSON.stringify(bar)};
</script>
```

On a related note, marko has special escaping rules for expressions inside the `<script>` tag to make sure `</script>` does not get rendered inside a string.

[Marko v4 will integrate Marko Widgets](https://github.com/marko-js/marko/blob/master/ROADMAP.md) and make it much easier to serialize extra data/state down to the browser that then gets passed to the widget constructor.

> Anyway, documenting marko-body would've at least made it easier to correct the problem when we figured out what it was.

Agreed. Keeping this issue open so that we at least fix the docs with Marko v4.

/cc @mlrawlings @philidem Thoughts?
  `extension` and `extensions` properties are both now supported and consolidated. A few things to discuss:

- The consolidation function takes a `requireObj`, which is the Node.js `require` in `node-require.js`. I did this so it was easy to mock in a unit test without having to pollute the actual `require` object.
- I put `consolidateExtensions.js` in a new folder `util/`. I am open to other suggestions as to where to put this module. I do like the idea of having a `util/` folder at the top-level though. Changes already manually merged. Closing PR. Thanks for working on this!
  Bug on jQuery Proxy when w-id contains dash/hyphen, see issue #391 

## Description

Bug on jQuery Proxy when w-id contains dash/hyphen (e.g `w-id="submit-button"`)

## Motivation and Context

This PR contains fix for issue #391 

## Screenshots (if appropriate):
None

## Checklist:
- [x] My code follows the code style of this project.
- [ ] I have updated/added documentation affected by my changes (comment: not relevant to this issue)
- [x] I have read the **CONTRIBUTING** document.
- [x] I have added tests to cover my changes.
- [x] All new and existing tests passed.
 Thanks for the fix! I will back port your fix to Marko Widgets v6 and update here when published.
 New version of `marko-widgets` published with your fix: `marko-widgets@6.4.1`

Thanks again!
  ### Background: why `<script marko-init>` exists

For the most part, all of your template ends up in a render function

A template like this:
```xml
<var name="World"/>
<div>Hello ${name}</div>
```
compiles to something like the following (oversimplified) output js:
```js
function render(data, out) {
    var name = 'World';
    out.w('<div>Hello'+name+'</div>');
}

module.exports = new Template(render);
```

But there are times when you might want to add initialization code outside the `render()` function so that it doesn't run everytime the template renders, only when the template is first required.

So `<script marko-init>` has fulfilled this need.

### Why we want to change

A template like this:
```html
<script marko-init>
    var format = require('format');
</script>
<var name="World"/>
<div>Hello ${format(name)}</div>
```
compiles to something like the following (oversimplified) output js:
```js
var format = require('format');

function render(data, out) {
    var name = 'World';
    out.w('<div>Hello'+format(name)+'</div>');
}

module.exports = new Template(render);
```

A `<script>` tag usually puts code into the output html, but in this case, we're highjacking it because of the `marko-init` attribute and using the code as part of the render logic.

We actually already have a construct that is meant to add arbitrary javascript in template render logic: [scriptlets](https://github.com/marko-js/marko/blob/21a43c010a75ca06857598f49ea3368b3e33c3c2/docs/what-is-new-marko-v3.md#scriptlets).

But scriptlets, like most other things, run within the context of the `render` method.

### The proposal

By default, scriptlets, `<var>`, `<assign>`, etc. would continue to run within the context of the render method, but we will introduce a new tag: `<render>`.

A template like this:
```html
<var format=require('format')/>
<render>
    <var name='World'/>
    <div>Hello ${format(name)}</div>
</render>
```
compiles to something like the following (oversimplified) output js:
```js
var format = require('format');

function render(data, out) {
    var name = 'World';
    out.w('<div>Hello'+format(name)+'</div>');
}

module.exports = new Template(render);
```

Now the structure of the template matches up fairly well with the structure of the output js. :+1:

Obviously anything outside of `<render>` would not be allowed to write to `out` as `out` wouldn't be in scope.  We should detect this and throw an error at compile time. I definitely have some concern around having to wrap all the template code just to introduce some JavaScript initialization code. With that said, it doesn't look as bad with the concise syntax:

``` html
var format=require('format')

render
    var name='World'
    <div>Hello ${format(name)}</div>
```

You could even make it look like a method by adding parens and possibly a `data` param:

``` xml
var format=require('format')

render(data)
    var name='World'
    <div>Hello ${format(data.name)}</div>
```

And finally, that could allow for ES6 argument destructuring:

``` xml
var format=require('format')

render({name})
    <div>Hello ${format(name)}</div>
```
 I agree with wrapping everything in a `<render>` not being so great. Would that be required, or optional, only if you need code generated out of the context of the render function?

If the goal is to deprecate `<script marko-init>` with the already established expectation of a `<script>` tag, why not add a new tag called `<init>`, or something else?

```html
<init>
    var format = require('format');
</init>

<var name='World'/>
<div>Hello ${format(name)}</div>
```
or
```html
<init>
    <var format=require('format')/>
</init>

<var name='World'/>
<div>Hello ${format(name)}</div>
``` @Hesulan The `<import>` tag does hoist outside the `render` function, see the [import-tag test](https://github.com/marko-js/marko/tree/master/test/autotests/compiler/import-tag) and its [expected output](https://github.com/marko-js/marko/blob/master/test/autotests/compiler/import-tag/expected.js).

Importing modules is a big reason `<script marko-init>` was needed (just look at every example in this thread), but you might need to do something like this:

```html
<import { createFormatter } from "./format"/>
<var format=createFormatter({ lang:'en' })/>

<render(data)>
    <var name='World'/>
    <div>Hello ${format(name)}</div>
</render>
```


```js
import { createFormatter } from "./format";
var format = createFormatter({ lang:'en' });

render(data)
    var name = 'World';
    <div>Hello ${format(name)}</div>
```

I think the actual implementation of `<render>` would internally rely on the equivalent of the suggested `<init>` tag.   You'd loop over each top level element and if you found a `<render>` tag, you'd move all the other top-level elements into an `<init>` tag.  The `<init>` tag would then generate the code for its children and instead of putting that code in the render method it would place it towards the top of the file.  The question is should this `<init>` tag be an internal thing or should it be exposed as an alternative?

@patrick-steele-idem You've talked about requiring the parens on `<render>` and maybe that makes sense.  But we should also require an actual argument there: the name of the `data` variable.

Wrapping the whole template in `<render(data)>` would leave things as they are now.  `<render()>` would be invalid.

As for the `<init>` name, would `<load>` make more sense?  If you're not using the require hook, you would call `marko.load('./template.marko')` and that's the point at which this init/load code is run.

_Almost_ makes me want to do something like `<on-load>` and `<on-render>`, but let's not. Closed via https://github.com/marko-js/marko/commit/2980546f7c3309ec11a268ea0d4a801506c4ab6b  I think that's a good suggestion, although I would probably use `WARNING` instead of `ERROR`. Would you be interested in submitting a PR to improve marko? Thanks for opening the issue.

NOTE: Marko v4 development is on master and Marko v3 is on the [v3 branch](https://github.com/marko-js/marko/tree/v3) 
  Thanks for opening the issue @tinovyatkin, but that is the expected behavior since Marko is using the JavaScript rules for parsing a String attribute value. This means that JavaScript escape sequences starting with the `\` character must be valid JavaScript escape sequences. In your case you need to escape the backslash character so that the JavaScript parser doesn't treat it as a JavaScript String escape sequence:

``` html
<input type="text" pattern="\\w{2,20}" />
```

While this is not a bug in Marko, I admit that the escaping of those characters is less than ideal. What are your thoughts on enhancing Marko to allow a JavaScript regular expression for the attribute value?:

``` html
<input type="text" pattern=/\w{2,20}/ />
```

(we could update the compiler so that the output would be as expected)
 We should do this.  It's come up [before](https://github.com/marko-js/marko/issues/306#issuecomment-225099028).

It should be as simple as adding the following to the `escapeXmlAttr` function:

``` js
if(attr instanceof RegExp) {
    let str = attr.toString();
    return str.slice(1, str.lastIndexOf('/'));
}
```

The only thing is that html style regex don't support flags, so I'm thinking we just drop them?
  It is not safe to remove whitespace inside a `<script>` because the code inside a `<script>` tag is not HTML rules so we cannot use the HTML whitespace removal rules. If marko were to remove whitespace inside `<script>` tags then there is a good chance that it would break the code. If you want to safely remove whitespace inside a `<script>` tag then you would need to use a JavaScript minifier (the performance would be really slow so you would not want to run the minifier for every request). 

If you want go advanced, you can create your own compile-time transform that removes whitespace that is appropriate for your use case.

Hopefully that answers your question, but please feel free to add more comments here if not.
  Hey @basickarl, at first glance your setup looks correct. Are you seeing any errors? Do you see the `<init-widgets>` tag in the final HTML output (you shouldn't, but that might be a clue)? 
 No longer an issue. Closing.  Hey @sriver111, we'll need more details to help you out. Have you tried using [browser-refresh](https://github.com/patrick-steele-idem/browser-refresh) to enable hot reloading of templates? Here's a sample app that demonstrates hot reloading that I recommend checking out: https://github.com/marko-js-samples/marko-hot-reload
 @sriver111 would it be possible to share a minimal project to reproduce the problem? I'm not able to reproduce, but it is possible that a Windows-specific issue has creeped in.

FYI, hot reloading works in the following way:

When hot reloading is enabled, the `Template` class is monkey-patched to proxy all of the rendering methods in order to check if the template needs to be reloaded or not before calling the original method. In addition, when a `.marko` file is modified it is deleted from the `require.cache` so that it can be reloaded through the Node.js module loading system. I can share more information, but just wanted to give you an idea how it works.
 Glad you got it working. Closing the issue. Thanks for the update.
  Looks like a bug. I am investigating and should have an update soon. Thanks for opening an issue!
 Should be fixed now. We were missing a test case that should have caught an internal API change. New version published with fix: `marko@3.11.7`

Thanks, again.
  There are no `try...catch` blocks in marko so exceptions will not be caught by marko (this includes render-time exceptions due to programming errors in marko templates). 

Certain errors (such as timeouts associated with the `<await>` tag) will be emitted on the target stream. You can listen for those errors by adding a listener for the `error` event:

``` javascript
res.on('error', function(err) { ... });
```

If you use promises then promises will have an implicit `try...catch` block. If the promise passed to an `<await>` tag gets rejected then the `<await-error>` tag can be used to show alternate content: [`<await-error>`](http://markojs.com/docs/marko/async-taglib/#<code>&ltawait-error><code)

It's good practice to make sure you have an uncaught exception handler for any Node.js app that will gracefully close any connections and shutdown the app.

Hope that helps, but let us know if you have any other specific questions. I'm going to go ahead and close this issue, but please feel free to add more comments below.
  Currently, the process for [discovering taglibs](http://markojs.com/docs/marko/custom-taglibs/#taglib-discovery) is determined per template by the following:
1. search for `marko.json` in the same directory as the template, and then in each parent directory up to the project root (until a `package.json` is found).
2. for each dependency in the `package.json`, search for a `marko.json` at the package root.

This provides encapsulation as each template can only be modified by taglibs in its own package and packages it directly depends on.  It also provides consistent behavior no matter how the `node_modules` directory structure ends up due to dependency flattening of `npm@3` or `yarn`. :+1:

However there are cases where it could be useful to have global taglibs that are discovered by **every** template.  Here's a few ideas:
- A security transform that puts a [`nonce`](https://developer.mozilla.org/en-US/docs/Web/Security/CSP/CSP_policy_directives#strict-dynamic) attribute on all inline script tags
- A asset management transform that allows relative paths to be specified for resources (ex. `<img src="./foo.png"/>`) and includes the resolved file in the build.
- etc.
 @mlrawlings Any thoughts on how to register global taglibs?
 I have few thoughts on this:

**1**. Add methods to force inclusion of a directory or package:

``` js
require('marko/compiler').taglibFinder.includeDir(dirPath);
// Where 'dirPath' is an absolute path to the folder containing marko.json 

require('marko/compiler').taglibFinder.includePackage(packageName);
// Where 'packageName' is the name of the node_module containing marko.json 
```

I don't particularly like this because I'm not a fan on having the application compile templates differently than the command-line tool, test, etc.  This becomes a source of hard-to-find problems.

**2**. Keep searching up after finding a `package.json` and load parent's packages' taglibs as well.   This would make the global behavior the default, though not truly global as taglibs would trickle down, but not up.   I could potentially see some unwanted behavior with this approach, but the top level would always be in control of what was added in, so it might not be so bad.  Another issue is dependency flattening.  One dependency might be a dependency of another but they could be siblings in the directory structure due to flattening.  This could lead to unexpected behavior.

**3**. Allow taglibs to specify a `"global":true` option in `marko.json`.  For discovery purposes (and sanity?)  only top level dependencies (those directly depended on by the main application) would be able to register global transforms, renderers, etc.  If the top level application wanted to register a global transform, it would be required to do so in a `marko.json` at the root of the package.  The only challenge with this would be determining the root application.  We could potentially do something with searching up to the root of the filesystem and the highest directory with a `package.json` is assumed to be the app root.  Or we could use `process.cwd()` as a heuristic. 

Option 3 is looking the best at this point, but I'm open to other suggestions.
  For performance reasons, if a render completes synchronously then the callback is invoked synchronously. Therefore, if you repeat the rendering when the callback is invoked then you will eventually get a `Maximum call stack exceeded` error because the stack trace keeps growing.

The simple solution is to break up the stack trace using `setImmediate()`:

``` javascript
bench('marko', (next) => {
    const template = require('./post.marko');
    template.render(data, () => {
        //throw away the render output
        setImmediate(next);
    });
});
```

If you add `setImmediate` for `marko` then make sure you also add it for `handlebars` so that the results are not skewed.

On a related note, have you taken a look at the following benchmarks that include `marko` and `handlebars`?: https://github.com/marko-js/templating-benchmarks

It's very easy add add a new comparison group with your own templates. If you want to improve those benchmarks with more comparisons I would encourage you to send a PR.

If you have any other questions or issues please let me know.
  ## New Feature
### Description

<!--- Provide a detailed description of the change or addition you are proposing -->

This is kinda a rough idea I've been throwing around in my head for a while now and figured I should put it out there:  I'd like Marko to provide a way to automatically inject a custom tag at the end of a page.
### Context

There's a number of tags in our ecosystem (some of these eBay specific) that we end up having users add to their layout templates right before the closing `</body>` tag.  Often users will forget to add one an wonder why something isn't working.

``` xml
<body>
    ...
    <await-reorderer/>
    <lasso-body/>
    <init-widgets/>
    <gh-footer/>
    <gh-body-js/>
    <tracking-cookies/>
    <tracking-images/>
    <tracking-body />
    <browser-refresh/>
    <site-speed-bottom/>
</body>
```
### Conciderations

<!--- What still needs to be discussed -->

Tags could already implement something basic by hooking into the closing body tag, but it's possible someone renders a template without a `<body>` tag.  Google even [recommends](https://google.github.io/styleguide/htmlcssguide.xml?showone=Optional_Tags#Optional_Tags) to omit it.  Ideally, the insertion point for these tags would be just before `</body>` or, if that's not found, at the end of the top level template.

Async is also something that needs to be considered.  

> Example: In the case of `<init-widgets/>`, we would only want to include it on the page if there are widgets on the page.  But it could be that the only widget is in an `<await>` block and therefore we don't know that we need to init widgets until that block is executed.

Finally, some tags (like `<init-widgets/>`) require that the javascript has been loaded before them.  And it's likely that a tag to insert that javascript (like `<lasso-body/>`) would also be using this system to insert itself.  So perhaps we need some system of priority.  Or tags could choose between append/prepend.
 It would also be ideal if we could do this without adding code to every generated template.
  Looks good. Thank you!
 @yomed Thanks for these docs related PRs!  We definitely appreciate it!
  Hey @jdnichollsc, thanks for the feedback and welcome to Marko! 

You are doing everything correctly, except you for got to register the Node.js require hook for Marko templates. You should add the `require('marko/node-require').install();` line to your main JavaScript file:

``` javascript
require('marko/node-require').install(); // â† Add this line

var express = require('express');
var router = express.Router();
var template = require('../views/index.marko');

/* GET home page. */
router.get('/', function(req, res, next) {
  res.marko(template, { title: 'Express' });
});

module.exports = router;
```

Without that line, Node.js will try to load Marko templates as JavaScript modules. The Node.js require hook for Marko registers a custom loader for Node.js that will automatically compile `require`d `.marko` templates to JavaScript modules so that they can be loaded by the Node.js module loading system.

Hope that solves your problem, but let us know if you run into any other issues.

Cheers.
 The `require('marko/node-require').install();` line just needs to run once at the very beginning. In your case, you just need to add it to the top of your `./app.js` file.

We tried to make this clear in the docs for using Marko with Express: http://markojs.com/docs/marko/express/

It's also discussed in more detail as part of the Getting Started guide: http://markojs.com/docs/marko/get-started/#template-loading

If you still think there is room for improving the docs please let us know or submit a PR (at the top of every docs page on [markojs.com](http://markojs.com/) there is a "Improve this page" page link).
  <!--- Provide a general summary of your changes in the Title above -->
## Description

<!--- Describe your changes in detail -->

Opening this for feedback & discussion.  This PR adds `await:error` and `await:timeout` events.  I will add documentation for these before we merge.
## Motivation and Context

<!--- Why is this change required? What problem does it solve? -->

<!--- If it fixes an open issue, please link to the issue here. -->

To allow applications to listen for errors that occur in an `<await>` tag, even if the error is handled by the template. For logging purposes and such.
## Checklist:

<!--- Go over all the following points, and put an `x` in all the boxes that apply. -->

<!--- If you're unsure about any of these, don't hesitate to ask. We're here to help! -->
- [x] My code follows the code style of this project.
- [x] I have updated/added documentation affected by my changes.
- [x] I have read the **CONTRIBUTING** document.
- [x] I have added tests to cover my changes.
- [x] All new and existing tests passed.
  ðŸ‘ Very much appreciated. Thanks!
  Looks great. Thanks!
  Marko supports custom attributes on standard HTML tags. You would need to write a compile-time transform to process those custom attributes. It's not hard, but it is definitely more in the "advanced usage" category. A compile-time transform can also process standard HTML attributes if you choose.

Here's some relevant docs that show an example of a transform processing a custom `if` attribute: http://markojs.com/docs/marko/compiler/advanced/#transform-stage

Sometimes it is easier to explain in code so I will push a sample app that will hopefully make things clear. I'll provide an update here soon.
 Hey @jasonmacdonald, it took a little longer because I got pulled into some other things, but here is a project that I hope clarifies how to handle custom attributes: https://github.com/marko-js-samples/marko-custom-attributes 

I'm going to go ahead and close this issue, but if you would like more details please feel free to post comments here.
 You're welcome. You just need to use `marko.json` to register the compile-time transform, but you can still use the `components` directory.
  Hey Ryen, I don't think this is an issue with the Marko middleware since there is no way for Marko to know that the response is going to be the same before rendering. I think the responsibility of setting the cache headers and setting HTTP status codes should reside in your application logic. If you have any more thoughts please share.
 In order for `res.marko()` to send a 304 it would need to buffer the response in order to calculate an etag based on the final HTML output and then use that etag to determine if 304 should be sent based on incoming request and it would also need to set the etag header for the response. That is certainly something we could offer as a feature, but it would need to be opt-in since buffering would prevent streaming/progressive HTML rendering (a huge reason to use Marko). In a perfect world, your page controller would calculate the etag independent of template rendering (this would would have the advantage that there would be no CPU cycles and memory wasted rendering a template that didn't need to be rendered).

I'm not opposed to offering feature as an enhancement, but it would need to be opt-in. If it something you are interested in working on, here is the related code:
- https://github.com/marko-js/marko/blob/master/express.js
- https://github.com/jshttp/fresh
- https://github.com/jshttp/etag

Please let me know if you are interested in working on this.
 And just to add. something like the following might be nice:

``` javascript
res.marko(template, templateData, { etag: 'weak' });
```
 Did you go any farther with this @RyenNelsen? Generating a hash of the data would work if the output is completely based on the backend data, but it would definitely require some extra CPU cycles. Depending on how your backend data is structured, you could store a "version"/"revision"/"last modified" or some other value with the data to track changes to the data and use that value to also set the `etag` and check freshness. That would all be outside the scope of marko. The only thing that marko could do is buffer up the output HTML in order to calculate an etag and compare freshness to conditionally send down a `304 not modified`
  I think changing the name of the package will disrupt things too much. Also, we merged the functionality of `autocomplete-marko` and `hyperclick-marko` into the main [language-marko](https://atom.io/packages/language-marko) package. It's unfortunate that the search results for `marko` are in such a bad order, but I'm not sure there is much we can do about that right now. I did add keywords to the `package.json` so hopefully that will help: https://github.com/marko-js/atom-language-marko/commit/9e5976ed29daca646b251c6a86f06992341e7284
  Currently, the Marko compiler compiles a template to a program that, when executed, will render an HTML string to a stream. This is perfect for the server, but it is less than ideal in the browser since the HTML string must be parsed using something like `innerHTML` in order to update the DOM. Instead, we plan to update Marko to support a new "virtual DOM" output mode for the compiler and an accompanying virtual DOM runtime. The templates will continue to be compiled to a program that renders an HTML stream for the server, but templates will be compiled to render to a virtual DOM tree in the browser. Supporting multiple compilation outputs will allow optimizations in the browser that were not possible before.

To make things more clear, let's take a look at an example template:

``` xml
<h1 class="title">
    Hello ${data.name}!
</h1>

<if(data.colors.length)>
    <ul>
        <li for(color in data.colors)>
            ${color}
        </li>
    </ul>
</if>
<else>
    <div class="empty">
        No colors!
    </div>
</else>
```

The current compiled output for the above template is similar to the following:

``` javascript
function render(data, out) {
  out.w("<h1 class=\"title\">Hello " +
    escapeXml(data.name) +
    "!</h1>");

  if (data.colors.length) {
    out.w("<ul>");

    forEach(data.colors, function(color) {
      out.w("<li>" +
        escapeXml(color) +
        "</li>");
    });

    out.w("</ul>");
  } else {
    out.w("<div>No colors!</div>");
  }
}
```

We are planning to go with the following virtual DOM output when compiled for the browser (not exact):

``` javascript
var attrs0 = { class: 'title' };

var el0 = createElement('div', { class: 'empty' }, 1 /* child count */)
    .text('No colors!');

function render(data, out) {
    out.element('h1', attrs0, 1)
        .text('Hello ' + data.name + '!');

    if (data.colors.length) {
        out.beginElement('ul');

        forEach(data.colors, function(color) {
            out.element('li', null, 1)
                .text(color)
        });

        out.endElement();
    } else {
        out.node(el0);
    }
}
```

A few things to note:
- Optimization: static subtrees are pulled into variables that are only initialized once and reused for every render
- Optimization: static attributes that are on dynamic elements are pulled out to static variables
- Optimization: Diffing is skipped when comparing static subtrees
- Async rendering will continue to be supported on both the server and in the browser. Async fragments will begin with a partially constructed virtual DOM subtree
- `out.write()` will not be allowed when rendering to a virtual DOM
- `out.getRootNode()` can be used to get the root [DocumentFragment](https://github.com/marko-js/marko-vdom#documentfragment) node for the virtual DOM tree being rendered.

Tasks:
- [x] Provide a virtual DOM implementation that is compatible with morphdom. Done: [marko-vdom](https://github.com/marko-js/marko-vdom)
- [x] Update [morphdom](https://github.com/patrick-steele-idem/morphdom) to support diffing the real DOM with a compliant virtual DOM. Done: [morphdom PR #83](https://github.com/patrick-steele-idem/morphdom/pull/83)
- [x] Update the Marko compiler to support multiple output modes
- [x] Implement the codegen for the virtual DOM output mode (almost done)
- [x] Optimize using `isSameNode()` for static subtrees
- [x] Update [async-writer](https://github.com/marko-js/async-writer) to support a virtual DOM runtime. Done: [async-vdom-builder](https://github.com/marko-js/async-vdom-builder)
- [x] Merge in [raptor-renderer](https://github.com/raptorjs/raptor-renderer) functionality into [async-vdom-builder](https://github.com/marko-js/async-vdom-builder) and [async-writer](https://github.com/marko-js/async-writer)
- [x] Additional optimizations for static attributes on non-static sub trees
- [x] Default to `vdom` output for [lasso-marko](https://github.com/lasso-js/lasso-marko)
 @PierBover Anything is possible because Marko allows for custom compile-time transforms and custom code generators for custom tags and this allows for custom JavaScript to be inserted into the compiled template to attach event listeners or whatever else is needed.

Marko Widgets is an example of a UI components library that utilizes compile-time transforms to supports declarative event bindings for both DOM events and custom widget events. Marko Widgets allows named events to be bound to a named widget method. How Marko Widgets handles event binding is a subtle implementation detail, but it allows the browser to pick up right where the server left off and, unlike with React, it is not necessary to rerender the UI in the browser if it was already rendered on the server. The reason React requires that the UI be rerendered in the browser is because a reference to a listener function on the server can't be passed down to the browser so all the server is really providing is the raw HTML.

More details: http://markojs.com/blog/a-closer-look-at-marko-widgets/#how-does-event-delegation-work
 @ianvonholt for now we only have raw numbers (no fancy graphs) for a benchmark of the new [marko-vdom](https://github.com/marko-js/marko-vdom) implementation that shows very significant speedups when measuring the time it takes to build a virtual DOM tree compared to a real DOM tree, as well as the time it takes to walk a virtual DOM tree compared to a real DOM tree: https://github.com/marko-js/marko-vdom/blob/master/docs/benchmark-results.md

While a virtual DOM implementation provides some significant gains, I suspect the bigger improvements will come from the fact that we can now skip rerendering parts of a template that are constant. That is, the improved compiler will separate out a DOM subtree to a virtual DOM node that is only created once and used for every rerender. On top of that, we also mark that virtual DOM node as constant so that Marko Widgets will completely skip diffing entire DOM subtrees that are constant. This was not really possible before when rendering to an HTML string since the entire HTML string was being parsed to produce a real DOM even though many of the HTML strings were constant.
  There are a few reasons we have kept `writeToDisk` enabled:
- In development, seeing the output `.marko.js` file is helpful for debugging and understanding
- In production, templates are not recompiled if the application server needs to restart since the compiled out from the previous startup was written to disk. This makes startup times slightly faster

Since disabling `writeToDisk` is as simple as `require('marko/compiler').configure({ writeToDisk: false })` I'm in favor of keeping the current behavior. I'm open to other thoughts though.

@mlrawlings @philidem any thoughts? 
 @hustcer templates should always be compiled on the server. When you call `require('./template.marko')` on the server the template will be compiled and loaded at that time. When you use a JavaScript module bundler to send down templates they will be compiled during the bundling process. If that doesn't answer your question I would recommend joining us on Gitter to discuss: https://gitter.im/marko-js/marko
 I would agree that it would be nice to remove these files by default if only because it makes things seem simpler.  I will say though, that these compiled output files were extremely helpful in understanding how `marko` works at a lower level - though that's certainly not a requirement in order to _use_ `marko`.

The other concern I have is that runtime errors will reference a line/column in the generated `*.marko.js` file, so if that file is not readily available, debugging becomes more cumbersome.  

Potential solutions:
 - sourcemaps
 - write out the generated file on error @Hesulan Regarding source maps, our parser already has line/column start/end positions for every tag/attribute/etc. so that's definitely a good starting point and I'm thinking with the changes made to the way we generate code in v4, it might not be _too_ difficult to get the code writer to map changes back to the positions of the nodes its writing.  Then we would need some kind of way to track where newly generated nodes came from.  This would probably require the core transforms and user-generated transforms to give the compiler hints about what it's doing.  This would be especially true when custom parsing tag/attribute argument expressions.

I actually just recently added a `_currentNode` property to the context, so if we connect the builder to use that we might be able to track things in many cases, but I there would still be cases where you might need to pass in an original node to a builder method, possibly with position offsets.  

I definitely think we can get this to work.  We just need the time to spend on it.

In the short-term, maybe controlling `writeToDisk` via an environment variable would be easiest:

```
MARKO_WRITE_TO_DISK=true npm start
```

or something more generic like:
```
DEBUG=marko npm start
```




 That's an interesting thought @mindeavor. It's a little more verbose, but a tag such as one of the following would be easier to implement::

```xml
<write-to-disk/>
<!-- or -->
<marko-compiler write-to-disk/>
<!-- or -->
<marko-debug/>
<!-- or -->
<marko-compiler debug/>

<div>
  Hello ${data.name}
</div>
```  I don't quite follow. Marko templates are resolved and loaded through the Node.js module loading system just like normal JavaScript modules. There's no "views dir" and there is no root path when using marko directly. Can you provide more details and code to illustrate the problem you are seeing?
 As Patrick said, we use node's module resolution to handle finding the template.  If you really wanted to have a views directory, you could roll something yourself using the `require('marko').load()` function which expects a fully resolved filesystem path.  In our examples we use `require.resolve` to get that path, but there's nothing stopping you from resolving it relative to some views directory, but that would all happen outside the scope of Marko.   Maybe something along the lines of [this](https://gist.github.com/mlrawlings/d92b5c1d89abefbba66e2d8af5c47eef).

However, I would recommend having your `render` function take the loaded template as a parameter:

``` js
var template = require('./index.marko')

app.use(({ res }) => {
  res.send(200, marko.render(template, { name: 'Trek Engine' }))
})
```

We do something similar in the [`marko/express`](https://github.com/marko-js/marko/blob/master/express.js) submodule to provide the [`res.marko`](http://markojs.com/docs/marko/express/) method.
  I think what needs to happen here is that in addition to `.marko` and `.marko.html`, we should also look for any extensions that were registered via `require('marko/node-require').install()`.

For example:

``` javascript
require('marko/node-require').install({ extension: '.marko' });
require('marko/node-require').install({ extension: '.marko-xml' });
require('marko/node-require').install({ extension: '.foo' });
```

We should check to see if the path ends with `.marko`, `.marko-xml` and `.foo`.

Thoughts? Would you be interested in working on this @jlarsson?
  Hey @fundon. marko uses the [Apache 2.0](http://www.apache.org/licenses/LICENSE-2.0) license. I'm not a lawyer, but if you are just depending on marko (and not modifying it) then you don't need to do anything. Any distribution of marko need to include a copy of the license (which will be the case if you  are installing from npm or directly from Github).

If that doesn't answer your question then please let me know, but I am going to go ahead and close the issue.
 @fundon yes. as long as you are not modifying and redistributing marko then it doesn't matter what the license is for your project.
  Hi @Eldar-X, what version of Safari are you using and which OS? When I test Safari version 9.1.2 (11601.7.7) on OSX everything is working as expected using the following sample app: https://github.com/marko-js-samples/marko-progressive-rendering

It will vary by browsers, but most browsers must receive a minimum threshold of bytes before the initial render. It's possible that for your app you are not sending down enough HTML for the initial HTML and this is causing the browser to just buffer the received HTML instead of rendering the initial page. If you can provide more details on your setup or a sample app I will investigate some more.
  Hey @basickarl, here's what I consider to be a good directory structure:

``` clojure
/
 â¤· .cache/ (auto-generated-files)
 â¤· config/
    â¤· development.json
    â¤· production.json
 â¤· node_modules/ (installed-modules)
 â¤· src/
    â¤· components/
       â¤· some-component/
          â¤· test/
          â¤· index.js
          â¤· style.css
          â¤· template.marko
          â¤· template.marko.js
       â¤· .../ (additional-components)
    â¤· layouts/
       â¤· _common/ (files-common-to-all-layouts)
       â¤· main/
          â¤· fonts/
             â¤· sanfrancisco.woff2
          â¤· images/
             â¤· logo.webp
          â¤· style.css
          â¤· layout.marko
          â¤· layout.marko.js
       â¤· .../ (additional-layouts)
    â¤· pages/ (directory-of-pages)
       â¤· home/ (the-home-page)
          â¤· components/ (components-used-by-home-only)
          â¤· images/
             â¤· hero-image.webp
          â¤· index.js (home-route-handler)
          â¤· style.css 
          â¤· home.marko
          â¤· home.marko.js
       â¤· .../ (additional-pages)
    â¤· app.js
 â¤· static/ (auto-generated-files)
 â¤· test/ (test-related-files)
 â¤· package.json
```

 And to touch on some of your other questions:

### **How does one create a template which nests another template?**

_template.marko_

``` xml
<ul for(item in data.items)>
    <include('./item.marko') name=item.name />
</ul>
```

_item.marko_

``` xml
<li>${data.name}</li>
```

### **tags vs. widgets?**

Typically you'll see widgets implemented as custom tags.  A widget's template uses the `w-bind` attribute to link to a JavaScript file that contains its client-side behavior.

### **what is [marko.json](http://markojs.com/docs/marko/custom-taglibs/#markojson)?**

Marko will automatically look for directories under `components/` and [scan them](http://markojs.com/docs/marko/custom-taglibs/#scanning-for-tags) for custom tags.  If you want to define individual tags, use custom transforms, or scan a directory other than `components/`, you'll need to use this file to provide the configuration.  It used to be that you needed this file even if all your components were under a `components/` directory, which is why you'll find it in many examples.

### client marko rendering (both non widget and widget) is still unclear to me

A module bundler is needed to use marko client side, webpack [should work](https://github.com/marko-js/marko/issues/44), but I don't have any experience using it with marko.  We're currently working on some improvements (performance and otherwise) to client-side rendering.  We should update the docs and give some better examples once that work is complete.

### I would like to see an example project which touches all areas so I can see how they could be fit together

We have an sample project that makes use of Marko, but currently it's internal to eBay.   We'd need to remove some eBay specific things from the app, but it would probably be worthwhile to make that generally available.

### I think explaining from scratch for beginners who have just come from i.e. jQuery how marko works will draw a lot more attention to it.

I agree.  This is an area where we could use some help if you're willing.  It would be amazing to start seeing some training content provided by people outside the project maintainers.  I think when you're just starting to learn something you're in a unique position to help people at the same place, as things become familiar we tend to forget the aspects that used to be difficult for us.  

If you have more questions, feel free to join us on [gitter](https://gitter.im/marko-js/marko) and welcome to the community! :tada:
 @davidenq everything under `src/` includes all application source code (both server-side, client-side and isomorphic code). In most cases, whether or not code is client-side or server-side will depend on how the code is used. Do you have any other specific doubts?
 I'm going to go ahead and close this issue. If you still have unanswered questions, please feel free to add comments here or open a new Github issue.
 @basickarl You can pass the data as the second argument for the `<include(path[, data])>` tag:

``` xml
<ul for(item in data.items)>
    <include('./item.marko', item) />
</ul>
```

See: http://markojs.com/docs/marko/language-guide/#includes
 @Anant-Raj 

The `components/` directory can exist in multiple places in your project and they are scoped. We recommend the following directory structure:

```
my-app/
    components/ â† top-level UI components shared by all pages/routes
    routes/
        about-me/
            components/ â† UI components scoped to the about-me route
            index.marko
        index/
            components/ â† UI components scoped to the index route
            index.marko
   ```

You can see this project structure in action as part of our starter app: https://github.com/marko-js-samples/marko-starter-demo

Let me know if you would like more details, but hopefully that answers your question.  No worries. I still think it was confusing since the docs say that they are deprecated, but we don't say why or which method should be used instead. I'll fix this to avoid confusing others. Thanks for opening the issue.
  See: https://github.com/marko-js/marko/issues/357
  The builtin `empty`/`notEmpty` helpers will be removed in Marko v4 and will be deprecated in v3 (with console warning).

If still needed, these helpers can still explicitly be imported:

``` html
<script marko-init>
var empty = require('marko/helpers/empty');
var notEmpty = require('marko/helpers/notEmpty');
</script>
```

Alternatively, you can simply check the array length or ensure that a string is not "falsey".
# Why?

The `empty`/`notEmpty` helpers were automatically being added to every compiled template. While they can be helpful, we feel it is better if the developer explicitly imports only the exact helpers that your code depends on for improved modularity. Also, when adding support for [inline marko templates](https://github.com/marko-js/marko/issues/349) we found that these `empty`/`notEmpty` helpers could conflict with other JavaScript code since all static code/imports are added at the top of the JavaScript file.
 @briceburg I suppose one possibility would be to introduce a new option in `marko.json` to opt-in for the `empty`/`notEmpty` helpers, but I don't think it is a good idea to go there. Personally, I would just use `<if(data.commits && data.commits.length)>` instead of a helper. If you have any other thoughts or ideas please share.
  Thanks. Appreciated ðŸ˜„ 
  <!--- Provide a general summary of your changes in the Title above -->
## Description

<!--- Describe your changes in detail -->

Previously there was a difference in the way empty string (`""`) was handled when it was a literal value.  It now uses the raptor-util behavior for both literals and dynamic values.
## Motivation and Context

<!--- Why is this change required? What problem does it solve? -->

<!--- If it fixes an open issue, please link to the issue here. -->

Fixes #327
## Checklist:

<!--- Go over all the following points, and put an `x` in all the boxes that apply. -->

<!--- If you're unsure about any of these, don't hesitate to ask. We're here to help! -->
- [x] My code follows the code style of this project.
- [x] I have updated/added documentation affected by my changes.
- [x] I have read the **CONTRIBUTING** document.
- [x] I have added tests to cover my changes.
- [ ] All new and existing tests passed. 

**The tests will fail until raptorjs/raptor-util#4 is merged and published**
  Thanks for letting me know. I have fixed the `.npmignore` file and published a new version with *.orig files excluded
  ## Description

Currently when a node/tag is marked with "preserve-whitespace", the whitespace is being preserved for only directly nested text. The expected behavior should be that whitespace should be preserved for all directly nested text and any text nested at any level below the node.
## Motivation and Context

[Issue #345](https://github.com/marko-js/marko/issues/345)
## Checklist:
- [X] My code follows the code style of this project.
- [X] I have updated/added documentation affected by my changes.
- [X] I have read the **CONTRIBUTING** document.
- [X] I have added tests to cover my changes.
- [X] All new and existing tests passed.
  ## Checklist:
- [X] My code follows the code style of this project.
- [X] I have updated/added documentation affected by my changes.
- [X] I have read the **CONTRIBUTING** document.
- [X] I have added tests to cover my changes.
- [X] All new and existing tests passed.
  Actual usage will be the following:

``` javascript
var defineRenderer = require('marko/defineRenderer');

module.exports = defineRenderer({
    template: require('./template.marko'),
    getTemplateData: function(input) {
        var firstName = input.firstName;
        var lastName = input.lastName;

        return {
            fullName: firstName + ' ' + lastName
        };
    }
})
```

NOTE: `defineRenderer` should be required as a sub-module (`require('marko/defineRenderer')`). This was done to avoid adding any extra weight to the main `marko` runtime.
  Some notes:
- The parser is working as expected
- This is not really a bug, but it is a "gotcha"
- We should offer a custom tag to avoid the situation where nested body content is ended too early.

One possible solution:

``` xml
<marko-parser body='static-text'>
    <section>
        <div>Other Content</div>
        <section>Content Goes Here</section>
    </section>
</marko-parser>
```

Thoughts?
  ## Description

<!--- Describe your changes in detail -->

Allows excluding the `components/` dir itself, in addition to its parent directory (presumably where a `marko.json` would have been found.
## Motivation and Context

<!--- Why is this change required? What problem does it solve? -->

<!--- If it fixes an open issue, please link to the issue here. -->

Fixes #340 
## Checklist:

<!--- Go over all the following points, and put an `x` in all the boxes that apply. -->

<!--- If you're unsure about any of these, don't hesitate to ask. We're here to help! -->
- [x] My code follows the code style of this project.
- [x] I have updated/added documentation affected by my changes.
- [x] I have read the **CONTRIBUTING** document.
- [x] I have added tests to cover my changes.
- [x] All new and existing tests passed.
  I'm testing this using a render test.  Is that fine?
 I think a render test is great because it easy to write tests based on the output HTML. Alternatively, you could add a taglib lookup test if you felt the need to inspect some of the internal data structures similar to the following: https://github.com/marko-js/marko/blob/master/test/autotests/taglib-lookup/custom-tag/test.js
 Amended commit has been merged: https://github.com/marko-js/marko/commit/80999593551b08d5a838daed462eb7561a735ec5

New version published with improvement: `marko@3.8.0`

Closing PR.
  There are no `try...catch` blocks in Marko (for performance reasons, but also because the Marko runtime wouldn't know how to best handle the error). A common strategy for error handling in Node.js is to gracefully close all connections when an uncaught error occurs and to shutdown the process. The following is a good read: https://www.joyent.com/node-js/production/design/errors

However, another good alternative is to use promises. Promise implementations use an implicit `try...catch` so you can do the following to catch any errors when rendering the initial HTML that is rendered synchronously:

``` javascript
function controller(req, res) {
    new Promise(function(resolve, reject) {
            template.render({name: 'Frank'}, res);
        })
        .catch(function(err) {
            res.end();
            // Handle the error...
            console.log('Templating rendering failed! ', err);

        });
}
```

In addition, if you are using the [`<await(...)>`](http://markojs.com/docs/marko/async-taglib/#<code>&ltawait><code) you can provide a promise as the data provider to handle the errors when rendering portions of your template asynchronously.

Also, we plan on adding a promise API method soon: https://github.com/marko-js/marko/issues/251

Does that answer your question?
  @bkuri, the implementation of `builder.text` looks like this:

``` js
text(argument, escape, preserveWhitespace) {
    if (typeof argument === 'object' && !(argument instanceof Node)) {
        var def = arguments[0];
        return new Text(def);
    }
    argument = makeNode(argument);

    return new Text({argument, escape, preserveWhitespace});
}
```

so try passing `true` as the third parameter:

``` js
return builder.htmlElement 'script', {}, [
    builder.text builder.literal(js), false, true
]
```
  @bkuri Thanks! Since you've already got a branch for this, would you mind running the tests (`npm test`) and fixing the one that fails?  It's actually asserting that `literalUndefined === null`! ðŸ˜† 
  @bkuri This one also fails due to the test being incorrect... oops!
  @aniruddh-a this looks like an issue with Lasso and not Marko. Do you mind moving this issue over to https://github.com/lasso-js/lasso and providing more details on your lasso version? Thanks!
 Lasso issue: https://github.com/lasso-js/lasso/issues/155
  This branch is a starting point for encouraging contributions to Marko with the following:
- [x] Highlight how to get involved in the `README.md`
- [x] Add a `CONTRIBUTING.md`
- [x] Add an `ISSUE_TEMPLATE.md`
- [x] Add a `PULL_REQUEST_TEMPLATE.md`
  @aniruddh-a and I were discussing how custom tags are discovered, and he wondered why it couldn't just be done automatically.  This might be a good idea to explore.

Essentially, it would function kinda like `node_modules` except based on the `components` directory (which has become a standard way of doing things).  The taglib lookup could search first in the current directory for a `components` directory and continue walking up to the project root to discover tags.

This actually mirrors the way that `marko.json` files are discovered and could be done in the same step.

Thoughts?

/cc @marko-js/maintainers 
 My initial reaction is that I don't like introducing too much convention since it makes things feel less flexible and introduces more magic. There's also the overhead of now looking for both a `marko.json` file and a `components/` folder. I feel like adding a `marko.json` file with a single `tags-dir` property is insignificant and it is extremely flexible. I will let others weigh in though.
 @patrick-steele-idem To reiterate what Yoni said, we already have convention within the `tags-dir`, this just takes it one step further.  I think it makes sense as a default.  ðŸ° ðŸŽ© âœ¨

@yomed This would allow a structure like:

```
/
 â¤· src/
    â¤· components/
        â¤· some-component/
           â¤· components/
               â¤· some-subcomponent/
           â¤· renderer.js
           â¤· template.marko
    â¤· layouts/
        â¤· main/
           â¤· components/
               â¤· some-layout-specific-component/
           â¤· layout.marko
    â¤· pages/
        â¤· home/
           â¤· components/
               â¤· some-page-specific-component/
           â¤· index.js
           â¤· template.marko
```

without a `marko.json` at each level.
  /CC @philidem @mlrawlings 

Not ideal, but you can using a space character: `<img alt=" ">`

With that said, I think we should revisit the rules for rendering attribute value. I think the following would be more appropriate...

Giving the following template:

``` xml
<img alt=someExpression/>
```

| someExpression | Current | Proposed |
| --- | --- | --- |
| `undefined` / `null` / `false` | `<img>` | `<img>` (no change) |
| `true` | `<img alt>` | `<img alt>` (no change) |
| `''` | `<img>` | `<img alt="">` |

While this would be a change, I am not sure it would actually break anything. Thoughts?
 @patrick-steele-idem I'd lean towards your table rather than creating a list of exceptions.

I was just testing and I think we've got some weird behavior...

`<img alt="">` becomes `<img alt>`

but

`<img alt=data.alt>` becomes `<img>` if `data.alt === ''`

This is weird, but also means that we could probably leave `alt=""` untouched if it's a string literal and keep the current behavior if it's a variable that contains an empty string as its value (if we want to).  Or maybe we should make it consistent...

@yomed Out of curiosity, is there any reason why you couldn't forgo the `alt` attribute and use `role="presentation"` or `aria-hidden`?  And does `alt` behave differently than `alt=""`?
 @yomed If you ask me, even `alt=""` is kinda a hack used to stop the screen reader from reading out the url to the image.  But `role="presentation"` or `aria-hidden` explicitly tell the screen reader to ignore it because it's for presentational purposes only.  

In any case, we should probably fix this.
 I'm in favor of updating Marko to follow the proposed table above as part of a minor release. The chances of actually breaking anything are extremely low since the worst case is that there will be an attribute with empty quotes when there was no attribute before. Any objections?
 @yomed I don't know that this is a definitive test, but here's what WAVE has to say:
http://wave.webaim.org/report#/http://output.jsbin.com/majejevelu

It would seem that `alt` and `alt=""` are equivalent.  I've also seen recommendations for an image to "be given empty/null alternative text", although they go on to show `alt=""` in examples.

@patrick-steele-idem What are your thoughts on leaving the current behavior for variables and leaving the empty string when it's specified as a string literal?

Although, it might be useful to have the behavior from the table if you're generating a list of images from something like:

``` js
[{ src="/1.png" alt="something"}, { src:"2.png", alt="" }]
```

Though I'd say chances are pretty good that given a list of images like this, they should all have `alt` content or should all have an empty/null `alt`.
 > @patrick-steele-idem What are your thoughts on leaving the current behavior for variables and leaving the empty string when it's specified as a string literal?

I would want things to be consistent regardless of whether or not the attribute value is a literal value or a dynamic expression.
  /CC @philidem @mlrawlings @tindli 

Thank you for the detailed write up, @nicolashery! This seems completely doable with some tweaks to the compiler and runtime. For example, we would need to modify the `FunctionDeclaration` AST node to support extra type information for params.

Personally, I am not yet using TypeScript. I'm not opposed to TypeScript, but I also haven't had a strong desire to start using it. Because of that, I may not be the best person to work on this. I would rather someone who is actively using TypeScript to do the coding, but I can definitely help point you in the right direction. As long as the code changes are clean and well-tested then I have no objections to this proposal.

Regarding open questions:

> Source-maps & errors: If a runtime error occurs in the generated JS, can we show the line in the .marko file that caused it?

That may be nice and I think that is  also doable without drastic changes. For example, the compiler would need to attach source mappings to parsed expressions. It's definitely something I have thought about, but we haven't had any time to come up with a formal proposal or implement it. With that said, I have found source maps to be somewhat problematic and often end up disabling them (e.g. when doing Atom plugin development with CoffeeScript). Instead, we have focused on making sure the compiled output is extremely readable. For that reason, supporting source maps has been a low priority.

> Editor integration: A nice feature of TypeScript is the auto-completion and real-time type-checking. Would it be feasible to have that directly in the the .marko file?

I would have to take a look at how TypeScript autocompletion works for other files, but I suspect this will be challenging. Maybe the template can be compiled to TypeScript and source maps could be used to generate autocompletions as the user is editing the `.marko` file? It seems like that would probably be too slow, but maybe not.

---

Please let me know if you are interested in contributing and we can discuss a plan of action.

Any thoughts from others?
 I think this will be possible once the changes here are hashed out: https://github.com/Microsoft/TypeScript/issues/6508 . They are solving some angular-2-specific problems that should also make it easier to typecheck `.marko` files, since they are pretty similar in structure.    @Hurtak this isn't actually a problem Marko can solve since putting dynamic values inside a `<script>` block is inherently unsafe. Wherever you are allowing user data to be inserted into a script block you should be using `JSON.stringify()` to ensure that it is only data and not code:

``` xml
<script>var x = $!{JSON.stringify(data)}</script>
```

In this case, HTML escaping is disabled because encoded HTML entities are not decoded if they are inside `<script>` tags.

However, if the stringified data contains an ending `</script>` tag then that will prematurely end the `<script>` block so you need to do the following:

``` xml
<script>var x = $!{JSON.stringify(data).replace(/<\//g, '<\\u002F')}</script>
```

With that said, using `<script>` tags with dynamic code is still very dangerous. It's best to put user data into DOM attributes so that it is guaranteed not be executed. For example:

``` xml
<div data-foo=JSON.stringify(data)>
```

The data can then be extracted from the DOM using code similar to the following:

```
var foo = JSON.parse(el.getAttribute('data-foo'));
```

I'm going to close this issue because it doesn't require any changes to Marko, but we should probably put together a more complete security guide.
 @Hurtak also, if you have any thoughts or suggestions on how we might be able to avoid the security problems associated with `<script>` tags please share. If we can provide a helper of some sort then that might not be a bad idea.
 @Hurtak The `escapejs` filter that django provides is a little odd since it assumes that the character being escaped inside a JavaScript string, but after giving it some thought that's probably an okay assumption. I think I'm coming around to escaping special HTML characters using the JavaScript string escape sequence in the  context of a `<script>` block. It's definitely better than the current code that escapes special HTML characters inside `<script>` blocks using HTML entities which is absolutely not what we want.

For example, given the following template:

``` html
<script>
    var foo = ${JSON.stringify(data.foo)};
</script>
```

And the given data:

``` javascript
{
    foo: {
        name: 'Evil </script>'
    }
}
```

The output is currently the following:

``` html
<script>
    var foo = {"name":"Evil &lt;/script>"};
</script>
```

(browsers do not decode HTML entities inside `<script>` blocks... `<script>` tags are special)

The output should be the following:

``` html
<script>
    var foo = {"name":"Evil \u003C/script>"};
</script>
```

I'm going to reopen this issue and investigate a proper fix. Thanks for opening this issue and thank you for your persistence :)
 New version published: `marko@3.7.1`

See [CHANGELOG.MD](https://github.com/marko-js/marko/blob/master/CHANGELOG.md#371) for a longer description of what exactly changed: 
 @yomed 

> With this fix in place, is there still any reason to avoid putting data in inline scripts? 

This was done in preparation for support CSP. However, as long as we put a CSP `nonce` attribute on the inline `<script>` tag then we are still able to use inline `<script>` tags. In a future version of Marko Widgets we plan on switching to using `<script>` tags to pass data down to the browser for performance reasons. So to answer your question, no, there is no good reason to avoid putting data in inline script tags.
  Looks good. Thanks!
  Thanks for the improvement! New version published with fix: `marko@3.6.2`

Please let me know if you see any other issues. Thanks, again.
  Hey @thomastorfs, thanks for reporting the problem. I'm going to see if I can reproduce, but if you could provide more details that would be great.
 I suspect you are seeing this issue because there are multiple instances of `marko` being loaded at runtime and each instance is being configured independently. This could happen if you have different versions of `marko` being used in your project and that would prevent de-duping from happening when installing the node modules. Do you see multiple lines for `marko` when you run `npm list`?

In either case, I decided to make the Marko configuration a true "singleton" by attaching it to the global scope. This may or may not solve your problem depending on which versions of `marko` are being loaded in your project, but once you are using only the latest version then it should fix the issue in the situation that there are multiple instances of marko being loaded.
 @thomastorfs @aaronshaf would either of you be able to share a minimal project to reproduce the problem? I was not able to reproduce the problem. Thanks!
 @jasonmacdonald thanks for digging in and figuring out the issue. I don't see any harm with passing along the configuration provided when calling `require('marko/node-require').install({config...})` to `require('marko/compiler').configure(...)` . This would make the configuration truly global as expected.

NOTE: You should not be referencing `global.__MARKO_CONFIG` in your code since that is an implementation detail that could change in the future.
  - Fixes #314 - Remove hyphens from include props
- Deprecated:
  - Properties passed in using the `<include>` tag should not be access using hyphens.

For example, given the following template:

``` xml
<include("./include-target.marko") first-name='Jane'/>
```

The `first-name` data should be accessed using the `firstName` property:

``` javascript
var firstName = input.firstName;
// NOT: var firstName = input['first-name'];
```
 Looks good!
  @patrick-steele-idem and I have discussed adding a tag to marko's core that handles streaming in an elegant way.

The syntax that we're looking at is the `<on>` tag:

``` xml
<ul>
    <on(user in data.usersStream)>
        <li>${user.name}</li>  
    </on>
</ul>
```

We'd also support a more verbose syntax for generic EventEmitters:

``` xml
<on('data' as user in usersStream until 'end')>
```

> **Note:** `<for(x in stream)>` was considered, but it would complicate the looping logic of regular for loops and require the stream logic to be present even for templates that never make use of it.  We need something that is syntactically different so we can distinguish at compile time.
> 
> **Note 2:** we also considered `<for-async(x in stream)>` and `<for await(x in stream)>` however `<on>` has the benefit of making sense when used with any EventEmitter.

In many ways, the `<on>` tag will be similar to the `<await>` tag ([previously `<async-fragment>`](https://github.com/marko-js/marko/pull/312)), however the `<on>` tag will also flush multiple times throughout it's rendering cycle.

There is a tradeoff to consider around flushing.  If we flush after each iteration, content will be pushed to the browser sooner, but if we buffer a few iterations and gzip is enabled, the resulting payload will be smaller.  We need a good default for flushing and an easy, intuitive way to configure it.  

We also need to figure out what should be provided by the tag, and what interesting use cases we want to support.  One that comes to mind immediately is infinite scrolling.

All that said, here is my proposed set of attributes for the `<on>` tag:
- `@var` - parsed from the argument, the variable to be used inside the body of the tag
- `@event` - parsed from the argument, the name of the event to listen to, defaults to "data"
- `@endEvent` - parsed from the argument, the name of the event that signifies the end of the loop, defaults to "end"
- `@data-provider` - parsed from the argument, the stream or emitter we're listening to
- `@name` - the name of the `<on>` tag.  used for debugging and the `show-after` attribute
- FUTURE: `@client-reorder` - the `<on>` tag will not block the rest of the page, JS is required on client
- FUTURE: `@show-after` - when `client-reorder` is set to true then displaying this instance's content will be delayed until the referenced `<await>` or `<on>` instance is shown.
- ~~`@buffer-count` - how many iterations of the `<on>` tag to buffer before flushing~~
- ~~`@buffer-duration` - if the time since the last flush is greater than the buffer duration, then the `<on>` tag will flush its buffer, regardless of the current buffer count~~
- `@timeout` - if the time since the last chunk of data was emitted is greater than the timeout, then the `<on>` tag will timeout
- ~~`@total-timeout` - if the time since the rendering started is greater than the total timeout, then the `<on>` tag will timeout~~
- `@error-message` - a message that is shown if the stream emits an error
- `@timeout-message` - a message that is shown if the stream times out
- FUTURE: `@placeholder-message` - a message that is shown while the `<on>` tag is streaming
- `@empty-message` - a message that is shown if the stream ends without emitting data
- `@finish-message` - a message that is shown when/if the stream completes successfully

Also, we'll provide `<on-placeholder>`, `<on-error>`, `<on-timeout>`, `<on-empty>`, and `<on-finish>` as alternatives `*-message` attributes.
 **Example time:**

Let's say we want to create a list that has a few users in it and a button to load more users.  Those users come from some service call.  With `<await>` we'd do something like this:

``` xml
<await(users from data.usersProvider) client-reorder>
    <await-placeholder>
        <card>
            <loading-indicator/>
        </card>
    </await-placeholder>
    <for(user in users)>
        <card>
            <img src=user.avatar />
            <info>
                <name>${user.name}</name>
                <handle>${user.handle}</handle>
            </info>
        </card>
    </for>
    <button>load more</button>
</await>
```

In this case, the placeholder card would spin until the data gets back from the service call, then we render the user cards and load more button and replace the placeholder with these.

With `<on>` and a stream, we could do this instead:

``` xml
<on(user in data.usersStream) client-reorder>
    <on-placeholder>
        <card>
            <loading-indicator/>
        </card>
    </on-placeholder>
    <card>
        <img src=user.avatar />
        <info>
            <name>${user.name}</name>
            <handle>${user.handle}</handle>
        </info>
    </card>
    <on-finish>
        <button>load more</button>
    </on-finish>
</on>
```

In this case, the placeholder would spin until all user cards have loaded.  As each user is emitted by the stream, a user card would be rendered and inserted right before the loading card.  Once all user cards were loaded, the load more button would be displayed and the placeholder removed.

Here's a [mockup](http://output.jsbin.com/nikifen) of the difference.
 More thoughts:

It might be useful be able to see what iteration you're on like the `<for>` tag's  `status-var`.
- Each time through the status var would contain the current iteration: `0, 1, 2, 3 ...`
- On the `end` event the status var would contain the number of iterations, similar to the way things work in a native `for` loop:

``` js
for(var i = 0; i < array.length; i++) {
    console.log(array[i]);    
}
assert(i === array.length);
```

This could be used to: 
- show a different `timeout-message` or `error-message` base on whether any data had already been rendered:

``` xml
<on(user in data.usersStream | status-var=loop)>
    <on-timeout>
        <if(loop.getIndex() > 0)>
            We timed out, but at least we got some data!
        </if>
        <else>
            We timed out and got nothing...
        </else>
    </on-timeout>
    ${user.name}
</on>
```
- In the same way, it removes the need for `empty-message`
 This sounds great! We would be able to use this right away. We're basically doing this manually in a renderer.js file ourselves now, but this is much cleaner and doesn't require us to expose all the `out.beginAsync` stuff to create our own stream.

Are there any strong feelings in making this a separate tag? Would it make sense to just have `<await>` accept a stream in addition to promises and callbacks? Or does that have mostly to do with the terminology of await in ES2017? @scttdavs The main difference, is in passing a stream to `<await>` you would need to buffer the stream until it completes, where as `<on>`'s body would be called every time a `data` event was emitted from the stream and could flush out multiple times.

I actually just [threw something together](https://github.com/mlrawlings/marko-on-tag) this afternoon because another team at eBay was asking about this.  It doesn't have any of the timeout/placeholder/buffering/flushing/etc. in place, but it's a good starting point.

I probably won't have time to revisit this for a little while, so if you're interested in working on this, that would be awesome!

/cc @rajaramu (on the aforementioned team at eBay) I think there's enough differences between handling a `Promise` vs a `ReadableStream`/`EventEmitter` that it makes sense to keep the tags separate and I think it will make things less confusing and easier to document. I could be wrong though and I might be convinced that `<await>` could be extended to support both a Promise that gets flushed once when resolved versus a `ReadableStream`/`EventEmitter` that will flush for every event. We still need to finalize this proposal before doing any work so if you have any thoughts on usage please share. I kind of like that implementation too. One concern I would have is that there's no clear way to use `<on-finish>` from Michael's example (or any of the other sub-tags).

I think `<on-finish>`, in particular, is important because given his example linked above, the one of a `load more` button below the users. What if it is not known whether there are more users to load until data from the stream comes in? In which case you may need a `load more` button or may not. So being able to render it after the steam ends when that information is available would solve that. I'll throw out another proposal:

```xml
<ul>
    <await(data.usersStream)>
        <on('data' as user)>
            <li>${user.name}</li>  
        </on>
    </await>
</ul>
``` @mlrawlings @philidem @tindli @austinkelleher @Hesulan @scttdavs  should we go forward with using `<await>` with nested `<on()>` tags (see above)? @patrick-steele-idem - I like that syntax a lot. @patrick-steele-idem I like the new proposal, especially reusing with `<await>` since the use cases seem so similar. So given that example and the new nested tag feature (which is done now?), would it look like:
```html
<ul>
    <await(data.usersStream)>
        <@on('data' as user)>
            <li>${user.name}</li>  
        </@on>
        // how is content here handled?
    </await>
</ul>
```
I also had a question in the comment above^ There's the potential argument against `<@on>` because it would need to be transformed:

`<@on('data' as user)>` would get transformed to `<@on(user) event='data'>` which would generate code like:
```js
{
    on:[{
        event:'data',
        renderBody:function(out, user) {
            out.w('<li>'+escapeXML(user.name)+'</li>';
        }
    }]
}
```

@scttdavs The rules around content outside `@` tags is a little weird...  Anything outside an `@` tag will come through as `input.renderBody`, except if there are dynamic `@` tags in which case `renderBody` is run and the `@` tags register themselves on the parent and in that case, no content output is allowed in the `renderBody`.

In the case of the `<await>`/`<@on>` combination, `renderBody` would _not_ be called.  We should probably thrown an error in that case.  _This:_

``` xml
<async-fragment data-provider=data.userDataProvider var="user">
    Hello, ${user.name}
</async-fragment>
```

_becomes this:_

``` xml
<await(user from data.userDataProvider)>
    Hello, ${user.name}
</await>
```

**Tag changes:**
- `<async-fragment>` => `<await>`
- `<async-fragments client-reorder/>` => `<await-reorderer/>`
- `<async-fragment-placeholder>` => `<await-placeholder>`
- `<async-fragment-timeout>` => `<await-timeout>`
- `<async-fragment-error>` => `<await-error>`

A transform is provided that will transform the async-fragment versions of these tags to the await version, so nothing will actually break, but a deprecation message will be logged to the console during template compilation.

This is primarily a syntax change.  All tag attributes remain the same, except that `var` and `data-provider` are now specified in the `<await>` tag's argument.

**Event changes:**
- `asyncFragmentBegin` => `await:begin`
- `asyncFragmentBeforeRender` => `await:beforeRender`
- `asyncFragmentFinish` => `await:finish`
- `asyncFragmentClientReorder` => `await:clientReorder`

The async-fragment versions of these events are still emitted, so as to not immediately break modules that make use of these events.  Those libraries should begin to migrate as we'll likely remove the duplicate events at some point.
 I forgot to mention:

Currently, the output JS looks something like this:

``` js
//...

      await = __loadTag(require("../../../../taglibs/async/await-tag"));
//...
      await({
          dataProvider: data.userDataProvider,
          _name: "data.userDataProvider",
          renderBody: function renderBody(out, user) {
             out.w("<div class=\"foo\">Hello,  "+escapeXml(user.name)+"</div>");
          }
      }, out);
//...
```

and while this actually works, I'm not thrilled about `await` being used as a variable/function name.

We could probably utilize a [list of reserved words](https://gist.github.com/mlrawlings/724cc0c3bd4635b7f6541df9526fd084) and append `Tag` to custom tags that match an item in that list.  In this case we'd have `awaitTag({}, out)`.
 Very nice and much cleaner. Thanks for working on this! The only thing that kind of bothers me is the `from` keyword...it works, but just want to make sure we explore all syntax options, what are your thoughts on reversing the syntax?:

``` xml
<await(data.userDataProvider as user)>
    Hello, ${user.name}
</await>
```

I read that as "await on `data.userDataProvider` and store the result as the `user` variable". It also is a little closer to the actual JavaScript syntax where `await` is in front of the expression that produces the `Promise`:

``` javascript
var user = await data.userDataProvider;
```

(of course, in JavaScript the variable is on the left hand side...)

I could probably go either way, but just wanted to throw the alternate option out there.

What do you think?
 Both make sense when you read them as a sentence:

```
await user from theUserDataProvider
```

```
await theUserDataProvider as user
```

`from` has the benefit of the variable name being to the left of the statement, which is closer to for loops and assignments, where as `as` has the benefit, as you said, of keeping `await` closer to the provider that it is awaiting which is how it's done in JS.

I'm kinda leaning towards `from`, but it may be just 'cause it's what I've had in my head while thinking about this... what does @tindli, @philidem, and the rest of the community think?

`as` _is_ two characters shorter than `from`...  
 So after thinking about this a bit more, I've come to the conclusion that I'm not so much awaiting the promise, because I already have the promise.   I'm awaiting what I get when the promise is fulfilled.  

In our example, the `userDataProvider` is just an means to an end.  The only reason I care about the `userDataProvider` is that it will eventually give me the `user`.  The `user` is what I really want.  I am awaiting the `user`.

If I could, I'd simply write

``` xml
<await(user)>
```

But that doesn't give enough information.  `<await>` doesn't know where the `user` comes `from`.

``` xml
<await(user from userDataProvider)>
```

Ah. Okay, it comes `from` the `userDataProvider`. Now `<await>` can get me my user.

---

Also, all feedback has either been neutral or in favor of the `from` syntax.

Let's go with `from`.
 @mlrawlings 

> Let's go with `from`.

Sounds good to me. I'll be spending a little more time reviewing and will publish a new version soon. In the meantime, would you be interested in updating the migration tool to migrate to the new await syntax from Marko v2? We should also consider making the migration tool a little smarter to look at the version of `marko` installed to determine how the code should be parsed and migrated.
  Hey @darkwebdev, just wanted to say that I haven't had a chance to investigate since I was out of the office this past week. I hope to investigate this a little later this week. Thanks for reporting the problem and thanks for your patience!
 Fixed. See: https://github.com/marko-js/marko-widgets/issues/153

Thanks for reporting the problem!
  Great. Thank you!
  Thanks for the improvement, @oxala! New version published: `marko@3.5.0`

If you get a chance, do you mind updating the following docs?: https://github.com/marko-js/marko/blob/master/docs/custom-taglibs.md 

Thanks, again
  Only set `prevClassName` when the `className` has been pushed to `finalClassNames`, otherwise future `className` values will be appended to a class that doesn't get included in the final output.  This effectively limits the number of classes to 2.
 Thanks for the fix! New version published: `marko@3.4.9`
  An attribute value needs to always follow the rules of JavaScript parsing. Unfortunately, that does introduce some deviation from the HTML spec. However, Marko is not using an HTML parser, but rather the [HTMLJS](https://github.com/philidem/htmljs-parser) parser, and the HTMLJS parser always parses an attribute value as a JavaScript expression. We would not want to special case various attributes since that would makes things problematic.

It might be helpful to think of it has having to write JavaScript code to set an HTML value:

``` javascript
var input = document.createElement('input');
input.setAttribute('pattern', '[\\w0-9]+'; 
// Note that the backslash character needs to be escaped.
```

Hope that answer satisfies your issue, but please let me know if not.
 > I understand the underlying issue. But my opinion is that when writing HTML within the template we shouldn't have to remember "no, this isn't really HTML, it's an escaped JavaScript string."

I definitely understand where you are coming from. To keep things simple we want to only support one way of parsing things and found that JavaScript expressions were a much better fit for attribute values. The only thing that you need to remember is that the right-hand side of an attribute value is always a JavaScript expression (at least it is consistent).

> I think a solution to this, and probably other cases, would be to have a <raw></raw> Marko directive.

We could, in theory, introduce a new syntax to break out of the rules of standard JavaScript parsing for an attribute value to support a "raw" value, but that would introduce more complexity and likely very little gain. Hypothetically, we could support triple quotes (borrowed from CoffeeScript) or something random:

``` xml
<input type="text"
           name="username"
           placeholder="username"
           spellcheck="false"
           autocomplete="off"
           autocorrect="off"
           pattern="""[\w0-9]+""">
```

Do you think that is worth considering? I'm leaning towards no, because I want to keep the syntax rules simple, but I am open to the idea if there is enough interest.
 /cc @philidem @mlrawlings @tindli Thoughts?
 I'm not sure adding something that deviates further from html (`=!` or anything else) to get back to html really makes sense.  

My biggest concern is that someone new to marko may not realize wha the issue is with the error presented.  Given that it's a pretty standard js error maybe this isn't really a concern.  It might be worth it if we could point out this difference in parsing when it comes up though.

I do understand not wanting to double escape.  It's a pain when you have to use strings to pass to `new RegExp()` too.  For this specific case, I think it would be nice to be able to use a js regex as the value (we'd have to remove the beginning and ending `/` after calling `.toString()`) :

``` coffeescript
<input pattern=/[\w0-9]+/>
```

Are there other attributes other than `pattern` that might parse unexpectedly?
 If we want to change the way strings are parsed, the only thing I think we should consider is changing the default.  The only change worth making is one that allows you to paste in valid HTML without any changes, otherwise it's easier to explain "strings are JS strings" rather than introducing additional syntax.

However, I'm not sure this is a good idea.  As to what other attributes this might affect, I guess the better question is where does the HTML attribute string spec deviate from the JS string spec?  Is it just that `\` needs to be escaped or are there other differences?
 One (probably bad) thought: attempt to parse as JS value, and if that fails, fall back to the HTML way of parsing attributes.
  - Adds additional event info (finished/timedout) to the data emitted from <async-fragment> tags. 
- Ensures that renderBody() is not called again if the fragment has already finished (timed out).
- Fixes `npm run test-async`
- Removes a redundant `async-fragment` timeout related test
 Thanks for the PR! New version published with fixes/improvements: `marko@3.4.7`

Still need to back port to Marko v2
 Fix back ported to Marko v2. New version of Marko v2 published: `marko-async@2.2.2`
  Thanks for reporting the problem. New version published with fix: `marko@3.4.5`

Please let me know if you still see any issues. Thanks!
  Adds coverage reporting through istanbul and coveralls.  We'll need to set up marko on [coveralls](https://coveralls.io/), but it's a pretty painless process.
 Awesome! Thank you for taking the time to do that. I have finished setting up coveralls and now we have a working badge. Thanks again!

> Did you consider using `--include-all-sources` in the istanbul command for coverage against the whole codebase?

@yomed: Would you be interested in trying that out to see if it makes the coverage more accurate?
  Thanks for the PR @mlrawlings!

New version published with improvement: `marko@3.4.2` 
  Hey @cantoine, loaded templates are stored in the Node.js require cache. Marko supports hot reloading functionality, but you need to provide a file watcher or use [browser-refresh](https://github.com/patrick-steele-idem/browser-refresh). I recommend taking a look at `browser-refresh`, you will get hot reloading for free on the server and in the browser if you launch your app using `browser-refresh`. If you don't want to use `browser-refresh`, please see the following sample app:

https://github.com/marko-js-samples/marko-hot-reload

Please let me know if you still have questions.
  Thanks for the fix to the docs! I'll publish a new version of the site now.
  Great, thank you! I'll publish the new docs now.
  When using <include> tag like so:

```
<include template="./deferred.marko" template-data="data" />
```

if deferred.marko has a widget bound to it in the `w-bind` attribute, the widget.js is not registered and invoked.
 I would not expect that to be the case. Would it be possible to set up a simple project to reproduce the problem? Or, could provide more details on your setup?
 @sidsakhadeo is this still an issue for you?
 Closing this issue.  If this is still an issue in v3, feel free to reopen.
  New version published: `marko@3.3.0`

Thanks!
  It doesn't look to be a problem in `browser.json`. The error is originally thrown by the html-js parser used by marko: https://github.com/philidem/htmljs-parser/blob/master/Parser.js#L51

@sanjeevashrivastava Are you using an older version of marko/htmljs-parser? I am not able to reproduce the problem using your exact template. Are you using an `npm-strinkwrap.json` that is locking your app to older versions of npm dependencies?
 That's really bizarre... That is the latest version of `htmljs-parser` and I am not able to reproduce with the exact version. Can you please attach your template file to this Github issue? I'm wondering if there are some Windows vs Unix line ending differences that are causing problems.
 I'm still not able to reproduce. It looks like the parser is reading the string too far for you (it's going past the ending quote for the string). I see no reason for this to happen and the test I added is passing...
 @sanjeevashrivastava do you mind spending some more time trying to isolate the problem? Some things to try:
- Put a space after the second double quote: `<lasso-page package-path="./browser.json" />`. Does that fix the issue?
- Reduce the template to the following to see if it still fails:

``` xml
<lasso-page package-path="./browser.json"/>
```
- Do you have a different `marko.json` file in the `views/admin` folder that might be causing issue? If so, can you remove that `marko.json` to help isolate the issue?

Finally, what version of `lasso` do you have installed?
 Thanks for the details. I was able to reproduce the issue using the uploaded file. I should be able to figure it out this morning now that I can reproduce. I'll update when I know more.
 Just an update. I found the issue. The htmljs-parser is not handling a [byte order mark (BOM)](https://en.wikipedia.org/wiki/Byte_order_mark) character sequence being added by your editor. BOM characters are pretty rare, but I am working on a fix to skip over those characters.

In case you are really curious, due to the BOM characters, the parser doesn't recognize the `<` character at the beginning and it is therefore parsing in concise mode. In concise mode the parser does not look for `/>`/`>` ending character sequence.
 Also, FYI:

From Wikipedia:

> The Unicode Standard permits the BOM in UTF-8, but does not require nor recommend its use. Byte order has no meaning in UTF-8.

Marko expects templates to be encoded using UTF-8. Again, we still will make the change to strip the BOM characters, but just sharing that BOM characters are not recommended in UTF-8 files.
 Fixed by https://github.com/philidem/htmljs-parser/commit/baf43d342a6263bc3955a95183a15621df767cc7

New version of `htmljs-parser` published with fix: `htmljs-parser@1.5.13`

Please let me know if you see any issues. Thanks!
  @GenaANTGOfficial when a marko template is compiled it will produce a `*.js` file next to the original file and the generation that new file is triggering a restart. The reason you are seeing the infinite restart after upgrading to Marko v3 is that Marko v3 will always recompile the template in development to avoid caching problems. You should update your `nodemon` config to ignore changes to `*.marko.js` files: https://github.com/marko-js/marko#nodemon

Or, better yet, use [browser-refresh](https://github.com/patrick-steele-idem/browser-refresh) :)
  Looks great! What are your thoughts on renaming `injectInto(express)` to `patchExpress(express)`?
 Awesome. Thank you
  I believe this is no longer needed after support for merging in `res.locals` to `out.globals` was added for Express. Closing issue.
  Good catch. Thank you for the fix!
    Thanks for the question @taecilla and thanks for the reply @davidenq! It sounds like the question was answered so I'm closing the issue. 
  Thanks for the PR but for convenience, we need to keep the docs folder as part of the npm package since the app that generates the docs for marko.json pulls in the `marko` npm package directly from npm to get the defaults. You can, of course, npm link in `marko`, but that adds a little friction. 
  Hey @bitinn, sorry for not being able to respond earlier. We definitely need to add better docs for the new syntax (we have plans to do this very soon). FYI, all of the following are equivalent:

``` xml
p - hello there, <strong>username</strong>.
```

``` xml
p
  - hello there, <strong>username</strong>.
```

``` xml
p
  ---
  hello there, <strong>username</strong>.
  ---
```

``` xml
p
  - hello there,
  strong - username
  - .
```

There are four ways to enter into HTML parsing mode:

**Option 1. HTML tag:**

```
<div>
  [this will be parsed as HTML]
</div>
```

**Option 2. HTML line after tag/attributes:**

```
div - [this will be parsed as HTML]
```

**Option 3. Single line HTML block:**

```
div
  - [this will be parsed as HTML]
```

**Option 4. Multiline, delimited HTML block:**

```
div
  ---
  [this will be parsed
  as HTML]
  ---
```

For the multiline, delimited HTML block, the delimiter just needs to be two or more characters so the following also works:

```
div
  -----
  [this will be parsed
  as HTML]
  -----
```

Sorry this wasn't explained better in the docs. Please let me know if you have any other questions. Also, please join us on Gitter if you haven't already: https://gitter.im/marko-js/marko
  Hi @jainprash, I believe that had already been fixed 12 days ago: https://github.com/marko-js/marko/issues/266

Which version of `marko` are you using?
 I believe this issue has been resolved.
  It looks like the code is being hit by the following breaking changes: https://github.com/nodejs/node/wiki/Breaking-changes-between-v5-and-v6#path

However, we shouldn't be passing in `undefined` for the path so we should fix that. I'll take a look. Thanks for reporting the problem!
 Tests for marko are passing on Node v6. Please let me know if you find any other issues. Thanks, again!
  I'm opening this issue to gauge the community's interest in a Atom plugin with advanced features that may include the following:
- [x] Smart autocompletion for custom tags and standard HTML tags ([get it](https://github.com/marko-js/atom-autocomplete-marko#marko-autocomplete-package))
- [x] Smart autocompletion for tag attributes based on tag schema files ([get it](https://github.com/marko-js/atom-autocomplete-marko#marko-autocomplete-package))
- [x] Pretty printing with syntax switcher ([get it](https://github.com/Glavin001/atom-beautify#installation))
- [x] Block commenting
- [x] Click to go to tag definition ([get it](https://github.com/marko-js/atom-hyperclick-marko#marko-hyperclick-package))
- [ ] UI component generator
- [ ] Anything else?

The more developers that are interested will help us make a stronger case for investing in this functionality.

Related issues:
- [WebStorm plugin](https://github.com/marko-js/marko/issues/272)

(I'll open a similar Github issue for Sublime Text and Visual Studio Code)
 Hey @BryceEWatson, thanks for working on the generator/scaffolding functionality. I like the setup, but I think we need to offer more flexibility and possibly provide the ability for the developer to provide their own "component template directories". As an example, not every developer is going to use `.less`. Also, I think we can simplify the code if we just provide a way to copy a directory tree while doing variable replacement (in files and in filenames, and possibly supporting conditional files as well).

As much as I dislike Yeoman, it might be worth providing Yeoman generators and piggy backing off [atom-yeoman](https://atom.io/packages/atom-yeoman).

Another option is to build a new, generic "Generator" plugin for Atom (independent of Yeoman) and there also be "Generator Provider" plugins. We could then provide a Generator Provider plugin for Marko, but other developers could publish their own. It's possible that something like this already exists, but I haven't seen it.

Thoughts?
 @Eldar-X I took on the challenge and we now have support for tag matching and synchronized editing of opening and closing tags in Atom: https://github.com/marko-js/atom-language-marko#tag-matching

There was some learning along the way, but it was a much more difficult task than expected (lots of edge cases), but I am very happy with the end result. You owe me a beer :)

As a side note, we have merged all of the Atom plugins ([atom-language-marko](https://github.com/marko-js/atom-language-marko), [atom-autocomplete-marko](https://github.com/marko-js/atom-autocomplete-marko) and [atom-hyperclick-marko](https://github.com/marko-js/atom-hyperclick-marko)) into the main [atom-language-marko](https://github.com/marko-js/atom-language-marko) package. The other packages are now deprecated and they were made into no-ops (feel free to uninstall `autocomplete-marko` and `hyperclick-marko).

Please let us know if you see any issues.
 @tinovyatkin, Patrick and I are not planning on picking up a VS Code plugin in the near future, but @pcanella mentioned he might be interested in working on one.
 @tinovyatkin I did take a look into what it would support autocomplete with VS Code and it wasn't too bad. The main difference between VS Code and Atom is that the autocomplete functionality is required to be provided as a separate process. But as @mlrawlings said, we don't plan on working that in the near future. At the moment we are busy preparing for the next major release of marko (development is happening on master).
  I'm opening this issue to gauge the community's interest in a WebStorm plugin with advanced features that may include the following:
- [ ] Smart autocompletion for custom tags and standard HTML tags
- [ ] Smart autocompletion for tag attributes based on tag schema files
- [ ] Pretty printing with syntax switcher
- [ ] Block commenting
- [ ] Click to go to tag definition
- [ ] UI component generator
- [ ] Anything else?

The more developers that are interested will help us make a stronger case for investing in this functionality.

Related issues:
- [Atom plugin](https://github.com/marko-js/marko/issues/273)

(I'll open a similar Github issue for Sublime Text and Visual Studio Code)
 > Also a default widget component files generator via right-click would be nice.

Great suggestion @wmossman. I'll update the description to include that. Thanks!
 @yask123 So far, most of our tooling effort has been focused around the atom editor (see #273).  We've not got WebStorm on our roadmap right now, and we don't have a lot of expertise with the java-based IntelliJ plugin system.  

Our hope is that a developer that is familiar with the WebStorm ecosystem could look at the atom implementation to add support for WebStorm.
 @davidmoshal Thanks for pointing this out, I believe that _is_ intentional as we don't have a true webstorm integration, but webstorm [can import tmbundles](https://www.jetbrains.com/help/webstorm/2016.3/importing-textmate-bundles.html).  We should definitely make this clearer on that page.  Thanks for reporting the problem @CestDiego. That would be a typo. In the upper right of the page you will see a "Improve this page" link. That will take you to the source markdown file if you want to clean it up. I would just remove the `var style = ;` line. If you don't have time to send a PR please let me know, but a PR would be greatly appreciated. Thanks again! 
  Hi, I have a question regarding to the usage of macro for marko@v3. I defined the following macros in `helpers.marko` and want to use it in another file. For example,

helpers.marko

```
<macro csrf-meta-tags(csrf)>
    <meta content=csrf name="csrf-token">
</macro>

<macro javascriptIncludeTag(src)>
    <script type="text/javascript" src=src></script>
</macro>
```

I want to use it in `application.marko`. How can I do this? I tried the include but it didn't work for me
 Just found out this http://markojs.com/docs/marko/custom-taglibs/
 Sorry, to reopened this again. I have some questions regarding to the usage of macro in multiple files. What is the benefit of using macro over custom-taglibs? Also for template inheritance like layout-taglib, how can I the layout can understand the data from current template?

For example,

index.marko

```
<layout-use("./layout.marko")>
    <layout-put into="title">My Page</layout-put>
    <layout-put into="body">BODY CONTENT</layout-put>
</layout-use>
```

layout.marko

```
<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title><layout-placeholder name="title"/></title>
</head>
<body>
    <p>
        <layout-placeholder name="body"/>
        <custom-tag env=data.env />
    </p>
</body>
</html>
```
 If I run `marko.load('index.marko').stream({ env: 'production' })`, the layout.marko will not understand data.env right?
 Hey @hung-phan, sorry I wasn't able to respond earlier.

A macro is just inline include/partial that can only be used within the current template.

An include is a partial that is separated to a separate file so that it can be used by other templates.

A custom tag is a more powerful version of an include that allows some JavaScript code to act as the "rendering controller" for the custom tag. In addition, a custom tag can be mapped directly to a template. Custom tags also have the benefit that they are easier to use since they get registered with a tag name.

A layout is just a reusable template that has placeholders

Here's some guidance on deciding when to use what:
- Use a macro if you need to repeat some HTML within the same template
- Use an include if you need to break up a template into multiple templates and all of the files are closely related and in the same directory.
- Custom tags are almost always a better option than includes since they are the most flexible and offer better encapsulation of rendering logic. 
- Use a layout template when you have multiple pages or components that share a common layout/structure

> Also for template inheritance like layout-taglib, how can I the layout can understand the data from current template?

You an pass data to a layout template as the second argument to the `<layout-use>` tag (see http://markojs.com/docs/marko/layout-taglib/#layout-data):

``` xml
<layout-use("./layout.marko", { foo: 'bar' })>
    <layout-put into="title">My Page</layout-put>
    <layout-put into="body">BODY CONTENT</layout-put>
</layout-use>
```

The data object passed in as the second argument will be available in the layout template as part of the `data` object (e.g. `data.foo`).

> If I run `marko.load('index.marko').stream({ env: 'production' })`, the `layout.marko` will not understand `data.env` right?

You should use sparingly, but you can pass "global" data that is available to all templates. See: http://markojs.com/docs/marko/language-guide/#global-properties

Therefore, you can do the following:

``` javascript
marko.load('index.marko').stream({
    $global: {
        env: 'production'    
    }
})
```

Global data is available in all templates (even templates for custom tags) or wherever you have access to the `out`. For example: 

``` xml
<span>The current environment is ${out.global.env}</span>
```

Hopefully that answers your questions, but please let me know if you need more clarification. I'm going to go ahead and close the issue, but please feel free to reopen or add more comments here and I will take a look.
 It did resolve my problem. Thanks @patrick-steele-idem.
 @hustcer creating a custom tag is as simple as creating a `template.marko` file. 

For example:

`src/components/app-my-helper/template.marko`

``` xml
<div>
  Hello ${data.name}!This is my awesome helper.
</div>
```

That's all that is required to create a custom tag. No other files are required.

The custom tag can then be used in any directory at or below the `src/` directory. For example:

`src/pages/home/template.marko`:

``` xml
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>Hello</title>
    </head>
    <body>
        <app-my-helper name="Frank"/>
    </body>
</html>
```

For more details: http://markojs.com/docs/marko/custom-taglibs/#scanning-for-tags
  @1N50MN14 The `w-preserve-attrs` attribute only works on standard HTML elements (not custom elements). You should, instead, be adding the `w-preserve-attrs` attribute to the root HTML element in the template for the `<mywidget>` UI component. Please let me know if that does or does not solve your problem.
 I believe this is a non-issue so closing. Please reopen if I am mistaken. Thanks.
  @Bluejay47 when I try to compile your exact template I get the following error:

```
An error occurred while trying to compile template at path ".../template.marko". Error(s) in template:
1) [.../template.marko:2:4] Line has extra indentation at the beginning
```

Which is what I would expect. The `<html>` tag should not be indented. The following compiles with no issue:

``` xml
<!DOCTYPE html>
<html lang="en">
    <head>
        <title>Estimake.co</title>
        <include template="./partials/includes.marko" />
        <link rel="stylesheet" type="text/css" href="editProject.css">
        <script src="editProject.js" type="text/javascript"></script>
    </head>
    <body>
        <include("./partials/menu.marko", data)/>
        <include("./partials/footer.marko")/>
    </body>
</html>
```

Please let me know if I am missing anything.
 Indentation only matters for top-level HTML elements. Once you are within an HTML tag, the indentation does not matter as long as you are not using the concise syntax.

Do you mind messaging me on Gitter to help debug your issue? I am not able to reproduce. https://gitter.im/patrick-steele-idem
  We need to use relative URLs so that docs will be correct on different branches. Thanks.
  Hey @christensson, in Marko v3 we dropped support for `$<var_name>` (without the curly braces). Therefore, you don't need to escape the `$`, but does seem odd that having `\$` in the attribute is causing a syntax error. I'm looking into it. Thanks for reporting the problem.
 Ok, I took a closer look. It's not actually a bug in Marko. The right-hand side of an attribute is parsed as  a JavaScript expression and the string definition must follow the rules for defining a JavaScript string.

If you run the following code in your JavaScript console you will see the same error:

``` javascript
JSON.parse('"\\$foo"');

// Output in Chrome/V8: SyntaxError: Unexpected token $(â€¦)
// Output in Firefox: SyntaxError: JSON.parse: bad escaped character at line 1 column 3 of the JSON data
```

With that said, I think we can improve the error message and we definitely need to fix `marko-migrate`. I'll keep working on on this. Thanks again.
 By the way, if you want to fix your template you should update it to the following:

``` xml
<li data-bind="\\$foo" for(color in data.colors)>
```

(with JavaScript, you need to escape the `\` if you want it to show up in the output)

I'm still working on updating `marko-migrate`, but I have improved the error message produced by the parser.
 I see. I will update `marko-migrate` to ensure the following:

Input Marko v2 template:

``` xml
<div class="\$foo"></div>
```

Output Marko v3 template:

``` xml
<div class="$foo"/>
```

Thanks for clarifying.
 Still investigating and adding more tests. It appears there might be some other issues that I need to resolve.
 Took a little more thought than expected, but the `marko-migrate` script has been updated to properly handle backslash characters in front of placeholders. If you would like to try the migration again, please install the latest version of `marko-migrate`:

``` bash
npm install marko-migrate@^1.0.13 --global
```

Please let me know if you still see issues. Thanks!
  Thanks for reporting the problem. I'm looking into it.
 @lohfu I was not able to reproduce the problem using a fresh `npm install`. I tried to recreate your setup and the template is compiling as expected:

``` javascript
function create(__helpers) {
  var str = __helpers.s,
      empty = __helpers.e,
      notEmpty = __helpers.ne,
      escapeXml = __helpers.x,
      loadTemplate = __helpers.l,
      navigation_template = loadTemplate(require.resolve("./components/navigation/template.marko"));

  return function render(data, out) {
    navigation_template.render({}, out);
  };
}

(module.exports = require("marko").c(__filename)).c(create);
```
 Hey @lohfu, just wanted to check in and see if you were able to reproduce. Thanks. 
 Thanks for creating the repo... I was able to reproduce the problem and am looking into it this morning. I'll update when I know more. Thanks again.
 Hey @lohfu, I realized later that I was trying to reproduce the problem using the `<include>` tag. Once I saw that you were using a custom tag mapped to a template it was easy to reproduce and easy to fix. Technically, everything was working as expected, but it would cause problems if a transform was looking at the file extension for the `require`/`require.resolve` path and not the fully resolved path. 

Anyway, the problem was fixed. New version published: `marko@3.1.5`

Please let me know if you see any other problems. Thanks!
  Thanks for the improvements! New version published: `marko@2.10.0`
  New version published with fix: `marko@3.0.7`

Please let me know if you still see issues.
  Could you provide more details on the directory structure? It looks like `<customTag2>` is not being discovered relative to the location of the `customTag/template.marko`. Are `<customTag>` and `<customTag2>` registered in the same package? Where is your `marko.json` relative to `customTag/template.marko` and `customTag2/template.marko`? 
 That does look pretty simple. The names of the custom tags are case-sensitive. If the directory name is "CustomTag2" then the custom tag will be `<CustomTag2/>`. Is that possibly the reason that `<customTag2>` is not being found?
 I'm not able to reproduce using the following sample app:
https://github.com/patrick-steele-idem/marko-issue-259

Do you see any differences between your app and the sample app I created?
  Proposal:

``` xml

<!-- marko-concise attribute: -->
<ul marko-concise>
  li.foo - Red
  li.foo - Green
  li.foo - Blue
</ul>

<!-- <marko-concise> tag: -->
<ul>
  <marko-concise>
    li.foo - Red
    li.foo - Green
    li.foo - Blue
  </marko-concise>
</ul>
```

In both cases, output should be:

``` html
<ul>
  <li class="foo">Red</li>
  <li class="foo">Green</li>
  <li class="foo">Blue</li>
</ul>
```
 @philidem any update on this?
 The fix for this wasn't as straight-forward as I had first thought and I haven't had a chance to revisit it lately.
  I agree with you both that this is needed. I will create a repo with a few links as a starting point and add more links as I find them and hopefully others can help make it better as well.

I'm also going to push our product teams at eBay to work on some blog posts that share how we are using Marko and Marko Widgets at eBay. It will take a little longer, but I also want to gather some numbers on how many UI components our teams have created (there's a lot) so that people will better idea how heavily Marko is being used at eBay. Teams have also done some interesting things with Lasso.js as well to create webapps that have specialized content for various devices. I'll definitely keep this issue open and hopefully will have something to show very soon.

Thanks!
 That would be really awesome @regiellis. I feel like if we just can get a few people blogging, then that would help a ton with awareness. If you want, I would be happy to review any early drafts :) 
  ``` xml
<!-- you're doing something like this: -->

<macro myMacro(label)>
    <h1>${label}</h1>
    <div w-body/>
</macro>

<div w-bind if(data.rootTagName === 'div')>
    <myMacro label="Hello World"/>
</div>
<span w-bind if(data.rootTagName === 'span')>
    <myMacro label="Hello World"/>
</span>
<p w-bind else>
    <myMacro label="Hello World"/>
</p>

<!-- try this instead: -->

<${data.rootTagName} w-bind>
    <h1>${label}</h1>
    <div w-body/>
</>
```
 I also investigated this issue and while I think we could make it work, it would complicate the code for an edge case. The workaround that @mlrawlings suggested above should work so I'm going to go ahead and close this issue.
 Hey @tbashor, there was a bug in Marko that prevented the Marko Widgets compile-time transformers from working on tags with a custom tag name. This has been fixed:  https://github.com/marko-js/marko/blob/master/CHANGELOG.md#374

Please let me know if you still see issues. Thanks!
  @tbashor by any chance, do you have any intermediate `package.json` files? The taglib finder stops when it gets to the "root" of the package? The root of the package is determined by looking for a `package.json` file with a `"name"` property. I suspect that the search for taglibs is being ended prematurely due to the root directory not being as expected. FYI, here is the code that is used to discover taglibs for marko: https://github.com/marko-js/marko/blob/master/compiler/taglib-finder/index.js

Please let me know if that is the case. Thanks.
 @tbashor We did change the logic for discovering taglibs to address some problems. It's linked to from the [What's New in Marko v3](http://markojs.com/docs/marko/what-is-new-marko-v3/#marko-taglibjson-â†’-markojson), but here is the relevant Github issue with details: https://github.com/marko-js/marko/issues/224

From that description of what changed do you see any issue that would be impacting your project? If needed, we can always adjust things slightly, but from what I can tell your project should be fine as long as there are no additional `package.json` files that are causing the root directory to be different than one what is expected. Since your plugins have `package.json` files it seems like that might be the cause, but I don't fully understand your project structure.

If you are able to create a minimal project to reproduce the problem that would be helpful.
 @tbashor also, here are the relevant docs: http://markojs.com/docs/marko/custom-taglibs/#taglib-discovery
 Thanks for the update @tbashor. Let me know if you run into any other issues and glad to see that you have migrated to Marko v3. 
  /CC @philidem @mlrawlings 

I would like to see a method that returns a promise, but I would prefer to avoid a breaking change. The purpose of returning the `AsyncWriter` instance was to be compatible with the `EventEmitter` API (`on`, `once`, `emit`, etc.) that `AsyncWriter` implements. For example:

``` javascript
template.render({ hello: "world" })
    .on('foo', function(e) {

    })
    .on('error', function(e) {

    })
    .on('finish', function() {

    })
```

What are your all thoughts on utilizing the native promise implementation to provide a new `renderAsync` method?:

``` javascript
var template = require("template.marko");

template.renderAsync({ hello: "world" })
    .then(function (html) { ... })
    .catch(function (err) { ... });
```
 I'd rather modify `async-writer` to be a [thenable](https://promisesaplus.com/) by adding `.then` and `.catch`

I've seen other libraries such as [`superagent`](http://visionmedia.github.io/superagent/) and [`mongoose`](http://mongoosejs.com/docs/promises.html) implement a promise-like interface that plays well with anything that is duck-typing rather than looking at `instanceof Promise` (which is most everything due to things like `bluebird` and `q`).  

It would support both

``` js
template.render({ hello:"world" })
    .then(function (html) { ... })
    .catch(function (err) { ... });
```

and

``` js
template.render({ hello:"world" })
    .on('error', function(e) { ... })
    .on('finish', function() { ... })
```

And with async/await you'd be able to do:

``` js
var html = await template.render({ hello:"world" })
```

We could also implement a `.promise` function (or some other name) that returns a true `Promise` for cases where it is needed.

<details>
<summary>

Expand for possible implementation</summary>



``` js
{
    then(fn, fnErr) {
        var promise = new Promise((resolve, reject) => {
            var buffer = ''
            this.on('data', data => buffer += data)
            this.on('error', error => reject(error))
            this.on('finish', () => {
                try {
                    resolve(fn(buffer))
                } catch(err) {
                    reject(err)
                }
            })
        })
        if(fnErr) {
            promise = promise.catch(fnErr)
        }
        return promise
    }
    promise() {
        return this.then(x => x)
    }
    catch(fn) {
        return this.promise().catch(fn)
    }
}
```

</details>
 I like the suggestion to implement the `then` and `catch` methods on the `AsyncWriter` instance. Let's go forward with that approach.
 FYI: it should be sufficient to add the `then()` and `catch()` methods to [OutMixins.js](https://github.com/marko-js/marko/blob/master/runtime/OutMixins.js) since those mixins are added to both `AsyncStream` and `AsyncVDOMBuilder`
 NOTE: We want to follow the rules for having a consistent rendering API: https://github.com/marko-js/marko/issues/389

That is:

``` javascript
template.render({})
    .then(function(out) {
        out.appendTo(document.body);
    });
```
  Thanks for the improvement! I'll publish in just a bit
 New version published: `marko@3.0.3`

Thanks again.
  The user of the "data grid" component can pass a `renderer(input, out)` function associated with a UI component to the "data grid" component for use as a cell renderer:

_In JavaScript_

``` javascript
var cellRenderer = require('src/components/app-my-component').renderer;
```

Usage of the "data grid" custom tag within a template:

``` xml
<app-data-grid cell-renderer="data.cellRenderer"/>
```

Within the template for the "data grid" component, the cell renderer can be invoked similar to the following:

``` xml
<tr>
  <td>
    <invoke function="data.cellRenderer({ ... }, out})"/>
  </td>
</tr>
```

Let me know if that doesn't answer your question.
 We'll be simplifying this as part of Marko v4: https://github.com/marko-js/marko/issues/139

Closing this issue.
  Do you have any specific use cases in mind?  Would something like a Marko DevTools chrome extension be better suited for accomplishing your goals?
 Would be nice to have a convention for enabling "Marko Debug Mode". For example, via an environment variable:

```
DEBUG=marko node server.js
```

In debug mode, we could add extra information to templates. For example, What if we automatically added a `data-template-path` attribute to the root HTML element(s) of every compiled template?:

``` html
<div data-template-path="/my-project/components/foo/index.marko">
    <h1>Foo</h1>
    <div>
        <div data-template-path="/my-project/components/bar/index.marko">
            <h2>Bar</h2>
        </div>
    </div>
</div>
```

This information could be helpful to developers, but it could also be used to enable more advanced in-browser development tools.
 Comments might provide more info if say, `bar` includes `baz`:

``` html
<!-- Begin: /my-project/components/foo/index.marko -->
<div>
    <h1>Foo</h1>
    <div>
        <!-- Begin: /my-project/components/bar/index.marko -->
            <!-- Begin: /my-project/components/baz/index.marko -->
                <div>
                    <h2>Baz</h2>
                </div>
            <!-- End: /my-project/components/baz/index.marko -->
        <!-- End: /my-project/components/bar/index.marko -->
    </div>
</div>
<!-- End: /my-project/components/foo/index.marko -->
```
   Thanks @davidenq! I probably won't have a chance to take a closer look until next week, but I'm thinking we should stick with the componentized directory structure with a `src/components/` directory and a `src/pages/` directory. Thoughts?
 Thanks for sharing @jsumners, I updated the Hapi docs to correctly set the content type header: https://github.com/marko-js/marko/commit/951c0dc906677725e3083061dbd2ae2575205d2c 
 Added sample: https://github.com/marko-js-samples/marko-hapi  @felixsanz I think you should proceed with the solution that I recommended because `<marko-compiler-options>` is treated very special inside `Parser.js` and never gets added to the AST so I don't think @patrick-steele-idem's suggestion would help here. I would recommend setting some type of _flag_ to `true` to indicate that the next newline character should be discarded. The flag should be reset back to `false` after you processed the next block of character data (so that you don't inadvertently remove the wrong newline character).
  @yomed do your component files also live in a directory that matches the same name?

For example, do you have something like:
`my-widget/my-widget.marko`
`my-widget/my-widget.less`
`my-widget/my-widget.js`

I'm wondering if we should add one more convention that will check for `*.marko` file that has a filename (ignoring the extension) that matches the component directory?

Alternatively, maybe we can read this setting from the `marko.json` file (or `marko-taglib.json in v2)? Similar to how the directory that will be scanned to find components can be configured.

I use to name my component files similar to your convention but then I decided to embrace the Marko convention since it does have some nice benefits.

Specifically, I like these benefits of the standard convention:
- Easy to copy & paste a directory to "clone" an existing component (don't have to rename the individual files)
- The convention does help keep Marko projects similar to each other and each component has similar files.

The downside is that you might need to type a little extra into your IDE's search box when searching for file.

That said, I don't think we ever wanted Marko Widgets to be _too_ opinionated so I think we could consider allowing an alternative convention.

I would be interested to hear thoughts from others.
 You can create a `marko-tag.json` file with the following:

``` json
{
  "template": "./my-component.marko"
}
```

With that said, I am curious as to why you think there is less typing when navigating in your IDE. For example, in Atom or Sublime if I want to open a template file for a UI component I start typing a portion of the component name followed by a few letters in "template" or "marko" and then it will quickly take me to the template belong to a specific component (thanks to fuzzy matching). For example:
![screen shot 2016-02-28 at 8 05 29 pm](https://cloud.githubusercontent.com/assets/978214/13384825/d05606ca-de56-11e5-9e08-8958d7f2f1ae.png)

The only con that I am aware when not repeating the directory name is that Atom still doesn't differentiate the file correctly when there are multiple files with the same basename opened. I opened up an issue against Atom that is worth checking out: https://github.com/atom/atom/issues/7345#issuecomment-113577006

Also, there are good reasons to keep the main file named `index.js` so won't it look strange to have one file named `my-component.marko` and another named `index.js`? Also, repeating the directory name is not DRY and has all of the issues that @philidem mentioned.

Making the convention more flexible to allow a repeated directory name would introduce more file system checks so I would rather not go that route. We could, in theory, introduce a new setting that could be put in the `marko.json` file at the root of the project to change the convention or to allow a custom user resolver.

With that said, there are benefits to have more consistency within the community. For example, we would like to introduce more developer tools to scaffold out new UI components and we would only want to support one convention. How attached are you to repeating the directory name in each of the nested files? Like @philidem, I also started out with the repeated directory name in nested files, but I switched and I would never go back.
  I would be in favor of using the official reserved words for ES5 and beyond. However, maybe we should add a warning to discourage their usage and maybe also add an option to disable the warning? We could rely on a environment property as quick hack (which would require smaller code change).

For example, something like `MARKO_DISABLE_RESERVED_WORD_WARNING=true ./build.sh` (disable the warning and launch the build).
 That would be a bug if reserved words are not being allowed as property names. The intention was to only not allow reserved words as variable names:

``` javascript
// Should not be allowed:
var short = 'foo';

// The following should be fine though:
data.short = 'foo';
```

I'll add a test case to see if I can reproduce. If I am not able to reproduce I'll probably ask for more details.
  I realize I am slow to reply to this, but it's a little hard to say with the issue is. From what I can tell, maybe both the `renderer.js` and `template.marko` are not being found? I think I might need to take a closer a look at your code when you get a chance.
 @yomed I'm closing this, re-open it if it still needs to be addressed
  Thanks for PR, @scttdavs. I have backported the improvement to Marko v2 and published a new version: `marko@2.9.0`

Thanks again.
  Here's one proposal:

``` xml
<import-tag "component-a" as componentA>
<import-tag "component-b" as componentB>

<invoke-tag(foo ? componentA : componentB) name="Frank" count=30/>
<invoke-tag(foo ? componentA : componentB, { name: 'Frank', count: 30 })/>
```

The `<import-tag>` tag would import another tag _renderer function_ at compile time and the tag rendering function would be accessible using the provided variable.

The following would also work:

``` xml
<import-tag "component-a" as componentA>
<import-tag "component-b" as componentB>

<invoke (foo ? componentA : componentB)({ name: 'Frank', count: 30 }, out)/>
```

In either case, the compiled code would be probably be similar to the following:

``` javascript
function create(__helpers) {
  var str = __helpers.s,
      empty = __helpers.e,
      notEmpty = __helpers.ne,
      escapeXml = __helpers.x,
      __loadTag = __helpers.t,
      componentA = __loadTag(require("../component-a/renderer")),
      componentB = __loadTag(require("../component-B/renderer"));

  return function render(data, out) {
    (foo ? componentA : componentB)({
      name: "World",
      count: 30
    }, out);
  };
}

(module.exports = require("marko").c(__filename)).c(create);
```

Thoughts? Suggestions? Concerns?
 @yomed @tindli @philidem Thoughts?
 @mlrawlings I like your suggestion of using `<...>` to denote tag name and `{...}` to denote module. Hopefully it's not too clever but I'd use this feature!
 @scttdavs Resolving a custom tag is relatively "expensive" and requires reading from the file system and require calls really need to be analyzable via static code analysis so that things will work with a JavaScript module bundler. For the completely dynamic use case, it's best to use `<invoke>` and to just pass in the component renderer for each component.
 Closing this issue in favor of extending `<include>` to support rendering components/custom tags: [Issue #139: Allow dynamic custom tags to be used with `<include>`](https://github.com/marko-js/marko/issues/139)
   Thanks @yomed. We are very close to a alpha release and I'm excited for others to start using the new Marko! Still a few more tasks left before the first alpha release: https://github.com/marko-js/marko/issues?q=is%3Aopen+is%3Aissue+milestone%3A3.0-alpha

There were a lot of commits across marko and [htmljs-parser](https://github.com/philidem/htmljs-parser), but we now have a much more extensive test suite (well over 500 individual tests and counting for marko, marko-widgets and htmljs-parser) so I feel free confident that things will work as expected.

We hope to have an alpha release early next week and the migration tool will come a little later. 
  This is the first time I have heard about this, but I have not had to a lot of development for mobile. Without actually trying to reproduce, it would appear that @yomed is right and that maybe Safari is not recognizing the elements as clickable and is not bothering to emit an `onclick` event. Here is the relevant section in the Safari developer docs:
https://developer.apple.com/library/ios/documentation/AppleApplications/Reference/SafariWebContent/HandlingEvents/HandlingEvents.html#//apple_ref/doc/uid/TP40006511-SW6

It appears that a workaround might be to attach a dummy `onclick` handler:

``` html
<span onclick="void(0)">...</span>
```

@pcanella or @yomed can either of you verify the dummy `onclick` workaround?

We actually make the decision at compile-time on whether or not to use event delegation or direct event listeners based on the event type: https://github.com/marko-js/marko-widgets/blob/526a04f46bcdbd292a46572c34fdb1b4a305bc08/taglib/TransformHelper/handleWidgetEvents.js#L123-L137

We could special case the `click` event and add code to do a direct event listener in mobile Safari and rely on event delegation in all other browsers.

If more details can be provided then we can definitely look into some possible fixes. Thanks for reporting the problem.
 For the record, adding `onclick: pointer;` to the style of your element causes Safari to trigger a click event when you touch it on mobile.  Nice to see that you are digging into the code for the Marko v3 compiler :)

I understand why you are expecting a different output, but the reason you are seeing the behavior that you are seeing is that at parse time we build all of the nodes in the AST based on the tag definitions and we associate the code generator when the node is initially created. Therefore, when the Marko parser encounters the `<div>` node it is creating an `HtmlElement` node and the `HtmlElement.prototype.generateHtmlCode` method is being used as the code generator for the node. Changing the tag name does _not_ change the code generator and I think it is best to keep that way. However, you can create a new replacement node in your transformer (instead of modifying the existing node):

``` javascript
module.exports = function transform(el, context) {
    console.log('CALLED TRANSFORM')

    if (el.getAttributeValue('transform')) {
        var newTagName = 'new';
        var newAttributes = {
            foo: context.builder.literal('bar')
        };

        var newEl = context.createNodeForEl(newTagName, newAttributes);
        el.replaceWith(newEl); // Remove the old HtmlElement out of the tree and replace it with the new one
    }
}
```

NOTE: I just added the `replaceWith(newNode)` method as a convenience method (see https://github.com/marko-js/marko/commit/2ce5493c9afaa1389f943946bc7e4d19ddf134b1) You will need to pull the latest code if you want to test the above code.

Hope that makes sense. Please let us know if you have any other questions/thoughts/concerns. Thanks!

I'm going to go ahead and close this issue, but feel free to respond here.
  Why are you bundling the Marko compiler? I feel like all that should be bundled are the compiled templates and the marko runtime.
  Hey @stevus, it looks like you are using browserify to build a JavaScript bundle to be loaded on the server (not the browser). That's not the normal use case and it breaks "dynamic" requires. However, let me see if I can put in a workaround for you. 
 Fixed. See: https://github.com/raptorjs/raptor-logging/issues/4

New version of `raptor-logging` published: `raptor-logging@1.0.8`

Please let me know if that works for you. Seems reasonable what you are trying to do, but you might run into edges like this again.
  With a few tweaks to the current parser, we could simultaneously support a new concise, Jade-like syntax. A sampling of the proposed syntax is shown below:

``` xml
<!-- Basic JavaScript constructs -->
var colors=['red', 'green', 'blue']

<!-- Placeholders, looping and conditionals -->
ul if(notEmpty(colors)) 
    li for(color in colors)
        | <b>${color}</b>
div else | No colors!

<!-- Custom tags with wrapped attributes -->
greeting [name="Frank"
    message-count=10]

<!-- Macros -->
macro navLink(href, title, isActive)
    li class=(isActive ? 'active' : null)
        <!-- HTML-JS parsing mode in the same document -->
        <a href="href">
            ${title}
        </a>

ul
    navLink href="/" title="Home" isActive=true
    navLink('/about', 'About', false)
```
 From various interactions I have found that there are a lot of people who would consider using Marko, but much prefer the Jade syntax. On the flip side there are a lot of developers that dislike the Jade-style syntax because it is too far removed from real HTML.

With that in mind, Marko has a lot of benefits that are independent of the input syntax/dialect:
- High performance and minimal runtime
- Custom tags
- Extensible at compile-time
- Async rendering
- CommonJS modules as compile output
- Marko Widgets support
- etc.

The input template is relatively small (but important) piece of Marko. I believe that if we can offer a Jade-like dialect for Marko then we will be able to attract additional developers to the project.

It's of course worth pointing out the negatives of supporting an alternate dialect:
- Fragmentation within the Marko community
- Development cost of supporting a two dialects (hopefully a minimal, one time cost)

Regarding "Fragmentation within the Marko community", my thinking that is better to grow the community. In addition, I want to keep the two dialects very similar such that there is a direct and perfect translation between the two. In fact, we could easily provide tools for converted from one dialect to the other with no change in behavior or loss of information.

Regarding "Development cost of supporting a two dialects", I do feel like development effort is not too burdensome and it will be a single parser that supports both dialects.

We are leaning towards using an alternate `.jarko` file extension for Marko with the Jade-like syntax. All of the Marko documentation would use the non-concise syntax and there would be one page of documentation that would explain the rules for the concise syntax for those who want to use it.

I opened the issue to invite discussion so if you have any other thoughts please share.
 I was on the fence about this at first but there a lot of people that are passionate about Jade so there must be some merit for its success. One of the subtle but elegant things about the _jarko_ dialect that has been proposed is that you could drop in normal HTML or Marko and it would just work because the parser would know to switch to HTML/Marko mode when it sees an opening tag.

If Jarko was available, I would definitely give a try to see if it would grow on me. I might enjoy not having to type all of those `<` and `>` characters.

Also, does anyone feel like the _Jarko_ name is a bad idea? Could it lead to confusion? The alternative might be that we refer to it as _concise Marko_ but I am not sure if that is better.
 Initially I didn't think it was a good idea, but I feel like the concise syntax might grow on me as well. It would need proper editor support for good syntax highlighting. I suspect that if I were to use the concise syntax then I might have a hard time switching back to the non-concise syntax. I like that the concise syntax allows the normal HTML syntax to be mixed in. This allows regular HTML to be pasted in without having to take the time to reformat it.

I'm very curious to se what the community thinks as well. I'm willing to put this out there as an experiment to see what others gravitate to.
 I am aware of the rename to "pug" but a lot of people are still going to remember it as Jade. The name "mug" was also proposed (which kind of fits in nicely with the coffee/java/javascript theme).

What are your thoughts on "mug" as the dialect name?

As far as as the development effort to support another dialect, I think @patrick-steele-idem has done a lot of great work to make the effort minimal so I don't think that is a big concern (but maybe we'd learn differently after experimenting a little). The event-based parser would emit the same events for both dialects so might not be that bad.
 > There are only two hard things in Computer Science: cache invalidation and naming things.
> 
> -- Phil Karlton
 As @tindli mentioned. We have no intentions to get rid of the HTML syntax. We are only trying to figure out if the HTML dialect can coexist with the concise syntax. We have the following options:
1. Only allow concise syntax for a separate file extension (e.g. `.jarko`)
2. Allow concise syntax and HTML syntax in same file (starting out in concise mode is probably the only good option)
3. Don't bother with concise syntax at all

Supporting mixed dialects in the same file (option 2) almost works perfectly exactly when a developer who prefers HTML wants to put plain text at the root (outside an HTML tag). The parser would need to start out in concise mode and that would cause the first word of the plain text to be "incorrectly" interpreted as a tag name (it needs to be prefixed)

There's also still some debates around the concise syntax. @tindli pointed out that `.` might be a better choice since you don't have to press the shift key (easier to type). I would much prefer to avoid the shift key.
 > I was under the impression that Marko was designed to adhere to the Rule of Least Power. By promoting Jade, it's no longer adhering to that rule.

@danrichman For Marko v3 syntax and the concise Jade-like syntax would parse into exactly the same AST (the same internal representation). Therefore, there would be no difference in power. The Jade-like syntax is just HTML without `<` and `>` and indentation is used to control nesting and there is one extra prefix symbol to escape out of indentation mode...everything else is identical. Neither dialect brings any extra power to the table.
 > @patrick-steele-idem Isn't there more to Jade than that? Conditionals, extends, etc. Wouldn't Jade developers just end up demanding those more powerful features?

@danrichman maybe starting this conversation with "Jade" was a bad idea. We are less interested in the features of Jade and more interested in the concise syntax that it offers.

> Wouldn't Jade developers just end up demanding those more powerful features?

Marko has all those features (and more) already, but in just a different form. For example, Marko doesn't have support for an `extends` keyword, but it does offer a `layout` taglib for doing the same thing in a cleaner and more extensible way (I would argue, at least). Marko has conditionals, looping, custom tags, etc.
 Good points @danrichman 

Maybe we should deviate more from Jade to make the distinction clear. We are not trying to be Jade (I think the rules for Jade are overly complicated and error-prone), but we are trying to potentially appeal to people who like a minimal syntax and that don't like typing a lot of redundant symbols.

I'm going to give the concise syntax some more thought over the weekend and will share more later.

Thank you, all, for your feedback!
 @danrichman thanks for pointing us to the Angular discussion. I imagine it might be more confusing using two distinct templating engines (not just different dialects) to build a page as is the case when doing server-side rendering of page built for Angular. I was never a fan of Angular because of the inability to pre-compile templates and I think they kind of created that problem themselves and I don't think they have a good solution. I don't think Marko has that issue since the client and server templating language will be same (regardless of whether it's the concise or non-concise dialect).

Thanks @scttdavs! Good to hear from the Jade camp :) I've always had an easier time reading HTML with all of the extra braces but I am sure that is more due to what I am use to. I think I have always rationalized typing a few extra characters for the sake of readability. It might be time to retrain my brain so that I can get faster readability and less typing.

I'm still in favor of offering a new concise syntax as an experiment and give people the challenge to try it for a little while to see if we can change some opinions. I'm curious how my own productivity would be impacted...
 Thanks for sharing your thoughts @scttdavs 

> But then again, I've used haml and jade for years, so the HTML like syntax seems like a step backward to me.

I have heard a lot of similar comments from people who like Jade. From what I have gathered, those who have used Jade or HAML (and stuck with it) would have a really hard time going back to HTML. 

For my own benefit, I took the time to find some real world Marko templates from the eBay code base and converted them by hand over to the concise syntax. I picked samples that were on the large/complex side and am finding that the HTML-based templates just look more complex than they really are and it takes me longer to make sense of the code. I'm starting to feel that the concise syntax is something that can grow on you, but that most people (me included) initially dislike it. I'm going to continue to experiment with the concise syntax. Thanks again for sharing your thoughts.
 Hey @danrichman, I definitely understand where you are coming from and share your concern about documentation.

As a point of comparison, Markdown is kind of a similar story. Markdown is a concise version of HTML, but it lets you drop into HTML mode at anytime. Therefore, with Markdown you can use the concise Markdown syntax to produce HTML documents or you can use regular old HTML. With that approach you kind of get the best of both worlds and everyone is happy. The HTML within Markdown files is in no way limited by the support for a concise Markdown syntax. It's worth noting that you can't switch to concise Markdown mode within an HTML tag.

What if Marko supported something similar and allowed both concise HTML and regular HTML within the same Marko file? This could not be done with a plugin and, instead, it would require a more flexible template parser. Sure, you could use two separate parsers (or two separate plugins), but that would be a lot of duplicate code when one happens to be a superset of the other (assuming blended mode).

If we want to ever support the blended mode within the same `.marko`  file by _default_ then it would need to happen before the next major release. The benefit of supporting the blended mode by default is that we would have a consistent file extension (i.e. `.marko`) that "works for everyone". We have until the v3 release to decide.

If we are good with not supporting a blended mode, then we could release support for a blended mode using a different file extension at any point in the future (or never).
 Hey @danrichman. That would be awful if periods were required for regular HTML, but fortunately that option is not on the table :) With mixed mode support, the following document would be a completely valid Marko template and parse hopefully as you would expect:

``` xml
<div class="something">
  <!-- Everything inside this tag will be parsed as HTML -->
  <h2>Heading 2</h2>
  Some <b>bold</b> text. Some <em>emphasis</em>.
  <div class="something-else">
    Good thing there are no
    more periods.
  </div>
</div>
<!-- You can also use the concise, indentation-based dialect in the same document!: -->
div class="something"
    h2 - Heading 2
    - Some <b>bold</b> text. Some <em>emphasis</em>.
    div.something-else
        ---
        Good thing there are no
        more periods.
        ---
```

NOTE: The sample template above uses the latest syntax that I am experimenting with. It has a lot of advantages over Jade and should feel very natural.

Does that look good to? Best of both worlds?
 @danrichman There will never be periods. I think the following sample template would be what you are looking for and it would also be completely valid:

``` xml
#another-div
    <div class="something">
        <!-- Everything inside this tag will be parsed as HTML -->
        <h2>Heading 2</h2>
        Some <b>bold</b> text. Some <em>emphasis</em>.
        <div class="something-else">
            Good thing there are no
            more periods.
        </div>
    </div>
    span.foo - Hello ${data.name}!
```

The above Marko template would render the following HTML:

``` html
<div id="another-div">
    <div class="something">
        <!-- Everything inside this tag will be parsed as HTML -->
        <h2>Heading 2</h2>
        Some <b>bold</b> text. Some <em>emphasis</em>.
        <div class="something-else">
            Good thing there are no
            more periods.
        </div>
    </div>
    <span class="foo">
        Hello ${data.name}!
    </span>
</div>
```

The problem with Jade is that you can't simply paste in valid HTML code into a Jade document and expect things to work. We can definitely do better than Jade. If we get this right then I see no reason why anyone would want to use Jade.
 Marko v3 now supports mixed mode parsing to allow the concise syntax and the HTML syntax within the same document. When the alpha release is published (hopefully soon) we will continue to gather feedback.

All docs will continue to use the HTML syntax since that is more approachable to new users.
  Hey @grawlinson, it looks like you are expecting well-formed XML as output (not HTML). is that correct? The `<meta>` tag happens to be defined by the HTML grammar as a self-closing/open-only tag. Marko defaults to HTML mode. If you want well-formed XML as output, then you should use the `.marko.xml` file extension which may not be documented :/ Please let me know if that works for you.
 Hey @grawlinson, you need to install the Node.js require extension for `.marko.xml` by doing the following:

``` javascript
require('marko/node-require').install({ extension: '.marko.xml' });
```

Without that line, Node.js is trying to load your `.marko.xml` file as a JavaScript module. Please let me know if that solves your problem or if you are still facing issues.
  It definitely needs some improvement.  It needs to be more of a tutorial rather than a list of features that a beginner might find useful.

I like the idea of filename labels.  I think we could create a nice widget (using Marko of course) that could take a directory path and create the widget from that.  Maybe it could be generated from a gist so that users on reading on github would still be able to view code snippets.  Maybe that's not worth it and they should just read it on markojs.com.
  Several people have asked about the security implications of allowing end-users to edit Marko templates. I too have wished for this ability but have held off allowing it because it is currently unsafe. We should assess the options for loading and running templates within a sandbox. Examples of unsafe template code includes scriptlets (e.g. `{% process.exit(1) %}`) and JavaScript expressions (e.g. `<div if="process.exit(1)">`). Also, the CommonJS/Node.js `require` function is currently exposed to the template which would allow the template to access the module cache (this is dangerous).

Two ideas have been proposed to support this:
1. Use the Node.js built-in `vm` module to load and run Marko templates within a sandbox
2. Staticly analyze the Marko template source code to find unsafe code and prevent compilation or provide whitelist of tags and features that can be used in sandbox mode

Personally, I think option `2` (static analysis) would be too error-prone but it is worth exploring.
 Hey @AminaG what option are you leaning towards (sandbox or static code analysis)?
 One thing not mentioned by @philidem is that the `out` could leak potentially sensitive objects if you are not careful. For example, if you render to the HTTP response stream in an Express app then you could do the following:

``` javascript
var res = out.stream;
var app = res.app;
// User now has a reference to the Express app instance
```

This can be avoided if you don't render directly to the HTTP response. For example:

``` javascript
template.stream(templateData).pipe(res);
```

You also have to be careful with data stored in `out.global` (see: http://markojs.com/docs/marko/language-guide/#global-properties).

Just wanted to make note of these subtle but important details for future reference.
 I think vm2 spawns a new process which is a good option for most security.
What if we used web worker? They might have sufficient isolation as well.

On Mon, Dec 28, 2015, 12:29 PM AminaG notifications@github.com wrote:

> I prefer sandbox via vm or vm2 (https://github.com/patriksimek/vm2).
> Regular VM, of node can make the entire process not responding while
> (true) {}.
> 
> â€”
> Reply to this email directly or view it on GitHub
> https://github.com/marko-js/marko/issues/192#issuecomment-167607882.
 I'm also leaning towards the sandbox (at least for now). Fortunately, the runtime for marko is tiny. All template loading happens in the following two functions: https://github.com/marko-js/marko/blob/de673d362e993263a926bf40d34f018aa6320ccf/runtime/loader.js#L33-L69

Once you have the source, you will need to load the source in a separate sandbox and you will need to provide your own pseudo globals: `require`, `module`, `__dirname`, `__filename`

The sandbox will not have the Node.js module loading system but you will need to shim in a fake module loading system for marko to work.
 I'm not convinced vm2 is completely needed, but out-of-process rendering of templates is possible (rendering will have to be async). 
 Marko doesn't depend on any globals.

You would just need to load the marko runtime in the separate process. However, it is challenging to load the marko runtime without the Node.js module loading system. For that reason, I think it is better to use an in-process sandbox and have the runtime be loaded outside the sandbox, but to have the template be loaded within the sandbox. If you want to try and load marko without a module loading system in a separate process then that will definitely be the safest, but it, again, it will be more challenging without the Node.js module loading system.
 I think the JavaScript API should provide a sandbox option and if true then
behavior can be different due to the additional constraints. I don't think
we have to worry about globals not working on sandbox. Also the global data
could be stranded and sent to other process.

On Mon, Dec 28, 2015, 12:36 PM AminaG notifications@github.com wrote:

> Out-of-process will make all global not works. It is break-change. Can we
> do that kind of break change to Marko?
> 
> â€”
> Reply to this email directly or view it on GitHub
> https://github.com/marko-js/marko/issues/192#issuecomment-167608790.
 Yes, that is a good suggestion @AminaG :

``` javascript
var template = require('marko').load(src,{secure:true})
template.render(templateData, stream)
```
 @AminaG this definitely can't be a breaking change. The "sandbox" functionality should be an opt-in only and that option should only be recognized on the server.
 Looking more closely at vm2 I see that there is support for a Node.js module loading system. That makes vm2 more applealing.
 @AminaG There are timeouts, but they are only for async timeouts (not CPU bound loops).
 My recommendation is to go forward with [vm2](https://github.com/patriksimek/vm2), but to allow the sandbox to be more pluggable and flexible. It is better if `marko` does not have a direct dependency on `vm2`. Something more like the following:

``` javascript
var NodeVM = require('vm2').NodeVM;

var options = {
    console: 'inherit',
    sandbox: {},
    require: true,
    requireExternal: true,
    ...
    requireRoot : "./"
};


var sandbox = new NodeVM(options);

var template = require('marko').load(templatePath, {
  sandbox: sandbox
});

template.render(templateData, ...);
```

Timeout only makes sense for the render method, but that is not supported for vm2. You would have to use an out-of-process solution for that.
 Just realized that vm2 doesn't allow you to whitelist external modules (only native modules)... Really??
 From the docs:

> IMPORTANT: Timeout is only effective on code you run trough run. Timeout is NOT effective on any method returned by VM.
> IMPORTANT: Timeout is not effective for NodeVM so it is not immune to while (true) {} or similar evil.

Therefore, timeout would not be effective for the `template.render()` method.
 > Maybe it is possible to add modules to VM2 context using the sandbox option, instead of requiring it:

That's possible, but it would mean that the templates would need to be compiled differently if they are loaded sandbox mode. It's worth exploring.
 My guess is that everything in the vm2 sandbox has to be serializable since
it gets sent to other process but maybe I'm wrong.

On Mon, Dec 28, 2015, 12:57 PM AminaG notifications@github.com wrote:

> Maybe it is possible to add modules to VM2 context using the sandbox
> option, instead of requiring it:
> 
> sandbox={marko: require('...'), `marko-async`:require('marko-async')}
> 
> What do you think/
> 
> â€”
> Reply to this email directly or view it on GitHub
> https://github.com/marko-js/marko/issues/192#issuecomment-167614396.
 Hey @philidem, I think you misread. The vm2 sandbox is in the same process.
 > vm.call('setTimeout(function(){process.exit()},60000)')

I don't see how that helps. Also, `process.exit` won't be available in the sandbox :)
 vm2 is not a lot of code. May be worth forking and improving to add support for whitelisted external modules. Basically, for any required module file, search up the directory tree to find the parent package name and check if that particular package has been whitelisted.

Only problem (for me at least) is that vm2 is written using CoffeeScript... 
 Actually, after giving it some more thought, vm2 is probably good as-is. As long as the native Node.js modules (`fs`, `process`, etc.) are blocked then I suppose there really is no security risk. I can see the reasoning for only supporting whitelisting of native Node.js modules.
 Actually, I take that back, a non-native module might have a native binary built from C++ that could be an attack vector. I suspect that those those non-native binaries would still be allowed to be loaded when using vm2, but I could be wrong.
 If you go with the out-of-process solution, then, yes, the template data needs to be serializable to JSON. vm2 is in-process so I don't think passing in helper functions or using data from closures is a problem.
 I recommend trying out vm2 further. If we run into limitations, we can always improve vm2, but I still think vm2 is in the best direction.
 @AminaG 

> So, there is any solution how to to stop vm2, in case of infinite loop

Yes, you need to invoke the `template.render()` method using the `vm.runInThisContext(code, { timeout: 999 })` method or `script.runInContext(contextifiedSandbox, { timeout: 999 })`. Using the latter is recommended since it can be used to execute a precompiled script (i.e., faster). See: https://nodejs.org/api/vm.html#vm_new_vm_script_code_options

UPDATE: It looks like vm2 may not expose the underlying `vm` interface, so that might require a fork.
  Currently, compiled templates are written next to the original file. It might be nice to offer the ability to place compiled templates in an alternate root directory. For example:
- `my-app/.marko-compiled/src/components/foo/template.marko.js`
- `my-app/node_modules/some-installed-package/.marko-compiled/src/components/bar/template.marko.js`
 @adammcarth I don't think putting compiled templates directly under the `node_modules` is the best choice since it I think it is an abuse of that folder and would not be expected by end users. I think putting compiled templates under a `.marko-compiled` directory at the root directory of the package associated with the template is the right thing to do. Yes, you would have to make sure that directory is included in `.gitignore` but I think that is okay.

NOTE: I adjusted the original text because there was a typo.

As a side note, one of the potential benefits of compiling a template and keeping it right next to the original file is that as a package prepublish step you can pre-compile all Marko templates, delete the original Marko template files (temporarily) and all of the requires would work and return the precompiled template. That is, if you you have a `require('./template.marko')` call in your code, Node.js will first look for `template.marko` and not find it and then it will look for `template.marko.js` and find that. That way, you can use the Node.js require extension for Marko during development, but when you publish your package you would only publish the pre-compiled templates (not the original Marko source files) and it would not be required for a user of the package to install Marko's Node.js require extension.

Thoughts?
 The current thinking is that we can make this an option by introducing a new configuration option in `marko.json` similar to the following:

``` json
{
  "compiled-output-dir": "./.marko-compiled",
   ...
}
```

After updating the compiler for Marko v3 and working on this task it became clear that we won't actually be able to directly load the template from the alternate directory. We would merely be writing it disk at the alternate location for reference purposes (and possibly to avoid recompiling in production). The stack trace would still need to match up where the original `.marko` file is on disk in order for any `require()` calls to work as expected.

It's also a little unclear if this setting would be applied globally. Currently, we only search up to the root of the package to find a `package.json` file so installed packages would currently not share the option if it comes from a `marko.json` in the root package. We might need to consider other options if we want the configuration option to also apply to all installed packages.
 This is not on our roadmap, but we're not opposed to it if someone from the community would like to tackle it.  If you want to take a stab, let us know and we'll help if necessary.

As far as directory naming, I think a sensible directory would be `.cache/marko` since Lasso and other modules already use `.cache/` to store cached files so this way we're not cluttering the top level directory.
  Hey @tropperstyle, thanks for the PR. I'll fix the jshint error that your code introduced and publish a new version. Thanks for the improvement.
 Hey @tropperstyle. I updated the code so that it still only did one pass through the directories: https://github.com/marko-js/marko/commit/a55f3bb82b2cc232903373afd6af3a654fea5299

New version published: marko@2.8.0

Please let me know if you find any issues with the new code. Thanks!
  Hey @patbegg, thanks for reporting the problem. I'll take a look into it. What version of npm are you using? 

_EDIT: Didn't notice the npm version in the issue title. Please disregard :)_
 Hey @patbegg, are you sure `marko-layout` is not being installed? I wasn't able to reproduce the problem with the latest npm version (v3.5.1). The latest version of `npm` flattens all of the installed `node_modules`. If that is the case then you should find `marko-layout` as a child of your top-level `node_modules` directory and that is perfectly fine. 

If you were using an older version of `npm` and then later switched to a new version of `npm` then I suggest forcing a recompile of all your templates since the directory structure may have changed and the compiler might need to recalculate relative paths that get generated. You can force a recompile using either of the following approaches:

Option 1) Force a recompile of templates by setting the `MARKO_CLEAN` environment variable to `true` (recommended):

```
MARKO_CLEAN=true node index.js
```

Option 2) Use the `markoc` command line utility to delete the generated `*.marko.js` files:

```
markoc . --clean
```

Please let me know if that solves your problem. Thanks.
 Hey @patbegg, glad that solved your problem.

If you know the directory structure is exactly the same on both machines then it is okay to copy over the compiled templates. If there is any chance that the directory structure will be different then I would just not copy the compiled templates and, instead, have them be lazily compiled on the target machine as you did.

How about we open another issue to track the docs improvement? I'm going to go ahead and close this issue for now. 
  Hey @ashishcpatel2, thanks for reporting the issue. I'm not going to have a chance this weekend to take a look, but I'll take a closer tomorrow. I'll update you as soon as I know more. Thanks again.
 Hey @ashishcpatel2, just wanted to provide an update that I was able to reproduce the problem and I have added a test case. It looks like things almost worked, but there is a bug in the taglib loader that is preventing the deeply nested tags from being properly registered. I am still investigating to see what is required to be changed to support deeply nested tags.
 Hey @ashishcpatel2, I pushed a fix to allow nested tags to be arbitrarily deep.

New version of marko published: `marko@2.7.31`

Thanks for your patience. Please let us know if you run into any other issues. Thanks for your help. 
  I like the idea of using **01. Configuration File**. As a slight variation, I would recommand `.marko` (not `.markoc`) because I don't it's necessary to distinguish between Marko runtime and compile-time options.

I know that @patrick-steele-idem is hard at work on Marko v3 so maybe we could target this feature for that version?
 And, regarding having a separate `marko-taglib.json`, I'm actually liking your idea of converging on a single file. This would also make the compiler a little simpler since it wouldn't have to look for two files when looking for configuration.

The only downside with using something like `.marko` is that files that start with "." are ignored by default in Unix-like operating systems. Maybe `marko.config`, `marko.config.json` or `marko.json` instead?
 Thank you for sharing your detailed thoughts, @adammcarth and @philidem! 

:+1: on `marko.json`. After giving it some more thought I'm also in favor of using `marko.json` to both register custom tags and provide compiler configuration.

I'm also in favor of requiring that this file be placed in the root directory of the package. Currently we allow `marko-taglib.json` to be placed in any directory and the compiler just searches up from the template file. This works, but it introduces the overhead of searching the file system and it also results in marko searching outside the main project's directory which is not good.

I also agree that we should wait until the next major version of `marko` to make this change since it is a breaking change, and we have wanted to revisit taglib loading anyway. I'll add this to the roadmap (which still needs to be written up and formally shared).

If you have any other thoughts or suggestions please share. Thanks again!
 Supporting `require('marko').configure({})` is not bad, but the problem is that if the command line compiler is used to compile a template then it won't be configured the same way. Ideally, configuration would all be loaded declaratively from files. The only problem is if configuration needs to be environment specific.

> I don't like the idea of messing with Node's require function, so I don't use marko/node-require. I use marko.load() for loading templates.

Longer term, I would like to see an npm `prepublish` step that modifies all code as such:

_Before:_

``` javascript
var template = require('./template.marko');
```

_After:_

``` javascript
var template = require('./template.marko.js');
```

With that approach, you still get the convenience of requiring a template, but you don't have to worry about installing the require extension for production usage and third party packages wouldn't depend on the Node.js require extension for Marko. The Node.js require extension for Marko is only there for convenience because it allows for less code to load a template:

``` javascript
var template = require('./template.marko');
var template = require('marko').load(require.resolve('./template.marko.js'));
```

In this case, I think it is better to be pragmatic instead of worrying about violating some Node.js tenet. The fact is, Marko is really just a transpiler that takes your Marko template file and converts it into a CommonJS module that Node.js can load and that is compatible with any JavaScript module bundler. The Node.js require extension for marko is just doing the transpiling on first require. Babel provides a Node.js require extension for ES6 transpiling.
 Global configuration is now supported by:

``` js
require('marko/compiler').configure({ writeToDisk: false, preserveWhitespace:true });
```
  Hey @adammcarth, thanks for the question. That is something we have thought about, but we decided _not_ to build an Express view engine for various reasons:

The Express view rendering engine only supports callback-style view rendering that is not compatible with streaming. As a result, the Express view rendering engine has worse performance and less flexibility. On top of that, the Express view rendering engine includes its own view resolving code (instead of just using the Node.js module resolving code) and it requires global/app-level configuration to make everything work. Finally, the Express view rendering engine introduces a new way to render a template that only works on the server and only with Express. The Express view rendering engine, while simple, is far more complicated than just rendering a template directly to an HTTP response stream. The only drawback to not using the Express view rendering engine is that if your templates or view rendering code needs information associated with the incoming request then you must manually add that data to the template data (possibly using [$global](http://markojs.com/docs/marko/language-guide/#global-properties)). I guess another possible "drawback" is that you need to require in the template in the view controller code, but I see that as a good thing since it promotes modularity.

I wrote a blog post on this topic that you should check out as well: [Bypassing Express View Rendering for Speed and Modularity](https://strongloop.com/strongblog/bypassing-express-view-rendering-for-speed-and-modularity/)

Hope that answers your question! Let us know if you have any other questions. Thanks again.
 Hey @adammcarth, glad you found that article helpful. Pretty much every product team at eBay building webapps on the Node.js stack have adopted the modular directory structure and the feedback has been very positive. I also see a similar trend with other frameworks and libraries.

For a blog post, I think that directory structure looks good. A page typically has a top-level route associated with and it will typically have a unique page controller and page template. For the [markojs.com blog](http://markojs.com/blog/), there are a set of pages associated with the blog that you can take a look at: https://github.com/marko-js/markojs.com/tree/master/src/pages/blog

Those pages each have a corresponding route. I prefer to put all of the routes in a single place so that anyone looking at the application source code can quickly figure out which routes map to which pages.

The layout taglib is used to separate out page layout from page content in cases where you have multiple pages that share a common layout. For example: https://github.com/marko-js/markojs.com/tree/master/src/layouts/default

I hope that helps.
  Hey @leonli, sorry for the delayed response, but better late than never...

What I found works well is to also require non-JavaScript module dependencies in your component's `index.js` file as shown in the following code:
https://github.com/marko-js-samples/ui-components-playground/blob/63cf6d30928d28060d293bbae1c171f598adc506/src/components/app-button/index.js#L1

Also, if you put a `browser.json` next to an included JavaScript module then it will automatically be processed and all of the referenced client-side dependencies will be included.

That way, if the UI component is sent to the browser then the required CSS will also be included. Also, all of the required client-side dependencies for nested UI component's will be included automatically when you bundle up the root UI component.

Does that answer your question or do you have another more specific suggestion on how to improve how CSS dependencies are included.
 Hey @leonli, I'm just going through issues to do some housecleaning. I'm going to go ahead and close this issue, but if this is still an issue/question please feel free to add more comments. Thanks.
  Good catch. Marko is isomorphic and works on the server (Node.js) and in any browser. You will need a JavaScript module bundler (browserify, [Lasso.js](https://travis-ci.org/lasso-js/lasso), etc.) to transport the compiled templates to the browser and everything will work exactly as it does on the server. I'll update the README and website to make this clear. Thanks for letting us know.
 Website updated. Please let us know if you see any other issues with the website or docs. Thanks again.
 Great. Thanks for the feedback, @wheresrhys!
  Hey @redben, that is the expected behavior. Anything inside `${ ... }` is just JavaScript and it will be evaluated just like any other JavaScript code (if you take a look at the compiled code this should be clear).

Because Marko templates compile down to CommonJS modules you can import the `lodash/object/get` function to provide safe access to nested properties as shown below:

``` xml
<require module="lodash/object/get" var="get"/>
<p>Author ${get(data, 'author.name')}</p>
```

You'll need to install `lodash` into your project for the above code to work:

``` bash
npm install lodash --save
```

If you don't want to use a third-party module, you can also do the following:

``` html
<p>Author ${data.author and data.author.name}</p>
```

NOTE: `and` is a special operator that gets converted to `&&`. See: http://markojs.com/docs/marko/language-guide/#expressions

Does that work for you? Hope that clarifies. Let us know.
 Hey @redben, it's true that many templating engines interpret expressions and handle safely reading nested properties. However, doing that by default results in worse runtime performance and it limits the power of the templating language since expressions cannot be arbitrary JavaScript code. Marko has always tried to be be as close to pure JavaScript wherever possible. This keeps the runtime tiny, improves performance and it allows templates to be more powerful.

In theory, we could offer the `get` as a builtin helper to avoid having to import it. Something worth considering (especially if it is only imported if it is used in the template). Thoughts?
 Hey @redben, what's nice about marko is that it only requires in things that are required. That way when you use a JavaScript module bundler to send a compiled template to the browser there is no extra baggage. As long as we made it so that the `get` function was only `require`'d if used then I see no harm as offering that as a feature. The hard part is figuring out if `get` is required because currently aren't fully parsing the JavaScript expressions used in a template (using something like esprima or acorn), but that is something we are considering for the next release of marko. Probably low priority though since there is a fairly clean workaround. Thanks for your feedback.
  Hey @designeng, thanks for the PR, but I think we need to keep the test case as-is. While `require('marko').stream(templatePath)` is not the recommended API, it is still supported and we should keep that test case around to make sure it continues to work. There is another test case that tests `marko.load..stream': https://github.com/marko-js/marko/blob/56d23b07bdc4ca2a20ebce868a3982277c97c618/test/api-tests.js#L170-L191

Look good to you?
 Thanks, @designeng! I appreciate the feedback. 
  Hi @Globik, let's start with your first question:

> I opened the file next morning I'v seen that marko engin rewrite the file of his own way with helper's javascript functions, but my Hallo ${data.name}! is gone, simple disapeared.

When a Marko compiles a template such as `template.marko` it will generate a new file next to the original file named `template.marko.js`. The original source file is definitely not deleted. If it is gone it is because you accidentally deleted it but most likely you are just not noticing it. The generated JavaScript file is what gets loaded by Node.js (or sent to the browser).

---

And for your second question:

> The server must be restart to keep changes in the template file every time. So bad and slowly for a site developing. Is it true?

Depends on how you are watching files. Make sure you add `*.marko.js` to your ignore patterns (e.g. `.gitignore`). Since the `*.marko.js` files are generated at runtime you will want to make sure those files are ignored.

---

And for your final question:

> Only opening tags are modified for conditionals and looping???

When you make an element conditional using the `if` attribute or if you make it repeated using the `for` attribute then both the starting and ending tag will be wrapped. Hopefully it is clear from the `Try Online` example: http://markojs.com/try-online/#Simple_Hello_World

---

Let us know if you have any other questions.
 Hey @Globik, I'm just going through issues to do some housecleaning. I'm going to go ahead and close this issue, but if this is still an issue/question please feel free to add more comments. Thanks.
  I believe this issue has been resolved with improvements to the [deresolve](https://github.com/raptorjs/raptor-modules/blob/04fc6554b800277e1c62b4e1d66586bfb45acf90/resolver/lib/deresolve.js) function. If I am mistaken, please reopen the issue. Thanks.
  Seems reasonable! Double-checked the travis documentation and this looks like a safe way to force container infrastructure to be used.
 Thanks for the fix, @zephraph.

I don't think your change was the cause, but for some reason the Travis CI build is failing now :disappointed: I'll retry in a bit, but if you find a solution please share.
 I think the failed build was my fault because I closed the pull request and
then reopened it. The build error message seems to imply that this was the
reason for failure. Subsequent builds have succeeded.

On Fri, Oct 16, 2015 at 8:51 AM, Zephraph notifications@github.com wrote:

> @patrick-steele-idem https://github.com/patrick-steele-idem which
> build? The only thing that I saw that has failed recently was a rebuild
> that triggered on my PR after it was merged (which failed because the git
> ref that PRs point to are deleted after merge).
> 
> â€”
> Reply to this email directly or view it on GitHub
> https://github.com/marko-js/marko/pull/157#issuecomment-148708406.
  You'll need to make sure tag.name is not overridden due to this line:
https://github.com/marko-js/marko/blob/master/compiler/taglibs/taglib-loader/scanTagsDir.js#L140
 Hey @zephraph, are you still interested in this PR? My opinion is that I don't think it is a good idea for the tag name to be defined in the renderer or in the `marko-tag.json`. I think it is better for the tag name to be defined in the `marko-taglib.json` file or have it be set based on the directory name (when using the directory scanning feature). What do you think?
 I'm also a fan of minimizing how much code gets put into configuration files such as `marko-tag.json` and `marko-taglib.json` so I think it is better to have the convention of using a directory scanner to discover custom tags and for the custom tag name to automatically match the name of the parent directory. I think it would be a mistake to allow the developer to choose a tag name that doesn't match the parent directory name since it would make things confusing.

Also, currently, if you _aren't_ using a directory scanner then you must use a _map_ to define custom tags and that requires that the tag name always be declared in the `marko-taglib.json`:

``` json
{
  "<my-custom-tag>": "./path/to/my-custom-tag/marko-tag.json",
  "<another-custom-tag>": { "@foo": "string", ... }
}
```

It wouldn't make sense to allow the developer to redefine the tag name in the `marko-tag.json` or in the `renderer.js` file since it was already declared in the parent taglib.

I propose that we not merge this PR if you are cool with that :) Let me know.
  Is that code being included inside an inline `<script>` block that inside a Marko template?
 Hi @baburammy, I am having a hard time understanding the issue and how it relates to Marko Widgets based on the details provided. It looks to me that the issue is completely unrelated to Marko and Marko Widgets, but I could be missing something.

With that said, I would not be using jQuery to execute the inline JS. It is better to send down the inline JS without the surrounding `<script>` tag. Instead, just send down the raw JS code and use `eval(response.inlineJs)` to run the inline code.

If you have a sample project or more code that you can share that would make it easier for me to provide help.
 Hey @baburammy, I'm just going through issues to do some housecleaning. I'm going to go ahead and close this issue, but if this is still an issue/question please feel free to add more comments. Thanks.
  That's true @viviangledhill.

However, if you want the image to go through the Lasso.js asset pipeline then you should use the `<lasso-img>` tag:

``` xml
<lasso-img src="./foo.jpg"/>
```

This might produce the following HTML output depending on how Lasso.js is configured:

``` html
<img src="/static/foo-25b047cc.jpg" width="100" height="100">
```

The referenced image will also be moved into the appropriate output location. If there are any plugins to minify images then those plugins will process the image as well.

Here are the docs that were just added: https://github.com/lasso-js/lasso#%3Classo-img
 @viviangledhill automatic conversion to webp is a good suggestion. Assuming the webp image is cached I don't see it being too expensive. The tricky part is that we would have to have a good mechanism for making Lasso.js aware of the target browser's user agent so that it can optimize accordingly. Maybe open a separate Github issue for that feature request to Lasso.js?

I'm going to go ahead and close this issue, but let us know if you run into any other issues related to images and Lasso.js. Thanks.
  Yes, require extensions are deprecated, but I'm not too concerned. As stated in the docs:

> Since the Module system is locked, this feature will probably never go away.

I disagree with their decision to deprecate the feature, but I do think there are better ways to extend the module loading system to add support for new compile-to-JavaScript languages such as JSX and marko. Worst comes to worst, we provide a script to precompile all templates to JS and use `require('template.marko.js')` instead, but that would impact developer usability since it would introduce an unnecessary build step that we don't have now. 

How we have implemented the Node.js require extension for marko avoids the problem of having a global. The global require extension that gets installed by marko simply delegates the compilation to JS to the appropriate marko compiler based on where the source template is on disk. There is no harm with registering the require extension multiple times and in different packages.

On a related note, I would like to see a tool that can be used to precompile all templates and that replaces all `require('./template.marko')` calls with `require('./template.marko.js')`. This would be useful as a `prepublish` script for publishing shared packages that make use of Marko templates.
 That's true that `require.extensions` was deprecated, but I am not too concerned. According to the docs:

> Since the Module system is locked, this feature will probably never go away. 

I disagree with their decision to deprecate that feature without providing a suitable alternative. There's definitely a need for compile to JS languages such as Marko and JSX. Forcing a precompile makes things more difficult and more complicated since it introduces an unnecessary build step that is not needed now. Worst comes to worst, we could precompile all templates and require the `.marko.js` files directly....

The Node.js require extension for marko avoids most of the problems with globals since the require extension just delegates the template compilation to the appropriate version of marko based on where the template is located on disk. There is no harm in installing the marko require extension multiple times and it can be multiple versions of marko in a single app.

On a related note, I do think there would be a benefit to offer a tool for Marko that could be used as a `prepublish` script to replace all `require('./template.marko')` calls with `require('./template.marko.js')` and to have it precompile all templates in the process.
 Hey @yomed, I'm just going through old issues to do some housecleaning. I'm going to go ahead and close this issue, but if this is still an issue/question please feel free to add more comments. 

As a separate issue I think we should explore the option of precompiling all templates and updating the JS code as a prepublish step. Please feel free to open an additional Github issue if you have specific thoughts on how to avoid using `require.extensions`. Thanks.
  At eBay we are using a very similar approach to handle localization. However, instead of adding additional methods to `out.global` we just pass the `out` object to various helper methods. For example:

``` javascript
var locale = getLocale(out);
```

If you are rendering to an HTTP response directly using `template.render({...}, res)` then you can access the underlying response stream and the request object by doing the following:

``` javascript
var res = out.stream;
var req = res.req; // Works for Express, not sure if it works for Koa
var locale = getLocaleFromRequest(req);
```

NOTE: For Koa you can render directly to the HTTP response stream by doing the following:

``` javascript
app.use(function *() {
  template.render({...}, this.res)
}); 
```

I don't use Koa so I am going by what @jlarsson said in the following issue: https://github.com/marko-js/marko/pull/144

The benefit of this approach is that the developer does not have to explicitly use the `$global` property to add things to `out.global`. The disadvantage is that this approach won't work if you are not rendering directly to an HTTP response stream.

Does the approach described above work for you?
 Also, you could create a custom compile-time tag to introduce a new JavaScript i18n variable in your template. For example:

``` xml
<i18n-var name="i18n"/>

<layout-use template="./boilerplate.marko">
    <layout-put into="content">
        <h1>${i18n.__('Welcome!')}</h1>
    </layout-put>
</layout-use>
```

I think that approach is cleaner. We have a similar taglib for our eBay apps.

If you want help going that route, I can put together a sample app to show how it can easily be implemented. The docs on compile-time tags is lacking at this point (https://github.com/marko-js/marko/issues/100).
 Hi @taecilla, sometimes it is just easier to explain in code, so I created a sample app to hopefully make things clearer about what I am proposing. Please check out the following app:

https://github.com/marko-js-samples/marko-koa-i18n

Key notes:
- Enable the `koa-i18n` middleware in your main `server.js` file and add some locales
- Just put `i18n` object into the `out.global` property when you render the page template:

``` javascript
this.response.body = require('./template.marko').renderSync({
    $global: {
        i18n: this.i18n
    }
});
```
- Use the `<i18n-var>` tag to add a new JavaScript `i18n` var to your template at compilation time whose value will be `out.global.i18n`
- In your template you can then do the following:

``` xml
<i18n-var/>
${i18n.__('hello', data.name)}
```

Does that look like a clean solution to you?
 Hi @taecilla, I only passed in `i18n` using `$global` because you were _not_ rendering directly to the HTTP response stream. If you were to do the following:

``` javascript
template.render({ ... }, this.response);
```

Then you could access the `i18n` variable as shown below:

``` javascript
var response = out.stream;
var koaContext = response.ctx;
var i18n = koaContext.i18n;
console.log(i18n.__('howAreYou'));
```

The easiest way to automatically associate a template rendering with a request/response is to render directly to `this.response`. Alternatively, you could create your own Koa plugin that introduces a `this.renderTemplate(template, templateData)` method for rendering the top-level page template:

``` javascript
module.exports = function *() {
    this.renderTemplate(template, { name: 'Frank' });
};
```

Your Koa plugin could then auto-populate any globals into the template data object.

There's alternatives to avoid having to explicitly pass in `$global` everywhere :)
 Hey @tropperstyle, it looks like a bad validation check at the following line:
https://github.com/marko-js/marko/blob/56d23b07bdc4ca2a20ebce868a3982277c97c618/compiler/taglibs/taglib-loader/scanTagsDir.js#L89

That line should probably be updated to not throw an error if the tag has a transformer:

``` javascript
if (!tagDef.renderer && !tagDef.template && !tagDef.transformer) {
```

Do you want to try it out locally and send a PR if it solves your problem?

Thanks,
Patrick
 Hey @taecilla, I'm just going through issues to do some housecleaning. I'm going to go ahead and close this issue, but if this is still an issue/question please feel free to add more comments. Thanks.
  Thanks for the fix! New version published: `marko@2.7.23`
  For context, please see [Proposal: Replace HTML parser with a new parser that recognizes attribute types](https://github.com/marko-js/marko/issues/90)

All of the details are not finalized for the new parser and template syntax, but we wanted to go ahead and create this issue to start the discussion and see if there was interest from folks in the open source community taking ownership of this task. Happy to answer any questions :)
 So the main thing that we need to do is fix how attributes are delimited. If the marko tag definition says that an attribute is a string or if the attribute is not defined in the tag then surround the tag with double quotes. For expressions, numbers, boolean, and non-string types simply then surround then remove the quotes and surround the value with parentheses. For example, transform `some-number="123"` to `some-number=123`.

The new for-loop and if/else/else-if syntax should be used in place of the standard attributes. For example, `<div for="x in y">` should become something like `<div for(x in y)>`.

We can keep the marko-tag.json files for reference but they wouldn't be used anymore to infer attribute types (since type will always be an expression now). Also note that marko-tag.json files would still need to be used for describing tag transformers.

The migration tool should probably leverage `htmljs-parser` to parse the old templates since it will be able to properly parse the new and old syntax. This would be helpful in case the migration tool is ran multiple times for the same templates.

This isn't a comprehensive guide but I think these are the key things that would need to be migrated.
  Thanks for the PR. 

I see the following jshint error that looks like a problem:

```
taglibs/core/core-tag-transformer.js: line 113, col 55, 'UnlessNode' is not defined.
```

Can you please add tests and update the docs? For the docs you will need to update the following file:
https://github.com/marko-js/marko/blob/master/docs/language-guide.md

For the tests, please duplicate the following directory and update it to test the new `unless` attribute and the new `<unless>` tag:
https://github.com/marko-js/marko/tree/master/test/fixtures/templates/if-else

Thanks,
Patrick
 We are using a simple string compare for "actual" and "expected" and any whitespace difference will cause the test case to fail. I suspect you are using Atom and it is automatically adding a trailing new line when you save the "expected" file to disk. You can disable the feature by adding the following to your `User Config` file:

```
"*":
  // ...
  whitespace:
    ensureSingleTrailingNewline: false
```
 Hi @kristianmandrup, the code changes and test look good, but why did you completely reformat the markdown for the docs? It looks like the markdown changes were just stylistic changes, but now the style will be different in the other markdown files. I would rather use the old style unless there is a good reason to switch. Can you please only change the relevant docs for `unless` and we can discuss stylistic changes to the Markdown as a separate Github issue/PR. Thanks.
 Thanks for the PR, @kristianmandrup. New version published: `marko@2.7.22`

The stylistic changes that I was referring to was the Markdown syntax for declaring headings and bold. I reverted those changes and updates the docs for Conditionals:
- https://github.com/marko-js/marko/commit/4a58db78ee36acd39bc90a18bee24578863e904d
- https://github.com/marko-js/marko/commit/1e19886a5a443f1b4ad6d5b90fba89d9dfc8fd61

I also published the new docs to markojs.com. Please let me know if you see any issues. Thanks again.
  Hi @jlarsson, thanks for the PR. I see where you are going with this but I do have some concerns. Adding a `try...catch` will prevent the frequently called code from being optimized by V8 and it will also only catch any synchronous errors. I'm more inclined to add the `try...catch` block around the following line:

https://github.com/jlarsson/marko/blob/3c51134965474d30de7e4e7e82f68cb3de822d0b/runtime/marko-runtime.js#L252

Thoughts? Can you make that change?

On a related note, Koa relies on a returned `Readable` stream, but in most Express apps we are writing directly to the `Writable` HTTP response stream without creating an intermediate stream (faster...):

``` javascript
var template = require('./template.marko');

module.exports = function(req, res) {
    template.render({ ... }, res);
}
```

 Just throwing that out there :)

Glad you are enjoying marko!
  That wouldn't be hard to implement but I always find `unless` confusing when reading CoffeeScript code. I'm sure I could get use to it though.
  Hi @kristianmandrup, I think that would be independent of Marko. In your application's main script (on either the server or client) you could run code to do what you are asking. In the Marko templates your expressions are just JavaScript so there would be no problem there.

However, I would recommend not using globals and to instead use `require` to import any JavaScript modules into your templates or other JavaScript code. Also, people might not be happy if you monkey patch the prototypes for core JavaScript types (unless they are polyfills).

Let me know if you still think that there is something that can be done to solve your common use case :)
 Hey @kristianmandrup. I'm going to go ahead and close this issue since you can make changes on your side to meet your needs. I don't think `marko` should be introducing any globals or making it easier to introduce globals. I think it is better to stick with the CommonJS way of importing dependencies using `require`. Let me know if you have any thoughts or suggestions. Thanks. 
  New version published with fix: `marko@2.7.24`
 Thanks for reporting the problem!
 De-duping is not happening if the found taglibs are coming from the cache...
  That's supported. Please see: https://github.com/marko-js/marko#loop-status-variable

That works for you, correct?
  Hi @kristianmandrup, thanks for the PR, but your changes broke tests (please run `npm test` first). I hope you don't mind, but I went ahead and made changes in marko core to support the following:

``` xml
<html-element tag-name="hello-${data.myTagName}" class="my-class" foo="bar">
    My nested content
</html-element>
```

Output:

``` html
<hello-world class="my-class" foo="bar">
    My nested content
</hello-world>
```

See: https://github.com/marko-js/marko/issues/137
 Not exactly... supporting dynamic components is a little tricky. It's kind of supported if you use `<invoke function="..."/>` but that's not a clean solution. We talked about adding support for something similar to the following:

``` xml
<register-dynamic-tag tag="ui-component-one"/>
<register-dynamic-tag tag="ui-component-two"/>

<dynamic-tag tag="ui-component-${data.variant}" name="Frank" message-count="${30}"/>
```

Is that along the lines of what you are thinking?
 It's doable, but it would require a little more work than what was required for `<html-element>`. I opened a Github issue: https://github.com/marko-js/marko/issues/139

I support that proposal, but I won't be able to work on it for at least a week or two. I need to finish up the marko website ([http://markojs.com.com](http://markojs.com/)!!!) and put together a blog post announcing Marko Widgets v5.

In the meantime, I recommend:

``` xml
<app-foo name="Frank" message-count="${30}" if="data.variant === 'foo'"/>
<app-foo name="Frank" message-count="${30}" else-if="data.variant === 'bar'"/>
<app-baz name="Frank" message-count="${30}" else/>
```
  `attrs` currently only applies HTML tags (not custom tags). You can, however, do the following:

``` xml
<icon-item c-data="item">
```

However, now that you point it out. We should allow: 

``` xml
<icon-item attrs="item">
```

I will make that change.
 Fixed. New version published: `marko@2.7.17`
  Since there is currently no JavaScript engine that natively supports ES6 modules, why not just use babel to transpile the ES6 module code into [mostly] equivalent ES5 code (that uses CommonJS module syntax)? Once you have ES5 code you can build browser JavaScript bundles using almost any of the popular JavaScript module bundlers (or the JavaScript module bundler can do the transpiling). That seems like a better strategy than buying into a custom module loading system such as SystemJS or jspm (each with their own quirks and proprietary features). When I look at SystemJS and jspm I am reminded of RequireJS and all of the ugly configuration that it required. If SystemJS or jspm do not support the [browser field spec](https://gist.github.com/defunctzombie/4339901) for remapping a server-side JavaScript module to a different browser-side JavaScript module then that would be a problem for marko. I recommend using [Lasso.js](https://github.com/lasso-js/lasso) or [Browserify](http://browserify.org/) (or possibly [Webpack](http://webpack.github.io/)) as your JavaScript module bundler for building client-side bundles of your JavaScript code.

I would not recommend trying to make marko (or any other module written in the Node.js way) work with RequireJS. Have you considered transforming your AMD code into CommonJS so that you can drop AMD and RequireJS completely (both are dying technologies).

With that said, if someone in the community wants to build a custom Marko loader for SystemJS or jspm then I'll try to help out, but it is not something I am interested in coding.
 I investigated integrating Babel a while ago and found that it was very
easy although I was waiting on some changes from Babel to make it more
efficient. Specifically, the Babel transpiler builds the Abstract Syntax
Tree (AST) of the code and we were hoping to leverage their AST instead of
also parsing it with esprima. I think Babel has since made some changes to
make it easier and better for tools like Lasso (bundler) to utilize ES6 via
Babel.

On Wed, Aug 26, 2015 at 11:08 AM, Patrick Steele-Idem <
notifications@github.com> wrote:

> Since there is currently no JavaScript engine that natively supports ES6
> modules, why not just use babel to transpile the ES6 module code into
> [mostly] equivalent ES5 code (that uses CommonJS module syntax)? Once you
> have ES5 code you can build browser JavaScript bundles using almost any of
> the popular JavaScript module bundlers (or the JavaScript module bundler
> can do the transpiling). That seems like a better strategy than buying into
> a custom module loading system such as SystemJS or jspm (each with their
> own quirks and proprietary features). When I look at SystemJS and jspm I am
> reminded of RequireJS and all of the ugly configuration that it required.
> If SystemJS or jspm do not support the browser field spec
> https://gist.github.com/defunctzombie/4339901 for remapping a
> server-side JavaScript module to a different browser-side JavaScript module
> then that would be a problem for marko. I recommend using Lasso.js
> https://github.com/lasso-js/lasso or Browserify http://browserify.org/
> (or possibly Webpack http://webpack.github.io/) as your JavaScript
> module bundler for building client-side bundles of your JavaScript code.
> 
> I would not recommend trying to make marko (or any other module written in
> the Node.js way) work with RequireJS. Have you considered transforming your
> AMD code into CommonJS so that you can drop AMD and RequireJS completely
> (both are dying technologies).
> 
> With that said, if someone in the community wants to build a custom Marko
> loader for SystemJS or jspm then I'll try to help out, but it is not
> something I am interested in coding.
> 
> â€”
> Reply to this email directly or view it on GitHub
> https://github.com/marko-js/marko/issues/134#issuecomment-135055021.
 Glad to hear @wheresrhys, thanks for sharing! I know you are using webpack, but I recommend checking out Lasso.js... I think it is pretty awesome and it offers a lot of features that webpack doesn't offer :) 
  Hi @kristianmandrup, I'm not sure if it makes sense to pull this into core just yet. Here's the same functionality provided as a separate module published to npm: https://github.com/marko-js/marko-tag-body

Does that work for you? 
 There's some really cool stuff that you can do simply by transforming the AST during the compilation stage. It definitely needs to be documented. I'm glad you were able to get your hands dirty and learn some of the tricks for marko!
  Did you forget the `w-bind`?
 `w-body` is also only for widgets (anything prefixed with `w-` is handled by `marko-widgets`). If you are not using `marko-widgets` then you need to do the following:

``` xml
<div class="ui $data.ui accordion">
    <invoke function="data.renderBody(out)" if="data.renderBody"/>
</div>
```
 It's more complicated for the `marko-widgets` use case since `marko-widgets` will handle preserving nested HTML content when the outer widget is rerendered. It will also handle updating the nested HTML content when the outer widget does not need to be rerendered, but new nested content was provided. In addition, `w-body` must be bound to a container HTML element in order for everything to work.
 Hi @kristianmandrup, you don't need to patch marko to support this. It can be done completely in user land. Let me put together a separate project that you can use as an example.
  First off, it's all just code so we can make anything work :) I don't see anything here to suggest that you would need a difficult change and I would be surprised if second-level imports are not supported. If that is the case then we should fix it. I'll add a test case and see what I can figure out.

Also, can you please clarify on the following?:

> Looks like the problem is in part caused by using browser-refresh

What makes you think that?
 Great. Thank you. I'll take a look now.
 Thanks for the sample project, @kristianmandrup. I was able to reproduce the problem pretty quickly and I have put in a fix. New version published: `marko@2.7.14`

Let me know if you see any other issues. Thanks again!
 :+1: on logging. The [debug](https://github.com/visionmedia/debug) module would probably be the most appropriate since you could launch the app with `DEBUG=marko node server.js` to see exactly what marko is doing during compilation. Do you mind opening a separate Github issue to describe what type of logging you would be interested in for marko?
 @kristianmandrup, please try the following:

```
MARKO_CLEAN=true node your-app.js
```

That will force all templates to be recompiled.
 Do you see any issue with the test case I added? It was pretty much your code with some extra things removed and the test cases are passing.

Do you by any chance have a circular dependency in your imports?
 I just pushed a small change to handle circular imports, but I don't think that is impacting you because otherwise you would have seen a `Maximum call stack` error. Here's the fix I pushed: https://github.com/marko-js/marko/commit/608d9092bbc71ac5e79a0b8c0ec15d9de88698b3
 Is your app crashing?

Do you think you would be able to provide a fork of marko with a failing test case?
 Are those global imports in an installed node module?
 If `buildLookup()` is not being called then that would suggest that no templates are being compiled. Make sure you run your app with `MARKO_CLEAN=true node app.js` to force all templates to be recompiled.
 The logic for disabling the `checkUpToDate` looks fine to me so `MARKO_CLEAN=true node app.js` should force all templates to be recompiled. Are you sure that is not happening?
 If you are using the Node.js require extension then it will be here:

https://github.com/marko-js/marko/blob/8035b5de72fc8258f88bcccec41e9e8ce0ff4245/node-require.js#L28
  Was that a question and then an answer to your own question? :)

Should I close this issue, or do you think we need to improve the docs for `renderBody(out)` as it relates to Marko?: https://github.com/marko-js/marko#tag-renderer
  Thanks!
  Thanks!
  Glad to have you on this project!
  Hi @kristianmandrup, if you have a `marko-tag.json` and you don't declare a certain attribute then it is considered a "splat" attribute and it is added to a special "*" property. The fix is to declare the `"@data": "expression"` attribute in your `marko-tag.json` file. See: https://github.com/marko-js/marko#defining-attributes

With that said, the Marko compiler should probably throw an error at time unless you explicitly add the "@*" attribute.  I'm going to investigate.

Also relevant: https://github.com/marko-js/marko/issues/90 (Proposal: Replace HTML parser with a new parser that recognizes attribute types)
  Thanks for reporting the confusing error message. I just pushed a commit that should make things less confusing. New version published: `marko@2.7.10`

Please let me know if you see any other issues. Thanks.
 You're welcome.

For Marko Widgets, we hope to release v5 next week. I've been focusing on benchmarking and testing this week and I do not expect the API to change for the final v5 release. That is, I encourage you to use the latest beta version now so that we can find and fix any bugs sooner :)

I'm not sure if you have had a chance to review, but I have updated the docs and added benchmarks to `morphdom`. See: https://github.com/patrick-steele-idem/morphdom

I've also updated the benchmarks we used to compare performance of Marko Widgets with React using the latest `5.0.0-beta.2` release: [Marko vs React: Performance Benchmark](https://github.com/patrick-steele-idem/marko-vs-react) (summary: React and Marko Widgets perform almost identical in the browser, but Marko Widgets is 10x faster when rendering on the server. In addition, Marko Widgets is much more lightweight)
  Hi @zwhitchcox, you might want to try reversing the order of the `this.body` and the `this.type` assignments as shown below:

``` javascript
'use strict';
require('marko/node-require').install();

let koa    = require('koa')
let app    = koa()
let template = require('./views/index.marko');

app.use(function* () {
    this.type = 'type/html'
    this.body = template.stream()
})
server.listen(3000);
```

I don't use Koa, but I suspect that when you assign the stream to `this.body` that it commits the response body. If that is the case, then the `Content-Type` header may not be sent correctly.

I also updated your code to use the Node.js require extension :)

Let me know if that does or does not solve your problem.
 Doh :)

I bet if the page HTML would have looked like HTML the browser would have been cool with it so it probably didn't help that it only rendered `hello`.
 Hey @Globik, 

Probably better to open a separate Github issue in the future, but I'll try to answer your questions below.

> So is correct: `this.type = "html";`

The following is the correct content type for HTML responses:

``` javascript
this.type = 'text/html; charset=utf-8';
```

> Your marko is "simple" enough, but how do I build a binary tree with marko?

Marko supports macros (inline functions for rendering HTML) and those functions can be called recursively: http://markojs.com/docs/marko/language-guide/#macros

You will want to do something similar to the following:

``` xml
<def function="renderTree(node)">
    <div class="node">
        <span>${node.value}</span>
        <div class="left">
            <invoke function="renderTree(node.left)" if="node.left"/>
        </div>
        <div class="right">
            <invoke function="renderTree(node.right)" if="node.right"/>
        </div>
    </div>
</div>

<invoke function="renderTree(data.rootNode)"/>
```

> Where is marko's tutos can i find?

Definitely start with the screencasts if you haven't watched those yet: https://www.youtube.com/playlist?list=PLZUgs-F38XXQJBxA58UqnwTVMZS_uza_C

Also check out:
- [Try Marko Online](http://markojs.com/try-online/)
- [Language guide](http://markojs.com/docs/marko/language-guide/)
- [Sample apps](https://github.com/marko-js-samples/)

If you think there are particular tutorials that are needed please share by opening a Github issue. Also, please join us in the Gitter chat room and we will be happy to answer any questions you might have: https://gitter.im/marko-js/marko
  Hi @dtrikannad,

I'm assuming you are using the [flash](https://github.com/expressjs/flash) module for Express. I've not used that module, but according to the documentation the flash messages are stored in the `res.locals.flash` variable and they are an array in the following form:

``` json
{
    "type": "info",
    "message": "message"
}
```

I would recommend just passing the flash messages to your page template as part of the template data similar to the following:

``` javascript
var template = require('./template.marko');

app.get('/', function(req, res) {
    template.render({
            flashMessages: res.locals.flash
        }, res);
});
```

And then in your template:

``` xml
<ul>
    <li for="flashMessage in data.flashMessages">
        <b>Type:</b> ${flashMessage.type}<br>
        <b>Message:</b> ${flashMessage.message}
    </li>
</ul>
```

I hope that answers your question.
 Hi @dtrikannad, glad that solved your problem. Do you have a stack trace with your 500 error? Marko doesn't have any `try...catch` blocks so any exception is just going to bubble up. If you are not seeing a proper stack trace in your logs then I think there are issues with how your server is configured and that is going to cause more problems for you in the future. Did you you add your own uncaught exception handler (e.g. `process.on('uncaughtException', function(err) { ... })`);? Are you using promises (promises catch exceptions and will silently eat them in some circumstances)?

If you are desperate you can do the following:

``` xml
{% try { %}
<require module="../private_libraries/globals_v1.js" var="globals"/>
<if test="!globals.isEmpty(data.messages)">Not Empty</if>
{% } catch(e) { console.error(e); } %}
```

(using embedded scripts is not recommended!)

I hope that helps
 Hi @dtrikannad, I'm going to close this issue, but if you are still facing issues related to debugging then feel free to comment here or open another Github issue.
 Hey @crash85, the "flash messages" are stored in a session that persists across redirects. See:
 https://github.com/expressjs/flash/blob/92fd748feb60c9a277622ce75ef7091735796af9/index.js#L6-L8

As an addendum to my earlier response, whenever you pass flash messages to the template to be rendered you should just also clear out flash messages from the session:

``` javascript
var template = require('./template.marko');

app.get('/', function(req, res) {
    var flashMessages = res.locals.flash;
    if (flashMessages) {
        flashMessages = res.locals.flash.concat([]); // Clone the flash messages before clearing
        res.locals.flash.length = 0; // Remove all of the elements from the flash messages stored in the session
    }  

    template.render({
            flashMessages: res.locals.flash
        }, res);
});
```

I don't use sessions in my app and I don't use the `flash` module, but that should work for you (assuming you have Express sessions set up correctly).
  Nice improvement. Thank you!
  Hi @williamvivier, I created a `<USER_HOME>/emmet/snippets.json` file and I also needed to update my Atom `keymap.cson` file (`Atom` â†’ `Open Your Keymap`):

_`keymap.cson:`_

``` coffee
'atom-text-editor[data-grammar~="marko"]:not([mini])':
    'tab': 'emmet:expand-abbreviation-with-tab'
```

_`<USER_HOME>/emmet/snippets.json:`_

``` json
{
    "marko": {
        "extends": "html",
        "snippets": {
            "for": "<for each=\"${1:item} in ${2:items}\">$3</for>",
            "@for": "for\"${1:item} in ${2:items}\"",
            "attrs=": "attrs=\"${1:expr}\"",
            "if": "<if test=\"${1:condition}\">$2</if>",
            "@if": "if=\"${1:condition}\"",
            "else-if": "<else-if test=\"${1:condition}\">$2</else-if>",
            "@else-if": "else-if=\"${1:condition}\"",
            "else": "<else>$1</else>",
            "var": "<var name=\"${1:name}\" value=\"$2\"/>",
            "assign": "<assign var=\"${1:var}\" value=\"$2\"/>",
            "require": "<require module=\"${1:module}\" var=\"$2\"/>",
            "op": "<optimizer-page package-path=\"${1:./optimizer.json}\"/>",
            "oh": "<optimizer-head/>",
            "ob": "<optimizer-body/>",
            "use": "<layout-use template=\"${1:./path/to/template.marko}\">\n    <layout-put into=\"${2:target}\">\n        ${3:content}\n    </layout-put>\n</layout-use>",
            "placeholder": "<layout-placeholder name=\"${1:name}\"/>",
            "put": "<layout-put into=\"${1:name}\"/>",
            "async": "<async-fragment data-provider=\"${1:data.myDataProvider}\" var=\"${2:varName}\">\n    ${3:}\n</async-fragment>",
            "bind": "w-bind=\"${1:./widget}\"",
            "include": "<include template=\"${1:./path/to/template.marko}\"/>",
            "?": "{?${1:expression};${2:trueTemplate};${3:falseTemplate}}",
            "def": "<def function=\"${1:name}(${2:params})\">\n    ${3:}\n</def>",
            "invoke": "<invoke function=\"${1:name}\" ${2:arg1Name}=\"${3:arg1Value}\"/>",
            "comment": "<html-comment>$1</html-comment"
        }
    }
}
```

Also, I had opened up an issue against the Emmet Atom project on Github that has relevant discussion: https://github.com/emmetio/emmet-atom/issues/206

Ideally, the Marko plugin for Atom would automatically enable Emmet support, but right now the Emmet API has limitations that prevent this.

Hopefully editing those two files enables Emmet for you, but let us know if you are still running into issues.
 Hey @williamvivier, I'm just do some housecleaning and am reviewing old issues. I'm going to go ahead and close this issue, but if you are still having issues getting Emmet to work with Marko please let us know. Thanks! 
  Hey @kristianmandrup, I'm just going through old issues to do some housecleaning. I'm going to go ahead and close this issue, but if this is still an issue/question please feel free to add more comments. 

On a related note, I plan on sharing a marko roadmap later this week. Work is [in-progress](https://github.com/marko-js/marko/tree/htmljs-parser) to integrate the new [htmljs-parser](https://github.com/philidem/htmljs-parser) as discussed in the following proposal: https://github.com/marko-js/marko/issues/90

The new syntax is much cleaner and more powerful. For example:

``` xml
Hello ${data.name}!

<ul if(notEmpty(data.colors))>
    <li for(color in data.colors)>
        ${color}
    </li>
</ul>
<div else>
    No colors!
</div>

<if(notEmpty(data.colors))>
    <ul>
        <for(color in data.colors)>
            <li>
                ${color}
            </li>
        </for>
    </ul>
</if>
<else>
    <div>
        No colors!
    </div>
</else>
```

We will also be introducing a cleaner syntax for macros/functions:

``` xml
<function renderTree(node)>
    Name: ${child.name}

    Children:
    <ul if(node.children)>
        <li for(child in node.children)>
            <renderTree(child)/>
        </li>
    </ul>
</function>

<renderTree(data.node)>
```

And ES6-style imports:

``` xml
<module-imports>
    reverse from "./helpers";
    foo from "./foo";
</module-imports>

Hello ${reverse('Frank')}
```

Just wanted to share with you, because I think these changes will likely impact how you are doing things with the jade transpiler. If you have feedback, please share!

Thanks.
  Thank you again, @merwan7, for the contribution!
  Hi @sandro-pasquali, the Marko compiler processes `${expression}` found in JavaScript strings to produce compiled JavaScript code that uses concatenation to achieve the expected result. Essentially, you get the benefits of ES6 template strings inside Marko templates and there is no conflict with ES6 since the code is transpiled to ES5 compatible code at compile time.

For example, given the following template:

``` xml
${"Hello ${data.name}"}
```

The compiled code will be similar to the following:

``` javascript
"Hello "+data.name
```

Interestingly, if you want to use ES6 template strings you can still do that by using backticks instead of string quotes (Marko only process `${...}` tokens inside JavaScript strings). For example, given the following template:

``` xml
${`Hello ${data.name}`}
```

The compiled output will be the following:

``` javascript
`Hello ${data.name}`
```

The above compiled code will work exactly as expected in web browsers that support ES6.

Hopefully that answers your question, but let me know if not.
  Hi @kristianmandrup, can you please provide more details on your use case and why you need this feature? I think that will allow is to provide a better solution to your problem.

Also, we want to make ensure that templates still compile through the command line compiler and other tools. If application code must first register taglibs as you described then that would mean that other tools would not work as expected unless they also some how loaded your application code to register the additional taglibs.

On a related note, Marko does support the ability for a taglib to import another taglib (here's a link to the [relevant code in loader-taglib.js](https://github.com/marko-js/marko/blob/156f04ed3537b3e1d0561f87a3353ac7e0c1f543/compiler/taglibs/taglib-loader/loader-taglib.js#L138)). Not sure if that would solve your problem though.

Please provide more details on your use case. Thanks!
  Interesting. It looks like the html parser we are using (i.e., [htmlparser2](https://github.com/fb55/htmlparser2) is processing the `<%` tags, and I don't think it would be reasonable to change that HTML parser. 

Marko is designed to render pure HTML code. While you can use it to render JSP code you will have to avoid using the special JSP tags in your Marko template. 

I suggest the following workaround:

## Create a custom tag to render the JSP directives and scriptlets

``` xml
<jsp-directive type="page" contentType="text/html;charset=UTF-8" language="java"/>
<jsp-directive type="taglib" prefix="sec" uri="http://www.springframework.org/security/tags"/>
<jsp-directive type="taglib" prefix="spring" uri="http://www.springframework.org/tags"/>

<jsp-scriptlet>

</jsp-scriptlet>

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title></title>
</head>
<body>

</body>
</html>
```

The JavaScript renderer for the `<jsp-directive>` tag might look like the following:

``` javascript
module.exports = function render(input, out) {
    var type = input.type;
    out.write('<%@ ' + type);

    var attrs = input['*'];
    for (var k in attrs) {
        if (attrs.hasOwnProperty('k')) {
            out.write(' ' + k + '="' + attrs[k] + '"');
        }
    }

    out.write('%>');
};
```

The JSON declaration for the tags might look like the following:

``` json
{
    "<jsp-directive>": {
        "renderer": "./jsp-directive-tag.js",
        "@type": "string",
        "@*": "string"
    },

    "<jsp-scriptlet>": {
        "renderer": "./jsp-scriptlet-tag.js"
    }
}
```

Let me know if you still have questions.
  Hi @ahmadnassri, the Marko compiler puts the compiled templates next to the original template because the Node.js module loader is context aware and we want the stack traces to match up with location that the Node.js module loader associates with the loaded compiled template. That is, the location of the JS module on disk matters since it impacts how `require`'d modules are resolved. Currently, we calculate all of the relative paths based on the original template location on disk and we therefore put the compiled template module next to the original template file. While we could place the compiled template at a different location on disk, we would need to change how the relative `require` paths are generated. Also, at a minimum, each module in the application would need to have its own parallel directory tree for compiled templates so that the required Node.js modules would be resolved relative to the module that contains the template. Something like the following:

```
my-app/
    .marko-compiled/
        foo/
            template.marko.js
        bar/
            template.marko.js
    foo/
        template.marko
    bar/
        template.marko
    node_modules/
        my-installed-module/
            .marko-compiled/
                foo/
                    template.marko.js
                bar/
                    template.marko.js
            foo/
                template.marko
            bar/
                template.marko
```

However, I would be concerned about the impact on usability if we move compiled templates to a parallel directory tree. There were also be other impacts on usability that would need to be explored. I don't want to dismiss your suggestion, but unfortunately it is not as simple as changing where the compiled template gets stored on disk.
 Hey @ahmadnassri, we added an option to disable writing compiled templates to disk:

``` javascript
require('marko/compiler').defaultOptions.writeToDisk = false; 
```

Please see issue #150 and commit 370ac4b3ab2adc078b0b1c79f8f58186cd8074e9.

If that is an acceptable solution then I would like to close this issue. Please let me know. Thanks.

Does that resolve this issue?
 Do you have an recommendation for a cleaner way to set the option? We can always adjust.
  Hi @thomasJang, can you please provide more clarity on what you are asking? The `marko-taglib.json` files are found relative to the template being compiled using the following search path: https://github.com/raptorjs/marko#taglib-discovery

If you can provide more details on what you are trying to accomplish I should then be able to provide better help. Thanks.
 Hi @thomasJang, the location cannot be changed because that would break other things (for example, the command-line compiler would not work). While we could make it possible to register additional `marko-taglib.json` files via code, I don't think that would be a good idea.

Not sure if it solves your use case but you can create a `marko-taglib.json` that imports other taglibs as shown below:

``` json
{
    "taglib-imports": [
        "./path/to/another/marko-taglib.json"
    ],
    ...
}
```

Can you provide more details on your use case? Why do you need `marko-taglib.json` files to be in another location?
 Sounds good. If you run into any specific issues or get stuck please feel free to post a new issue. It's pretty easy to change things if necessary so just let us know. Thanks and good luck with your coding!
  Hi @thomasJang, the marko compiler strips all whitespace by default (including trailing new lines). You can disable whitespace removal by doing the following:

``` javascript
require('marko/compiler').defaultOptions.preserveWhitespace = true;
```

You'll need to force a recompile all your templates. The easiest way to do that is to set the `MARKO_CLEAN` environment to `true`:

```
MARKO_CLEAN=true node .
```

Of course, you can also just append the new line in your code:

``` javascript
tmpl.render(data, function(err, output){
    if(!err)
        grunt.file.write(dest, output + '\n');
    else
        grunt.log.error(err);
});
```

Hopefully that answers your question, but if not please let me know.
 Also, please check out the following docs: [Marko >> Whitespace](https://github.com/raptorjs/marko#whitespace)
  Hi @snapwich, this question has come up before and here is a relevant discussion: https://github.com/raptorjs/marko/issues/6

The main reason for writing the compiled template to disk is so that stack traces will be valid in case there is an exception thrown during template rendering. By design, the Marko template compiler produces very readable JavaScript output. It would be extremely frustrating to debug a JavaScript exception if the loaded source code was not available.

In addition, the compiled template _must_ be loaded through the Node.js module loader (or a compatible CommonJS module loader of some sort). If you take a close look at the compiled output of a template you will see that most templates make heavy use of the `require` function that is only available inside the context of a CommonJS module. The `require` function is used to load included templates, custom tags, etc. In other words, you can't just `eval` the compiled output and expect things to work.

In theory, we could provide an option to disable the writing of the compiled Marko template to disk with a small code change but I think that would be undesirable. I'm happy to discuss some more and would not necessarily be opposed to a PR (as long as the default was still to write the compiled template to disk).

Let me know if you still have questions. Thanks.
  Hi @kristianmandrup, you should probably be using custom tags instead of partials. Custom tags are superior to vanilla partials in many ways and are often easier to use.

Instead of the following:

``` xml
<include template="../../path/to/header.marko" ... />
```

Just make header a custom tag:

``` xml
<my-header .../>
```

With custom tags, the path of the partial template doesn't matter and Marko makes it easy to utilize custom tags provided by installed Node modules. Custom tags can be associated with a JavaScript renderer or just a template (if a JavaScript renderer is not needed).

It is considered a bad practice to use includes/partials where the target partial template is outside the current directory of the parent template. That is, a partial is probably fine if it the parent template and the partial template are in the same directory.

If you create a Node.js module that is to export custom tags, just put a `marko-taglib.json` in the root of the module. I recommend taking advantage of directory scanning for automatically discovering taglibs based on the directory structure. Please see [Scanning for Tags](https://github.com/raptorjs/marko#scanning-for-tags).

The marko compiler will automatically discover the exported taglib of installed modules and make the taglib available to any template that has the taglib in its search path. Please see [Taglib Discovery](https://github.com/raptorjs/marko#taglib-discovery)

I hope that answers your question. Please let me know if you would like to discuss some more. I will try to put together a sample project that illustrates creating and utilizing custom tags.
 Closing issue for now, but please feel free to add additional comments. Thanks.
  While [consolidate.js](https://github.com/tj/consolidate.js/) doesn't support streaming, we should still add marko support for better visibility to this project.

I'm requesting help from the community in sending a Pull Request to the [consolidate.js](https://github.com/tj/consolidate.js/) project to add support for the marko template engine. Thanks in advance!
 There are two issues with that PR:
- Issue 1) It doesn't cache the loaded template
- Issue 2) Marko needs both the template's source (as a string) and the  template's file system path.

**For issue 1:** make sure you use the provided cache to cache the loaded marko template: https://github.com/gregwebs/consolidate.js/blob/8592fed81cd4483ff433b3fdc1d5ea190e004097/lib/consolidate.js#L525

**For issue 2:**  I believe the template's file system path is provided as `options.filename` based on the following line:
https://github.com/gregwebs/consolidate.js/blob/8592fed81cd4483ff433b3fdc1d5ea190e004097/lib/consolidate.js#L138

You can then use the marko [`load(templatePath, templateSrc)`](http://markojs.com/docs/marko/javascript-api/#loadtemplatepath-templatesrc-options--template) method to load the template:

``` javascript
var template = marko.load(str, options.filename);
```

And then to render the loaded template:

``` javascript
template.render(options, fn);
```

I don't like the Express view engine (see [Bypassing Express View Rendering for Speed and Modularity](https://strongloop.com/strongblog/bypassing-express-view-rendering-for-speed-and-modularity/) and I don't like `consolidate.js`, but for visibility to marko it is probably worthwhile to enable marko template rendering via consolidate.js... The biggest downside is that streaming/progressive HTML rendering won't work.

Thanks for looking into it @seangates!
 See: https://github.com/tj/consolidate.js/pull/255
 @bitinn I've not used `metalsmith`, but loaded `.marko` templates are loaded and cached by the Node.js module loading system the same as normal `.js` modules. That is, they are cached in `require.cache` and deleting from `require.cache` will cause the template to be reloaded on the next `require()` of the template. `metalsmith-watch` supports a `invalidateCache` that might work. 

`marko` also supports a special `hot reload`: https://github.com/marko-js-samples/marko-hot-reload. You'll need to use your own file watcher to tell `marko` when a file is modified and `marko` will ensure that all templates automatically hot reload such that the next time they render they will be render based on the modified source.

Please let me know if you need more details @bitinn.  Closed via https://github.com/tj/consolidate.js/pull/255. Thanks @fabsrc!  Hi @kristianmandrup,  I updated the docs to mention the `template-data` attribute that is supported on the `<include>` tag. For your example, you would want to do the following:

``` xml
<include name="xyz.marko" template-data="${data}"/>
```

Here's a link to the relevant docs that now mentions the `template-data` attribute:
https://github.com/raptorjs/marko#includes

Please let me know if that doesn't solve your problem.

Thanks.
 Hey @jcc2303, can you please provide more details on your problem? I believe it is best to open a separate Github issue because your code seems unrelated to what @kristianmandrup described. Please clarify. Thanks.
  Hi @jackhorton, this is not clarified in the docs, but if the `template` attribute is a dynamic expression (not a static string) then the expression should resolve to an already _loaded_ template. You can load the template in the template itself as shown below:

``` xml
<require module="../relative/path/to/template.marko" var="myLoadedIncludeTemplate"/>
<include template="$myLoadedIncludeTemplate" />
```

However, if it usually cleaner for the include template to be loaded by the custom tag/controller and for it to be provided as part of the view model to the template.

``` xml
<include template="$data.myLoadedIncludeTemplate" />
```

I'll update the docs, but let me know if that doesn't work for you.

There are two ways to load a template in your JavaScript code:

Option 1)

``` javascript
var myLoadedTemplate = require('marko').load(require.resolve('./template.marko'));
```

Option 2)

``` javascript
require('marko/node-require').install(); // Called once in your application main script
// ...
var myLoadedTemplate = require('./template.marko');
```

Option 2 is recommended
 Hi @jackhorton, just an update: I put in a minor tweak to allow the `template` attribute to be a dynamic path that can be relative. It is still recommended to preload the include target and pass a reference to the fully loaded template. This mainly because JavaScript module bundlers that do static code analysis will not find dynamically required templates.

New version published: `marko@2.7.4`

Please let me know if you have any questions or still have issues. Thanks. 
  Hi @yomed, instead of a custom tag (which is associated with a renderer function) you can invoke a `renderer(input, out)` function directly:

``` javascript
data.renderers=[
    require('../foo'),
    require('../bar'),
    require('../baz')
]
```

``` xml
<for each="renderer in data.renderers">
    <invoke function="renderer(myInputObject, out)"/>
</for>
```

I don't know exactly how that fits into your app, but hopefully you get the idea. FYI, a custom tag is resolved to a renderer at compile-time.

Please let me know if that doesn't solve your problem.
 Assigning a `w-id` attribute to an `<invoke>` tag currently doesn't work because of how the compile-time transform is implemented for marko-widgets. I'll look into seeing if it can be supported with a small code change. Can you please open a Github issue against the [marko-widgets](https://github.com/raptorjs/marko-widgets) project?
 marko-widgets was updated to support the `w-id` attribute with the `<invoke>` tag: https://github.com/raptorjs/marko-widgets/issues/46

Closing this issue.
  You mentioned two separate issues:

> what if class name is coming dynamically from the JavaScript object.

For that you will want to use the custom `attrs` attribute which allows attributes to come from a JavaScript object: https://github.com/raptorjs/marko#attrs

> Also there is inconsistency across marko for defining JavaScript expression. Some places its using ${}, some places it dosent needs ${} and here its using {?condition;value} (WITHOUT $ sign)

That is a known issue that would be solved with the following proposal: https://github.com/raptorjs/marko/issues/90 (Proposal: Replace HTML parser with a new parser that recognizes attribute types)

Please let me know if that does or does not address your concern so that I can close this issue. Thanks.
 Hi @SunnyGurnani, If an attribute type is declared as `expression` (such as `value` attribute for the `<assign>` tag) then the attribute value is assumed to be a valid JavaScript expression. Therefore you would need to have the value be valid JavaScript such as the following:

``` javascript
<assign var="viewDetailsClass" value="data.listingModel.bin.binAction ? 'btn' : 'btn btn--primary'"/>
```

Longer term, we want to have everything be JavaScript. Again, this would be solved by the following proposal: https://github.com/raptorjs/marko/issues/90 :)
  For the benefit of those outside eBay, here's the template that you shared:

``` xml
<div ${helper.renderAttributes()} >
    Please inspect my container element and you will find dynamic content is not evaluated
</div>
```

The above is not valid HTML and will not be parseable. However, the equivalent alternative is to take advantage of the custom [attrs](https://github.com/raptorjs/marko#attrs) attribute as shown below:

``` xml
<div attrs="helper.getTrackingAttributes()">...</div>
```

Where the `helper.getTrackingAttributes` is implemented as shown below:

``` javascript
function getTrackingAttributes() {
    return {
        "attr1": "attr1Value",
        "attr2": "attr2Value"
    }
}
```

Alternatively, you could use a custom compile-time transform to add the attributes to allow for something similar to the following:

``` xml
<div tracking-attrs/>
```

The benefit of a custom compile-time transform is that it could add extra validations to handle the case where an element may be missing an `id` or some other attribute.

Let me know if this answers your question or if you would like more help with a custom compile-time transform.
 Hi @SunnyGurnani, I was hoping to put together a sample app to demonstrate custom compile-time transforms to process custom attributes, but I have been pretty swamped. In the meantime, it might be helpful to understand how marko-widgets utilizes compile-time transforms.

Here is the implementation for the marko-widgets compile-time transform:
https://github.com/raptorjs/marko-widgets/blob/master/taglib/widgets-transformer.js#L21

Here is the taglib that registers the transform:
https://github.com/raptorjs/marko-widgets/blob/master/marko-taglib.json#L70

I still hope to improve the docs for this advanced feature, but hopefully this helps in the meantime. Thanks for your patience. 
 Closing this issue. I have opened another issue to improve the docs for compile-time transforms to better explain how custom tags and custom attributes can be processed at compile-time: https://github.com/raptorjs/marko/issues/100
  Currently, Marko is using an HTML parser. An HTML parser treats every attribute value as a `String` type regardless of how it is written.

For example, with an HTML parser the following lines are all equivalent:

``` xml
<my-component foo=123/>
<my-component foo="123"/>
<my-component foo='123'/>
```

As a result of this limitation, Marko relies on custom tag schemas to associate a type with an attribute value or the developer must use the `${<javascript-expression}` syntax. Tag schemas are great for documentation but they are a pain to maintain and they make usage of a custom tag ambiguous. Not to mention, the `${<javascript-expression}` syntax can only be used with attributes that have a `string` type (not `expression`, `boolean`, etc.).

The author of the `<my-component>` tag can separately declare the type for an attribute and developer viewing a template wouldn't know the attribute type unless you consulted the tag schema:
It would be great if the parser used by Marko treated _all_ attribute values as _JavaScript expressions_. Spaces will end an attribute value unless the space is in a quoted string or within a parenthesis/square brackets/curly braces block. Finally, we would support `${<javascript-expression>}` usage within [ES6 Template strings](http://tc39wiki.calculist.org/es6/template-strings/) (i.e. strings "quoted" using backticks). The following illustrates what is being proposed.

``` xml
<my-component number=1/>
<my-component variable=name/>
<my-component complex-expression=1+2/>
<my-component complex-expression-with-spaces=(a + b)/>
<my-component simple-string="hello"/>
<my-component simple-string='hello'/>
<my-component dynamic-string=`hello ${name}`/>
<my-component string-concatenated=("hello "+name)/>
<my-component boolean=true/>
<my-component array=[1, 2, 3]/>
<my-component object={hello: 'world'}/>
<my-component function-call=data.foo()/>
<my-component complex-function-call=(data.foo() + data.bar())/>
```

Now that we are using a custom parser, we can also improve the syntax for conditionals and looping as @onemrkarthik suggested:

``` xml
<div if(x > 5)>
   Do something
</div>

<ul>
   <li for(color in colors)>
       ${color}
   </li>
</ul>

<ul>
   <li for(color in colors; status-var=loop)>
       ${loop.getIndex+1}) ${color}
   </li>
</ul>
```

Here's what for-loops and conditionals would look like as tags:

``` javascript
<if(x > 5)>
    <div>
        Do something
    </div>
</if>

<ul>
    <for(color in colors)>
        <li>
            ${color}
        </li>
    </for>
</ul>

<ul>
    <for(color in colors; status-var=loop)>
        <li>
            ${loop.getIndex+1}) ${color}
        </li>
    </for>
</ul>
```

Thoughts? Concerns?
 Hey @SunnyGurnani, as for JavaScript arrays and objects, we should make sure the following works as well:

``` xml
<my-component array=[1, 2, 3]/>
<my-component object={hello: 'world'}/>
```

I'll updated the proposal. Thanks for the feedback
 Hi @pswar, good question. Yes, any valid JavaScript expression is allowed on the right-hand side and will be copied to the compiled JavaScript template verbatim. I'll update the proposal to make this clear. Thanks for the feedback
 Do you think that for parsing simplicity we should require expressions to be wrapped with parentheses? If you can get it work without parentheses that would be great but I could see how that might be tricky.

For example, consider:

``` xml
<my-component object=someFunc (1) />
```

That space after `someFunc` might look like a new attribute to the parser.

This would be safer in all cases:

``` xml
<my-component object=(someFunc (1)) />
```
 Hey @philidem, I see where you are coming from, but requiring parenthesis would actually make things more confusing I think. It would be a bad idea to require that variable names be wrapped in parenthesis like the following:

``` xml
<my-component variable=(foo) />
```

The following is better:

``` xml
<my-component variable=foo />
```

In this case, `foo` just happens to be a simple variable expression (not a function call).

I think using a space (outside of a code block) is the best way to delimit attributes.
 Hi @vedam, you bring up a good question regarding the use of backticks for template strings. Adopting backticks would make things more like JavaScript, but my initial reaction is that why not allow number quoted strings to be treated as template strings? We are processing all of these strings at compile-time to find the dynamic parts so there is no performance hit at runtime. Also worth mentioning is that we already support dynamic parts in normal quoted strings so switching to backticks would make things potentially problematic for developers migrating to the new version (migration is also a very important topic that needs to be discussed since this proposal would definitely be a breaking change). The only negative about not using backticks is that developers would need to escape the `$` character inside quoted strings if it is not intended for a dynamic part. I'm leaning towards not supporting backticks, but I would like to get more thoughts from others since I think it is definitely worth discussing some more.
 Hey @vedam, I'm actually okay with supporting backticks, but I would want to transpile the code to its ES5 equivalent so that it works in older browsers that do not support that ES6 feature.

For example,

``` javascript
`foo ${name}`
```

Would be transpiled to the following:

``` javascript
'foo ' + name
```

I think the end result would be the same. I agree with your sentiment that the right-hand should just be JavaScript...this makes Marko more intuitive and more powerful.

If we agree to support backticks, then the question becomes: should we also support dynamic parts in normal quoted strings or should dynamic parts only be allowed in ES6 template strings?
 :+1: for supporting string templates with backticks

I think usage of backticks is a good idea and I think the Marko compiler could easily convert the string template to ES5 JavaScript.

Let's make this happen!
 To @patrick-steele-idem's question, I would suggest only support variable replacement in string templates which are delimited with backticks. That is, don't do variable replacement within strings delimited with `"` and `'`.

Since migration tool seems necessary, I think we should convert any existing string attribute values to ES6 templates (using backticks).
 Hi @SunnyGurnani, what is being proposed is that the right-hand side is _always_ a JavaScript expression. If it is valid JavaScript expression then it can go on the right hand side and it will actually be copied into the compiled JS verbatim. Even if right-hand value is a simple string it would still be a valid JavaScript expression. I think this will make things the least confusing.

The only special case is for attributes that are interpreted at compile-time (e.g. `for="color in ['red', 'green', 'blue']`)

Seem reasonable?
 Thanks for the comments @pswar. Some related thoughts:

1) I think we are saying the same thing. I'm in favor of _only_ allowing `${...}` in strings that use back ticks as "quotes" (not in strings quoted using double or single quotes). For example:

``` xml
<my-component my-dynamic-string=`Hello ${data.name}!`/>
```

On top of that, we would transpile ES6 template strings to an ES5 equivalent.

2) If you want to have a string of `"[1, 2, 3]"` then you would just do: `mystring="[1, 2, 3]"`. If you want an Array of `[1, 2, 3]` then you would just omit the quotes: `myarray=[1, 2, 3]`
 NOTE: I have updated the proposal to reflect that `${...}` should _only_ be allowed in ES6 template strings.
 Hi @DanCech, this is still a developing proposal so nothing is set in stone. My thinking is that this is definitely going to be a breaking/major change and old templates will need to be migrated to work correctly with the new Marko version. We would want to make the migration as easy as possible so at a minimum we would need to provide a tool that would automatically update existing Marko templates to conform to the new parser by doing things such as the following:

**Old:**

``` xml
<my-component foo="Hello ${data.name}"/>
```

**New:**

``` xml
<my-component foo=`Hello ${data.name}`/>
```

As another example, if a custom "foo" attribute is declared as an "expression" type then the following conversion would happen:

**Old:**

``` xml
<my-component foo="data.name"/>
```

**New:**

``` xml
<my-component foo=data.name/>
```

---

Beyond that, if you are concerned that it would be hard to unlearn the old handling of `${...}` in attribute values or that you still prefer all `${...}` to be processed in all strings then that would be a good argument for going back to the old behavior and allowing `${...}` in _all_ quoted strings. Honestly, I could go either way since I see the value in both choices.
 Hi @SunnyGurnani, I think there might be a misunderstanding because with the updated proposal we want to go _closer_ to the simplicity of pure JavaScript. Instead of tag schemas, we are saying that an attribute value is simply a pure JavaScript expression and nothing more and nothing less. Marko has always been close to JavaScript by design but with the latest proposal we want to take it even closer. That is, Marko aims to be a perfect blend of JavaScript and HTML :)
 Also, @SunnyGurnani, the parenthesis are only needed in situations where a "complex" expression has spaces that would have otherwise ended the attribute value.
 The idea is that the `foo` attribute in the following Marko template:

``` xml
<my-component foo=`Hello ${data.name}`/>
```

Would compile to the following property definition in JavaScript code:

``` javascript
foo: "Hello " + data.name
```

NOTE: there would no signs of the backticks in the final compiled output because we want the code to work in ES5 and not just ES6

We could absolutely interpolate `${...}` in normal quoted JavaScript strings, but then we are slightly changing the rules of JavaScript which may be surprising to some users if we say "the right-hand side of an attribute is just JavaScript".
 Hi @SunnyGurnani, technically we don't need to support `${...}` but just just makes the code easier to write and read compared to using string concatenation. 

It did occur to me that we also currently support `$<var-name>` (without the curly braces) which is technically not part of the ES6 template strings spec. We could require `${<var-name>}` but that seems like it would require extra code for end users unnecessarily. That is something we should also discuss. Thanks for the feedback so far!
 A big plus of marko for me is that it can be used with editors that understand HTML/XML (syntactically at least) instead of treating it like a big lump of characters, providing e.g. live linting and structure-aware navigation. In order to do so they need to parse it and that would likely be broken by adopting a custom syntax for attributes.
 And then you have JavaScript template strings: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/template_strings

The problem with `{ ... }` is that it appears all of the time in HTML markup. For example, inline style sheets:

``` xml
<style>
.foo {font-weight: bold;}
</style>
```
 Read your comment too fast, @aaronshaf. I thought you were suggesting `{ ... }` over `${ ... }` (which other templating languages choose... including Angular and Dust).

My problem with supporting the following:

``` xml
<my-component foo={`Hello ${data.name}`} />
```

Is that I really feel like it would be cleaner if the right-hand side of an attribute is _always_ treated as a JavaScript expression. The following code is a valid JavaScript expression:

``` javascript
`Hello ${data.name}`
```

The following is also a valid JavaScript expression despite the additional surrounding parenthesis added for grouping:

``` javascript
(`Hello ${data.name}`)`
```

But the following is not a valid JavaScript expression:

``` javascript
{`Hello ${data.name}`}
```

(curly braces are only valid for block statements)

That is, you can't do the following in JavaScript:

``` javascript
var foo = {`Hello ${data.name}`};
```

I would rather not introduce new symbols for the sake of introducing new symbols if that makes sense.
 Great suggestion, @onemrkarthik. I like that the `for(color in colors)` and `if(x > 5)` directives match up very nicely to pure JavaScript. I'm going to update the original proposal to include your suggestions. Thanks!
 Fixes. Thanks, @onemrkarthik 
 Great feedback @kristianmandrup. What are your thoughts on the fragmentation that would result from supporting two different syntaxes?
 FYI, I started working on a new parser that will better understand JavaScript expressions in HTML attributes (e.g. `<custom message="Hello ${name}!" count=100 large=true complex=(a + b)>`). The key difference between the existing HTML parsers is that attributes will _not_ need to be surrounded by quotes (quotes should only be used if the attribute value will be of type _string_). 

See https://github.com/philidem/htmljs-parser

The base HTML language is handled just fine but I am still working on:
- Placeholders within content: `<div>${xyz}</div>`
- Placeholders within attribute string expressions: `<div class="${xyz}">`
- Placeholders within placeholders: `<div class="${"abc ${def}" + 123}">` (hopefully wouldn't be used very often)
- Better flow control syntax: `<for(a in b)>`, `<div for(a in b)>`, and `<div if(a === b)>`

There's also going to be additional work inside Marko to switch to new parser and there will be some breaking changes that need to be addressed with a template migration tool perhaps.

If anyone has some additional thoughts about the Marko syntax and improvements that could be made, then please let me know! Thoughts and feedback on the parser are also welcome.
 Nice work, @philidem! Thank you for the hard work to make this happen. This will be a huge improvement to Marko and it will be nice to be able to do away the `marko-tag.json` files in most cases.

We'll definitely have to think about transforming old templates. The big thing is that if an attribute is declared as an `expression` then we will need to transform the template to drop the attribute quotes. For example:

Old:

``` xml
<my-custom-tag data="data.someFunction()">
```

New:

``` xml
<my-custom-tag data=(data.someFunction())>
```

We'll also need to transform `if`, `for`, `else-if` and `else`(?) attributes to use the new directive syntax.

I'm sure there will be some other transformations as well, but it is definitely doable.

Thanks again.
 Still actively working on the parser and I'll push some more changes later today. There's still a lot of heavy work to do in Marko to leverage the parser and I think we're leaning toward making breaking changes while also providing a migration tool.

So nothing in the immediate future will be available but still working hard to get this done! I'll probably have to get feedback from @patrick-steele-idem when it is time make changes to Marko. Perhaps we can document the plan to see if we can help from the community as well.
 We could definitely start on the migration tool right now so that it would be ready and well-tested in time for the switch to the new parser. That's an area where we could definitely use some more help from the community. I'll open another Github issue for that task.
 Thoughts on the following?:

``` xml
<var foo=1 hello='World'/>
```

Output JavaScript:

``` javascript
var foo=1;
var hello='World';
```

Old style:

``` xml
<var name="foo" value="1"/>
<var name="hello" value="'World'"/>
```
 Yes, like `<var foo=1 hello='World'/>`!

Also, I would like to propose this:

Declare function:

``` xml
<function doSomething(a, b, c)>
</function>
```

Call function:

``` xml
<doSomething(a, b, c) />
```
 Also, we currently support simple conditionals in Marko:

``` xml
<div class="{?data.isActive;active}">
```

How should we support that with the new parser?

This should of course work in the new parser, but it is a little uglier:

``` xml
<div class=data.isActive?'active':''>
```
 @yomed one variable per line is a coding style. Doesn't really matter to the compiler and it could go either way.
 Thanks for the feedback @yomed. I'm leaning towards standard JS as well. 
 I agree @mlrawlings. That's definitely allowed in Marko v3 and would work as expected. Thanks for pointing that out. I'm definitely looking forward to the new Marko v3 syntax :)
 This feature has been implemented.
  Hi @aaronshaf, can you please be more specific on which aspects of the Angular 2 syntax interest you? Some of the syntax is related to event binding, one-way versus two-way data-binding, etc.

On a related note, this has been discussed in a few other issues, but longer term we are thinking about replacing the HTML parser with a new parser that can recognize types of attributes. With an HTML parser every attribute is a string regardless if it is quoted or not. Here's what we are thinking:

``` xml
<my-component number=1/>
<my-component expression=(a + b)/>
<my-component string="hello"/>
<my-component string-concatenated=("hello"+a)/>
<my-component boolean=true/>
```

Thoughts?
 Hi @aaronshaf, I decided to create a more formal proposal for introducing typed attributes. Please take a look at the following and provide feedback if you get a chance: https://github.com/raptorjs/marko/issues/90 
 Closing this issue in favor of the proposal for #90. We want to make Marko a more powerful blend of JavaScript and HTML by adopting JavaScript as the type for all HTML attributes.
    Hi @kobenauf, I am not able to reproduce the issue so there must be something else that is coming into play. What version of `marko` are you using?

I created a simple project to test with and everything renders as expected:
https://github.com/patrick-steele-idem/marko-issue-82

Please try to reproduce the problem in that project or share your own simple project to reproduce the problem. Thank you.
 Correct, each standalone template needs to be independent and well-formed HTML since each template is parsed using an HTML parser. In practice this is really not a limitation but it does put a constraint on how to code your templates. I recommend using the layout taglib to piece together your page instead of includes. Please see: https://github.com/raptorjs/marko#layout-taglib

Please let me know if that does or does not work for you. I'm going to go ahead and close this issue, but we can discuss some more here if you would like or in the Gitter chat room: https://gitter.im/raptorjs/marko
  If I am following correctly then I would agree with @DanCech that you are looking to do a server-side redirect. Please let us know if that is the answer you are looking for or if there is a question more specific to Marko.
  Thanks for the improved fix!
 New version published with fix: `marko@2.4.3` 
  Try this:

``` javascript
var markoCompiler = require('marko/compiler');
markoCompiler.compile(templateStr, templatePath, function(err, compiledCode) {
    if (err) {
        return callback(err);
    }
    // handle compiledCode here
});
```

The `templatePath` argument is used for resolving taglibs/includes and error reporting; there doesn't actually have to be a template file at this path.

Let me know if that works for you and I can close this issue.
 The "Try Online" section of the raptorjs website does client-side compilation of Marko templates:
http://raptorjs.org/marko/try-online/

The client code that does the compiling is here:
https://github.com/raptorjs/website/blob/master/src/components/app-marko-try-online/widget.js

This uses [Lasso](https://travis-ci.org/lasso-js/lasso) (formerly named "Optimizer") instead of Browserify.

Is not possible to pre-compile your templates during build or on server-side? This would be the most efficient way to compile templates.
 Hi @yazla, it's almost always a bad idea to compile a template in the browser with any template engine (compilation is relatively slow and sending the compiler to the browser introduces a lot of extra overhead). The Marko compiler is designed to run on the server in a Node.js environment where it can access the file system and have access to other taglibs installed via npm. Sorry Marko didn't work out for you, but I think you should reconsider compiling templates in the browser.

Just to be clear, if you do what is suggested in the docs and enable the [markoify](https://github.com/raptorjs/markoify) transform for browserify then the compiled template will automatically be sent down to the browser and your code to render templates will just work. Please see the [Using Browserify](https://github.com/raptorjs/marko#using-browserify) section in the docs. Let us know if you still have questions.
 @yazla, I see where you are coming from, but I still don't see why it is any different to bundle up the compiled templates versus the uncompiled templates. The compiled template is just a standard CommonJS module that exports a function that can be used to load a `Template` instance. For example:

``` javascript
var template = require('marko').load(require('./my-template.marko.js'));
```

The above code works if the template has already been compiled (i.e. the `*.marko.js` file already exists). In the case where the template is not compiled the `markoify` transform will do that for you automatically if the code to load your template is in the following form:

``` javascript
var template = require('marko').load(require.resolve('./my-template.marko'));
```

If it helps, you can use the `markoc` command line compiler to compile all of your templates to CommonJS modules beforehand. For example, to compile all templates in the current directory and all sub directories:

``` bash
npm install marko --global
markoc .
```

I hope that helps.
 Hi @tonii75, the compiler does work in the browser but it does require that you use the Lasso.js module runtime in the browser since the Browserify module runtime doesn't support dynamic requires. For the "Try Marko Online" feature we are using the compiler in the browser. Here's the relevant code:
https://github.com/marko-js/markojs.com/blob/master/src/components/app-try-marko/index.js

I hope that helps. If you want to discuss further might be better to open a new Github issue.
  I'm not seeing any failing tests and our CI never reported any failing tests. I will take a look and see if I can reproduce and report back soon.

Thanks for reporting the problem.
 @viviangledhill I just did a refresh `npm install` with the latest code of `marko@2.4.0` (`master` branch) and I am still not able to reproduce the problem. Which version of marko are you testing with?
 I also tested with the latest code on the `v1.6` branch and am not able to reproduce.
 Also, one other thought: if you have `marko-layout` or `marko-async` installed as dependencies in your project then you should remove those dependencies. Both `marko-layout` and `marko-async` are core dependencies of `marko` and are already included. Having multiple versions of those modules might be causing problems in your app.
 @viviangledhill Did you try deleting your `node_modules` directory?
 Ok. Interesting. I'll look into making a change to prevent the core taglibs from loading multiple times even though it is an edge case. Thanks for the update and I'm glad you got everything working.
  Thanks for improving the documentation!
  @patbegg Can you confirm what version of marko you have installed? This looks to be the same bug that was previously fixed: https://github.com/raptorjs/marko/issues/60

I am not able to reproduce the problem when compiling the following template with the latest version of marko (`v2.3.2`):

``` xml
<layout-use template="./layout.marko">
    <layout-put into="foo">
        <div class="c c2 span-8-collapse">
            <div class="c-inner">
                <dl class="summary-list">
                    <dt>
                        <h3>Intuitive Features Wrapped Up In a Smart Interface</h3>
                    </dt>
                    <dd>
                        <p>Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.</p>
                        <span class="blue">&#9656; </span><a href="/features">Explore the Features</a>
                    </dd>

                    <dt>
                        <h3>Pay-as-you-go + Monthly Plans Available</h3>
                    </dt>
                    <dd>
                        <p>Whether you're publishing lots or publishing little we have a plan that's great value and can scale up/down as your needs do, and you're free to cancel anytime.</p>
                        <span class="blue">&#9656; </span><a href="/pricing">Choose a plan that's right for you</a>
                    </dd>
                    <dt>
                        <h3 class="green">Start Now - No Obligation 14 Day Free Trial</h3>
                    </dt>
                    <dd>
                        <p>We don't expect you to make a decision before you've kicked the tyres and shown your boss so we offer a no obligation 14 day free trial to everyone.</p>
                        <span class="green">&#9656; </span><a href="/features#analytics" class="green">Bored of reading and want to try it for yourself? Start your free trial now</a>
                    </dd>
                </dl>
            </div>
        </div>
    </layout-put>
</layout-use>
```
 @patbegg The [view-engine](https://github.com/raptorjs/view-engine) modules were an attempt to normalize the APIs for rendering templates across multiple template engines and to ensure that all templates are loaded as CommonJS modules, but it never really got any traction. We'll fix bugs (and update dependencies when requested), but if you are just using Marko then I would suggest dropping the usage of the `view-engine` modules and just use `marko` directly for loading and rendering templates (no middleman and less overhead). While not officially deprecated, I personally don't think it is worthwhile to continue investing in or using the `view-engine` modules. If you still want to use `view-engine` then please let me know and if you find issues please open the issue against the appropriate Git repo.

In the mean time I will look into doing a new release for the [view-engine-marko](https://github.com/raptorjs/view-engine-marko) module. Thanks.
 Update: A new major version of `view-engine-marko` was published that tracks `marko@^2`: `view-engine-marko@2.0.0`

To upgrade to the latest version:

``` bash
npm install view-engine-marko@^2 --save
```

I'm closing the issue for now. Please let me know if you still see issues and we can reopen if needed.
  Hi Sara,

Does your `<app-fieldset>` custom tag have a `renderer.js`? If so, which syntax of the following does your `renderer.js` use?

**Option 1:**

``` javascript
exports.renderer = function(input, out) { ... }
```

**Option 2:**

``` javascript
module.exports = function renderer(input, out) { ... }
```

If you have a circular dependency you need to use **Option 1** since it allows for a partially loaded module to be returned. It is recommended that you always use the syntax shown in **Option 1**. If you do not have a `renderer.js` then I'll probably need more details to reproduce the problem.

Thanks,
Patrick
 This issue was fixed as part of the fixes for #66. Closing this issue, but please let me know if you are still facing problems. Thanks.
  @schetnikovich Excellent proposal! You did a great job capturing the disconnect between nested tags and how their values are actually used by the parent widget. I think you're exactly right that they're more like attributes since the complex values for the nested tag get stored the same way as attributes (based on the proposals we have so far).

We need to make sure that this remains valid HTML. I don't think the HTML parser will allow `.` and `@` in the tag names (haven't verified this yet), and for that reason we could try to use XML namespaces instead of a new syntax. For example:

``` xml
<app-tabs>
    <app-tabs:tab label="Tab 1">
        Content for Tab 1
    </app-tabs:tab>
    <app-tabs:tab label="Tab 2">
        Content for Tab 1
    </app-tabs:tab>
</app-tabs>
```

At one name every tag could be put into a namespace but then we decided to require that all tags be named uniquely. For example, instead of creating a namespace with name "app" and using `<app:tabs>` we moved toward `<app-tabs>`. I think we need to completely remove that namespace code.

Also, I wonder if we can support nested tags within nested tags. For example, using the namespace notation:

``` xml
<app-tabs>
    <app-tabs:tab>
        <app-tabs:tab:label>Tab 1</app-tabs:tab:label>
        Content for Tab 1
    </app-tabs:tab>
    <app-tabs:tab>
        <app-tabs:tab:label>Tab 2</app-tabs:tab:label>
        Content for Tab 1
    </app-tabs:tab>
</app-tabs>
```

If the HTML parser will allow `@` and `.` in an HTML tag then it might be worth considering that notation as well. We could fork the HTML parser that we are using. There is a precedence of using `@` to indicate attributes. If we could interpret `@` to mean "this tag belongs to the closest parent tag" then we could automatically bind nested tags as attributes to parent tag. If the nested tag is not the direct descendant then maybe we could support a qualifier.

For example, simple case that doesn't require qualifiers:

``` xml
<app-tabs>
    <@tab>
        <@label>Tab 1</@label>
        Content for Tab 1
    </@tab>
    <@tab>
        <@label>Tab 2</@label>
        Content for Tab 1
    </@tab>
</app-tabs>
```

For example, less simple case that does require qualifiers:

``` xml
<app-tabs>
    <if test="data.readOnly">
        <@app-tabs.tab>
            <@label>Tab 1</@label>
            Content for Tab 1
        </@app-tabs.tab>
    </if>
    <@tab>
        <@label>Tab 2</@label>
        Content for Tab 1
    </@tab>
</app-tabs>
```

Also, if we go this route then we'll need to enhance the Marko syntax highlighter for Atom (and possibly create one for other editors such as Sublime Text). Even on Github you can see that the syntax highlighter doesn't know how to highlight tags with `@`.

If we hit limitations with the HTML parser that we're using then maybe we should consider writing our own because that would provide some other niceties.

I've been interested in doing this:

``` xml
<app-button size=${data.buttonSize}></app-button>
```

I'm definitely going to think about this some more!
 Thanks for the proposal, @schetnikovich. I like the idea of having a shorthand for nested tags. 

Technically, HTML 5 does allow any character for the tag name but the first character must match`[a-zA-Z]`. This only made clear if you look at the tokenization spec:
http://www.w3.org/TR/2011/WD-html5-20110113/tokenization.html#tag-open-state
http://www.w3.org/TR/2011/WD-html5-20110113/tokenization.html#tag-name-state

Therefore, unless we fork the parser that we are using and are willing to break syntax highlight in all HTML editors then we should conform to the HTML spec.

I don't consider `<attribute>` as a replacement for repeatable nested tags for two reasons:
- Marko already supports nested `<attr>` tags that can be used to add HTML attributes to the parent element (not documented, but [here is a relevant test](https://github.com/raptorjs/marko/blob/9e3bbfe882af26e9eda63a5e86e69651a3a3dfcb/test/fixtures/templates/nested-attrs/template.marko#L4-L5))
- Real attributes cannot be repeated

Just to be clear, the following is already supported:

``` html
<app-tabs>
    <app-tab>
        <attr name="label">Tab 1</attr>
        Content for Tab 1
    </app-tab>
    <app-tab>
        <attr name="label">Tab 2</attr>
        Content for Tab 2
    </app-tab>
</app-tabs>
```

Regarding nested tags, I think we should consider the following options:

## Option 1: Use a colon to namespace nested tags:

``` html
<app-tabs>
    <app-tabs:tab label="Tab 1">
        Content for Tab 1
    </app-tabs:tab>
    <app-tabs:tab label="Tab 2">
        Content for Tab 2
    </app-tabs:tab>
</app-tabs>
```

Pros:
- The colon character is already associated with namespacing and a nested tag is namespaced within a parent element.
- In the future, we may want to support a short-hand by dropping the parent namespace part (e.g., `<app-tabs:tab>` â†’ `<:tab>`
- Most HTML editors should not have a problem with a colon character in a tag name

Cons:
- Looks like XML namespaces (can be a turn off to some people)
- Colon character is harder to type (requires the `SHIFT` key)
- More typing

## Option 2: use a period to namespace nested tags:

``` html
<app-tabs>
    <app-tabs.tab label="Tab 1">
        Content for Tab 1
    </app-tabs.tab>
    <app-tabs.tab label="Tab 2">
        Content for Tab 2
    </app-tabs.tab>
</app-tabs>
```

Pros
- Same as Option 1 _plus_ the period character is easier to type (no `SHIFT` key)

Cons
- Not sure how most HTML editors, parsers and linters will feel about a `period` character in the tag name
- More typing

## Option 3: Use a dash separator for the nested tag name:

``` html
<app-tabs>
    <app-tabs-tab label="Tab 1">
        Content for Tab 1
    </app-tabs-tab>
    <app-tabs-tab label="Tab 2">
        Content for Tab 2
    </app-tabs-tab>
</app-tabs>
```

## Option 4: Use no explicit namespacing and just rely on a unique tag name:

``` html
<app-tabs>
    <app-tab label="Tab 1">
        Content for Tab 1
    </app-tab>
    <app-tab label="Tab 2">
        Content for Tab 2
    </app-tab>
</app-tabs>
```

---

Thoughts on which option is best? I'm leaning towards Option 2 (using a period as a separator), but I think we need to see how various tools feel about a period in the tag name.
 @schetnikovich I think I missed the main purpose of your proposal. Your goal was to normalize attributes and nested tags and I think that is a good idea. What do you think of the following variation?:

`app-tabs/marko-taglib.json`:

``` json
{
    "attributes": {
        "orientation": "string",
        "tabs": {
            "type": "object[]",
            "nested-tag": {
                "name": "tab",
                "attributes": {
                    "label": "string",
                    "body": "string"
                }
            }
        }
    }
}
```

You would then have two options for passing in the array of tabs:

## Using the tabs attribute:

``` html
<app-tabs tabs="[ { label: 'Foo', body: 'Content for Foo' }, { label: 'Bar', body: 'Content for Bar' }, ... ]"/>
```

## Using the nested tab tag:

``` html
<app-tabs>
    <app-tabs.tab label="Tab 1">
        Content for Tab 1
    </app-tabs.tab>
    <app-tabs.tab label="Tab 2">
        Content for Tab 2
    </app-tabs.tab>
</app-tabs>
```

---

Also, there is no right answer on whether or an attribute is more appropriate then a nested tag for passing input to a custom tag. Key differences between attributes and nested tags is that attributes cannot be repeated and attributes cannot contain complex markup. Nested tags do not have those limitations. I believe we need to support both attributes and nested tags.
 Completely agree with your comments @DanCech. Even if it is more typing, I think it is better to have some concept of explicit namespacing and I think it is better to avoid the colon character. I could go either way on `<app-tabs.tab>` vs `<app-tabs-tab>`, but I am leaning towards `<app-tabs.tab>` because the syntax makes it clear that it is a nested tag (i.e. not a top-level tag) and that will hint to the user where the nested tag is defined. 

As for `<attr>`, yes that feature is officially supported. It is an oversight that the documentation does not mention `<attr>` tag. Pull requests welcome :)
 I'm in favor of supporting the dot-notation for using nested tags in your HTML. A short-hand of only using something like `<.tab>` would be great too if we can tweak the HTML parser.

I have a new proposal for `marko-tag.json` that should reduce the characters via a short-hand notation.

I propose that we use "@" as a property prefix to identify attributes instead of having to nest them under a `attributes` property.

For example:

``` json
{    
    "@orientation": "string",
    "@tabs <tab>[]": {
        "@label": "string",
        "@body": "string"
    }
}
```

The `@tabs <tab>[]` portion of the example above would be interpreted as:
"tabs can also be provided via one or more nested tab tags"

Thoughts?
 Great suggestion @philidem! I really like the much flatter and more concise structure and I think it allows us to capture all of the same information. I do have a few minor concerns:
1. Symbols have meaning (slightly higher learning curve)
2. The fact that the `tabs` attribute is an expression type would be implicit instead of explicit

We can mitigate the first concern by first introducing developers to the long-hand form (that we would always need to support) and then provide the equivalent short-hand syntax.

:+1: for the following:

``` json
{    
    "@orientation": "string",
    "@tabs <tab>[]": {
        "@label": "string",
        "@body": "string"
    }
}
```
 Just an update. Based on the feedback shared in this Github issue (and the related Github issue of #61) we have made changes to support the following:
- Better support for tags with a parent/child relationship
- Shorthand syntax for defining tags and attributes

The Pull Request is still being reviewed, but you can find the details in the CHANGELOG for the upcoming `marko@2.4.0`: https://github.com/patrick-steele-idem/marko/blob/parent-child/CHANGELOG.md#240

Here's the Pull Request with the changes: #68 

Feedback on this Pull Request is greatly appreciated. Thanks!
 Support for parent/child relationships has been completed. Closing issue.
  Sorry for the delayed response, but better late than never...

You have a few options:

**_Option 1) Access req/res properties using `out.stream`**_

Assuming you render the top-level page template directly to an HTTP response stream using `template.render(viewModel, res)`, you can access the HTTP request and response objects by doing the following:

``` javascript
exports.renderer = function(input, out) {
    var res = out.stream;
    var req = res.req; // The "req" property is added to the "res" object by Express
}
```

**_Option 2) Use continuation local storage (CLS)**_

You could use something like [continuation-local-storage](https://github.com/othiym23/node-continuation-local-storage) (or [request-local](https://www.npmjs.com/package/request-local) which is a small wrapper on top of CLS) to make request-specific information automatically available to all templates and modules, but I've found that CLS can be very problematic. I think you are better off passing in the request-specific globals via the `$global` property or going with Option 1. 

---

I hope that helps. Please feel free to reopen this issue if you would like to discuss some more.
  Currently, to set up a parent/child relationship between custom tags requires a decent amount of code.

Here's an idea how it can be improved:

Let's say we want to achieve the following:

``` html
<app-tabs orientation="vertical">
    <app-tab label="Tab 1">
        Content for Tab 1
    </app-tab>
    <app-tab label="Tab 2">
        Content for Tab 2
    </app-tab>
</app-tabs>
```

This could be described in a single `app-tabs/marko-taglib.json` as shown below:

``` json
{
    "attributes": {
        "orientation": "string"
    },
    "nested-tags": {
        "app-tab": {
            "target-property": "tabs",
            "repeated": true,
            "attributes": {
                "label": "string"
            }
        }
    }
}
```

In the renderer, the nested tabs could be accessed using the `input.tabs` property that will be an array:

``` javascript
exports.renderer = function(input, out) {
    var tabs = input.tabs;
    tabs.forEach(function(tab) {
        // ...
    });
};
```

Another example:

``` html
<app-overlay visible="false">
    <app-overlay-header>
        This is the header content
    </app-overlay-header>
    <app-overlay-body>
        This is the body content
    </app-overlay-body>
    <app-overlay-footer>
        This is the footer content
    </app-overlay-footer>
</app-overlay>
```

This could be described in a single `app-overlay/marko-taglib.json` as shown below:

``` json
{
    "attributes": {
        "visible": "boolean"
    },
    "nested-tags": {
        "app-overlay-header": {
            "target-property": "header",
            "repeated": false
        },
        "app-overlay-body": {
            "target-property": "body",
            "repeated": false
        },
        "app-overlay-footer": {
            "target-property": "footer",
            "repeated": false
        }
    }
}
```

In the renderer, the nested header, body and footer content could be accessed as shown below:

``` javascript
exports.renderer = function(input, out) {
    var header = input.header;
    var body = input.body;
    var footer = input.footer;

    console.log(typeof header.renderBody); // Output: 'function'
    console.log(typeof body.renderBody); // Output: 'function'
    console.log(typeof footer.renderBody); // Output: 'function'
};
```
 I like this concept a lot. It might be helpful to include a snippet of what the compiled output might look like so that we can discuss.

Here are some alternate property names for configuring the nested tag:
- **target-property:** property (a little shorter)
- **repeated:** limit (a numeric value), repeatable

Alternatively have just "target-property" and use `[]` to denote allowed repeatability:
- Allow any number of tabs: `target-property: "tabs[]"`
- Allow one tab: `target-property: "tabs[1]"`
- Allow two tabs: `target-property: "tabs[2]"`
- Allow only a single tab: `target-property: "tab"`

Also, perhaps the target property should always be an array and don't require the compiler to check constraints about repeatability of nested tag.

Something even crazier to avoid some of the JSON clunkiness:

``` json
{
    "attributes": {
        "visible": "boolean"
    },
    "nested-tags": [
        "app-overlay-title => title",
        "app-overlay-header => header[]",
        "app-overlay-body => body[1]",
        "app-overlay-footer => footer[]"
    ]
}
```
 I like the idea of dropping the `repeated`/`repeatable` property and, instead, just use the `[]` suffix to denote something that is repeatable. However, I don't think we should allow `[<max_count>]`.

I think I prefer `target-property` since it I think it is a little more clear that this is the name of the target property.

I don't think we need the short-hand because it prevents attributes from being defined for the nested tags, but I might be able to be persuaded.
 I am worried that repeatable will be the most common case and that people will forget to add the `[]` to the target property name. That's why I was wondering if we should always assume arrays...

I like the shorthand notation for the most common case. We can implement the longhand approach first and then see if shorthand makes sense.
 Definitely don't want to have nested tags always produce an array. I think that will make the tag renderer more complicated than it needs to be.
 @patrick-steele-idem and I discussed this and the proposal looks more like this:

``` json
{
    "attributes": {
        "orientation": "string"
    },
    "taglib": {
        "tags": {
            "app-tab": {
                "target-property": "tabs[]",
                "attributes": {
                    "label": "string"
                }
            }
        }
    }
}
```

Basically, you can now declare taglibs within other tags. If the **target-property** exists for a tag then this creates the parent/child relationship between the parent tag and the child tag. When taglibs are declared within another tag, then that taglib is associated with a parent taglib.
 Thanks for summarizing @philidem. I'm going to start the implementation now.
  New version of marko published with fix: `marko@2.2.2`

Thanks for setting up the project to reproduce the problem and thank you for bringing this problem to our attention!
  Hey @tindli, I'm going through old issues to do some housecleaning. I am going to go ahead and close this issue. If you think that we need to improve the docs in various areas, I would recommend opening a Github issue for each proposal for better tracking purposes.

FYI, I actually haven't done any extensive tests to see how Google indexes pages with client-side reordering. I would be curious to know the answer to that :) However, we have aimed to only do out-of-order rendering for non-bots and browsers with JS enabled. For bots and non-JS users the recommendation has been to not enable client-side reordering (`client-reorder="false"`). Thanks!
  Hi @patbegg. We use an HTML parser that follows the same HTML parser rules as a web browser so each templates should be valid HTML documents which means you can't break out the opening and closing tags for an element into separate templates. However, that is not really a problem in practice and the recommended solution is to use the [layout taglib](https://github.com/raptorjs/marko#layout-taglib) to define the skeleton of your page. For your example, you would want to do something like the following:

**_src/pages/home/template.marko:**_

``` html
<layout-use template="../layouts/default/template.marko">
    <layout-put into="title">My Page Title</layout-put>
    <layout-put into="body">content here</layout-put>
</layout-use>
```

**_src/layouts/default/template.marko:**_

``` html
<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title><layout-placeholder name="title"/></title>
</head>
<body>
    <app-header/>
    <div>
        <layout-placeholder name="body"/>
    </div>
    <app-footer/>
</body>
</html>
```

Let me know if that does or does not solve your problem.
 You're welcome. I hope that solution worked out for you.
  Welcome to Marko and Node, @patbegg! There are two ways to pass along data:
1. As part of the attributes on the custom tag
2. As part of global data that is made available to all custom tags (as part of the `out` object).

You want to take advantage of the second option and provide global data. This is described in the following section of the docs: https://github.com/raptorjs/marko#global-properties

Here's some code that matches your example:

``` javascript
template.render({
        $global: {
            env: 'development'
        },
        ... // All other non-global data
    });
```

And then in any rendered template:

``` html
<if test="out.global.env == 'development'">
```

NOTE: `out.global.env` is used instead of `data.env`.

Please confirm that that solves your problem. Let us know know if you have any other questions.
 Glad that solved your problem. Happy coding!
  Let's create some logos for Marko!

I'll start things off with a really _rough_ sketch of an idea:

![marko-logo-small](https://cloud.githubusercontent.com/assets/978214/6374693/ce18ec78-bccf-11e4-968f-7c06ae73e8e6.jpg)

Please feel free to take that idea and make it better or come up with something completely different.

All logos submitted here will be assumed to be licensed as public domain / [CC0](http://creativecommons.org/about/cc0).

Contributors to the final logo will get credit on the main page and a custom printed T-Shirt with the logo on it!
 @pdajlido I like the logo with the pink lettering because it is simpler. I like the visual elements added around the lettering, but what is the meaning of the lattice decoration?

Also, I think it works well if the graphic part of the logo could be used independent of the "Marko" text and for the graphic part to be easily recognizable and unique (if that makes sense).
 Instead of `><><` (which looks like two X's), I would lean more towards `<><>` since it matches how the characters would appear in an HTML tag. Maybe something can be done with a double diamond :)
 I like the upper-right "M" logo. Might want to create a companion logo that contains "Marko" as well. I do like the diamond concept.
 I didn't see two "X"s at first but now that's all I see for "><><". Maybe "<><>" As @patrick-steele-idem suggested would be better.
 @seangates Even "dumb" ideas can inspire something better! What is "Mark" though? Just kidding :)
 ![marko-logo-01](https://cloud.githubusercontent.com/assets/978214/6874018/bd5efd20-d479-11e4-9f0e-24ca36bfbc08.png)
 @patrick-steele-idem Maybe ".Marko" instead of "Marko."

Or maybe ".marko" (lower case)
 ![marko-logo-01](https://cloud.githubusercontent.com/assets/978214/6875756/1917e016-d487-11e4-9b7e-f7fdc7e6a75a.png)
![marko-logo-02](https://cloud.githubusercontent.com/assets/978214/6875757/19198b6e-d487-11e4-9bce-098856955d3d.png)
 Hah, nice @pdajlido! I'm curious as to what others think of adding a character to the logo, but I might like it :) A logo with a character seems to have worked well for [Yeoman](http://yeoman.io/)
 Also, for Marko Widgets you could modify the dude to be a mad scientist.
 Thanks for the contributions, @pdajlido! 
 ![marko-logo-03](https://cloud.githubusercontent.com/assets/978214/6877648/975279c6-d498-11e4-9b92-bfb4afaf571f.png)
 Hey folks, while we had a some great submissions we decided to get the help of some professionals. We started a logo contest on 99designs.com yesterday and are getting some great submissions:

https://99designs.com/logo-design/contests/create-logo-marko-open-source-programming-project-ebay-531819/entries

If you have any thoughts please share so that we can provide feedback to the designers. Also, after the contest progresses some more I'll share a poll so that we can get more input. Thanks!
 Link to contest entries?
 Accidentally pressed the wrong button... Comment updated with link to contest. Thanks.
 Hi folks,

We created two separate polls to help us choose a logo (99designs.com limits each poll to only 8 logos each):

Poll 1: https://99designs.com/logo-design/vote-d19zuf
Poll 2: https://99designs.com/logo-design/vote-3qyhyb 

Please vote! Thanks!
 Hi folks,

Thank you all for the votes in the earlier polls! We have one more poll (last one, I promise). Please give your ratings for the last set of designs:

Final poll: https://99designs.com/logo-design/vote-bdarln

We will use the final poll to help select the winner. Thanks in advance!
 Marko has a new logo!

![Marko Logo](https://cloud.githubusercontent.com/assets/978214/9265711/774768ca-41f4-11e5-81ee-8fff2cae7e9a.png)
  @fierysunset Is the problem that the `attribute` input value in your example is not available when using `c-input`? Since you can only have one input to the tag (`c-input` takes precedence in this case) I am guessing that `attribute` will not be passed along. Technically, I think the compiler should flag this as an error.

Here are some alternatives:
- Put the value of `attribute` into `data.someObj` and use `<tagname c-input="data.someObj" />`. For example:

``` javascript
<assign var="data.someObj.attribute" value="test" />
<tagname c-input="data.someObj" />
```
- Don't use `c-input` but allow wildcard attributes for `tagname` tag. See https://github.com/raptorjs/marko#defining-attributes
- Declare a `data` (or some other name) attribute for `tagname` that could be used as an alternate way to provide input. You could then use it like:

``` html
<tagname data="data.someObj" attribute="test"/>
```

Because `data` is not a special attribute, the renderer for `tagname` could access both `data` and `attribute`.
 I think the desired behavior is for the attributes to be merged into the data object provided by `c-input`. The properties provided via attributes should take precedence over the properties in the the `c-input` object. Also, we should not modify the object provided via `c-input` and instead create a new object with the merged properties.

Is that what you are thinking as well, @fierysunset ? Thoughts @philidem ?
 Also, there are plenty of workarounds to avoid making this change, but I do think it is something we should just go ahead and fix since the current behavior of silently discarding the attributes when used in conjunction with `c-input` is not right.
 New version published: `marko@2.3.0`
  Please fix the jshint error so that the build will pass. Also, jshint plugins/packages for your code editor are really helpful if you don't have one installed.

See https://travis-ci.org/raptorjs/marko/jobs/54955691
 Published marko@2.1.4
Thanks Sean!
  How about the following?:

_component-library/marko-taglib.json__

``` json
{
    "taglib-imports": ["./package.json"]
}
```

Behind the scenes, Marko would read the `package.json` file to find the `dependencies` object. It would then loop over all of the module dependencies and do the following:

``` javascript
var taglibPathToTry = require.resolve('<module_name>/marko-taglib.json');

if (taglibPathToTry) {
    // Import the current taglib
}
```

Sound good?
 New versions published with enhancement:

`marko@1.6.7`
`marko@2.1.0`

Test for new feature are passing, but documentation has not been updated. Sample usage:
https://github.com/raptorjs/marko/blob/5a918e85d0a6e38e0aae4c96f5db273e48e1080b/test/test-project/marko-taglib.json#L102

Let me know if you see any issues.
  I agree. The interdependencies between modules and out-of-date modules can cause some strangeness. Besides keeping the changelog up-to-date, we should see if there is a way to detect incompatibilities at runtime when in development mode (might be a tooling issue). Perhaps something that could inspect the `package.json` and `node_modules` to look for inconsistencies.
 Hi @barwin. We do maintain a CHANGELOG.md for Marko:  https://github.com/raptorjs/marko/blob/master/CHANGELOG.md

However, I think an "Upgrade Guide" is needed as well to describe what steps should be taken to upgrade to a new major version. This would be similar to the "Upgrade Guide" added for Marko Widgets: https://github.com/raptorjs/marko-widgets/blob/master/CHANGELOG.md#upgrade-guide

Any other suggestions for making the changelog better?
  # Short answer

Yes, you can use Marko with webpack. You just need to enable the [markoify](https://github.com/raptorjs/markoify) Browserify transform for webpack: https://github.com/raptorjs/marko#using-browserify

To use a browserify transform with webpack you can use the following webpack loader: https://github.com/webpack/transform-loader

In theory, it would probably be trivial to build a custom Marko loader for webpack, but it is not something we have plans to do. If you or someone else wants to introduce a marko-loader for webpack I'm sure that would be helpful to others.

# Long answer

Marko templates compile down to standard CommonJS JavaScript modules. If you pre-compile all of your templates, then the following code will always work with webpack or any other JavaScript module loader:

``` javascript
var template = require('marko').load(require('./template.marko.js'));
```

You can pre-compile your templates using the `markoc` command line utility. For example:

``` bash
markoc .
```

Pre-compilation is kind of a pain since you need to typically set up a file watching service (or Gulp/Grunt build script) compile on templates on change, but it works.

To avoid pre-compilation, we recommend the following code to load a template:

``` javascript
var template = require('marko').load(require.resolve('./template.marko'));
```

That code will work on the server-side no problem, but Browserify and WebPack do not recognize and support `require.resolve` so you must use a Browserify transform to compile the Marko template automatically and transform the code to the following:

``` javascript
var template = require('marko').load(require('./template.marko.js'));
```

That's exactly what the following Browserify transform does for you: https://github.com/raptorjs/markoify

---

I hope that answers your question.

As a side note, you might want to consider using the [optimizer](https://github.com/raptorjs/optimizer) since it is more feature-rich JavaScript module bundler that also supports CSS, code splitting, bundling, lazy loading, etc.
 I've not tried using marko with webpack, but I suspect that the webpack bundler is choking due to the following lines: https://github.com/raptorjs/raptor-logging/blob/b5045817e413e29077fa6fc7ac9de3243167c679/lib/raptor-logging.js#L1-L7

I'm not sure what to suggest in this case, because it seems like a bug in webpack since [lasso](https://github.com/lasso-js/lasso) and [browserify](http://browserify.org/) have no issues. If anyone knows of a workaround for webpack please share.
 Hey @wheresrhys, I think the right thing to do here is to use the [markoify](https://github.com/marko-js/markoify) Browserify transform with Webpack using the transform loader for webpack:
https://github.com/webpack/transform-loader

The `markoify` transform will auto compile the referenced Marko templates and transform the code to require the generated `.marko.js` file (e.g. `require('./tpl.marko.js')`. Have you given that a try?

Unfortunately, generating the following code would _not_ work since the referenced template may not already be compiled:

``` javascript
__loadTemplate(require("../../components/nav/tpl.marko.js"), require)
```

Marko is designed to generate code that always works on the server. We use `require.resolve('./template.marko')` instead of `require('./template.marko')` because the Node.js require extension for Marko is optional. We provide transforms for JavaScript module bundlers so that referenced templates will automatically be compiled and required in. I hope that clarifies.
 Hey @wheresrhys, were you able to get things working with with the `markoify` transform? If you still think it is need to generate compiled code differently such that it doesn't use `require.resolve('./foo.marko')` and instead uses `require('./foo.marko')` then it might be reasonable to offer that as a compile-time option:

``` javascript
require('marko/compiler').defaultOptions.useRequireExtension = true;
```

I'm doing some housecleaning so I am going to go ahead and close this issue, but please feel free to open another Github issue if you would like to pursue the proposed idea or any other ideas. Thanks!
 @naumovs thanks for sharing. If you are interested in maintaining a loader for others to use I can give you access to `github.com/marko-js/marko-loader`, or the webpack folks may let you maintain the repo at `github.com/webpack/marko-loader`. It would be great to have an official webpack loader for those who want to use webpack (even if the code for the loader is trivial). It would be also good to update the marko docs to describe usage with webpack. Please let me know if you are interested in helping out.
 Marko has been updated to be compatible with wepback. New version published: `marko@3.10.1`

Also see: https://github.com/marko-js/marko-loader
 > It does work, although I'm still getting Webpack warnings:

Yes, for now there is no way to remove the warnings without potentially breaking things. In the next version of Marko we can revisit how the optional "streams" module is enabled for the browser.
  @maxwarch I think you meant to ask this question as a Github issue and not a Pull Request. Please open a Github issue with your question and we can discuss there. Thanks.
  Topics to include:
- Creating nested tags using the following:
  - `body-function`
  - `import-var`
- Compile-time transformers
- Compile-time nodes
- Tag renderers
- `marko-taglib.json` and `marko-tag.json`
 The Marko compile-time API is getting a much-needed refactoring with Marko v3. The plan is to finally provide docs for how to extend Marko at compile-time with Marko v3.
  It is. I think you are running into a problem because you have an instance of `<mytag>` that is _not_ nested within another `<mytag>`. This is causing the scoped `__children` variable to be undefined and you are seeing an error. I suggest the following:

``` json
"import-var": {
    "children": "typeof __children === 'undefined' ? null : __children"
}
```

That should avoid the `__children is undefined` error.
 Glad that worked for you and glad to see that you are taking advantage of these features!

Also, you might want to avoid a generic variable name such as `__children` and instead use `__mytag` or something that makes it clear where the variable came from and avoids possible variable collisions.
 Sounds good. You are right that the documentation related to `body-function`, `renderBody(out)` and `import-var` could be improved. The plan is to eventually provide a separate Markdown document that goes into much more depth on building custom taglibs. There's actually a lot of really interesting things you can do at compile time using a custom transformer that manipulates the AST before the code generation phase. In the mean time, if you have any questions on how to accomplish something please ask here or on Gitter.

I would be curious to check out your wrapper around rendering a React component. I do feel like these two technologies do play nice together and welcome any solutions that can bridge the two.

Closing issue now that you have a working solution.
  Thanks for the fix! New version published: `marko@1.5.4`
  Fixed by 90f7dbf8c496d7c65d776042472fdbac646ef0d0
  This is a known issue with a clean workaround. Marko ignores HTML comments and this breaks IE conditionals since the comments are never written to the output. I've suggested the following workaround in the past:

Create a custom tag named `<app-html>` that maps to the following renderer:

``` javascript
module.exports = function render(input, out) {
    var lang = input.lang;

    out.write(
        '<!DOCTYPE html>' +
        '<!--[if lt IE 7]> <html class="lt-ie9 lt-ie8 lt-ie7" lang="' + lang + '"> <![endif]-->' +
        '<!--[if IE 7]> <html class="lt-ie9 lt-ie8" lang="' + lang + '"> <![endif]-->' +
        '<!--[if IE 8]> <html class="lt-ie9" lang="' + lang + '"> <![endif]-->' +
        '<!--[if !IE]> --><html lang="' + lang + '"><!--<![endif]â€”>');

    input.renderBody(out);

    out.write('</html>');
};
```

Then in your page layout or page template:

``` html
<app-html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>Hello World</title>
        ...
    </head>
    <body>
        ...
    </body>
</app-html>
```

Output:

``` html
<!DOCTYPE html>
<!--[if lt IE 7]> <html class="lt-ie9 lt-ie8 lt-ie7" lang="en-us"> <![endif]-->
<!--[if IE 7]> <html class="lt-ie9 lt-ie8" lang="en-us"> <![endif]-->
<!--[if IE 8]> <html class="lt-ie9" lang="en-us"> <![endif]-->
<!--[if !IE]> --><html lang="en-us"><!--<![endif]â€”>
    <head>
        <meta charset="UTF-8">
        <title>Hello World</title>
        ...
    </head>
    <body>
        ...
    </body>
</html>
```

The benefit of this approach is that the HTML template is cleaner. In theory, we could look into a code change to introduce special handling for IE HTML comments. I'm open to ideas and/or Pull Requests, but hopefully the workaround solves your problem for now.
 New version published with improvement: `marko@2.7.0`
 Thanks for letting me know @yomed. IE conditional HTML comments are automatically preserved now so the workaround discussed is not needed. 
 That's true, variables inside comments are not resolved. Does keep the template code cleaner as well. Thanks for sharing.
  The HTML syntax does not allow attribute types to be distinguished (similar to JSON). This is unfortunate, but short of introducing a new language we must live with a separate schema that informs the compiler of the types of each attribute. Alternatively, we would assume that every attribute is a string and for `$`/`${ }` to change the type (more typing and ugly).

Therefore, in your example, you would just need to do the following:

``` json
{
    "attributes": {
        "viewModel": "expression",
        "options": "expression"
    }
}
```

If we were willing to depart from an HTML parser, we could create our own HTML-like parser that supports the following:

``` html
<my-component number=1/>
<my-component expression=(a + b)/>
<my-component string="hello"/>
<my-component boolean=true/>
```

If we were to go that route then we would lose syntax highlighting/completion/validation support from existing HTML editors and tools like [Emmet](http://emmet.io/).
 Closing issue as I don't think there are any short-term actionable items. If you disagree please feel free to add comments.
 Hey @pedramphp, please provide comments on the following proposal: https://github.com/raptorjs/marko/issues/90 
  Can you provide more details or a reproducible test? I have not run into a case where the stack trace was not valid. Are you sure the problem does not reside in your code?
 @pedramphp ping. Can you please provide more details?
 I just created a project to try and reproduce and I am not able to reproduce the problem. Here is the error that I see logged:

```
/Users/psteeleidem/temp/marko-issue-25/components/app-foo/renderer.js:3
Â  Â  var a = t.a;
Â  Â  Â  Â  Â  Â  Â ^
TypeError: Cannot read property 'a' of null
Â  Â  at Function.module.exports (/Users/psteeleidem/temp/marko-issue-25/components/app-foo/renderer.js:3:14)
Â  Â  at module.exports.t (/Users/psteeleidem/temp/marko-issue-25/node_modules/marko/runtime/helpers.js:127:14)
Â  Â  at render (/Users/psteeleidem/temp/marko-issue-25/template.marko.js:9:5)
Â  Â  at Object.Template.render (/Users/psteeleidem/temp/marko-issue-25/node_modules/marko/runtime/marko-runtime.js:126:9)
Â  Â  at Object.<anonymous> (/Users/psteeleidem/temp/marko-issue-25/index.js:2:10)
Â  Â  at Module._compile (module.js:456:26)
Â  Â  at Object.Module._extensions..js (module.js:474:10)
Â  Â  at Module.load (module.js:356:32)
Â  Â  at Function.Module._load (module.js:312:12)
Â  Â  at Function.Module.runMain (module.js:497:10)
```

I don't believe the problem is with Marko. Please check your project setup because I suspect you have some error handling code that is not displaying caught errors correctly. 
  Hi @bkniffler, a custom tag is just a mapping to a `render(input, out)` function that gets resolved at compile time. It's possible to invoke a render function directly instead of going through a custom tag and I think that might help in your case. This is done using the [`<invoke>` tag](https://github.com/raptorjs/marko#invoke) as shown below:

``` html
<!-- Loop over components, each which as a render function and an input model -->
<div for="item in data.components">
   <!-- Invoke the render function for the current item using the current item's input model -->
    <invoke function="item.render(item.value, out)"/>
</div>
```

NOTE: A loaded template also has a `template.render(input, out)` function so you could also do the following:

``` html
<invoke function="item.template.render(item.value, out)"/>
```

I'm not sure if you are using the RaptorJS Optimizer or Browserify, but the RaptorJS Optimizer supports dynamic requires while Browserify does not. Therefore, if you are using the RaptorJS Optimizer then you can send down all of the templates that may be needed on the client and dynamically require them instead of relying only on static code analysis. You can use a glob pattern to send down all of the templates in a directory as shown below:

_optimizer.json_

``` json
{
    "dependencies": [
        "*.marko"
    ]
}
```

Those templates could be dynamically required doing something similar to the following:

``` javascript
var template = require('marko').load(require.resolve('./components/' + componentName + '/template.marko'));
```

NOTE: We currently don't register the `*.marko.html` extension for the [optimizer-marko](https://github.com/raptorjs/optimizer-marko) plugin so you might need to send a PR for the plugin.

Does this help in your use case? If not, please provide more details.
 @bkniffler I would recommend an approach that uses a single component/tag that simply delegates rendering to multiple other components/renderers.

For example, I often run into the use case of choosing a template based on a `type` or `layout` attribute. Consider the case where you might want to do something like this:

``` xml
<app-message type="info">${data.message}</app-message>
<app-message type="warning">${data.message}</app-message>
<app-message type="error">${data.message}</app-message>
```

Depending on your use case, this might be simpler than having three separate tags (`app-info-message`, `app-warning-message`, and `app-error-message`, for example).

In this example, `app-message` may have a template for each type of message. The `app-message` renderer would simply choose the right template based on the type.

The `app-message` component would have a `renderer.js` with something like this:

``` javascript
var marko = require('marko');

var TEMPLATE_BY_TYPE = {
    info: marko.load(require.resolve('./info.marko')),
    warning: marko.load(require.resolve('./warning.marko')),
    error: marko.load(require.resolve('./error.marko'))
};

module.exports = function(input, out) {
    // find the template that maps to the given type
    var template = TEMPLATE_BY_TYPE[input.type];
    if (!template) {
        throw new Error('Invalid type "' + input.type + '".');
    }

    // now render the template
    template.render(input, out);
}
```

In summary, I think this logic of choosing a template would be easier to read if the developer moved this logic to the renderer. I don't think there would be much benefit of implementing this "choosing" logic in the template.

Please let me know if you still don't think the solution from @patrick-steele-idem or myself would help in your use case (or if you are still looking for a more elegant solution).
  The meaning of `render-tag-if` is unclear since it could easily just be interpreted to be the same as `if`. That is, `render-tag-if` doesn't make it clear that only the body will render if the condition evaluates to `false`. `body-only-if` makes it clear that only the body content will be rendered (not the surrounding tag) if the condition evaluates to `true`.

Since `body-only-if` will rarely be used, I'm inclined to keep its usage as-is. What do you think?
 I didn't know about `body-only-if` until I saw this issue, but after learning about it I would recommend keeping `body-only-if`. For me, the intention is to only render the body (and less about only rendering the tag). Kind of confusing but I think it works :)
 @pedramphp, I agree with you that `body-only-if` feels a little backwards, but I am not seeing a better name. Thank you for the suggestion, but let's stick with `body-only-if` unless you have another idea on how this functionality could be provided in a less confusing way. 
  Syntax highlighting for Marko templates in Sublime would be great. Personally, I switched to from Sublime to Atom and am happier with Atom. I don't remember the exact method for creating a new language file for Sublime, but here is the grammar file that I created for Atom:
https://github.com/raptorjs/atom-language-marko/blob/master/grammars/marko.cson

I'm sure it is possible to write a tool that converts the Atom grammar into a Sublime grammar, but it is not something that I have time to do right now. I think it would be great if someone from the community could contribute Sublime support.
 That's awesome, @merwan7... thank you for the contribution! Do you mind submitting a PR to marko to add `sublime-marko` to the [Tools](https://github.com/marko-js/marko#tools) section in the marko `README.md` file?

Out of curiosity, how did you go about converting the Atom grammar file to work for Sublime? Was there an existing tool that you used? 

Thanks again!
 Just closing old issues... Syntax highlighting in Sublime now works for Marko thanks to the PR submitted by @merwan7 that was merged: https://github.com/wbond/package_control_channel/pull/4652
  I have no objections to adding support for `*.marko.html` except that most editors only let you set file associates based on the last part. Therefore, you would likely lose the ability to have custom syntax highlighting for Marko template files and instead have to settle for HTML syntax highlighting, which is not too terrible I suppose.

Please see my comment I added to your Pull Request and please make sure the tests pass by running `npm test`. 

Thanks for sending the PR.
 New version published: `marko@1.4.0`
 Thanks for the PR, @bkniffler. Updated code looks good.
  Yes, you are correct. Sorry for the missing docs. I don't mind adding the missing docs, but Pull Requests are always welcome.
  Example:

``` html
<some-component c-input="{ message: 'Hello World' }"/>
```

_src/components/some-component/renderer.js:_

``` javascript
module.exports = function render(input, out) {
   var message = input.message; // 'Hello World'
}
```

"template-data" is similar, but it only works for includes. Only one should be documented for consistency.
 FYI, in Marko v3 we are moving to the following syntax:

``` xml
<some-component({message: 'Hello World' })/>
<some-component(data.someObject)/>
```

Will keep issue open because we still need to update the docs.
  Custom tags are resolved to a "renderer" module at compile-time so it is not possible to support something like `<app-test-${path} ...>`. However, a custom tag is mapped directly to a renderer and you can invoke the renderer directly to have the HTML be written to the output stream. One option is to create a custom tag that delegates rendering to the appropriate renderer based on some internal logic. Something like the following:

`src/components/app-test/renderer.js`:

``` javascript
var rendererA = require('./variant-A/renderer');
var rendererB = require('./variant-B/renderer');
var rendererC = require('./variant-C/renderer');

module.exports = function render(input, out) {
    if (input.type === 'A') {
        rendererA(input, out);
    } else if (input.type === 'B') {
        rendererB(input, out);
    } else if (input.type === 'C') {
        rendererC(input, out);
    }
}
```

This nice thing about that approach is that to the outside world there is only a single tag, but internally the custom tag renderer can delegate to the appropriate implementation.

Let us know if that works or doesn't work for you.
 ping. 

Can you please let me know if the proposed solution meets your needs so that I can close this issue or keep it open? Thanks.
  Hi @mattfysh, Marko will remove unnecessary whitespace based on some builtin rules, by default. These rules are partially based on the rules that browser's use to normalize whitespace and partially based on the goal of allowing nicely indented markup. These rules are as follows:
- For whitespace before the first child element: `text = text.replace(/^\n\s*/g, '')`
- For whitespace after the last child element: `text = text.replace(/\n\s*$/g, '')`
- For whitespace between child elements: `text = text.replace(/^\n\s*$/g, '')`
- Any contiguous sequence of whitespace characters is collapsed into a single whitespace character

FYI, the whitespace removal happens in the following code:
[marko/compiler/TextNode.js:112](https://github.com/raptorjs/marko/blob/71ffdf3e4cce257fbd0c09d072462e1e04a207bb/compiler/TextNode.js#L112-L124)

It's possible to disable whitespace removal on a per-element basis using a special attribute applied to a parent element. It's also possible to disable all whitespace removal by changing an option for the compiler. Unfortunately the docs are currently lacking for both these options so I'll describe them below for now:

Option 1) Disable whitespace removal using the `c-whitespace` attribute:

``` html
<div c-whitespace="preserve">
    <my-first-tag>
    <my-second-tag>
</div>
```

Option 2) Disable all whitespace removal by changing a compiler option

``` javascript
require('marko/compiler').defaultOptions.preserveWhitespace = true;
```

Also, you can avoid whitespace removal by avoiding the new line character. For example, the following whitespace between the elements will be preserved:

``` html
<my-first-tag> <my-second-tag>
```

I'll work on adding some formal documentation on the whitespace removal rules. Do these options meet your needs or are you looking for a different solution?
 @mattfysh, I added some documentation to clarify how Marko deals with whitespace:
https://github.com/raptorjs/marko#whitespace

Please let me know what you think.

Thanks,
Patrick
 Perhaps we should add a tag that can be used to enable preservation of whitespace.

For example, something like this:

``` xml
<preserve-whitespace>
<my-first-tag>
<my-second-tag>
</preserve-whitespace>
```

Sometimes there isn't a convenient parent tag to add the `c-whitespace="preserve"` attribute
 I agree regarding introducing a `<preserve-whitespace>` tag. I have added Issue #11 to the backlog.
 Marking issue as closed since additional docs were added clarifying the whitespace rules for Marko. If there are still issues please let us know. Thanks.
  From looking at the code it does look like the taglib loading relies on a path to json file. I'll investigate making changes to allow loading a taglib from object in memory.
 Just to elaborate on @philidem comments (and this may be more information than you need), we only want to support declarative registration of custom tags for the following reasons:
1. Tags need to be discovered at compile time (the templates compile differently based on the set of known tags) and the tags need to be available at runtime (which may be on the server or the client) and it would be awkward to have to register custom tags in both places.
2. The `markoc` command line compiler should to be able to compile templates without running any user JS code (that is tags need to be discovered based on a declarative mechanism)
3. There is no single lookup for all tags and custom tags are discovered relative to a template's location on disk. Among other things, this allows installed modules to have their own custom tags that would not pollute the parent application.
4. Templates are compiled such that custom tag renderers are `require`'d and this allows client-side JavaScript module bundlers to automatically include only the tags that are needed by a compiled template module

I can't think of any reason that you would need to programmatically register new tags at runtime, but if you share more details about your use case then maybe I can offer better help.

Thanks for the feedback. Let us know if you have any more questions.
 Also, if you have ideas on how we can improve how tags are registered then please feel free to share, but there is a requirement that it needs to be declarative (for the reasons above).
 I did investigate this and I came to the same conclusion as Patrick. I think it would have technically been possible to support the definition of tags through a code change but this goes in the opposite direction of modularizing tags and the components that use them. The discovery mechanism for finding tags is an important feature of Marko that allows tags/components to be shared without having to require users to manually register tags. For this reason, I would discourage manually registering tags and instead rely on the discovery of tags from `marko-taglib.json` and `marko-tag.json` files. I would also like to know if relying on these files prevents your project from using Marko effectively.
  On the server-side, the templates utilize the NodeJS module loader so that code in the template can leverage `require()` just like any other CommonJS module. In order to allow requiring modules via relative path, the template module itself needs to have a path which is why it is written to disk. Also, the copy that is written to disk is used for the up-to-date check.

I wonder if there is some hackery that we could do to fake module loading of in-memory code and making it think it is at a specific path.

A while ago, for development in NodeJS, I tried to use a technique of strategically removing modules from the cache but this caused a lot of inconsistencies and I eventually decided to just restart the app (I was really hoping to find a solution that clears the cache...). Perhaps you should consider the route of restarting the app when a source file changes?
 The fact that Marko writes the compiled template to disk in order to load them has very little to do with preventing changes to a template from being reflected without a restart. In fact, in the earlier versions the loader did not write the compiled source to disk and instead used Node.js internals to load the compiled module directly from a source String (see https://github.com/raptorjs/marko/blob/v0.2.0-beta/runtime/lib/loader.js#L6-L17). In case you are curious, the reason we switched to loading compiled templates from disk is so that stack traces would be accurate and it also makes debugging much easier for developers (compiled templates can be debugged just like any other loaded JavaScript modules).

What prevents changes to a template from being immediately reflected is the fact that once the template is loaded there are no checks at each render call to verify if the template is up-to-date and there is no file watching service to invalidate loaded templates. Both of these approaches would add overhead and bring in additional dependencies. With Marko, templates are typically loaded once when a parent module is first required and loaded templates only hold a reference to the JavaScript render function and nothing else. The only cache is the Node.js module cache and the templates are typically referenced as part of the closure of another function. To reload a template without a restart you would need to delete the template module from the `require.cache` and you would need to call `load()` again for all of the templates that were modified.

With that said, it's obviously very important for template changes to be reflected immediately. Otherwise, using Marko would be extremely painful. At eBay, we have had a lot of success with using the [browser-refresh](https://github.com/patrick-steele-idem/browser-refresh) module to automatically restart the server whenever files are modified and the browser-refresh module starts a Web Sockets server to tell web browser pages to reload. This works for all types of resources (CSS/Less/Stylus, JavaScript, Marko templates, Dust templates, etc.) and it ensures that the application is always in a good state since we don't have to worry about messing with Node.js internals to hot reload modules. As long as the server restarts quickly (and it should) then this makes development very productive.  Also, with the browser-refresh module you don't have to change how you structure your application at all. When you want to use the browser-refresh module then you simply use the `browser-refresh` CLI to run the Node.js process, otherwise you just use the standard `node` executable. If you want to try out [browser-refresh](https://github.com/patrick-steele-idem/browser-refresh) with a real app that uses Marko, please check out the sample [weather](https://github.com/raptorjs/raptor-samples/tree/master/weather) app.

If you really don't want to rely on server restarts then you could monkey-patch the loader that `marko` uses to add additional hooks to reload modified templates. Perhaps something like the following:

``` javascript
require('marko-hot-reload').enable(require('marko'));
```

Internally, `marko-hot-reload` module could use [chokidar](https://github.com/paulmillr/chokidar) to detect changes to Marko templates and loaded templates would need to have additional code that runs before each render call to see if the loaded template is still up-to-date. I would advise against going that route and to use [browser-refresh](https://github.com/patrick-steele-idem/browser-refresh) instead, but there are definitely options.

If you have any thoughts please let me know.
 We could make it an option to disable writing a compiled template to disk, but writing the compiled template to disk also provides the benefit that the template does not need to be recompiled if the server is restarted which is kind of nice. I agree that the extra noise of additional files is kind of annoying, but it's a tradeoff. Atom will at least grey out files that are .gitignored (with the option to hide the completely). 

Regardless of if a template is written to disk or not, the resulting module still needs to be loaded through the Node.js module loader. Since a compiled template is loaded through the Node.js module loader you would still need to clear the module from the `require.cache` in order for the template to be reloaded (compiled Marko templates rely heavily on the `require` function so they have to go through the Node.js module loader). Please give [browser-refresh](https://github.com/patrick-steele-idem/browser-refresh) a try and let us know if that doesn't work out for you.

If you were interested in making writing a compiled to disk optional then I would consider a pull request since I think that is a harmless feature. Also, I am not opposed to a separate module enabling hot reloading of Marko templates, but I would rather not pollute the core marko module with that functionality. I'm going to go ahead and close this issue unless you still think there needs to be something done.
 I decided to reopen this issue. After giving it some thought I came up with a clean way to enable template reloading without requiring a full server restart. I'm working on the solution now.
 I have completed the work to add support for Marko template hot-reloading. Usage:

``` javascript
require('marko/hot-reload').enable();
require('fs').watch('somedir', function (event, filename) {
    if (/\.marko$/.test(filename)) {
       require('marko/hot-reload').handleFileModified(filename);
    }
});
```

If hot-reloading is enabled (which should only be done in development), the loaded templates are monkey-patched to detect file changes. If a Marko-related file is modified then the appropriate caches are cleared out so that templates are correctly reloaded. 

Marko still depends on an external file watching service to detect file modifications. That is, Marko does _not_ start its own file watching service to detect changes to `*.marko` files. I added `browser-refresh` integration. If `browser-refresh` is used to start your app then it is already starting a file watching service and the `marko` module can be notified by the `browser-refresh` module when a file is modified (via inter-process communication). To enable hot-reloading _and_ `browser-refresh` integration, the following code should be used:

``` javascript
require('marko/browser-refresh').enable();
```

NOTE: If the app was _not_ started using `browser-refresh` then the above code will be a no-op.

For more details, please see: https://github.com/patrick-steele-idem/browser-refresh#controlling-reloading
 I'll try to reproduce and get back to you.

On a related note, I recommend doing the following:

``` javascript
var formulaTemplate = marko.load(require.resolve('./web/marko/formula.marko'))
app.get('/formula', function(req, res) {
  formulaTemplate.render({}, res)
})
```

The `stream()` method will unnecessarily produce an intermediate stream when it is more efficient to write to the existing `res` stream.
 @Solido, I was not able to reproduce even after installing io.js (v1.0.2). What version of express and marko are you using. Do you have a simplified project that I could try? 
 Hi @Solido, I'll try to answer your question below, but I recommend joining the Marko Gitter chat room for more realtime help: https://gitter.im/raptorjs/marko

Gitter provides great desktop and mobile apps. Definitely recommend checking it out.

<hr>

With Marko you must explicitly pass along any required data to the other templates. Each template gets its own `data` variable.

You didn't share all of your code, but if you are using the `<layout-use>` tag then you can just pass along any data to the target template by doing something similar to the following:

``` html
<use-layout template="path/to/some/layout.marko" some-data="foo">
  <!-- ... -->
</use-layout>
```

The target layout template can then access the data as shown below:

_path/to/some/layout.marko:_

``` html
<div>
  $data.someData
</div>
```

Output:

``` html
<div>foo</div>
```

There's also a feature to support "global" data that is automatically made available to all templates. This feature is supported, but it needs to be documented. The usage is shown below:

``` javascript
var template = require('marko').load('template.marko');
template.render({
    $global: {  // $global is special
      someData: 'foo'
    }
  }
```

You can then access that data in any of your templates using `out.global`:

``` html
<div>
  $out.global.someData
</div>
```
  Great. Thank you for the corrections.
